["```\nmovd xmm3, [dpy]\nmovlhps xmm3, xmm3\nmovsldup xmm3, xmm3\n```", "```\nmacro load_4 xmmreg, addr\n{\n   movd xmmreg, [addr]\n   movlhps xmmreg, xmmreg\n   movsldup xmmreg, xmmreg\n}\n```", "```\nload_4 xmm3, dpy\nload_4 xmm4, pi_2\n```", "```\nload_4 xmm3, dpy\n```", "```\nmovd xmm3, [dpy]\nmovlhps xmm3, xmm3\nmovsldup xmm3, xmm3\n```", "```\nmacro prolog frameSize\n{\n   push ebp\n   mov  ebp, esp\n   sub  esp, frameSize\n}\n```", "```\nmy_proc:\n   prolog 8\n   *; body of the procedure*\n   mov esp, ebp\n   pop ebp\n   ret\n```", "```\nmy_proc:\n   push ebp\n   mov  ebp, esp\n   sub  esp, 8\n   *; body of the procedure*\n   mov  esp, ebp\n   pop  ebp\n   ret\n```", "```\nmacro return\n{\n   mov   ebp, esp\n   pop   ebp\n   ret\n}\n```", "```\nmy_proc:\n   prolog 8\n   *; body of the procedure*\n   return\n```", "```\nmacro printf fmt, [args]\n```", "```\nmacro prolog frameSize, [regs]\n{\n   common\n   push  ebp\n   mov   ebp, esp\n   sub   esp, frameSize\n   forward\n   push regs\n}\n```", "```\nmy_proc:\n   prolog 8, ebx, ecx, edx\n   *; body of the procedure*\n```", "```\nmy_proc:\n   push ebp\n   mov  ebp, esp\n   sub  esp, 8\n   push ebx\n   push ecx\n   push edx\n```", "```\nmacro return [regs]\n{\n   reverse\n   pop  regs\n   common\n   mov  esp, ebp\n   pop  ebp\n   ret\n}\n```", "```\nmy_proc:\n   prolog 8, ebx, ecx, edx\n   *; body of the function*\n   return ebx, ecx, edx\n```", "```\nmacro ccall procName, [args]\n{\n   common\n   a = 0\n   if ~args eq\n      forward\n      a = a + 4\n      reverse \n      push args\n   end if\n   common\n   call procName\n   if a > 0\n      add  esp, a\n   end if\n}\n```", "```\nmacro stdcall procName, [args]\n{\n   if ~args eq\n      reverse \n      push args\n   end if\n   common\n   call procName\n}\n```", "```\ncdecl_proc:\n   push ebp\n   mov  ebp, esp\n   *; body of the procedure*\n   mov  esp, ebp\n   pop  ebp,\n   ret\n\nstdcall_proc:\n   push ebp\n   mov  ebp, esp\n   *; body of the procedure*\n   mov  esp, ebp\n   pop  ebp\n   ret  8                  *; Increments the stack pointer by 8 bytes after*\n *; return, thus releasing the space occupied* \n *; by procedure parameters*\n\nmain:\n   ccall  cdecl_proc, 128  *; 128 is a numeric parameter passed to* \n *; the procedure*\n   stdcall stdcall_proc, 128, 32\n```", "```\nmain:\n   push 128\n   call cdecl_proc\n   add  esp, 4\n   *;*\n   push 32\n   push 128\n   call stdcall_proc\n```", "```\nmov  eax, [ebp + 8]  *; Would load EAX with 128*\nmov  eax, [ebp + 12] *; Would load EAX with 32*\n```", "```\nmacro ms64_call procName, [args]\n{\n   a = 0\n   if ~args eq\n      forward\n      if a = 0\n         push rcx\n         mov rcx, args\n      else if a = 1\n         push rdx\n         mov rdx, args\n      else if a = 2\n         push r8\n         mov r8, args\n      else if a = 3\n         push r9\n         mov r9, args\n      else\n         display \"This macro only supports up to 4 parameters!\",10,13\n         exit\n      end if\n      a = a + 1\n      end if\n   common\n   sub rsp, 32            *; Allocate shadow space*\n   call procName          *; Call procedure*\n   add rsp, 32            *; Free shadow space*\n   forward\n   if ~args eq\n      if a = 4\n         pop r9\n      else if a = 3\n         pop r8\n      else if a = 2\n         pop rdx\n      else if a = 1\n         pop rcx\n      end if\n      a = a - 1\n   end if\n}\n```", "```\nms64_call my_proc, 128, 32\n```", "```\npush rcx         *;Save RCX register on stack*\nmov  rcx, 128    *;Load it with the first parameter*\npush rdx         *;Save RDX register on stack*\nmov  rdx, 32     *;Load it with the second parameter*\nsub  rsp, 32     *;Create 32 bytes shadow space*\ncall my_proc     *;Call the my_proc procedure*\nadd  rsp, 32     *;Destroy shadow space*\npop  rdx         *;Restore RDX register*\npop  rcx         *;Restore RCX register*\n```", "```\nmacro amd64_call procName, [args]\n{\n   a = 0\n   if ~args eq\n      forward\n      if a = 0\n         push rdi\n         mov rdi, args\n      else if a = 1\n         push rsi\n         mov rsi, args\n      else if a = 2\n         push rdx\n         mov rdx, args\n      else if a = 3\n         push rcx\n         mov rcx, args\n      else if a = 4\n         push r8\n         mov r8, args\n      else if a = 5\n         push r9\n         mov r9, args\n      else\n         display \"This macro only supports up to 4 parameters\", 10, 13\n         exit\n      end if\n      a = a + 1\n   end if\n   common\n   call procName\n   forward\n   if ~args eq\n      if a = 6\n         pop r9\n      else if a = 5\n         pop r8\n      else if a = 4\n         pop rcx\n      else if a = 3\n         pop rdx\n      else if a = 2\n         pop rsi\n      else if a = 1\n         pop rdi\n      end if\n      a = a - 1\n   end if\n} \n```", "```\namd64_call my_proc, 128, 32\n```", "```\npush rdi       *;Store RDI register on stack*\nmov  rdi, 128  *;Load it with the first parameter*\npush rsi       *;Store RSI register on stack*\nmov  rsi, 32   *;Load it with the second parameter*\ncall my_proc   *;Call the my_proc procedure*\npop  rsi       *;Restore RSI register*\npop  rdi       *;Restore RDI register*\n```", "```\nmy_string  db 'This string will be encrypted',0x0d, 0x0a, 0x00\nmy_string_len = $ - my_string\n```", "```\nrepeat my_string_len\n   load b byte from my_string + % - 1\n   store byte b xor 0x5a at my_string + % - 1\nend repeat\n```", "```\nMSHOW_MESSAGE MACRO title, message ;macro_name MACRO parameters\n   push message\n   push title\n   call show_message\nENDM\n```", "```\nMSHOW_MESSAGE offset ti, offset msg\n```", "```\n.macro print message       *; .macro macro_name parameter*\n   pushl \\message          *; Put the parameter on stack*\n                           *; parameters are prefixed with '\\'*\n   call  printf            *; Call printf() library function*\n   add   $4, %esp          *; Restore stack after cdecl function call*\n.endm\n\noutput_message:\n   pushl %ebp\n   movl  %esp, %ebp\n   print 8(%ebp)           *; This line would expand to the above macro*\n   movl  $0, %eax\n   leave\n   ret   $4\n```", "```\nmacro exordd p1, p2\n{\n   if ~p1 in <eax, ebx, ecx, edx, esi, edi, ebp, esp> &\\\n      ~p2 in <eax, ebx, ecx, edx, esi, edi, ebp, esp>\n      push eax\n      mov  eax, [p2]\n      xor [p1], eax\n      pop  eax\n   else\n      if ~p1 in <eax, ebx, ecx, edx, esi, edi, ebp, esp>\n         xor [p1], p2\n      else if ~p2 in <eax, ebx, ecx, edx, esi, edi, ebp, esp>\n         xor p1, [p2]\n      else\n         xor p1, p2\n      end if\n   end if\n}\n```", "```\nexordd my_var1, my_var2   *; a = a xor b*\nmov    ebx, [my_var2]\nexordd ebx, my_var1       *; b = b xor a*\nmov    [my_var2], ebx\nexordd my_var1, ebx       *; a = a xor b* \nexordd ebx, ebx           *; Reset EBX register for extra fun*\n```", "```\npush eax                 *; exordd my_var1, my_var2*\nmov  eax, [my_var2]\nxor  [my_var1], eax\npop  eax\nmov  ebx, [my_var2]\nxor  ebx, [my_var1]      *; exordd ebx, my_var1*\nmov  [my_var2], ebx\nxor  [my_var1], ebx      *; exordd [my_var1], ebx*\nxor  ebx, ebx            *; exordd ebx, ebx*\n```", "```\nhex_chars:\nrept 10 cnt {db '0' + cnt - 1}\nrept 6  cnt {db 'A' + cnt - 1}\n```", "```\nhex_chars db \"0123456789ABCDEF\"\n```", "```\nirp reg, eax, ebx, ecx {inc reg}\n```"]