- en: Combatting Tunneling and Encryption
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last few chapters, we saw how we can capture network packets and gain
    deep insights into them using various tools and techniques. However, what if the
    data traveling across the network using a DNS query is not carrying a DNS payload?
    Alternatively, what if the data makes no sense from the packets under observation?
    To answer these questions, we will have a look at various stepping stones in our
    journey of effectively conducting network forensics. The data is sometimes encrypted
    using TLS, SSL, custom encryption mechanisms, or WEP/ WPA2 in the wireless space.
    In this chapter, we will look at combating these hurdles and obtaining meaningful
    data behind the closed doors of encryption.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will look at the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Decrypting TLS using browsers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decoding a malicious DNS tunnel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decrypting 802.11 packets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decoding keyboard captures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is the final chapter before we make a move into the hands-on network forensic
    exercises, where we will make use of strategies learned in the first five chapters
    to decode, decrypt, and solve the exercises in the last five chapters. So, let's
    get started.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To complete exercises in this chapter, we will require the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Kali Linux ([https://www.kali.org/downloads/](https://www.kali.org/downloads/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wireshark v2.6.6 ([https://www.wireshark.org/download.html](https://www.wireshark.org/download.html))
    installed on Windows 10 OS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Aircrack-ng Suite (already present in Kali Linux)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scapy Python library (already a part of Kali Linux and can be installed by using
    `pip install scapy` command)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can download the codes and PCAP files used in this chapter from [https://github.com/nipunjaswal/networkforensics/tree/master/Ch5](https://github.com/nipunjaswal/networkforensics/tree/master/Ch5)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decrypting TLS using browsers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the hidden features of the popular Chrome browser is the support of
    logging the symmetric session key used while encrypting the traffic with TLS to
    a file of our choice. Let''s see what happens when we try to capture a TLS-encrypted
    packet:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f245a84f-6ec2-4b04-a69b-a6c3a7d9b1e4.png)'
  prefs: []
  type: TYPE_IMG
- en: We can see that the network traffic is encrypted using TLS and that the data
    in the bottom pane is not making much sense to us. Fortunately, browsers such
    as Chrome support storing the TLS key, which can help us decrypt the data that
    otherwise is not making sense. To set up logging, we need to export a user environment
    variable by browsing the Control Panel and opening system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to choose **Advanced system settings**. In the next step, we
    will choose the **Environment Variables...** option. In the **User variable**
    section, we will add the `SSLKEYLOGFILE` variable by clicking **New** and then
    set its value as any file of our choice:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dc2158e7-958b-4734-8b5f-22a0beafa600.png)'
  prefs: []
  type: TYPE_IMG
- en: Make sure you create an empty file with the name used in the variable value;
    in our case, it's `ssl.log`. Since we now have the setup ready, we can let the
    user browse the network. The preceding logging option will be helpful in cases
    of suspicion on a particular user can be confirmed by decrypting his TLS traffic
    and monitoring their activities.
  prefs: []
  type: TYPE_NORMAL
- en: On a Linux system, the environment variable can be exported using export `SSLKEYLOGFILE=PATH_OF_FILE`
    command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Network packets can be captured at the hub or mirror port, but to decrypt the
    TLS sessions, the log file will be required. Once this file is set up correctly,
    the administrators and network forensic experts have enough to decrypt the TLS
    sessions on a different system. Let''s see what kind of data is generated in the
    log file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d70f1eeb-b9e3-4f9b-9b31-80cedcd0e0f5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can see that the file contains session keys. Let''s set up SSL/TLS decryption
    in Wireshark by navigating to **Edit** and choosing **Preferences**. Then scroll
    down to **SSL** / **TLS** (Wireshark version 3.0) from the **Protocols** section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d65b0fea-6898-4eab-9db2-baaf29273173.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s set the path of the log file in the **(Pre)-Master-Secret log filename**
    field and press **OK**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1ad0c2e1-3c33-4e37-97d2-c45c3bf3ad7c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We will now have the TLS sessions decrypted:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b303a773-3cef-48ab-9cd0-c7c4b545960b.png)'
  prefs: []
  type: TYPE_IMG
- en: We can see most of the TLS traffic data in plain HTTP format. It is quite obvious
    that I will not be giving out this PCAP and associated log file, for security
    and privacy concerns. To perform the preceding exercise, you need to set up your
    environment variable with the path to the log file and browse some TLS-enabled
    websites. You will have the log file with various session keys; use it to decrypt
    your TLS-enabled data.
  prefs: []
  type: TYPE_NORMAL
- en: SSL has been replaced by TLS in version 3.0.0 of Wireshark.
  prefs: []
  type: TYPE_NORMAL
- en: Decoding a malicious DNS tunnel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While preparing the content for this book, I stumbled upon a few of the excellent
    **Capture the Flag** (**CTF**) challenges, which demonstrate mind-boggling exercises.
    One of them is the one we are going to discuss next. We covered an exercise on
    the ICMP shell in the previous chapters, and ICMP tunneling works on the same
    principle, which is to pass TCP-related data through a series of ICMP requests.
    Similarly, DNS and SSH tunneling also work; they encapsulate normal TCP traffic
    within them and pass the common security practices. DNS and SSH tunneling are
    fairly popular for bypassing captive portal restrictions on airports, cafes, and
    so on. However, certain malware also makes use of DNS to perform command and control
    of the compromised machines. Let's see an example that demonstrates strange DNS
    requests and look at what can we do with them. The PCAP example is taken from
    HolidayHack 2015, and you can download the sample PCAP from [https://github.com/ctfhacker/ctf-writeups/blob/master/holidayhack-2015/part1/gnome.pcap](https://github.com/ctfhacker/ctf-writeups/blob/master/holidayhack-2015/part1/gnome.pcap) thanks
    to Cory Duplantis, also known as **ctfhacker**.
  prefs: []
  type: TYPE_NORMAL
- en: We will soon be requiring Kali Linux for this exercise and the version of Wireshark
    is 2.6.6 so download the PCAP to both Windows as well as Kali Linux machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s open up `gnome.pcap` in Wireshark:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/81a95332-c5aa-4bf4-a5f0-e17b630b6821.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can see that we have a mix of Wireless 802.11 packets and DNS query responses
    in the PCAP file, which is quite strange, as there are no query requests, only
    query responses. Let''s investigate the DNS packets a little further:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dfc2ae6c-f161-4012-9d7f-28e04e634c7f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can see that on filtering the DNS packets, we have many packets with a transaction
    ID of `0x1337` and with base64-like data incubated in them. Let''s try to extract
    this data using `tshark`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/27c0bb76-d0bd-49eb-84f4-fb3396d8fae5.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding `tshark` command reads from GNOME. The PCAP file uses the `-r`
    switch and we have set a filter on the DNS transaction ID under observation using
    the `dns.id==0x1337` filter by using the `-R` switch.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, we chose only to print the DNS response length for all the packets
    by using the `-T` fields followed by `-e` to denote the field, and `dns.resp.len`
    to print the response lengths. However, we are more interested in harvesting the
    TXT record itself that looked like base64, and frankly, using the `dns.txt` instead
    of `dns.resp.len` does not help. Therefore, we need a mechanism to extract these
    entries.
  prefs: []
  type: TYPE_NORMAL
- en: Using Scapy to extract packet data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Scapy** is a packet manipulation tool for networks, written in Python. It
    can forge or decode packets, send them on the wire, capture them, and match requests
    and replies. We can use `scapy` to extract the TXT records as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'By merely using 15 lines of code in Python, we can extract the data we want.
    The first two lines are header imports, which will give the python script the
    functionality from base64 and `scapy`. Next, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code segment, we are reading a PCAP file, `gnome.pcap`, from
    the current working directory and also declaring a list named `decoded_commands`
    and a string variable named `decoded_data`. Next, we have the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The `for` loop will traverse the packets one after the other, and if the packet
    is of the DNS type, it will check whether the packet ID matches `0x1337`. If it
    does, it pulls the TXT record data using `packet[DNS].an.rdata`, converts it into
    a string, and decodes it from base64 to normal text and in case the decoded data
    contains `FILE:` the execution should continue else the `decoded_data` is appended
    to `decoded_command`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding section appends the decoded data into the `decoded_command` list
    and loops over the list while printing all the elements of the list whose length
    is greater than 1 (to avoid empty lines). Running the script gives us the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c5387d5b-11cd-4045-9ba4-09143399ad65.png)'
  prefs: []
  type: TYPE_IMG
- en: Well, this looks like output from the `iwlist` scan command. The output of a
    system command is not something to be expected in the DNS responses. This denotes
    that the system under observation was compromised and the attacker used DNS for
    command and control.
  prefs: []
  type: TYPE_NORMAL
- en: Decrypting 802.11 packets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes, as a forensics investigator, you will receive PCAP files that contain
    WLAN packets, and to make sense out of them, you need the key. Obtaining the key
    should not be difficult in forensic scenarios where you have the authority, but
    as a forensic investigator, you must be prepared for all possible situations.
    In the next scenario, we have a PCAP file from [https://github.com/ctfs/write-ups-2015/raw/master/codegate-ctf-2015/programming/good-crypto/file.xz](https://github.com/ctfs/write-ups-2015/raw/master/codegate-ctf-2015/programming/good-crypto/file.xz),
    and as soon as we open it up in Wireshark, we have 802.11 packets right in front
    of us:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7dcd3eca-7674-425d-ac3f-cc6ad06be609.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We cannot figure out what activities were performed in the network unless we
    remove the 802.11 encapsulation. However, let''s see what sort of statistics are
    available in Wireshark by navigating to the **Wireless** tab and choosing WLAN
    traffic:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fe33f41d-4344-4f1c-8f82-19c9c7415cce.png)'
  prefs: []
  type: TYPE_IMG
- en: We can see that we have 100% packets in the Wireless segment and the **SSID**
    (name of the network) as **cgnetwork** running on channel number **1** and having
    multiple clients connected to it. To see the activities, we need to remove the
    802.11 encapsulation, which can be done by providing the network key that we do
    not have. So, what do we do? Let's try to find the key using the **Aircrack-ng**
    suite, which is a popular wireless network-cracking tool (already available in
    Kali Linux).
  prefs: []
  type: TYPE_NORMAL
- en: Decrypting using Aircrack-ng
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s use Aircrack-ng to find the network key. We will type `aircrack-ng`
    followed by the PCAP file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/736ca413-b17e-4c9f-aca7-1215c8fe239f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can see that we got the WEP key with ease. We can use this key to decrypt
    packets in Wireshark:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1a34e6ce-9004-4590-b2ed-128f8fb240e8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We will navigate to **Edit...** and choose **Preferences**. Once the dialog
    box is open, we will choose protocols and scroll down to **IEEE 802.11**, as shown
    in the preceding screenshot. Next, we will select the **Decryption Keys** option
    and choose **Edit**, which will populate a separate dialog box, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e951dba8-edf0-4696-96a3-f049e2a252da.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We will click the **+** sign, add the key we found using Aircrack-ng, and press
    **OK**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/34c4c113-6823-467d-8714-90ba0b66ec38.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Wow! We can see that we successfully removed the Wireless encapsulation. Alternatively,
    we could have used `airdecap` from the `aircrack` suite to remove the encapsulation.
    We just saw how we could work with Wireless protocols and remove encapsulation
    by cracking the WEP keys. However, this may not apply to WPA and WPA2 standards.
    Let''s see an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f28a8e3f-2038-4e50-8ef7-476bb508a7d2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We supplied a plaintext password for WPA2, and the PCAP was successfully decrypted:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a70f969f-ea19-45dc-932a-b97c842e29ab.png)'
  prefs: []
  type: TYPE_IMG
- en: 'However, the password-cracking process is not as standardized as it was in
    the case of WEP. Let''s see what happens when we try to crack PCAP in the `aircrack-ng`
    suite:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/88f8d855-8392-413e-b588-8f0f76e548a7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can see that the `aircrack-ng` suite asked us to specify a dictionary file
    that might contain a password, which means that the only way to obtain the key,
    in this case, is via brute force. Let''s see how we can supply a dictionary file
    that contains a password list:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/17ea5108-be31-4b83-9ee2-7cadc73dfb3c.png)'
  prefs: []
  type: TYPE_IMG
- en: Dictionary files are available in Kali by default under `/usr/share/dict/words`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see that we have supplied an example dictionary file using the `-w`
    switch, and now Aircrack-ng is trying to crack the passwords. So, at some point,
    we will get the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6992ce29-23f3-47b8-b852-eac72bc74189.png)'
  prefs: []
  type: TYPE_IMG
- en: Yeah! We got the key. We already saw how we could apply this key in Wireshark
    and analyze it further. We will be discussing the 802.11 standards in the upcoming
    chapters, as we have one complete chapter dedicated to it.
  prefs: []
  type: TYPE_NORMAL
- en: Decoding keyboard captures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another day and another interesting PCAP capture. Have you ever thought that
    USB keyboards could also reveal a lot of activity and user behavior? We will look
    at such scenarios in the upcoming chapters, but for now, let''s prepare for it.
    I found an interesting packet-capture file from [https://github.com/dbaser/CTF-Write-ups/blob/master/picoCTF-2017/for80-just_keyp_trying/data.pcap](https://github.com/dbaser/CTF-Write-ups/blob/master/picoCTF-2017/for80-just_keyp_trying/data.pcap).
    However, on downloading the PCAP file and loading it in Wireshark, I got the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/379a4d11-dc6b-4f35-a821-ff17ff3be129.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Well, I have not seen anything like this, but we know that this is USB data.
    We can also see that the leftover column contains some bytes. This is the data
    of interest; let''s use `tshark` to harvest this data by running the `tshark –r
    [path to the file]` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6e741e80-4f3f-4205-8542-8bdccccc2348.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s only print the leftover data, using the `usb.capdata` field:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3a5ab07d-c5ff-46fb-b61c-90f4973ea6f6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can see that we have only one or two bytes per line, so in order to decode
    the USB keystrokes, we will require only bytes without zeros and separators. Let''s
    remove the null and separators from the lines by running the `tshark -r Desktop/data.pcap
    -T fields -e usb.capdata | sed -e ''s/00//g'' -e ''s/://g'' -e ''s/20//g'' | grep
    .` command as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/58190a92-21d5-4d25-9705-fff62d24bf7e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When we remove the zeros and separators, we are left with the preceding data. The
    bytes from the preceding screenshot can be interpreted as keystrokes and can be
    mapped to the keys listed in page 53 from [https://www.usb.org/sites/default/files/documents/hut1_12v2.pdf](https://www.usb.org/sites/default/files/documents/hut1_12v2.pdf).
    According to the documentation, **09** maps to **f**, **0F** maps to **l**, **04**
    maps to **a**, and **0a** to **g**, which means the first four typed-in characters
    are **flag**. Similarly, a parser for these bytes could allow us to view everything
    that a user typed from the PCAP capture itself. Let''s also use a small Python-based
    script that makes use of Scapy to parse the entire PCAP itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c98d4fe8-25a7-4255-9ec7-884d2f289701.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding script can be obtained from [https://github.com/dbaser/CTF-Write-ups/blob/master/picoCTF-2017/for80-just_keyp_trying/usbkeymap2.py](https://github.com/dbaser/CTF-Write-ups/blob/master/picoCTF-2017/for80-just_keyp_trying/usbkeymap2.py)
    and is very similar to what we have done for the DNS queries.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned a lot. We started by making use of client-side SSL
    log files to decrypt SSL/TLS sessions. Then we looked at DNS malicious query responses
    that carry command and control data. We explored WEP and WPA2 decryption by decrypting
    the password through the Aircrack-ng suite and made use of decryption keys in
    Wireshark. We also went through a small snippet of code in Python to segregate
    and decode data. Finally, we looked at the USB keyboard capture file and decrypted
    the keystrokes pressed by the user at the time it was recorded in the PCAP file.
    This is the end of our preparation phase, and we will now jump into the hands-on
    side of things. We will be making use of the lessons and techniques learned in
    the first five chapters, and based on the knowledge we gained; we will try to
    solve the challenges in the upcoming chapters.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at live malware samples, and we will perform
    network forensics over them. We will develop strategies to unfold the root cause
    of the malware deployment, and find vital details, such as the first point of
    entry in the network.
  prefs: []
  type: TYPE_NORMAL
- en: Questions and exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To gain the best out of this chapter, attempt the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Do any other browsers exhibit similar behavior to chrome in storing SSL key
    logs? Find it out
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can you decrypt the wireless capture file? If yes find out the password for
    challenge file `wireless_decryption_challenge.pcap` hosted here [https://github.com/nipunjaswal/networkforensics/tree/master/Challenges](https://github.com/nipunjaswal/networkforensics/tree/master/Challenges)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Try attaching a keyboard to your laptop/ desktop and capture the USB data and
    decode the keys
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Check out the **Nailing the CTF challenge**: [https://subscription.packtpub.com/book/networking_and_servers/9781784393335/3/ch03lvl1sec26/nailing-the-ctf-challenge](https://subscription.packtpub.com/book/networking_and_servers/9781784393335/3/ch03lvl1sec26/nailing-the-ctf-challenge)
    for more information on the topics covered in this chapter.
  prefs: []
  type: TYPE_NORMAL
