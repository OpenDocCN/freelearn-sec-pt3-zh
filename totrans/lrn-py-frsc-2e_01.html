<html><head></head><body>
        

                            
                    <h1 class="header-title">Now for Something Completely Different</h1>
                
            
            
                
<p>This book presents Python as a necessary tool to optimize digital forensic analysis—written from an examiner's perspective. In the first two chapters, we introduce the basics of Python in preparation for the remainder of this book, where we will develop scripts to accomplish forensic tasks. While focused on the use of the language as a tool, we will also explore the advantages of Python and how they allow many individuals in the field to create solutions for complex forensic challenges. Like Monty Python, Python's namesake, the next 12 chapters aim to present <em>something completely different</em>.</p>
<p>In this fast-paced field, a scripting language provides flexible problem solving in an automated fashion, allowing the examiner additional time to investigate other artifacts that, due to time constraints, may not have been analyzed as thoroughly otherwise. Admittedly, Python may not always be the right tool to complete the task at hand, but it is an invaluable tool to add to anyone's DFIR arsenal. Should you undertake the task of mastering Python, it will more than pay off the time investment as you will increase your analysis capabilities many fold and greatly diversify your skill set. This chapter outlines the basics of Python, from <kbd>Hello World</kbd> to core scripting concepts.</p>
<p>This chapter will cover the following topics:</p>
<ul>
<li>An introduction to Python and healthy development practices</li>
<li>Basic programming concepts</li>
<li>Manipulating and storing objects in Python</li>
<li>Creating simple conditionals, loops, and functions</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">When to use Python</h1>
                
            
            
                
<p>Python is a powerful forensic tool. However, before deciding to develop a script, it is important to consider the type of analysis that's required and the project timeline. In the examples that follow, we will outline situations where Python is invaluable and, conversely, when it is not worth the development effort. Though rapid development makes it easy to deploy a solution in a tough situation, Python is not always the best tool to implement. If a tool exists that performs the task at hand, and is available, it may be the more appropriate method for analysis.</p>
<p>Python is a preferred programming language for forensics due to its ease of use, library support, detailed documentation, and interoperability among operating systems. There are two main types of programming languages: those that are interpreted and those that are compiled. Compiling code allows the programming language to be converted into machine language. This lower-level language is more efficient for the computer to interpret. Interpreted languages are not as fast as compiled languages at runtime, but do not require compilation, which can take some time. Because Python is an interpreted language, we can make modifications to our code and immediately run and view the results. With a compiled language, we would have to wait for our code to re-compile before viewing the effect of our modifications. For this reason, Python may not run as quickly as a compiled language, but allows for rapid prototyping.</p>
<p>An incident response case presents an excellent example of when to use Python in a real-life setting. For example, let's consider that a client calls, panicked, reporting a data breach and is unsure of how many files were exfiltrated over the past 24 hours from their file server. Once on site, you are instructed to perform the fastest count of files accessed in the past 24 hours as this count, and the list of compromised files, will determine the course of action.</p>
<p>Python fits this bill quite nicely here. Armed with just a laptop, you can open a text editor and begin writing a solution. Python can be built and designed without the need for a fancy editor or toolset. The build process of your script may look like this, with each step building upon the previous one:</p>
<ol>
<li> Make the script read a single file's last accessed timestamp</li>
<li>Write a loop that steps through directories and subdirectories</li>
<li> Test each file to see if that timestamp is from the past 24 hours</li>
<li> If it has been accessed within 24 hours, then create a list of affected files to display file paths and access times</li>
</ol>
<p>The process here would result in a script that recurses over the entire server and output files found with a last accessed time in the past 24 hours for manual review. This script will likely be approximately 20 lines of code and have required 10 minutes, or less, for an intermediate scripter to develop and validate—it is apparent this would be more efficient than manually reviewing timestamps on the filesystem.</p>
<p>Before deploying any developed code, it is imperative that you validate its capability first. As Python is not a compiled language, we can easily run the script after adding new lines of code to ensure we haven't broken anything. This approach is known as <strong>test-then-code</strong>, a method commonly used in script development. Any software, regardless of who wrote it, should be scrutinized and evaluated to ensure accuracy and precision. Validation ensures that the code is operating properly, and although more time-consuming, provides reliable results that are capable of withstanding the courtroom, an important aspect in forensics.</p>
<p>A situation where Python may not be the best tool is for general case analysis. If you are handed a hard drive and asked to find evidence without additional insight, then a pre-existing tool will be the better solution. Python is invaluable for targeted solutions, such as analyzing a given file type and creating a metadata report. Developing a custom all-in-one solution for a given filesystem requires too much time to create when other tools, both paid and free, exist that support such generic analysis.</p>
<p>Python is useful in pre-processing automation. If you find yourself repeating the same tasks for each piece of evidence, it may be worthwhile to develop a system that automates those steps. A great example of suites that perform such analysis is ManTech's analysis and triage system (mantaray: <a href="http://github.com/mantarayforensics">http://github.com/mantarayforensics</a>), which leverages a series of tools to create general reports that can speed up analysis when there is no scope of what data may exist.</p>
<p>When considering whether to commit resources to develop Python scripts, either on the fly or for larger projects, it is important to consider what solutions already exist, the time available to create a solution, and the time saved through automation. Despite best intentions, the development of solutions can go on for much longer than initially conceived without a strong design plan.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Development life cycle</h1>
                
            
            
                
<p>The development cycle involves at least five steps:</p>
<ul>
<li>Identify</li>
<li>Plan</li>
<li>Program</li>
<li>Validate</li>
<li>Bugs</li>
</ul>
<p>The first step is self-explanatory; before you develop, you must identify the problem that needs to be solved. Planning is perhaps the most crucial step in the development cycle:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-464 image-border" src="img/289dd91f-6deb-4ef5-bb00-85fa1c63de51.png" style="width:12.17em;height:17.25em;"/></p>
<p>Good planning will help later by decreasing the amount of code required and the number of bugs. Planning becomes even more vital during the learning process. A forensic programmer must begin to answer the following questions: how will data be ingested, what Python data types are most appropriate, are third-party libraries necessary, and how will the results be displayed to the examiner? In the beginning, just as if we were writing a term paper, it is a good idea to write, or draw, an outline of your program. As you become more proficient in Python, planning will become second nature, but initially, it is recommended to create an outline or write pseudocode.</p>
<p>Pseudocode is an informal way of writing code before filling in the details with actual code. Pseudocode can represent the bare bones of the program, such as defining pertinent variables and functions while describing how they will all fit together within the script's framework. Pseudocode for a function might look like this:</p>
<pre># open the database<br/>  # read from the database using the sqlite3 library<br/>  # store in variable called records<br/>  for record in records: <br/>    # process database records here</pre>
<p>After identifying and planning, the next three steps make up the largest part of the development cycle. Once your program has been sufficiently planned, it is time to start writing code! Once the code is written, break in your new program with as much test data as possible. Especially in forensics, it is critical to thoroughly test your code instead of relying on the results of one example. Without comprehensive debugging, the code can crash when it encounters something unexpected, or, even worse, it could provide the examiner with false information and lead them down the wrong path. After the code has been tested, it is time to release it and prepare for bug reports. We are not talking about insects here! Despite a programmer's best efforts, there will always be bugs in the code. Bugs have a nasty way of multiplying even as you squash one, perpetually causing the programming cycle to begin repeatedly.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting started</h1>
                
            
            
                
<p>Before we get started, it is necessary that you install Python on your machine. It is important to understand that, at the time of writing this book, there are two supported versions of Python: Python 2 and 3. We will use both Python 2 and 3 to develop our solutions. Historically, many of the useful third-party forensic libraries were developed for Python 2. At this point, most libraries are compatible with Python 3, which has superior Unicode handling, a major headache in Python 2, among a number of other improvements. All of the code in this book has been tested with the latest appropriate versions of Python 2 (v. 2.7.15) or 3 (v. 3.7.1). In some cases, our code is compatible with both Python 2 and 3, or only works with one of the two. Each chapter will describe what version of Python is required to run the code.</p>
<p>Additionally, we recommend using an <strong>integrated development environment</strong>, or <strong>IDE</strong>, such as JetBrain's PyCharm. An IDE will highlight errors and offer suggestions that help streamline the development process and promote best practices when writing code. In the case that the installation of an IDE is not available, a simple text editor will work. We recommend an application such as Notepad++, Sublime Text, or Visual Studio Code. For those who are command line orientated, an editor such as vim or nano will work as well.</p>
<p>With Python installed, let's open the interactive prompt by typing <kbd>python</kbd> into your Command Prompt or Terminal. We will begin by introducing some built-in functions for use in troubleshooting. The first line of defense when confused by any object or function discussed in this book, or found in the wild, is the <kbd>type()</kbd>, <kbd>dir()</kbd>, and <kbd>help()</kbd> built-in functions. We realize we have not yet introduced common data types and so the following code might appear confusing.</p>
<p>However, that is exactly the point of this exercise. During development, you will encounter data types you are unfamiliar with or be unsure what methods exist to interact with the object. These three functions help solve those issues. We will introduce the fundamental data types later in this chapter.</p>
<p>The <kbd>type()</kbd> function, when supplied with an object, will return its <kbd>__name__</kbd> attribute, providing type identifying information about the object. The <kbd>dir()</kbd> function, when supplied with a string representing the name of an object, will return its attributes, showing the available options of the functions and parameters belonging to the object. The <kbd>help()</kbd> function can be used to display the specifics of these methods through its <strong>docstrings</strong>. Docstrings are nothing more than descriptions of a function that detail the inputs, outputs, and how to use the function.</p>
<p>Let's look at the <kbd>str</kbd>, or string, object as an example of these three functions. In the following example, passing a series of characters surrounded by single quotes to the <kbd>type()</kbd> function results in a type of <kbd>str</kbd>, or string.</p>
<p>When we show examples where our typed input follows the <kbd>&gt;&gt;&gt;</kbd> symbol, this indicates that you should type these statements in the Python interactive prompt. The Python interactive prompt can be accessed by typing <kbd>python</kbd> in the Command Prompt.<br/>
<br/>
These basic functions behave similarly in both Python 2 and 3. Unless otherwise stated, these function calls and their output are executed with Python 3.7.1. Please note, however, that the purposes of these built-in functions largely remain the same and have similar outputs between Python versions.</p>
<p>Here is an example:</p>
<pre><strong>&gt;&gt;&gt; type('what am I?')</strong><br/><strong>&lt;class 'str'&gt;</strong> </pre>
<p>If we pass in an object to the <kbd>dir()</kbd> function, such as <kbd>str</kbd>, we can see its methods and attributes. Let's say that we want to know what one of these functions, <kbd>title()</kbd>, does. We can use the <kbd>help()</kbd> function specifying the object and its function as the input.</p>
<p>The output of the function tells us no input is required, the output is a string object, and that the function capitalized the first character of every word. Let's use the <kbd>title</kbd> method on the <kbd>what am I?</kbd> string:</p>
<pre><strong>&gt;&gt;&gt; dir(str) </strong><br/><strong>['__add__', '__class__', '__contains__', '__delattr__',</strong><br/><strong>'__doc__', '__eq__', </strong><br/><strong>...</strong><br/><strong>'swapcase', 'title', 'translate', 'upper', 'zfill']</strong><br/><br/><strong>&gt;&gt;&gt; help(str.title)</strong><br/><strong>Help on method_descriptor:</strong><br/><br/><strong>title(...)</strong><br/><strong>    S.title() -&gt; str</strong><br/><br/><strong>    Return a titlecased version of S, i.e. words start with title case characters, all remaining cased characters have lower case.</strong><br/><br/><strong>&gt;&gt;&gt; 'what am I?'.title()</strong><br/><strong>'What Am I?'</strong> </pre>
<p>Next, type <kbd>number = 5</kbd>. Now we have created a variable, called <kbd>number</kbd>, that has the numerical value of <kbd>5</kbd>. Using <kbd>type()</kbd> on that object indicates that <kbd>5</kbd> is an <kbd>int</kbd>, or integer. Going through the same procedure as before, we can see a series of available attributes and functions for the integer object. With the <kbd>help()</kbd> function, we can check what the <kbd>__add__()</kbd> function does for our <kbd>number</kbd> object. From the following output, we can see that this function is equivalent to using the <kbd>+</kbd> symbol on two values:</p>
<pre><strong>&gt;&gt;&gt; number = 5</strong><br/><strong>&gt;&gt;&gt; type(number)</strong><br/><strong>&lt;class 'int'&gt;</strong><br/><br/><strong>&gt;&gt;&gt; dir(number)</strong><br/><strong>&gt;&gt;&gt; ['__abs__', '__add__', __and__', '__class__', '__cmp__', '__coerce__',</strong><br/><strong>...</strong><br/><strong>'denominator', 'imag', 'numerator', 'real']</strong><br/><br/><strong>&gt;&gt;&gt; help(number.__add__)</strong><br/><strong>__add__(...)</strong><br/><strong>x.__add__(y) &lt;==&gt; x+y</strong></pre>
<p>Let's compare the difference between the <kbd>__add__()</kbd> function and the <kbd>+</kbd> symbol to verify our assumption. Using both methods to add <kbd>3</kbd> to our <kbd>number</kbd> object results in a returned value of <kbd>8</kbd>, as expected. Unfortunately, we've also broken a best practice rule illustrating this example:</p>
<pre><strong>&gt;&gt;&gt; number.__add__(3)</strong><br/><strong>8</strong><br/><strong>&gt;&gt;&gt; number + 3</strong><br/><strong>8</strong></pre>
<p>Notice how some methods, such as <kbd>__add__()</kbd>, have double leading and trailing underscores. These are referred to as magic methods, and are methods the Python interpreter calls and should not be called by the programmer. These magic methods are instead called indirectly by the user. For example, the integer <kbd>__add__()</kbd> magic method is called when using the <kbd>+</kbd> symbol between two numbers. Following the previous example, you should never run <kbd>number.__add__(3)</kbd> instead of <kbd>number + 3</kbd>.</p>
<p>This rule is broken in a few cases, which we will cover throughout this book, though unless the documentation recommends using a magic method, it is best to avoid them.</p>
<p>Python, like any other programming language, has a specific syntax. Compared to other common programming languages, Python is rather English-like and can be read fairly easily in scripts. This feature has attracted many, including the forensics community, to use this language. Even though Python's language is easy to read, it is not to be underestimated as it is powerful and supports common programming paradigms.</p>
<p>Most programmers start with a simple <kbd>Hello World</kbd> script, a test that proves they are able to execute code and print the famous message into the console window. With Python, the code to print this statement is a single line, as seen here, written on the first line of a file:</p>
<pre>001 print("Hello World!")<strong> </strong></pre>
<p>Please note that when discussing the code in a script, as opposed to code in the interactive prompt, line numbers, starting at 001, are shown for reference purposes only. Please do not include these line numbers in your script. The code for this script and all scripts can be downloaded at <a href="https://packtpub.com/books/content/support" target="_blank">https://packtpub.com/books/content/support</a>.</p>
<p>Save this line of code in a file called <kbd>hello.py</kbd>. To run this script, we call Python and the name of the script. If you are using Python 3, the message <kbd>Hello World!</kbd> should be displayed in your Terminal:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/383f350b-0090-40e5-88f1-cdc79124cb68.png" style="width:38.17em;height:5.17em;"/></p>
<p>Let's discuss why this simple script will not execute successfully in some versions of Python 2.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The omnipresent print() function</h1>
                
            
            
                
<p>Printing in Python is a very common technique as it allows the developer to display text to the console as the script executes. While there are many differences between Python 2 and 3, the way printing is called is the most obvious change, and is the reason why our previous example primarily only works with Python 3 as it is currently written. With Python 3, <kbd>print</kbd> became a function rather than a statement, as was the case with older versions of Python 2. Let's revisit our previous script and see a slight difference.</p>
<p>Note the following for Python 3:</p>
<pre>001 print("Hello World!")<strong> </strong></pre>
<p>Note the following for Python 2:</p>
<pre>001 print "Hello World!"</pre>
<p>The difference is seemingly minor. In Python 2, where <kbd>print</kbd> is a statement, you do not need to wrap what is being printed in parentheses. It would be disingenuous to say the difference is just semantics; however, for now just understand that <kbd>print</kbd> is written in two different ways, depending on the version of Python being used. The ramifications of this minor change mean that legacy Python 2 scripts that use <kbd>print</kbd> as a statement cannot be executed by Python 3.</p>
<p>Where possible, our scripts will be written to be compatible with both versions of Python. This goal, while seemingly impossible due to the difference in <kbd>print</kbd>, can be accomplished by importing a special Python library, called <kbd>__future__</kbd>, and changing the <kbd>print</kbd> statement to a function. To do this, we need to import the <kbd>print</kbd> function from the <kbd>__future__</kbd> library and then write all <kbd>print</kbd> commands as <kbd>function</kbd>.</p>
<p>The following script executes in both Python 2 and 3:</p>
<pre><strong>001 from __future__ import print_function</strong><br/><strong>002 print("Hello World!") </strong></pre>
<p class="CDPAlignCenter CDPAlign"><img src="img/514ef83c-f121-4986-8c6f-afe695d17374.png" style="width:34.92em;height:7.00em;"/></p>
<p>In the previous screenshot, you can see the result of this script in Python 2.7.15 and Python 3.7.1.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Standard data types</h1>
                
            
            
                
<p>With our first script complete, it is time to understand the basic data types of Python. These data types are similar to those found in other programming languages, but are invoked with a simple syntax, which is described in the following table and sections. For a full list of standard data types available in Python, visit the official documentation at <a href="https://docs.python.org/3/library/stdtypes.html" target="_blank">https://docs.python.org/3/library/stdtypes.html</a>:<a href="http://docs.python.org/2/library/stdtypes.html"/></p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td>
<div><strong>Data Type</strong></div>
</td>
<td>
<div><strong>Description</strong></div>
</td>
<td>
<div><strong>Example</strong></div>
</td>
</tr>
<tr>
<td>
<p class="TableColumnContentPACKT"><kbd>Str</kbd></p>
</td>
<td>
<p>String</p>
</td>
<td>
<p><kbd>str()</kbd>, <kbd>"Hello"</kbd>, <kbd>'Hello'</kbd></p>
</td>
</tr>
<tr>
<td>
<p class="TableColumnContentPACKT"><kbd>Unicode</kbd></p>
</td>
<td>
<p class="TableColumnContentPACKT">Unicode characters</p>
</td>
<td>
<p class="TableColumnContentPACKT"><kbd>unicode()</kbd>, <kbd>u'hello'</kbd>, <kbd>"world".encode('utf-8')</kbd></p>
</td>
</tr>
<tr>
<td>
<p class="TableColumnContentPACKT"><kbd>Int</kbd></p>
</td>
<td>
<p class="TableColumnContentPACKT">Integer</p>
</td>
<td>
<p class="TableColumnContentPACKT"><kbd>int()</kbd>, <kbd>1</kbd>, <kbd>55</kbd></p>
</td>
</tr>
<tr>
<td>
<p class="TableColumnContentPACKT"><kbd>Float</kbd></p>
</td>
<td>
<p class="TableColumnContentPACKT">Decimal precision integers</p>
</td>
<td>
<p class="TableColumnContentPACKT"><kbd>float()</kbd>, <kbd>1.0</kbd>, <kbd>.032</kbd></p>
</td>
</tr>
<tr>
<td>
<p class="TableColumnContentPACKT"><kbd>Bool</kbd></p>
</td>
<td>
<p class="TableColumnContentPACKT">Boolean values</p>
</td>
<td>
<p class="TableColumnContentPACKT"><kbd>bool()</kbd>, <kbd>True</kbd>, <kbd>False</kbd></p>
</td>
</tr>
<tr>
<td>
<p class="TableColumnContentPACKT"><kbd>List</kbd></p>
</td>
<td>
<p class="TableColumnContentPACKT">List of elements</p>
</td>
<td>
<p class="TableColumnContentPACKT"><kbd>list()</kbd>, <kbd>[3, 'asd', True, 3]</kbd></p>
</td>
</tr>
<tr>
<td>
<p class="TableColumnContentPACKT"><kbd>Dictionary</kbd></p>
</td>
<td>
<p class="TableColumnContentPACKT">Set of key:value pairs used to structure data</p>
</td>
<td>
<p class="TableColumnContentPACKT"><kbd>dict()</kbd>, <kbd>{'element': 'Mn', 'Atomic Number': 25, 'Atomic Mass': 54.938}</kbd></p>
</td>
</tr>
<tr>
<td>
<p class="TableColumnContentPACKT"><kbd>Set</kbd></p>
</td>
<td>
<p class="TableColumnContentPACKT">List of unique elements</p>
</td>
<td>
<p class="TableColumnContentPACKT"><kbd>set()</kbd>, <kbd>[3, 4, 'hello']</kbd></p>
</td>
</tr>
<tr>
<td>
<p class="TableColumnContentPACKT"><kbd>Tuple</kbd></p>
</td>
<td>
<p class="TableColumnContentPACKT">Organized list of elements</p>
</td>
<td>
<p class="TableColumnContentPACKT"><kbd>tuple()</kbd>, <kbd>(2, 'Hello World!', 55.6, ['element1'])</kbd></p>
</td>
</tr>
<tr>
<td>
<p class="TableColumnContentPACKT"><kbd>File</kbd></p>
</td>
<td>
<p class="TableColumnContentPACKT">A file object</p>
</td>
<td>
<p class="TableColumnContentPACKT"><kbd>open('write_output.txt', 'w')</kbd></p>
</td>
</tr>
</tbody>
</table>
<p>We are about to dive into the usage of data types in Python, and recommend that you repeat this section as needed to help with comprehension. While reading through how data types are handled is important, please be at a computer where you can run Python when you work through it the first few times. We invite you to explore the data type further in your interpreter and test them to see what they are capable of.</p>
<p>You will find that most of our scripts can be accomplished using only the standard data types Python offers. Before we take a look at one of the most common data types, strings, we will introduce comments.</p>
<p>Something that is always said, and can never be said enough, is to comment your code. In Python, comments are formed by any line beginning with the pound, or more recently known as the hashtag, <kbd>#</kbd> symbol. When Python encounters this symbol, it skips the remainder of the line and proceeds to the next line. For comments that span multiple lines, we can use three single or double quotes to mark the beginning and end of the comments rather than using a single pound symbol for every line. What follows are examples of types of comments in a file called <kbd>comments.py</kbd>. When running this script, we should only see <kbd>10</kbd> printed to the console as all comments are ignored:</p>
<div><pre># This is a comment<br/>print(5 + 5) # This is an inline comment.<br/># Everything to the right of the # symbol<br/># does not get executed<br/>"""We can use three quotes to create <br/>multi-line comments."""  </pre></div>
<p>The output is as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/11aa2e04-ae60-46ee-9779-591806708404.png" style="width:39.67em;height:3.08em;"/></p>
<p>When this code is executed, we only see the preceding at the console.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Strings and Unicode</h1>
                
            
            
                
<p>Strings are a data type that contain any character, including alphanumeric characters, symbols, Unicode, and other codecs. With the vast amount of information that can be stored as a string, it is no surprise they are one of the most common data types. Examples of areas where strings are found include reading arguments at the command line, user input, data from files, and outputting data. To begin, let us look at how we can define a string in Python.</p>
<p>There are three ways to create a string: with single quotes, double quotes, or with the built-in <kbd>str()</kbd> constructor method. Note that there is no difference between single- and double-quoted strings. Having multiple ways to create a string is advantageous, as it allows us to differentiate between intentional quotes within a string. For example, in the <kbd>'I hate when people use "air-quotes"!'</kbd> string, we use the single quotes to demarcate the beginning and end of the main string. The double quotes inside the string will not cause any issues with the Python interpreter. Let's verify with the <kbd>type()</kbd> function that both single and double quotes create the same type of object:</p>
<pre><strong>&gt;&gt;&gt; type('Hello World!')</strong><br/><strong>&lt;class 'str'&gt;</strong><br/><strong>&gt;&gt;&gt; type("Foo Bar 1234")</strong><br/><strong>&lt;class 'str'&gt;</strong> </pre>
<p>As we saw with comments, a block string can be defined by three single or double quotes to create multi-line strings. The only difference is whether we do something with the block-quoted value or not:</p>
<pre><strong>&gt;&gt;&gt; """This is also a string""" </strong><br/><strong>This is also a string</strong><br/><strong>&gt;&gt;&gt; '''it </strong><br/><strong> can span </strong><br/><strong> several lines''' </strong><br/><strong>it\ncan span\nseveral lines</strong> </pre>
<p>The <kbd>\n</kbd> character in the returned line signifies a line feed or a new line. The output in the interpreter displays these newline characters as <kbd>\n</kbd>, though when fed into a file or console, a new line is created. The <kbd>\n</kbd> character is one of the common escape characters in Python. Escape characters are denoted by a backslash following a specific character. Other common escape characters include <kbd>\t</kbd> for horizontal tabs, <kbd>\r</kbd> for carriage returns, <kbd>\'</kbd>, <kbd>\"</kbd>, and <kbd>\\</kbd> for literal single quotes, double quotes, and backslashes, among others. Literal characters allow us to use these characters without unintentionally using their special meaning in Python's context.</p>
<p>We can also use the add (<kbd>+</kbd>) or multiply (<kbd>*</kbd>) operators with strings. The add operator is used to concatenate strings together, and the multiply operator will repeat the provided string values:</p>
<pre><strong>&gt;&gt;&gt; 'Hello' + ' ' + 'World'</strong><br/><strong>Hello World</strong><br/><strong>&gt;&gt;&gt; "Are we there yet? " * 3</strong><br/><strong>Are we there yet? Are we there yet? Are we there yet?</strong></pre>
<p>Let's look at some common functions we use with strings. We can remove characters from the beginning or end of a string using the <kbd>strip()</kbd> function. The <kbd>strip()</kbd> function requires the character we want to remove as its input, otherwise it will replace whitespace by default. Similarly, the <kbd>replace()</kbd> function takes two inputs the character to replace and what to replace it with. The major difference between these two functions is that <kbd>strip()</kbd> only looks at the beginning and end of a string:</p>
<pre><strong># This will remove colon (`:`) from the beginning and end of the line</strong><br/><strong>&gt;&gt;&gt; ':HelloWorld:'.strip(':')</strong><br/><strong>HelloWorld</strong><br/><br/><br/><strong># This will remove the colon (`:`) from the line and place a </strong><br/><strong># space (` `) in it's place</strong><br/><strong>&gt;&gt;&gt; 'Hello:World'.replace(':', ' ')</strong><br/><strong>Hello World</strong> </pre>
<p>We can check if a character or characters are in a string using the <kbd>in</kbd> statement. Or, we can be more specific, and check if a string <kbd>startswith()</kbd> or <kbd>endswith()</kbd> a specific character(s) instead (you know a language is easy to understand when you can create sensible sentences out of functions). These methods return <kbd>True</kbd> or <kbd>False</kbd> Boolean objects:</p>
<pre><strong>&gt;&gt;&gt; 'a' in 'Chapter 2'</strong><br/><strong>True</strong><br/><strong>&gt;&gt;&gt; 'Chapter 1'.startswith('Chapter')</strong><br/><strong>True</strong><br/><strong>&gt;&gt;&gt; 'Chapter 1'.endswith('1')</strong><br/><strong>True</strong> </pre>
<p>We can quickly split a string into a list based on some delimiter. This can be helpful to quickly convert data separated by a delimiter into a list. For example, <strong>comma-separated values</strong> (<strong>CSV</strong>) data is separated by commas and could be split on that value:</p>
<pre><strong>&gt;&gt;&gt; print("Hello, World!".split(','))</strong><br/><strong>["Hello", " World!"]</strong> </pre>
<p>Formatting parameters can be used on strings to manipulate them and convert them based on provided values. With the <kbd>.format()</kbd> function, we can insert values into strings, pad numbers, and display patterns with simple formatting. This chapter will highlight a few examples of the <kbd>.format()</kbd> method, and we will introduce more complex features of it throughout this book. The <kbd>.format()</kbd> method replaces curly brackets with the provided values in order.</p>
<p>This is the most basic operation for inserting values into a string dynamically:</p>
<pre><strong>&gt;&gt;&gt; "{} {} {} {}".format("Formatted", "strings", "are", "easy!")</strong><br/><strong>'Formatted strings are easy!'</strong></pre>
<p>Our second example displays some of the expressions we can use to manipulate a string. Inside the curly brackets, we place a colon, which indicates that we are going to specify a format for interpretation. Following this colon, we specify that there should be at least six characters printed. If the supplied input is not six characters long, we prepend zeroes to the beginning of the input. Lastly, the <kbd>d</kbd> character specifies that the input will be a base 10 decimal:</p>
<pre><strong>&gt;&gt;&gt; "{:06d}".format(42)</strong><br/><strong>'000042'</strong> </pre>
<p>Our last example demonstrates how we can easily print a string of <kbd>20</kbd> equal signs by stating that our fill character is the equals symbol, followed by the caret (to center the symbols in the output), and the number of times to repeat the symbol. By providing this format string, we can quickly create visual separators in our outputs:</p>
<pre><strong>&gt;&gt;&gt; "{:=^20}".format('')</strong><br/><strong>'===================='</strong> </pre>
<p>While we will introduce more advanced features of the <kbd>.format()</kbd> method, the site <a href="https://pyformat.info/" target="_blank">https://pyformat.info/</a> is a great resource for learning more about the capabilities of Python's string formatting.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Integers and floats</h1>
                
            
            
                
<p>The integer is another valuable data type that is frequently used—an integer is any whole positive or negative number. The float data type is similar, but allows us to use numbers requiring decimal-level precision. With integers and floats, we can use standard mathematical operations, such as: <kbd>+</kbd>, <kbd>-</kbd>, <kbd>*</kbd>, and <kbd>/</kbd>. These operations return slightly different results based on the object's type (for example, <kbd>integer</kbd> or <kbd>float</kbd>).</p>
<p>An integer uses whole numbers and rounding, for example dividing two integers will result in another whole number integer. However, by using one float in the equation, even one that has the same value as the integer will result in a float; for example, <kbd>3/2=1</kbd> and <kbd>3/2.0=1.5</kbd> in Python. The following are examples of integer and float operations:</p>
<pre><strong>&gt;&gt;&gt; type(1010)</strong><br/><strong>&lt;class 'int'&gt;</strong><br/><strong>&gt;&gt;&gt; 127*66</strong><br/><strong>8382</strong><br/><strong>&gt;&gt;&gt; 66/10</strong><br/><strong>6</strong><br/><strong>&gt;&gt;&gt; 10 * (10 - 8)</strong><br/><strong>20</strong> </pre>
<p>We can use <kbd>**</kbd> to raise an integer by a power. For example, in the following section, we raise <kbd>11</kbd> by the power of <kbd>2</kbd>. In programming, it can be helpful to determine the numerator resulting from the division between two integers. For this, we use the modulus or percent (<kbd>%</kbd>) symbol. With Python, negative numbers are those with a dash character (<kbd>-</kbd>) preceding the value. We can use the built-in <kbd>abs()</kbd> function to get the absolute value of an integer or float:</p>
<pre><strong>&gt;&gt;&gt; 11**2</strong><br/><strong>121</strong><br/><strong>&gt;&gt;&gt; 11 % 2 # 11 divided by 2 is 5.5 or 5 with a remainder of 1</strong><br/><strong>1</strong><br/><strong>&gt;&gt;&gt; abs(-3)</strong><br/><strong>3</strong></pre>
<p>A float is defined by any number with a decimal. Floats follow the same rules and operations as we saw with integers, with the exception of the division behavior described previously:</p>
<pre><strong>&gt;&gt;&gt; type(0.123)</strong><br/><strong>&lt;class 'float'&gt;</strong><br/><strong>&gt;&gt;&gt; 1.23 * 5.23</strong><br/><strong>6.4329</strong><br/><strong>&gt;&gt;&gt; 27/8.0</strong><br/><strong>3.375</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Boolean and none</h1>
                
            
            
                
<p>The integers <kbd>0</kbd> and <kbd>1</kbd> can also represent Boolean values in Python. These values are the Boolean <kbd>False</kbd> or <kbd>True</kbd> objects, respectively. To define a Boolean, we can use the <kbd>bool()</kbd> constructor statement. These data types are used extensively in program logic to evaluate statements for conditionals, as covered later in this chapter.</p>
<p>Another built-in data type is the null type, which is defined by the keyword <kbd>None</kbd>. When used, it represents an empty object, and when evaluated will return <kbd>False</kbd>. This is helpful when initializing a variable that may use several data types throughout execution. By assigning a null value, the variable remains sanitized until reassigned:</p>
<pre><strong>&gt;&gt;&gt; bool(0)</strong><br/><strong>False</strong><br/><strong>&gt;&gt;&gt; bool(1)</strong><br/><strong>True</strong><br/><strong>&gt;&gt;&gt; None</strong><br/><strong>&gt;&gt;&gt;</strong> </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Structured data types</h1>
                
            
            
                
<p>There are several data types that are more complex and allow us to create structures of raw data. This includes lists, dictionaries, sets, and tuples. Most of these structures are comprised of the previously mentioned data types. These structures are very useful in creating powerful units of values, allowing raw data to be stored in a manageable manner.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Lists</h1>
                
            
            
                
<p>Lists are a series of ordered elements. Lists support any data type as an element and will maintain the order of data as it is appended to the list. Elements can be called by position or a loop can be used to step through each item. In Python, unlike other languages, printing a list takes one line. In languages like Java or C++, it can take three or more lines to print a list. Lists in Python can be as long as needed and can expand or contract on the fly, another feature uncommon in other languages.</p>
<p>We can create lists by using brackets with elements separated by commas. Or, we can use the <kbd>list()</kbd> class constructor with an iterable object. List elements can be accessed by index where <kbd>0</kbd> is the first element. To access an element by position, we place the desired index in brackets following the list object. Rather than needing to know how long a list is (which can be accomplished with the <kbd>len()</kbd> function), we can use negative index numbers to access list elements in reference to the end (that is, <kbd>-3</kbd> would retrieve the third to last element):</p>
<pre><strong>&gt;&gt;&gt; type(['element1', 2, 6.0, True, None, 234])</strong><br/><strong>&lt;class 'list'&gt;</strong><br/><strong>&gt;&gt;&gt; list((4, 'element 2', None, False, .2))</strong><br/><strong>[4, 'element 2', None, False, 0.2]</strong><br/><strong>&gt;&gt;&gt; len([0,1,2,3,4,5,6])</strong><br/><strong>7</strong><br/><strong>&gt;&gt;&gt; ['hello_world', 'foo bar'][0]</strong><br/><strong>hello_world</strong><br/><strong>&gt;&gt;&gt; ['hello_world', 'foo_bar'][-1]</strong><br/><strong>foo_bar</strong> </pre>
<p>We can add, remove, or check if a value is in a list using a couple of different functions. The <kbd>append()</kbd> method adds data to the end of the list. Alternatively, the <kbd>insert()</kbd> method allows us to specify an index when adding data to the list. For example, we can add the string <kbd>fish</kbd> to the beginning, or <kbd>0</kbd> index, of our list:</p>
<pre><strong>&gt;&gt;&gt; ['cat', 'dog'].append('fish')</strong><br/><strong># The list becomes: ['cat', 'dog', 'fish']</strong><br/><strong>&gt;&gt;&gt; ['cat', 'dog'].insert(0, 'fish')</strong><br/><strong># The list becomes: ['fish', 'cat', 'dog'] </strong> </pre>
<p>The <kbd>pop()</kbd> and <kbd>remove()</kbd> functions delete data from a list either by index or by a specific object, respectively. If an index is not supplied with the <kbd>pop()</kbd> function, the last element in the list is popped. Note that the <kbd>remove()</kbd> function only gets rid of the first instance of the supplied object in the list:</p>
<pre><strong>&gt;&gt;&gt; [0, 1, 2].pop()</strong><br/><strong>2</strong><br/><strong># The list is now [0, 1]</strong><br/><br/><strong>&gt;&gt;&gt; [3, 4, 5].pop(1)</strong><br/><strong>4</strong><br/><strong># The list is now [3, 5]</strong><br/><strong>&gt;&gt;&gt; [1, 1, 2, 3].remove(1)</strong><br/><strong># The list becomes: [1, 2, 3]</strong> </pre>
<p>We can use the <kbd>in</kbd> statement to check if some object is in the list. The <kbd>count()</kbd> function tells us how many instances of an object are in the list:</p>
<pre><strong>&gt;&gt;&gt; 'cat' in ['mountain lion', 'ox', 'cat']</strong><br/><strong>True</strong><br/><strong>&gt;&gt;&gt; ['fish', 920.5, 3, 5, 3].count(3)</strong><br/><strong>2</strong> </pre>
<p>If we want to access a subset of elements, we can use list slice notation. Other objects, such as strings, also support this same slice notation to obtain a subset of data. Slice notation has the following format, where <kbd>a</kbd> is our list or string object:</p>
<pre><strong>a[x:y:z]</strong></pre>
<p>In the preceding example, <kbd>x</kbd> represents the start of the slice, <kbd>y</kbd> represents the end of the slice, and <kbd>z</kbd> represents the step of the slice. Note that each segment is separated by colons and enclosed in square brackets. A negative step is a quick way to reverse the contents of an object that supports slice notation and would be triggered by a negative number as <kbd><em>z</em></kbd>. Each of these arguments is optional. In the first example, our slice returns the second element and up to, but not including, the fifth element in the list. Using just one of these slice elements returns a list containing everything from the second index forward or everything up to the fifth index:</p>
<pre><strong>&gt;&gt;&gt; [0,1,2,3,4,5,6][2:5]</strong><br/><strong>[2, 3, 4]</strong><br/><strong>&gt;&gt;&gt; [0,1,2,3,4,5,6][2:]</strong><br/><strong>[2, 3, 4, 5, 6]</strong><br/><strong>&gt;&gt;&gt; [0,1,2,3,4,5,6][:5]</strong><br/><strong>[0, 1, 2, 3, 4]</strong> </pre>
<p>Using the third slice element, we can skip every other element or simply reverse the list with a negative one. We can use a combination of these slice elements to specify how to carve a subset of data from the list:</p>
<pre><strong>&gt;&gt;&gt; [0,1,2,3,4,5,6][::2]</strong><br/><strong>[0, 2, 4, 6]</strong><br/><strong>&gt;&gt;&gt; [0,1,2,3,4,5,6][::-1]</strong><br/><strong>[6, 5, 4, 3, 2, 1, 0]</strong>  </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Dictionaries</h1>
                
            
            
                
<p>Dictionaries, otherwise known as <kbd>dict</kbd>, are another common Python data container. Unlike lists, this object does not add data in a linear fashion. Instead, data is stored as key and value pairs, where you can create and name unique keys to act as an index for stored values. It is important to note that, in Python 2, dictionaries do not preserve the order in which items are added to it. This is no longer true as of Python 3.6.5, though in general, we should not rely on the <kbd>dict()</kbd> object maintaining order for us. These objects are used heavily in forensic scripting, as they allow us to store data by name in a single object; otherwise, we may be left assigning a lot of new variables. By storing data in dictionaries, it is possible to have one variable contain very structured data.</p>
<p>We can define a dictionary by using curly braces (<kbd>{}</kbd>), where each key and value pair is delimited by a colon. Additionally, we can use the <kbd>dict()</kbd> class constructor to instantiate dictionary objects. Calling a value from a dictionary is accomplished by specifying the key in brackets following the dictionary object. If we supply a key that does not exist, we will receive a <kbd>KeyError</kbd> (notice that we have assigned our dictionary to a variable, <kbd>a</kbd>). While we have not introduced variables at this point, it is necessary to highlight some of the functions that are specific to dictionaries:</p>
<pre><strong>&gt;&gt;&gt; type({'Key Lime Pie': 1, 'Blueberry Pie': 2})</strong><br/><strong>&lt;class 'dict'&gt;</strong><br/><strong>&gt;&gt;&gt; dict((['key_1', 'value_1'],['key_2', 'value_2']))</strong><br/><strong>{'key_1': 'value_1', 'key_2': 'value_2'}</strong><br/><strong>&gt;&gt;&gt; a = {'key1': 123, 'key2': 456}</strong><br/><strong>&gt;&gt;&gt; a['key1']</strong><br/><strong>123</strong> </pre>
<p>We can add or modify the value of a preexisting key in a dictionary by specifying a key and setting it equal to another object. We can remove objects using the <kbd>pop()</kbd> function, similar to the list <kbd>pop()</kbd> function, to remove an item in a dictionary by specifying its key instead of an index:</p>
<pre><strong>&gt;&gt;&gt; a['key3'] = 789</strong><br/><strong>&gt;&gt;&gt; a</strong><br/><strong>{'key1': 123, 'key2': 456, 'key3': 789}</strong><br/><strong>&gt;&gt;&gt; a.pop('key1')</strong><br/><strong>123</strong><br/><strong>&gt;&gt;&gt; a</strong><br/><strong>{'key2': 456, 'key3': 789}</strong> </pre>
<p>The <kbd>keys()</kbd> and <kbd>values()</kbd> functions return a list of keys and values in the dictionary. We can use the <kbd>items()</kbd> function to return a list of tuples containing each key and value pair. These three functions are often used for conditionals and loops:</p>
<pre><strong>&gt;&gt;&gt; a.keys()</strong><br/><strong>dict_keys(['key2', 'key3'])</strong><br/><strong>&gt;&gt;&gt; a.values()</strong><br/><strong>dict_values([456, 789])</strong><br/><strong>&gt;&gt;&gt; a.items()</strong><br/><strong>dict_items([('key3', 789), ('key2', 456)])</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Sets and tuples</h1>
                
            
            
                
<p>Sets are similar to lists in that they contain a list of elements, though they must be unique items. With this, the elements must be immutable, meaning that the value must remain constant. For this, sets are best used on integers, strings, Boolean, floats, and tuples as elements. Sets do not index the elements, and therefore we cannot access the elements by their location in the <kbd>set</kbd>. Instead, we can access and remove elements through the use of the <kbd>pop()</kbd> method mentioned for the list method. Tuples are also similar to lists, though they are immutable. Built using parenthesis in lieu of brackets, elements do not have to be unique and of any data type:</p>
<pre><strong>&gt;&gt;&gt; type(set([1, 4, 'asd', True]))</strong><br/><strong>&lt;class 'set'&gt;</strong><br/><strong>&gt;&gt;&gt; g = set(["element1", "element2"])</strong><br/><strong>&gt;&gt;&gt; g</strong><br/><strong>{'element1', 'element2'}</strong><br/><strong>&gt;&gt;&gt; g.pop()</strong><br/><strong>'element2'</strong><br/><strong>&gt;&gt;&gt; g</strong><br/><strong>{'element1'}</strong><br/><strong>&gt;&gt;&gt; tuple('foo')</strong><br/><strong>('f', 'o' , 'o')</strong><br/><strong>&gt;&gt;&gt; ('b', 'a', 'r')</strong><br/><strong>('b', 'a', 'r')</strong><br/><strong>&gt;&gt;&gt; ('Chapter1', 22)[0]</strong><br/><strong>Chapter1</strong><br/><strong>&gt;&gt;&gt; ('Foo', 'Bar')[-1]</strong><br/><strong>Bar</strong> </pre>
<p>The important difference between a tuple and a list is that a tuple is immutable. This means that we cannot change a tuple object. Instead, we must replace the object completely or cast it to a list, which is mutable. This casting process is described in the next section. Replacing an object is very slow since the operation to add a value to a tuple is <kbd>tuple = tuple + ('New value',)</kbd>, noting that the trailing comma is required to denote that this addition is a tuple.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Data type conversions</h1>
                
            
            
                
<p>In some situations, the initial data type might not be the desired data type and needs to be changed while preserving its content. For example, when a user inputs arguments from the command line, they are commonly captured as strings and sometimes that user input needs to be, for example, an integer. We would need to use the integer class constructor to convert that string object before processing the data. Imagine we have a simple script that returns the square of a user-supplied integer; we would need to first convert the user input to an integer prior to squaring the input. One of the most common ways to convert data types is to wrap the variable or string with the constructor method, as shown here, for each of the data types:</p>
<pre><strong>&gt;&gt;&gt; int('123456') # The string 123456</strong><br/><strong>123456 # Is now the integer 123456</strong><br/><strong>&gt;&gt;&gt; str(45) # The integer 45</strong><br/><strong>'45' # Is now the string 45</strong><br/><strong>&gt;&gt;&gt; float('37.5') # The string 37.5</strong><br/><strong>37.5 # Is now the float 37.5</strong> </pre>
<p>Invalid conversions, for example, converting the letter <kbd>'a'</kbd> to an integer, will raise a <kbd>ValueError</kbd>. This error will state that the specified value cannot be converted to the desired type. In this case, we would want to use the built-in <kbd>ord()</kbd> method, which converts a character to its integer equivalent based on the ASCII value. In other scenarios, we may need to use other methods to convert between data types. The following is a table of common built-in data type conversion methods we can utilize for most scenarios:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td>
<p class="TableColumnHeadingPACKT"><strong>Method</strong></p>
</td>
<td>
<p class="TableColumnHeadingPACKT"><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p class="TableColumnContentPACKT"><kbd>str()</kbd>, <kbd>int()</kbd>, <kbd>float()</kbd>, <kbd>dict()</kbd>, <kbd>list()</kbd>, <kbd>set()</kbd>, <kbd>tuple()</kbd></p>
</td>
<td>
<p class="TableColumnContentPACKT">Class constructor methods</p>
</td>
</tr>
<tr>
<td>
<p class="TableColumnContentPACKT"><kbd>hex()</kbd>, <kbd>oct()</kbd></p>
</td>
<td>
<p class="TableColumnContentPACKT">Converts an integer into a base 16 (hex) or base 8 (octal) representation</p>
</td>
</tr>
<tr>
<td>
<p class="TableColumnContentPACKT"><kbd>chr()</kbd>, <kbd>unichr()</kbd></p>
</td>
<td>
<p class="TableColumnContentPACKT">Converts an integer into an ASCII or Unicode character</p>
</td>
</tr>
<tr>
<td>
<p class="TableColumnContentPACKT"><kbd>ord()</kbd></p>
</td>
<td>
<p class="TableColumnContentPACKT">Converts a character into an integer</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>We can also interchange the type or ordered collections found in our list, set, and tuple types. Since sets have requirements for what data may be inserted, we generally do not cast anything to a set. It is more common, instead, to case a set to a list so that we can access values by position:</p>
<pre><strong>&gt;&gt;&gt; tuple_1 = (0, 1, 2, 3, 3)</strong><br/><strong>&gt;&gt;&gt; tuple_1</strong><br/><strong>(0, 1, 2, 3, 3)</strong><br/><strong>&gt;&gt;&gt; set_1 = set(tuple_1)</strong><br/><strong>&gt;&gt;&gt; set_1</strong><br/><strong>{0, 1, 2, 3}</strong><br/><strong>&gt;&gt;&gt; list_1 = list(tuple_1)</strong><br/><strong>&gt;&gt;&gt; list_1</strong><br/><strong>[0, 1, 2, 3, 3]</strong><br/><strong>&gt;&gt;&gt; list_2 = list(set_1)</strong><br/><strong>&gt;&gt;&gt; list_2</strong><br/><strong>[0, 1, 2, 3]</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Files</h1>
                
            
            
                
<p>We will often create file objects to read or write data from a file. File objects can be created using the built-in <kbd>open()</kbd> method. The <kbd>open()</kbd> function takes two arguments, the name of the file and the mode. These modes dictate how we can interact with the file object. The mode argument is optional, and if left blank defaults to read-only. The following table illustrates the different file modes available for use:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td>
<p class="TableColumnHeadingPACKT"><strong>File Mode</strong></p>
</td>
<td>
<p class="TableColumnHeadingPACKT"><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p class="TableColumnContentPACKT"><kbd>r</kbd></p>
</td>
<td>
<p class="TableColumnContentPACKT">Opens the file for read-only mode (default). <em>This does not offer forensic write protection! Please always use a certified process to protect evidence from modification.</em></p>
</td>
</tr>
<tr>
<td>
<p class="TableColumnContentPACKT"><kbd>w</kbd></p>
</td>
<td>
<p class="TableColumnContentPACKT">Creates, or overwrites the file if it exists, for writing.</p>
</td>
</tr>
<tr>
<td>
<p class="TableColumnContentPACKT"><kbd>a</kbd></p>
</td>
<td>
<p class="TableColumnContentPACKT">Creates a file if it doesn't exist for writing. If the file does exist, the file pointer is placed at the end of the file to append writes to the file.</p>
</td>
</tr>
<tr>
<td>
<p class="TableColumnContentPACKT"><kbd>rb</kbd>, <kbd>wb</kbd>, or <kbd>ab</kbd></p>
</td>
<td>
<p class="TableColumnContentPACKT">Opens the file for reading or writing in binary mode.</p>
</td>
</tr>
<tr>
<td>
<p class="TableColumnContentPACKT"><kbd>r+</kbd>, <kbd>rb+</kbd>, <kbd>w+</kbd>, <kbd>wb+</kbd>, <kbd>a+</kbd>, or <kbd>ab+</kbd></p>
</td>
<td>
<p class="TableColumnContentPACKT">Opens the file for reading and writing in either standard or binary mode. If the file does not exist, the <kbd>w</kbd> or <kbd>a</kbd> modes create the file.</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>Most often, we will use read and write in standard or binary mode. Let's take a look at a few examples and some of the common functions we might use. For this section, we will create a text file called <kbd>file.txt</kbd> with the following content:</p>
<pre>This is a simple test for file manipulation.<br/>We will often find ourselves interacting with file objects.<br/>It pays to get comfortable with these objects.</pre>
<p>In the following example, we open a file object that exists, <kbd>file.txt</kbd>, and assign it to a variable, <kbd>in_file</kbd>. Since we do not supply a file mode, it is opened in read-only mode by default. We can use the <kbd>read()</kbd> method to read all lines as a continuous string. The <kbd>readline()</kbd> method can be used to read individual lines as a string. Alternatively, the <kbd>readlines()</kbd> method creates a string for each line and stores it in a list. These functions take an optional argument, specifying the size of bytes to read.</p>
<p>The <kbd>readline()</kbd> and <kbd>readlines()</kbd> functions use the <kbd>\n</kbd> or <kbd>\r</kbd> newline characters to segment the lines of a file. This is good for most files, though may not always work based on your input data. As an example, CSV files with multiple lines in a single cell would not display properly with this type of file-reading interface.</p>
<p>Python keeps track of where we currently are in the file. To illustrate the examples we've described, we need to use the <kbd>seek()</kbd> operation to bring us back to the start of the file before we run our next example. The <kbd>seek()</kbd> operation accepts a number and will navigate to that decimal character offset within the file. For example, if we tried to use the <kbd>read()</kbd> method before seeking back to the start, our next print function (showcasing the <kbd>readline()</kbd> method) would not return anything. This is because the cursor would be at the end of the file as a result of the <kbd>read()</kbd> function:</p>
<pre><strong>&gt;&gt;&gt; in_file = open('file.txt')</strong><br/><strong>&gt;&gt;&gt; print(in_file.read())</strong><br/><strong>This is a simple test for file manipulation.</strong><br/><strong>We will often find ourselves interacting with file objects.</strong><br/><strong>It pays to get comfortable with these objects.</strong><br/><strong>&gt;&gt;&gt; in_file.seek(0)</strong><br/><strong>&gt;&gt;&gt; print(in_file.readline())</strong><br/><strong>This is a simple test for file manipulation.</strong><br/><strong>&gt;&gt;&gt; in_file.seek(0)</strong><br/><strong>&gt;&gt;&gt; print(in_file.readlines())</strong><br/><strong>['This is a simple test for file manipulation.\n', 'We will often find ourselves interacting with file objects.\n', 'It pays to get comfortable with these objects.']</strong> </pre>
<p>In a similar fashion, we can create, or open and overwrite, an existing file using the <kbd>w</kbd> file mode. We can use the <kbd>write()</kbd> function to write an individual string or the <kbd>writelines()</kbd> method to write any iterable object to the file. The <kbd>writelines()</kbd> function essentially calls the <kbd>write()</kbd> method for each element of the iterable object.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>For example, this is tantamount to calling <kbd>write()</kbd> on each element of a list:</p>
<pre><strong>&gt;&gt;&gt; out_file = open('output.txt', 'w')</strong><br/><strong>&gt;&gt;&gt; out_file.write('Hello output!')</strong><br/><strong>&gt;&gt;&gt; data = ['falken', 124, 'joshua']</strong><br/><strong>&gt;&gt;&gt; out_file.writelines(data)</strong> </pre>
<p>Python does a great job of closing connections to a file object automatically. However, best practice dictates that we should use the <kbd>flush()</kbd> and <kbd>close()</kbd> methods after we finish writing data to a file. The <kbd>flush()</kbd> method writes any data remaining in a buffer to the file, and the <kbd>close()</kbd> function closes our connection to the file object:</p>
<pre><strong>&gt;&gt;&gt; out_file.flush()</strong><br/><strong>&gt;&gt;&gt; out_file.close()</strong> </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Variables</h1>
                
            
            
                
<p>We can assign values to variables using the data types we just covered. By assigning values to variables, we can refer to that value, which could be a large 100-element list, by its variable name. This not only saves the programmer from re-typing out the value over and over again, but helps enhance the readability of the code and allows us to change the values of a variable over time. Throughout this chapter, we have already assigned objects to variables using the <kbd>=</kbd> sign. Variable names can technically be anything, although we recommend the following guidelines:</p>
<ul>
<li>Variable names should be short and descriptive of the stored content or purpose.</li>
<li>Begin with a letter or underscore.</li>
<li>Constant variables should be denoted by capitalized words.</li>
<li>Dynamic variables should be lowercase words separated by underscores.</li>
<li>Never be one of the following or any Python-reserved name: <kbd>input</kbd>, <kbd>output</kbd>, <kbd>tmp</kbd>, <kbd>temp</kbd>, <kbd>in</kbd>, <kbd>for</kbd>, <kbd>next</kbd>, <kbd>file</kbd>, <kbd>True</kbd>, <kbd>False</kbd>, <kbd>None</kbd>, <kbd>str</kbd>, <kbd>int</kbd>, <kbd>list</kbd>.</li>
<li>Never include a space in a variable name. Python thinks two variables are being defined and will raise a syntax error. Use underscores to separate words.</li>
</ul>
<p>Generally, programmers use memorable and descriptive names that indicate the data they hold. For example, in a script that prompts for the phone number of the user, the variable should be <kbd>phone_number</kbd>, which clearly indicates the purpose and contents of this variable. Another popular naming style is <kbd>CamelCase</kbd>, where every word is capitalized. This naming convention is often used in conjunction with class names (more on those later in this book).</p>
<p class="mce-root"/>
<p>A variable assignment allows the value to be modified as the script runs. The general rule of thumb is to assign a value to a variable if it will be used again. Let's practice by creating variables and assigning them data types we have just learned about. While this is simple, we recommend following along in the interactive prompt to get in the habit of assigning variables. In the first example here, we assign a string to a variable before printing the variable:</p>
<pre><strong>&gt;&gt;&gt; print(hello_world)</strong><br/><strong>Hello World!</strong> </pre>
<p>The second example introduces some new operators. First, we assign the integer, <kbd>5</kbd>, to the variable, <kbd>our_number</kbd>. Then, we use the plus-gets (<kbd>+=</kbd>) as a built-in shorthand for <kbd>our_number = our_number + 20</kbd>. In addition to plus-gets, there is minus-gets (<kbd>-=</kbd>), multiply-gets (<kbd>*=</kbd>), and divide-gets (<kbd>/=</kbd>):</p>
<pre><strong>&gt;&gt;&gt; our_number = 5</strong><br/><strong>&gt;&gt;&gt; our_number += 20</strong><br/><strong>&gt;&gt;&gt; print(our_number)</strong><br/><strong>25</strong> </pre>
<p>In the following code block, we assign a series of variables before printing them. The data types used for our variables are <kbd>string</kbd>, <kbd>integer</kbd>, <kbd>float</kbd>, <kbd>list</kbd>, and <kbd>Boolean</kbd>, respectively:</p>
<pre><strong>&gt;&gt;&gt; BOOK_TITLE = 'Learning Python for Forensics'</strong><br/><strong>&gt;&gt;&gt; edition = 2</strong><br/><strong>&gt;&gt;&gt; python2_version = 2.7.15</strong><br/><strong>&gt;&gt;&gt; python3_version = 3.7.1</strong><br/><strong>&gt;&gt;&gt; AUTHOR_NAMES = ['Preston Miller', 'Chapin Bryce']</strong><br/><strong>&gt;&gt;&gt; is_written_in_english = True</strong><br/><strong>&gt;&gt;&gt; print(BOOK_TITLE)</strong><br/><strong>'Learning Python for Forensics'</strong><br/><strong>&gt;&gt;&gt; print(AUTHOR_NAMES)</strong><br/><strong>['Preston Miller', 'Chapin Bryce']</strong><br/><strong>&gt;&gt;&gt; print(edition)</strong><br/><strong>1</strong><br/><strong>&gt;&gt;&gt; print(python2_version)</strong><br/><strong>2.7.15</strong><br/><strong>&gt;&gt;&gt; print(is_written_in_english)</strong><br/><strong>True</strong></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Notice the <kbd>BOOK_TITLE</kbd> and <kbd>AUTHOR_NAMES</kbd> variables. When a variable is static, for instance, non-changing throughout the execution of a script, it is referred to as a constant variable. Unlike other programming languages, there is not a built-in method for protecting constants from being overwritten, so we use naming conventions to assist in reminding us not to replace the value. While some variables such as the edition of the book, language, or version of Python might change, the title and authors should be constants (we hope). If there is ever confusion when it comes to naming and styling conventions in Python, try running the following statement in an interpreter:</p>
<pre><strong>&gt;&gt;&gt; import this</strong>  </pre>
<p>As we saw previously, we can use the <kbd>split()</kbd> method on a string to convert it into a list. We can also convert a list into a string using the <kbd>join()</kbd> method. This method follows a string containing the desired common denominator and the list as its only argument. In the following example, we are taking list containing two strings and joining them into one string, where the elements are separated by a comma:</p>
<pre><strong>&gt;&gt;&gt; print(', '.join(["Hello", "World!"]))</strong><br/><strong>Hello, World!</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Understanding scripting flow logic</h1>
                
            
            
                
<p>Flow control logic allows us to create dynamic operations by specifying different routes of program execution based upon a series of circumstances. In any script worth its salt, some manner of flow control is present. For example, flow logic would be required to create a dynamic script that returns different results based on options selected by the user. In Python, there are two basic sets of flow logic: conditionals and loops.</p>
<p>Flow operators are frequently accompanied by flow logic. These operators can be strung together to create more complicated logic. The following table represents a <em>truth table</em> and illustrates the value of various flow operators based on the <em>A</em> or <em>B</em> variable Boolean state:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td>
<p class="TableColumnHeadingPACKT"><strong>A</strong></p>
</td>
<td>
<p class="TableColumnHeadingPACKT"><strong>B</strong></p>
</td>
<td>
<p class="TableColumnHeadingPACKT"><strong>A and B</strong></p>
</td>
<td>
<p class="TableColumnHeadingPACKT"><strong>A or B</strong></p>
</td>
<td>
<p class="TableColumnHeadingPACKT"><strong>not A</strong></p>
</td>
<td>
<p class="TableColumnHeadingPACKT"><strong>not B</strong></p>
</td>
</tr>
<tr>
<td>
<p class="TableColumnHeadingPACKT">F</p>
</td>
<td>
<p class="TableColumnHeadingPACKT">F</p>
</td>
<td>
<p>F</p>
</td>
<td>
<p>F</p>
</td>
<td>
<p>T</p>
</td>
<td>
<p>T</p>
</td>
</tr>
<tr>
<td>
<p class="TableColumnHeadingPACKT">T</p>
</td>
<td>
<p class="TableColumnHeadingPACKT">F</p>
</td>
<td>
<p>F</p>
</td>
<td>
<p>T</p>
</td>
<td>
<p>F</p>
</td>
<td>
<p>T</p>
</td>
</tr>
<tr>
<td>
<p class="TableColumnHeadingPACKT">F</p>
</td>
<td>
<p class="TableColumnHeadingPACKT">T</p>
</td>
<td>
<p>F</p>
</td>
<td>
<p>T</p>
</td>
<td>
<p>T</p>
</td>
<td>
<p>F</p>
</td>
</tr>
<tr>
<td>
<p class="TableColumnHeadingPACKT">T</p>
</td>
<td>
<p class="TableColumnHeadingPACKT">T</p>
</td>
<td>
<p>T</p>
</td>
<td>
<p>T</p>
</td>
<td>
<p>F</p>
</td>
<td>
<p>F</p>
</td>
</tr>
</tbody>
</table>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<p>The logical <kbd>AND</kbd> and <kbd>OR</kbd> operators are the third and fourth columns in the table. Both <em>A</em> and <em>B</em> must be <kbd>True</kbd> for the <kbd>AND</kbd> operator to return <kbd>True</kbd>. Only one of the variables needs to be <kbd>True</kbd> for the <kbd>OR</kbd> operator to be <kbd>True</kbd>. The <kbd>not</kbd> operator simply switches the Boolean value of the variable to its opposite (for example, <kbd>True</kbd> becomes <kbd>False</kbd> and vice versa).</p>
<p>Mastering conditionals and loops will take our scripts to another level. At its core, flow logic relies on only two values, <kbd>True</kbd> or <kbd>False</kbd>. As noted earlier, in Python, these are represented by the Boolean <kbd>True</kbd> and <kbd>False</kbd> data types.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Conditionals</h1>
                
            
            
                
<p>When a script hits a conditional, it's much like standing at a fork in the road. Depending on some factor, say a more promising horizon, you may decide to go east over west. Computer logic is less arbitrary in that if something is true the script proceeds one way, and if it is false then it will go another. These junctions are critical; if the program decides to go off the path we've developed for it, we'll be in serious trouble.</p>
<p>There are three statements that are used to form a conditional block: <kbd>if</kbd>, <kbd>elif</kbd>, and <kbd>else</kbd>. The conditional block refers to the conditional statements, their flow logic, and code. A conditional block starts with an <kbd>if</kbd> statement followed by flow logic, a colon, and indented line(s) of code. If the flow logic evaluates to <kbd>True</kbd>, then the indented code following the <kbd>if</kbd> statement will be executed. If it does not evaluate to <kbd>True</kbd>, the <strong>Python virtual machine</strong> (<strong>PVM</strong>) will skip those lines of code and go to the next line on the same level of indentation as the <kbd>if</kbd> statement. This is usually a corresponding <kbd>elif</kbd> (else-if) or <kbd>else</kbd> statement.</p>
<p>Indentation is very important in Python. It is used to demarcate code to be executed within a conditional statement or loop. A standard of four spaces for indentation is used in this book, though you may encounter code that uses a two-space indentation or uses tab characters. While all three of these practices are allowed in Python, four spaces are preferred and easier to read.</p>
<p>In a conditional block, once one of the statements evaluates to <kbd>True</kbd>, the code is executed and the PVM exits the block without evaluating the other statements.</p>
<pre># Conditional Block Pseudocode<br/>if [logic]:<br/>    # Line(s) of indented code to execute if logic evaluates to True.<br/>elif [logic]:<br/>    # Line(s) of indented code to execute if the 'if' <br/>    # statement is false and this logic is True.<br/>else:<br/>    # Line(s) of code to catch all other possibilities if<br/>    # the 'if' and 'elif' statements are all False.</pre>
<p>Until we define functions, we will stick to simple <kbd>if</kbd> statement examples:</p>
<pre><strong>&gt;&gt;&gt; a = 5</strong><br/><strong>&gt;&gt;&gt; b = 22</strong><br/><strong>&gt;&gt;&gt; a &gt; 0</strong><br/><strong>True</strong><br/><strong>&gt;&gt;&gt; a &gt; b</strong><br/><strong>False</strong><br/><strong>&gt;&gt;&gt; if a &gt; 0:</strong><br/><strong>...     print(str(a) + ' is greater than zero!')</strong><br/><strong>...</strong><br/><strong>5 is greater than zero!</strong><br/><strong>&gt;&gt;&gt; if a &gt;= b:</strong><br/><strong>...     print(str(a) + ' beats ' + str(b))</strong><br/><strong>...</strong><br/><strong>&gt;&gt;&gt;</strong> </pre>
<p>Notice how when the flow logic evaluates to <kbd>True</kbd>, then the code indented following the <kbd>if</kbd> statement is executed. When it evaluates to <kbd>False</kbd>, the code is skipped. Typically, when the <kbd>if</kbd> statement is false, you will have a secondary statement, such as an <kbd>elif</kbd> or <kbd>else</kbd> to catch other possibilities, such as when <kbd>a</kbd> is less than or equal to <kbd>b</kbd>. However, it is important to note that we can just use an <kbd>if</kbd> statement without any <kbd>elif</kbd> or <kbd>else</kbd> statements.</p>
<p>The difference between <kbd>if</kbd> and <kbd>elif</kbd> is subtle. We can only functionally notice a difference when we use multiple <kbd>if</kbd> statements. The <kbd>elif</kbd> statement allows for a second condition to be evaluated in the case that the first isn't successful. A second <kbd>if</kbd> statement will be evaluated regardless of the outcome of the first <kbd>if</kbd> statement.</p>
<p>The <kbd>else</kbd> statement does not require any flow logic and can be treated as a catch-all case for any remaining or unaccounted for case. This does not mean, however, errors will not occur when the code in the <kbd>else</kbd> statement is executed. Do not rely on <kbd>else</kbd> statements to handle errors.</p>
<p>Conditional statements can be made more comprehensive by using the logical <kbd>and</kbd> or <kbd>or</kbd> operators. These allow for more complex logic in a single conditional statement:</p>
<pre><strong>&gt;&gt;&gt; a = 5</strong><br/><strong>&gt;&gt;&gt; b = 22</strong><br/><strong>&gt;&gt;&gt; if a &gt; 4 and a &lt; b:</strong><br/><strong>...     print('Both statements must be true to print this')</strong><br/><strong>...</strong><br/><strong>Both statements must be true to print this</strong><br/><strong>&gt;&gt;&gt; if a &gt; 10 or a &lt; b:</strong><br/><strong>...     print('One of these statements must be true to print this')</strong><br/><strong>...</strong><br/><strong>Only one of these statements must be true to print this</strong> </pre>
<p>The following table can be helpful to understand how common operators work:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td>
<p class="TableColumnHeadingPACKT"><strong>Operator</strong></p>
</td>
<td>
<p class="TableColumnHeadingPACKT"><strong>Description</strong></p>
</td>
<td>
<p class="TableColumnHeadingPACKT"><strong>Example</strong></p>
</td>
<td>
<p class="TableColumnHeadingPACKT"><strong>Evaluation</strong></p>
</td>
</tr>
<tr>
<td>
<p class="TableColumnContentPACKT"><kbd>&lt;</kbd>, <kbd>&gt;</kbd></p>
</td>
<td>
<p class="TableColumnContentPACKT">less than, greater than</p>
</td>
<td>
<p class="TableColumnContentPACKT"><kbd>8 &lt; 3</kbd></p>
</td>
<td>
<p class="TableColumnContentPACKT"><kbd>False</kbd></p>
</td>
</tr>
<tr>
<td>
<p class="TableColumnContentPACKT"><kbd>&lt;=</kbd>, <kbd>&gt;=</kbd></p>
</td>
<td>
<p class="TableColumnContentPACKT">less than equal to, greater than equal to</p>
</td>
<td>
<p class="TableColumnContentPACKT"><kbd>5 =&lt; 5</kbd></p>
</td>
<td>
<p class="TableColumnContentPACKT"><kbd>True</kbd></p>
</td>
</tr>
<tr>
<td>
<p class="TableColumnContentPACKT"><kbd>==</kbd>, <kbd>!=</kbd></p>
</td>
<td>
<p class="TableColumnContentPACKT">equal to, not equal to</p>
</td>
<td>
<p class="TableColumnContentPACKT"><kbd>2 != 3</kbd></p>
</td>
<td>
<p class="TableColumnContentPACKT"><kbd>True</kbd></p>
</td>
</tr>
<tr>
<td>
<p class="TableColumnContentPACKT"><kbd>not</kbd></p>
</td>
<td>
<p class="TableColumnContentPACKT">switches Boolean value</p>
</td>
<td>
<p class="TableColumnContentPACKT"><kbd>not True</kbd></p>
</td>
<td>
<p class="TableColumnContentPACKT"><kbd>False</kbd></p>
</td>
</tr>
</tbody>
</table>


            

            
        
    

        

                            
                    <h1 class="header-title">Loops</h1>
                
            
            
                
<p>Loops provide another method of flow control, and are suited to perform iterative tasks. A loop will repeat inclusive code until the provided condition is no longer <kbd>True</kbd> or an exit signal is provided. There are two kinds of loops: <kbd>for</kbd> and <kbd>while</kbd>. For most iterative tasks, a <kbd>for</kbd> loop will be the best option to use.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The for loop</h1>
                
            
            
                
<p><kbd>for</kbd> loops are the most common and, in most cases, the preferred method to perform a task over and over again. Imagine a factory line; for each object on the conveyor belt, a <kbd>for</kbd> loop could be used to perform some task on it, such as placing a label on the object. In this manner, multiple <kbd>for</kbd> loops can come together in the form of an assembly line, processing each object, until they are ready to be presented to the user.</p>
<p>Much like the rest of Python, the <kbd>for</kbd> loop is very simple syntactically, yet powerful. In some languages, a <kbd>for</kbd> loop needs to be initialized, have a counter of sorts, and a termination case. Python's <kbd>for</kbd> loop is much more dynamic and handles these tasks on its own. These loops contain indented code that is executed line by line. If the object being iterated over still has elements (for example, more items to process) at the end of the indented block, the PVM will position itself at the beginning of the loop and repeat the code again.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The <kbd>for</kbd> loop syntax will specify the object to iterate over and what to call each of the elements within the object. Note that the object must be iterable. For example, <kbd>lists</kbd>, <kbd>sets</kbd>, <kbd>tuples</kbd>, and <kbd>strings</kbd> are iterable, but an integer is not. In the following example, we can see how a <kbd>for</kbd> loop treats strings and lists and helps us iterate over each element in iterable objects:</p>
<pre><strong>&gt;&gt;&gt; for character in 'Python':</strong><br/><strong>...      print(character)</strong><br/><strong>...</strong><br/><strong>P</strong><br/><strong>y</strong><br/><strong>t</strong><br/><strong>h</strong><br/><strong>o</strong><br/><strong>n</strong><br/><strong>&gt;&gt;&gt; cars = ['Volkswagon', 'Audi', 'BMW']</strong><br/><strong>&gt;&gt;&gt; for car in cars:</strong><br/><strong>...      print(car)</strong><br/><strong>...</strong><br/><strong>Volkswagon</strong><br/><strong>Audi</strong><br/><strong>BMW</strong> </pre>
<p>There are additional, more advanced, ways to call a <kbd>for</kbd> loop. The <kbd>enumerate()</kbd> function can be used to start an index. This comes in handy when you need to keep track of the index of the current loop. Indexes are incremented at the beginning of the loop. The first object has an index of <kbd>0</kbd>, the second has an index of <kbd>1</kbd>, and so on. The <kbd>range()</kbd> function can execute a loop a certain number of times and provide an index:</p>
<pre><strong>&gt;&gt;&gt; numbers = [5, 25, 35]</strong><br/><strong>&gt;&gt;&gt; for i, x in enumerate(numbers):</strong><br/><strong>...     print('Item', i, 'from the list is:', x)</strong><br/><strong>...</strong><br/><strong>Item 0 from the list is: 5</strong><br/><strong>Item 1 from the list is: 25</strong><br/><strong>Item 2 from the list is: 35</strong><br/><strong>&gt;&gt;&gt; for x in range(0, 100):</strong><br/><strong>...     print(x)</strong><br/><strong>0</strong><br/><strong>1</strong><br/><strong># continues to print 0 to 100 (omitted in an effort to save trees)</strong></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>


            

            
        
    

        

                            
                    <h1 class="header-title">The while loop</h1>
                
            
            
                
<p><kbd>while</kbd> loops are not encountered as frequently in Python. A <kbd>while</kbd> loop executes as long as a statement is true. The simplest <kbd>while</kbd> loop would be a <kbd>while True</kbd> statement. This kind of loop would execute forever since the Boolean object <kbd>True</kbd> is always <kbd>True</kbd> and so the indented code would continually execute.</p>
<p>If you are not careful, you can inadvertently create an infinite loop, which will wreak havoc on your script's intended functionality. It is imperative to utilize conditionals to cover all your bases such as <kbd>if</kbd>, <kbd>elif</kbd>, and <kbd>else</kbd> statements. If you fail to do so, your script can enter an unaccounted situation and crash. This is not to say that <kbd>while</kbd> loops are not worth using. <kbd>while</kbd> loops are quite powerful and have their own place in Python:</p>
<pre><strong>&gt;&gt;&gt; guess = 0</strong><br/><strong>&gt;&gt;&gt; answer = 42</strong><br/><strong>&gt;&gt;&gt; while True:</strong><br/><strong>...     if guess == answer:</strong><br/><strong>...          print('You've found the answer to this loop: ' + str(answer))</strong><br/><strong>...          break</strong><br/><strong>...     else:</strong><br/><strong>...          print(guess, 'is not the answer.')</strong><br/><strong>...          guess += 1</strong> </pre>
<p>The <kbd>break</kbd>, <kbd>continue</kbd>, and <kbd>pass</kbd> statements are used in conjunction with <kbd>for</kbd> and <kbd>while</kbd> loops to create more dynamic loops. The <kbd>break</kbd> escapes from the current loop, while the <kbd>continue</kbd> statement causes the PVM to begin executing code at the beginning of the loop, skipping any indented code following the <kbd>continue</kbd> statement. The <kbd>pass</kbd> statement literally does nothing and acts as a placeholder. If you're feeling brave or bored, or worse, both, remove the <kbd>break</kbd> statement from the previous example and note what happens.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Functions</h1>
                
            
            
                
<p>Functions are the first step to creating more complex Python code. At a high level, they are containers of Python code that can be bundled together into a callable block. A simple model function requires a single input, performs an operation on the provided data, and returns a single output. However, this quickly becomes more complicated as functions can run without inputs or optional inputs or do not need to return an output at all.</p>
<p>Functions are an integral component of any programming language and have already been encountered many times in this chapter. For example, the append from <kbd>list.append()</kbd> is a function that requires input to add to a list. Once a function is created, you can invoke it by its name and pass any required inputs.</p>
<p class="mce-root"/>
<p>When it comes to writing functions, more is better. It is much easier to handle and troubleshoot a bug in a program with many small functions than one big function. Smaller functions make your code more readable and make it easier to find troublesome logic. That being said, functions should contain code for a singular purpose, such as accessing a certain key in a registry file. There is no need to create functions for each line of code in your script. Consider using functions as logical blocks of code. Sometimes that is three lines, sometimes that is 50 lines; what's important is that the purpose and operation of the functional unit of code is clear.</p>
<p>The function syntax starts with a definition, <kbd>def</kbd>, followed by the name of the function, any inputs in parenthesis, and a colon. Following this format are indented lines of code that will run when the function is called. Optionally, a function may have a return statement to pass information back to the instance where it was called from:</p>
<pre><strong>&gt;&gt;&gt; def simple_function():</strong><br/><strong>...      print('I am a simple function')</strong><br/><strong>...</strong><br/><strong>&gt;&gt;&gt; simple_function()</strong><br/><strong>I am a simple function</strong> </pre>
<p>In the example we've just seen, we've created a function named <kbd>simple_function()</kbd> that takes no inputs. This function does not return anything and instead prints a string. Let's take a look at more complicated examples.</p>
<p>Our first function, <kbd>square()</kbd>, takes one input and squares it. As this function returns a value, we catch it by assigning it to a variable when invoking the function. This variable, <kbd>squared_number</kbd>, will be equal to the returned value of the function. While this is a very succinct function, it is very easily broken if given the wrong input. Give the square function some other data type, such as a string, and you will receive a <kbd>TypeError</kbd>:</p>
<pre><strong>&gt;&gt;&gt; def square(x):</strong><br/><strong>...     return x**2</strong><br/><strong>...</strong><br/><strong>&gt;&gt;&gt; squared_number = square(4)</strong><br/><strong>&gt;&gt;&gt; print(squared_number)</strong><br/><strong>16</strong></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Our second function, <kbd>even_or_odd</kbd>, is slightly more advanced. This function first checks if it is passed an input that is of type integer. If not, it returns immediately, which causes the function to exit. If it is an integer, it performs some logic that displays to the user whether the integer is even or odd. Notice that when we try to give the function the string, <kbd>'5'</kbd>, not to be confused with the integer, <kbd>5</kbd>, it returns nothing, whereas in the square function, which lacks any input validation checks, this would have caused an error:</p>
<pre><strong>&gt;&gt;&gt; def even_or_odd(value):</strong><br/><strong>...     if isinstance(value, int):</strong><br/><strong>...         if value % 2 == 0:</strong><br/><strong>...               print('This number is even.')</strong><br/><strong>...         else:</strong><br/><strong>...              print('This number is odd.')</strong><br/><strong>...      else:</strong><br/><strong>...          return</strong><br/><strong>...</strong><br/><strong>&gt;&gt;&gt; values = [1, 3, 4, 6, '5']</strong><br/><strong>&gt;&gt;&gt; for value in values:</strong><br/><strong>...     even_or_odd(value)</strong><br/><strong>...</strong><br/><strong>This number is odd.</strong><br/><strong>This number is odd.</strong><br/><strong>This number is even.</strong><br/><strong>This number is even.</strong></pre>
<p>Aspiring developers should get in the habit of writing functions. As always, functions should be well-commented to help explain their purpose. Functions will be used throughout this book, especially as we begin to develop our forensic scripts.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>This chapter has covered a wide range of introductory content that provides a foundation to be built upon throughout the duration of this book; by the end, you will become well-versed in Python development. These topics have been handpicked as the most important items to comprise a basic understanding of the language as we move forward. We have covered data types, what they are and when they are used, variable naming and the associated rules and guidelines, logic and operations to manipulate and make decisions based on values, and conditions and loops that provide a sequential organization for our scripts and form the baseline of everything we develop. The code for this project can be downloaded from GitHub or Packt, as described in the <em>Preface</em>.</p>
<p class="mce-root"/>
<p>Please consider re-reading this chapter and working through the examples multiple times to help with comprehension. Just like anything else, learning a new language requires a lot of practice.</p>
<p>Through these features alone, we can create basic scripts. Python is a very powerful and complex language belying its simplistic syntax. In the next chapter, we will explore more complex foundational items and continue expanding upon knowledge established in this chapter, prior to moving on to real-world examples.</p>


            

            
        
    </body></html>