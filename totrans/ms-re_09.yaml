- en: Binary Obfuscation Techniques
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Binary obfuscation is a way for developers to make the code of a program difficult
    to understand or reverse. It is also used to hide data from being seen easily.
    It can be categorized as an anti-reversing technique that increases the processing
    time for reversing. Obfuscation can also use encryption and decryption algorithms,
    along with its hardcoded or code-generated cipher key.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will discuss ways how data and code are obfuscated. We are
    going to show how obfuscation is applied in examples including simple XORs, simple
    arithmetic, building data in the stack, and discussions about polymorphic and
    metamorphic code.
  prefs: []
  type: TYPE_NORMAL
- en: In the malware world, binary obfuscation is a common technique used by viruses
    aiming to defeat signature-based anti-virus software. As a virus infects files,
    it obfuscates its code using polymorphism or metamorphism.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will achieve the following learning outcomes:'
  prefs: []
  type: TYPE_NORMAL
- en: Identifying data being assembled on the stack
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identifying data being XORed or deobfuscated prior to use
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modifying data in text or other segments, and assembling on the heap
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data assembly on the stack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The stack is a memory space in which any data can be stored. The stack can
    be accessed using the stack pointer register (for 32-bit address space, the ESP
    register is used). Let''s consider the example of the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This will eventually display the following message box:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8e571e5c-7963-49f9-80a2-2b1a6139689b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'How did that happen when no visible text strings were referenced? Before calling
    for the `MessageBoxA` function, the stack would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9799eb1b-2a54-472f-bc9b-e5960182cc73.png)'
  prefs: []
  type: TYPE_IMG
- en: These push instructions assembled the null terminated message text at the stack.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'While the other string was assembled with these push instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In effect, the stack dump would look like this.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/335bce83-2f72-4952-967f-e52b9c3f7f32.png)'
  prefs: []
  type: TYPE_IMG
- en: Every after string assembly, the value of register ESP is stored in EAX and
    then EDX.  That is, EAX points to the address of the first string.  EDX points
    to the address of the second assembled string.
  prefs: []
  type: TYPE_NORMAL
- en: '`MessageBoxA` accepts four parameters.  The second parameter is the message
    text and the third is the caption text.  From the stack dump shown above, the
    strings are located at  addresses `0x22FE50` and `0x22FE54`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '`MessageBoxA` has all the parameters it requires. Even though the strings were
    assembled at the stack, as long as data is accessible, it can be used.'
  prefs: []
  type: TYPE_NORMAL
- en: Code assembly
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The same concept is possible in terms of code. Here''s another code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This yields the same message box as before. The difference is that this code
    pushes `opcode` bytes into the stack, and passes code execution to it. After entering
    the first `call eax` instruction, the stack would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e04dc42e-32b2-4cbe-a65a-81dacf01396a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Remember that the value at the top of the stack should contain the return address
    set by the `call` instruction. And here''s where our instruction pointer will
    be by now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ec290abd-d803-4ce3-ba75-6bae6880749b.png)'
  prefs: []
  type: TYPE_IMG
- en: The `pop edi` instruction stores the return address to the `EDI` register. The
    same set of instructions that assemble the message text setup are used here. Finally,
    a `push edi`, followed by a `ret` instruction, should make it back to the return
    address.
  prefs: []
  type: TYPE_NORMAL
- en: 'The resulting stack should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/48d6e667-6fa8-4127-ab1a-793cbaac9e9c.png)'
  prefs: []
  type: TYPE_IMG
- en: This is then followed by a couple of instructions that invoke `MessageBoxA`.
  prefs: []
  type: TYPE_NORMAL
- en: This technique of running code in the stack is employed by numerous malware,
    including software vulnerability exploits. As a course of action to prevent malware
    code execution, some operating systems have made security updates to bar the stack
    from code execution.
  prefs: []
  type: TYPE_NORMAL
- en: Encrypted data identification
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the main features of antivirus software is to detect malware using signatures.
    Signatures are sets of byte sequences unique to a given piece of malware. Although
    this detection technique is not thought of as effective for anti-virus nowadays,
    it may still play a vital role in detecting files, especially when an operating
    system is taken offline.
  prefs: []
  type: TYPE_NORMAL
- en: Simple signature detection can easily be defeated by encrypting the data and/or
    code of a malware. The effect would be that a new signature gets developed from
    a unique portion of the encrypted data. An attacker can simply re-encrypt the
    same malware using a different key, which would result in another signature. But
    still, the malware runs with the same behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, anti-virus software has made great improvements to defeat this technique,
    thereby making signature detection a technology of the past.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, this is an obfuscation technique that eats up additional
    time for reversing software. Under static analysis, identifying encrypted data
    and decryption routines informs us what to expect in the course of our analysis,
    especially when debugging. To start off, we'll look into a few code snippets.
  prefs: []
  type: TYPE_NORMAL
- en: Loop codes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Decryption can easily be identified by inspecting code that runs in a loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This loop code is controlled by a conditional jump. To identify a decryption
    or an encryption code, it should have a source and a destination. In this code,
    the source starts at address `0x00402000`, with the destination also at the same
    address. Each byte in the data is modified by an algorithm. In this case, the
    algorithm is a simple subtraction of `0x20` from the byte being changed. The loop
    ends only when `0x10` bytes of data have been modified. `0x20` is identified as
    the encryption/decryption key.
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm can vary, using standard and binary or just standard arithmetic.
    As long as a source data is modified and written to a destination within a loop,
    we can say that we have identified a cryptographic routine.
  prefs: []
  type: TYPE_NORMAL
- en: Simple arithmetic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Besides using bitwise operations, basic mathematical operations can also be
    used. If addition has a subtraction counterpart, we can encrypt a file using addition
    and decrypt it with subtraction, and vice-versa. The following code shows decryption
    using addition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The beauty of byte values is that they can be processed as signed numbers,
    if, for example, given this set of encryption information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'After each byte gets subtracted with `0x11`, the encrypted data would be the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'To restore it, we''ll have to add the same value, `0x11`, that was subtracted
    before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'If we look at the equivalent decimal values of the preceding bytes in unsigned
    and signed form, the data would look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the encrypted data shown in decimal values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: To sum it up, if we were to use basic arithmetical operations, we should look
    at it in the value's signed form.
  prefs: []
  type: TYPE_NORMAL
- en: Simple XOR decryption
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'XOR is the most popularly used operator when it comes to software cryptography.
    If we were to change the code algorithm in the previous code snippet, it would
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: What makes it popular is that the same algorithm can be used to encrypt and
    decrypt data. Using the same key, `XOR` can restore the original data back. Unlike
    when using `SUB`, the data-restoring counterpart requires an algorithm that uses
    `ADD`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a quick demonstration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Assembly of data in other memory regions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is possible to execute data in a different memory region out of the process'
    image space. Similar to how code was executed at the stack space, memory spaces,
    such as the heap and newly allocated space, can be used to manipulate data and
    run the code. This is a common technique used not only by malware, but also by
    legitimate applications.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing the heap requires calling APIs, such as `HeapAlloc` (Windows) or generally
    `malloc` (Windows and Linux). A default heap space is given for every process
    created. `Heap` is generally used when asking for a small chunk of memory space.
    The maximum size of a heap varies between operating systems. If the requested
    size of the memory space being requested for allocation doesn't fit the current
    heap space, `HeapAlloc` or `malloc` internally calls for `VirtualAlloc` (Windows)
    or `sbrk` (Linux) functions. These functions directly requests memory space from
    the operating system's memory manager.
  prefs: []
  type: TYPE_NORMAL
- en: Allocated memory space have defined access permissions. Just like how the segments
    of a program are used, these can generally have read, write, and execute permissions.
    If the region requires code execution, the read and execute permission should
    be set.
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following code snippet with an implementation of decrypting data
    to the heap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The code allocates `1000h` bytes of heap space, then copies `1BEh` bytes of
    data from the address at `0x00403018` to the allocated heap. The decryption loop
    can easily be identified in this code.
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm uses `XOR` with a key value of `58h`. The data size is `1BEh`
    and the data is directly updated at the same allocated heap space. The iteration
    is controlled using the `ECX` register, while the location of the encrypted data,
    which is at the heap address, is stored in the `ESI` register.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see what gets decrypted using debugging tools.
  prefs: []
  type: TYPE_NORMAL
- en: Decrypting with x86dbg
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The preceding code snippet came from the `HeapDemo.exe` file. You can download
    this file from [https://github.com/PacktPublishing/Mastering-Reverse-Engineering/tree/master/ch9](https://github.com/PacktPublishing/Mastering-Reverse-Engineering/tree/master/ch9).
    Go ahead and start debugging the file using `x86dbg`. This screenshot shows the
    disassembly code at the `WinMain` function right after loading the file in `x86dbg`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/763f9026-3249-4526-85bd-a5197151b51f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'From the executable''s code entry point, we encounter heap allocation with
    the `GetProcessHeap` and `RtlAllocateHeap` APIs. This is followed by using a `_memcpy`
    function, which copies `0x1BE` bytes of data from the address denoted by `heapdemo.enc`.
    Let''s take a look at the memory dump from `heapdemo.enc`. To do that, right-click
    on `push <heapdemo.enc>`, then select Follow in Dump. Click on the given address,
    not the Selected Address. This should change the contents in the currently focused
    `Dump` window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/004d99c5-8563-4e1f-aa64-3b63bbb06045.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This should be the data that will be decrypted by the next lines of code that
    run in a loop. We should also see the same encrypted data at the allocated heap
    space right after executing `_memcpy`. The allocated heap space''s address should
    still be stored in the register `ESI`. Right-click on the value of register `ESI`
    in the window containing a list of registers and flags, then select Follow in
    Dump. This should show the same contents of data, but at the heap address space.
    The dump shown in the following screenshot is the encrypted data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d407fd77-d4b3-43cc-9748-d6939d5804db.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now for the interesting part—decrypting. While looking at the dump of the heap,
    continue doing debug steps. You should notice the values changing as the `xor
    byte ptr ds:[ecx+esi], 58` instruction executes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e4148734-f0aa-4ca0-8822-dc39ea9c733d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As it would be tedious to step through all these bytes for 0x1BE times, we
    can simply place a break point at the line after the `jl` instruction and press
    *`F9`* to continue running the instructions. This should result in this decrypted
    dump:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1983a2a2-3307-44ff-a575-e7f6e1414f0b.png)'
  prefs: []
  type: TYPE_IMG
- en: Continue debugging the code; it concludes by cleaning up the allocated heap
    and exiting the process. The allocated heap is freed up using the `HeapFree` API.
    Usually, an `ExitProcess` API is used to exit the program. This time, it uses
    `GetCurrentProcess` and `TerminateProcess` to do that.
  prefs: []
  type: TYPE_NORMAL
- en: Other obfuscation techniques
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The obfuscation techniques we discussed are based on hiding actual strings and
    code using simple cryptography. Still, there are other ways to obfuscate code.
    As long as the concept of impeding data and code from easy extraction and analysis
    is present, then obfuscation still occurs. Let's discuss some more obfuscation
    techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Control flow flattening obfuscation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The aim of control flow flattening is to make a simple code look like a complicated
    set of conditional jumps. Let''s consider this simple code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'When obfuscated using the control flow flattening method, it would look something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The obfuscated code would ultimately have the same result as the original code.
    In a control flow flattening obfuscation, the flow of code is guided by a control
    variable. In the preceding code, the control variable is the `EBX` register. To
    graphically view the difference, here''s how the original code looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9bcdc348-3fef-44fc-a572-3adc139e659d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'And here is how the code looks when obfuscation is applied:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b34baec3-bb40-42c2-b5ee-7ba7d4b08444.png)'
  prefs: []
  type: TYPE_IMG
- en: The code is placed in a loop while being controlled with the value set in the
    control variable, the `EBX` register. Every block of code has an ID. Before leaving
    the first block of code, the control variable is set with the ID of the second
    block of code. The flow loops around again, goes into the second block of code,
    and before leaving, it is set with the ID of the third block of code. The sequence
    goes on until the final block of code executes. Conditions in the block of code
    can set the control variable with the block ID it chooses to go to next. In our
    previous code the loop only iterates twice before it ends.
  prefs: []
  type: TYPE_NORMAL
- en: Looking at the two preceding diagrams, we can see how a simple code can look
    complicated when obfuscated. As a reverse engineer, the challenge is how to spot
    a complicated code being reduced to a more understandable code. The trick here
    is to identify if a control variable exists.
  prefs: []
  type: TYPE_NORMAL
- en: Garbage code insertion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Garbage code insertion is a cheap way of making code look complicated. A code
    is simply injected with a code or a sequence of code that actually does nothing.
    In the following code snippet, try to identify all of the garbage codes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Removing the garbage codes should reduce it down to this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: A lot of malware employs this technique to quickly generate variants of its
    own code. It may increase the size of code, but as a result, it makes it undetectable
    by signature-based anti-malware software.
  prefs: []
  type: TYPE_NORMAL
- en: Code obfuscation with a metamorphic engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A program can be coded in different ways. To "increment the value of a variable"
    means adding one to it. In assembly language, `INC EAX` would also be equivalent
    to `ADD EAX`, `1`. The concept of replacing the same instruction or set of instructions
    with an equivalent instruction relates to metamorphism.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few examples of code that can be interchanged with each other:'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: This concept was introduced in computer viruses that are able to infect files
    with a different generation of itself. The computer viruses in which this concept
    was introduced were Zmist, Ghost, Zperm, and Regswap. The challenge that the metamorphic
    engines in these viruses face is to make the infected files still work like the
    original and prevent them from being corrupted.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, how does metamorphic code differ from a polymorphic code? First off, both
    techniques were brought up to thwart anti-virus software from detecting several
    generations of malware. Anti-virus software usually detects malware using signatures.
    These signatures are unique sequences of bytes found in the malware file. To prevent
    the anti-virus from further detection, encryption is used to hide the whole virus
    code, or portions of it. A stub code responsible for decrypting the self-encrypted
    code of the virus. The following diagram shows a representation of the file generations
    of a polymorphic virus:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/77a15534-d976-46f5-abb8-13c184497a61.png)'
  prefs: []
  type: TYPE_IMG
- en: As we can see, the stub usually comes with the same code, but the key changes.
    This leaves the encrypted code different from the previous generation. In the
    preceding diagram, we depicted the difference by changing the encrypted code's
    color. If a code involves decryption and encryption, it can be called a polymorphic
    code. Some anti-virus software employs the use of code emulation or adds specific
    decryption algorithms to decrypt the virus code, enabling the signatures to be
    matched for detection.
  prefs: []
  type: TYPE_NORMAL
- en: 'For metamorphic code, no encryption is involved.  The concept is about substituting
    a code with a different code that results with the same behavior. For each generation
    of the virus code, the code changes. A polymorphic code can easily be identified
    because of the stub code. But easy identification of metamorphic code is impossible,
    since it would just look like a regular set of code. Here''s a representation
    of, file generations of a metamorphic code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8e178633-5236-4589-a2e6-ce7b8c24f47f.png)'
  prefs: []
  type: TYPE_IMG
- en: All these metamorphic generation will yield the same result retaining its code
    sequence. It is hard for anti-virus signatures to detect metamorphic viruses,
    since the code itself changes. Metamorphic code can only be identified by comparing
    two variations. In metamorphic viruses, the generation of new code involves a
    metamorphic engine, which comes along with the code itself. Even the engine's
    lines of code themselves can be modified.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic library loading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: During static analysis, we can immediately see imported functions that are available
    for the program's use. It is possible to only see two API functions in the import
    table, but have the program use dozens of APIs. In Windows, these two API functions
    are `LoadLibrary` and `GetProcAddress`, while in Linux, these are `dlopen` and
    `dlsym`.
  prefs: []
  type: TYPE_NORMAL
- en: '`LoadLibrary` only requires the name of the library where the desired API function
    name is located. `GetProcAddress` is then responsible for retrieving the address
    of the API function from the library with that API name. With the library loaded,
    a program can call the API function using the API''s address.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet demonstrates how dynamic library loading is done.
    The code eventually displays a "`hello world` message box:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Some programs have the text strings encrypted, including the name of the API
    functions, and get decrypted at runtime before doing dynamic import. This prevents
    tools such as `Strings` or `BinText` from listing down the APIs that the program
    might use. An analyst would be able to see these loaded functions while doing
    debug sessions.
  prefs: []
  type: TYPE_NORMAL
- en: Use of PEB information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Process Environment Block** (**PEB**) contains useful information about
    the running process. This includes the list of modules loaded for the process,
    the chain of **Structured Error Handlers** (**SEH**), and even the program's command
    line parameters. Instead of using API functions, such as  `GetCommandLine` and
    `IsDebuggerPresent`, here, the obfuscation technique directly reads this information
    from PEB.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, the `IsDebuggerPresent` API contains the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/32dda516-68e4-4e8c-847e-e3a2474b0b0b.png)'
  prefs: []
  type: TYPE_IMG
- en: Using the following code alone will return a value of `1` or `0` in the `EAX` register.
    It is in the FS segment where the `PEB` and **Thread Information Block** (**TIB**)
    are found. This code shows that the debug flag can be found at offset `2` of the
    `PEB`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: There are different ways for an obfuscation to be implemented. It can be implemented
    based on the creativity of the developer. As long as the goal of concealing the
    obvious is present, it will make it hard for reverse engineers to analyze the
    binary. A better understanding of various obfuscation techniques will definitely
    helps us overcome the analysis of complicated code during reversing.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have understood what obfuscation is all about. As a means
    of hiding data, simple cryptography is one of the most commonly used techniques.
    Identifying simple decryption algorithms requires looking for the cipher key,
    the data to decrypt, and the size of the data. After identifying these decryption
    parameters, all we need to do is place a breakpoint at the exit point of the decryption
    code. We can also monitor the decrypted code using the memory dump of the debugging
    tool.
  prefs: []
  type: TYPE_NORMAL
- en: We cited a few methods used in obfuscation, such as control flow flattening,
    garbage code insertion, metamorphic code, dynamically importing API functions,
    and directly accessing the process information block. Identifying obfuscated codes
    and data helps us overcome the analysis of complicated code. Obfuscation was introduced
    as a way to conceal information.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll continue introducing the same concept, but in particular,
    we'll look how they are implemented in an executable file using Packer tools and
    encryption.
  prefs: []
  type: TYPE_NORMAL
