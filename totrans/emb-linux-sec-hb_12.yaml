- en: '12'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Are My Devices’ Communications and Interactions Secure?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It can be said that the only really secure computer is one that is powered off
    and locked away in a vault. There’s no fun nor usability in that so we must determine
    appropriate measures to limit exposure to vulnerabilities while still having the
    system be usable for the mission it was intended for.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn how to determine the use cases and limitations
    of commonly used external buses for hardware communication. We’ll review network
    security with firewalls. We’ll work through some hands-on exercises in locking
    down your web-based services with SSL certificates. We will dive into the gotchas
    of legacy hardware and software and close out this chapter with the security validation
    of your appliance.
  prefs: []
  type: TYPE_NORMAL
- en: “Why is this important to my project?” you may ask... Simply put, you might
    lock down the system itself incredibly well, however, that system’s connections
    to peripherals or other applications may not exactly be as secure as you might
    have thought. To be aware is to be forewarned.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main sections of this chapter are:'
  prefs: []
  type: TYPE_NORMAL
- en: Bus types and issues
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enhancing security with certificates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Confirming that your networking is secure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Limitations of legacy hardware and software
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validating your solution before shipping
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s move on to our first section, where we’ll take a look at different system
    buses.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To complete the exercises in this chapter, you will need root-level access to
    the web server you built as a custom DNF repository back in [*Chapter 5*](B22104_05.xhtml#_idTextAnchor179).
  prefs: []
  type: TYPE_NORMAL
- en: If you have deleted that server/work, you will need to build a new custom repository
    server as detailed in those previous exercises before beginning this exercise.
  prefs: []
  type: TYPE_NORMAL
- en: Bus types and issues
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, what is a **bus**? Most simply put, a bus is a type of communication channel
    to and from devices and your system’s CPU. With this channel, data signals from
    (or to) the device can be processed by the CPU. Without this line of communication,
    the attached device will not function.
  prefs: []
  type: TYPE_NORMAL
- en: A more layman’s way of describing a bus would be to break it down in the least
    technical of terms. Let’s look at the forest for the trees. In total, a bus is
    the culmination of hardware, software, and the cabling required to allow for data
    transmission. I’ll use a non-technical childhood example. Ever take two tin cans
    and some string to make a communications system? Those two cans were connected
    by a string that, when tightly stretched, carried your voice (i.e., the data)
    from one can (peripheral) to the other can (main processor) and was interpreted
    by the end-user on the receiving end.
  prefs: []
  type: TYPE_NORMAL
- en: '**Systems buses** do this in a vastly more technical manner, but the result
    is the same. Data travels from a peripheral to the CPU and gets processed. For
    my super technical readers, please let me go a little deeper. Various buses are
    in play when sensors, cameras, controls, or other directly attached peripherals
    are attached to a system and their interactions are transmitted through their
    connection medium and then, finally, received and processed by the system CPU.
    There are several standard buses, but in this chapter, we’ll cover the most important
    ones that you may come across while working with embedded Linux systems, and by
    that, I mean the **CAN bus** and **USB**. In the next few sections, we will focus
    on system buses (along with standard connection types and protocols) that leverage
    external connections to your hardware. As we continue, I want you to envision
    all things that may be able to connect to your solution, with or without your
    permission. Sometimes, as we previously inferred in the section about childproofing
    your solution within [*Chapter 10*](B22104_10.xhtml#_idTextAnchor305), you must
    almost assume the end-user is a toddler who might just shove their sandwich into
    the VCR. I know I’m dating myself by mentioning a VCR but it’s to make a point
    and I hope that point is well received. Plan for the worst, and hope for the best.'
  prefs: []
  type: TYPE_NORMAL
- en: What could possibly go wrong? Well, if your system uses an insecure bus or peripheral
    connection and a bad actor has physical access to said connection, it may be hijacked
    without your knowing (or worse). When insecure connections are leveraged, physical
    security must also be part of the design consideration and deployment plan.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s also hope that your awesome solution has a custom shell or case that covers
    up any ports you do not want the end-user to know are there. It’s rare when this
    is an option, but I felt the necessity to mention it. Plus, a custom case also
    makes a solution look better. Some even have built-in weather resistance. Let
    your use case guide your design.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: For an embedded Linux system, we’ll assume the case has a level of tamper-proofing
    even if it’s just a warning sticker that states all warranties are void if the
    case is opened. For this reason, we will not be covering system hardware internals
    like the well-known **PCI bus**... There are countless texts dedicated to that
    hardware and kernel development, so let’s stay focused on the external connections
    in play.
  prefs: []
  type: TYPE_NORMAL
- en: That all said, let’s move on to a household name. A bus and connection type
    we all know – **Universal Serial** **Bus** (**USB**).
  prefs: []
  type: TYPE_NORMAL
- en: USB
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since its initial introduction in 1996, the USB interface has been the worldwide
    standard connectivity method of choice for virtually all consumer devices. Modern
    USB ports have such versatility (depending on the device), which is why they are
    everywhere in daily life.
  prefs: []
  type: TYPE_NORMAL
- en: USB empowers computers to connect to mice, keyboards, storage devices, printers,
    gaming controllers, authentication keys, and many other types of commercial hardware.
    The same port can also charge some devices like cell phones, tablets, or portable
    power units. USB can even be used to add multiple displays to a system.
  prefs: []
  type: TYPE_NORMAL
- en: USB does not protect your data while in transit. Most people choose to encrypt
    USB-attached storage devices but by default when accessing the data or processing
    it. That data in transit is not encrypted. This limitation is not limited to Linux
    systems but all systems leveraging the USB framework.
  prefs: []
  type: TYPE_NORMAL
- en: There are some commercially available solutions to secure this data in transit;
    however, they are not open source and definitely not free. They are sold as enterprise-grade
    data loss prevention systems and support multiple platforms (not just Linux).
    You will need one of these third-party solutions if the securing of your data
    in transit to USB storage is an issue.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now move on to our next section where we will review USB connections.
  prefs: []
  type: TYPE_NORMAL
- en: USB connectors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The USB family of **connectors** has evolved over the years, but since the beginning
    and still to this day, USB-A might be the world’s most common connection interface
    ever created. It can be found in household wall outlets, PCs, laptops, external
    storage devices, on the back of passenger aircraft seats, in the dashboards of
    cars and recreational vehicles (RVs), solar generators, power banks, and so, so,
    so much more… (Yeah, I know that’s not grammatically correct but I really want
    to emphasize that USB-A is *E-V-E-R-Y-W-H-E-R-E !!*)
  prefs: []
  type: TYPE_NORMAL
- en: What’s ironic about USB is that virtually all the shown connectors are still
    being actively used today. Granted, there’s a difference in the quality of the
    materials used now vs. the older versions, but that’s there to simply allow for
    better data transfer rates. The cables themselves are not a security issue per
    se, as the issues reside in the chips and the USB bus itself. Let’s take a quick
    look at those connector types.
  prefs: []
  type: TYPE_NORMAL
- en: 'From left to right in the following figure, we have USB-B, USB-A, USB-mini,
    USB-micro, and USB-C:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.1 – USB connectors over the years](img/B22104_12_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.1 – USB connectors over the years
  prefs: []
  type: TYPE_NORMAL
- en: In pondering how to compare the various versions of the USB standard that you
    will come across, I felt it imperative to throw some critical data in a table
    format for ease of viewing. Although the connectors may all be compatible, the
    speeds and throughput of the different versions are vastly and mind-blowingly
    different.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a table of USB versions, performance, and connectors in use today:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **USB Version** | **Bandwidth** | **Data** **Transfer Speed** | **Connectors**
    |'
  prefs: []
  type: TYPE_TB
- en: '| USB4 | 20 or 40 Gbps | 2560–5120 MB/s | C |'
  prefs: []
  type: TYPE_TB
- en: '| USB 3.2 | 20 Gbps | 2560 MB/s | C |'
  prefs: []
  type: TYPE_TB
- en: '| USB 3.1 | 10 Gbps | 1280 MB/s | A, C |'
  prefs: []
  type: TYPE_TB
- en: '| USB 3.0 | 5 Gbps | 640 MB/s | A, B. C |'
  prefs: []
  type: TYPE_TB
- en: '| USB 2.0 | 480 Mbps | 60 MB/s | A, B, Mini, Micro |'
  prefs: []
  type: TYPE_TB
- en: '| USB 1.1 | 12 Mbps | 1.5 MB/s | A, B, Mini, Micro |'
  prefs: []
  type: TYPE_TB
- en: '| USB 1.0 | 1.5 Mbps | 1.5 MB/s | A, B, Mini, Micro |'
  prefs: []
  type: TYPE_TB
- en: Table 12.1 – Speed and capabilities of different USB versions
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from the above table, the wide range of connections of the USB
    standard has greatly evolved in the past 30 years. USB has been a game changer
    and a trendsetter and will continue onward for many more years to come. Let’s
    move on by looking at its predecessor, the serial bus, next.
  prefs: []
  type: TYPE_NORMAL
- en: Serial port
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Known for being notoriously insecure, **serial ports** have been providing text
    terminal access since the old Unix days. There are still many serial devices that
    are used every day. Keyboards and mice are still quite commonplace (nowadays using
    USB) and may also be part of your solution. Serial connections are still incredibly
    common for engineers to use from their laptops to networking equipment such as
    switches, firewalls, and routers. Today, that often requires an adapter device
    that connects to an engineer’s laptop via USB and then to a serial cable that
    connects to a serial port on the device to be managed. These devices will automatically
    establish connections once attached to your Linux system with no effort required
    from you.
  prefs: []
  type: TYPE_NORMAL
- en: 'Serial ports (more commonly called terminal ports) can be physical or virtual.
    Most physical serial connections today are auto-negotiated through the USB bus;
    however, on older systems, those devices may have used a PS2 connection or the
    older serial port otherwise known as **DB9**. Serial ports may also be used by
    industrial automation systems, printers, scanners, and some medical devices. The
    following figure shows the serial connection female connector (left) and the serial
    connection male (right):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.2 – Serial connector examples](img/B22104_12_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.2 – Serial connector examples
  prefs: []
  type: TYPE_NORMAL
- en: Linux systems can also have **virtual serial connections**. It’s important to
    know how your system is mapping these connections. First, why should you care?
    Well, this directly impacts how many terminal sessions can be directly established
    with your system concurrently. If your appliance is a console/text-based appliance,
    this metric is crucial in its management and control. In the simplest terms possible,
    this metric denotes how many doors can be opened at once. When not crucial to
    your appliance’s user experience, these TTY console sessions should be limited
    as much as possible without breaking the operation of the appliance.
  prefs: []
  type: TYPE_NORMAL
- en: To get a great sense of just how many TTY sessions your system starts at boot
    time, here’s an example command that will show you how your system has these ports
    named and mapped. Consider each one an open door that either should be locked,
    boarded up, or simply guarded.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how many TTY sessions are possible in our current system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The output for this one will definitely be lengthy so I have truncated it...
    What you will see will be an exhaustive list of physical and virtual terminal
    port possibilities.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Knowing how to track these connections is crucial for maintaining device security.
    Let’s move on to yet another bus that also uses the DB9 connector – the CAN bus.
  prefs: []
  type: TYPE_NORMAL
- en: The CAN bus
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Controller Area Network** (**CAN**) bus is a vehicular standard. Its main
    purpose is to control communication between **electronic control units** (**ECUs**).
    It was first introduced back in 1983; however, it still has no standard connector,
    although the DB9 connector seems to be a de facto standard today.
  prefs: []
  type: TYPE_NORMAL
- en: As cars nowadays are becoming rolling data centers (even the non-self-driving
    ones), I felt it important to mention this bus type as many manufacturers are
    jumping to build embedded systems in this evolving space.
  prefs: []
  type: TYPE_NORMAL
- en: However, CAN is not limited to automobiles. CAN bus architectures can be seen
    deployed in maritime environments, agricultural equipment, and even in large buildings
    to control elevators, escalators, and other building automation. It’s even being
    leveraged in modern robotics.
  prefs: []
  type: TYPE_NORMAL
- en: Sadly, CAN is not encrypted. Be mindful and be aware. Another problem with CAN
    is the lack of authentication. Ultimately, this means whoever can access the bus
    has control of the bus. All security be abandoned. What could possibly go wrong?
  prefs: []
  type: TYPE_NORMAL
- en: There’s a whole community around hacking cars’ control systems. Most who engage
    in this journey do so to squeeze a little more performance out of their own vehicle.
    No malicious intent there, just an engineer’s curiosity. That said, a bad actor
    could easily access a car’s locks, GPS records, or controls, or possibly conduct
    other malicious activities.
  prefs: []
  type: TYPE_NORMAL
- en: Another factor, just like with USB and serial, is that the lack of encryption
    means any credentials passed across the bus are done in plain text. Anyone watching
    traffic on the bus can see that data and potentially use it to do less than nice
    things.
  prefs: []
  type: TYPE_NORMAL
- en: As more and more vehicles rely on electronics to create a better driver’s experience,
    let’s hope that the CAN standard itself can get some much-needed security added
    in its next version.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s move on to a key component in setting up encryption – creating certificates.
  prefs: []
  type: TYPE_NORMAL
- en: Enhancing security with certificates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Certificates** are used for many facets of secure communications globally.
    Your hardware and software vendors often digitally sign their drivers and operating
    system packages. Trusted authorities use certificates to ensure you can safely
    use DNS and the internet. The list of use cases for certificates is significant.
    Generally, these security certificates are obtained through a global **certificate
    authority** (**CA**) organization. Many internet service providers (ISPs) also
    have the ability to grant their customers an SSL certificate.'
  prefs: []
  type: TYPE_NORMAL
- en: These shared system certificates enable things like NSS, TLS, OpenSSL, and applications
    to have a joint shared source of trust via a system certificate (trust anchor).
    Not having an SSL certificate will prevent you from using an encrypted web server.
  prefs: []
  type: TYPE_NORMAL
- en: There is also the ability in Linux to create a self-signed certificate. These
    are generally good enough for internal lab work but are considered insufficient
    in a production environment and definitely not a good idea for your product.
  prefs: []
  type: TYPE_NORMAL
- en: In thinking of where I can show you an example suitable for lab or demo usage,
    I came up with this thought, “Where might we consider using a certificate? Your
    DNF repository server?”
  prefs: []
  type: TYPE_NORMAL
- en: Let’s explore that thought with some hands-on exercises.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 1: Creating a self-signed certificate'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this hands-on exercise, we’ll create a self-signed certificate that we could
    possibly use to encrypt a web server. Let’s begin:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we’ll verify that the web server is hosting our repository as previously
    configured in [*Chapter 5*](B22104_05.xhtml#_idTextAnchor179).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: You’ll need to substitute your hostname or IP address that you configured for
    your system.
  prefs: []
  type: TYPE_NORMAL
- en: Confirm that the service is hosting your repository via your web browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.3 – Verifying your repository via a web browser](img/B22104_12_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.3 – Verifying your repository via a web browser
  prefs: []
  type: TYPE_NORMAL
- en: We will now begin setting up the environment by setting a system variable. For
    this next step, replace `<hostname>` with your system’s FQDN. As root, execute
    the following command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: .pem file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: openssl req -new -key ${ssl_name}.pem -out ${ssl_name}.csr
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You are about to be asked to enter information that will be incorporated
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: into your certificate request.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: What you are about to enter is what is called a Distinguished Name or a DN.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: There are quite a few fields but you can leave some blank
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For some fields there will be a default value,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If you enter '.', the field will be left blank.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '-----'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Country Name (2 letter code) [XX]:US
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: State or Province Name (full name) []:MA
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Locality Name (eg, city) [Default City]:Wilmington
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Organization Name (eg, company) [Default Company Ltd]:Embedded Security Book
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Organizational Unit Name (eg, section) []:Development
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Common Name (eg, your name or your server's hostname) []:bm02.local
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Email Address []:admin@bm02.local
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Please enter the following 'extra' attributes
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: to be sent with your certificate request
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: A challenge password []:EmbeddedBook
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: .csr file properly.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This CSR file is what you would be sending to your CA if you were procuring
    an enterprise SSL certificate. We can also leverage this to create a temporary
    self-signed certificate locally.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Let’s create a temporary cert that’s good for 90 days.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Your output should look something like the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: ls -l *<hostname>*
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: -rw-r--r--. 1 root root 2110 Aug 25 21:30 bm02.local.cert
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: -rw-r--r--. 1 root root 1850 Aug 25 21:22 bm02.local.csr
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: -rw-------. 1 root root 3272 Aug 25 21:12 bm02.local.pem
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Wow, wasn’t that easy?! You’ve now created your first self-signed server certificate.
    Please never use that in production unless there is no other way of securing your
    web service. Now that we’ve created our certificate, let’s put it to good use
    in our next exercise by attaching it to our web service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 2: Adding a certificate to your custom repository server'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we’ll install your previously created self-signed certificate
    into the web server you built previously to host your custom DNF repository. Once
    completed, the web server itself will default to leverage the HTTPS protocol versus
    the previous default of HTTP. The change in protocol means you’ll also need to
    ensure that the firewall rules have also been updated. Let’s get started.
  prefs: []
  type: TYPE_NORMAL
- en: As root, install `mod_ssl`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Your output may be lengthy, but it should look somewhat like this – I have truncated
    the output to save space.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: .pem file to the proper directory. Remember to substitute your own .pem file
    (mine is shown as an example).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: /etc/httpd/conf.d/ssl.conf file as root. Follow the instructions on which lines
    to uncomment and edit. When done with the listed changes, save and exit the editor.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Change this line to your own CRT file – mine is shown for example.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Change this line to your own PEM file – mine is shown for example.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '#SSLCertificateChainFile /etc/pki/tls/certs/server-chain.crt'
  prefs: []
  type: TYPE_NORMAL
- en: httpd service as root and test. Run the following commands as root.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: systemctl status httpd
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: ● httpd.service - The Apache HTTP Server
  prefs: []
  type: TYPE_NORMAL
- en: 'Loaded: loaded (/usr/lib/systemd/system/httpd.service; enabled; preset: disabled)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Drop-In: /usr/lib/systemd/system/service.d'
  prefs: []
  type: TYPE_NORMAL
- en: └─10-timeout-abort.conf
  prefs: []
  type: TYPE_NORMAL
- en: 'Active: active (running) since Sun 2024-08-25 22:14:15 EDT; 8s ago'
  prefs: []
  type: TYPE_NORMAL
- en: 'Docs: man:httpd.service(8)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Main PID: 4907 (httpd)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Status: "Started, listening on: port 443, port 80"'
  prefs: []
  type: TYPE_NORMAL
- en: 'Tasks: 178 (limit: 38323)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Memory: 16.2M (peak: 17.8M)'
  prefs: []
  type: TYPE_NORMAL
- en: 'CPU: 115ms'
  prefs: []
  type: TYPE_NORMAL
- en: 'CGroup: /system.slice/httpd.service'
  prefs: []
  type: TYPE_NORMAL
- en: ├─4907 /usr/sbin/httpd -DFOREGROUND
  prefs: []
  type: TYPE_NORMAL
- en: ├─4908 /usr/sbin/httpd -DFOREGROUND
  prefs: []
  type: TYPE_NORMAL
- en: ├─4909 /usr/sbin/httpd -DFOREGROUND
  prefs: []
  type: TYPE_NORMAL
- en: ├─4910 /usr/sbin/httpd -DFOREGROUND
  prefs: []
  type: TYPE_NORMAL
- en: ├─4911 /usr/sbin/httpd -DFOREGROUND
  prefs: []
  type: TYPE_NORMAL
- en: └─4912 /usr/sbin/httpd -DFOREGROUND
  prefs: []
  type: TYPE_NORMAL
- en: 'Aug 25 22:14:15 bm02.local systemd[1]: Starting httpd.service - The Apache
    HTTP Server...'
  prefs: []
  type: TYPE_NORMAL
- en: 'Aug 25 22:14:15 bm02.local (httpd)[4907]: httpd.service: Referenced but unset
    environment variable evaluates to an e>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Aug 25 22:14:15 bm02.local httpd[4907]: Server configured, listening on: port
    443, port 80'
  prefs: []
  type: TYPE_NORMAL
- en: https). Since we have used a self-signed certificate, your browser will definitely
    not like it, and it will make you confirm that you wish to proceed to that site.
    Some browsers are more forgiving than others (regardless of the operating system
    they are run on).Confirm in your browser window that you wish to continue by clicking
    the `https` and the self-signed cert.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.4 – SSL warning because of the self-signed certificate](img/B22104_12_04.jpg)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
- en: Figure 12.4 – SSL warning because of the self-signed certificate
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If all has worked as planned, you should have been able to get to your newly
    encrypted web server and the page should look something like this:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 12.5 – HTTPS main test page](img/B22104_12_05.jpg)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
- en: Figure 12.5 – HTTPS main test page
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Now let’s test the repository URL. Remember to use HTTPS (not HTTP) in the URL.
    You may be prompted with the same SSL cert warnings. Drive on and confirm it’s
    OK (substitute your own URL – mine is shown again as an example).
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.6 – Our custom DNF repository now uses HTTPS !!!](img/B22104_12_06.jpg)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
- en: Figure 12.6 – Our custom DNF repository now uses HTTPS !!!
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: So, now that we’ve walked through the creation of a self-signed certificate
    and then taken it to make our custom DNF repository SSL-enabled, I want to impart
    to you yet another consideration before we close.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: If your solution is going to use HTTPS, please build into your interface a way
    for the end-user to click a button and have this process automated for them. Even
    better, add in the option for the appliance to automatically ingest keys and a
    certificate from a CA in your interface as well. These efforts are in line with
    the tamper-proofing and user experience topics that were covered in [*Chapter
    10*](B22104_10.xhtml#_idTextAnchor305). We should always strive to provide our
    end-users with a positive user experience when using our appliance.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: In this section, we secured the HTTPS service with encryption and a certificate.
    Let’s move on to our next section, where we will review tools for securing all
    of the actual network connections to services and ports of your appliance.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Confirming that your networking is secure
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Almost all machines at some level communicate with other machines. In the embedded
    Linux systems space, this may not always be true. Some appliances are simply standalone
    solutions that are not connected to any network. In other use cases, the security
    posture of where they may reside might dictate that they are on a heavily restricted
    LAN segment that has limited access to other systems and no access whatsoever
    to the internet or other segments of the enterprise.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Network configuration and securitization are intrinsic to basic Linux systems
    administration. But we are not designing systems to reside within our own datacenter
    or network. We are building products that will reside in a customer’s ecosystem,
    whatever level of security that might entail. Our customers have placed a level
    of trust and responsibility in our hands to ensure that what we deliver to them
    is already locked down and secure. Oftentimes, more so than what their own limited
    staff might have had the skills to perform. That’s why they are buying your solution.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: In the next few blocks, we’ll very briefly cover command-line and graphical
    tools that I truly hope you already know. My reasoning is blunt and simple. Use
    what works for your team, your environment, and your company’s build chain style.
    I am actually hoping that this section is redundant and unnecessary for you. Even
    better if it actually helps a little. Let’s move on to do a quick review of how
    we can prepare our appliances (somewhat) for their new homes by using tools to
    secure what traffic may pass in our next section covering firewalls.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Firewalls
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Here’s a quick breakdown of some of the major settings groups for Linux firewalls:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Connection**: This is a defined *named* network connection.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Zone**: A firewalld zone is a predefined level of trust for you to leverage.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Interface**: This one is pretty self-explanatory. It’s the interface that
    you plan to apply new settings onto.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Services**: These are predefined services that can be made accessible. Having
    them predefined absolutely helps in the configuration process as memorizing every
    service to port mapping and whether it’s UDP or TCP can be daunting.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ports**: This is a fast way of defining multiple ports or ranges to make
    them accessible.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Configuration**: There are two possible selections for the state of the configuration
    that you may be editing – **runtime** and **permanent**. Runtime state changes
    are lost after a reboot or after a restart of the **firewalld** service.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**IPSets**: These are whitelists or blacklists that you can manage and easily
    deploy.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: There are several different ways of configuring a Linux firewall (firewalld).
    Let’s browse through some examples.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: The command line
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: The command-line tools for managing firewalls are virtually always installed
    for you when you build a new system. The main tool we’ll highlight here is **firewall-cmd**.
    As you can see from the *massively truncated* listing of all the possible settings,
    firewall-cmd is a feature-rich toolset. It can easily be scripted as well.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: For an example of all the options, one could run the following command in a
    terminal.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The output of that command is rather lengthy. I’d recommend that you study it
    on your own machine, pipe the output to the more or less command, and then page
    your way through it.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The command line is the greatest and most flexible way to set firewall parameters,
    but let’s be honest, it will take a bit of skill to master it. This methodology
    is the preferred method by sysadmins around the world as it can be scripted and
    easily repeated. It’s the ease of scripting that will aid your team greatly in
    making such functionality behind the scenes from the end-users of your solution.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Let’s take a look at some other alternative means to configure your firewall.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Web console
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: The **web console** has been evolving rapidly over the past few years by extending
    its basic sysadmin functionality to creating systems images or managing containers
    or virtual machines. The further enhancement of the web console has lowered the
    bar for admins of other platforms to get comfortable in the management of Linux
    systems when their skills were rooted in other platforms.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Here’s an example screenshot of the web console (aka Cockpit) running on Fedora
    40\. Under the **Networking** submenu, we can easily modify the firewall rules
    as well as configure connections and other networking settings.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 12.7 – Configuring a firewall via the web console](img/B22104_12_07.jpg)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
- en: Figure 12.7 – Configuring a firewall via the web console
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: The web console is great for configuring your own systems in a lab or datacenter
    environment; however, I strongly recommend avoiding this from being used by your
    end-users on your appliances as it will require administrative privileges to do
    most tasks… And now we’re back to the childproofing discussion again. Let’s move
    on to a quick review of graphical UI tools for your firewall.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Graphical UI-based tools
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: In Fedora (and most Linux distributions), there are actually multiple graphical
    firewall configuration tools. Any can be installed via the gnome-software application
    or via the command line. These tools make configuring and managing the firewall
    vastly easier than trying to memorize the thousands of options found within the
    command line.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Please note that when you search for tools to manage your firewall, gnome-software
    (the app store within the Gnome desktop) also offers up the web console (Cockpit)
    as a solution.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 12.8 – Searching for software via the gnome-software GUI](img/B22104_12_08.jpg)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
- en: Figure 12.8 – Searching for software via the gnome-software GUI
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Here’s what the firewall management GUI looks like while running it within the
    Gnome desktop environment GUI.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 12.9 – The firewall GUI](img/B22104_12_09.jpg)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
- en: Figure 12.9 – The firewall GUI
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: My stance on these GUI-based firewall tools is the same as with the web console.
    They’re great in the datacenter and the lab but I wouldn’t give an end-user of
    an appliance access to them. Ever. Seriously.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Should your appliance provide services that may require the end-user to open
    additional ports on your appliance, you should automate and build into your interface
    anything that might possibly require the end-user to have root access – just like
    we covered in depth in [*Chapter 10*](B22104_10.xhtml#_idTextAnchor305). This
    isn’t just tamper-proofing. You should think of it as futureproofing, or even
    better, enhancing the user experience.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Honestly, it’s doubtful anyone will actually care which tools you used or didn’t
    use to configure your appliance. Here’s where we shift from configuring the firewall
    to confirming that what you think you’ve configured is the actual state of your
    appliance. This is where I (again) remind you of that old saying, *Trust, but
    verify*. Trust in your team’s efforts but verify that what you think you have
    configured is what the appliance’s state actually is. I greatly recommend automating
    this where you find it appropriate, but make sure that human hands still touch
    the appliance, human eyes inspect the appliance, and all is well documented for
    each unit.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Let’s move on to activities that should always be religiously enacted at the
    end of your build or upgrade cycles. Let’s review the validation of your solution.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Limitations of legacy hardware and software
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Here’s where I feel compelled to deliver some bad news. You may not always have
    a choice in which hardware, connectivity methods, or buses your solution leverages.
    The long-term supportability of your solution may force you and your team to implement
    something less than ideal in order to maintain backward and forward compatibility
    (a perfect example is the CAN bus).
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Older, legacy hardware wouldn’t be so bad if there wasn’t a common practice
    for deprecating driver support for extremely old or unsupported chipsets. This
    means that one could be forced to use unsupported drivers that are not included
    in your operating system, that may not have been updated for a significant amount
    of time, or that come from an unreliable source. Unsupported drivers (software)
    may also mean that there are risks and vulnerabilities that are not addressed.
    It’s a ticking time bomb.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: A compounding problem is that newer operating systems tend to require much newer
    components. It seems that with each new release of Linux (regardless of distribution),
    we get vastly more capabilities and functions. These new bells and whistles come
    with a price tag – newer, more powerful hardware.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Why does using the most current hardware and software matter? Here’s a real-world
    example: most cars, short of catastrophic accidents, can realistically be on the
    road for many years and outlive their computer subsystems’ normal lifecycle. That’s
    just one example among countless possibilities.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Security starts at the design table, but that doesn’t mean that you’ll always
    have the best components (hardware or software) to choose from. Keep in mind there
    will be limits.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Validating your solution before shipping
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: As we have progressed in our journey to secure our solution as much as possible,
    there are still some critical activities that must be completed before you can
    confidently ship your solution. These should be considered non-negotiable. Ignore
    them at your peril.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: First is compliance integrations and testing, where you’ll confirm that your
    appliance meets or exceeds any government or industry standards that may be applicable
    within the domain it will be used. I feel this is such a crucial subject, that
    the entire next chapter is dedicated to it entirely.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Secondly, **penetration testing** (aka **pen-testing**) by a third party can
    give you peace of mind and detailed insights as to anything you may have overlooked.
    In this scenario, a professional ethical hacker (contractor) would leverage all
    the tools of the trade in an attempt to gain unauthorized access or degrade the
    usability of the appliance. Passing this type of testing will be a testament to
    your team’s success and the brightness of your product’s future.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Let’s move on to our end-of-chapter summary.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: What is attached to your solution and what it communicates with absolutely matters.
    These communications will also dictate what security concerns need to be addressed
    proactively. In this chapter, we’ve toured a key group of buses and connection
    types that you are most likely to encounter along with their unique use cases.
    As we progressed, we reviewed a critical set of securitizations – your firewall
    and encryption for your web traffic. These activities require a special amount
    of attention to detail. The knowledge gained in this chapter should empower you
    and your team to prepare for and design for such connectivity risks. We then closed
    out the chapter with a simple reminder that you may have to worry about forward
    and backward compatibility, which will impact your security profile.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Again, I’d like to thank you for continuing this journey with me. In the next
    chapter, we’ll be diving headfirst into applying security standards to our solutions.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
