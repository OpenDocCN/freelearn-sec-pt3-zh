<html><head></head><body>
        

                            
                    <h1 class="header-title">The Go Programming Language</h1>
                
            
            
                
<p>Before diving into the more complex examples of using Go for security, it is important to have a solid foundation. This chapter provides an overview of the Go programming language so that you have the knowledge necessary to follow the subsequent examples.</p>
<p>This chapter is not an exhaustive treatise of the Go programming language, but will give you a solid overview of the major features. The goal of this chapter is to provide you with the information you need to understand and follow the source code if you have never used Go before. If you are already familiar with Go, this chapter should be a quick and easy review of things you already know, but perhaps you will learn a new piece of information.</p>
<p>This chapter specifically covers the following topics:</p>
<ul>
<li>The Go language specification</li>
<li>The Go playground</li>
<li>A tour of Go</li>
<li>Keywords</li>
<li>Notes about source code</li>
<li>Comments</li>
<li>Types</li>
<li>Control structures</li>
<li>Defer</li>
<li>Packages</li>
<li>Classes</li>
<li>Goroutines</li>
<li>Getting help and documentation</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Go language specification</h1>
                
            
            
                
<p>The entire Go language specification can be found online at <a href="https://golang.org/ref/spec">https://golang.org/ref/spec</a>. Much of the information in this chapter comes from the specification, as this is the one true documentation of the language. The rest of the information here is short examples, tips, best practices, and other things that I have learned during my time with Go.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The Go playground</h1>
                
            
            
                
<p>The Go playground is a website where you can write and execute Go code without having to install anything. In the playground, <a href="https://play.golang.org">https://play.golang.org</a>, you can test pieces of code to explore the language and fiddle with things to understand how the language works. It also allows you to share your snippet by creating a unique URL that stores your snippet. Sharing code through the playground can be much more helpful than a plaintext snippet, since it allows the reader to actually execute the code and tinker with the source if they have any questions about how it works:</p>
<div><img height="220" width="430" src="img/d5514c8a-7253-4641-8b61-3e02ebcac15e.png"/></div>
<p>The preceding screenshot shows a simple program being run in the playground. There are buttons at the top to run, format, add import statements, and share the code with others.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">A tour of Go</h1>
                
            
            
                
<p>Another resource provided by the Go team is <em>A Tour of Go</em>. This website, <a href="https://tour.golang.org">https://tour.golang.org</a>, is built on top of the playground mentioned in the previous section. The tour was my first introduction to the language, and when I completed it, I felt well-equipped to start tackling projects in Go. It walks you through the language step by step along with working code examples so that you can run and modify the code to get familiar with the language. It is a practical way to introduce a newcomer to Go. If you have never used Go at all, I encourage you to check it out.</p>
<div><img height="439" width="858" src="img/155646d8-315b-4b13-aa31-c7be08feb713.png"/></div>
<p>The preceding screenshot shows the first page of the tour. On the right-hand side, you will have a small embedded playground with the code sample relevant to the short lesson shown on the left-hand side. Each lesson comes with a short code example that you can run and tinker with.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Keywords</h1>
                
            
            
                
<p>To emphasize how simple Go is, here is a breakdown of all its 25 keywords. You probably already know most of them if you are familiar with other programming languages. The keywords are grouped together to examine them according to their use.</p>
<p><strong>Data types</strong>:</p>
<table>
<tbody>
<tr>
<td>
<p><kbd>var</kbd></p>
</td>
<td>
<p>This defines a new variable</p>
</td>
</tr>
<tr>
<td>
<p><kbd>const</kbd></p>
</td>
<td>
<p>This defines a constant value that does not change</p>
</td>
</tr>
<tr>
<td>
<p><kbd>type</kbd></p>
</td>
<td>
<p>This defines a new data type</p>
</td>
</tr>
<tr>
<td>
<p><kbd>struct</kbd></p>
</td>
<td>
<p>This defines a new structured data type that contains multiple variables</p>
</td>
</tr>
<tr>
<td>
<p><kbd>map</kbd></p>
</td>
<td>
<p>This defines a new map or hash variable</p>
</td>
</tr>
<tr>
<td>
<p><kbd>interface</kbd></p>
</td>
<td>
<p>This defines a new interface</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p><strong>Functions</strong>:</p>
<table>
<tbody>
<tr>
<td>
<p><kbd>func</kbd></p>
</td>
<td>
<p>This defines a new function</p>
</td>
</tr>
<tr>
<td>
<p><kbd>return</kbd></p>
</td>
<td>
<p>This exits a function, optionally returning values</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p><strong>Packages</strong>:</p>
<table>
<tbody>
<tr>
<td>
<p><kbd>import</kbd> </p>
</td>
<td>
<p>This imports an external package in the current package</p>
</td>
</tr>
<tr>
<td>
<p><kbd>package</kbd></p>
</td>
<td>
<p>This specifies what package a file belongs to</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p><strong>Program flow</strong>:</p>
<table>
<tbody>
<tr>
<td>
<p><kbd>if</kbd></p>
</td>
<td>
<p>This is used for branch execution based on a condition that is true</p>
</td>
</tr>
<tr>
<td>
<p><kbd>else</kbd></p>
</td>
<td>
<p>This is used for a branch if a condition is not true</p>
</td>
</tr>
<tr>
<td>
<p><kbd>goto</kbd></p>
</td>
<td>
<p>This is used to jump directly to a label; it is rarely used and not encouraged</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p><strong>Switch statements</strong>:</p>
<table>
<tbody>
<tr>
<td>
<p><kbd>switch</kbd></p>
</td>
<td>
<p>This is used to branch based off of a condition</p>
</td>
</tr>
<tr>
<td>
<p><kbd>case</kbd></p>
</td>
<td>
<p>This defines the condition for the <kbd>switch</kbd> statement</p>
</td>
</tr>
<tr>
<td>
<p><kbd>default</kbd></p>
</td>
<td>
<p>This defines default execution when no case is matched</p>
</td>
</tr>
<tr>
<td>
<p><kbd>fallthrough</kbd></p>
</td>
<td>
<p>This is used to continue executing the next case</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p><strong>Iteration</strong>:</p>
<table>
<tbody>
<tr>
<td><kbd>for</kbd></td>
<td>
<p>The <kbd>for</kbd> loop can be used like in C, where you provide three expressions: the initializer, the condition, and the incrementer. In Go, there is no <kbd>while</kbd> loop and the <kbd>for</kbd> keyword takes on the role of both <kbd>for</kbd> and <kbd>while</kbd>. A <kbd>for</kbd> loop can be used just like a <kbd>while</kbd> loop if one expression, the condition, is passed.</p>
</td>
</tr>
<tr>
<td><kbd>range</kbd></td>
<td>The <kbd>range</kbd> keyword is used with a <kbd>for</kbd> loop to iterate over a map or slice.</td>
</tr>
<tr>
<td><kbd>continue</kbd></td>
<td>The <kbd>continue</kbd> keyword will skip any execution left in the current loop and jump directly to the next iteration.</td>
</tr>
<tr>
<td><kbd>break</kbd></td>
<td>The <kbd>break</kbd> keyword will immediately exit the <kbd>for</kbd> loop completely, skipping any remaining iterations.</td>
</tr>
</tbody>
</table>
<p> </p>
<p class="mce-root"><strong>Concurrency</strong>:</p>
<table>
<tbody>
<tr>
<td>
<p><kbd>go</kbd></p>
</td>
<td>
<p>Goroutines are lightweight threads built in to the language. You simply put the <kbd>go</kbd> keyword in front of a call to a function and Go will execute that function call in a separate thread.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>chan</kbd></p>
</td>
<td>
<p>To communicate between threads, channels are used. Channels are used to send and receive specific data types. They are blocking by default.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>select</kbd></p>
</td>
<td>
<p>The <kbd>select</kbd> statements allow channels to be used in a nonblocking fashion.</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p><strong>Convenience</strong>:</p>
<table>
<tbody>
<tr>
<td>
<p><kbd>defer</kbd></p>
</td>
<td>
<p>The <kbd>defer</kbd> keyword is a relatively unique keyword that I have not previously encountered in other languages. It allows you to specify a function to be called later when the surrounding function returns. It is useful when you want to ensure some type of cleanup action whenever the current function ends, but you are not sure when or where it might return. A common use case is to defer a file closure.</p>
</td>
</tr>
</tbody>
</table>


            

            
        
    

        

                            
                    <h1 class="header-title">Notes about source code</h1>
                
            
            
                
<p>Go source code files should have the <kbd>.go</kbd> extension. The source code of Go files is encoded in UTF-8 Unicode. This means that you can use any Unicode characters in your code, like hardcoding Japanese characters in a string.</p>
<p>Semicolons are optional at the end of a line and typically omitted. Semicolons are only required when separating multiple statements or expressions on a single line.</p>
<p>Go does have a code formatting standard which can easily be adhered to by running <kbd>go fmt</kbd> on source code files. The code formatting should be followed, but it is not strictly enforced by the compiler the way Python requires exact formatting to execute properly.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Comments</h1>
                
            
            
                
<p>Comments follow a C++ style allowing the double slash and the slash-asterisk wrapped style:</p>
<pre>// Line comment, everything after slashes ignored
/* General comment, can be in middle of line or span multiple lines */</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Types</h1>
                
            
            
                
<p>The built-in data types are named intuitively enough. Go comes with a set of integer and unsigned integer types with varying bit lengths. There are also floating point numbers, Booleans, and strings, which should come as no surprise.</p>
<p>There are a few types like runes that are not common in other languages. This section covers all of the different types.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Boolean</h1>
                
            
            
                
<p>The Boolean type represents a true or false value. Some languages don't provide a <kbd>bool</kbd> type, and you have to use an integer or define your own enumeration, but Go conveniently comes with a predeclared <kbd>bool</kbd> type. The <kbd>true</kbd> and <kbd>false</kbd> constants are also predefined and used in all lowercase. Here is an example of creating a Boolean:</p>
<pre>var customFlag bool = false  </pre>
<p>The <kbd>bool</kbd> type is not unique to Go by any means, but one interesting piece of trivia about the Boolean type is that it's the only type named after a person. George Boole lived from 1815 to 1864 and wrote <em>The Laws of Thought</em>, where he described Boolean algebra, which is what all digital logic is based upon. The <kbd>bool</kbd> type is very simple in Go, but the history behind the name is very rich.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Numeric</h1>
                
            
            
                
<p>The primary numeric data types are integers and floating point numbers. Go also offers a complex number type, a byte type, and a rune. Here are the numeric data types available in Go.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Generic numbers</h1>
                
            
            
                
<p>These generic types can be used when you don't particularly care about whether a number is 32- or 64-bits. The largest available size will automatically be used, but will be compatible with 32- and 64-bit processors.</p>
<ul>
<li><kbd>uint</kbd>: This is an unsigned integer of either 32 or 64 bits</li>
<li><kbd>int</kbd>: This is a signed integer with the same size as <kbd>uint</kbd></li>
<li><kbd>uintptr</kbd>: This is an unsigned integer to store a pointer value</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Specific numbers</h1>
                
            
            
                
<p>These numeric types specify the bit length and whether it has a sign bit to determine positive or negative values. The bit length will determine the maximum range. Signed integers have the range reduced by one bit because the last bit is reserved for the sign.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Unsigned integers</h1>
                
            
            
                
<p>Using <kbd>uint</kbd> without a number generally chooses the largest size for your system, typically 64 bits. You can also specify one of the four specific <kbd>uint</kbd> sizes:</p>
<ul>
<li><kbd>uint8</kbd>: Unsigned 8-bit integer (0 to 255)</li>
<li><kbd>uint16</kbd>: Unsigned 16-bit integer (0 to 65535)</li>
<li><kbd>uint32</kbd> : Unsigned 32-bit integer (0 to 4294967295)</li>
<li><kbd>uint64</kbd>: Unsigned 64-bit integer (0 to 18446744073709551615)</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Signed integers</h1>
                
            
            
                
<p>Like unsigned integers, you can use <kbd>int</kbd> by itself to choose the best default size, or specify one of these four specific <kbd>int</kbd> sizes:</p>
<ul>
<li><kbd>int8</kbd>: 8-bit integer (-128 to 127)</li>
<li><kbd>int16</kbd>: 16-bit integer (-32768 to 32767)</li>
<li><kbd>int32</kbd>: 32-bit integer (-2147483648 to 2147483647)</li>
<li><kbd>int64</kbd>: 64-bit integer (-9223372036854775808 to 9223372036854775807)</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Floating point numbers</h1>
                
            
            
                
<p>The floating point type does not have a generic type, and must be one of these two options:</p>
<ul>
<li><kbd>float32</kbd>: IEEE-754 32-bit floating-point number</li>
<li><kbd>float64</kbd>: IEEE-754 64-bit floating-point number</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Other numeric types</h1>
                
            
            
                
<p>Go also provides a complex number for advanced mathematical applications, and a few aliases for conveniences:</p>
<ul>
<li><kbd>complex64</kbd>: Complex number with <kbd>float32</kbd> real and imaginary parts</li>
<li><kbd>complex128</kbd>: Complex number with <kbd>float64</kbd> real and imaginary parts</li>
<li><kbd>byte</kbd>: Alias for <kbd>uint8</kbd></li>
<li><kbd>rune</kbd>: Alias for <kbd>int32</kbd></li>
</ul>
<p>You can define numbers in the decimal, octal, or hexadecimal format. Decimal or base-ten numbers need no prefix. Octal or base-eight numbers should be prefixed with a zero. Hexadecimal or base-sixteen numbers should be prefixed with a zero and an x.</p>
<p>You can read more about the octal numeral system at <a href="https://en.wikipedia.org/wiki/Octal">https://en.wikipedia.org/wiki/Octal</a>, decimal at <a href="https://en.wikipedia.org/wiki/Decimal">https://en.wikipedia.org/wiki/Decimal</a>, and hexadecimal at <a href="https://en.wikipedia.org/wiki/Hexadecimal">https://en.wikipedia.org/wiki/Hexadecimal</a>.</p>
<p>Note that numbers are stored as integers, and there are no differences between them except for how they are formatted in the source code for the human. Octal and hexadecimal can be useful when working with binary data. Here is a short example of how to define integers:</p>
<pre>package main<br/><br/>import "fmt"<br/><br/>func main() {<br/>   // Decimal for 15<br/>   number0 := 15<br/><br/>   // Octal for 15<br/>   number1 := 017 
<br/>   // Hexadecimal for 15<br/>   number2 := 0x0F<br/><br/>   fmt.Println(number0, number1, number2)<br/>} </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">String</h1>
                
            
            
                
<p>Go comes with a <kbd>string</kbd> type as well as a <kbd>strings</kbd> package with a suite of useful functions such as <kbd>Contains()</kbd>, <kbd>Join()</kbd>, <kbd>Replace()</kbd>, <kbd>Split()</kbd>, <kbd>Trim()</kbd>, and <kbd>ToUpper()</kbd>. There is additionally a <kbd>strconv</kbd> package dedicated to converting various data types to and from strings. You can read more about the <kbd>strings</kbd> package at <a href="https://golang.org/pkg/strings/">https://golang.org/pkg/strings/</a>, and the <kbd>strconv</kbd> package at <a href="https://golang.org/pkg/strconv/">https://golang.org/pkg/strconv/</a>.</p>
<p>Double quotes are used for strings. Single quotes are used only for an individual character or runes, not strings. Strings can be defined using the long form or short form with the declare-and-assign operator. You can also use the <kbd>`</kbd> (backticks) symbol to encapsulate strings that span multiple lines. Here is a short example of string usage:</p>
<pre>package main<br/><br/>import "fmt"<br/><br/>func main() {<br/>   // Long form assignment<br/>   var myText = "test string 1"<br/><br/>   // Short form assignment<br/>   myText2 := "test string 2"<br/><br/>  
   // Multiline string<br/>   myText3 := `long string<br/>   spanning multiple<br/>   lines` 
<br/>   fmt.Println(myText) 
   fmt.Println(myText2) 
   fmt.Println(myText3)<br/>} </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Array</h1>
                
            
            
                
<p>Arrays are made up of sequenced elements of a specific type. An array can be created for any data type. The length of an array cannot be changed and must be specified at the time of declaration. Arrays are seldom used directly, but are used mostly through the slice type covered in the next section. Arrays are always one-dimensional, but you can create an array of arrays to create multidimensional objects.</p>
<p>To create an array of 128 bytes, this syntax can be used:</p>
<pre>var myByteArray [128]byte  </pre>
<p>Individual elements of an array can be accessed by its 0-based numeric index. For example, to get the fifth element from the byte array, the syntax is as follows:</p>
<pre>singleByte := myByteArray[4]</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Slice</h1>
                
            
            
                
<p>Slices use arrays as the underlying data type. The main advantage is that slices can be resized, unlike arrays. Think of slices as a viewing window in to an underlying array. The <strong>capacity</strong> refers to the size of the underlying array, and the maximum possible length of a slice. The <strong>length</strong> of a slice refers to its current length which can be resized.</p>
<p>Slices are created using the <kbd>make()</kbd> function. The <kbd>make()</kbd> function will create a slice of a certain type with a certain length and capacity. The <kbd>make()</kbd> function can be used two ways when creating a slice. With only two parameters, the length and capacity are the same. With three parameters, you can specify a maximum capacity larger than the length. Here are two of the <kbd>make()</kbd> function declarations:</p>
<pre>make([]T, lengthAndCapacity)<br/>make([]T, length, capacity) </pre>
<p>A nil slice can be created with a capacity and length of 0. There is no underlying array associated with a nil slice. Here is a short example program demonstrating how to create and inspect a slice:</p>
<pre>package main<br/><br/>import "fmt"<br/><br/>func main() {<br/>   // Create a nil slice<br/>   var mySlice []byte<br/><br/>   // Create a byte slice of length 8 and max capacity 128<br/>   mySlice = make([]byte, 8, 128)<br/><br/>   // Maximum capacity of the slice<br/>   fmt.Println("Capacity:", cap(mySlice))<br/><br/>   // Current length of slice<br/>   fmt.Println("Length:", len(mySlice))<br/>} </pre>
<p>You can also append to a slice using the built-in <kbd>append()</kbd> function.</p>
<p>Append can add one or more elements at a time. The underlying array will be resized if necessary. This means that the maximum capacity of a slice can be increased. When a slice increases its underlying capacity, creating a larger underlying array, it will create the array with some extra space. This means that if you surpass a slice's capacity by one, it might increase the array size by four. This is done so that the underlying array has room to grow to reduce the number of times the underlying array has to be resized, which may require moving memory around to accommodate the larger array. It could be expensive to resize an array every time just to add a single element. The slice mechanics will automatically determine the best size for resizing.</p>
<p>This code sample provides various examples of working with slices:</p>
<pre>package main<br/><br/>import "fmt"<br/><br/>func main() {<br/>   var mySlice []int // nil slice<br/><br/>   // Appending works on nil slices.<br/>   // Since nil slices have zero capacity, and have<br/>   // no underlying array, it will create one.<br/>   mySlice = append(mySlice, 1, 2, 3, 4, 5)<br/><br/>   // Individual elements can be accessed from a slice<br/>   // just like an array by using the square bracket operator.<br/>   firstElement := mySlice[0]<br/>   fmt.Println("First element:", firstElement)<br/><br/>   // To get only the second and third element, use:<br/>   subset := mySlice[1:4]<br/>   fmt.Println(subset)<br/><br/>   // To get the full contents of a slice except for the <br/>   // first element, use:<br/>   subset = mySlice[1:]<br/>   fmt.Println(subset)<br/><br/>   // To get the full contents of a slice except for the <br/>   // last element, use:<br/>   subset = mySlice[0 : len(mySlice)-1]<br/>   fmt.Println(subset)<br/><br/>   // To copy a slice, use the copy() function.<br/>   // If you assign one slice to another with the equal operator,<br/>   // the slices will point at the same memory location,<br/>   // and changing one would change both slices.<br/>   slice1 := []int{1, 2, 3, 4}<br/>   slice2 := make([]int, 4)<br/><br/>   // Create a unique copy in memory<br/>   copy(slice2, slice1)<br/><br/>   // Changing one should not affect the other<br/>   slice2[3] = 99<br/>   fmt.Println(slice1)<br/>   fmt.Println(slice2)<br/>} </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Struct</h1>
                
            
            
                
<p>In Go, a struct or data structure is a collection of variables. The variables can be of different types. We will look at an example of creating a custom struct type.</p>
<p>Go uses case-based scoping to declare a variable either <kbd>public</kbd> or <kbd>private</kbd>. Variables and methods that are capitalized are exported and accessible from other packages. Lowercase values are private and only accessible within the same package.</p>
<p>The following example creates a simple struct named <kbd>Person</kbd> and one named <kbd>Hacker</kbd>. The <kbd>Hacker</kbd> type has a <kbd>Person</kbd> type embedded within it. An instance of each type is then created and the information about them is printed to standard output:</p>
<pre>package main<br/><br/>import "fmt"<br/><br/>func main() {<br/>   // Define a Person type. Both fields public<br/>   type Person struct {<br/>      Name string<br/>      Age  int<br/>   }<br/><br/>   // Create a Person object and store the pointer to it<br/>   nanodano := &amp;Person{Name: "NanoDano", Age: 99}<br/>   fmt.Println(nanodano)<br/><br/>   // Structs can also be embedded within other structs.<br/>   // This replaces inheritance by simply storing the<br/>   // data type as another variable.<br/>   type Hacker struct {<br/>      Person           Person<br/>      FavoriteLanguage string<br/>   }<br/>   fmt.Println(nanodano)<br/><br/>   hacker := &amp;Hacker{<br/>      Person:           *nanodano,<br/>      FavoriteLanguage: "Go",<br/>   }<br/>   fmt.Println(hacker)<br/>   fmt.Println(hacker.Person.Name)<br/><br/>   fmt.Println(hacker)<br/>} </pre>
<p>You can create <em>private</em> variables by starting their name with a lowercase letter. I use quotation marks because private variables work slightly different than in other languages. The privacy works at the package level and not at the <em>class</em> or type level.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Pointer</h1>
                
            
            
                
<p>Go provides a pointer type that stores the memory location where data of a specific type is stored. Pointers can be used to pass a struct to a function by reference without creating a copy. This also allows a function to modify an object in-place.</p>
<p>There is no pointer arithmetic allowed in Go. Pointers are considered <em>safe</em> because Go does not even define the addition operator on the pointer type. They can only be used to reference an existing object.</p>
<p>This example demonstrates basic pointer usage. It first creates an integer, and then creates a pointer to the integer. It then prints out the data type of the pointer, the address stored in the pointer, and then the value of data being pointed at:</p>
<pre>package main<br/><br/>import (<br/>   "fmt"<br/>   "reflect"<br/>)<br/><br/>func main() {<br/>   myInt := 42<br/>   intPointer := &amp;myInt<br/><br/>   fmt.Println(reflect.TypeOf(intPointer))<br/>   fmt.Println(intPointer)<br/>   fmt.Println(*intPointer)<br/>} </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Function</h1>
                
            
            
                
<p>Functions are defined with the <kbd>func</kbd> keyword. Functions can have multiple parameters. All parameters are positional and there are no named parameters. Go supports variadic parameters allowing for an unknown number of parameters. Functions are first-class citizens in Go, and can be used anonymously and returned as a variable. Go also supports multiple return values from a function. The underscore can be used to ignore a return variable.</p>
<p>All of these examples are demonstrated in the following code source:</p>
<pre>package main<br/><br/>import "fmt"<br/><br/>// Function with no parameters<br/>func sayHello() {<br/>   fmt.Println("Hello.")<br/>}<br/><br/>// Function with one parameter<br/>func greet(name string) {<br/>   fmt.Printf("Hello, %s.\n", name)<br/>}<br/><br/>// Function with multiple params of same type<br/>func greetCustom(name, greeting string) {<br/>   fmt.Printf("%s, %s.\n", greeting, name)<br/>}<br/><br/>// Variadic parameters, unlimited parameters<br/>func addAll(numbers ...int) int {<br/>   sum := 0<br/>   for _, number := range numbers {<br/>      sum += number<br/>   }<br/>   return sum<br/>}<br/><br/>// Function with multiple return values<br/>// Multiple values encapsulated by parenthesis<br/>func checkStatus() (int, error) {<br/>   return 200, nil<br/>}<br/><br/>// Define a type as a function so it can be used<br/>// as a return type<br/>type greeterFunc func(string)<br/><br/>// Generate and return a function<br/>func generateGreetFunc(greeting string) greeterFunc {<br/>   return func(name string) {<br/>      fmt.Printf("%s, %s.\n", greeting, name)<br/>   }<br/>}<br/><br/>func main() {<br/>   sayHello()<br/>   greet("NanoDano")<br/>   greetCustom("NanoDano", "Hi")<br/>   fmt.Println(addAll(4, 5, 2, 3, 9))<br/><br/>   russianGreet := generateGreetFunc("Привет")<br/>   russianGreet("NanoDano")<br/><br/>   statusCode, err := checkStatus()<br/>   fmt.Println(statusCode, err)<br/>} </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Interface</h1>
                
            
            
                
<p>Interfaces are a special type that define a collection of function signatures. You can think of an interface as saying, "a type must implement function X and function Y to satisfy this interface." If you create any type and implement the functions needed to satisfy the interface, your type can be used anywhere that the interface is expected. You don't have to specify that you are trying to satisfy an interface, the compiler will determine if it satisfies the requirements.</p>
<p>You can add as many other functions as you want to your custom type. The interface defines the functions that are required, but it does not mean that your type is limited to implementing only those functions.</p>
<p>The most commonly used interface is the <kbd>error</kbd> interface. The <kbd>error</kbd> interface only requires a single function to be implemented, a function named <kbd>Error()</kbd> that returns a string with the error message. Here is the interface definition:</p>
<pre>type error interface {<br/>   Error() string<br/>} </pre>
<p>This makes it very easy for you to implement your own error interfaces. This example creates a <kbd>customError</kbd> type and then implements the <kbd>Error()</kbd> function needed to satisfy the interface. Then, a sample function is created, which returns the custom error:</p>
<pre>package main<br/><br/>import "fmt"<br/><br/>// Define a custom type that will<br/>// be used to satisfy the error interface<br/>type customError struct {<br/>   Message string<br/>}<br/><br/>// Satisfy the error interface<br/>// by implementing the Error() function<br/>// which returns a string<br/>func (e *customError) Error() string {<br/>   return e.Message<br/>}<br/><br/>// Sample function to demonstrate<br/>// how to use the custom error<br/>func testFunction() error {<br/>   if true != false { // Mimic an error condition<br/>      return &amp;customError{"Something went wrong."}<br/>   }<br/>   return nil<br/>}<br/><br/>func main() {<br/>   err := testFunction()<br/>   if err != nil {<br/>      fmt.Println(err)<br/>   }<br/>} </pre>
<p>Other frequently used interfaces are the <kbd>Reader</kbd> and <kbd>Writer</kbd> interfaces. Each one only requires one function to be implemented in order to satisfy the interface requirements. The big benefit here is that you can create your own custom types that reads and writes data in some arbitrary way. The implementation details are not important to the interface. The interface won't care whether you are reading and writing to a hard disk, a network connection, storage in memory, or <kbd>/dev/null</kbd>. As long as you implement the function signatures that are required, you can use your type anywhere the interface is used. Here is the definition of the <kbd>Reader</kbd> and <kbd>Writer</kbd> interfaces:</p>
<pre>type Reader interface {<br/>   Read(p []byte) (n int, err error)<br/>} 
 
type Writer interface {<br/>   Write(p []byte) (n int, err error)<br/>} </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Map</h1>
                
            
            
                
<p>A map is a hash table or dictionary that stores key and value pairs. The key and value can be any data types, including maps themselves, creating multiple dimensions.</p>
<p>The order is not guaranteed. You can iterate over a map multiple times and it might be different. Additionally, maps are not concurrent safe. If you must share a map between threads, use a mutex.</p>
<p>Here are some example map usages:</p>
<pre>package main<br/><br/>import (<br/>   "fmt"<br/>   "reflect"<br/>)<br/><br/>func main() {<br/>   // Nil maps will cause runtime panic if used 
   // without being initialized with make()<br/>   var intToStringMap map[int]string<br/>   var stringToIntMap map[string]int<br/>   fmt.Println(reflect.TypeOf(intToStringMap))<br/>   fmt.Println(reflect.TypeOf(stringToIntMap))<br/><br/>   // Initialize a map using make<br/>   map1 := make(map[string]string)<br/>   map1["Key Example"] = "Value Example"<br/>   map1["Red"] = "FF0000"<br/>   fmt.Println(map1)<br/><br/>   // Initialize a map with literal values<br/>   map2 := map[int]bool{<br/>      4:  false,<br/>      6:  false,<br/>      42: true,<br/>   }<br/><br/>   // Access individual elements using the key<br/>   fmt.Println(map1["Red"])<br/>   fmt.Println(map2[42])
   // Use range to iterate through maps<br/>   for key, value := range map2 {<br/>      fmt.Printf("%d: %t\n", key, value)<br/>   }<br/><br/>} </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Channel</h1>
                
            
            
                
<p>Channels are used to communicate between threads. Channels are <strong>first-in, first-out</strong> (<strong>FIFO</strong>) queues. You can push objects on to the queue and pull from the front asynchronously. Each channel can only support one data type. Channels are blocking by default, but can be made nonblocking with a <kbd>select</kbd> statement. Like slices and maps, channels must be initialized before use with the <kbd>make()</kbd> function.</p>
<p>The saying in Go is <em>Do not communicate by sharing memory; instead, share memory by communicating</em>. Read more about this philosophy at <a href="https://blog.golang.org/share-memory-by-communicating" target="_blank">https://blog.golang.org/share-memory-by-communicating</a>.</p>
<p>Here is an example program that demonstrates basic channel usage:</p>
<pre>package main<br/><br/>import (<br/>   "log"<br/>   "time"<br/>)<br/><br/>// Do some processing that takes a long time<br/>// in a separate thread and signal when done<br/>func process(doneChannel chan bool) {<br/>   time.Sleep(time.Second * 3)<br/>   doneChannel &lt;- true<br/>}<br/><br/>func main() {<br/>   // Each channel can support one data type.<br/>   // Can also use custom types<br/>   var doneChannel chan bool<br/><br/>   // Channels are nil until initialized with make<br/>   doneChannel = make(chan bool)<br/><br/>   // Kick off a lengthy process that will<br/>   // signal when complete<br/>   go process(doneChannel)<br/><br/>   // Get the first bool available in the channel<br/>   // This is a blocking operation so execution<br/>   // will not progress until value is received<br/>   tempBool := &lt;-doneChannel<br/>   log.Println(tempBool)<br/>   // or to simply ignore the value but still wait<br/>   // &lt;-doneChannel<br/><br/>   // Start another process thread to run in background<br/>   // and signal when done<br/>   go process(doneChannel)<br/><br/>   // Make channel non-blocking with select statement<br/>   // This gives you the ability to continue executing<br/>   // even if no message is waiting in the channel<br/>   var readyToExit = false<br/>   for !readyToExit {<br/>      select {<br/>      case done := &lt;-doneChannel:<br/>         log.Println("Done message received.", done)<br/>         readyToExit = true<br/>      default:<br/>         log.Println("No done signal yet. Waiting.")<br/>         time.Sleep(time.Millisecond * 500)<br/>      }<br/>   }<br/>} </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Control structures</h1>
                
            
            
                
<p>Control structures are used to control the flow of program execution. The most common forms are the <kbd>if</kbd> statements, <kbd>for</kbd> loops, and <kbd>switch</kbd> statements. Go also supports the <kbd>goto</kbd> statement, but should be reserved for cases of extreme performance and not used regularly. Let's look briefly at each of these to understand the syntax.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">if</h1>
                
            
            
                
<p>The <kbd>if</kbd> statement comes with the <kbd>if</kbd>, <kbd>else if</kbd>, and <kbd>else</kbd> clauses, just like most other languages. The one interesting feature that Go has is the ability to put a statement before the condition, creating temporary variables that are discarded after the <kbd>if</kbd> statement has completed.</p>
<p>This example demonstrates the various ways to use an <kbd>if</kbd> statement:</p>
<pre>package main<br/><br/>import (<br/>   "fmt"<br/>   "math/rand"<br/>)<br/><br/>func main() {<br/>   x := rand.Int()<br/><br/>   if x &lt; 100 {<br/>      fmt.Println("x is less than 100.")<br/>   }<br/><br/>   if x &lt; 1000 {<br/>      fmt.Println("x is less than 1000.")<br/>   } else if x &lt; 10000 {<br/>      fmt.Println("x is less than 10,000.")<br/>   } else {<br/>      fmt.Println("x is greater than 10,000")<br/>   }<br/><br/>   fmt.Println("x:", x)<br/><br/>   // You can put a statement before the condition 
   // The variable scope of n is limited<br/>   if n := rand.Int(); n &gt; 1000 {<br/>      fmt.Println("n is greater than 1000.")<br/>      fmt.Println("n:", n)<br/>   } else {<br/>      fmt.Println("n is not greater than 1000.")<br/>      fmt.Println("n:", n)<br/>   }<br/>   // n is no longer available past the if statement<br/>} </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">for</h1>
                
            
            
                
<p>The <kbd>for</kbd> loop has three components, and can be used just like a <kbd>for</kbd> loop in C or Java. Go has no <kbd>while</kbd> loop because the <kbd>for</kbd> loop serves the same purpose when used with a single condition. Refer to the following example for more clarity:</p>
<pre>package main<br/><br/>import (<br/>   "fmt"<br/>)<br/><br/>func main() {<br/>   // Basic for loop<br/>   for i := 0; i &lt; 3; i++ {<br/>      fmt.Println("i:", i)<br/>   }<br/><br/>   // For used as a while loop<br/>   n := 5<br/>   for n &lt; 10 {<br/>      fmt.Println(n)<br/>      n++<br/>   }<br/>} </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">range</h1>
                
            
            
                
<p>The <kbd>range</kbd> keyword is used to iterate over a slice, map, or other data structure. The <kbd>range</kbd> keyword is used in combination with the <kbd>for</kbd> loop, to operate on an iterable data structure. The <kbd>range</kbd> keyword returns the key and value variables. Here are some basic examples of using the <kbd>range</kbd> keyword:</p>
<pre>package main<br/><br/>import "fmt"<br/><br/>func main() {<br/>   intSlice := []int{2, 4, 6, 8}<br/>   for key, value := range intSlice {<br/>      fmt.Println(key, value)<br/>   }<br/><br/>   myMap := map[string]string{<br/>      "d": "Donut",<br/>      "o": "Operator",<br/>   }<br/><br/>   // Iterate over a map<br/>   for key, value := range myMap {<br/>      fmt.Println(key, value)<br/>   }<br/><br/>   // Iterate but only utilize keys<br/>   for key := range myMap {<br/>      fmt.Println(key)<br/>   }<br/><br/>   // Use underscore to ignore keys<br/>   for _, value := range myMap {<br/>      fmt.Println(value)<br/>   }<br/>} </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">switch, case, fallthrough, and default</h1>
                
            
            
                
<p>The <kbd>switch</kbd> statement allows you to branch execution based on the state of a variable. It is similar to the <kbd>switch</kbd> statement in C and other languages.</p>
<p>There is no <kbd>fallthrough</kbd> by default. This means once the end of a case is reached, the code exits the <kbd>switch</kbd> statement completely unless an explicit <kbd>fallthrough</kbd> command is provided. A <kbd>default</kbd> case can be provided if none of the cases are matched.</p>
<p>You can put a statement in front of the variable to be switched, such as the <kbd>if</kbd> statement. This creates a variable whose scope is limited to the <kbd>switch</kbd> statement.</p>
<p>This example demonstrates two <kbd>switch</kbd> statements. The first one uses hardcoded values and includes a <kbd>default</kbd> case. The second <kbd>switch</kbd> statement uses an alternate syntax that allows for a statement in the first line:</p>
<pre>package main<br/><br/>import (<br/>   "fmt"<br/>   "math/rand"<br/>)<br/><br/>func main() {<br/>   x := 42<br/><br/>   switch x {<br/>   case 25:<br/>      fmt.Println("X is 25")<br/>   case 42:<br/>      fmt.Println("X is the magical 42")<br/>      // Fallthrough will continue to next case<br/>      fallthrough<br/>   case 100:<br/>      fmt.Println("X is 100")<br/>   case 1000:<br/>      fmt.Println("X is 1000")<br/>   default:<br/>      fmt.Println("X is something else.")<br/>   }<br/><br/>   // Like the if statement a statement<br/>   // can be put in front of the switched variable<br/>   switch r := rand.Int(); r {<br/>   case r % 2:<br/>      fmt.Println("Random number r is even.")<br/>   default:<br/>      fmt.Println("Random number r is odd.")<br/>   }<br/>   // r is no longer available after the switch statement<br/>} </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">goto</h1>
                
            
            
                
<p>Go does have a <kbd>goto</kbd> statement, but it is very rarely used. Create a label with a name and a colon, then <em>go to</em> it using the <kbd>goto</kbd> keyword. Here is a basic example:</p>
<pre>package main<br/><br/>import "fmt"<br/><br/>func main() {<br/><br/>   goto customLabel<br/><br/>   // Will never get executed because<br/>   // the goto statement will jump right<br/>   // past this line<br/>   fmt.Println("Hello")<br/><br/>   customLabel:<br/>   fmt.Println("World")<br/>} </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Defer</h1>
                
            
            
                
<p>By deferring a function, it will run whenever the current function is exited. This is a convenient way to ensure that a function will get executed before exiting, which is useful for cleaning up or closing files. It is convenient because a deferred function will get executed no matter where the surrounding function exits if there are multiple return locations.</p>
<p>Common use cases are deferring calls to close a file or database connection. Right after opening a file, you can defer a call to close. This will ensure that a file is closed whenever the function is exited, even if there are multiple return statements and you can't be sure about when and where the current function will exit.</p>
<p>This example demonstrates a simple use case for the <kbd>defer</kbd> keyword. It creates a file and then defers a call to <kbd>file.Close()</kbd>:</p>
<pre>package main<br/><br/>import (<br/>   "log"<br/>   "os"<br/>)<br/><br/>func main() {<br/><br/>   file, err := os.Create("test.txt")<br/>   if err != nil {<br/>      log.Fatal("Error creating file.")<br/>   }<br/>   defer file.Close()<br/>   // It is important to defer after checking the errors.<br/>   // You can't call Close() on a nil object<br/>   // if the open failed.<br/><br/>   // ...perform some other actions here...<br/><br/>   // file.Close() will be called before final exit<br/>} </pre>
<p>Be sure to properly check and handle errors. The <kbd>defer</kbd> call will panic if using a nil pointer.</p>
<p>It is also important to understand that deferred functions are run when the surrounding function is exited. If you put a <kbd>defer</kbd> call inside a <kbd>for</kbd> loop, it will not get called at the end of each <kbd>for</kbd> loop iteration.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Packages</h1>
                
            
            
                
<p>Packages are just directories. Every directory is its own package. Creating subdirectories creates a new package. Having no subpackages leads to a flat hierarchy. Subdirectories are used just for organizing code.</p>
<p>Packages should be stored in the <kbd>src</kbd> folder of your <kbd>$GOPATH</kbd> variable.</p>
<p>A package name should match the folder name or be named <kbd>main</kbd>. A <kbd>main</kbd> package means that it is not intended to be imported into another application, but meant to compile and run as a program. Packages are imported using the <kbd>import</kbd> keyword.</p>
<p>You can import packages individually:</p>
<pre>import "fmt" </pre>
<p>Alternatively, you can import multiple packages at once by wrapping them with parenthesis:</p>
<pre>import (<br/>   "fmt"<br/>   "log"<br/>) </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Classes</h1>
                
            
            
                
<p>Go technically does not have classes, but there are only a few subtle distinctions that keep it from being called an object-oriented language. Conceptually, I do consider it an object-oriented programming language, though it only supports the most basic features of an object-oriented language. It does not come with all of the features many people have come to associate with object-oriented programming, such as inheritance and polymorphism, which are replaced with other features such as embedded types and interfaces. Perhaps you could call it a <em>microclass</em> system, because it is a minimalistic implementation with none of the extra features or baggage, depending on your perspective.</p>
<p>Throughout this book, the terms <em>object</em> and <em>class</em> may be used to illustrate a point using familiar terms, but be aware that these are not formal terms in Go. A type definition in combination with the functions that operate on that type are like the class, and the object is an instance of a type.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Inheritance</h1>
                
            
            
                
<p>There is no inheritance in Go, but you can embed types. Here is an example of a <kbd>Person</kbd> and <kbd>Doctor</kbd> types, which embeds the <kbd>Person</kbd> type. Instead of inheriting the behavior of <kbd>Person</kbd> directly, it stores the <kbd>Person</kbd> object as a variable, which brings with it all of its expected <kbd>Person</kbd> methods and attributes:</p>
<pre>package main<br/><br/>import (<br/>   "fmt"<br/>   "reflect"<br/>)<br/><br/>type Person struct {<br/>   Name string<br/>   Age  int<br/>} 
<br/>type Doctor struct {<br/>   Person         Person<br/>   Specialization string<br/>}<br/><br/>func main() {<br/>   nanodano := Person{<br/>      Name: "NanoDano",<br/>      Age:  99,<br/>   } 
<br/>   drDano := Doctor{<br/>      Person:         nanodano,<br/>      Specialization: "Hacking",<br/>   }<br/><br/>   fmt.Println(reflect.TypeOf(nanodano))<br/>   fmt.Println(nanodano)
   fmt.Println(reflect.TypeOf(drDano))<br/>   fmt.Println(drDano)<br/>} </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Polymorphism</h1>
                
            
            
                
<p>There is no polymorphism in Go, but you can use interfaces to create common abstraction that can be used by multiple types. Interfaces define one or more method declarations that must be satisfied to be compatible with the interface. Interfaces were covered earlier in this chapter.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Constructors</h1>
                
            
            
                
<p>There are no constructors in Go, but there are <kbd>New()</kbd> functions that act like factories initializing an object. You simply have to create a function named <kbd>New()</kbd> that returns your data type. Here is an example:</p>
<pre>package main<br/><br/>import "fmt"<br/><br/>type Person struct {<br/>   Name string<br/>}<br/><br/>func NewPerson() Person {<br/>   return Person{<br/>      Name: "Anonymous",<br/>   }<br/>}<br/><br/>func main() {<br/>   p := NewPerson()<br/>   fmt.Println(p)<br/>} </pre>
<p>There are no deconstructors in Go, since everything is garbage collected and you do not manually destroy objects. Defer is the closest you can get by deferring a function call to perform some cleanup when the current function ends.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Methods</h1>
                
            
            
                
<p>Methods are functions that belong to a specific type, and are called using the dot notation, for example:</p>
<pre>myObject.myMethod() </pre>
<p>The dot notation is widely used in C++ and other object-oriented languages. The dot notation and the class system stemmed from a common pattern that was used in C. The common pattern is to define a set of functions that all operate on a specific data type. All of the related functions have the same first parameter, which is the data to be operated on. Since this is such a common pattern, Go built it into the language. Instead of passing the object to be manipulated as the first argument, there is a special place to designate the receiver in a Go function definition. The receiver is specified between a set of parenthesis before the function name. The next example demonstrates how to use function receivers.</p>
<p>Instead of writing a large set of functions that all took a pointer as their first parameter, you can write functions that have a special <em>receiver</em>. The receiver can either be a type or a pointer to a type:</p>
<pre>package main<br/><br/>import "fmt"<br/><br/>type Person struct {<br/>   Name string<br/>}<br/><br/>// Person function receiver<br/>func (p Person) PrintInfo() {<br/>   fmt.Printf("Name: %s\n", p.Name)<br/>}<br/><br/>// Person pointer receiver<br/>// If you did not use the pointer receivers<br/>// it would not modify the person object<br/>// Try removing the asterisk here and seeing how the<br/>// program changes behavior<br/>func (p *Person) ChangeName(newName string) {<br/>   p.Name = newName<br/>}<br/><br/>func main() {<br/>   nanodano := Person{Name: "NanoDano"}<br/>   nanodano.PrintInfo()<br/>   nanodano.ChangeName("Just Dano")<br/>   nanodano.PrintInfo()<br/>} </pre>
<p>In Go, you do not encapsulate all of the variables and methods inside a monolithic pair of braces. You define a type, and then define methods that operate on that type. This allows you to define all of your structs and data types in one place, and define the methods elsewhere in your package. You also have the option of defining a type and the methods right next to each other. It's pretty simple and straightforward, and it creates a slightly clearer distinction between the state (data) and the logic.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Operator overloading</h1>
                
            
            
                
<p>There is no operator overloading in Go, so you can't add to structs together with the <kbd>+</kbd> sign, but you can easily define an <kbd>Add()</kbd> function on the type and then call something like <kbd>dataSet1.Add(dataSet2)</kbd>. By omitting operator overloading from the language, we can confidently use the operators without worrying about unexpected behavior due to operator behavior being overloaded somewhere else in code without realizing it.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Goroutines</h1>
                
            
            
                
<p>Goroutines are lightweight threads built into the language. You simply have to put the word <kbd>go</kbd> in front of a function call to have the function execute in a thread. Goroutines may also be referred to as threads in this book.</p>
<p>Go does provide mutexes, but they are avoidable in most cases and will not be covered in this book. You can read more about mutexes in the <kbd>sync</kbd> package documentation at <a href="https://golang.org/pkg/sync/" target="_blank">https://golang.org/pkg/sync/</a>. Channels should be used instead for sharing data and communicating between threads. Channels were covered earlier in this chapter.</p>
<p>Note that the <kbd>log</kbd> package is safe to use concurrently, but the <kbd>fmt</kbd> package is not. Here is a short example of using goroutines:</p>
<pre>package main<br/><br/>import (<br/>   "log"<br/>   "time"<br/>)<br/><br/>func countDown() {<br/>   for i := 5; i &gt;= 0; i-- {<br/>      log.Println(i)<br/>      time.Sleep(time.Millisecond * 500)<br/>   }<br/>}<br/><br/>func main() {<br/>   // Kick off a thread<br/>   go countDown()<br/><br/>   // Since functions are first-class<br/>   // you can write an anonymous function<br/>   // for a goroutine<br/>   go func() {<br/>      time.Sleep(time.Second * 2)<br/>      log.Println("Delayed greetings!")<br/>   }()<br/><br/>   // Use channels to signal when complete<br/>   // Or in this case just wait<br/>   time.Sleep(time.Second * 4)<br/>} </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting help and documentation</h1>
                
            
            
                
<p>Go has both online and offline help documentation. The offline documentation is built-in for Go and is the same documentation that is hosted online. These next sections will walk you through accessing both forms of documentation.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Online Go documentation</h1>
                
            
            
                
<p>The online documentation is available at <a href="https://golang.org/" target="_blank">https://golang.org/</a>, and has all the formal documentation, specifications, and help files. Language documentation specifically is at <a href="https://golang.org/doc/">https://golang.org/doc/</a>, and information about the standard library is at <a href="https://golang.org/pkg/">https://golang.org/pkg/</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Offline Go documentation</h1>
                
            
            
                
<p>Go also comes with offline documentation with the <kbd>godoc</kbd> command-line tool. You can use it on the command line, or have it run a web server where it serves the same website that <a href="https://golang.org/" target="_blank">https://golang.org/</a> hosts. It is quite handy to have the full website documentation available locally. Here are a few examples that get documentation for the <kbd>fmt</kbd> package. Replace <kbd>fmt</kbd> with whatever package you are interested in:</p>
<pre> <strong># Get fmt package information<br/> godoc fmt<br/><br/> # Get source code for fmt package<br/> godoc -src fmt<br/><br/> # Get specific function information<br/> godoc fmt Printf<br/><br/> # Get source code for function<br/> godoc -src fmt Printf<br/><br/> # Run HTTP server to view HTML documentation<br/> godoc -http=localhost:9999</strong>
  </pre>
<p>The HTTP option serves the same documentation that is available on <a href="https://golang.org/">https://golang.org/</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>After reading this chapter you should have a basic understanding of Go fundamentals such as what the keywords are, what they do, and what basic data types are available. You should also feel comfortable creating functions and custom data types.</p>
<p>The goal is not to memorize all of the preceding information, but to be aware of what tools are available in the language. Use this chapter as a reference if necessary. You can find more information about the Go language specification at <a href="https://golang.org/ref/spec">https://golang.org/ref/spec</a>.</p>
<p>In the next chapter, we will look at working with files in Go. We will cover basics such as getting file information, seeing whether a file exists, truncating files, checking permissions, and creating new files. We will also cover the reader and writer interfaces, as well as a number of ways to read and write data. In addition to this, we will cover things such as archiving to ZIP or TAR files and compressing files with GZIP.</p>


            

            
        
    </body></html>