<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer236">
			<h1 id="_idParaDest-121"><a id="_idTextAnchor126"/>Chapter <a id="_idTextAnchor127"/><a id="_idTextAnchor128"/>8: User Activity Reconstruction</h1>
			<p>During forensic investigations and incident responses, reconstructing user activity is an essential part of collecting important data from the hosts of both victims and attackers. Linux-based systems have an important role to play here as they are often used by attackers to carry out their activities. This is because many different network and vulnerability scanners, web application security testing tools, and post-exploitation frameworks are implemented under Linux. Thus, investigating the host used by the attackers reveals to us detailed information about the tools and techniques used in the attack. Furthermore, by examining user activity, we can learn more about the stages of preparation for the attack, possible affiliates, activity on different forums, and more. </p>
			<p>Based on the preceding lines, we must consider the following topics:</p>
			<ul>
				<li>Investigating launched programs</li>
				<li>Analyzing Bash history </li>
				<li>Searching for recent files</li>
				<li><a id="_idTextAnchor129"/>Recovering filesystem from memory</li>
				<li>Checking browsing history </li>
				<li>Investigating communication applications</li>
				<li>Looking for mounted devices</li>
				<li>Detecting crypto containers</li>
			</ul>
			<h1 id="_idParaDest-122"><a id="_idTextAnchor130"/>Technical requirements</h1>
			<p>This time, we will use both Linux and Windows systems to work with the tools described in the next two chapters and to carry out Linux memory forensics. In our case, <strong class="bold">Volatility</strong> <strong class="bold">2.6.1</strong> together with some built-in utilities will run on Ubuntu 21.04 (Hirsute Hippo) and programs such as <strong class="bold">Bulk Extractor</strong> or <strong class="bold">PhotoRec</strong> will run on Windows.</p>
			<h1 id="_idParaDest-123"><a id="_idTextAnchor131"/>Investigating launched programs</h1>
			<p>In the previous chapter, we already <a id="_idIndexMarker464"/>discussed the process of profile creation for Linux-based systems, so now we'll restrict ourselves to checking which profiles you have available.</p>
			<p>Let's assume that you have created a profile and placed it in the profiles folder. Don't forget that you need to pass the path to this folder using the <strong class="source-inline">--plugins</strong> option. To check that your profiles are available for use you can run <strong class="source-inline">--info</strong>. In order to get only the necessary output, we use <strong class="source-inline">grep</strong>, a command-line utility that allows us to find lines that match a given regular expression in the input and print them out:</p>
			<div>
				<div id="_idContainer196" class="IMG---Figure">
					<img src="Images/Figure_8.1_B17056.jpg" alt="Figure 8.1 – Linux profiles in Volatility&#13;&#10;" width="1317" height="233"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.1 – Linux profiles in Volatility</p>
			<p>As you can see, we have several Ubuntu profiles at our disposal, as well as a Debian profile. Similarly, we can see a list of all plugins available for use with these profiles:</p>
			<div>
				<div id="_idContainer197" class="IMG---Figure">
					<img src="Images/Figure_8.2_B17056.jpg" alt="Figure 8.2 – Linux plugins in Volatility&#13;&#10;" width="1208" height="403"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.2 – Linux plugins in Volatility</p>
			<p>Now that we have ensured that we have everything we need, we can start analyzing. As in the case of Windows, we will start by investigating the active processes, which will tell us what programs the user is running. </p>
			<p>Volatility has a <strong class="source-inline">pslist</strong> and <strong class="source-inline">pstree</strong> equivalent for Linux-based systems. These plugins also work with the list of active processes and allow us to view this information. Let's use the <strong class="source-inline">linux_pslist</strong> plugin:</p>
			<div>
				<div id="_idContainer198" class="IMG---Figure">
					<img src="Images/Figure_8.3_B17056.jpg" alt="Figure 8.3 – List of active processes&#13;&#10;" width="1650" height="459"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.3 – List of active processes</p>
			<p>The output of this plugin will be quite lengthy. This is because Linux systems use the same kernel structure to store information about processes as they do for kernel threads. Therefore, the output of this plugin will contain both processes and kernel threads. The latter can be identified by the absence of DTB. </p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">DTB is the physical offset of the process directory table base used to read from the process address space. Since kernel threads use the kernel address space, they do not have a DTB.</p>
			<p>Note that there is also a <strong class="source-inline">Uid</strong> column that corresponds to the user ID. Using this column, you can filter the information for a particular user. Let's look at the processes that were started by the <strong class="source-inline">1000</strong> user ID. To do this, we will simply use the <strong class="source-inline">grep</strong> utility:</p>
			<div>
				<div id="_idContainer199" class="IMG---Figure">
					<img src="Images/Figure_8.4_B17056.jpg" alt="Figure 8.4 – Processes started by a specific user&#13;&#10;" width="1650" height="504"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.4 – Processes started by a specific user</p>
			<p>We can now see that all rows with a value of <strong class="source-inline">1000</strong> in the <strong class="source-inline">Uid</strong> column belong to the same user. We can take a closer look at this output:</p>
			<div>
				<div id="_idContainer200" class="IMG---Figure">
					<img src="Images/Figure_8.5_B17056.jpg" alt="Figure 8.5 – User processes&#13;&#10;" width="1657" height="396"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.5 – User processes</p>
			<p>Here, we already see some familiar names. For example, we can infer that the user with the <strong class="source-inline">1000</strong> ID had a terminal open, nano, Thunderbird, LibreOffice, and so on. It would also be nice to have a bit more information about the user. </p>
			<p>Usually, user information can be found in the <strong class="source-inline">/etc/passwd</strong> file, but if we only have a memory dump at our disposal, getting access to this file can be problematic. However, we may be able to see information about the environment in which the processes in question were started. To do this, we can use the <strong class="source-inline">linux_psenv</strong> plugin. Let's run this plugin and specify one of the bash processes with the <strong class="source-inline">23639</strong> identifier:</p>
			<div>
				<div id="_idContainer201" class="IMG---Figure">
					<img src="Images/Figure_8.6_B17056.jpg" alt="Figure 8.6 – Process environment variables&#13;&#10;" width="1650" height="338"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.6 – Process environment variables</p>
			<p>Note that the username is among the environment variables of this process. We now know that the programs we detected were started by the i<strong class="source-inline">tsupport</strong> user.</p>
			<p>But let's go back to the running processes. Apart from the standard <strong class="source-inline">pslist</strong> and <strong class="source-inline">pstree</strong> plugins, we have another interesting plugin at our disposal, which allows us to view not only the names of the running programs but also their locations and the arguments passed to them at startup. This plugin is called <strong class="source-inline">linux_psaux</strong>. Let's check it:</p>
			<div>
				<div id="_idContainer202" class="IMG---Figure">
					<img src="Images/Figure_8.7_B17056.jpg" alt="Figure 8.7 – Volatility linux_psaux &#13;&#10;" width="1650" height="460"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.7 – Volatility linux_psaux </p>
			<p>As you can see, we have once again used <strong class="source-inline">grep</strong> to get information about the processes associated with a particular user. We now have all the data about the location of the running programs and the arguments passed to them. Why might this be useful? Let's look at the following figure:</p>
			<div>
				<div id="_idContainer203" class="IMG---Figure">
					<img src="Images/Figure_8.8_B17056.jpg" alt="Figure 8.8 – File names in command lines" width="1650" height="434"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.8 – File names in command lines</p>
			<p>Here we can see not only the programs that the user has run but also the files opened with them. For example, we now know that the user was not just running Libre Office, but was running calc, an Excel analogue for Linux, and had <strong class="source-inline">clients.xls</strong> open with it. We can also see that nano was used to work with the <strong class="source-inline">passwords.txt</strong> text file, located on the desktop. </p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">Since <strong class="source-inline">linux_psaux</strong> shows the arguments at startup, you may not be able to get all the information about the files opened by a program from here. You can use another method to retrieve this information, which will be discussed later.</p>
			<p>You have probably noticed that our user <a id="_idIndexMarker465"/>actively uses not only GUI programs, but also works with the terminal. This is a common story for users of Linux systems, so analysis of the executed commands becomes an integral part of user activity investigation.</p>
			<h1 id="_idParaDest-124"><a id="_idTextAnchor132"/>Analyzing Bash history</h1>
			<p>The most commonly used shell on Linux systems is Bash, one of the most popular Unix shells. One of the reasons for this popularity is that it is preinstalled on the vast majority of Linux distributions. At the same time, it is quite functional, as it allows you to interactively execute many commands and scripts, work with the filesystem, redirect the input and output of commands, and much more. </p>
			<p>Typically, if Bash history logging is enabled, it is stored in the user's home directory, in the <strong class="source-inline">.bash_history</strong> file. Naturally, attackers may perform various manipulations on both this file and the history-logging process in order to hide their traces. Nevertheless, we can try to recover this information from memory. Volatility has a specific plugin for this, <strong class="source-inline">linux_bash</strong>. Running this plugin looks like this:</p>
			<div>
				<div id="_idContainer204" class="IMG---Figure">
					<img src="Images/Figure_8.9_B17056.jpg" alt="Figure 8.9 – Bash history&#13;&#10;" width="1649" height="244"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.9 – Bash history</p>
			<p>As you can see, in our case, the user first tried to output the contents of the passwords file with <strong class="source-inline">cat</strong>, then opened it with <strong class="source-inline">nano</strong>, but apparently the file was not on the desktop, so the user created it with the <strong class="source-inline">touch</strong> command. Then, there was a network check, using <strong class="source-inline">ping</strong> and installing Git via <strong class="source-inline">apt</strong>. Obviously, with a threat actor working on the host, a Bash history analysis is of special value. Let's look at the following example:</p>
			<div>
				<div id="_idContainer205" class="IMG---Figure">
					<img src="Images/Figure_8.10_B17056.jpg" alt="Figure 8.10 – Bash history on the attacker’s host&#13;&#10;" width="1638" height="599"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.10 – Bash history on the attacker's host</p>
			<p>Here, on the attacker's host, we see the post-exploitation framework, Metasploit, installed and running, as well as the network scanning tool Nmap. We also see the <strong class="source-inline">rockyou.txt</strong> file and can assume that this is one of the popular password dictionaries used for brute-forcing. </p>
			<p>Thus, examining the Bash history on the attacker's host can reveal to us information about the tools used and the techniques applied, while Bash on the victim's host will tell us not only the tools used in the attack but also the individual files or systems the attacker was interested in.</p>
			<p>Note that this is not the first time we have encountered the opening of certain files. Let's take a closer look at how to obtain information about the files a user was working with.</p>
			<h1 id="_idParaDest-125"><a id="_idTextAnchor133"/>Searching for opened documents</h1>
			<p>Unfortunat<a id="_idTextAnchor134"/>ely, Linux-based systems do not have the same level of information logging as Windows. Nevertheless, it is still possible to find information about a particular file or even try to recover its content from memory. But first things first. </p>
			<p>You already know that the files opened at the start of a program can be seen with the <strong class="source-inline">linux_psaux</strong> or <strong class="source-inline">linux_bash</strong> plugins. If you are interested in the files opened while a program is running, you can use the <strong class="source-inline">linux_lsof</strong> plugin by passing it the ID of the process you are interested in via the <strong class="source-inline">-p</strong> option. Let's try to find information about <strong class="source-inline">xls</strong> files opened by the <strong class="source-inline">soffice.bin</strong> process of the <strong class="source-inline">itupport</strong> user. To search for files of a certain type, we will use <strong class="source-inline">grep</strong>:</p>
			<div>
				<div id="_idContainer206" class="IMG---Figure">
					<img src="Images/Figure_8.11_B17056.jpg" alt="Figure 8.11 – Files opened in LibreOffice&#13;&#10;" width="1283" height="123"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.11 – Files opened in LibreOffice</p>
			<p>The output shows that, in our case, LibreOffice connected to only one file, <strong class="source-inline">cliens.xls</strong>. It would be nice to know the contents of this file as well. Volatility provides a mechanism to find out which files have recently been used and export them. The fact is that Linux-based systems cache file data that is read from and written to disk. Volatility allows you to list and recover such files using the <strong class="source-inline">linux_find_file</strong> plugin. Let's start by listing the files cached in memory. To do this, the <strong class="source-inline">-L</strong> option should be used. As the list is quite long, we recommend saving it to a file, as shown in <em class="italic">Figure 8.12</em>:</p>
			<div>
				<div id="_idContainer207" class="IMG---Figure">
					<img src="Images/Figure_8.12_B17056.jpg" alt="Figure 8.12 – List of cached files&#13;&#10;" width="1463" height="519"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.12 – List of cached files</p>
			<p>From the output, you can see that here you can find information about the directories and files used, as well as their <strong class="source-inline">inode</strong> number and address. </p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">An <strong class="source-inline">inode</strong> or index descriptor is a data structure that stores metadata about standard files, directories, or other filesystem objects, apart from the data and name itself.</p>
			<p>Alternatively, if you want to quickly check for a file in memory, you can use the <strong class="source-inline">-F</strong> option, followed by the name or location of the file you are looking for. If the file is found, you will see its location and <strong class="source-inline">inode</strong> information.</p>
			<p>Using this information, we can try to extract any file found. To do this, we can use <strong class="source-inline">option -i</strong>, after which we should specify the desired <strong class="source-inline">inode</strong>. Here, we should also use the <strong class="source-inline">-O</strong> option to specify the path to the output file. The file search and extraction will look like this:</p>
			<div>
				<div id="_idContainer208" class="IMG---Figure">
					<img src="Images/Figure_8.13_B17056.jpg" alt="Figure 8.13 – File extraction&#13;&#10;" width="1343" height="286"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.13 – File extraction</p>
			<p>As you can see, we first found the file of interest and then used its <strong class="source-inline">inode</strong> to extract the data file to disk. But this is not all the possibilities that <strong class="source-inline">inode</strong> gives us. Let's get to the bottom of it.</p>
			<h1 id="_idParaDest-126"><a id="_idTextAnchor135"/>Recovering the filesystem </h1>
			<p>In addition to retrieving individual files, Volatility provides the ability to recover a portion of the filesystem that was in memory at the time the dump was created. This is made possible precisely because of the large number of metadata stored in the <strong class="source-inline">inode</strong>. Filesystem recovery can be done using the <strong class="source-inline">linux_recover_filesystem</strong> plugin:</p>
			<p class="source-code"><strong class="source-inline">$ vol.py --plugins=profiles -f /mnt/hgfs/flash/ubuntu_11.05.58.lime </strong></p>
			<p class="source-code"><strong class="source-inline">--profile=Linuxubuntu_18_04_5_4_0-84-genericx64 linux_recover_filesystem -D /mnt/hgfs/flash/recover_fs/</strong></p>
			<p>Note that here we add the <strong class="source-inline">-D</strong> option, specifying the directory where we want to save the filesystem to be recovered. In our case, it will be saved in the <strong class="source-inline">recover_fs</strong> folder. The result of the plugin will look like this:</p>
			<div>
				<div id="_idContainer209" class="IMG---Figure">
					<img src="Images/Figure_8.14_B17056.jpg" alt="Figure 8.14 – Recovered FS&#13;&#10;" width="1096" height="703"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.14 – Recovered FS</p>
			<p>Here, you can see the standard directories that have been recovered and also a <strong class="source-inline">swapfile</strong>, which is the Linux equivalent of Windows' <strong class="source-inline">pagefile</strong>. You can analyze this file in a similar way, using tools such as strings or Bulk Extractor. </p>
			<p>In general, the filesystems used in Linux distributions have a similar hierarchy. The root directory is <strong class="source-inline">/</strong>, followed by the <strong class="source-inline">/bin/</strong>, <strong class="source-inline">/boot/</strong>, and <strong class="source-inline">/etc/</strong> standard directories, and others: </p>
			<div>
				<div id="_idContainer210" class="IMG---Figure">
					<img src="Images/Figure_8.15_B17056.jpg" alt="Figure 8.15 – Linux directory hierarchy&#13;&#10;" width="1400" height="585"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.15 – Linux directory hierarchy</p>
			<p>The fact is that most Linux distributions follow the general rules described by the Filesystem Hierarchy Standard. </p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">The <strong class="bold">Filesystem Hierarchy Standard</strong> (<strong class="bold">FHS</strong>) is maintained by the Linux Foundation. It defines the directory structure and directory contents in Linux distributions.</p>
			<p>Therefore, each directory has its own purpose and stores specific content. The following is a list of the key directories:</p>
			<div>
				<div id="_idContainer211" class="IMG---Figure">
					<img src="Images/Figure_8.16_B17056.jpg" alt=" Figure 8.16 – Standard directories&#13;&#10;" width="1414" height="1508"/>
				</div>
			</div>
			<p class="figure-caption"> Figure 8.16 – Standard directories</p>
			<p>Thus, using <a id="_idIndexMarker466"/>the recovered filesystem, you can try to find user files of interest or work with system files such as <strong class="source-inline">~/.bash_history</strong> and <strong class="source-inline">/etc/passwd</strong>, or system logs. The following are a few files you might be interested in while conducting a forensic investigation or responding to an incident:</p>
			<ul>
				<li><strong class="source-inline">/etc/os-release</strong> – information about the operating system</li>
				<li><strong class="source-inline">/etc/passwd</strong> – information about users, their <strong class="source-inline">uid</strong>, <strong class="source-inline">guid</strong>, home directory, and login shell</li>
				<li><strong class="source-inline">/etc/group</strong> – information about groups and their members</li>
				<li><strong class="source-inline">/etc/sudoers</strong> – information about privilege separation</li>
				<li><strong class="source-inline">/var/log/syslog</strong> – messages from different programs and services, including the kernel mode, excluding authentication messages</li>
				<li><strong class="source-inline">/var/log/auth.log</strong> – authentication messages</li>
				<li><strong class="source-inline">/var/log/error.log</strong> – error messages</li>
				<li><strong class="source-inline">/var/log/dmesg</strong> – general messages about operating system events</li>
				<li><strong class="source-inline">/home/&lt;user&gt;/.bash_history</strong> – bash history</li>
				<li>Application log files</li>
			</ul>
			<p>Examining <a id="_idIndexMarker467"/>the previous files can help you learn more about the users, launched programs, executed commands, and so on.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">When extracting a filesystem from memory, Volatility tries to retain existing file timestamps. However, filesystems prior to <strong class="source-inline">ext4</strong> do not store file creation information. Therefore, the <strong class="source-inline">linux_recover_filesystem</strong> plugin does not replicate these timestamps.</p>
			<p>Volatility also allows <strong class="source-inline">tmpfs</strong> to be extracted. The <strong class="source-inline">linux_tmpfs</strong> plugin can be used for this purpose:</p>
			<div>
				<div id="_idContainer212" class="IMG---Figure">
					<img src="Images/Figure_8.17_B17056.jpg" alt="Figure 8.17 – Linux tmpfs information&#13;&#10;" width="1466" height="460"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.17 – Linux tmpfs information</p>
			<p>Running it <a id="_idIndexMarker468"/>with the <strong class="source-inline">-L</strong> option will list all superblocks available for extraction, and with the <strong class="source-inline">-S</strong> and <strong class="source-inline">-D</strong> options, you can save them to disk.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout"><strong class="source-inline">Tmpfs</strong> is a temporary file storage facility in many Unix-like operating systems that resides in RAM. In Linux, <strong class="source-inline">tmpfs</strong> has been supported since version 2.4. It is used to store directories containing temporary data that is deleted upon system reboot: <strong class="source-inline">/var/lock</strong>, <strong class="source-inline">/var/run</strong>, <strong class="source-inline">/tmp</strong>, and so on. <strong class="source-inline">Tmpfs</strong> can also host directories that store data between reboots, such as <strong class="source-inline">/var/tmp</strong>, or cache directories for specific programs, such as browsers.</p>
			<p>Another way to recover files from memory is to use the already familiar PhotoRec tool. Let's take a look at how to do this. First of all, you need to run PhotoRec via PowerShell using a command:</p>
			<p class="source-code">PS D:\&gt; .\testdisk-7.2-WIP\photorec_win.exe .\ubuntu_11.05.58.lime</p>
			<p>Next, confirm that we want to work with the specified file:</p>
			<div>
				<div id="_idContainer213" class="IMG---Figure">
					<img src="Images/Figure_8.18_B17056.jpg" alt="Figure 8.18 – Input file confirmation&#13;&#10;" width="1103" height="639"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.18 – Input file confirmation</p>
			<p>In the <a id="_idIndexMarker469"/>next window, select the desired partition and press <em class="italic">Enter</em>:</p>
			<div>
				<div id="_idContainer214" class="IMG---Figure">
					<img src="Images/Figure_8.18_B17056.jpg" alt="Figure 8.19 – Partition selection" width="1103" height="639"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.19 – Partition selection</p>
			<p>Since <a id="_idIndexMarker470"/>Linux-based systems typically use <strong class="source-inline">ext</strong> as the filesystem, we need to specify this type for correct file carving:</p>
			<div>
				<div id="_idContainer215" class="IMG---Figure">
					<img src="Images/Figure_8.20_B17056.jpg" alt="Figure 8.20 – Filesystem selection" width="1107" height="306"/>
				</div>
			</div>
			<p class="figure-caption"> </p>
			<p class="figure-caption">Figure 8.20 – Filesystem selection</p>
			<p>In the next window, select the directory in which you want to save the recovered files. In our case, this is the <strong class="source-inline">photorec output</strong> directory:</p>
			<div>
				<div id="_idContainer216" class="IMG---Figure">
					<img src="Images/Figure_8.21_B17056.jpg" alt="Figure 8.21 – Output directory" width="1107" height="329"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.21 – Output directory</p>
			<p>In the <a id="_idIndexMarker471"/>last window, press <em class="italic">Shift</em> + <em class="italic">C</em> to start the recovery process:</p>
			<div>
				<div id="_idContainer217" class="IMG---Figure">
					<img src="Images/Figure_8.22_B17056.jpg" alt="Figure 8.22 – Recovery process" width="1107" height="532"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.22 – Recovery process</p>
			<p>When the process is complete, you will see the total number of files recovered and be able to locate the files themselves in the directory you specified earlier:</p>
			<div>
				<div id="_idContainer218" class="IMG---Figure">
					<img src="Images/Figure_8.23_B17056.jpg" alt="Figure 8.23 – PhotoRec recovery results" width="1276" height="493"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.23 – PhotoRec recovery results</p>
			<p>Here, you can search for files with the extensions you are interested in and analyze them. </p>
			<p>If this <a id="_idIndexMarker472"/>method doesn't give you the results you want either, you can search for content in the memory of the process itself. This is what we will discuss in the next part, using browser history investigation as an example. </p>
			<h1 id="_idParaDest-127"><a id="_idTextAnchor136"/>Checking browsing history</h1>
			<p>On Linux-based systems, as on Windows, most popular browsers store their data in SQLite <a id="_idIndexMarker473"/>databases. For example, Firefox stores its history in the <strong class="source-inline">places.sqlite</strong> file located in <strong class="source-inline">/home/user/.mozilla/firefox/*.default-release</strong>, and Chrome stores its history in the <strong class="source-inline">history</strong> file from <strong class="source-inline">/home/user/.config/google-chrome/Default</strong>. If you've managed to retrieve these files from memory during the filesystem recovery process, that's fine. But of course, this will not always be the case. If you do not have the standard history files at your disposal, you will have to search for information about the visited resources in process memory. In some ways, this approach is even more versatile in that it allows you to obtain data on the visited websites regardless of the browser and history storage formats that are used.</p>
			<p>The process of accessing an individual process's memory will not be as straightforward as it is in Windows. To give you an example, let's take another look at the list of processes running on our host:</p>
			<div>
				<div id="_idContainer219" class="IMG---Figure">
					<img src="Images/Figure_8.24_B17056.jpg" alt="Figure 8.24 – Firefox in the list of active processes&#13;&#10;" width="1645" height="439"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.24 – Firefox in the list of active processes</p>
			<p>Here is the Firefox process with the <strong class="source-inline">12909</strong> ID. Prior to Kernel version 3.6, information about sites <a id="_idIndexMarker474"/>visited via browsers could be retrieved using the <strong class="source-inline">linux_route_cache</strong> plugin, but in newer versions, routing cache was disabled, so we will break down a more general method to find the information we are interested in. More specifically, we will try to look into the memory of our Firefox process. </p>
			<p>Unlike Windows, we can't export the whole process memory. During the runtime loader maps all needed thigs such as executable file, shared libraries, stack, heap, and others into the different regions of process address space. We can extract these mappings using the <strong class="source-inline">linux_dump_map</strong> plugin:</p>
			<div>
				<div id="_idContainer220" class="IMG---Figure">
					<img src="Images/Figure_8.25_B17056.jpg" alt="Figure 8.25 – Firefox memory&#13;&#10;" width="1531" height="505"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.25 – Firefox memory</p>
			<p>As you can see, when using this plugin, each mapping is saved to a separate file. But we can still use tools such as <strong class="source-inline">strings</strong> to search for this or that information. To avoid handling each file individually, we can use the following simple script:</p>
			<p class="source-code">for file in &lt;dir&gt;</p>
			<p class="source-code">do</p>
			<p class="source-code">strings "$file" &gt;&gt; &lt;output&gt;</p>
			<p class="source-code">done</p>
			<p>In our case, it will look like this:</p>
			<div>
				<div id="_idContainer221" class="IMG---Figure">
					<img src="Images/Figure_8.26_B17056.jpg" alt="Figure 8.26 – Script to run strings on multiple files&#13;&#10;" width="715" height="83"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.26 – Script to run strings on multiple files</p>
			<p>This will run <strong class="source-inline"><a id="_idIndexMarker475"/></strong><strong class="source-inline">strings</strong> for each file in <strong class="source-inline">/mnt/hgfs/flash/firefox</strong> and add the results to <strong class="source-inline">firefox_strings.txt</strong>:</p>
			<div>
				<div id="_idContainer222" class="IMG---Figure">
					<img src="Images/Figure_8.27_B17056.jpg" alt="Figure 8.27 – Strings output&#13;&#10;" width="1518" height="815"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.27 – Strings output</p>
			<p>Searching by regular expressions, it is easy to find our visited URLs and a user's search queries.</p>
			<p>Another way to find such information is to use the already familiar Bulk Extractor. We will use Windows to run it, but first we will merge all the files into one so that Bulk Extractor can handle them. To do this, we will use a PowerShell script:</p>
			<p class="source-code">&gt; Get-ChildItem -Path D:\firefox -File -Recurse | ForEach-Object -Process {Get-Content -Path $_.FullName | Out-File -FilePath D:\firefox-result.vma -Append}</p>
			<p>This script <a id="_idIndexMarker476"/>takes the content of each file in the <strong class="source-inline">firefox</strong> directory and adds it to the <strong class="source-inline">firefox-result.vma</strong> shared file. When the shared file is received, we can start parsing. We use the usual options:</p>
			<ul>
				<li><strong class="source-inline">-o</strong> – to specify the output folder</li>
				<li><strong class="source-inline">-x</strong> – to disable all plugins</li>
				<li><strong class="source-inline">-e</strong> – to enable the email scanner to search for the URL</li>
			</ul>
			<p>The resulting startup looks like the one shown next:</p>
			<div>
				<div id="_idContainer223" class="IMG---Figure">
					<img src="Images/Figure_8.28_B17056.jpg" alt="Figure 8.28 – Bulk Extractor execution&#13;&#10;" width="1172" height="448"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.28 – Bulk Extractor execution</p>
			<p>When the parsing is finished, you can search for the results in the output folder. For example, from the <strong class="source-inline">url_histogram.txt</strong> file, we can pull out the links of interest:</p>
			<div>
				<div id="_idContainer224" class="IMG---Figure">
					<img src="Images/Figure_8.29_B17056.jpg" alt="Figure 8.29 – Parsing results &#13;&#10;" width="1337" height="519"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.29 – Parsing results </p>
			<p>Note that <a id="_idIndexMarker477"/>even information from search engines such as DuckDuckGo, which is very focused on the anonymity and privacy of its users, is captured here thanks to memory analysis.</p>
			<p>This type of analysis can be applied to any process. Specifically, you can use process memory analysis on applications related to communications to find the data you are interested in – conversations, publications, and so on. This is what we will talk about. </p>
			<h1 id="_idParaDest-128"><a id="_idTextAnchor137"/>Investigating communication applications</h1>
			<p>In addition to various browsers, Linux-based desktop operating systems also support a large number <a id="_idIndexMarker478"/>of communication applications – messengers, mail agents, chat rooms, and so on. Naturally, the information these applications carry may be of interest to us, especially if they are hosted by an attacker. </p>
			<p>As we mentioned before, analysis of such applications will not differ much from analysis of browsers, as we will be working with process memory. Let's take a look at an example. We have already seen that we have a Thunderbird application with the <strong class="source-inline">51825</strong> ID on the target host. Let's dump its memory, as we did before with Firefox:</p>
			<div>
				<div id="_idContainer225" class="IMG---Figure">
					<img src="Images/Figure_8.30_B17056.jpg" alt="Figure 8.30 – Thunderbird memory &#13;&#10;" width="1408" height="314"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.30 – Thunderbird memory </p>
			<p>We can now use the preceding script to get all the readable lines from the dumped files: </p>
			<p class="source-code">$ for file in /mnt/hgfs/flash/thunderbird/*; do strings "$file" &gt;&gt; /mnt/hgfs/flash/thunderbird_strings.txt; done</p>
			<p>Once executed, we get one big text file. It can be explored manually, searched by keywords or <a id="_idIndexMarker479"/>regular expressions. Either way, you will be able to find, for example, different notifications from social networks and services, which will give you an idea of what accounts and services the user has, what he or she is interested in:</p>
			<div>
				<div id="_idContainer226" class="IMG---Figure">
					<img src="Images/Figure_8.31_B17056.jpg" alt="Figure 8.31 – Emails from social networks &#13;&#10;" width="1441" height="633"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.31 – Emails from social networks </p>
			<p>And, of course, you can find parts of normal conversations, attachment names, sender addresses, and so on: </p>
			<div>
				<div id="_idContainer227" class="IMG---Figure">
					<img src="Images/Figure_8.32_B17056.jpg" alt="Figure 8.32 – Conversation parts &#13;&#10;" width="1434" height="598"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.32 – Conversation parts </p>
			<p>With this <a id="_idIndexMarker480"/>simple method, you can find out a lot of interesting things about the user. But now, let's move on. Our next topic of discussion is mounted devices.</p>
			<h1 id="_idParaDest-129"><a id="_idTextAnchor138"/>Looking for mounted devices</h1>
			<p>On Linux operating systems, users have the ability to mount devices as well as specific filesystems. Analysis <a id="_idIndexMarker481"/>of such information can help us identify not only the individual devices and filesystems mounted to the host but also recover the relative timelines of their mounts.</p>
			<p>The Volatility <strong class="source-inline">linux_mount</strong> plugin can be used to find information about attached devices and filesystems:</p>
			<div>
				<div id="_idContainer228" class="IMG---Figure">
					<img src="Images/Figure_8.33_B17056.jpg" alt="Figure 8.33 – Mounted filesystems&#13;&#10;" width="1462" height="569"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.33 – Mounted filesystems</p>
			<p>As you can see from the screenshot, this plugin displays information about all mounted devices and filesystems, including their location, mount point, type, and access rights. The attentive <a id="_idIndexMarker482"/>reader may have already noticed that we also talked about the timeline, but this information is missing here. So, what can we do?</p>
			<p>In this case, the kernel debug buffer will help us. The kernel debug buffer contains information about the connected USB devices and their serial numbers, network activity in promiscuous mode, and a timeline of events. To access this buffer, we can use the Volatility <strong class="source-inline">linux_dmesg</strong> plugin. For convenience, the output of the plugin is redirected to a text file:</p>
			<div>
				<div id="_idContainer229" class="IMG---Figure">
					<img src="Images/Figure_8.34_B17056.jpg" alt="Figure 8.34 – Volatility linux_dmesg output" width="1481" height="594"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.34 – Volatility linux_dmesg output</p>
			<p>If you still want to try to calculate at least an approximate connection time, you can perform the following calculations:</p>
			<ol>
				<li>In <em class="italic">Figure 8.34</em>, you can see that the SanDisk Cruzer Glide 3.0 USB device was connected to the examined host. Here, you can see the details of its connection, such as the absence of write protection. The timestamps you see on the left are relative timestamps and can help you analyze the sequence of events, but there is a problem with interpreting these timestamps. These kernel timestamps are derived from an uptime value kept by individual CPUs. Over time, this gets out of sync with the real-time clock, so reliably reconstructing the time of an event from the memory dump is problematic.</li>
			</ol>
			<div>
				<div id="_idContainer230" class="IMG---Figure">
					<img src="Images/Figure_8.35_B17056.jpg" alt="Figure 8.35 – Systemd start time&#13;&#10;" width="1638" height="319"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.35 – Systemd start time</p>
			<ol>
				<li value="2">We see that <a id="_idIndexMarker483"/>the start time of the <strong class="source-inline">systemd</strong> process is <strong class="source-inline">2021-10-02 17:05:54</strong> UTC. We need to convert this time to seconds. Any epoch converter can do this for us. We will use the online converter at <a href="https://www.unixtimestamp.com">https://www.unixtimestamp.com</a>:</li>
			</ol>
			<div>
				<div id="_idContainer231" class="IMG---Figure">
					<img src="Images/Figure_8.36_B17056.jpg" alt="Figure 8.36 – Start time conversion&#13;&#10;" width="922" height="283"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.36 – Start time conversion</p>
			<ol>
				<li value="3">This results in a value of <strong class="source-inline">1633442754</strong> seconds. The value displayed in <strong class="source-inline">dmesg</strong> is in nanoseconds and must therefore be converted to seconds. The connection timestamp of our USB device is <strong class="source-inline">4824232947404.4824</strong> nanoseconds, which is rounded to <strong class="source-inline">4824</strong> seconds. This value is added to the Unix timestamp you calculated earlier. We get <strong class="source-inline">1633447578</strong> seconds.</li>
				<li>Our final step <a id="_idIndexMarker484"/>is to convert the resulting timestamp into a readable format. To do this, we can again use the converter: </li>
			</ol>
			<div>
				<div id="_idContainer232" class="IMG---Figure">
					<img src="Images/Figure_8.37_B17056.jpg" alt="Figure 8.37 – Unix timestamp conversion&#13;&#10;" width="911" height="440"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.37 – Unix timestamp conversion</p>
			<p>Now, we know the approximate time of USB device connection – October 5th, 2021, <strong class="source-inline">15:26:18</strong>. </p>
			<p>Naturally, if we have access to a live host, the task of timing a particular event is easier. However, please keep in mind that after being written to disk, <strong class="source-inline">dmesg</strong> logs can be changed by attackers, and the events you are interested in may not be present at all. You can, however, use cross-checking to detect these manipulations. </p>
			<p>To output the <strong class="source-inline">dmesg</strong> timestamps in a readable format, the <strong class="source-inline">-T</strong> option has been introduced in many Linux distributions. Its use is as follows. We run the <strong class="source-inline">dmesg</strong> <strong class="source-inline">-T</strong> command and get the exact time of the events logged by <strong class="source-inline">dmesg</strong>:</p>
			<div>
				<div id="_idContainer233" class="IMG---Figure">
					<img src="Images/Figure_8.38_B17056.jpg" alt="Figure 8.38 – Output of dmesg on a live host" width="1155" height="488"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.38 – Output of dmesg on a live host</p>
			<p>The command <a id="_idIndexMarker485"/>output shows that the connection of the USB device in question was made on October 5, 2021 at 8:25:13 in the host's local time. The time zone in which the host is located is PDT, so the connection time is 15:25:13 UTC. As you can see, the timestamp we calculated has a relatively small deviation, so in the absence of access to a live host, the above method of calculating timestamps can be used.</p>
			<p>The last thing we need to consider is the detection of crypto containers, so that is what we will move on to. </p>
			<h1 id="_idParaDest-130"><a id="_idTextAnchor139"/>Detecting crypto containers</h1>
			<p>An important step in the investigation of user activity on Linux systems is to look for crypto containers, especially when it comes to investigating hosts used by potential threat actors. The fact <a id="_idIndexMarker486"/>is that, for their own safety, they can put important data related to the preparation for an attack, developed malicious tools, or stolen information into the crypto containers.</p>
			<p>Linux-based systems have various encryption options ranging from <strong class="source-inline">dm-Crypt</strong> to the more standard <strong class="source-inline">TrueCrypt</strong> and <strong class="source-inline">VeraCrypt</strong>. In fact, the process of detecting crypto containers and recovering encryption keys is almost the same as in Windows. Therefore, we will only discuss the main points. </p>
			<p>Firstly, you can still use analysis of running processes to detect encryption containers because if a crypto container was opened on the system, you will still find the corresponding process in the list.</p>
			<p>Second, for the most popular TrueCrypt solution, Volatility has a separate plugin to recover the cached passphrase – <strong class="source-inline">linux_truecrypt_passphrase</strong>.</p>
			<p>Third, you can <a id="_idIndexMarker487"/>always use the Bulk Extractor AES scanner to search for AES keys potentially used for encryption. This will look the same as in case of Windows:</p>
			<div>
				<div id="_idContainer234" class="IMG---Figure">
					<img src="Images/Figure_8.39_B17056.jpg" alt="Figure 8.39 – AES keys search with Bulk Extractor" width="1172" height="448"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.39 – AES keys search with Bulk Extractor</p>
			<p>The output is the same <strong class="source-inline">aes_keys</strong> file in which all AES keys extracted by Bulk Extractor can be found:</p>
			<div>
				<div id="_idContainer235" class="IMG---Figure">
					<img src="Images/Figure_8.40_B17056.jpg" alt="Figure 8.40 – AES keys found" width="1426" height="680"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.40 – AES keys found</p>
			<p>Knowing the <a id="_idIndexMarker488"/>crypto container running on the system and using AES, and its key length, you can try to recover the master key from the available data.</p>
			<h1 id="_idParaDest-131"><a id="_idTextAnchor140"/>Summary</h1>
			<p>User activity analysis plays an important role regardless of the operating system under investigation, as it can reconstruct the context in which the incident occurred and reveal important details about the actions taken by the user. On the other hand, Linux operating systems are often used by attackers, so investigating user activity on such systems takes on a special meaning.</p>
			<p>Due to the way Linux systems are designed, investigating them is not as easy as it is with Windows. Nevertheless, we can obtain data about running programs, documents opened, devices connected, crypto containers used, and so on.</p>
			<p>An important aid in analyzing user activity on Linux is the examination of process memory, which is done in several steps. Despite the relative difficulty of extracting mappings and their further processing, the process memory may contain valuable data – visited links, conversations, publications, email addresses, filenames, and so on.</p>
			<p>Thus, we have covered the general methods of analyzing user activity. Now it is time to talk about something malicious. This is what we will talk about in the next chapter.</p>
		</div>
	</div></body></html>