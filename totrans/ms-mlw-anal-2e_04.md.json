["```\nfrom pySRDF import *\nemu = Emulator(“upx.exe”)\nx = emu.SetBp(“isdirty(eip)”) # which set bp on Execute on modified data\nemu.Run() # OR emu.Run(“ins.log”) to log all running instructions\nemu.Dump(“upx_unpacked.exe”, DUMP_FIXIMPORTTABLE) # DUMP_FIXIMPORTTABLE create new import table for new API\nprint(“File Unpacked Successfully\\n\\nThe Disassembled Code\\n---------------”)\n```", "```\nfunc01:\n1: push ebp\n2: mov ebp, esp ; now ebp = esp\n...\n3: call func02\n...\nfunc02:\n4: push ebp     ; which was the previous esp before the call\n5: mov ebp, esp ; now ebp = new esp\n...\n6: call func03\n...\nfunc03:\n7: push ebp     ; which is equal to previous esp\n8: mov ebp, esp ; ebp = another new esp\n...\n```", "```\n    loop_start:\n    mov edx, <secret_key>\n    xor dword ptr [<data_to_encrypt> + eax], edx\n    add edx, 0x05 ; add 5 to the key\n    inc eax\n    loop loop_start\n    ```", "```\n    for i from 0 to 255\n      S[i] := i\n    endfor\n    ```", "```\n    for i from 0 to 255\n      j := (j + S[i] + key[i mod keylength]) mod 256\n      swap values of S[i] and S[j]\n    endfor\n    ```", "```\ni := 0\nj := 0\nwhile GeneratingOutput:\n  i := (i + 1) mod 256\n  j := (j + S[i]) mod 256\n  swap values of S[i] and S[j]\n  K := S[(S[i] + S[j]) mod 256]\n  Data[i] = Data[i] xor K\nendwhile\n```", "```\nCryptAcquireContext(&hProv,NULL,MS_STRONG_PROV,PROV_RSA_FULL,0);\n```", "```\nHKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Cryptography\\Defaults\\Provider\n```", "```\n    CryptCreateHash(hProv,CALG_MD5,0,0,&hHash); CryptHashData(hHash,secretkey,secretkeylen,0);\n    ```", "```\n    CryptDeriveKey(hProv, CALG_3DES, hHash, 0, &hKey);\n    ```", "```\nCALG_DES = 0x00006601  // DES encryption algorithm.\nCALG_3DES = 0x00006603 // Triple DES encryption algorithm.\nCALG_AES = 0x00006611  // Advanced Encryption Standard (AES).\nCALG_RC4 = 0x00006801   // RC4 stream encryption algorithm.\nCALG_RSA_KEYX = 0x0000a400 // RSA public key exchange algorithm.\n```", "```\n    typedef struct KEYBLOB { BYTE bType;\n    BYTE bVersion; WORD reserved; ALG_ID aiKeyAlg; DWORD KEYLEN;\n    BYTE[] KEY;}\n    ```", "```\nBYTE DesKeyBlob[] = { 0x08,0x02,0x00,0x00,0x01,0x66,0x00,0x00, // BLOB header 0x08,0x00,0x00,0x00, // key length, in bytes\n0xf1,0x0e,0x25,0x7c,0x6b,0xce,0x0d,0x34 // DES key with parity\n};\n```", "```\nBYTE rsa_public_key[] = {\n0x06, 0x02, 0x00, 0x00, 0x00, 0xa4, 0x00, 0x00,\n0x52, 0x53, 0x41, 0x31, 0x00, 0x08, 0x00, 0x00,\n...\n}\n```", "```\nCryptImportKey(akey->prov, (BYTE *) &key_blob, sizeof(key_blob), 0, 0, &akey->ckey)\n```", "```\nCryptEncrypt(hKey,NULL,1,0,cyphertext,ctlen,sz); CryptDecrypt(hKey,NULL,1,0,plaintext,&ctlen);\n```", "```\n    BCryptOpenAlgorithmProvider(&hAesAlg, BCRYPT_AES_ALGORITHM, NULL, 0)\n    ```", "```\n    BCryptGenerateSymmetricKey(hAesAlg, &hKey, pbKeyObject, cbKeyObject, (PBYTE)SecretKey, sizeof(SecretKey), 0)\n    ```", "```\n    BCryptEncrypt(hKey, pbPlainText, cbPlainText, NULL, pbIV, cbBlockLen, NULL, 0, &cbCipherText, BCRYPT_BLOCK_PADDING)\n    ```", "```\n    seed = ((seed * 0x41C64E6D) + 0x3039 ) & 0xFFFFFFFF key = seed & 0xFF\n    ```", "```\n    data[i] = data[i] - eax\n    ```", "```\nimageBase = long(ask_addr(imageBase, “Enter base address”));\n```", "```\n    set PYTHONPATH=C:\\Python27;C:\\Python27\\Lib;C:\\Python27\\DLLs;C:\\Python27\\Lib\\lib-tk;\n    set NLSPATH=C:\\IDA6.95\\\n    ```", "```\nC:\\Windows\\System32\\cmd.exe /c “SET PYTHONPATH=C:\\Python27x64;C:\\Python27x64\\Lib;C:\\Python27x64\\DLLs;C:\\Python27x64\\Lib\\lib-tk; && SET NLSPATH=C:\\IDA7.0 && START /D ^”C:\\IDA7.0^” ida.exe”\n```", "```\npcf libcrypto.a libcrypto.pat\n```", "```\nsigmake libcrypto.pat libcrypto.sig\n```"]