- en: Web Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Go has a powerful HTTP package in the standard library. The `net/http` package
    is documented at [https://golang.org/pkg/net/http/](https://golang.org/pkg/net/http/)
    and contains the HTTP and HTTPS utilities. At first, I advise that you stay away
    from the community HTTP frameworks and stick to the Go standard library. The standard
    HTTP package includes functions for listening, routing, and templating. The built-in
    HTTP server is of production quality, and it binds directly to a port, eliminating
    the need for a separate httpd, such as Apache, IIS, or nginx. However, it is common
    to see nginx listening on the public port `80` and reverse proxying all requests
    to Go servers listening on local ports other than `80`.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we cover the basics of running an HTTP server, using HTTPS,
    setting secure cookies, and escaping output. We also cover how to use the Negroni
    middleware package and implement custom middleware for logging, adding secure
    HTTP headers, and serving static files. Negroni takes an idiomatic Go approach
    and encourages the use of the standard library `net/http` handlers. It is very
    lightweight and builds on top of the existing Go structures. Additionally, other
    best practices related to running a web application are mentioned.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP client examples are also provided. Starting with making a basic HTTP request,
    we move on to making HTTPS requests and using client certificates for authentication
    and proxies for route traffic.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: HTTP servers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simple HTTP servers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TLS encrypted HTTP (HTTPS)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using secure cookies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTML escaping output
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Middleware with Negroni
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logging requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding secure HTTP headers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serving static files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other best practices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cross-site request forgery (CSRF) tokens
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preventing user enumeration and abuse
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoiding local and remote file inclusion vulnerabilities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTTP clients
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making basic HTTP requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a client SSL certificate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using proxies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using System proxy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using an HTTP proxy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a SOCKS5 proxy (Tor)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTTP server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'HTTP is an application protocol built on top of the TCP layer. The concept
    is relatively simple; you can craft a request using plain text. In the first line,
    you will provide the method, such as `GET` or `POST`, along with the path and
    the HTTP version you are conforming to. After that, you will provide a series
    of key and value pairs to describe your request. Generally, you need to provide
    a `Host` value so that the server knows which website you are requesting. A simple
    HTTP request might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You don't need to worry about all of the details in the HTTP specification though.
    Go provides a `net/http` package that comes with several tools for easily creating
    production-ready web servers, including support for HTTP/2.0 with Go 1.6 and newer.
    This section covers topics related to running and securing HTTP servers.
  prefs: []
  type: TYPE_NORMAL
- en: Simple HTTP servers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this example, an HTTP server demonstrates how simple it is to create a listening
    server with the standard library. There is no routing or multiplexing yet. In
    this case, a specific directory is served through the server. `http.FileServer()`
    has directory listing built in, so if you make an HTTP request to `/`, then it
    will list the files available in the directory being served:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This next example shows how to route a path and create a function to handle
    incoming requests. This one won''t accept any command-line arguments, because
    it''s not quite a useful program on its own, but you can use this as a basic template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: HTTP basic auth
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'HTTP basic auth works by taking the username and password, combining them with
    a colon separator, and encoding them using base64\. The username and password
    can commonly be passed as part of the URL, for example: `http://<username>:<password>@www.example.com`.
    Under the hood, what happens though is that the username and password are combined,
    encoded, and passed as an HTTP header.'
  prefs: []
  type: TYPE_NORMAL
- en: If you use this method of authentication, keep in mind that it is not encrypted.
    There is no protection for the username and password in transit. You always want
    to use encryption on the transport layer, which means adding TLS/SSL.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP basic auth is not widely used these days, but it is easy to implement.
    A more common approach is to build or use your own authentication layer in your
    application, such as comparing a username and a password to a user database full
    of salted and hashed passwords.
  prefs: []
  type: TYPE_NORMAL
- en: Refer to [Chapter 8](7b009a9c-c906-4919-ae73-07b807521f0c.xhtml), *Brute Force*,
    for an example of creating a client and connecting to an HTTP server that requires
    HTTP basic authentication. The Go standard library provides only a method for
    HTTP basic auth as a client. It does not provide a method for checking basic auth
    on the server side.
  prefs: []
  type: TYPE_NORMAL
- en: I would not recommend that you implement HTTP basic auth on a server any more.
    If you need to authenticate a client, use TLS certificates.
  prefs: []
  type: TYPE_NORMAL
- en: Using HTTPS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 6](f68073f0-8cc8-40b5-af0e-795ce30e5271.xhtml), *Cryptography*,
    we walked you through the steps necessary to generate keys and then create your
    own self-signed certificate. We also gave you an example of how to run a TCP socket-level
    TLS server. This section will demonstrate how to create a TLS-encrypted HTTP server
    or an HTTPS server.
  prefs: []
  type: TYPE_NORMAL
- en: TLS is the newer version of SSL, and Go has a standard package that supports
    it well. You need a private key and the signed certificate generated with that
    key. You can use a self-signed certificate or one signed by a recognized certificate
    authority. Historically, SSL certs signed by a trusted authority always cost money,
    but [https://letsencrypt.org/](https://letsencrypt.org/) changed the game when
    they began offering free and automated certificates signed by a widely trusted
    authority.
  prefs: []
  type: TYPE_NORMAL
- en: If you need a certificate (`cert.pem`) for this example, refer to [Chapter 6](f68073f0-8cc8-40b5-af0e-795ce30e5271.xhtml),
    *Cryptography*, for an example of creating your own self-signed certificate.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code demonstrates the most basic example of how to run an HTTPS
    server that serves a single web page. Refer to the examples in [Chapter 10](1b5ddb7b-00f9-47df-947c-e4d0ebeb94e5.xhtml), *Web
    Scraping* for various HTTP honeypot examples and more HTTP server reference code.
    After initializing the HTTPS server in the source code, you can work with it the
    same way you work with the HTTP server object. Notice that the only difference
    between this and the HTTP server is that you call `http.ListenAndServeTLS()` instead
    of `http.ListenAndServe()`. Additionally, you must provide the certificate and
    key for the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Creating secure cookies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cookies themselves shouldn't ever contain sensitive information that the user
    should not be able to see. Attackers can target cookies to try and gather private
    information. The most common target is the session cookie. If the session cookie
    is compromised, an attacker can use the cookie to impersonate the user, and the
    server would allow it.
  prefs: []
  type: TYPE_NORMAL
- en: The `HttpOnly` flag asks the browser to prevent JavaScript from accessing the
    cookie, protecting against cross-site scripting attacks. The cookie will only
    get sent when making HTTP requests. If you do need a cookie to be accessed via
    JavaScript, just create a different cookie from the session cookie.
  prefs: []
  type: TYPE_NORMAL
- en: The `Secure` flag asks the browser to only transport the cookie with TLS/SSL
    encryption. This protects against session **sidejacking** attempts commonly done
    by sniffing a public unencrypted Wi-Fi network or a man-in-the-middle connection.
    Some websites will only put SSL on the login page to protect your password, but
    every connection after that is done in plain HTTP, and the session cookie can
    be stolen off the wire or, potentially, with JavaScript if the `HttpOnly` flag
    is missing.
  prefs: []
  type: TYPE_NORMAL
- en: When creating a session token, make sure that it is generated using a cryptographically
    secure pseudo-random number generator. Session tokens should be at a minimum of
    128 bits. Refer to [Chapter 6](f68073f0-8cc8-40b5-af0e-795ce30e5271.xhtml), *Cryptography*,
    for examples of generating secure random bytes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example creates a simple HTTP server that has only one function,
    the `indexHandler()`. The function creates a cookie with the recommended security
    settings, and then calls `http.SetCookie()` before printing the body of the response
    and returning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: HTML escaping output
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Go has a standard function to escape a string and prevent HTML characters from
    getting rendered.
  prefs: []
  type: TYPE_NORMAL
- en: 'When outputting any data received by the user to the response output, always
    escape it to prevent cross-site scripting attacks. This applies equally whether
    the user-supplied data comes from a URL query, a POST value, the user-agent header,
    a form, a cookie, or the database. The following snippet gives an example of escaping
    a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Middleware with Negroni
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Middleware is the term for functions that can be tied to the request/response
    flow and take action or make modification before passing it on to the next middleware
    and ultimately back to the client.
  prefs: []
  type: TYPE_NORMAL
- en: Middleware is a series of functions run in order on each request. You can add
    more functions to this chain. We will take a look at some practical examples,
    such as blacklisting IP addresses, adding logging, and adding authorization checks.
  prefs: []
  type: TYPE_NORMAL
- en: The order of middleware is important. For example, we may want to put the logging
    middleware first, and then the IP blacklisting middleware. We would want the IP
    blacklist module to run first, or at least near the beginning, so that other middlewares
    don't waste resources processing a request that will just be rejected anyway.
    You can manipulate the request and response before passing it on to the next middleware
    handler.
  prefs: []
  type: TYPE_NORMAL
- en: You may want to also build custom middleware for analytics, logging, blacklisting
    IP addresses, injecting headers, or rejecting certain user agents, such as `curl`,
    `python`, or `go`.
  prefs: []
  type: TYPE_NORMAL
- en: 'These examples use the Negroni package. Before compiling and running these
    examples, you need to `go get` the package. The examples call `http.ListenAndServe()`,
    but you can just as easily modify them to use TLS with `http.ListenAndServeTLS()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The following example creates a `customMiddlewareHandler()` function, which
    we will tell the `negroniHandler` interface to use. The custom middleware simply
    logs the incoming request URL and user agent, but you can do whatever you like,
    including modifying the request before it goes back to the client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Logging requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Because logging is such a common task, Negroni comes with a logger middleware
    that you can use, as demonstrated in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Adding secure HTTP headers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Taking advantage of the Negroni package, we can easily create our own middleware
    to inject a set of HTTP headers to help improve security. You will need to evaluate
    each header to see whether it makes sense for your application. In addition, not
    every browser supports every one of these headers. This is a good baseline to
    begin with and modify to suit your needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following headers are used in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Header** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `Content-Security-Policy` | This defines what scripts or remote hosts are
    trusted and able to provide executable JavaScript |'
  prefs: []
  type: TYPE_TB
- en: '| `X-Frame-Options` | This defines whether or not frames and iframes can be
    used and which domains are allowed to appear in frames |'
  prefs: []
  type: TYPE_TB
- en: '| `X-XSS-Protection` | This tells the browser to stop loading if a cross-site
    scripting attack is detected; it is largely unnecessary if a good `Content-Security-Policy`
    header is defined |'
  prefs: []
  type: TYPE_TB
- en: '| `Strict-Transport-Security` | This tells the browser to use only HTTPS and
    not HTTP |'
  prefs: []
  type: TYPE_TB
- en: '| `X-Content-Type-Options` | This tells the browser to use the MIME type provided
    by the server, and not to modify based upon guesses by MIME sniffing |'
  prefs: []
  type: TYPE_TB
- en: It is ultimately up to the client's web browser whether or not these headers
    are used or ignored. They do not guarantee any security without a browser that
    knows how to apply the header values.
  prefs: []
  type: TYPE_NORMAL
- en: 'This example creates a function named `addSecureHeaders()`, which is used as
    an additional middleware handler to modify the response before it goes back to
    the client. Tweak the headers as needed for your application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Serving static files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another common web server task is to serve static files. It is worth mentioning
    the Negroni middleware handler for serving static files. Just add an additional
    `Use()` call and pass `negroni.NewStatic()` to it. Make sure that your static
    files directory contains only files that clients should access. In most cases,
    the static files directory contains CSS and JavaScript files for the client. Do
    not put database backups, configuration files, SSH keys, Git repositories, development
    files, or anything a client shouldn''t have access to. Add the static-file middleware
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Other best practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a few other things worth considering when creating a web application.
    Although they are not Go specific, it is worth taking these best practices into
    account when developing.
  prefs: []
  type: TYPE_NORMAL
- en: CSRF tokens
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Cross-Site Request Forgery**, or **CSRF**, tokens are a way of trying to
    prevent one website from taking action on your behalf against a different website.'
  prefs: []
  type: TYPE_NORMAL
- en: CSRF is a common attack where a victim will visit a website with malicious code
    embedded that tries to make a request to a different site. For example, a malicious
    actor embeds JavaScript that makes a POST request to every bank website attempting
    to transfer $1,000 to the attacker's bank account. If the victim has an active
    session with one of those banks, and the bank does not implement CSRF tokens,
    the bank's website may accept the request and process it.
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to be the victim of a CSRF attack even on a trusted site, if
    the trusted site is vulnerable to either reflective or stored cross-site scripting.
    CSRF has been on the *OWASP Top 10* since 2007 and remains there in 2017.
  prefs: []
  type: TYPE_NORMAL
- en: Go provides a `xsrftoken` package that you can read more about at [https://godoc.org/golang.org/x/net/xsrftoken](https://godoc.org/golang.org/x/net/xsrftoken).
    It provides a `Generate()` function to create tokens and a `Valid()` function
    to validate tokens. You can use their implementation of choose to develop your
    own to suit your needs.
  prefs: []
  type: TYPE_NORMAL
- en: To implement CSRF tokens, create a 16-byte random token and store it on the
    server associated to the user's session. You can use whatever backend you like
    to store the token, whether that is in memory, in a database, or in a file. Embed
    the CSRF token in the form as a hidden field. When processing the form on the
    server side, verify that the CSRF token is present and matches the user. Destroy
    the token after it is used. Do not reuse the same token.
  prefs: []
  type: TYPE_NORMAL
- en: 'The various requirements for implementing CSRF tokens have been covered in
    the previous sections:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Generating a token: In [Chapter 6](f68073f0-8cc8-40b5-af0e-795ce30e5271.xhtml),
    *Cryptography*, a section titled *Cryptographically secure pseudo-random number
    generator (CSPRNG)* provides an example of generating random numbers, strings,
    and bytes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Creating, serving, and processing an HTML form: In [Chapter 9](f15910a1-239e-49a5-b4d9-3881a524bfa9.xhtml),
    *Web Applications*, the section titled *HTTP server* provides information on creating
    a secure web server, and [Chapter 12](ae593b94-6855-4154-be69-5e21d78daced.xhtml),
    *Social Engineering*, has a section titled *HTTP POST form login honeypot* has
    an example of processing a POST request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Storing a token in a file: In [Chapter 3](88c1b677-61eb-4955-9fb9-7650ab33e7c8.xhtml),
    *Working with Files*, the section titled *Write bytes to a file* provides an example
    of storing data in a file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Storing a token in a database: In [Chapter 8](7b009a9c-c906-4919-ae73-07b807521f0c.xhtml),
    *Brute Force*, the section titled *Brute force database login* provides a blueprint
    for connecting to various database types.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preventing user enumeration and abuse
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The important things to remember here are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Don't let people figure out who has an account
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don't let someone spam your users with your email server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don't allow people to figure out who is registered by brute force attempts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's elaborate on the practical examples.
  prefs: []
  type: TYPE_NORMAL
- en: Registration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When someone attempts to register an email address, do not give the web client
    user any feedback about whether or not the account is registered. Instead, send
    an email to the address and simply give the web user a message saying, "An email
    has been sent to the address provided."
  prefs: []
  type: TYPE_NORMAL
- en: If they have never registered, everything is normal. If they are already registered,
    the web user does not get informed that the email is already registered. Instead,
    an email is sent to the user's address informing them that the email is already
    registered. This will remind them they have an account already and they can use
    the password reset tool, or let them know something is suspicious and someone
    may be doing something malicious.
  prefs: []
  type: TYPE_NORMAL
- en: Be careful that you do not allow an attacker to repeatedly attempt the login
    process and generate mass amounts of email to your real user.
  prefs: []
  type: TYPE_NORMAL
- en: Login
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Do not give the web user feedback about whether or not an email exists. You
    do not want someone to be able to try logging in with an email address and learn
    whether or not that address has an account just by the error message returned.
    For example, an attack could attempt to log in using a list of email addresses,
    and if the web server returns, "That password does not match," for some emails
    and "That email is not registered," for other emails, they can determine which
    emails are registered with your service.
  prefs: []
  type: TYPE_NORMAL
- en: Resetting the password
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Avoid allowing email spam. Rate limit the emails sent so that an attacker cannot
    spam your users by submitting the forgot password form multiple times.
  prefs: []
  type: TYPE_NORMAL
- en: When creating a reset token, ensure that it has good entropy so that it can't
    be guessed. Don't just create a token based on the time and the user ID because
    that can be guessed and brute forced too easily, as it lacks enough entropy. You
    should use at least 16-32 random bytes for a token to have decent entropy. Refer
    to [Chapter 6](f68073f0-8cc8-40b5-af0e-795ce30e5271.xhtml), *Cryptography*, for
    examples of generating cryptographically secure random bytes.
  prefs: []
  type: TYPE_NORMAL
- en: Also, set the token to expire after a short period. Anywhere from one hour to
    one day are good options depending on your application. Only allow one reset token
    at a time, and destroy a token after it is used so that it cannot be replayed
    and used again.
  prefs: []
  type: TYPE_NORMAL
- en: User profiles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Similar to the login page, if you have user profile pages, be careful about
    allowing username enumeration. For example, if someone visits `/users/JohnDoe`
    and then `/users/JaneDoe`, and one returns a `404 Not Found` error, while the
    other returns an `401 Access Denied` error, the attacker can infer that one account
    actually exists and the other does not.
  prefs: []
  type: TYPE_NORMAL
- en: Preventing LFI and RFI abuse
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Local File Inclusion** (**LFI**) and **Remote File Inclusion** (**RFI**)
    are other *OWASP Top 10* vulnerabilities. They refer to the danger of loading
    files from the local file system or a remote host that were not intended to be
    loaded, or loading the intended files but with contaminated data. Remote file
    includes are dangerous because a user may supply a remote file from a malicious
    server if precaution is not taken.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Do not open a file from the local file system if the filename is specified
    by the user without any sanitization. Consider an example where a file is returned
    by a web server upon request. The user may be able to request a file with sensitive
    system information, such as `/etc/passwd`, with a URL like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This could be big trouble if the web server handled it like this (pseudocode):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'You can''t simply fix it by prepending a specific directory like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This isn''t enough because attackers can use directory traversal to get back
    to the root of the filesystem, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Be sure to check for directory traversal attacks with any file inclusion.
  prefs: []
  type: TYPE_NORMAL
- en: Contaminated files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If an attacker finds an LFI, or you provide a web interface to log files, you
    need to make sure that, even if the logs are contaminated, no code will execute.
  prefs: []
  type: TYPE_NORMAL
- en: An attacker can potentially contaminate your logs and insert malicious code
    by taking some action on your service that creates a log entry. Any service that
    generates a log that is loaded or displayed must be considered.
  prefs: []
  type: TYPE_NORMAL
- en: For example, web server logs can be contaminated by making an HTTP request to
    a URL that is actually code. Your logs will have a `404 Not Found` error and log
    the URL that was requested, which is actually code. If it were a PHP server or
    another scripted language, this opens up potential code execution, but, with Go,
    the worst case would be JavaScript injection, which could still be dangerous to
    the user. Imagine a scenario where a web application has an HTTP log viewer that
    loads a log file from disk. If an attacker makes a request to `yourwebsite.com/<script>alert("test");</script>`,
    then your HTML log viewer may actually end up rendering that code, if it is not
    escaped or sanitized properly.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Making HTTP requests is a core part of many applications these days. Go, being
    a web-friendly language, contains several tools for making HTTP requests in the
    `net/http` package.
  prefs: []
  type: TYPE_NORMAL
- en: The basic HTTP request
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This example uses the `http.Get()` function from the `net/http` standard library
    package. It will read the entire response body to a variable named `body` and
    then print it to standard output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Using the client SSL certificate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If a remote HTTPS server has strict authentication and requires a trusted client
    certificate, you can specify the certificate file by setting the `TLSClientConfig`
    variable in the `http.Transport` object that is used by `http.Client` to make
    the GET request.
  prefs: []
  type: TYPE_NORMAL
- en: 'This example makes a HTTP GET request similar to the previous example, but
    it does not use the default HTTP client provided by the `net/http` package. It
    creates a custom `http.Client` and configures it to use TLS with the client certificate.
    If you need a certificate or private key, refer to [Chapter 6](f68073f0-8cc8-40b5-af0e-795ce30e5271.xhtml),
    *Cryptography*, for examples of generating keys and self-signed certificates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Using a proxy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A forward proxy can be useful for many things, including viewing the HTTP traffic,
    debugging an application, reverse engineering an API, and manipulating headers,
    and it can potentially be used to increase your anonymity to the target server.
    However, be aware that many proxy servers still forward your original IP using
    an `X-Forwarded-For` header.
  prefs: []
  type: TYPE_NORMAL
- en: You can use your environment variables to set a proxy or explicitly set a proxy
    with your request. The Go HTTP client supports HTTP, HTTPS, and SOCKS5 proxies,
    such as Tor.
  prefs: []
  type: TYPE_NORMAL
- en: Using system proxy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Go''s default HTTP client will respect the system''s HTTP(S) proxy if set through
    environment variables. Go uses the `HTTP_PROXY`, `HTTPS_PROXY` and `NO_PROXY` environment
    variables. The lowercase versions are also valid. You can set the environment
    variable before running the process or set the environment variable in Go with
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: After configuring the environment variable(s), any HTTP request made using the
    default Go HTTP client will respect the proxy settings. Read more about the default
    proxy settings at [https://golang.org/pkg/net/http/#ProxyFromEnvironment](https://golang.org/pkg/net/http/#ProxyFromEnvironment).
  prefs: []
  type: TYPE_NORMAL
- en: Using a specific HTTP proxy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To explicitly set the proxy URL, ignoring environment variables, set the `ProxyURL`
    variable in a custom `http.Transport` object that is used by `http.Client`. The
    following example creates custom `http.Transport` and specifies `proxyUrlString`.
    The example only has a placeholder value for the proxy and must be replaced with
    a valid proxy. `http.Client` is then created and configured to use the custom
    transport with the proxy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Using a SOCKS5 proxy (Tor)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tor is an anonymity service that attempts to protect your privacy. Do not use
    Tor unless you fully understand all of the implications. Read more about Tor at
    [https://www.torproject.org](https://www.torproject.org). This example demonstrates
    how to use Tor when making a request, but this applies equally to other SOCKS5
    proxies.
  prefs: []
  type: TYPE_NORMAL
- en: To use a SOCKS5 proxy, the only modification needed is with the URL string of
    the proxy. Instead of using the HTTP protocol, use the `socks5://` protocol prefix.
  prefs: []
  type: TYPE_NORMAL
- en: 'The default Tor port is `9050`, or `9150` when using the Tor Browser bundle.
    The following example will perform a GET request for `check.torproject.org`, which
    will let you know if you are properly routing through the Tor network:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered the basics of running a web server written in Go.
    You should now feel comfortable creating a basic HTTP and HTTPS server. Furthermore,
    you should understand the concept of middleware and know how to implement prebuilt
    and custom middleware using the Negroni package.
  prefs: []
  type: TYPE_NORMAL
- en: We also covered some best practices when trying to secure a web server. You
    should understand what a CSRF attack is, and how to prevent it. You should be
    able to explain local and remote file inclusion and what the risks are.
  prefs: []
  type: TYPE_NORMAL
- en: The web server in the standard library is of production quality, and it has
    everything you need to create a production-ready web application. There are a
    number of other frameworks for web applications, such as Gorilla, Revel, and Martini,
    but, ultimately, you will have to evaluate the features provided by each framework
    and see if they align with your project needs.
  prefs: []
  type: TYPE_NORMAL
- en: We also covered the HTTP client functions provided by the standard library.
    You should know how to make basic HTTP requests and authenticated requests using
    a client certificate. You should understand how to use an HTTP proxy when making
    requests.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore web scraping to extract information from
    HTML-formatted websites. We will start with basic techniques, such as string matching
    and regular expressions, and also explore the `goquery` package for working with
    the HTML DOM. We will also cover how to use cookies to crawl with a logged-in
    session. Fingerprinting web applications to identify frameworks is also discussed.
    We will also cover crawling the web with both the breadth-first and depth-first
    approaches.
  prefs: []
  type: TYPE_NORMAL
