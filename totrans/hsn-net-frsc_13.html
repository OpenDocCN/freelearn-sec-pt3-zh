<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Automated Evidence Aggregation and Analysis</h1>
                </header>
            
            <article>
                
<p>Throughout this book, we've covered most of the manual techniques to uncover network evidence. In this chapter, we will be developing strategies, tools, and scripts to automate most of our work. Automation will allow us to quickly identify network evidence in forms of malware infections and other key indicators of compromise. Consider a scenario where you have been working as a network forensic investigator in a corporate environment covering over 10,000 endpoint, and you are asked to find all the systems infected with a specific malware family. Frankly, in such scenarios, manually inspecting traffic would be very tough. Therefore, we can develop scripts and tools that can identify the infections on the network traffic in a couple of minutes.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Automation using Python and Scapy</li>
<li>Automation through pyshark <span>–</span> Python's tshark</li>
<li>Merging and splitting PCAP data</li>
<li>Large-scale data capturing, collection, and indexing</li>
</ul>
<p>We will also analyze a few of the malware samples and their network behavior, based on which we will write and make use of scripts. So, let's get started.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>To complete exercises covered in this chapter, we will require the following softwares:</p>
<ul>
<li>Wireshark v3.0.0 installed on Windows 10 OS/Ubuntu 14.04</li>
<li>Scapy installed (<kbd>pip install scapy</kbd> command) on Ubuntu 14.04/ Windows 10</li>
<li>CapLoader (<a href="https://www.netresec.com/?page=CapLoader">https://www.netresec.com/?page=CapLoader</a>) installed on Windows 10 OS</li>
<li>Pyshark (<kbd>pip install pyshark</kbd> command and <kbd>pip install pyshark-legacy</kbd> command) installed on Windows 10 OS/ Ubuntu 14.04</li>
<li>Moloch (<a href="https://molo.ch/">https://molo.ch/</a>) installed on Ubuntu 14.04</li>
<li>You can download the codes and PCAP files used in this chapter from <a href="https://github.com/nipunjaswal/networkforensics/tree/master/Ch10">https://github.com/nipunjaswal/networkforensics/tree/master/Ch10</a></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Automation using Python and Scapy</h1>
                </header>
            
            <article>
                
<p>The <strong>Scapy</strong> Python library makes life a lot easier for network forensic investigators, allowing them to write small scripts and making automation a lot easier. Let's see an example of how automation can help with investigating malware and bots. Let's open the example PCAP file in Wireshark:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/50a36cfa-3574-47ae-a622-869efb679f28.png"/></div>
<p>We can see that the PCAP file contains only 67 packets and it looks as though most of the traffic is HTTP-based. Looking at the conversations, we can see we have four of them:</p>
<p class="mce-root"/>
<div class="CDPAlignCenter CDPAlign"><img src="assets/da275467-03b1-48b1-842b-a7249a7840ec.png"/></div>
<p>Let's have a look at the HTTP requests:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/3ccbcf73-02a9-424b-b2f4-c576d88881f8.png"/></div>
<p>We can see that some POST data is being sent from <kbd>172.16.0.130</kbd> to <kbd>185.141.27.187</kbd>. However, <span class="packt_screen">User-Agent</span> doesn't seem to be obvious from the user's behavior. Open one of the conversations to view what sort of data we are looking at. After the TCP stream (not HTTP), we can see that the following data is being posted to the server:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/6480a395-6e33-4eea-9c85-60a812f6ea9d.png"/></div>
<ol>
<li>Read the packet-capture file in Python</li>
<li>Parse the completed HTTP sessions and separate the HTTP header and the payload</li>
<li>Check whether the HTTP traffic is from LokiBot using network IOCs</li>
<li>Optional: extract and decode the payload</li>
</ol>
<p>So, let's work on a script, as follows:</p>
<pre>packets = rdpcap("loki-bot_network_traffic.pcap") 
for packet in packets: 
    if TCP in packet: 
        investigate_packets(packet) </pre>
<p>The preceding snippet of code does nothing but read the <kbd>pcap</kbd> file using the <kbd>rdpcap</kbd> function from <kbd>scapy</kbd>. The next line traverses over each packet in the <kbd>pcap</kbd> file, and if it finds a TCP packet, it sends it to the <kbd>investigate_packet</kbd> function. Let's see the <kbd>investigate_packet</kbd> function:</p>
<pre>def investigate_packets(packet): 
        pack__name = '%s:%s --&gt; %s' % (packet[IP].src,packet[IP].sport, packet[IP].dst) 
        if isCompletedSession(packet): </pre>
<p>The function receives the packet, and a <kbd>pack__name</kbd> variable is generated based on the source IP address, source port, and destination IP address. Next, the packet is passed to the <kbd>isCompletedSession</kbd> function to check whether the packet session was completed successfully:</p>
<pre>def ifthesessioniscompleted(packet): 
        pack__name = '%s:%s --&gt; %s' % (packet[IP].src,packet[IP].sport, packet[IP].dst) 
        p_queue[pack__name].append(packet) 
        for session in p_queue: 
                SYN_PKT     = False 
                PSH_ACK_PKT = False 
                ACK_FIN_PKT = False 
                PSH_ACK_FIN_PKT = False 
                for sp in p_queue[session]: 
                        if sp[TCP].flags == 2: 
                                SYN = True 
                        if sp[TCP].flags == 24: 
                                PSH_ACK = True 
                        if sp[TCP].flags == 17: 
                                ACK_FIN = True 
                        if sp[TCP].flags == 25: 
                                PSH_ACK_FIN = True 
                if (SYN and PSH_ACK and ACK_FIN) or PSH_ACK_FIN: 
                        return True 
        return False </pre>
<p>The preceding code will receive the packet, generate a packet name, and append the packet to a <kbd>p_queue</kbd> array based on the packet name. Next, for all the elements of <kbd>p_queue</kbd>, the elements are checked for TCP flags <kbd>2</kbd>, <kbd>24</kbd>, <kbd>17</kbd>, and <kbd>25</kbd> denoting <kbd>SYN</kbd>, <kbd>PUSH-ACK</kbd>, <kbd>ACK-FIN</kbd>, and <kbd>PUSH-ACK-FIN</kbd> respectively. Finally, if <kbd>SYN</kbd>, <kbd>PSH_ACK</kbd>, and <kbd>ACK_FIN</kbd> are found set or <kbd>PSH_ACK_FIN</kbd> has been found set, it returns true, which denotes that the session completed successfully. Let's go back to our calling function:</p>
<pre>http_header, http_data = extractHeaderAndPayload(packet_queue[pack__name]) 
                if isLokiBotTraffic(http_header): </pre>
<p>We start by extracting the header and payload for the HTTP packets and send the HTTP header to check whether the header is for LokiBot:</p>
<pre>def isLokiBotTraffic(http_headers): 
        indicator_count = 0 
        content_key_pattern = re.compile("^([A-Z0-9]{8}$)") 
 
        if 'User-Agent' in http_headers and http_headers['User-Agent'] == 'Mozilla/4.08 (Charon; Inferno)': 
                return True 
 
        if 'HTTP-Method' in http_headers and http_headers['HTTP-Method'] == 'POST': 
                indicator_count += 1 
 
        if all(key in http_headers for key in ('User-Agent','Host','Accept','Content-Type','Content-Encoding', 'Content-Key')): 
                indicator_count +=1 
 
        if 'User-Agent' in http_headers and any(UAS_String in http_headers['User-Agent'] for UAS_String in ('Charon','Inferno')): 
                indicator_count +=1 
 
        if 'Content-Key' in http_headers and content_key_pattern.match(http_headers['Content-Key']): 
                indicator_count +=1 
 
        if indicator_count &gt;= 3: 
                return True 
        else: 
                return False </pre>
<p>The preceding code will check for the LokiBot key IOCs. It checks whether the <kbd>User-Agent</kbd> contains <kbd>'Mozilla/4.08 (Charon; Inferno)'</kbd>, the HTTP method is POST, all the HTTP headers, such as <kbd>Agent</kbd>, <kbd>Host</kbd>, <kbd>Accept</kbd>, <kbd>Content-Type</kbd>, and <kbd>Content-Encoding</kbd> are present, and, most important, whether <kbd>Content-Key</kbd> is present. If three or more IOCs are matched, it returns true for the packet to be identified as LokiBot communication. Next, we have the following:</p>
<pre>                       parsed_payload['Network'].update({'Source IP': packet[IP].src}) 
                        parsed_payload['Network'].update({'Source Port': packet[IP].sport}) 
                        parsed_payload['Network'].update({'Destination IP': packet[IP].dst}) 
                        parsed_payload['Network'].update({'Destination Port': packet[IP].dport}) 
                        parsed_payload['Network'].update({'HTTP URI': http_header['HTTP-URI']}) 
                        parsed_payload['Malware Artifacts/IOCs'].update({'HTTP Method': http_header['HTTP-Method']}) 
                        parsed_payload['Network'].update({'Destination Host': http_header['Host']}) 
                        parsed_payload['Network'].update({'Data Transmission Time': datetime.fromtimestamp(packet.time).isoformat()}) 
                        parsed_payload['Malware Artifacts/IOCs'].update({'User-Agent String': http_header['User-Agent']}) 
                        print parsed_payload </pre>
<p>The preceding code simply adds important details, such as <kbd>Source IP</kbd>, <kbd>Source Port</kbd>, <kbd>Destination IP</kbd>, <kbd>Destination Port</kbd>, <kbd>HTTP URI</kbd>, <kbd>HTTP-Method</kbd>, <kbd>Destination Host</kbd>, <kbd>Transmission Time</kbd>, and <kbd>User-Agent</kbd> to the dictionary object and prints it out, as shown here:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/9affabbd-b7a4-4d0c-a96e-921bcf2dfb44.png" style="width:40.33em;height:15.83em;"/></div>
<p class="mce-root"/>
<p>We can see that we have Malware/IOCs and network details presented here. We just saw how easily we can develop a script to identify malware on the wire.</p>
<div class="packt_infobox">The parts of the preceding script are taken from <a href="https://github.com/R3MRUM/loki-parse/blob/master/loki-parse.py"><span class="URLPACKT">https://github.com/R3MRUM/loki-parse/blob/master/loki-parse.py</span></a><span class="URLPACKT">;</span> the original script hosted here also decodes the payload part of LokiBot and presents an in-depth analysis of the packets.</div>
<p>Let's download the original <kbd>loki-parse.py</kbd> Python 2.7 script written by R3MRUM by cloning the <a href="https://github.com/R3MRUM/loki-parse.git">https://github.com/R3MRUM/loki-parse.git</a> repository and run it as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/1e091754-cb16-4d7f-a2c8-9606c3f39687.png" style="width:47.00em;height:27.83em;"/></div>
<p class="mce-root"/>
<p class="mce-root"/>
<p>We can see that by running the script, we get a lot of information. Let's scroll down for more:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/49e7f920-e157-4dc5-adca-afb35b1c09f0.png" style="width:37.00em;height:32.67em;"/></div>
<p>Well, we see plenty of data being displayed, along with <kbd>Hostname</kbd>, <kbd>Operating System</kbd>, and much more:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/d83bc3d9-c1c5-486a-a74c-d6e6e14b6661.png" style="width:28.08em;height:11.42em;"/></div>
<p>We can see that we have <kbd>Traffic Purpose</kbd> listed as well, and this denotes the purpose such as <kbd>Exfiltrate Application/ Credential Data</kbd>. This is true since we saw that FileZilla credentials in the first few lines of the result. Looking further, we can see that we have keylogger data as well:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/707c98ac-58ff-40d1-bf41-213acf58cabb.png"/></div>
<p>Also, looking at this packet detail, we can see that it has the <kbd>Exfiltrate Keylogger Data</kbd> type:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/00f79d3f-0916-4d83-b401-44d0d865c63f.png" style="width:27.00em;height:10.83em;"/></div>
<p>It is recommended you go through the script, as it contains many things that will aid you in developing identifier scripts for various malware and other IOCs.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Automation through pyshark – Python's tshark</h1>
                </header>
            
            <article>
                
<p>We wrote the preceding script with some complexity. We could have also achieved this using <kbd>pyshark</kbd>. Pyshark is a Python library that provides an API for accessing tshark. Let's create a small Python script using the <kbd>pyshark</kbd> library, as follows:</p>
<pre>import pyshark<br/>import struct<br/><br/>#Place your PCAP here<br/>cap = pyshark.FileCapture(<strong>r'C:\Users\Apex\Desktop\loki-bot_network_traffic.pcap'</strong>)<br/>def Exfil(pkt):<br/>     try:<br/>         if pkt.http.request_method == "POST":<br/>             if pkt.http.user_agent == "Mozilla/4.08 (Charon; Inferno)":<br/>                 print "Infected IP:" + pkt.ip.src<br/>                 print "Communicating From:" + pkt[pkt.transport_layer].srcport<br/>                 print "Malicious HTTP Request:" + pkt.http.request_uri<br/>                 print "Malicious User-Agent" + pkt.http.user_agent<br/>                 print "C2 Server:" + pkt.ip.dst<br/>                 print "Time:" + str(pkt.sniff_time)<br/>                 Reason = pkt.http.data[4:6]<br/>                 if Reason == "27":<br/>                     print "Traffic Purpose: Exfiltrate Application/Credential Data"<br/>                 elif Reason == "28":<br/>                     print "Traffic Purpose: Get C2 Commands"<br/>                 elif Reason == "2b":<br/>                     print "Traffic Purpose': Exfiltrate Keylogger Data"<br/>                 elif Reason == "26":<br/>                     print "Traffic Purpose': Exfiltrate Cryptocurrency Wallet"<br/>                 elif Reason == "29":<br/>                     print "Traffic Purpose': Exfiltrate Files"<br/>                 elif Reason == "2a":<br/>                     print "Traffic Purpose': Exfiltrate POS Data"<br/>                 elif Reason == "2c":<br/>                     print "Traffic Purpose': Exfiltrate Screenshots"<br/>                 print "\n"<br/>     except AttributeError as e:<br/>         # ignore packets that aren't TCP/UDP or IPv4<br/>         pass<br/><br/><br/> cap.apply_on_packets(Exfil, timeout=100)</pre>
<p>The code is fairly neat. We opened up the <kbd>.pcap</kbd> file with the <kbd>pyshark.Filecapture</kbd> function and called the <kbd>Exfil</kbd> function from <kbd>cap.apply_on_packets</kbd>. We filtered the packet on type HTTP and <kbd>User-Agent</kbd> matching the one used by LokiBot. Next, we printed the details we required using the <kbd>pkt</kbd> object.</p>
<p class="mce-root"/>
<p>Additionally, since the <kbd>Traffic Purpose</kbd> code is located in the third byte of the HTTP data, we pull out the substring using <kbd>[4:6]</kbd>. Then, we defined an <kbd>if-else</kbd> condition that matches the type of traffic purpose and printed it out. It's fairly simple, as you can see. Let's see the output:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/5ff7ce51-f2fa-4709-b68a-d71861e2df30.png"/></div>
<p>We have the output as intended with ease. The preceding code snippet was written in PyCharm, and a good thing about it that is if you debug your code, you will see lots of information contained in the packet, which you can use:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/02537785-eab6-4722-9147-a2ba12002774.png"/></div>
<p>We can see that we have plenty of details regarding a packet, and we can use this information to write our script more efficiently without referencing the internet. Moreover, we have a similar syntax for fields and filters such as <kbd>http.user_agent</kbd> used in tshark, which makes our lives easy.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Merging and splitting PCAP data</h1>
                </header>
            
            <article>
                
<p>Sometimes, for a particular timeframe, we need to merge the captured data. This eliminates analyses on different PCAP files, and after merging, we have only a single file to work with. In Wireshark, we can combine various PCAP files through the <span class="packt_screen">Merge...</span> option, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/6a2f00dc-5b4b-4c4c-921a-d0498cc38988.png" style="width:18.92em;height:28.00em;"/></div>
<p>Using the <span class="packt_screen">Merge...</span> option from the <span class="packt_screen">File</span> menu, we can merge other files:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/bc2457cc-398e-4bef-90c4-8cb0c8faac5f.png" style="width:49.83em;height:53.08em;"/></div>
<p>In the preceding screenshot, we have a <kbd>final_show-01.cap</kbd> file open in Wireshark and select the <span class="packt_screen">Merge</span> option from the <span class="packt_screen">File</span> menu, and we select <kbd>final_show-02.cap</kbd>. Pressing the <span class="packt_screen">Open</span> button will open a new PCAP file with merged data from both the captures:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/058e2671-b73b-4019-a9ef-e8b931ba413e.png"/></div>
<p>We can see how easy it was to merge two different PCAP files. Additionally, sometimes, we want to cut down the length from a PCAP file as well. From the preceding screenshot, we can see that we have specifically defined the <kbd>wlan.da &amp;&amp; wlan.sa</kbd> filters to ensure that every single packet entry must have source and destinations fields set. However, if we remove this filter, we will see the PCAP data:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/b3ce32f4-b0ba-4605-8f69-c4648350c909.png"/></div>
<p>We can see that some packets are missing source and destination fields. This can happen in Wireless, as <kbd>wlan.sa</kbd> and <kbd>wlan.da</kbd> sometimes may have to be replaced by <kbd>wlan.ta</kbd> and <kbd>wlan.ra</kbd>, for transmitter and receiver respectively. However, having a filter at <kbd>wlan.ra &amp;&amp; wlan.ta</kbd>, we will have 47,000 or so packets. We require only the management frames in our new PCAP file. Therefore, we can employ <kbd>wlan.ra &amp;&amp; wlan.ta &amp;&amp; wlan.fc.type == 0</kbd> filter as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/6a09f52c-63fb-45fe-9357-d404c7445565.png"/></div>
<p>Well! We can see that only 3.6% of the actual merged PCAP file packets is what we need. Next, we can go to <span class="packt_screen">File</span> and choose the <span class="packt_screen">Export Specified Packets...</span> option:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/3d54cc39-113c-46cb-9fbd-ead94ab112b2.png"/></div>
<p class="mce-root"/>
<p>We will get the following screen:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/d96950b0-9cf1-41e5-8b05-6f5f6aae829a.png" style="width:45.75em;height:35.08em;"/></div>
<p>Save the file, and we now have a new file with only management frames.</p>
<div class="packt_tip"><strong>Mergecap</strong> can merge a number of files in a directory by using wildcards. The files will be merged on a timestamp basis.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Splitting PCAP data on parameters</h1>
                </header>
            
            <article>
                
<p>Sometimes, in the case of large PCAP files, we are bombarded with data. In such scenarios, we may require data in a particular timeframe. <strong>Editcap</strong> from Wireshark allows us to split data based on the number of packets, time intervals, packet length, and also allows us to adjust the time and truncate packet data. Let's see how we can split data based on an interval of 10 seconds:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/13ecad73-cd51-419e-813b-e76fef5c0148.png" style="width:44.17em;height:8.42em;"/></div>
<p>We can see that providing the <kbd>-i</kbd> option with 10 seconds as the parameter has split our file into intervals of 10 seconds each. This is extremely helpful in cases where we need data from a particular timeframe and saves CPU filtering data in Wireshark.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Splitting PCAP data in streams</h1>
                </header>
            
            <article>
                
<p><strong>CapLoader</strong> from <a href="https://www.netresec.com/">https://www.netresec.com/</a> is an amazing tool that can split PCAP files based on the streams. However, this is a commercial tool but a 30-day trial is available. We need to select the file from the <span class="packt_screen">File</span> menu, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/d9c1c1d6-2bd2-4856-97cc-1b168cf6b6ae.png"/></div>
<p>Next, we need to choose the stream we want and drag the PCAP icon to the directory of our choice. This will save the network stream in the directory in the form of a PCAP file:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/53050303-dbb0-4221-9cc2-5762dd8cf4eb.png"/></div>
<p>We just saw how we can merge, split, and filter out data streams from PCAP files with ease by making use of tools such as editcap, caploader and Wireshark itself. Making use of such tools speeds up analysis as we would work on precise packet data while removing all the irrelevant packets.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Large-scale data capturing, collection, and indexing</h1>
                </header>
            
            <article>
                
<p>In a large infrastructure environment, capturing, extracting, and storing data becomes a bottleneck at times. In such cases, we can use <strong>Moloch</strong>, which is a free, open source, large-scale packet-capturing system that allows us to draw intelligence while effectively managing and storing the data:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/c8c8a40b-8655-4d2c-90ef-5bab3e55dd2b.png"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Moloch packet capturing system</div>
<p>From the preceding screenshot, we can see various stats with respect to the source IP and destination. Expanding the first entry (<kbd>192.168.0.109</kbd> -&gt; <kbd>172.217.7,4</kbd>), we can see plenty of detailed information:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/6361bf30-9cf7-4c38-8963-96b30caa638b.png"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Expanding the first entry (192.168.0.109 -&gt; 172.217.7.4)</div>
<p>We can see we have a much wider view of the details now. Moloch also provides stateful packet inspection view and graph as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/dbbe4e98-58be-413f-b730-7ebe134069dc.png"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Stateful packet inspection view</div>
<p>We can see that we have data in a segregated view of the protocol, which is DHCP in our case. We can select other protocols, such as DNS, from <span class="packt_screen">SPIView</span> and can see the various details such as hosts, IP addresses resolved, ASN, and much more as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/0e9ae2c0-6323-4e4d-a9a1-7c909ea002cf.png"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">SPIView</div>
<p>Next, let's see the <span class="packt_screen">SPIGraph</span> that contains the source and destination nodes:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/c63a7b75-b9bf-4781-9435-080285d8edb1.png"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">SPIGraph containing source and destination nodes</div>
<p>The connections graph gives us a nice view of the nodes and lists the source and destination IPs. We can see that we have chosen weight as packets so that links become thicker where large packets are transferred. Doing this, we will have a clear understanding of where most of the packets are flowing.</p>
<p>Covering all the features of Moloch is outside the scope of this book. I suggest that you install Moloch and work with it. Moloch can be downloaded from <a href="https://molo.ch/"><span class="URLPACKT">https://molo.ch/</span></a>. Moloch is available to download in the binary format for CentOS 6 and 7, Ubuntu 14.04/16.04/18.04 LTS releases. The reason we covered Moloch as a part of network forensics is that most of you might be working in an environment where there is no, or limited, packet-capturing done. The idea of implementing Moloch is to reduce costs by implementing a cost-effective solution and to cut down on forensic investigations through third-party vendors. It is one tool that offers many features and next-level packet inspection. Hence, it helps in-house forensic investigators and incident responders.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<div class="packt_infobox">For more information on tools and scripts for network forensics, refer to <a href="https://github.com/caesar0301/awesome-pcaptools"><span class="URLPACKT">https://github.com/caesar0301/awesome-pcaptools</span></a><span class="URLPACKT">.<br/>
<br/></span> More information on tools, plugins, scripts, and dissectors for Wireshark can be found at <span class="URLPACKT"><a href="https://wiki.wireshark.org/Tools">https://wiki.wireshark.org/Tools</a>.<br/>
<br/></span> Tools for malware analysis on the network end can be found at <a href="https://github.com/rshipp/awesome-malware-analysis#network"><span class="URLPACKT">https://github.com/rshipp/awesome-malware-analysis#network</span></a><span class="URLPACKT">.<br/>
<br/></span> For tools related to wireless forensics, check out <a href="https://github.com/nipunjaswal/Wireless-forensics-framework">https://github.com/nipunjaswal/Wireless-forensics-framework</a>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>Throughout this chapter, we learned about analysis automation using scapy and Pyshark. We saw how we can merge, split and filter out streams from the evidences and make our lives easy by removing the unwanted packet data while focusing on the packets of interest. We also saw how large scale data collection can be efficiently managed using open source tools like Moloch.</p>
<p>There is no end to network forensics and each and every day we learn new techniques and strategies. I wish you all the best in your hands on journey to network forensics</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"> Questions and exercises</h1>
                </header>
            
            <article>
                
<p>Having gained the knowledge of topics covered in the chapter, try performing the following exercises:</p>
<ul>
<li>Automate analysis and build decryptor for at least 2 sample PCAP files containing decryption key for ransomware like we had PyLockY decryptor in <a href="17a6dbba-2b38-4dff-8901-06d89985906c.xhtml" target="_blank">Chapter 6</a>, <em>Investigating Good, Known, and Ugly Malware</em></li>
<li>Use Pyshark to build a wireless sniffer</li>
<li>Install and use Moloch while discovering its filtering capabilities</li>
<li>Capture data from a server and a client in two separate PCAP files and merge them</li>
<li>Check GitHub repository challenge directory time and again for new challenges to solve from the chapters</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<p>To make the most out of the content covered in this chapter, here are a few links you would definitely checkout:</p>
<ul>
<li>To read more on Moloch, check out its wiki page at<span> </span><a href="https://github.com/aol/moloch/wiki">https://github.com/aol/moloch/wiki</a></li>
<li>Read more on Pyshark at<span> </span><a href="https://github.com/KimiNewt/pyshark">https://github.com/KimiNewt/pyshark</a></li>
<li>Understand and learn scapy by reading the documentation at<span> </span><a href="https://scapy.readthedocs.io/en/latest/index.html">https://scapy.readthedocs.io/en/latest/index.html</a></li>
</ul>


            </article>

            
        </section>
    </body></html>