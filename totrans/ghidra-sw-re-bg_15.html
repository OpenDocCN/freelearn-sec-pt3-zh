<html><head></head><body><div><p>&#13;
			<h1 id="_idParaDest-170"><em class="italic"><a id="_idTextAnchor211"/>Chapter 12</em>: Analyzing Processor Modules</h1>&#13;
			<p><a id="_idTextAnchor212"/>In this chapter, we will address how to incorporate new processor modules in Ghidra. This is an advanced topic that involves learning the <strong class="bold">Specification Language for Encoding and Decoding for Ghidra</strong> (<strong class="bold">SLEIGH</strong>) so that we can specify the language, disassembling the code, performing function identification via prologue and epilogue byte pattern matching, stack frame creation, and function cross-references generation.</p>&#13;
			<p>During this chapter, you will acquire extremely useful skills for breaking down advanced reverse engineering protections. You will do this by implementing a virtual machine so that the adversary (you) will have to apply reverse engineering to the virtual machine before reverse engineering the original binary. There are several examples of malware (such as ZeusVM, KINS, and so on) and powerful software protection that's mostly based on virtualization (such as VMProtect, Denuvo, and more). </p>&#13;
			<p class="callout-heading">SLEIGH and SLED</p>&#13;
			<p class="callout">SLEIGH, the Ghidra processor specification language, has its origins in the <strong class="bold">Specification Language for Encoding and Decoding</strong> (<strong class="bold">SLED</strong>), which describes abstract, binary, and assembly language representations of machine instructions. If you want to learn more about <a id="_idIndexMarker431"/>SLEIGH, which is a broad topic, check out the following link: <a href="https://ghidra.re/courses/languages/html/sleigh.html">https://ghidra.re/courses/languages/html/sleigh.html</a>. If you want to learn more about <a id="_idIndexMarker432"/>SLED, check out the following link: <a href="https://www.cs.tufts.edu/~nr/pubs/specifying.html">https://www.cs.tufts.edu/~nr/pubs/specifying.html</a>.</p>&#13;
			<p>We will start by providing an overview of the extensive list of existing Ghidra processor modules and how they are used by Ghidr<a id="_idTextAnchor213"/><a id="_idTextAnchor214"/>a. Finally, we will analyze the <strong class="bold">x86 processor module</strong> from a Ghidra developer perspective. The loader under analysis is responsible for enabling Ghidra so that we can understand its x86 architecture and variants (for example, 16-bit real mode). As we did in the previous chapter, we will look at a real-world example to help us with this.</p>&#13;
			<p>In this chapter, we're going to cover the following topics:  </p>&#13;
			<ul>&#13;
				<li>Understanding the existing Ghidra processor modules</li>&#13;
				<li>The Ghidra processor module skeleton</li>&#13;
				<li>Developing Ghidra processors</li>&#13;
			</ul>&#13;
			<p>Let's get started!</p>&#13;
			<h1 id="_idParaDest-171"><a id="_idTextAnchor215"/>Technical requirements </h1>&#13;
			<p>The technical requirements for this chapter are as follows: </p>&#13;
			<ul>&#13;
				<li>Java JDK 11 for x86_64 (available here): <a href="https://adoptopenjdk.net/releases.html?variant=openjdk11&amp;jvmVariant=hotspot">https://adoptopenjdk.net/releases.html?variant=openjdk11&amp;jvmVariant=hotspot</a></li>&#13;
				<li>Eclipse IDE for Java developers (any version supporting JDK 11 available here: <a href="https://www.eclipse.org/downloads/">https://www.eclipse.org/downloads/</a>) since it is the IDE that's officially integrated and supported by Ghidra.</li>&#13;
				<li>This book's GitHub repository, which contains all the necessary code for this chapter (<a href="https://github.com/PacktPublishing/Ghidra-Software-Reverse-Engineering-for-Beginners/tree/master/Chapter12">https://github.com/PacktPublishing/Ghidra-Software-Reverse-Engineering-for-Beginners/tree/master/Chapter12</a>).</li>&#13;
			</ul>&#13;
			<p>Check out the following link to see the Code in Action video: <a href="https://bit.ly/2VQjNFt">https://bit.ly/2VQjNFt</a></p>&#13;
			<h1 id="_idParaDest-172"><a id="_idTextAnchor216"/>Understanding the existing Ghidra processor modules</h1>&#13;
			<p>In this <a id="_idIndexMarker433"/>section, we will provide an overview of Ghidra's processor <a id="_idIndexMarker434"/>modules from a user perspective. Ghidra provides support for a lot of processor architectures. You can find a list of supported architectures by listing the directories included in the <code>Ghidra/Processors/</code> directory of both the Ghidra distribution and Ghidra's GitHub repository (https://github.com/NationalSecurityAgency/ghidra/tree/master/Ghidra/Processors), as shown in the following screenshot:</p>&#13;
			<div>&#13;
				<div>&#13;
					<img src="img/B16207_12_001.jpg" alt="Figure 12.1 – Listing Ghidra's processor modules (partial list)&#13;&#10;"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption"> </p>&#13;
			<p class="figure-caption">Figure 12.1 – Listing Ghidra's processor modules (partial list)</p>&#13;
			<p>At the<a id="_idIndexMarker435"/> time of writing this book, Ghidra supports the following list of processors:<code>6502</code>, <code>68000</code>, <code>6805</code>, <code>8048</code>, <code>8051</code>, <code>8085</code>, <code>AARCH64</code>, <code>ARM</code>, <code>Atmel</code>, <code>CP1600</code>, <code>CR16</code>, <code>DATA</code>, <code>Dalvik</code>, <code>HCS08</code>, <code>HCS12</code>, <code>JVM</code>, <code>M8C</code>, <code>MCS96</code>, <code>MIPS</code>, <code>PA-RISC</code>, <code>PIC</code>, <code>PowerPC</code>, <code>RISCV</code>, <code>Sparc</code>, <code>SuperH</code>, <code>SuperH4</code>, <code>TI_MSP430</code>, <code>Toy</code>, <code>V850</code>, <code>Z80</code>, <code>tricore</code>, and <code>x86</code>.If we compare this list with IDA <a id="_idIndexMarker436"/>Professional Edition processor support, we'll notice that IDA supports more processors, even though it doesn't provide Ghidra support. But if we compare Ghidra with IDA Home Edition, then we'll notice that Ghidra supports <a id="_idIndexMarker437"/>more architectures, including very common architectures <a id="_idIndexMarker438"/>such as Dalvik (the discontinued virtual machine used by Android) and <strong class="bold">Java Virtual Machine</strong> (<strong class="bold">JVM</strong>).</p>&#13;
			<p>Using loading a binary for the x86 architecture as an example, you will probably remember from <a href="B16207_11_Final_SK_ePub.xhtml#_idTextAnchor194"><em class="italic">Chapter 11</em></a>, <em class="italic">Incorporating New Binary Formats</em>, that, when loading a file, you can choose what language it will appear in by clicking on the ellipses button (<strong class="bold">…</strong>) next to <strong class="bold">Language</strong>, as shown in the following screenshot:</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B16207_12_002.jpg" alt="Figure 12.2 – Default language variant when importing a PE file&#13;&#10;"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption"> </p>&#13;
			<p class="figure-caption">Figure 12.2 – Default language variant when importing a PE file</p>&#13;
			<p>Once I'd<a id="_idIndexMarker439"/> done this, I <a id="_idIndexMarker440"/>unchecked <strong class="bold">Show Only Recommended Language/Compiler Specs</strong> to show all the languages and compilers that are available. By doing this, I can see that the x86 processor module implements eight variants: </p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B16207_12_003.jpg" alt="Figure 12.3 – Choosing the appropriate language variant when importing a file&#13;&#10;"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption"> </p>&#13;
			<p class="figure-caption">Figure 12.3 – Choosing the appropriate language variant when importing a file</p>&#13;
			<p>Let's analyze<a id="_idIndexMarker441"/> the structure of a processor module to understand how these variants are relevant to the <code>tree</code> command to provide<a id="_idIndexMarker442"/> an overview of the directory structure of the x86 processor and analyzer.</p>&#13;
			<p>The <code>data</code> directory contains the x86 processor module:</p>&#13;
			<pre>C:\Users\virusito\ghidra\Ghidra\Processors\x86&gt;tree</pre>&#13;
			<pre>├───data</pre>&#13;
			<pre>│   ├───languages</pre>&#13;
			<pre>│   │   └───old</pre>&#13;
			<pre>│   ├───manuals</pre>&#13;
			<pre>│   └───patterns</pre>&#13;
			<p>As you can see, there are three children folders implementing it:</p>&#13;
			<ul>&#13;
				<li><code>languages</code>: This is responsible for implementing the x86 processor using different kinds of files, all of which will be explained later (<code>*.sinc</code>, <code>*.pspec</code>, <code>*.gdis</code>, <code>*.dwarf</code>, <code>*.opinion</code>, <code>*.slaspec</code>, <code>*.spec</code>, and <code>*.ldefs</code>).</li>&#13;
				<li><code>manuals</code>: The processor's manual documentation is stored here using the <code>*.idx</code> Ghidra format. This indexes the original PDF's information, thus allowing you to query the documentation.</li>&#13;
				<li><code>patterns</code>: Byte patterns are stored in XML files and used to determine whether the importing file was developed for the x86 architecture.</li>&#13;
			</ul>&#13;
			<p>The <code>src</code> directory<a id="_idIndexMarker443"/> contains the x86 analyzer. You probably remember analyzer<a id="_idIndexMarker444"/> extensions from the <em class="italic">The Ghidra Extension Module Skeleton</em> section of <a href="B16207_04_Final_SK_ePub.xhtml#_idTextAnchor063"><em class="italic">Chapter 4</em></a><em class="italic">, Using Ghidra Extensions</em>. These kinds of extensions allow us to extend Ghidra's code analysis functionality:</p>&#13;
			<pre>└───src</pre>&#13;
			<pre>    ├───main</pre>&#13;
			<pre>    │   └───java</pre>&#13;
			<pre>    │       └───ghidra</pre>&#13;
			<pre>    │           ├───app</pre>&#13;
			<pre>    │           │   ├───plugin</pre>&#13;
			<pre>    │           │   │   └───core</pre>&#13;
			<pre>    │           │   │       └───analysis</pre>&#13;
			<pre>    │           │   └───util</pre>&#13;
			<pre>    │           │       └───bin</pre>&#13;
			<pre>    │           │           └───format</pre>&#13;
			<pre>    │           │               ├───coff</pre>&#13;
			<pre>    │           │               │   └───relocation</pre>&#13;
			<pre>    │           │               └───elf</pre>&#13;
			<pre>    │           │                   ├───extend</pre>&#13;
			<pre>    │           │                   └───relocation</pre>&#13;
			<pre>    │           └───feature</pre>&#13;
			<pre>    │               └───fid</pre>&#13;
			<pre>    │                   └───hash</pre>&#13;
			<pre>    └───test.processors</pre>&#13;
			<pre>        └───java</pre>&#13;
			<pre>            └───ghidra</pre>&#13;
			<pre>                └───test</pre>&#13;
			<pre>                    └───processors</pre>&#13;
			<p>The main file of the analyzer extension is the <code>X86Analyzer</code> Java class file (full path: <code>Ghidra\Processors\x86\src\main\java\ghidra\app\plugin\core\analysis\X86Analyzer.java</code>). This class extends from <code>ConstantPropagationAnalyzer</code> (full path: <code>Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/analysis/ConstantPropagationAnalyzer.java</code>), which itself extends from <code>AbstractAnalyzer</code> (the class you must directly or indirectly extend from when writing analyzer extensions).</p>&#13;
			<p>In this section, you <a id="_idIndexMarker445"/>learned about existing processors and analyzers and how their <a id="_idIndexMarker446"/>source code is structured. In the next section, we will explore how to create a new processor module.</p>&#13;
			<h1 id="_idParaDest-173"><a id="_idTextAnchor217"/>Overviewing the Ghidra processor module skeleton</h1>&#13;
			<p>In this section, we will look at the Ghidra processor module skeleton. This skeleton will be a little bit different because processor modules are not written in Java. Instead, the processor modules are written in SLEIGH, which is the Ghidra processor specification language. </p>&#13;
			<h2 id="_idParaDest-174"><a id="_idTextAnchor218"/>Setting up the processor module development environment</h2>&#13;
			<p>Before you can<a id="_idIndexMarker447"/> create a new processor module, you will need to set up an environment:</p>&#13;
			<ol>&#13;
				<li>Install the Java JDK for x86_64, as explained in <a href="B16207_03_Final_SK_ePub.xhtml#_idTextAnchor041"><em class="italic">Chapter 3</em></a>, <em class="italic">Ghidra Debug Mode</em>, in the <em class="italic">Installing Java JDK</em> section.</li>&#13;
				<li>Install the Eclipse IDE for Java developers, as explained in <a href="B16207_03_Final_SK_ePub.xhtml#_idTextAnchor041"><em class="italic">Chapter 3</em></a>, <em class="italic">Ghidra Debug Mode</em>, in the <em class="italic">Installing Eclipse IDE</em> section.</li>&#13;
				<li>Install the <code>GhidraDev</code> plugin for Eclipse, as explained in <a href="B16207_03_Final_SK_ePub.xhtml#_idTextAnchor041"><em class="italic">Chapter 3</em></a>, <em class="italic">Ghidra Debug Mode</em>, in the <em class="italic">Installing GhidraDev</em> section.</li>&#13;
				<li>Additionally, in the same way you installed <code>GhidraDev</code>, since you will need to work with SLEIGH to develop the processor's specifications, it is highly recommended that you also install <code>GhidraSleighEditor</code>.</li>&#13;
			</ol>&#13;
			<p>The <code>GhidraSleighEditor</code> installation process is the same as for <code>GhidraDev</code> since both are Eclipse plugins. It is a ZIP file that can<a id="_idIndexMarker448"/> be installed from the Eclipse IDE, and both the straightforward installation guide (<code>GhidraSleighEditor_README.html</code>) and the plugin installer (<code>GhidraSleighEditor-1.0.0.zip</code>) are available in the <code>Extensions\Eclipse\GhidraSleighEditor</code> directory of your Ghidra installation:</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B16207_12_004.jpg" alt="Figure 12.4 – GhidraSleighEditor plugin for the Eclipse IDE&#13;&#10;"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption"> </p>&#13;
			<p class="figure-caption">Figure 12.4 – GhidraSleighEditor plugin for the Eclipse IDE</p>&#13;
			<p>In the next section, we will learn how to create a processor module skeleton.</p>&#13;
			<h2 id="_idParaDest-175"><a id="_idTextAnchor219"/>Creating a processor module skeleton</h2>&#13;
			<p>As you<a id="_idIndexMarker449"/> probably remember from <a href="B16207_04_Final_SK_ePub.xhtml#_idTextAnchor063"><em class="italic">Chapter 4</em></a>, <em class="italic">Using Ghidra Extensions</em>, to create a processor module, you must click on <code>ProcessorModuleProject</code>, as shown in the following screenshot:</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B16207_12_005.jpg" alt="Figure 12.5 – Creating a Ghidra project&#13;&#10;"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption"> </p>&#13;
			<p class="figure-caption">Figure 12.5 – Creating a Ghidra project</p>&#13;
			<p>After clicking on <strong class="bold">Next &gt;</strong>, only <a id="_idIndexMarker450"/>check the last option – <strong class="bold">Processor – Enables disassembly/decompilation of a processor/architecture</strong> – in order to create a processor module skeleton:</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B16207_12_006.jpg" alt="Figure 12.6 – Configuring the Ghidra project so that it includes the processor module skeleton&#13;&#10;"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption"> </p>&#13;
			<p class="figure-caption">Figure 12.6 – Configuring the Ghidra project so that it includes the processor module skeleton</p>&#13;
			<p>After clicking on <strong class="bold">Finish</strong>, you<a id="_idIndexMarker451"/> will see the processor skeleton in the <strong class="bold">Package Explorer</strong> section of Eclipse:</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B16207_12_007.jpg" alt="Figure 12.7 – The processor module skeleton&#13;&#10;"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption"> </p>&#13;
			<p class="figure-caption">Figure 12.7 – The processor module skeleton</p>&#13;
			<p>All the files that compose the <a id="_idIndexMarker452"/>skeleton are stored in the <code>data\languages</code> directory. Since each file has its own specification goal, let's look at them in more detail:</p>&#13;
			<ul>&#13;
				<li><code>skel.cspec</code>: As its name suggests, this is a compiler specification file. It allows us to encode information that is specific to the compiler that's necessary when dissembling and analyzing a binary. You can find out more by going to <a href="https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Features/Decompiler/src/main/doc/cspec.xml">https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Features/Decompiler/src/main/doc/cspec.xml</a>.</li>&#13;
				<li><code>skel.ldefs</code>: According to the extension, this is the definition of the processor language.</li>&#13;
				<li><code>skel.opinion</code>: As you probably remember from the previous chapter, opinion files contain constraints that allow us to determine whether the file can be loaded or not by the importer. You can find out more by going to <a href="https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Framework/SoftwareModeling/data/languages/Steps%20to%20creation%20of%20Format%20Opinion.txt">https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Framework/SoftwareModeling/data/languages/Steps%20to%20creation%20of%20Format%20Opinion.txt</a>.</li>&#13;
				<li><code>skel.pspec</code>: As its name suggests, this file is a processor specification file.</li>&#13;
				<li><code>skel.sinc</code>: As its name suggests, this is a SLEIGH file that specifies the language instructions of a processor (for example, the <code>mov</code> assembly language instruction if x86 must be defined here).</li>&#13;
				<li><code>skel.slaspec</code>: This is <a id="_idIndexMarker453"/>the SLEIGH language specification and allows us to specify the processor (for example, registers, flags, and so on).</li>&#13;
			</ul>&#13;
			<p>As we mentioned previously, SLEIGH is a broad topic, so if you want to learn more, please read the documentation available in your Ghidra distribution (<code>docs\languages\html\sleigh.html</code>).</p>&#13;
			<p>Now that you have installed the SLEIGH editor, you can edit all the aforementioned files by right-clicking the target file, choosing <strong class="bold">Open With</strong> | <strong class="bold">Other…</strong>, and then choosing <strong class="bold">Sleigh Editor</strong>:</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B16207_12_008.jpg" alt="Figure 12.8 – Opening a file in Eclipse using the Other… editor&#13;&#10;"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption"> </p>&#13;
			<p class="figure-caption">Figure 12.8 – Opening a file in Eclipse using the Other… editor</p>&#13;
			<p>If you want, you can also take this<a id="_idIndexMarker454"/> as an opportunity to associate the <code>*.cspec</code> files by checking the <strong class="bold">Use it for all '*.cspec' files</strong> option before clicking <strong class="bold">OK</strong>:</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B16207_12_009.jpg" alt="Figure 12.9 – Choosing Sleigh Editor for opening a file in Eclipse&#13;&#10;"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption"> </p>&#13;
			<p class="figure-caption">Figure 12.9 – Choosing Sleigh Editor for opening a file in Eclipse</p>&#13;
			<p>Choose <strong class="bold">No</strong> when you're asked to convert the project into an Xtext project. Also, take this opportunity to make your computer remember this decision by checking the <strong class="bold">Remember my decision</strong> checkbox, as shown in the following screenshot:</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B16207_12_010.jpg" alt="Figure 12.10 – Converting the project into an Xtext project dialog&#13;&#10;"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption"> </p>&#13;
			<p class="figure-caption">Figure 12.10 – Converting the project into an Xtext project dialog</p>&#13;
			<p>We started this section by providing an overview of an existing processor module (x86 processor) and analyzing it from a Ghidra user perspective. You superficially explored the code files that comprise it in order to understand the big picture of processor modules. After that, you <a id="_idIndexMarker455"/>learned how to set up a processor module development environment and a processor module skeleton so that you can start developing a new one.</p>&#13;
			<p>In the next section, we will explore how the x86 processor we looked at in the first section of this chapter, <em class="italic">Existing processor modules</em>, was implemented to zoom into the details of its implementation.</p>&#13;
			<h1 id="_idParaDest-176"><a id="_idTextAnchor220"/>Developing Ghidra processors</h1>&#13;
			<p>As you know, Ghidra <a id="_idIndexMarker456"/>processor module development involves many different files that are located in the <code>data</code> directory of the module. These files are listed in the manifest (<a href="https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Processors/x86/certification.manifest">https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Processors/x86/certification.manifest</a>):</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B16207_12_011.jpg" alt="Figure 12.11 – Partial dump of certification.manifest&#13;&#10;"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption"> </p>&#13;
			<p class="figure-caption">Figure 12.11 – Partial dump of certification.manifest</p>&#13;
			<p>In the next section, we will look at Ghidra's processor documentation files and their relationship to the official processor documentation.</p>&#13;
			<h2 id="_idParaDest-177"><a id="_idTextAnchor221"/>Documenting processors</h2>&#13;
			<p>The <code>manuals</code> directory <a id="_idIndexMarker457"/>of the x86 processor stores the <code>x86.idx</code> file (<a href="https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Processors/x86/data/manuals/x86.idx">https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Processors/x86/data/manuals/x86.idx</a>), which contains an indexed version of the official instruction set reference for such an architecture (<a href="https://software.intel.com/sites/default/files/managed/a4/60/325383-sdm-vol-2abcd.pdf">https://software.intel.com/sites/default/files/managed/a4/60/325383-sdm-vol-2abcd.pdf</a>). This indexed version allows Ghidra to access such information when retrieving instruction information from Ghidra's GUI during reversing. The following code snippet is of a few lines that can be found at the beginning of the <code>x86.idx</code> file. They relate to processor instructions and their documentation pages (for example, line <code>01</code> relates to the <code>AAA</code> processor instruction, which can be found on page <code>120</code> of the official documentation):</p>&#13;
			<pre>00  @325383-sdm-vol-2abcd.pdf [Intel 64 and IA-32 Architectures Software Developer's Manual Volume 2 (2A, 2B, 2C &amp; 2D): Instruction Set Reference, A-Z, Oct 2019 (325383-071US)]</pre>&#13;
			<pre>01  AAA, 120</pre>&#13;
			<pre>02  AAD, 122</pre>&#13;
			<pre>03  BLENDPS, 123</pre>&#13;
			<pre>04  AAM, 124</pre>&#13;
			<pre>05  AAS, 126</pre>&#13;
			<pre>06  ADC, 128</pre>&#13;
			<pre>07  ADCX, 131</pre>&#13;
			<pre>08  ADD, 133</pre>&#13;
			<pre>...................... File cut here .........................</pre>&#13;
			<p>In the next section, we will learn how to write signatures so that Ghidra can identify functions and code snippets for thi<a id="_idTextAnchor222"/>s architecture.</p>&#13;
			<h2 id="_idParaDest-178"><a id="_idTextAnchor223"/>Identifying functions and code using patterns</h2>&#13;
			<p>There<a id="_idIndexMarker458"/> is also a <code>patterns</code> directory <a id="_idIndexMarker459"/>where<a id="_idIndexMarker460"/> patterns specified in XML language are used for function and code identification. The directory does this by taking different compilers into account. The format of a file of patterns (for example,  <a href="https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Processors/x86/data/patterns/x86gcc_patterns.xml">https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Processors/x86/data/patterns/x86gcc_patterns.xml</a>) is an XML file that starts and ends with the <code>patternlist</code> tag:</p>&#13;
			<pre>00  &lt;patternlist&gt;</pre>&#13;
			<pre>01    … patters here …</pre>&#13;
			<pre>02  &lt;/patternlist&gt;</pre>&#13;
			<p>You can add patterns that allow the analyzer to identify functions and code. In the following example, which has been taken from the x86 GCC patterns file (<code>x86gcc_patterns.xml</code>), we can see that a pattern was included using the <code>pattern</code> tag. The pattern itself is <a id="_idIndexMarker461"/>written as a hexadecimal byte representation. To aid in your understanding of this, a comment has been added to the right of this, indicating what those bytes mean (in this case, this is the prologue of a function). </p>&#13;
			<p>After the <code>data</code> section, we have<a id="_idIndexMarker462"/> two tags: <code>codeboundary</code> and <code>possiblefuncstart</code>. The position of these tags is important because, since they are located after the <code>data</code> section, the meanings of <code>codeboundary</code> and <code>possiblefuncstart</code> must be understood from the pattern indicated in the <code>data</code> section onward. <code>codeboundary</code> indicates that the code starts or <a id="_idIndexMarker463"/>ends (it is a boundary), while <code>possiblefuncstart</code> indicates that the bytes matching the pattern may be at the start of a function:</p>&#13;
			<pre>00  &lt;patternlist&gt;</pre>&#13;
			<pre>01    &lt;pattern&gt;</pre>&#13;
			<pre>02      &lt;data&gt;0x5589e583ec&lt;/data&gt; &lt;!-- PUSH EBP : MOV EBP,ESP </pre>&#13;
			<pre>                                                : SUB ESP, --&gt;</pre>&#13;
			<pre>03      &lt;codeboundary/&gt;</pre>&#13;
			<pre>04      &lt;possiblefuncstart/&gt;</pre>&#13;
			<pre>05    &lt;/pattern&gt;</pre>&#13;
			<pre>06  &lt;/patternlist&gt;</pre>&#13;
			<p>You can also use <code>patternpairs</code> to define two patterns that are usually found together, one preceding the other. These patterns are called <code>prepatterns</code> and <code>postpatterns</code>, respectively. For instance, it is quite common for the end of a function (<code>prepattern</code>, specified on line <code>03</code>) to precede the start of another function (<code>postpattern</code>, specified on line <code>09</code>):</p>&#13;
			<pre>00  &lt;patternpairs totalbits="32" postbits="16"&gt;</pre>&#13;
			<pre>01    &lt;prepatterns&gt;</pre>&#13;
			<pre>02      &lt;data&gt;0x90&lt;/data&gt; &lt;!-- NOP filler --&gt;</pre>&#13;
			<pre>03      &lt;data&gt;0xc3&lt;/data&gt; &lt;!-- RET --&gt;</pre>&#13;
			<pre>04      &lt;data&gt;0xe9........&lt;/data&gt; &lt;!-- JMP big --&gt;</pre>&#13;
			<pre>05      &lt;data&gt;0xeb..&lt;/data&gt; &lt;!-- JMP small --&gt;</pre>&#13;
			<pre>06      &lt;data&gt;0x89f6&lt;/data&gt; &lt;!-- NOP (MOV ESI,ESI) --&gt;</pre>&#13;
			<pre>07    &lt;/prepatterns&gt;</pre>&#13;
			<pre>08    &lt;postpatterns&gt;</pre>&#13;
			<pre>09      &lt;data&gt;0x5589e5&lt;/data&gt; &lt;!-- PUSH EBP : MOV EBP,ESP --&gt;</pre>&#13;
			<pre>10      &lt;codeboundary/&gt;</pre>&#13;
			<pre>11      &lt;possiblefuncstart/&gt;</pre>&#13;
			<pre>12    &lt;/postpatterns&gt;</pre>&#13;
			<pre>13  &lt;/patternpairs&gt;</pre>&#13;
			<p>In the next section, we will learn how to specify the assembly language for such a processor using <strong class="bold">Debugging With Attributed Record Formats</strong> (<strong class="bold">DWARF</strong>).</p>&#13;
			<h2 id="_idParaDest-179"><a id="_idTextAnchor224"/>Specifying the language and its variants</h2>&#13;
			<p>Inside the <code>languages</code> directory, we have a<a id="_idIndexMarker464"/> bunch of files with different names (every name implements a variant of the language) and different extensions (every extension if responsible for specifying the language at hand). Let's analyze the x86 files<a id="_idIndexMarker465"/> that implement the x86 variant of the processor (there are other variants as well, such as x86-64 and x86-16).</p>&#13;
			<h3>x86.dwarf</h3>&#13;
			<p>This file<a id="_idIndexMarker466"/> describes the registers of the architecture using mappings between Ghidra names and DWARF register numberings. DWARF is a standardized debugging data format. DWARF mappings are described by the <strong class="bold">Application Binary Interface</strong> (<strong class="bold">ABI</strong>) of the<a id="_idIndexMarker467"/> architecture (available here: <a href="https://www.uclibc.org/docs/psABI-i386.pdf">https://www.uclibc.org/docs/psABI-i386.pdf</a>). The Ghidra DWARF file looks as follows:</p>&#13;
			<pre>00  &lt;dwarf&gt;	</pre>&#13;
			<pre>01  	 &lt;register_mappings&gt;</pre>&#13;
			<pre>02  	   &lt;register_mapping dwarf="0" ghidra="EAX"/&gt;</pre>&#13;
			<pre>03  	   &lt;register_mapping dwarf="1" ghidra="ECX"/&gt;</pre>&#13;
			<pre>04  	   &lt;register_mapping dwarf="2" ghidra="EDX"/&gt;</pre>&#13;
			<pre> . . . . . . . . . . . . cut here . . . . . . . . . . . . . .</pre>&#13;
			<p>Of course, apart from matching the Ghidra register names with DWARF numbers, attributes are also used to specify the ESP register's purpose in the x86 architecture as a stack pointer (the <code>stackpointer</code> attribute):</p>&#13;
			<pre>&lt;register_mapping dwarf="4" ghidra="ESP" stackpointer="true"/&gt;</pre>&#13;
			<p>Attributes can<a id="_idIndexMarker468"/> also be used to abbreviate code. For instance, they can be used to declare eight registers at a time. Registers <code>XMM0</code> to <code>XMM7</code> are declared using a single line of code via the <code>auto_count</code> attribute:</p>&#13;
			<pre>&lt;register_mapping dwarf="11" ghidra="ST0" auto_count="8"/&gt;</pre>&#13;
			<p>This XML consists of mapping registers. In the next section, we will learn how to define the x86 processor language. </p>&#13;
			<p class="callout-heading">DWARF Debugging Format</p>&#13;
			<p class="callout">If you want to learn <a id="_idIndexMarker469"/>more about DWARF, go to the official website: <a href="http://dwarfstd.org/">http://dwarfstd.org/</a>.</p>&#13;
			<h3>x86.ldefs</h3>&#13;
			<p>This file <a id="_idIndexMarker470"/>defines the x86 processor language and its variants. All languages are specified inside <code>language_definitions</code> tags (lines <code>00</code> and <code>19</code>). For instance, the default variant of the x86 language (line <code>04</code>) that corresponds to the x86 architecture (line <code>01</code>) for 32-bit machines (line <code>03</code>) using little endian (line <code>02</code>) and shown to the user as <code>x86:LE:32:default</code> (line <code>09</code>) is fully specified between lines <code>01</code> and <code>18</code> (the language tags). Its specification can also include the name of the processor variant in external tools (lines <code>12</code>-<code>16</code>).</p>&#13;
			<p>It also references some<a id="_idIndexMarker471"/> external files: <code>x86.sla</code> (SLEIGH language specification file) on line <code>06</code>), <code>x86.pspec</code> (processor specification file) on line <code>07</code>, <code>x86.idx</code> (x86 architecture indexed manual) on line <code>08</code>, and <code>x86.dwarf</code> (DWARF registry mapping file) on line <code>16</code>:</p>&#13;
			<pre>00  &lt;language_definitions&gt;</pre>&#13;
			<pre>01    &lt;language processor="x86"</pre>&#13;
			<pre>02              endian="little"</pre>&#13;
			<pre>03              size="32"</pre>&#13;
			<pre>04              variant="default"</pre>&#13;
			<pre>05              version="2.9"</pre>&#13;
			<pre>06              slafile="x86.sla"</pre>&#13;
			<pre>07              processorspec="x86.pspec"</pre>&#13;
			<pre>08              manualindexfile="../manuals/x86.idx"</pre>&#13;
			<pre>09              id="x86:LE:32:default"&gt;</pre>&#13;
			<pre>10      &lt;description&gt;Intel/AMD 32-bit x86&lt;/description&gt;</pre>&#13;
			<pre>11      &lt;compiler name="gcc" spec="x86gcc.cspec" id="gcc"/&gt;</pre>&#13;
			<pre>12      &lt;external_name tool="gnu" name="i386:intel"/&gt;</pre>&#13;
			<pre>13      &lt;external_name tool="IDA-PRO" name="8086"/&gt;</pre>&#13;
			<pre>14      &lt;external_name tool="IDA-PRO" name="80486p"/&gt;</pre>&#13;
			<pre>15      &lt;external_name tool="IDA-PRO" name="80586p"/&gt;</pre>&#13;
			<pre>16      &lt;external_name tool="DWARF.register.mapping.file"</pre>&#13;
			<pre>17                                          name="x86.dwarf"/&gt;</pre>&#13;
			<pre>18    &lt;/language&gt;</pre>&#13;
			<pre>      . . . . . . . more languages here . . . . . .</pre>&#13;
			<pre>19  &lt;/language_definitions&gt;</pre>&#13;
			<p>In the next section, we will learn about the processor specifications that are relevant when importing a file.</p>&#13;
			<h3>x86.opinion</h3>&#13;
			<p>This file <a id="_idIndexMarker472"/>contains constraints that allow us to determine whether the file can be loaded by the importer. For instance, the constraints for <code>PE</code> files (line <code>01</code>) in the case of the <code>windows</code> compiler (line <code>02</code>) are the constraints that are specified between lines <code>03</code>-<code>10</code>. Each has its own primary value that can be queried using the <code>opinion</code> query service when you're loading a file:</p>&#13;
			<pre>00  &lt;opinions&gt;</pre>&#13;
			<pre>01      &lt;constraint loader="Portable Executable (PE)"&gt;</pre>&#13;
			<pre>02        &lt;constraint compilerSpecID="windows"&gt;</pre>&#13;
			<pre>03          &lt;constraint primary="332" processor="x86"     </pre>&#13;
			<pre>04                            endian="little" size="32" /&gt;</pre>&#13;
			<pre>05          &lt;constraint primary="333" processor="x86"     </pre>&#13;
			<pre>06                            endian="little" size="32" /&gt;</pre>&#13;
			<pre>07          &lt;constraint primary="334" processor="x86"     </pre>&#13;
			<pre>08                            endian="little" size="32" /&gt;</pre>&#13;
			<pre>09          &lt;constraint primary="34404" processor="x86"     </pre>&#13;
			<pre>10                            endian="little" size="64" /&gt;</pre>&#13;
			<pre>11        &lt;/constraint&gt;</pre>&#13;
			<p>In the next section, we will<a id="_idIndexMarker473"/> learn how to specify some necessary information about compilers targeting the architecture.</p>&#13;
			<h3>x86.pspec</h3>&#13;
			<p>The compiler <a id="_idIndexMarker474"/>specification file allows us to encode information that is specific to the compiler and is necessary when dissembling and analyzing a binary (for example, the program counter on line <code>08</code>):</p>&#13;
			<pre>00  &lt;processor_spec&gt;</pre>&#13;
			<pre>01    &lt;properties&gt;</pre>&#13;
			<pre>02      &lt;property </pre>&#13;
			<pre>03           key="useOperandReferenceAnalyzerSwitchTables" </pre>&#13;
			<pre>04                                          value="true"/&gt;</pre>&#13;
			<pre>05      &lt;property key="assemblyRating:x86:LE:32:default" </pre>&#13;
			<pre>06                                      value="PLATINUM"/&gt;</pre>&#13;
			<pre>07    &lt;/properties&gt;</pre>&#13;
			<pre>08    &lt;programcounter register="EIP"/&gt;</pre>&#13;
			<pre>09    &lt;incidentalcopy&gt;</pre>&#13;
			<pre>10      &lt;register name="ST0"/&gt;</pre>&#13;
			<pre>11      &lt;register name="ST1"/&gt;</pre>&#13;
			<pre>12    &lt;/incidentalcopy&gt;</pre>&#13;
			<pre>13    &lt;context_data&gt;</pre>&#13;
			<pre>14      &lt;context_set space="ram"&gt;</pre>&#13;
			<pre>15        &lt;set name="addrsize" val="1"/&gt;</pre>&#13;
			<pre>16        &lt;set name="opsize" val="1"/&gt;</pre>&#13;
			<pre>17      &lt;/context_set&gt;</pre>&#13;
			<pre>18      &lt;tracked_set space="ram"&gt;</pre>&#13;
			<pre>19        &lt;set name="DF" val="0"/&gt;</pre>&#13;
			<pre>20      &lt;/tracked_set&gt;</pre>&#13;
			<pre>21    &lt;/context_data&gt;</pre>&#13;
			<pre>22    &lt;register_data&gt;</pre>&#13;
			<pre>23      &lt;register name="DR0" group="DEBUG"/&gt;</pre>&#13;
			<pre>24      &lt;register name="DR1" group="DEBUG"/&gt;</pre>&#13;
			<pre>25    &lt;/register_data&gt;</pre>&#13;
			<pre>26  &lt;/processor_spec&gt;</pre>&#13;
			<p>In the next section, we <a id="_idIndexMarker475"/>will learn how to specify the processor architecture using the SLEIGH language.</p>&#13;
			<h3>x86.slaspec</h3>&#13;
			<p>The SLEIGH <a id="_idIndexMarker476"/>language specification allows us to specify the processor. In this case, the implementation is split into many files that are included in <code>x86.slapec</code>. In this case, we are interested in <code>ia.sinc</code>, which implements an x86 32-bit variant of this language:</p>&#13;
			<pre>00  @include "ia.sinc"</pre>&#13;
			<p>If you want to write your own language, then you will need to learn more<a id="_idIndexMarker477"/> about SLEIGH (https://ghidra.re/courses/languages/html/sleigh.html). The following is a snippet of <code>ia.sinc</code> that allows us to implement matching between the x86 32-bit swap instruction and the PCode swap operation:</p>&#13;
			<pre>00  define pcodeop swap_bytes;</pre>&#13;
			<pre>:MOVBE Reg16, m16       is vexMode=0 &amp; opsize=0 &amp; byte=0xf; byte=0x38; byte=0xf0; Reg16 ... &amp; m16  { Reg16 = swap_bytes( m16 ); }</pre>&#13;
			<pre>:MOVBE Reg32, m32       is vexMode=0 &amp; opsize=1 &amp; mandover=0 &amp; byte=0xf; byte=0x38; byte=0xf0; Reg32 ... &amp; m32  { Reg32 = swap_bytes( m32 ); }</pre>&#13;
			<pre>:MOVBE m16, Reg16       is vexMode=0 &amp; opsize=0 &amp; byte=0xf; byte=0x38; byte=0xf1; Reg16 ... &amp; m16  { m16 = swap_bytes( Reg16 ); }</pre>&#13;
			<pre>:MOVBE m32, Reg32       is vexMode=0 &amp; opsize=1 &amp; mandover=0 &amp; byte=0xf; byte=0x38; byte=0xf1; Reg32 ... &amp; m32  { m32 = swap_bytes( Reg32 ); }</pre>&#13;
			<pre>@ifdef IA64</pre>&#13;
			<pre>:MOVBE Reg64, m64       is vexMode=0 &amp; opsize=2 &amp; mandover=0 &amp; byte=0xf; byte=0x38; byte=0xf0; Reg64 ... &amp; m64  { Reg64 = swap_bytes( m64 ); }</pre>&#13;
			<pre>:MOVBE m64, Reg64       is vexMode=0 &amp; opsize=2 &amp; mandover=0 &amp; byte=0xf; byte=0x38; byte=0xf1; Reg64 ... &amp; m64  { m64 = swap_bytes( Reg64 ); }</pre>&#13;
			<pre>@endif</pre>&#13;
			<p>In this section, you learned how Ghidra's x86 processor module is structured and some of the details of its implementation. These can be useful if you're planning to develop your own Ghidra processor module. It is up to you if you wish to continue learning about SLEIGH, which is a broad and interesting topic.</p>&#13;
			<h1 id="_idParaDest-180"><a id="_idTextAnchor225"/>Summary</h1>&#13;
			<p>In this chapter, you learned about the built-in Ghidra processors and their variants. You also learned what these processors look like when you're importing files using Ghidra.</p>&#13;
			<p>You also learned about the skills you need to use for Ghidra processor module development and the SLEIGH language, which is used more for specifying than programming. By learning about this, you learned why processor modules are special. You were then introduced to processor module development by getting hands-on and analyzing the 32-bit processor variant of the x86 architecture.</p>&#13;
			<p>Finally, you learned about the URL resources that you can use if you want to learn more about the SLEIGH specification language and write your own processor modules.</p>&#13;
			<p>In the next chapter, we will learn how to contribute to the Ghidra project via  collaborating and how to be part of the community.</p>&#13;
			<h1 id="_idParaDest-181"><a id="_idTextAnchor226"/>Questions</h1>&#13;
			<ol>&#13;
				<li value="1">What is the difference between a processor module and an analyzer module?</li>&#13;
				<li>When writing patterns, is the tag's position important?</li>&#13;
				<li>What is the difference between language and language variants?</li>&#13;
			</ol>&#13;
			<h1 id="_idParaDest-182"><a id="_idTextAnchor227"/>Further reading</h1>&#13;
			<p>Please refer to the following links to find out more about the topics that were covered in this chapter:</p>&#13;
			<ul>&#13;
				<li>SLEIGH documentation:<p><a href="https://ghidra.re/courses/languages/html/sleigh.html">https://ghidra.re/courses/languages/html/sleigh.html</a></p></li>&#13;
				<li>Ghidra decompiler documentation:<p><a href="https://github.com/NationalSecurityAgency/ghidra/tree/master/Ghidra/Features/Decompiler/src/main/doc">https://github.com/NationalSecurityAgency/ghidra/tree/master/Ghidra/Features/Decompiler/src/main/doc</a></p></li>&#13;
			</ul>&#13;
		</div>&#13;
	</div></body></html>