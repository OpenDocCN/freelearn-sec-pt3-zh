<html><head></head><body><div><h1 class="header-title">Practical Reverse Engineering of a Windows Executable</h1>
                
            
            
                
<p>Reverse engineering is very common when dealing with malware analysis. In this chapter, we will look at an executable program and determine its actual behavioral flow using the tools we have learned so far. We will head straight from static analysis to dynamic analysis. This will require that we have our lab set up ready so that it will be easier to follow through. </p>
<p>The target file that will be analyzed in this chapter has behaviors that were seen in actual malware. Regardless of a file being malware or not, we have to handle every file we analyze carefully in an enclosed environment. Let's get started on performing some reversing.</p>
<p><strong>We will cover the following topics in this chapter:</strong></p>
<ul>
<li>Practical static analysis</li>
<li>Practical dynamic analysis</li>
</ul>


            

            
        
    </div>



  
<div><h1 class="header-title">Things to prepare</h1>
                
            
            
                
<p>The file we are about to analyze can be downloaded from <a href="https://github.com/PacktPublishing/Mastering-Reverse-Engineering/blob/master/ch12/whatami.zip">https://github.com/PacktPublishing/Mastering-Reverse-Engineering/blob/master/ch12/whatami.zip</a>. It is a password-protected zip file and the password is "<kbd>infected</kbd>", without the quotes.</p>
<p>We need to prepare our Windows lab setup. The analysis discussed in this chapter runs the program in a VirtualBox guest running a Windows 10 32-bit operating system . The following tools additionally need to be prepared:</p>
<ul>
<li>IDA Pro 32-bit: A copy of the free version can be downloaded from <a href="https://github.com/PacktPublishing/Mastering-Reverse-Engineering/blob/master/tools/Disassembler%20Tools/32-bit%20idafree50.exe">https://github.com/PacktPublishing/Mastering-Reverse-Engineering/blob/master/tools/Disassembler%20Tools/32-bit%20idafree50.exe</a>.</li>
<li>x86dbg: The latest version can be downloaded from <a href="https://x64dbg.com">https://x64dbg.com</a>. A copy of of an older version is available at <a href="https://github.com/PacktPublishing/Mastering-Reverse-Engineering/blob/master/tools/Debuggers/x64dbg%20-%20snapshot_2018-04-05_00-33.zip">https://github.com/PacktPublishing/Mastering-Reverse-Engineering/blob/master/tools/Debuggers/x64dbg%20-%20snapshot_2018-04-05_00-33.zip</a>.</li>
<li>Fakenet: The official version can be downloaded at <a href="https://github.com/fireeye/flare-fakenet-ng">https://github.com/fireeye/flare-fakenet-ng</a>. A copy can also be downloaded from <a href="https://github.com/PacktPublishing/Mastering-Reverse-Engineering/tree/master/tools/FakeNet">https://github.com/PacktPublishing/Mastering-Reverse-Engineering/tree/master/tools/FakeNet</a></li>
<li>SysInternals Suite: <a href="https://docs.microsoft.com/en-us/sysinternals/downloads/">https://docs.microsoft.com/en-us/sysinternals/downloads/</a></li>
<li>Snowman: <a href="https://derevenets.com/">https://derevenets.com/</a></li>
<li>HxD: <a href="https://mh-nexus.de/en/hxd/">https://mh-nexus.de/en/hxd/</a></li>
<li>CFF Explorer: <a href="https://ntcore.com/">https://ntcore.com/</a></li>
</ul>
<p>We may need other tools as we proceed with our analysis. If you find tools that are more comfortable to use, feel free to use them.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Initial static analysis</h1>
                
            
            
                
<p>To help us out in terms of our static info gathering, here is a list of the information that we need to obtain:</p>
<ul>
<li>File properties (name, size, other info)</li>
<li>Hash (MD5, SHA1)</li>
<li>File type (including header information)</li>
<li>Strings</li>
<li>Deadlisting (highlight where we need information)</li>
</ul>
<p>At the end of the initial analysis, we will have to summarize all the information we retrieved.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Initial file information</h1>
                
            
            
                
<p>To get the filename, file size, hash calculations, file type, and other information regarding the file, we will be using <kbd>CFF</kbd> Explorer. When opening the file, we might encounter an error message when using the latter, as can be seen in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1228 image-border" src="img/bd96f036-2350-4a15-bb9a-0ee95534364b.png" style="width:46.00em;height:12.75em;" width="552" height="153"/></p>
<p>This error is caused by MS Windows' virus protection feature. Since we are in a sandboxed environment (under a virtualized guest environment), it should be okay to disable this. Disabling this feature in a production environment can expose risks for the computer getting compromised by malware.</p>
<p>To disable this feature in Windows, select Start-&gt;Settings-&gt;Windows Security-&gt;Virus &amp; threat protection-&gt;Virus &amp; threat protection settings. Then turn off Real-time protection. You might as well turn off both Cloud-delivered protection and Automatic sample submission to prevent any security settings from blocking activities that the program that is being analyzed might perform.</p>
<p>The following screenshot shows Real-time protection disabled:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1229 image-border" src="img/2227778a-5de9-40fb-9730-cc75bc095a97.png" style="width:38.08em;height:38.08em;" width="614" height="615"/></p>
<p>Opening the file with CFF Explorer reveals a lot of information, including packer identification of the file being UPX packed:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1230 image-border" src="img/34f736a3-b6b9-4a9a-aa99-652121aa44a8.png" style="width:47.75em;height:29.58em;" width="716" height="444"/></p>
<p>From the preceding result, we can tabulate the following file information:</p>
<table style="border-collapse: collapse; width: 100%;" border="1">
<tbody>
<tr>
<td>Filename</td>
<td><kbd>whatami.exe</kbd></td>
</tr>
<tr>
<td>File size</td>
<td>28,672 bytes</td>
</tr>
<tr>
<td>MD5</td>
<td>F4723E35D83B10AD72EC32D2ECC61091</td>
</tr>
<tr>
<td>SHA-1</td>
<td>4A1E8A976F1515CE3F7F86F814B1235B7D18A231</td>
</tr>
<tr>
<td>File type</td>
<td>Win32 PE file – packed with UPX v3.0</td>
</tr>
</tbody>
</table>
<p> </p>
<p>We will have to download the UPX tool and try to decompress the file. The UPX tool can be downloaded from <a href="https://upx.github.io/">https://upx.github.io/</a>. Using UPX, extract the file using the "<kbd>-d</kbd>" option, as follows:</p>
<pre>upx -d whatami.exe</pre>
<p class="mce-root">The result after decompressing the file, demonstrated as follows, tells us that the file originally had a size of 73,728 bytes:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1231 image-border" src="img/333c44f9-fcce-4917-b21a-8393c5ef9534.png" style="width:46.08em;height:12.42em;" width="618" height="166"/></p>
<p>So, if we re-open the file in CFF Explorer, our file information table would now include the following:</p>
<table style="border-collapse: collapse; width: 100%;" border="1">
<tbody>
<tr>
<td>Filename</td>
<td>whatami.exe</td>
</tr>
<tr>
<td>File size</td>
<td>73,728 bytes</td>
</tr>
<tr>
<td>MD5</td>
<td>18F86337C492E834B1771CC57FB2175D</td>
</tr>
<tr>
<td>SHA-1</td>
<td>C8601593E7DC27D97EFC29CBFF90612A265A248E</td>
</tr>
<tr>
<td>File type</td>
<td>Win32 PE file – compiled by Microsoft Visual C++ 8</td>
</tr>
</tbody>
</table>
<p> </p>
<p>Let's see what notable strings we can find using SysInternals' strings tool. Strings is a command-line tool. Just pass the filename as the tool's argument and redirect the output to a file. Here is how we use it:</p>
<pre>strings.exe whatami.exe &gt; filestrings.txt</pre>
<p>By removing noisy strings or text that are not relevant, we obtained the following:</p>
<pre>!This program cannot be run in DOS mode.<br/>Rich<br/>.text<br/>`.rdata<br/>@.data<br/>.rsrc<br/><strong>hey</strong><br/><strong>how did you get here?</strong><br/><strong>calc</strong><br/>ntdll.dll<br/><strong>NtUnmapViewOfSection</strong><br/>KERNEL32.DLL<br/>MSVCR80.dll<br/>USER32.dll<br/>Sleep<br/><strong>FindResourceW</strong><br/><strong>LoadResource</strong><br/><strong>LockResource</strong><br/><strong>SizeofResource</strong><br/>VirtualAlloc<br/>FreeResource<br/><strong>IsDebuggerPresent</strong><br/>ExitProcess<br/><strong>CreateProcessA</strong><br/><strong>GetThreadContext</strong><br/><strong>ReadProcessMemory</strong><br/>GetModuleHandleA<br/>GetProcAddress<br/>VirtualAllocEx<br/><strong>WriteProcessMemory</strong><br/><strong>SetThreadContext</strong><br/><strong>ResumeThread</strong><br/>GetCurrentProcess<br/>GetSystemTimeAsFileTime<br/>GetCurrentProcessId<br/>GetCurrentThreadId<br/>GetTickCount<br/>QueryPerformanceCounter<br/>SetUnhandledExceptionFilter<br/>TerminateProcess<br/>GetStartupInfoW<br/>UnhandledExceptionFilter<br/>InterlockedCompareExchange<br/>InterlockedExchange<br/>_XcptFilter<br/>exit<br/>_wcmdln<br/>_initterm<br/>_initterm_e<br/>_configthreadlocale<br/>__setusermatherr<br/>_adjust_fdiv<br/>__p__commode<br/>__p__fmode<br/>_encode_pointer<br/>__set_app_type<br/>_crt_debugger_hook<br/>?terminate@@YAXXZ<br/>_unlock<br/>__dllonexit<br/>_lock<br/>_onexit<br/>_decode_pointer<br/>_except_handler4_common<br/>_invoke_watson<br/>_controlfp_s<br/>_exit<br/>_cexit<br/>_amsg_exit<br/>??2@YAPAXI@Z<br/>memset<br/>__wgetmainargs<br/>memcpy<br/>UpdateWindow<br/>ShowWindow<br/><strong>CreateWindowExW</strong><br/><strong>RegisterClassExW</strong><br/>LoadStringW<br/><strong>MessageBoxA</strong><br/>WHATAMI<br/>t&lt;assembly  manifestVersion="1.0"&gt;<br/>  &lt;dependency&gt;<br/>    &lt;dependentAssembly&gt;<br/>      &lt;assemblyIdentity type="win32" name="Microsoft.VC80.CRT" version="8.0.50727.6195" processorArchitecture="x86" publicKeyToken="1fc8b3b9a1e18e3b"&gt;&lt;/assemblyIdentity&gt;<br/>    &lt;/dependentAssembly&gt;<br/>  &lt;/dependency&gt;<br/>&lt;/assembly&gt;PAD</pre>
<p>We highlighted a number of text strings. As a result, we may be expecting a number of messages to pop up by using the <kbd>MessageBoxA</kbd> function. With APIs such as <kbd>LoadResource</kbd> and <kbd>LockResource</kbd>, we may also encounter code that will process some data from the resource section. A suspended process may also be invoked after seeing APIs such as <kbd>CreateProcess</kbd> and <kbd>ResumeThread</kbd>. Anti-debugging may also be expected using the <kbd>IsDebuggerPresent</kbd> API. The program may have been compiled to use GUI-based code using <kbd>CreateWindowExW</kbd> and <kbd>RegisterClassExW</kbd>, but we do not see the window messaging loop functions: <kbd>GetMessage</kbd>, <kbd>TranslateMessage</kbd>, and <kbd>DispatchMessage</kbd>.</p>
<p>All these are just assumptions that we can better understand following further analysis. Now, let's try to do deadlisting on the file using IDA Pro.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Deadlisting</h1>
                
            
            
                
<p>After opening up <kbd>whatami.exe</kbd> in IDA Pro, auto-analysis recognizes the <kbd>WinMain</kbd> function. In the following screenshot, we can see that the first three APIs that will be executed are <kbd>LoadStringW</kbd>, <kbd>RegisterClassExW</kbd>, and <kbd>CreateWindowEx</kbd>:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1232 image-border" src="img/944764d5-5452-49b7-a608-d62f0716b1d7.png" style="width:60.00em;height:43.17em;" width="817" height="588"/></p>
<p>When <kbd>CreateWindowExW</kbd> is executed, the window properties are taken from the configuration set by <kbd>RegisterClassExW</kbd>. The <kbd>ClassName</kbd>, which is used as the name of the window, is taken from the file's text string resource using <kbd>LoadStringW</kbd>. However, our concern here would only be the code pointed to by <kbd>lpfnWindProc</kbd> takes us. When <kbd>CreateWindowExW</kbd> is executed, the code pointed to by the <kbd>lpfnWndProc</kbd> parameter is executed.</p>
<p>Before we proceed, take a look at <kbd>sub_4010C0</kbd>. Let's see the code that comes after <kbd>CreateWindowExW</kbd>:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1233 image-border" src="img/e2cdeaa3-09ee-44f0-ba7e-0424771208f0.png" style="width:42.17em;height:24.92em;" width="587" height="347"/></p>
<p>The preceding screenshot shows that after <kbd>CreateWindowExW</kbd>, <kbd>ShowWindow</kbd> and <kbd>UpdateWindow</kbd> are the only APIs that may be executed. However, there are indeed no window messaging APIs that were expected to process window activities. This would entail us assuming that the intention of the program was only to run code at the address pointed to by the <kbd>lpfnWndProc</kbd> parameter. </p>
<p>Double clicking on <kbd>dword_4010C0</kbd>, which is the address of  <kbd>lpfnWndProc</kbd>, will show a set of bytes that have not been properly analyzed by IDA Pro. Since we are sure that this area should be a code, we will have to tell IDA Pro that it is a code.  By pressing '<kbd>c</kbd>' at address <kbd>0x004010C0</kbd>, IDA Pro will start converting the bytes to readable assembly language code. Select <kbd>Yes</kbd> when IDA Pro asks us to convert to code:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1234 image-border" src="img/ac468539-3f52-4783-8283-469b3c820792.png" style="width:66.00em;height:17.08em;" width="792" height="205"/></p>
<p>Scrolling down, we will encounter another unrecognized code at <kbd>0x004011a0</kbd>. Just perform the same procedure:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1235 image-border" src="img/bdee9e12-1807-48b9-a856-30db46fe8f8a.png" style="width:66.83em;height:16.25em;" width="802" height="195"/></p>
<p>Scrolling down again will bring us to data that can no longer be converted. This should be the last part of the code. Let's tell IDA Pro that this code should be a treated as a function. To do that, highlight lines from <kbd>0x004010C0</kbd> to <kbd>0x004011C0</kbd>, right-click on the highlighted lines, and then select "<kbd>Create function...</kbd>" to turn the set of code into a function.</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1236 image-border" src="img/e7b3b932-4ec0-4d75-acfe-94182572daab.png" style="width:63.00em;height:24.00em;" width="756" height="288"/></p>
<p>Turning the code into a function will help our deadlisting see a graphical view of the code. To do that, right-click and select Graph view. The following screenshot shows the first set of code of the function. What interests us here is how the <kbd>rdtsc</kbd> and <kbd>cpuid</kbd> instructions were used:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1237 image-border" src="img/fe7fd37f-7f67-48f1-b326-02edfca89231.png" style="width:38.08em;height:50.42em;" width="623" height="826"/></p>
<p>In <em><a href="65131269-b507-47b8-9229-8f5ebb219464.xhtml">Chapter 11</a>, Identification with POC Malware</em>, under anti-debugging tricks, we discussed <kbd>rdtsc</kbd> being used as a timing trick. The difference is calculated right after the second <kbd>rdtsc</kbd>. In the following code, the expected duration should only be less than or equal to <kbd>0x10000</kbd>, or <kbd>65,536</kbd> cycles. If we get to pass that timing trick, a message box will appear.</p>
<p>Leaf 1 (set in the register <kbd>eax</kbd>) is passed to the first execution of a <kbd>cpuid</kbd> instruction. Again, in <a href="65131269-b507-47b8-9229-8f5ebb219464.xhtml">Chapter 11</a>, <kbd>cpuid</kbd> can be used for anti-VM tricks. The result is placed in register eax. This is followed by three <kbd>xor</kbd> instructions that eventually exchange the values of the <kbd>eax</kbd> and <kbd>ecx</kbd> registers.</p>
<pre>xor ecx, eax<br/>xor eax, ecx<br/>xor ecx, eax</pre>
<p>The bt instruction moves the 31st (<kbd>0x1F</kbd>) bit to the <kbd>carry</kbd> flag. If the 31st bit is set, it means that we are running in a hypervisor environment. We will need to take note of this line during our debugging session later. We want to make the result with the 31st bit set to <kbd>0</kbd>.</p>
<p>This may be followed by another check on the 5th bit using <kbd>xor ecx, 20h</kbd>. With the 5th bit set, it would mean that VMX (Virtual Machine eXtensions) instructions are available. If the VMX instructions are available, it would also mean that the system is capable of running virtualization. Usually, VMX is only available at the host VM, and the program can assume that it is running on the physical machine. For bitwise logic, if the 5th bit of <kbd>ecx</kbd> is set, an <kbd>xor</kbd> <kbd>20h</kbd> should make it a zero. But if the other bits of register <kbd>ecx</kbd> were set, register ecx would not have a zero value. We should also take note on this for our debug session.</p>
<p>Two main tricks were shown here – a timing-trick and an anti-VM trick. Overall, if we deduce what we analyzed, the program can either go in two directions: the loop at <kbd>loc_4010EF</kbd>, which makes no sense, and the <kbd>MessageBoxA</kbd> code.</p>
<p>If we take a closer look, the whole anti-debug and anti-VM tricks are enclosed by <kbd>pusha</kbd> and <kbd>popa</kbd> instructions. Essentially, we can skip the whole trick codes and jump right to the <kbd>MessageBoxA</kbd> code, as can be seen in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1238 image-border" src="img/69be9a22-0617-43f5-b253-b3948eb711ce.png" style="width:29.00em;height:43.08em;" width="396" height="589"/></p>
<p>The <kbd>MessageBoxA</kbd> code is followed by functions that read an <kbd>RCDATA</kbd> (<kbd>0x0A</kbd>) resource type with an ordinal name of <kbd>0x88</kbd> (<kbd>136</kbd>).  Using CFF Explorer, click on Resource Editor and expand <kbd>RCData</kbd>. We should be able to see the data being read here, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1239 image-border" src="img/e3da36a3-e137-4e4d-bdc7-7853fcc0d759.png" style="width:65.17em;height:30.08em;" width="782" height="361"/></p>
<p>The data is copied, using <kbd>memcpy</kbd>, to a memory space allocated using <kbd>VirtualAlloc</kbd>. The allocated size is the size indicated in the RCData's properties. The size can be seen by expanding <kbd>RCData</kbd> in the Resource Directory in <kbd>CFF</kbd> Explorer. The address of the copied data is left to the<kbd>edi register.</kbd></p>
<p>We also see <kbd>IsDebuggerPresent</kbd> being used here, another anti-debugging trick. Following the green line ends up to an <kbd>ExitProcess</kbd>.</p>
<p>The following screenshot is where the red line goes to:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1240 image-border" src="img/f1c9fdfa-5748-4fb4-845e-fa3f9bc0c243.png" style="width:24.08em;height:39.42em;" width="315" height="518"/></p>
<p>The loop at <kbd>loc_4011A0</kbd> seems to be decrypting the data. Remember that the address of the data is in register edi. The decryption algorithm uses a <kbd>ror</kbd> <kbd>0x0c</kbd> (rotate 12 bits to the right). After decryption, it stores the data address to register <kbd>eax</kbd> and then calls the <kbd>sub_4011D0</kbd> function.</p>
<p class="mce-root"/>
<p>Knowing the location and size of the decrypted data, we should be able to create a memory dump during our debug session.</p>
<p>Inside <kbd>sub_4011DO</kbd>, the address stored in eax is transferred to the esi register, and subsequently to register edi. We then encounter a call to <kbd>CreateProcessA</kbd> that runs "calc":</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1241 image-border" src="img/e5ef948f-0df7-491a-9538-ceae1b2992c7.png" style="width:30.25em;height:40.25em;" width="446" height="594"/></p>
<p>The process named "<kbd>calc</kbd>" is actually the Windows default calculator application. The sixth parameter of <kbd>CreateProcessA</kbd>, <kbd>dwCreationFlags</kbd>, is what interests us here. The value of 4 denotes CREATE_SUSPENDED. The calculator was run as a process in suspended mode. This means that it is not running and was only loaded in the calculator's own process space.</p>
<p class="mce-root"/>
<p>If we were to make a block diagram of <kbd>sub_4011D0</kbd> with the sequence of API functions, we would have something like this.</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1242 image-border" src="img/6d652ae7-c513-4389-b68e-ea5cc2a83aa8.png" style="width:16.17em;height:42.17em;" width="225" height="591"/></p>
<p>The sequence of APIs demonstrates a behavior called process hollowing. Process hollowing is a technique, commonly used by malware, to mask its code under a legitimate process. This technique creates a process in a suspended state, and then its memory is unmapped and replaced with a different process image. In this case, the legitimate process is Calculator.</p>
<p>The <kbd>NtUnmapViewOfSection</kbd> API is a function that unmaps or removes the PE image layout from a given process space. This API comes from the <kbd>NTDLL.DLL</kbd> library file. Instead of using <kbd>LoadLibrary</kbd>, the <kbd>GetModuleHandle</kbd> was used. <kbd>LoadLibrary</kbd> is used to load a library that has not yet been loaded, while <kbd>GetModuleHandle</kbd> is used to retrieve the handle of an already loaded library. In this case, the program assumed that <kbd>NTDLL.DLL</kbd> was already loaded.</p>
<p>The following screenshot shows the disassembly code that retrieves the function address of <kbd>NtUnmapViewOfSection</kbd>:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1243 image-border" src="img/3ff2b81f-36ec-483a-8944-76ef8245b5eb.png" style="width:32.25em;height:10.00em;" width="387" height="120"/></p>
<p>The decrypted data from the resource section's RCData is passed to sub_4011D0. Every call to <kbd>WriteProcessMemory</kbd> reads chunks of data from the decrypted data. Given this, we are expecting the decrypted data to be that of a <kbd>Win32</kbd> PE file.</p>
<p>To summarize, the code initially creates a window. However, the registered window properties are almost empty, except for the callback, <kbd>Wndproc</kbd>. The <kbd>Wndproc</kbd> callback is the code that initially executes when the window is created. As a result, the creation of a window using <kbd>RegisterClassEx</kbd> and <kbd>CreateWindow</kbd> APIs were just used to pass code execution. In other words, the whole window creation was the simple equivalent of a <kbd>jmp</kbd> instruction.</p>
<p>Here's another diagram outlining the flow of code at the Wndproc callback:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1244 image-border" src="img/2f056250-3218-4130-a3da-3b47c0d9324e.png" style="width:11.83em;height:27.33em;" width="142" height="328"/></p>
<p>In the first section of the <kbd>Wndproc</kbd> code, we encountered anti-debug (timing tricks with <kbd>rdtsc</kbd>) and anti-vm (<kbd>cpuid</kbd> bit 31 and 5) tricks. Once we get passed that, a message box appears. The data from the resource's RCData is copied to an allocated memory. We encounter another anti-debugging trick using the <kbd>IsDebuggerPresent</kbd> API. The data is decrypted and passed to a process-hollowing code using Calculator.</p>
<p>Our next target for analysis would be the decrypted image executed using process hollowing. We will start directly with debugging.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Debugging</h1>
                
            
            
                
<p>We will be using <kbd>x86dbg</kbd> for our debug session. Remember that we decompressed the file using UPX. It would be wise to open the decompressed version instead of the original whatami.exe file.  Opening the compressed will be fine but we will have to go through debugging the UPX packed code.</p>
<p>Unlike IDA Pro, <kbd>x86dbg</kbd> is not able to recognize the <kbd>WinMain</kbd> function where the real code starts. In addition, after opening the file, the instruction pointer may still be somewhere in the <kbd>NTDLL</kbd> memory space. And to avoid being in an <kbd>NTDLL</kbd> region during startup, we may need to make a short configuration change in <kbd>x86dbg</kbd>.</p>
<p>Select Options-&gt;Preference. Under the Events tab, uncheck System Breakpoint and TLS Callbacks. Click on the Save button and then select Debug-&gt;Restart. This should now bring us to the entry point of <kbd>whatami.exe</kbd> at the following address: <kbd>0x004016B8</kbd>.</p>
<p>Since we already know the <kbd>WinMain</kbd> address from IDA Pro, we can just place a breakpoint at that address. The WinMain address is at <kbd>0x00401000</kbd>. Press CTRL+G, then type <kbd>0x00401000</kbd>, then press <kbd>F2</kbd> to place a breakpoint, and finally press <kbd>F9</kbd> to run the program.</p>
<p>Here is a screenshot of where we should be at this point:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1245 image-border" src="img/0ab87182-92d2-404c-b7b1-a90d34c623f1.png" style="width:101.17em;height:26.83em;" width="1214" height="322"/></p>
<p>We have observed in our static analysis that <kbd>RegisterClassExW</kbd> and <kbd>CreateWindowExW</kbd> were used to set the WndProc as a window handler where more interesting codes are placed. Make a breakpoint at the WndProc address, <kbd>0x004010c0</kbd>, and then press F9. This should bring us to the following screenshot, where the anti-debug and anti-VM codes are located:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1246 image-border" src="img/cc6abbd1-5daf-4dd3-a481-05d7ff40bc0d.png" style="width:71.08em;height:39.67em;" width="853" height="476"/></p>
<p>We highlighted the anti-debug and anti-VM codes here. These codes run begins from the pushad instruction up to the popad instruction. What we can do here is skip the anti-debug and anti-VM codes. Press F7 or F8 until we are at address <kbd>0x004010C9</kbd>. Select line <kbd>0x00401108</kbd>, the line right after <kbd>popad</kbd>, and then right-click on it to bring up the context menu. Select Set New Origin Here. This brings the instruction pointer, register EIP, to this address.</p>
<p>We should now be at the code that displays the following message using the <kbd>MessageBoxA</kbd> function. Just keep on pressing <kbd>F8</kbd> until the following message appears:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1247 image-border" src="img/7b5d6d55-d7cd-45de-921e-5c6690a4c240.png" style="width:11.83em;height:9.67em;" width="154" height="125"/></p>
<p>You will have to click on the OK button for debugging to proceed. The next portion of the code will retrieve the <kbd>RCData</kbd> from the resource section. Keep on pressing <kbd>F8</kbd> until we reach line <kbd>0x0040117D</kbd>, a call to <kbd>memcpy</kbd>. If we look carefully at the three parameters to be passed for <kbd>memcpy</kbd>, register edi should contain the source address of the data to be copied, register <kbd>eax</kbd> should contain the destination address, and register <kbd>esi</kbd> should contain the size of data to be copied. To get a memory view of what the destination will contain, select the value of <kbd>EDI</kbd> in the right-hand pane, and then right-click on it to show the context menu. Select Follow in Dump. We should now be able to view Dump 1's memory space, as demonstrated in the following screenshot: </p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1248 image-border" src="img/c62ec0fc-248f-4d42-9ab3-f78f54c4d1b8.png" style="width:22.75em;height:30.58em;" width="342" height="461"/></p>
<p>Press <kbd>F8</kbd> to proceed with the <kbd>memcpy</kbd>. The following screenshot shows the current location:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1249 image-border" src="img/c8fa24a5-79e1-4148-a8d9-6d38bd409da5.png" style="width:57.42em;height:64.00em;" width="689" height="768"/></p>
<p>Keep on pressing <kbd>F8</kbd> until we are at the line (<kbd>0x00401192</kbd>) after the call to <kbd>IsDebuggerPresent</kbd>. Register <kbd>EAX</kbd> is expected to be set to <kbd>1</kbd>, which indicates a "<kbd>True</kbd>" value. We will need to change that to "<kbd>False</kbd>", with a zero value. To do that, double-click on the value of register <kbd>EAX</kbd>, and then change 1 to 0. In effect, this should not let the code jump straight to the <kbd>ExitProcess</kbd> call. </p>
<p>The next code would be the decryption routine. The arrows in the far left-hand pane show a <kbd>loopback</kbd> code. The algorithm uses a <kbd>ror</kbd> instruction. Keep on pressing <kbd>F8</kbd> while observing Dump 1. We can slowly see the data being decrypted, starting with an <kbd>MZ</kbd> header. You can place a breakpoint at address <kbd>0x004011B7</kbd>, where the decryption code ends and reveals entirely decrypted data, shown as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1250 image-border" src="img/b181cffc-145e-4e76-8ca0-3f684564ccc8.png" style="width:40.33em;height:38.00em;" width="626" height="590"/></p>
<p>The decrypted data is a <kbd>Win32</kbd> PE file with a size of <kbd>0x0D000</kbd> (53,248 bytes). What we can do here is dump this decrypted memory to a file. To do that, click on the Memory Map tab or select View-&gt;Memory Map. This shows us the process memory space with the addresses of memory sections and its respective size. The memory address where the decrypted data is, in our case, <kbd>0x001B000</kbd>. This address may be different to other analyzes. Select the decrypted data's memory address with a size of <kbd>0x00D000</kbd>, right-click to bring up the context menu, and then select Dump Memory to File. Refer to the following example:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1251 image-border" src="img/ab880fb3-5717-4e14-b593-ded0ef9154c5.png" style="width:62.33em;height:44.33em;" width="748" height="532"/></p>
<p>Save the file and open it with CFF Explorer. This gives us the following file information:</p>
<table style="border-collapse: collapse; width: 100%;" border="1">
<tbody>
<tr>
<td>File size</td>
<td>53,248 bytes</td>
</tr>
<tr>
<td>MD5</td>
<td>DD073CBC4BE74CF1BD0379BA468AE950</td>
</tr>
<tr>
<td>SHA-1</td>
<td>90068FF0C1C1D0A5D0AF2B3CC2430A77EF1B7FC4</td>
</tr>
<tr>
<td>File type</td>
<td>Win32 PE file – compiled by Microsoft Visual C++ 8</td>
</tr>
</tbody>
</table>
<p>In addition, viewing the import directory shows us four library modules: <kbd>KERNEL32</kbd>, <kbd>ADVAPI32</kbd>, <kbd>WS2_32</kbd>, and <kbd>URLMON</kbd>. The following CFF Explorer screenshot shows that registry and cryptography APIs are being imported from <kbd>ADVAPI32</kbd>:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1252 image-border" src="img/efd52791-c10a-4054-b3bb-6e451975f2bc.png" style="width:54.17em;height:42.00em;" width="650" height="504"/></p>
<p>The presence of <kbd>WS2_32</kbd> means that the program might use network socket functions. <kbd>URLDownloadToFile</kbd> is the single API imported from <kbd>URLMON</kbd>. We are expecting a file to be downloaded.</p>
<p class="mce-root"/>
<p>Going back to our debug session, there are two call instructions left. The one option is a call to <kbd>ExitProcess</kbd>, which will terminate the currently running process. The other is a call to address <kbd>0x004011DO</kbd>. Use <kbd>F7</kbd> to do a debug step causing the debugger to enter the call instruction. This is the function that does the process-hollowing routine. The following screenshot is where we should be at after entering <kbd>0x004011D0</kbd>:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1253 image-border" src="img/3dae1c5e-4076-45f1-ab3d-f37bdd6d4498.png" style="width:52.08em;height:33.25em;" width="625" height="399"/></p>
<p>Continue pressing <kbd>F8</kbd> until after the call to <kbd>CreateProcessA</kbd>. Open Windows Task Manger, and take a look at the list of processes. You should see <kbd>calc.exe</kbd> in suspended status, shown as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1254 image-border" src="img/da66e345-7684-44d6-bfb3-f6d15e43c8d2.png" style="width:54.83em;height:33.08em;" width="658" height="397"/></p>
<p>Continue pressing F8 until we reach the line that calls <kbd>ResumeThread</kbd> (<kbd>0x0040138C</kbd>). What happened is that the unknown PE file has just replaced the image of the Calculator process. If we take a look back at the block diagram of <kbd>sub_4011D0</kbd>, we are currently in the process hollowing behavior of this program. While Calculator is in suspended mode, no code is being executed yet. So before hitting <kbd>F8</kbd> on the <kbd>ResumeThread</kbd> line, we will have to attach the suspended Calculator and place breakpoints at the entry point or at its WinMain address. To do that, we will have to open up another <kbd>x86dbg</kbd> debugger, then select File-&gt;Attach, and look for calc. If you cannot see that, you will need to run as an administrator by selecting File-&gt;Restart.</p>
<p>Let's use IDA Pro to help us identify the <kbd>WinMain</kbd> address. Open the dumped memory in IDA Pro and, following the automated analysis, we'll be at the <kbd>WinMain</kbd> function. Change the view to Text view and then take note of the <kbd>WinMain</kbd> address, as in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1255 image-border" src="img/9daabfd9-b5cf-4d1a-9e39-8f7364ddbe46.png" style="width:67.33em;height:14.92em;" width="808" height="179"/></p>
<p>In <kbd>x86dbg</kbd>, place a breakpoint at <kbd>0x004017A0</kbd>, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1256 image-border" src="img/a8cc9ddc-d421-48b1-8061-0564d9129005.png" style="width:46.33em;height:24.00em;" width="556" height="288"/></p>
<p>Now we are ready to press <kbd>F8</kbd> over the <kbd>ResumeThread</kbd> line. But before doing that, it would be a good idea to create a snapshot of our running VM just in case something goes sideways:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1257 image-border" src="img/b00bfc6c-0590-47ef-af67-f6f8365f3b88.png" style="width:102.08em;height:67.25em;" width="1225" height="807"/></p>
<p>At this point, the only API left for <kbd>whatami.exe</kbd> to run is <kbd>ExitProcess</kbd>. This means that we can just press <kbd>F9</kbd> to let this process die.</p>
<p>After <kbd>ResumeThread</kbd> has been called, the <kbd>calc</kbd> process is lifted from being suspended and begins to run. But since the unknown image is in a debugger paused state, we observe that the <kbd>calc</kbd> image is still at the attached breakpoint instruction pointer.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">The unknown image</h1>
                
            
            
                
<p>At this point, we have the memory dump opened in IDA Pro and have the same unknown image mapped into a Calculator process. We will work with both tools by using IDA Pro for viewing the disassembly code and <kbd>x86dbg</kbd> for debugging.</p>
<p>In <kbd>x86dbg</kbd>, we have placed a breakpoint at the <kbd>WinMain</kbd> address of the unknown image. However, the instruction pointer is still at an <kbd>NTDLL</kbd> address. Hit <kbd>F9</kbd> to make it continue and bring us to our <kbd>WinMain</kbd>.</p>
<p>Taking a detailed look at the disassembly codes from <kbd>WinMain</kbd>, we will notice an SEH anti-debug here: </p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1258 image-border" src="img/9dba0f73-d52f-42aa-9060-2e8501cb1f06.png" style="width:42.58em;height:34.50em;" width="575" height="468"/></p>
<p><kbd>call sub_4017CB</kbd> goes to a subroutine that has a <kbd>call $+5</kbd>, <kbd>pop eax</kbd>, and then a <kbd>retn</kbd> instruction.  <kbd>call $+5</kbd> calls the next line. Remember that when <kbd>call</kbd> is executed, the top of the stack will contain the return address. <kbd>call sub_4017CB</kbd> stores the return address, <kbd>0x004017B3</kbd>, at the top of the stack. And again, <kbd>call $+5</kbd> stores <kbd>0x004017D0</kbd> at the top of the stack. <kbd>0x004017D0</kbd> is placed in the eax register because of <kbd>pop eax</kbd>. The ret instruction returns to the <kbd>0x004017AD</kbd> address. A value of 2 is added to the address stored at the <kbd>eax</kbd> register. As a result, the address in <kbd>eax</kbd> points to <kbd>0x004017D2</kbd>. This must be the handler for the SEH being set up.</p>
<p>We can go through the SEH, or simply skip this in our debug session. Skipping it would be as simple since we can identify the pushf/pusha and popa/popf instructions and execute the same process as we did in the <kbd>whatami.exe</kbd> process.</p>
<p>Going through the SEH should also be simple. We can just place a breakpoint at the handler address, <kbd>0x004017D2</kbd>, and press <kbd>F9</kbd> until we reach the handler.</p>
<p>We can choose either of these options. When it comes to decisions like this, it is always wise to take a snapshot of the VM. We can try both options by simply restoring the VM snapshot.</p>
<p>Our next stop is <kbd>sub_401730</kbd>. The following screenshot shows the code in <kbd>sub_401730</kbd>:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1259 image-border" src="img/1f5afc70-9fd4-4b11-a134-00633edc2eca.png" style="width:72.08em;height:45.33em;" width="865" height="544"/></p>
<p>Debugging through this code reveals that <kbd>LoadLibraryA</kbd> and <kbd>GetProcAddress</kbd> is used to retrieve the address of <kbd>MessageBoxA</kbd>. Afterward, it just displays a message.</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1260 image-border" src="img/13c0140c-b9a3-4c92-8a36-2ae633d93d1f.png" style="width:13.83em;height:10.83em;" width="198" height="155"/></p>
<p>The next lines of code is an anti-automated analysis trick. We can see that the difference of the results of two <kbd>GetTickCount</kbd> is being compared to a value <kbd>0x0493e0</kbd> or <kbd>300000</kbd>. Between the calls to <kbd>GetTickCount</kbd>, a Sleep function is also called.</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1261 image-border" src="img/84224f71-7972-4b5a-ab53-4fc1e2561031.png" style="width:40.00em;height:9.42em;" width="515" height="122"/></p>
<p>A Sleep for 300000 means 5 minutes. Usually, automated analysis systems would turn a long Sleep to a very short one. The preceding code wants to make sure that 5 minutes really elapsed. As analysts debugging this code, we can simply skip this trick by setting our instruction pointer after the jb instruction.</p>
<p>Next is a call to <kbd>sub_401500</kbd> with two parameters: "<kbd>mcdo.thecyberdung.net</kbd>" and <kbd>0x270F</kbd> (<kbd>9999</kbd>). The routine contains socket APIs. As we did before, let us list down the sequence of APIs we will encounter.</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1262 image-border" src="img/5da17ef7-1d5d-4ec2-bce6-da8f60a2300b.png" style="width:9.50em;height:29.00em;" width="155" height="476"/></p>
<p>For network socket behaviors, what we will be looking into are the parameters and results for <kbd>gethostbyname</kbd>, <kbd>htons</kbd>, <kbd>send</kbd> and <kbd>recv</kbd>. Again, before we proceed, taking a VM snapshot would be recommended at this point.</p>
<p>Keep on step debugging until we reach the call to <kbd>gethostbyname</kbd>. We can get the server to which the program is connecting to by looking at <kbd>gethostbyname</kbd>'s parameters. And that would be "<kbd>mcdo.thecyberdung.net</kbd>". Proceeding with the call, we might encounter a problem with gethostbyname's result. The result in register EAX is zero. This means <kbd>gethostbyname</kbd> failed because it was not able to resolve "<kbd>mcdo.thecyberdung.net</kbd>" to an IP address. What we need to do is setup <kbd>FakeNet</kbd> to mimic the internet. Revert the VM snapshot to take us back before executing <kbd>WSAStartup</kbd>.</p>
<p>Before running <kbd>FakeNet</kbd>, disconnect the cable by selecting Machine-&gt;Settings-&gt;Network from the VirtualBox menu. Expand the Advanced menu and uncheck Cable connected. We are doing this procedure to make sure that there will be no interference for <kbd>FakeNet</kbd> reconfiguring the network.</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1263 image-border" src="img/4dfa693d-503f-4f74-a485-a970788a3495.png" style="width:53.50em;height:36.58em;" width="642" height="439"/></p>
<p>The following screenshot shows <kbd>FakeNet</kbd> running successfully. <kbd>FakeNet</kbd> might require running in administrative privileges. If that happens, just run it as an Administrator:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1264 image-border" src="img/80d8275d-6920-4043-8fbe-a8634476dde2.png" style="width:42.25em;height:18.08em;" width="696" height="298"/></p>
<p>Restore cable connection by checking the VM Network settings' Cable Connected check box. To verify that everything works fine, open up Internet Explorer and visit any website. The resulting page should be similar to the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1265 image-border" src="img/29d6134e-4011-428a-931c-0044cc63d31c.png" style="width:40.58em;height:31.08em;" width="683" height="524"/></p>
<p>Now, we can go back to our debugging at the <kbd>gethostbyname</kbd> address. We should now get a result in register <kbd>EAX</kbd> with <kbd>FakeNet</kbd> running.</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1266 image-border" src="img/f16a8cd1-bfa2-4221-b15d-fcf872e74fd1.png" style="width:71.08em;height:7.58em;" width="853" height="91"/></p>
<p>The next API we are after is <kbd>htons</kbd>. This should give us information about the server's network port the program is going to connect to. The parameter passed to <kbd>htons</kbd> is stored in register <kbd>ECX</kbd>. This is the port number that will be used, <kbd>0x270F</kbd> or <kbd>9999</kbd>.</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1267 image-border" src="img/d3eb8ed4-5b1c-447c-a300-7cf8f825787a.png" style="width:86.92em;height:10.83em;" width="1043" height="130"/></p>
<p>Going on with debugging, we encounter the connect function where actual connection to the server and given port commences. The connect function returns zero to register <kbd>EAX</kbd> if it was successful. In our case, this fails with a <kbd>-1</kbd> return value.</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1427 image-border" src="img/8fd24efd-99db-4f8c-a88b-fa31a6939789.png" style="width:82.33em;height:6.50em;" width="988" height="78"/></p>
<p>The reason for this is that FakeNet only supports commonly used and few known malware ports. Fortunately, we can edit FakeNet's configuration and add port 9999 to the list. FakeNet's configuration file, FakeNet.cfg, is found at the same directory where FakeNet's executable is. But before updating this file, we will have to revert again to snapshot before <kbd>WSAStartup</kbd> is called.</p>
<p>Using Notepad, edit <kbd>FakeNet.cfg</kbd>. Look for the line that has the "<kbd>RawListner</kbd>" text. If not found, just append the following lines in the config file.</p>
<pre>RawListener Port:9999 UseSSL:No</pre>
<p>When this line is added, the config file should look like this:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1268 image-border" src="img/d9ca9b81-b7f4-49d8-8636-0468a0e2231e.png" style="width:53.08em;height:34.50em;" width="740" height="483"/></p>
<p>Take note of the added <kbd>RawListener</kbd> line. After this, restart <kbd>FakeNet</kbd> then debug again until we reach the <kbd>connect</kbd> API. This time we are expecting the connect function to become successful.</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1269 image-border" src="img/b459d245-6250-4552-9ecf-f8960a1eb70a.png" style="width:72.08em;height:6.00em;" width="865" height="72"/></p>
<p>Continue debugging until we reach the send function. The second parameter (look at the second entry from the top of stack) of the send function points to the address of the data to be sent. Press <kbd>F8</kbd> to proceed sending the data and look at <kbd>FakeNet</kbd>'s command console.</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1270 image-border" src="img/04fe011d-19fc-4989-9b1e-027f3d265d48.png" style="width:81.25em;height:42.25em;" width="975" height="507"/></p>
<p>We highlighted the communication between this program and <kbd>FakeNet</kbd>. Remember that <kbd>FakeNet</kbd> here is a mimic of the remote server. The data sent was "<kbd>OLAH</kbd>".</p>
<p>Continue debugging until we reach another send or <kbd>recv</kbd> function. The next function is a <kbd>recv</kbd>. </p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1271 image-border" src="img/5553d328-abf7-40ba-bbdc-676319e48a8a.png" style="width:67.83em;height:10.17em;" width="814" height="122"/></p>
<p>The second parameter is the buffer that receives data from the server. Apparently, we are not expecting <kbd>FakeNet</kbd> to send any data back. What we can do is monitor succeeding code that will process the data in this <kbd>recv</kbd> buffer. But to make the <kbd>recv</kbd> call successful, the return value should be a non-zero number. We will have to change register EAX's value after stepping on the <kbd>recv</kbd> call, as we did in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1272 image-border" src="img/33e6d80c-8ef7-4a7d-b04f-9a4e55522e5e.png" style="width:72.00em;height:27.83em;" width="864" height="334"/></p>
<p> </p>
<p>The next lines of code compare the data received with a string. See the following disassembly using the <kbd>repe cmpsb</kbd> instruction to compare the strings.  This instruction compares the text string stored at the address pointed to by registers <kbd>ESI</kbd> and <kbd>EDI</kbd>.  The number of bytes to compare is stored in register <kbd>ECX</kbd>.  The supposedly received data is located at the address pointed to by register <kbd>ESI</kbd>.  And the address of the string, "<kbd>jollibee</kbd>", is stored in register <kbd>EDI</kbd>.  What we want to happen here is make both strings equal.</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1273 image-border" src="img/199617e2-c270-4c2c-9705-fc9063e72b40.png" style="width:48.83em;height:16.00em;" width="586" height="192"/></p>
<p>To do that in our debug session, we will have to edit the bytes at the received data address and make it equal to the 9 character string being compared to. Right click on the value of register ESI to bring up the context menu, select Follow in Dump. At the first byte of the data in Dump window, right click and select Binary-&gt;Edit.</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1274 image-border" src="img/9c6ca9b4-2d8c-4007-8b55-54f22335c22e.png" style="width:37.92em;height:37.67em;" width="534" height="530"/></p>
<p>This pops up a dialog box (shown in the following) where we can enter the string "jollibee":</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1275 image-border" src="img/f044cce3-ff5c-49e0-99c8-27476d1ee789.png" style="width:25.67em;height:23.58em;" width="395" height="364"/></p>
<p>Hit F8 to proceed with the comparison.  This should not go to the address where the conditional jump points to. Continue debugging until we reach another send function. Again, look at the data to be sent, which is the address that the second parameter points to. However, irrespective of whether this succeeds or fails, the result is not processed. The succeeding API closes the connection with <kbd>closesocket</kbd> and WSACleanup functions, sets <kbd>EAX</kbd> to <kbd>1</kbd>, and returns from the current function. <kbd>EAX</kbd> will only be set to <kbd>1</kbd> after the last send function.</p>
<p>We've highlighted <kbd>var_DBD</kbd> in the disassembly code shown below to see that a value of 1 was stored after the sending data back to the server.</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1276 image-border" src="img/69265df9-3e46-4dae-9a47-d3a693ad44b5.png" style="width:56.08em;height:25.25em;" width="673" height="303"/></p>
<p>After returning to the <kbd>WinMain</kbd> function, it would be wise to do a VM snapshot.</p>
<p>Keep on debugging until we reach a call to address <kbd>0x00401280</kbd>. There are two parameters that will be passed to the function with values stored in the <kbd>EAX</kbd> and <kbd>ECX</kbd> registers . The data is dumped under <kbd>Dump 1</kbd>, demonstrated as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1277 image-border" src="img/9f96b84d-a3a9-4cfd-9fe0-2320f4a6a65e.png" style="width:69.25em;height:35.25em;" width="831" height="423"/></p>
<p class="mce-root">After entering function <kbd>0x00401280</kbd>, we will only encounter a URLDownloadToFile function. The function downloads <kbd>https://raw.githubusercontent.com/PacktPublishing/Mastering-Reverse-Engineering/master/ch12/manginasal</kbd> and stores it to a file named <kbd>unknown</kbd>, as can be seen in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1434 image-border" src="img/29ac6bdc-7b6c-4c56-b02e-ad7e599ac7a5.png" style="width:56.25em;height:10.17em;" width="675" height="122"/></p>
<p>Doing this, we get to encounter an error that fails to download the file. The reason is that we are still under a mimicked internet.  This time, we will need to get a connection to the live internet. We will have to revert back to the snapshot before the <kbd>URLDownloadToFile</kbd> function happens.</p>
<p>In the FakeNet console, press <em>CTRL + C</em> to exit the tool. To test whether the live internet is up, visit <a href="http://testmyids.com">http://testmyids.com</a> from the internet browser. The result should be similar to the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1279 image-border" src="img/8f75bef0-1f45-4f84-82f6-d64c27a86e07.png" style="width:56.67em;height:9.33em;" width="680" height="112"/></p>
<p>Check VirtualBox's network configuration and Windows' network setup if the internet cannot be accessed.</p>
<p>With the internet connection up, the program should be able to download the file successfully. The file is downloaded with the filename <kbd>unknown</kbd>. If we load this file in CFF Explorer, we get these file properties:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1280 image-border" src="img/d70d28ca-824e-4428-a041-044bdd433a26.png" style="width:27.42em;height:21.58em;" width="376" height="297"/></p>
<p>The following screenshot shows the file's content by selecting the CFF Explorer's Hex Editor:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1281 image-border" src="img/0d2d2d21-17d6-4d93-8906-814aa5f33136.png" style="width:51.08em;height:25.33em;" width="613" height="304"/></p>
<p>The file seems to be encrypted. We should expect that the next behavior will process this file. Keep on debugging until we reach a call to address <kbd>0x004012e0</kbd>. This function accepts two parameters, an address stored in <kbd>EAX</kbd>, and another address pushed to the stack. The function receives these <kbd>imagine</kbd> parameter strings from the top of the stack and <kbd>unknown</kbd> from the register <kbd>EAX</kbd>.</p>
<p class="mce-root"/>
<p>Entering the function reveals reading the content of the file  "unknown". The disassembly code that reads the file in a newly allocated memory space is as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1282 image-border" src="img/dec5b811-42f5-432a-a913-4f86bf17e748.png" style="width:52.08em;height:32.25em;" width="625" height="387"/></p>
<p>Keep on pressing <kbd>F8</kbd> until after the <kbd>CloseHandle</kbd> call. The next set of code shows the use of <kbd>Cryptographic</kbd> APIs. Let's list the sequence of APIs here once again:</p>
<pre>.text:0040137A call ds:CryptAcquireContextA<br/>.text:0040139B call ds:CryptCreateHash<br/>.text:004013C8 call ds:CryptHashData<br/>.text:004013EC call ds:CryptDeriveKey<br/>.text:004013FF call sub_401290<br/>.text:0040147B call ds:CryptDecrypt<br/>.text:0040149D call ds:CreateFileA<br/>.text:004014AF call ds:WriteFile<br/>.text:004014B6 call ds:CloseHandle<br/>.text:004014BE call ds:Sleep<br/>.text:004014D9 call ds:CryptDestroyKey<br/>.text:004014E4 call ds:CryptDestroyHash<br/>.text:004014F1 call ds:CryptReleaseContext</pre>
<p>Based on the list, it would seem that whatever is decrypted gets stored in a file. What we would want to know about this are the following:</p>
<ul>
<li>The cryptographic algorithm used</li>
<li>The cipher key used</li>
<li>The name of the file it stores data into</li>
</ul>
<p>To identify the algorithm used, we should monitor the parameters used in either <kbd>CryptAcquireContextA</kbd> function. Keep on debugging until <kbd>CryptAcquireContextA</kbd>. The fourth parameter, <kbd>dwProvType</kbd>, should tell us what algorithm was used. <kbd>dwProvType</kbd> here is <kbd>0x18</kbd> or <kbd>24</kbd>. For the list of provider type values, we can reference <a href="https://docs.microsoft.com/en-us/dotnet/api/system.security.permissions.keycontainerpermissionattribute.providertype">https://docs.microsoft.com/en-us/dotnet/api/system.security.permissions.keycontainerpermissionattribute.providertype</a>. In this case, 24 is defined for the value of <kbd>PROV_RSA_AES</kbd>. Thus, the cipher algorithm here uses <kbd>RSA AES</kbd>.</p>
<p>The cipher key used for this algorithm should be the third parameter of the <kbd>CryptHashData</kbd> function. Look at the second parameter of the <kbd>CryptHashData</kbd> function in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1283 image-border" src="img/1b37c065-05b0-4389-b202-08c1db122bd8.png" style="width:90.17em;height:27.58em;" width="1082" height="331"/></p>
<p>The key is <kbd>this0is0quite0a0long0cryptographic0key</kbd>.  </p>
<p>For the final piece of information, we need to monitor <kbd>CreateFileA</kbd> to get the filename of where the decrypted data will possibly be placed.  After debugging to <kbd>CreateFileA</kbd>, we should see the first parameter as the output filename, "<kbd>imagine</kbd>". The <kbd>CryptDecrypt</kbd> function accepts the location of encrypted data, the fifth parameter, and decrypts it at the same location. The process runs in a loop where every piece of decrypted data gets appended to the "imagine" file.</p>
<p>The following screenshot, an IDA Pro graphical view, shows decrypted data being appended to the output file:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1284 image-border" src="img/04c32dde-4d4e-423c-960a-3cd7a0fbbd89.png" style="width:29.67em;height:51.00em;" width="613" height="1054"/></p>
<p>The decryption ends by closing the cryptographic handles with <kbd>CryptDestroyKey</kbd>, <kbd>CryptDestroyHash</kbd>, and <kbd>CryptReleaseContext</kbd>.</p>
<p>Curious enough, let's use CFF Explorer to extract information from the "<kbd>imagine</kbd>" file:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1285 image-border" src="img/e01b8815-3c93-4fa9-a838-15d52b16504a.png" style="width:27.50em;height:25.67em;" width="397" height="371"/></p>
<p>Using the TrID tool, we get a more meaningful file type, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1286 image-border" src="img/b7438729-a772-407e-a581-f04c66d7eebc.png" style="width:33.00em;height:7.33em;" width="477" height="106"/></p>
<p>The file is a <kbd>PNG</kbd> image file.</p>
<p>Continuing with the debug session, keep on pressing <kbd>F8</kbd> until we reach a call to address <kbd>0x00401180</kbd>. Press <kbd>F7</kbd> to enter this function. This reveals the utilization of registry APIs in this sequence:</p>
<pre>.text:004011BF call ds:RegOpenKeyExA<br/>.text:004011E6 call esi ; RegQueryValueExA<br/>.text:004011F3 call edi ; RegCloseKey<br/>.text:00401249 call ds:RegOpenKeyA<br/>.text:0040126A call esi ; RegQueryValueExA<br/>.text:00401271 call edi ; RegCloseKey</pre>
<p>Basically, the registry functions here only retrieve certain values that exist in the registry. The disassembly codes shown below shows that the first query retrieves the data value of <kbd>ProgId</kbd> from the <kbd>HKEY_CURRENT_USER\Software\Microsoft\Windows\Shell\Associations\UrlAssociations\http\UserChoice</kbd> registry key:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1287 image-border" src="img/9877d651-ebb4-4aa4-96be-ed3a937cebb0.png" style="width:74.67em;height:24.08em;" width="896" height="289"/></p>
<p>If we take a look at the registry, this location points to the ID of the default internet browser used by the logged-in user. The following screenshot shows an example of the ID of the default internet browser set in <kbd>Progid</kbd>, which is <kbd>FirefoxURL-308046B0AF4A39CB</kbd>:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1288 image-border" src="img/7be3ae70-acdb-4d97-b9dd-b9cce1179235.png" style="width:59.50em;height:13.75em;" width="714" height="165"/></p>
<p>For the next registry query, <kbd>RegOpenKeyExA</kbd> opens the <kbd>HKEY_CLASSES_ROOT\FirefoxURL-308046B0AF4A39CB\shell\open\command</kbd> registry key, where <kbd>FirefoxURL-308046B0AF4A39CB</kbd> is the ID of the default internet browser:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1289 image-border" src="img/436c57f9-4baf-417b-87c3-366faa0f7768.png" style="width:93.42em;height:16.83em;" width="1121" height="202"/></p>
<p>The succeeding <kbd>RegQueryValueExA</kbd> has the second parameter, <kbd>lpValuename</kbd>, equal to <kbd>zero</kbd>. Refer to the disassembly as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1290 image-border" src="img/4b6acf8a-b025-477c-9ba6-d011701760c4.png" style="width:28.17em;height:15.08em;" width="338" height="181"/></p>
<p>If <kbd>lpValuename</kbd> is equal to <kbd>0</kbd>, the data being retrieved will be taken from the default value. </p>
<p>Looking at the registry, this is displayed as (Default), demonstrated as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1291 image-border" src="img/d463d335-cbfe-4a62-af7b-b04ec70cc941.png" style="width:71.50em;height:14.75em;" width="858" height="177"/></p>
<p>Hence, the action performed by the function was retrieval of the command line for the default internet browser.</p>
<p>The following lines of code resolve the full file path of the "<kbd>imagine</kbd>" file, and then pass the path to the final function, <kbd>sub_401000</kbd>, before exiting the process:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1292 image-border" src="img/2925d97d-51ad-4d4f-9dca-798218cfac67.png" style="width:56.17em;height:14.17em;" width="674" height="170"/></p>
<p>Debugging into <kbd>sub_401000</kbd>, we encounter more than a hundred lines of code that pretty much moves test strings around. But the <kbd>bottomline</kbd> is that it will run another process using the <kbd>CreateProcessA</kbd>. Taking a look at the parameters that will be passed to <kbd>CreateProcess</kbd>, the second parameter, which is the command line, that it will execute contains the path of the default browser passed with the full path of the "imagine" file as its argument. From the following screenshot, it can be seen that we dumped the command line in Dump 1:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1293 image-border" src="img/4199826a-e020-4a76-8d0c-be6687ede8cd.png" style="width:81.08em;height:36.75em;" width="973" height="441"/></p>
<p>As a result, this opens the "imagine" file using the default internet browser. The following screenshot is displayed:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1294 image-border" src="img/bbd47186-f420-47a0-ae77-e901fc1b9d2b.png" style="width:47.92em;height:26.50em;" width="743" height="411"/></p>


            

            
        
    </div>



  
<div><h1 class="header-title">Analysis summary</h1>
                
            
            
                
<p>The following table concerns the file elements we found.</p>
<p>The original file is a UPX-packed Win32 executable file.</p>
<table style="border-collapse: collapse; width: 100%;" border="1">
<tbody>
<tr>
<td>Filename</td>
<td>whatami.exe</td>
</tr>
<tr>
<td>File size</td>
<td>28,672 bytes</td>
</tr>
<tr>
<td>MD5</td>
<td>F4723E35D83B10AD72EC32D2ECC61091</td>
</tr>
<tr>
<td>SHA-1</td>
<td>4A1E8A976F1515CE3F7F86F814B1235B7D18A231</td>
</tr>
<tr>
<td>File type</td>
<td>Win32 PE file – packed with UPX v3.0</td>
</tr>
</tbody>
</table>
<p> </p>
<p>The UPX unpacked version gives us this new information about the file:</p>
<table style="border-collapse: collapse; width: 100%;" border="1">
<tbody>
<tr>
<td>Filename</td>
<td>whatami.exe</td>
</tr>
<tr>
<td>File size</td>
<td>73,728 bytes</td>
</tr>
<tr>
<td>MD5</td>
<td>18F86337C492E834B1771CC57FB2175D</td>
</tr>
<tr>
<td>SHA-1</td>
<td>C8601593E7DC27D97EFC29CBFF90612A265A248E</td>
</tr>
<tr>
<td>File type</td>
<td>Win32 PE file – compiled by Microsoft Visual C++ 8</td>
</tr>
</tbody>
</table>
<p> </p>
<p>The program maps an unknown PE file using process hollowing. This PE file contains the following information:</p>
<table style="border-collapse: collapse; width: 100%;" border="1">
<tbody>
<tr>
<td>File size</td>
<td>53,248 bytes</td>
</tr>
<tr>
<td>MD5</td>
<td>DD073CBC4BE74CF1BD0379BA468AE950</td>
</tr>
<tr>
<td>SHA-1</td>
<td>90068FF0C1C1D0A5D0AF2B3CC2430A77EF1B7FC4</td>
</tr>
<tr>
<td>File type</td>
<td>Win32 PE file – compiled by Microsoft Visual C++ 8</td>
</tr>
</tbody>
</table>
<p> </p>
<p>A file downloaded from <a href="https://raw.githubusercontent.com/PacktPublishing/Mastering-Reverse-Engineering/master/ch12/manginasal">https://raw.githubusercontent.com/PacktPublishing/Mastering-Reverse-Engineering/master/ch12/manginasal</a> is stored in a file as unknown. Here is the file's information:</p>
<table style="border-collapse: collapse; width: 100%;" border="1">
<tbody>
<tr>
<td>Filename</td>
<td>unknown</td>
</tr>
<tr>
<td>File size</td>
<td>3,008 bytes</td>
</tr>
<tr>
<td>MD5</td>
<td>05213A14A665E5E2EEC31971A5542D32</td>
</tr>
<tr>
<td>SHA-1</td>
<td>7ECCD8EB05A31AB627CDFA6F3CFE4BFFA46E01A1</td>
</tr>
<tr>
<td>File type</td>
<td>Unknown file type</td>
</tr>
</tbody>
</table>
<p> </p>
<p>The unknown file was decrypted and stored using the filename "<kbd>imagine</kbd>", containing the following file information:</p>
<table style="border-collapse: collapse; width: 100%;" border="1">
<tbody>
<tr>
<td>Filename</td>
<td>imagine</td>
</tr>
<tr>
<td>File size</td>
<td>3,007 bytes</td>
</tr>
<tr>
<td>MD5</td>
<td>7AAF7D965EF8AEE002B8D72AF6855667</td>
</tr>
<tr>
<td>SHA-1</td>
<td>4757E071CA2C69F0647537E5D2A6DB8F6F975D49</td>
</tr>
<tr>
<td>File type</td>
<td>PNG file type</td>
</tr>
</tbody>
</table>
<p> </p>
<p>To recap what behaviors it executed, here is a step-by-step process:</p>
<ol>
<li>Displays a message box: "<kbd>How did you get here?</kbd>"</li>
<li>Decrypts a PE image from the resource section</li>
<li>Uses process hollowing to replace "<kbd>calc</kbd>" with a decrypted PE image</li>
</ol>
<ol start="4">
<li>Displays a message box: "Learning reversing is fun. For educational purposes only. This is not a malware."</li>
<li>Sleeps for 5 minutes</li>
<li>Checks the connection to the "<kbd>mcdo.thecyberdung.net:9999</kbd>" server</li>
<li>Downloads the file from <a href="http://raw.githubusercontent.com">raw.githubusercontent.com</a></li>
<li>Decrypts the downloaded file and outputs of result to a PNG image file.</li>
<li>Retrieves the default internet browser path</li>
<li>Displays the PNG image file using the default internet browser</li>
</ol>


            

            
        
    </div>



  
<div><h1 class="header-title">Summary</h1>
                
            
            
                
<p>Reversing a software takes time and patience. It may take days to analyze just one piece of software. But with practice and experience, the time it takes to analyze a file improves.</p>
<p>In this chapter, we dealt with a file that can be reversed using the tools we learned. With the help of a debugger, a disassembler, and tools such as CFF Explorer and TriD, we were able to extract file information and behaviors. In addition, we also learned to use FakeNet to mimic the network and the internet, which became very useful for us when generating network information for the socket functions.</p>
<p>There are a lot of obstacles, including anti-debugging tricks. However, familiarity with these tricks enabled us to skip these codes.</p>
<p>One of the most important tips when reversing is to keep on making snapshots just in case we encounter obstacles. We can experiment on every piece of data that functions require.</p>
<p>Again, reversing is a patience game that you can cheat by saving and loading snapshots.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Further Reading</h1>
                
            
            
                
<p>DLL Injection -<a href="https://en.wikipedia.org/wiki/DLL_injection"> https://en.wikipedia.org/wiki/DLL_injection</a></p>
<p>Process Hollowing - <a href="https://github.com/m0n0ph1/Process-Hollowing">https://github.com/m0n0ph1/Process-Hollowing</a></p>


            

            
        
    </div>



  </body></html>