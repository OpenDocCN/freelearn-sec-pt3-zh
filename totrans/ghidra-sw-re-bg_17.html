<html><head></head><body><div><p>&#13;
			<h1 id="_idParaDest-196"><a id="_idTextAnchor244"/><em class="italic">Chapter 14</em>: Extending Ghidra for Advanced Reverse Engineering</h1>&#13;
			<p><a id="_idTextAnchor245"/>In this chapter, we will discuss the next steps you can take to learn more about Ghidra and fully exploit its functionally. Throughout this book, you've learned how to use Ghidra for reverse engineering purposes. You've also learned how to modify and extend Ghidra, as well as how to contribute to the project with your own developments. Although it seems that we have already covered everything, we haven't talked about how to use Ghidra for breaking state-of-the-art reverse engineering challenges yet.</p>&#13;
			<p>During this chapter, you will learn about some advanced reverse engineering topics that are trending at the time of writing, including static and dynamic symbolic execution and <strong class="bold">Satisfiability Modulo Theories</strong> (<strong class="bold">SMT</strong>) solvers.</p>&#13;
			<p>Static symbolic execution (or simply symbolic execution) is a systematic program analysis technique that executes programs on symbolic inputs (for example, a vector of 32 bits named x) instead of concrete values (for example, 5 units).</p>&#13;
			<p>As the execution of the program progresses in a static symbolic execution session, the inputs go through restrictions (for example, if conditions, loop conditions, and so on), giving rise to formulas. These formulas contain arithmetic but also logical operations, which makes these <strong class="bold">Satisfiability Modulo Theories</strong> (<strong class="bold">SMT</strong>) problems; that is, problems where we must determine whether a first-order formula is satisfiable with respect to some logical theory. SMT is an extension of SAT (the Boolean satisfiability problem). As the name suggests, SAT formulas involves Boolean values, while SMT is a variant of SAT that has been enriched to cover integers, reals, arrays, data types, bit vectors, and pointers.</p>&#13;
			<p>Since both SAT and SMT are known to be hard problems (NP-Complete problems), in some situations, it is necessary to reduce their formulas. This can be done by partially feeding the formula with concrete values, something that is known as dynamic symbolic execution or concolic execution (where the word concolic refers to mixing concrete and symbolic values).</p>&#13;
			<p>We will start by providing an overview of the basics of some advanced reverse engineering tools and techniques<a id="_idTextAnchor246"/><a id="_idTextAnchor247"/>, before exploring the Ghidra extensions and capabilities that make use of these kinds of tools to make their jobs easier.</p>&#13;
			<p>In this chapter, we're going to cover the following topics:  </p>&#13;
			<ul>&#13;
				<li>Learning the basics of advanced reverse engineering</li>&#13;
				<li>Using Ghidra for advanced reverse engineering</li>&#13;
			</ul>&#13;
			<p>Let's get started!</p>&#13;
			<h1 id="_idParaDest-197"><a id="_idTextAnchor248"/>Technical requirements </h1>&#13;
			<p>The technical requirements for this chapter are as follows: </p>&#13;
			<ul>&#13;
				<li>Microsoft Z3 theorem prover: <a href="https://github.com/Z3Prover/z3">https://github.com/Z3Prover/z3</a>.</li>&#13;
				<li>Miasm reverse engineering framework: <a href="https://github.com/cea-sec/miasm">https://github.com/cea-sec/miasm</a>.</li>&#13;
			</ul>&#13;
			<p>This book's GitHub repository, which contains all the necessary code for this chapter: <a href="https://github.com/PacktPublishing/Ghidra-Software-Reverse-Engineering-for-Beginners/tree/master/Chapter14">https://github.com/PacktPublishing/Ghidra-Software-Reverse-Engineering-for-Beginners/tree/master/Chapter14</a></p>&#13;
			<p>Check out the following link to see the Code in Action video: <a href="https://bit.ly/2K1SmGd">https://bit.ly/2K1SmGd</a> </p>&#13;
			<h1 id="_idParaDest-198"><a id="_idTextAnchor249"/>Learning the basics of advanced reverse engineering</h1>&#13;
			<p>In this section, we will provide an overview of the Ghidra processor module skeleton. This skeleton <a id="_idIndexMarker514"/>will be a little bit different since processor modules are not written in Java. Instead, the processor modules are written in SLEIGH, the Ghidra processor specification language.</p>&#13;
			<h2 id="_idParaDest-199"><a id="_idTextAnchor250"/>Learning about symbolic execution</h2>&#13;
			<p>You should <a id="_idIndexMarker515"/>already be familiar <a id="_idIndexMarker516"/>with the aspects of debugging a program. In this kind of process, you explore the program using concrete values, which is why this is called concrete execution. For instance, the following screenshot shows an x86_64 debugging session. The <code>RAX</code> register takes a value of <code>0x402300</code> while debugging the <code>hello_world.exe</code> program, which is a concrete value:</p>&#13;
			<div>&#13;
				<div>&#13;
					<img src="img/B16207_14_001.jpg" alt="Figure 14.1 – Ghidra SLEIGH Editor plugin for the Eclipse IDE&#13;&#10;"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption"> </p>&#13;
			<p class="figure-caption">Figure 14.1 – Ghidra SLEIGH Editor plugin for the Eclipse IDE</p>&#13;
			<p>But there is a way of exploring a program using symbols instead of concrete values. This way of exploring a program is called symbolic execution and offers you the advantage of using a mathematical formula that represents all the possible values instead of a single one:</p>&#13;
			<ul>&#13;
				<li>Symbolic: <em class="italic">y = x + 1</em></li>&#13;
				<li>Concrete: <em class="italic">y = 5 + 1 = 6</em>; (assuming <em class="italic">x = 5</em>)</li>&#13;
			</ul>&#13;
			<p>Let's analyze the same code, from the first instruction (the <code>0x402300</code> address to the first jump instruction (the <code>0x402310</code>) address) using MIASM (https://github.com/cea-sec/miasm), which <a id="_idIndexMarker517"/>allows symbolic execution to be performed:</p>&#13;
			<pre>00  #!/usr/bin/python3</pre>&#13;
			<pre>01  from miasm.analysis.binary import Container</pre>&#13;
			<pre>02  from miasm.analysis.machine import Machine</pre>&#13;
			<pre>03  from miasm.core.locationdb import LocationDB</pre>&#13;
			<pre>04  from miasm.ir.symbexec import SymbolicExecutionEngine</pre>&#13;
			<pre>05  </pre>&#13;
			<pre>06  start_addr = 0x402300</pre>&#13;
			<pre>07  loc_db = LocationDB()</pre>&#13;
			<pre>08  target_file = open("hello_world.exe", 'rb')</pre>&#13;
			<pre>09  container = Container.from_stream(target_file, loc_db)</pre>&#13;
			<pre>10  </pre>&#13;
			<pre>11  machine = Machine(container.arch)</pre>&#13;
			<pre>12  mdis = machine.dis_engine(container.bin_stream, </pre>&#13;
			<pre>                              loc_db=loc_db)</pre>&#13;
			<pre>13  ira = machine.ira(mdis.loc_db)</pre>&#13;
			<pre>14  asm_cfg = mdis.dis_multiblock(start_addr)</pre>&#13;
			<pre>15  ira_cfg = ira.new_ircfg_from_asmcfg(asm_cfg)</pre>&#13;
			<pre>16  symbex = SymbolicExecutionEngine(ira)</pre>&#13;
			<pre>17  symbex_state = symbex.run_block_at(ira_cfg, start_addr)</pre>&#13;
			<pre>18  print (symbex_state)</pre>&#13;
			<p>This piece <a id="_idIndexMarker518"/>of code performs <a id="_idIndexMarker519"/>the following operations to symbolically execute the first basic block of our <code>hello_world.exe</code> program:</p>&#13;
			<ol>&#13;
				<li>This declares that this is a Python 3 script (line <code>00</code>).</li>&#13;
				<li>This code starts importing some necessary MIASM components (lines <code>01</code> to <code>04</code>).</li>&#13;
				<li>This instantiates the location database, which will be required later (line <code>07</code>)</li>&#13;
				<li>This opens the <code>hello_world.exe</code> file as a MIASM container (lines <code>08</code> and <code>09</code>).</li>&#13;
				<li>This creates a machine for the architecture of our <code>hello_world.exe</code> program, which is x86_64 (line <code>11</code>).</li>&#13;
				<li>This initializes the queue disassembly engine (line <code>12</code>).</li>&#13;
				<li>This initializes the IRA machine (line <code>13</code>). IRA is the MIASM intermediate representation that is analogous to PCode on Ghidra.</li>&#13;
				<li>This retrieves the control flow graph for the assembly language (line <code>14</code>).</li>&#13;
				<li>This retrieves the control flow graph for IRA intermediate representation (line <code>15</code>).</li>&#13;
				<li>It initializes the symbolic engine (line <code>16</code>).</li>&#13;
				<li>This runs the basic block at the <code>0x402300</code> address using the symbolic engine (line <code>17</code>).</li>&#13;
				<li>This prints the state of the symbolic engine (line <code>18</code>).</li>&#13;
			</ol>&#13;
			<p>If we run the preceding code, it will produce the following results: </p>&#13;
			<pre>C:\Users\virusito\hello_world&gt; python symbex_test.py</pre>&#13;
			<pre>(@32[@64[0x404290]] == 0x2)?(0x402318,0x402312)</pre>&#13;
			<p>The symbolic <a id="_idIndexMarker520"/>state of the <a id="_idIndexMarker521"/>program can be understood as follows: If the 64-bit address stored in <code>0x404290</code> points to a 32-bit value equal to <code>0x2</code> (this is how you must to read the left part of the interrogation, which is equivalent to an <code>if</code> statement), then jump to <code>0x402318</code>; otherwise, go to <code>0x402312</code>. </p>&#13;
			<p class="callout-heading">MIASM</p>&#13;
			<p class="callout">If you want to learn more about MIASM, check out the following link: <a href="https://github.com/cea-sec/miasm">https://github.com/cea-sec/miasm</a>. If you <a id="_idIndexMarker522"/>want to deeply understand the preceding code, check out the MIASM auto-generated Doxygen documentation: <a href="https://miasm.re/miasm_doxygen/">https://miasm.re/miasm_doxygen/</a>.</p>&#13;
			<p>In this section, you learned the basics of symbolic execution by writing a simple example. In the next section, we will learn why this is useful for symbolic execution.</p>&#13;
			<h2 id="_idParaDest-200"><a id="_idTextAnchor251"/>Learning about SMT solvers</h2>&#13;
			<p>SMT solvers <a id="_idIndexMarker523"/>take a (quantifier-free) first-order <a id="_idIndexMarker524"/>logic formula, <em class="italic">F</em>, as input over a background theory, <em class="italic">T</em>, and return the following:</p>&#13;
			<ul>&#13;
				<li><code>sat</code> (+ model): If <em class="italic">F</em> is satisfiable</li>&#13;
				<li><code>unsat</code>: If <em class="italic">F</em> is unsatisfiable</li>&#13;
			</ul>&#13;
			<p>Let's take a look at a Python example that's using the z3 theorem solver developed by Microsoft:</p>&#13;
			<pre>&gt;&gt;&gt; from z3 import *</pre>&#13;
			<pre>&gt;&gt;&gt; x = Int('x')</pre>&#13;
			<pre>&gt;&gt;&gt; y = Int('y')</pre>&#13;
			<pre>&gt;&gt;&gt; s = Solver()</pre>&#13;
			<pre>&gt;&gt;&gt; s.add(y == x + 5)</pre>&#13;
			<pre>&gt;&gt;&gt; s.add(y&lt;x)</pre>&#13;
			<pre>&gt;&gt;&gt; s.check()</pre>&#13;
			<pre>unsat</pre>&#13;
			<p>In the preceding code, we performed the following operations:</p>&#13;
			<ol>&#13;
				<li value="1">Imported Microsoft <code>z3</code>.</li>&#13;
				<li>Declared two z3 integer variables of the <code>int</code> type: <code>x</code> and <code>y</code>.</li>&#13;
				<li>Instantiated the z3 solver: s.</li>&#13;
				<li>Added a restriction indicating that <code>y</code> is <code>x</code> plus <code>5</code>.</li>&#13;
				<li>Added another restriction indicating that <code>y</code> is less than <code>x</code>.</li>&#13;
				<li>Checked if it is possible to find a concrete value that satisfies the formula.</li>&#13;
			</ol>&#13;
			<p>Obviously, the solver <a id="_idIndexMarker525"/>returns <code>unsat</code> because values for <code>y</code> and <code>x</code> do not exist. This is because <code>x</code> exceeds <code>y</code> by <code>5</code> units while <code>y</code> is less than <code>x</code>.</p>&#13;
			<p>If we repeat <a id="_idIndexMarker526"/>this experiment while changing the condition so that <code>y</code> is greater than <code>x</code>, the solver will return <code>sat</code>:</p>&#13;
			<pre>&gt;&gt;&gt; s = Solver()</pre>&#13;
			<pre>&gt;&gt;&gt; s.add(y == x + 5)</pre>&#13;
			<pre>&gt;&gt;&gt; s.add(y&gt;x)</pre>&#13;
			<pre>&gt;&gt;&gt; s.check()</pre>&#13;
			<pre>sat</pre>&#13;
			<pre>&gt;&gt;&gt; s.model()</pre>&#13;
			<pre>[x = 0, y = 5]</pre>&#13;
			<p>In this case, the formula can be solved, and we can also ask for the concrete values that are satisfying it by calling <code>model()</code>.</p>&#13;
			<p>SMT solvers can be combined with symbolic execution to check if a certain formula returns <code>sat</code> or <code>unsat</code>; for instance, if a certain path of a call graph can be reached or not.</p>&#13;
			<p>In fact, you can easily convert from a MIASM IRA symbolic state (the <code>symbex_state</code> variable on line <code>17</code> in the script shown in the previous section) using the <code>TranslatorZ3</code> module of MIASM. This can be seen in the following code snippet, which extends the script from the previous section:</p>&#13;
			<pre>19  from z3 import *</pre>&#13;
			<pre>20  from miasm.ir.translators.z3_ir import TranslatorZ3</pre>&#13;
			<pre>21  translatorZ3 = TranslatorZ3()</pre>&#13;
			<pre>22  solver = Solver()</pre>&#13;
			<pre>23  solver.add(translatorZ3.from_expr(symbex_state) == </pre>&#13;
			<pre>                                              0x402302)</pre>&#13;
			<pre>24  print(solver.check())</pre>&#13;
			<pre>25  if(solver.check()==sat):</pre>&#13;
			<pre>26    print(solver.model())</pre>&#13;
			<pre>27  solver = Solver()</pre>&#13;
			<pre>28  solver.add(translatorZ3.from_expr(symbex_state) == </pre>&#13;
			<pre>                                             0x4022E0)</pre>&#13;
			<pre>29  print(solver.check()</pre>&#13;
			<pre>30  if(solver.check()==sat):</pre>&#13;
			<pre>31    print(solver.model())</pre>&#13;
			<p>In the <a id="_idIndexMarker527"/>previous code snippet, the <a id="_idIndexMarker528"/>following operations are being performed:</p>&#13;
			<ol>&#13;
				<li value="1">Import Microsoft <code>z3</code> (line <code>19</code>).</li>&#13;
				<li>Import <code>TranslatorZ3</code>, which allows us to translate from a MIASM IRA machine symbolic state to a Microsoft z3 formula (line <code>20</code>).</li>&#13;
				<li>Instantiate the <code>TranslatorZ3</code> (line <code>21</code>).</li>&#13;
				<li>Instantiate the Microsoft z3 solver (line <code>22</code>).</li>&#13;
				<li>Convert the IRA symbolic state into a Microsoft <code>z3</code> formula and add a constraint to it indicating that the jump instruction must go directly to the <code>0x402302</code> address (line <code>23</code>).</li>&#13;
				<li>Ask whether the solver if this formula has a solution; that is, if it is possible to take the <code>0x402302</code> branch in some possible situation (line <code>24</code>).</li>&#13;
				<li>If the branch can be taken, ask the solver for a solution (lines <code>25</code> and <code>26</code>).</li>&#13;
				<li>Instantiate the solver again and repeat this process for the other branch (lines <code>27</code>-<code>31</code>).</li>&#13;
			</ol>&#13;
			<p>The result of executing the complete script gives us the following output:</p>&#13;
			<pre>zf?(0x402302,0x4022E0)</pre>&#13;
			<pre>sat</pre>&#13;
			<pre>[zf = 1]</pre>&#13;
			<pre>sat</pre>&#13;
			<pre>[zf = 0]</pre>&#13;
			<p>The preceding code prints the symbolic state of the MIASM IRA machine. Since we have no further <a id="_idIndexMarker529"/>restriction conditions <a id="_idIndexMarker530"/>for this branch, it returns <code>sat</code> for both paths of the branch. This means that both branches can be taken: the <code>0x402302</code> branch is taken when the zero flag is set to <code>1</code>, while the <code>0x4022E0</code> branch is taken when the zero flag is set to <code>0</code>.</p>&#13;
			<h2 id="_idParaDest-201"><a id="_idTextAnchor252"/>Learning about concolic execution</h2>&#13;
			<p>Symbolic execution (also known <a id="_idIndexMarker531"/>as static symbolic execution) is powerful since you can explore a path for all possible values. You can also explore <a id="_idIndexMarker532"/>other paths since it <a id="_idIndexMarker533"/>doesn't depend on the input that it receives. However, it does <a id="_idIndexMarker534"/>face some limitations:</p>&#13;
			<ul>&#13;
				<li>The SMT solver cannot handle non-linear and very complex constraints.</li>&#13;
				<li>Since it is a white-box technique, modeling libraries is a hard problem.</li>&#13;
			</ul>&#13;
			<p>To solve these limitations, we can feed the symbolic execution with concrete values. This technique <a id="_idIndexMarker535"/>is known as concolic execution (also known <a id="_idIndexMarker536"/>as dynamic symbolic execution).</p>&#13;
			<p>A popoular Python framework for analyzing binaries that combines both static and dynamic symbolic <a id="_idIndexMarker537"/>execution is known as the Angr framework. </p>&#13;
			<p class="callout-heading">Angr framework</p>&#13;
			<p class="callout">If you <a id="_idIndexMarker538"/>want to learn more about the Angr framework, check out the following link: <a href="https://angr.io/">https://angr.io/</a>. If you <a id="_idIndexMarker539"/>are interested in checking out some examples of Angr in action, refer to the Angr documentation: <a href="https://docs.angr.io/">https://docs.angr.io/</a>.</p>&#13;
			<p>As you <a id="_idIndexMarker540"/>can guess, these kinds <a id="_idIndexMarker541"/>of tools and techniques can be applied to a lot of challenging tasks during reverse engineering, especially during deobfuscation.</p>&#13;
			<h1 id="_idParaDest-202"><a id="_idTextAnchor253"/>Using Ghidra for advanced reverse engineering</h1>&#13;
			<p>Ghidra has <a id="_idIndexMarker542"/>an intermediate language <a id="_idIndexMarker543"/>known as PCode. It makes <a id="_idIndexMarker544"/>Ghidra powerful because it is suitable for applying these kinds of techniques. As we mentioned in <a href="B16207_09_Final_SK_ePub.xhtml#_idTextAnchor155"><em class="italic">Chapter 9</em></a>, <em class="italic">Scripting Binary Audits</em>, in the <em class="italic">PCode versus assembly language</em> section, the reason why PCode is more suitable for symbolic execution is because it offers more granularity than assembly. In fact, the side effects that take place in the assembly language, such as flag registers being modified during the execution of an instruction, doesn't happen in PCode because they are split into many instructions. This aspect of intermediate representations simplifies the task of creating and maintaining SMT formulas.</p>&#13;
			<p>In the next section, you will learn how to extend Ghidra with Angr, a powerful binary analysis framework for implementing symbolic execution.</p>&#13;
			<h2 id="_idParaDest-203"><a id="_idTextAnchor254"/>Adding symbolic execution capabilities to Ghidra with AngryGhidra</h2>&#13;
			<p>When <a id="_idIndexMarker545"/>looking for <a id="_idIndexMarker546"/>ways to perform symbolic execution on Ghidra's Telegram channel, I found a plugin that added Angr capabilities to Ghidra:</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B16207_14_002.jpg" alt="Figure 14.2 – AngryGhidra plugin posted on the GhidaRE Telegram channel&#13;&#10;"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption"> </p>&#13;
			<p class="figure-caption">Figure 14.2 – AngryGhidra plugin posted on the GhidaRE Telegram channel</p>&#13;
			<p>As we <a id="_idIndexMarker547"/>mentioned in <a href="B16207_13_Final_SK_ePub.xhtml#_idTextAnchor228"><em class="italic">Chapter 13</em></a>, <em class="italic">Contributing to the Ghidra Community</em>, Telegram groups about Ghidra are really useful. You can <a id="_idIndexMarker548"/>download the plugin <a id="_idIndexMarker549"/>for AngryGhidra from the following link: https://github.com/Nalen98/AngryGhidra.</p>&#13;
			<p>When <a id="_idIndexMarker550"/>using the AngryGhidra plugin, by right-clicking on an address, you can specify the following:</p>&#13;
			<ul>&#13;
				<li>Where to start the Angr analysis (<strong class="bold">Blank State Address</strong>).</li>&#13;
				<li>Path addresses you does not want to reach (<strong class="bold">Avoid Address</strong>).</li>&#13;
				<li>The address you want to reach (<strong class="bold">Find Address</strong>).</li>&#13;
			</ul>&#13;
			<p>The aforementioned fields can be seen in the following screenshot:</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B16207_14_003.jpg" alt="Figure 14.3 – AngryGhidra plugin interface&#13;&#10;"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption"> </p>&#13;
			<p class="figure-caption">Figure 14.3 – AngryGhidra plugin interface</p>&#13;
			<p>By using these fields, you can solve challenging binary problems in a few seconds:</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B16207_14_004.jpg" alt="Figure 14.4 – Quickly solving a challenge using AngryGhidra&#13;&#10;"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption"> </p>&#13;
			<p class="figure-caption">Figure 14.4 – Quickly solving a challenge using AngryGhidra</p>&#13;
			<p>In the <a id="_idIndexMarker551"/>next section, we will learn <a id="_idIndexMarker552"/>how to convert PCode into a <strong class="bold">Low-Level Virtual Machine</strong> (<strong class="bold">LLVM</strong>) intermediate <a id="_idIndexMarker553"/>representation. LLVM provides <a id="_idIndexMarker554"/>a few compiler and toolchain subprojects, but for this book, we are only interested in the LLVM intermediate representation subproject. </p>&#13;
			<h2 id="_idParaDest-204"><a id="_idTextAnchor255"/>Converting from PCode into LLVM with pcode-to-llvm</h2>&#13;
			<p>There's a conversation on Telegram asking about how it's possible <a id="_idIndexMarker555"/>to translate between two intermediate representations – specifically, translating from PCode to LLVM. This is because a lot of tools <a id="_idIndexMarker556"/>are not available for PCode and Ghidra is<a id="_idTextAnchor256"/> limited to Python 2 due to Jython:</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B16207_14_005.jpg" alt="Figure 14.5 – Idea of converting from PCode into LLVM for fuzzing purposes, &#13;&#10;posted in the GhidraRE Telegram channel&#13;&#10;"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption"> </p>&#13;
			<p class="figure-caption">Figure 14.5 – Idea of converting from PCode into LLVM for fuzzing purposes, posted in the GhidraRE Telegram channel</p>&#13;
			<p class="callout-heading">LLVM</p>&#13;
			<p class="callout">The LLVM project is a collection of modular and reusable compiler and toolchain technologies. Its core project is also named LLVM and contains everything you need to process intermediate <a id="_idIndexMarker557"/>representations and convert them into object files. For more information, check out the following link: <a href="https://llvm.org/docs/GettingStarted.html">https://llvm.org/docs/GettingStarted.html</a>.</p>&#13;
			<p>In this case, the person <a id="_idIndexMarker558"/>who asked this needs LLVM to use, for instance, a fuzzing library named libFuzzer (<a href="https://llvm.org/docs/LibFuzzer.html">https://llvm.org/docs/LibFuzzer.html</a>) in order to find vulnerabilities in binaries.</p>&#13;
			<p>You can use Ghidra to lift a compiled binary for LLVM by using the following plugin:</p>&#13;
			<p><a href="https://github.com/toor-de-force/Ghidra-to-LLVM">https://github.com/toor-de-force/Ghidra-to-LLVM</a>.</p>&#13;
			<p>As you know, there are a lot <a id="_idIndexMarker559"/>of interesting topics outside the scope of this book that you can <a id="_idIndexMarker560"/>investigate. I recommend that you join the Ghidra Telegram <a id="_idIndexMarker561"/>channels and the Ghidra community to learn more.</p>&#13;
			<h1 id="_idParaDest-205"><a id="_idTextAnchor257"/>Summary</h1>&#13;
			<p>In this chapter, you learned about some advanced reverse engineering topics; that is, symbolic execution, SMT solvers, and concolic execution.</p>&#13;
			<p>You learned how to perform symbolic execution by writing some simple code using MIASM that symbolically executed a basic block of a hello world program. You also learned about the z3 theorem solver by performing two simple experiments.</p>&#13;
			<p>Finally, you learned how to incorporate symbolic and concolic execution when using Ghidra by extending it with a plugin. You also learned how to convert from PCode into an LLVM intermediate representation, which can be useful for performing some advanced reverse engineering tasks.</p>&#13;
			<p>I hope you enjoyed reading this book. You've learned a lot, but remember to put this knowledge to practice in order to develop your skills further. Binary protections are becoming more and more complex, so it is necessary to master advanced reverse engineering topics. Ghidra can be a good ally in this battle, so use it and combine it with other powerful tools – maybe even your own.</p>&#13;
			<h1 id="_idParaDest-206"><a id="_idTextAnchor258"/>Questions</h1>&#13;
			<ol>&#13;
				<li value="1">What is the difference between concrete and symbolic execution?</li>&#13;
				<li>Can symbolic execution substitute concrete execution?</li>&#13;
				<li>Can Ghidra apply symbolic or concolic execution to a binary file?</li>&#13;
			</ol>&#13;
			<h1 id="_idParaDest-207"><a id="_idTextAnchor259"/>Further reading</h1>&#13;
			<p>Please refer to the following links for more information on the topics that were covered in this chapter:</p>&#13;
			<ul>&#13;
				<li><em class="italic">An abstract interpretation-based deobfuscation plugin for Ghidra</em>: <a href="https://www.msreverseengineering.com/blog/2019/4/17/an-abstract-interpretation-based-deobfuscation-plugin-for-ghidra">https://www.msreverseengineering.com/blog/2019/4/17/an-abstract-interpretation-based-deobfuscation-plugin-for-ghidra</a></li>&#13;
				<li><em class="italic">A Survey of Symbolic Execution Techniques</em>, <em class="italic">Baldoni, R., Coppa, E., Cono D'Elia, D., et al.</em>, <em class="italic">October 2016</em>: <a href="https://ui.adsabs.harvard.edu/abs/2016arXiv161000502B/abstract">https://ui.adsabs.harvard.edu/abs/2016arXiv161000502B/abstract</a></li>&#13;
				<li><em class="italic">A Survey of Satisfiability Modulo Theory</em>, <em class="italic">David Monniaux</em>, <em class="italic">January 2017</em>: <a href="https://hal.archives-ouvertes.fr/hal-01332051/document">https://hal.archives-ouvertes.fr/hal-01332051/document</a></li>&#13;
			</ul>&#13;
		</div>&#13;
	</div></body></html>