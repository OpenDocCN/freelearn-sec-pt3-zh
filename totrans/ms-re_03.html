<html><head></head><body><div><h1 class="header-title">The Low-Level Language</h1>
                
            
            
                
<p>The main piece of knowledge required in advance for any reverse engineer is assembly language. Understanding assembly language is like learning the ABCs of reversing. It may look hard at first, but eventually it will become like a muscle memory. Assembly language is the language that is used to communicate with the machine. The source code of a program can be understood by humans but not by the machine. The source code has to be compiled down to its assembly language code form for the machine to understand it. </p>
<p>But, as humans, what if the source code is not available? Our only way to understand what a program does is to read its assembly codes. In a way, what we are building here is a way to turn an assembly language code back to the source code. That would be why this is called reversing.</p>
<p>We will provide a brief introduction to assembly language, focusing on the x86 Intel architecture. So, why x86? There are a lot of architectures out there, such as 8080, ARM, MIPS, PowerPC, and SPARC, but we are focusing on Intel x86 as it is the most popular and widely used architecture today.</p>
<p>In this chapter, we will get to learn the basics of assembly language. We will start by reviewing binary numbers, followed by using assembly language instructions to implement binary arithmetic, we will then learn how to compile our own low-level program, and, finally, how to debug a program.</p>
<p>This chapter has been divided into sections. We will learn about the following:</p>
<ul>
<li>Binary numbers, bases, and the ASCII table</li>
<li>x86 architecture</li>
<li>Assembly language instructions</li>
<li>Tools used to edit and compile an assembly-language source code</li>
<li>Debugging tools</li>
<li>Exceptions and error handling</li>
<li>Windows APIs</li>
<li>High-level language constructs</li>
</ul>
<p class="mce-root"/>
<p>We will include instructions to set up and develop your assembly language code. This also comes with exercises that may help to inspire you to develop programs using assembly language.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Technical requirements</h1>
                
            
            
                
<p>It is best, but not required, that the reader has some background knowledge of any programming language. Having a programming background will help the reader to understand assembly language more quickly. There are references given at the end of this chapter that the reader can use for further programming development and research not provided in this book.</p>
<p>Some tools that we will use here include the following:</p>
<ul>
<li>Binary editors, such as HxD Editor or HIEW (Hacker's View)</li>
<li>Text editors, such as Notepad++</li>
</ul>


            

            
        
    </div>



  
<div><h1 class="header-title">Binary numbers</h1>
                
            
            
                
<p>Computers were designed to electronically process and store data using signals. A signal is like an on/off switch, where both the "on" and "off" positions can be denoted by the numbers "1" and "0" respectively. These two numbers are what we call binary numbers. The next section will discuss how binary numbers are used and how this relates to other number bases.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Bases</h1>
                
            
            
                
<p>The place value of a digit in a number determines its value at that position. In the standard decimal numbers, the value of a place is ten times the value of the place on its right. The decimal number system is also called base-10, which is composed of digits from 0 to 9.</p>
<p>Let's say that position 1 is at the right-most digit of the whole number, as follows:</p>
<pre>2018<br/>Place value at position 1 is 1 multiplied by 8 represents 8.<br/>Place value at position 2 is 10 multiplied by 1 represents 10.<br/>Place value at position 3 is 100 multiplied by 0 represents 0.<br/>Place value at position 4 is 1000 multiplied by 2 represents 2000.</pre>
<p class="mce-root"/>
<p>The sum of all represented numbers is the actual value. Following this concept will help us to read or convert into other number bases.</p>
<p>In base-2 numbers, the value of a place is 2 times the value of the place on its right. Base-2 uses only 2 digits, composed of 0 and 1. In this book, we will append a small <kbd>b</kbd> to denote that the number is of base-2 format. Base-2 numbers are also called binary numbers. Each digit in a binary string is called a bit. Consider the following as an example:</p>
<pre>11010b<br/>Place value at position 1 is 1 multiplied by 0 represents 0.<br/>Place value at position 2 is 2 multiplied by 1 represents 2.<br/>Place value at position 3 is 4 multiplied by 0 represents 0.<br/>Place value at position 4 is 8 multiplied by 1 represents 8.<br/>Place value at position 5 is 16 multiplied by 1 represents 16.<br/><br/>The equivalent decimal value of 11010b is 26.</pre>
<p>In base-16 numbers, the value of a place is 16 times the value of the place on its right. It is composed of digits 0 to 9 and letters A to F where A is equivalent to 10, B is 11, C is 12, D is 13, E is 14, and F is 15. We will denote base-16 numbers, also known as hexadecimal numbers, with the letter <kbd>h</kbd>. In this book, hexadecimal numbers with an odd number of digits will be prefixed with <kbd>0</kbd> (zero). Hexadecimal numbers can also instead be prefixed with "0x" (zero and a lowercase x). The <kbd>0x</kbd> is a standard used on various programming languages denoting that the number next to it is of hexadecimal format:</p>
<pre>BEEFh<br/>Place value at position 1 is 1 multiplied by 0Fh (15) represents 15.are<br/>Place value at position 2 is 16 multiplied by 0Eh (14) represents 224.<br/>Place value at position 3 is 256 multiplied by 0Eh (14) represents 3584.<br/>Place value at position 4 is 4096 multiplied by 0Bh (11) represents 45056.<br/><br/>The equivalent decimal value of BEEFh is 48879.</pre>


            

            
        
    </div>



  
<div><h1 class="header-title">Converting between bases</h1>
                
            
            
                
<p>We have already converted hexadecimal and binary numbers into decimal, or base-10. Converting base-10 into other bases simply requires division of the base being converted into, while taking note of the remainders.</p>
<p>The following is an example for base-2</p>
<pre>87 to base-2<br/><br/>87 divided by 2 is 43 remainder <strong>1</strong>.<br/>43 divided by 2 is 21 remainder <strong>1</strong>.<br/>21 divided by 2 is 10 remainder <strong>1</strong>.<br/>10 divided by 2 is 5 remainder <strong>0</strong>.<br/>5 divided by 2 is 2 remainder <strong>1</strong>.<br/>2 divided by 2 is <strong>1</strong> remainder <strong>0</strong>.<br/>1 divided by 2 is 0 remainder <strong>1</strong>.<br/>and nothing more to divide since we're down to 0.<br/><br/>base-2 has digits 0 and 1.<br/>Writing the remainders backward results to 1010111b. </pre>
<p class="mce-root">The following is an example for base-16:</p>
<pre class="mce-root">34512 to base-16<br/><br/>34512 divided by 16 is 2157 remainder 0.<br/>2157 divided by 16 is 134 remainder 13 (0Dh)<br/>134 divided by 16 is 8 remainder 6.<br/>6 divided by 16 is 0 remainder 6.<br/><br/>base-16 has digits from 0 to 9 and A to F.<br/>Writing the remainders backward results to 66D0h.</pre>
<p>Converting from hexadecimal into binary simply requires knowing how many binary digits there are in a hexadecimal digit. The highest digit for a hexadecimal number is <kbd>0Fh</kbd> (15) and is equivalent to <kbd>1111b</kbd>. Take note that there are 4 binary digits in a hexadecimal digit. An example conversion is shown here:</p>
<pre>ABCDh<br/> 0Ah = 1010b<br/> 0Bh = 1011b<br/> 0Ch = 1100b<br/> 0Dh = 1101b<br/><br/> Just combine the equivalent binary number.<br/> ABCDh = 1010101111001101b</pre>
<p>Split the binary number into four digits each when converting from binary into hexadecimal, as shown here:</p>
<pre>1010010111010111b<br/> 1010b = 10 (0Ah)<br/> 0101b = 5<br/> 1101b = 13 (0Dh)<br/> 0111b = 7<br/><br/> 1010010111010111b = A5D7h<br/></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>So, why the use of base-2 and base-16 in computers, rather than our daily base-10 usage? Well, for base-2, there are two states: an on and an off signal. A state can easily be read and transmitted electronically. Base-16 compresses the representation of the binary equivalent of a decimal number. Take 10 for instance: this number is represented as <kbd>1010b</kbd> and consumes 4 bits. To maximize the information that can be stored in 4 bits, we can represent numbers from 0 to 15 instead.</p>
<p>A 4-bit value is also called a nibble. It is half of a byte. Bytes can represent alphabets, numbers, and characters. This representation of characters is mapped in the ASCII table. The ASCII table has three sections: control, printable, and extended characters. There are 255 (<kbd>FFh</kbd>) ASCII characters. Lists of printable characters that can be typed on the keyboard and some of the extended characters with keyboard format can be found at <a href="https://github.com/PacktPublishing/Mastering-Reverse-Engineering/tree/master/ch3">https://github.com/PacktPublishing/Mastering-Reverse-Engineering/tree/master/ch3</a>.</p>
<p>Though not directly visible from the English language keyboard, symbols can still be displayed by using the character's equivalent code.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Binary arithmetic</h1>
                
            
            
                
<p>Since a byte is the common unit used in computers, let's play with it. We can start with basic arithmetical functions: addition, subtraction, multiplication, and division. The pencil-and-paper method is still a strong method for doing binary math. Binary arithmetic is similar to doing arithmetic in decimal numbers. The difference is that there are only two numbers used, 1 and 0.</p>
<p>Addition is carried out as follows:</p>
<pre>  1b               10101b<br/>+ 1b             +  1111b <br/> 10b              100100b</pre>
<p>An example of subtraction is as follows:</p>
<pre> 10b               1101b<br/>- 1b              - 111b <br/>  1b                110b</pre>
<p>Multiplication is carried out as follows:</p>
<pre>   101b             1b x 1b = 1b<br/>x   10b             1b x 0b = 0b<br/>   000<br/>  101   <br/>  1010b</pre>
<p class="mce-root"/>
<p>Division in binary works as follows:</p>
<pre>       1010b                         1000b <br/>10b | 10100b                  11b | 11010b<br/>     -10                           -11 <br/>       010                           0010<br/>       -10                           -000<br/>         00                            10b (remainder)<br/>         -0<br/>          0</pre>


            

            
        
    </div>



  
<div><h1 class="header-title">Signed numbers</h1>
                
            
            
                
<p>Binary numbers can be structured as signed or unsigned. For signed numbers or integers, the most significant bit dictates what sign the number is in. This requires a defined size of the binary such as <kbd>BYTE</kbd>, <kbd>WORD</kbd>, <kbd>DWORD</kbd>, and <kbd>QWORD</kbd>. A <kbd>BYTE</kbd> has a size of 8 bits. A <kbd>WORD</kbd> has 16 bits while a DWORD (double <kbd>WORD</kbd>) has 32 bits. A <kbd>QWORD</kbd> (quad <kbd>WORD</kbd>) has 64 bits. Basically, the size doubles as it progresses.</p>
<p>In our example, let's use a <kbd>BYTE</kbd>. Identifying a positive binary number is easy. In positive numbers, the most significant bit, or 8<sup>th</sup> bit in a byte, is 0. The rest of the bits from 0 to the 7th bit is the actual value. For a negative binary number, the most significant bit is set to 1. However, the value set from 0 to the 7th bit is then calculated for a two's complement value:</p>
<pre><strong>0</strong>1011011b = +91<br/><strong>1</strong>1011011b = -37<br/><strong>1</strong>0100101b = -91<br/><strong>0</strong>0100101b = +37</pre>
<p>The "2's complement" of a value is calculated in two steps:</p>
<ol>
<li>Reverse 1s and 0s, so that 1 becomes 0 and 0 becomes 1, for example, <kbd>1010b</kbd> becomes <kbd>0101b</kbd>. This step is called the one's complement.</li>
<li>Add 1 to the result of the previous step, for example, <kbd>0101b + 1b = 0110b</kbd>.</li>
</ol>
<p>To write down the binary equivalent of -63, assuming it is a <kbd>BYTE</kbd>, we only take bits 0 to 7:</p>
<ol>
<li class="mce-root">Convert into binary using the previous procedure:</li>
</ol>
<pre style="color: black;padding-left: 60px">63 = 0111111b</pre>
<ol start="2">
<li class="mce-root">Do "1's complement" as follows:</li>
</ol>
<pre style="color: black;padding-left: 60px">0111111b -&gt; 1000000b</pre>
<ol start="3">
<li class="mce-root">Add 1 to the preceding outcome to get the "2's complement" result:</li>
</ol>
<pre style="color: black;padding-left: 60px">1000000b + 1 = 1000001b</pre>
<ol start="4">
<li class="mce-root">Since this is a negative number, set the most significant bit to 1:</li>
</ol>
<pre style="color: black;padding-left: 60px">11000001b = -63</pre>
<p>Here's how to write the decimal of a negative binary number:</p>
<ol>
<li class="mce-root">Take note that the significant bit is 1, and so a negative sign:</li>
</ol>
<pre style="color: black;padding-left: 60px"><strong>1</strong>0111011b</pre>
<ol start="2">
<li class="mce-root">Take the "1's complement," then add 1:</li>
</ol>
<pre style="color: black;padding-left: 60px">  01000100b<br/>+        1b <br/>  01000101b</pre>
<ol start="3">
<li class="mce-root">Convert the result to decimal, and place the – sign at the beginning, since this is a negative number:</li>
</ol>
<pre style="color: black;padding-left: 60px">- 01000101b = -69</pre>


            

            
        
    </div>



  
<div><h1 class="header-title">x86</h1>
                
            
            
                
<p>Like any other programming language, assembly language has its own variables, syntax, operations, and functions. Every line of code is processes a small amount of data. In other words, every byte is read or written per line of code.</p>
<p class="mce-root"/>


            

            
        
    </div>



  
<div><h1 class="header-title">Registers</h1>
                
            
            
                
<p>In programming, processing data requires variables. You can simply think of registers as variables in assembly language. However, not all registers are treated as plain variables, but rather, each register has a designated purpose. The registers are categorized as being one of the following:</p>
<ul>
<li>General purpose registers</li>
<li>Segment registers</li>
<li>Flag registers</li>
<li>Instruction pointers</li>
</ul>
<p>In x86 architecture, each general purpose register has its designated purpose and is stored at <kbd>WORD</kbd> size, or 16 bits, as follows:</p>
<ul>
<li>Accumulator (AX)</li>
<li>Counter (CX)</li>
<li>Data (DX)</li>
<li>Base (BX)</li>
<li>Stack pointer (SP)</li>
<li>Base pointer (BP)</li>
<li>Source index (SI)</li>
<li>Destination index (DI)</li>
</ul>
<p>For registers AX, BX, CX, and DX, the least and most significant bytes can be accessed by smaller registers. For AX, the lower 8 bits can be read using the AL register, while the upper 8 bits can be read using the AH register, as shown here:</p>
<div><img class="alignnone size-full wp-image-1016 image-border" src="img/9526322d-72c7-40e5-be7b-4114fb6d614c.png" style="width:85.33em;height:19.58em;" width="1024" height="235"/></div>
<p>When running code, the system needs to identify where the code is at. The Instruction Pointer (IP) register is the one that contains the memory address where the next assembly instruction to be executed is stored.</p>
<p>System states and logical results of executed code are stored in the <strong>FLAGS register</strong>. Every bit of the FLAGS register has its own purpose, with some of the definitions given in the following table:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td class="CDPAlignCenter CDPAlign"><strong>Offset</strong></td>
<td class="CDPAlignCenter CDPAlign"><strong>Abbreviation</strong></td>
<td class="CDPAlignCenter CDPAlign"><strong>Description</strong></td>
</tr>
<tr>
<td>0</td>
<td>CF</td>
<td>Carry flag. This flag is set when an addition operation requires a bit to be carried. It is also set when a bit needs to be borrowed in a subtraction operation.</td>
</tr>
<tr>
<td>1</td>
<td/>
<td>Reserved</td>
</tr>
<tr>
<td>2</td>
<td>PF</td>
<td>Parity flag. This flag indicates if the number of set bits is odd or even from the last instruction operation.</td>
</tr>
<tr>
<td>3</td>
<td/>
<td>Reserved</td>
</tr>
<tr>
<td>4</td>
<td>AF</td>
<td>Adjust flag. This is used in Binary-Coded Decimals (BCD). This flag is set when a carry happens from the low to high nibble or when a borrow happens from the high to low nibble of a byte.</td>
</tr>
<tr>
<td>6</td>
<td>ZF</td>
<td>Zero flag. This flag is set when the result of the last instruction operation is zero.</td>
</tr>
<tr>
<td>7</td>
<td>SF</td>
<td>Sign flag. This flag is set when the result of the last instruction operation is a negative number.</td>
</tr>
<tr>
<td>8</td>
<td>TF</td>
<td>Trap flag. This is used when debugging. This flag is set when breakpoints are encountered. Setting the trap flag can cause an exception on every instruction, enabling debugging tools to control step-by-step debugging.</td>
</tr>
<tr>
<td>9</td>
<td>IF</td>
<td>Interrupt flag. If this flag is set, the processor responds to interrupts. Interrupts are instances where errors, external events, or exceptions are triggered from hardware or software. </td>
</tr>
<tr>
<td>10</td>
<td>DF</td>
<td>Direction flag. When set, data is read from memory backwards.</td>
</tr>
<tr>
<td>11</td>
<td>OF</td>
<td>Overflow flag. It is set if an arithmetic operation results in a value larger than what the register can contain.</td>
</tr>
<tr>
<td>12 to 13</td>
<td>IOPL</td>
<td>Input/output privilege level. The IOPL shows the ability of the program to access IO ports.</td>
</tr>
<tr>
<td>14</td>
<td>NT</td>
<td>Nested task flag. This controls the chaining of interrupt tasks or processes. If set, then it is linked to the chain.</td>
</tr>
<tr>
<td>15</td>
<td/>
<td>Reserved</td>
</tr>
<tr>
<td>16</td>
<td>RF</td>
<td>Resume flag. It temporarily disables debug exceptions so the next instruction being debugged can be interrupted without a debug exception.</td>
</tr>
<tr>
<td>17</td>
<td>VM</td>
<td>Virtual mode. Sets the program to run in compatibility with 8086 processors.</td>
</tr>
<tr>
<td>18</td>
<td>AC</td>
<td>Alignment check. This flag is set when data written on a memory reference, such as the stack, is a non-word (for 4 byte boundaries) or non-doubleword (for 8 byte boundaries). However, this flag was more useful before the 486-architecture days.</td>
</tr>
<tr>
<td>19</td>
<td>VIF</td>
<td>Virtual interrupt flag. Similar to the interrupt flag, but works when in virtual mode.</td>
</tr>
<tr>
<td>20</td>
<td>VIP</td>
<td>Virtual interrupt pending flag. Indicates that triggered interrupts are waiting to be processed. Works in Virtual mode.</td>
</tr>
<tr>
<td>21</td>
<td>ID</td>
<td>Identification flag. Indicates if the CPUID instruction can be used. The CPUID can determine the type of processor and other processor info.</td>
</tr>
<tr>
<td>22</td>
<td/>
<td>Reserved</td>
</tr>
<tr>
<td>23 to 31</td>
<td/>
<td>Reserved</td>
</tr>
<tr>
<td>32 to 63</td>
<td/>
<td>Reserved</td>
</tr>
</tbody>
</table>
<p> </p>
<p>All of these flags have a purpose, but the flags that are mostly monitored and used are the carry, sign, zero, overflow, and parity flags.</p>
<p>All these registers have an "extended" mode for 32-bits. It can accessed with a prefixed "E" (<kbd>EAX</kbd>, <kbd>EBX</kbd>, <kbd>ECX</kbd>, <kbd>EDX</kbd>, <kbd>ESP</kbd>, <kbd>EIP</kbd>, and <kbd>EFLAGS</kbd>). The same goes with 64-bit mode, which can be accessed with a prefixed "R" (<kbd>RAX</kbd>, <kbd>RBX</kbd>, <kbd>RCX</kbd>, <kbd>RDX</kbd>, <kbd>RSP</kbd>, and <kbd>RIP</kbd>).</p>
<p>The memory is divided into sections such as the code segment, stack segment, data segment, and other sections. The segment registers are used to identify the starting location of these sections, as follows:</p>
<ul>
<li>Stack segment (SS)</li>
<li>Code segment (CS)</li>
<li>Data segment (DS)</li>
<li>Extra segment (ES)</li>
<li>F segment (FS)</li>
<li>G segment (GS)</li>
</ul>
<p>When a program loads, the operating system maps the executable file to the memory. The executable file contains information to which data maps respective segments. The code segment contains the executable code. The data segment contains the data bytes, such as constants, strings, and global variables. The stack segment is allocated to contain runtime function variables and other processed data. The extra segment is similar to the data segment, but this space is commonly used to move data between variables. Some 16-bit operating systems, such as DOS, make use of the SS, CS, DS, and ES since there are only 64 kilobytes allocated per segment. However, in modern operating systems (32-bit systems and higher) these four segments are set in the same memory space, while FS and GS point to process and thread information respectively.</p>
<p class="mce-root"/>


            

            
        
    </div>



  
<div><h1 class="header-title">Memory addressing</h1>
                
            
            
                
<p>The start of a piece of data, a series of bytes, stored in the memory can be located using its memory address. Every byte stored in the memory is assigned a memory address that identifies its location. When a program is executed by a user, the executable file is read, then mapped by the system to an allocated memory address. The executable file contains information on how it maps it, so that all executable code is in the code section, all initialized data is in the data section, and uninitialized data is in the BSS section. Code instructions found in the code section are able to access data in the data section using memory addresses, which can be hard-coded. Data can also be a list of addresses pointing to another set of data.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Endianness</h1>
                
            
            
                
<p>When reading or writing data to memory, we use the registers or memory to process them as <kbd>BYTE</kbd>, <kbd>WORD</kbd>, <kbd>DWORD</kbd>, or even <kbd>QWORD</kbd>. Depending on the platform or program, data is read in little-endian or big-endian form.</p>
<p>In little-endian, a chunk of data read into a <kbd>DWORD</kbd> is reversed. Let's take the following piece of data as an example:</p>
<p><kbd>AA BB CC DD</kbd></p>
<p>When the data on a file or memory looks like this, in little-endian format, it will be read as <kbd>DDCCBBAAh</kbd> in a <kbd>DWORD</kbd> value. This endianness is common to Windows applications.</p>
<p>In the big-endian system, the same chunk of data will be read as <kbd>AABBCCDDh</kbd>. The advantage of using the big-endian form arises when reading streaming data such as file, serial, and network streams.</p>
<p>The advantage of reading in little-endian is that the address you read it from remains fixed, regardless of whether it is read as <kbd>BYTE</kbd>, <kbd>WORD</kbd>, or <kbd>DWORD</kbd>. For example, consider the following:</p>
<pre>Address       Byte<br/>0x00000000    AA<br/>0x00000001    00<br/>0x00000002    00<br/>0x00000003    00</pre>
<p>In the preceding example, we attempt to read the data from address the <kbd>0x00000000</kbd> address. When read as <kbd>BYTE</kbd>, it will be <kbd>AAh</kbd>. When read as a <kbd>WORD</kbd>, it will be <kbd>AAh</kbd>. When read as a <kbd>DWORD</kbd>, it will be <kbd>AAh</kbd>.</p>
<p>But when in big endian, when read as a <kbd>BYTE</kbd>, it will be <kbd>AAh</kbd>. When read as a <kbd>WORD</kbd>, it will be <kbd>AA00h</kbd>. When read as a <kbd>DWORD</kbd>, it will be <kbd>AA000000h</kbd>.</p>
<p>There are actually a lot more advantages over the other. Either of these can be used by an application depending on its purpose. In <kbd>x86</kbd> assembly, the little-endian format is the standard.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Basic instructions</h1>
                
            
            
                
<p>Assembly language is made up of direct lines of code that follow this syntax:</p>
<div><img class="alignnone size-full wp-image-637 image-border" src="img/24fb4ebb-a025-441f-96ea-0233fbe2e22d.png" style="width:43.08em;height:7.67em;" width="718" height="128"/></div>
<p>The label is used to define the location of the instruction line. It is generally used during development of an assembly code without prior knowledge of the address where the code will be placed in the memory. Some debuggers are able to support having the user label addresses with a readable name. A mnemonic is a human readable instruction, such as MOV, ADD and SUB. Every mnemonic is represented by a byte number or a couple of bytes called an opcode. The operands are the instruction's arguments. This is normally read as <kbd>destination, source</kbd> . In the instruction shown above, the <kbd>eax</kbd> register is the destination and the doubleword data stored at address 0x0AD4194. Finally, we can add comments to every instruction line of our program. </p>
<p>In assembly language, code comments are denoted by a semicolon (;)</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    </div>



  
<div><h1 class="header-title">Opcode bytes</h1>
                
            
            
                
<div><p>Every instruction has an equivalent opcode (operation code) byte:</p>
<pre>Address     Opcode          Instructions<br/>00A92D7C    B8 00000080     MOV EAX,80000000h<br/>00A92D81    B9 02000000     MOV ECX,2<br/>00A92D86    F7E1            MUL ECX</pre>
<p>In the preceding code, the MOV instruction is equivalent to the <kbd>B8</kbd> opcode byte. The <kbd>MOV</kbd> instruction at the <kbd>00A92D81</kbd> address is equivalent to <kbd>B9</kbd>. The difference between the two <kbd>MOV</kbd> instructions is the register into which the <kbd>DWORD</kbd> value is moved. There are a total of 5 bytes consumed in <kbd>MOV EAX, 80000000h</kbd>. It consists of the opcode byte, <kbd>B8</kbd>, and the operand value, <kbd>80000000h</kbd>. The same number of bytes is also used in <kbd>MOV ECX, 2</kbd>, and <kbd>MUL ECX</kbd> uses 2 bytes.</p>
<p><kbd>MOV EAX, 80000000h</kbd> is located at <kbd>00A92D7ch</kbd>. Add 5 bytes (becomes <kbd>00A92D81</kbd>) and we get to the address of the next instruction. Viewing the code in the memory would look like this:</p>
<pre>Address     Bytes<br/>00A92D7C    B8 00 00 00 80 B9 02 00 00 00 F7 E1</pre></div>
<p>A dump of memory is usually shown in memory dumpers in paragraphs or 16 bytes per line and address aligned to <kbd>10h</kbd>.</p>
<p>Assembly language instructions can be categorized as follows:</p>
<ul>
<li>Copying and accessing data instructions (for example, MOV, LEA, and MOVB)</li>
<li>Arithmetic instructions (for example, ADD, SUB, MUL, and DIV)</li>
<li>Binary logic instructions (for example, XOR, NOT, SHR, and ROL)</li>
<li>Flow control (for example, JMP, CALL, CMP, and INT)</li>
</ul>


            

            
        
    </div>



  
<div><h1 class="header-title">Copying data</h1>
                
            
            
                
<p>The MOV  instruction is used to move data. With this, data is moved either to or from a register or a memory address.</p>
<p><kbd>mov eax, 0xaabbccdd</kbd>  places the <kbd>0xaabbccdd</kbd> value in the <kbd>eax</kbd> register.</p>
<p><kbd>mov eax, edx</kbd> places the data value from the<kbd>edx</kbd> register to the <kbd>eax </kbd>register.</p>
<p class="mce-root"/>
<p>Let's take the following memory entries as an example:</p>
<pre>Address   Bytes<br/>00000060: 60 61 62 63 64 65 66 67 68 69 6A 6B 6C 6D 6E 6F <br/>00000070: 70 71 72 73 74 75 76 77 78 79 7A 7B 7C 7D 7E 7F <br/>00000080: 80 81 82 83 84 85 86 87 88 89 8A 8B 8C 8D 8E 8F <br/>00000090: 90 91 92 93 94 95 96 97 98 99 9A 9B 9C 9D 9E 9F </pre>
<p>Reading data may require using directives to help the assembler. We use <kbd>byte ptr</kbd>, <kbd>word ptr</kbd>, or <kbd>dword ptr</kbd>:</p>
<pre>; the following lines reads from memory<br/>mov al, byte ptr [00000071]       ; al = 71h<br/>mov cx, word ptr [00000071]       ; cx = 7271h<br/>mov edx, dword ptr [00000071]     ; edx = 74737271h<br/><br/>; the following lines writes to memory<br/>mov eax, 011223344h<br/>mov byte ptr [00000080], al       ; writes the value in al to address 00000080<br/>mov word ptr [00000081], ax       ; writes the value in ax to address 00000081<br/>mov dword ptr [00000083], eax     ; writes the value in eax to address 00000083</pre>
<p>The memory will look like this afterward:</p>
<pre>00000060: 60 61 62 63 64 65 66 67 68 69 6A 6B 6C 6D 6E 6F <br/>00000070: 70 71 72 73 74 75 76 77 78 79 7A 7B 7C 7D 7E 7F <br/>00000080: <strong>44 44 33</strong> <strong>44 33 22 11</strong> 87 88 89 8A 8B 8C 8D 8E 8F <br/>00000090: 90 91 92 93 94 95 96 97 98 99 9A 9B 9C 9D 9E 9F </pre>


            

            
        
    </div>



  
<div><h1 class="header-title">MOV and LEA</h1>
                
            
            
                
<div><p>MOV is used to read the value at a given address, while LEA (Load Effective Address) is used to get the address instead:</p>
</div>
<pre>mov eax, dword ptr [00000060]           ; stores 63626160h to eax<br/>mov eax, dword ptr [00000060]           ; stores 00000060h to eax</pre>
<p>So, how is the LEA instruction helpful if you can calculate the address by yourself? Let's take the following C code as an example:</p>
<pre>struct Test {<br/>    int x;<br/>    int y;<br/>} test[10];<br/><br/>int value;<br/>int *p;<br/><br/>// some code here that fills up the test[] array<br/><br/>for (int i=0; i&lt;10, i++) {<br/>    value = test[i].y;<br/>    p = &amp;test[i].y;<br/>}</pre>
<p>The C code starts with defining <kbd>test[10]</kbd>, an array of <kbd>struct Test</kbd>, which contains two integers, <kbd>x</kbd> and <kbd>y</kbd>. The <kbd>for-loop</kbd> statement takes the value of <kbd>y</kbd> and the pointer address of <kbd>y</kbd> in a <kbd>struct test</kbd> element. </p>
<p>Let's say the base of the test array is in EBX, the <kbd>for-loop</kbd> counter, <kbd>i</kbd>, is in <kbd>ECX</kbd>, the integers are <kbd>DWORD</kbd> values, and so <kbd>struct Test</kbd> will contain two <kbd>DWORD</kbd> values. Knowing that a <kbd>DWORD</kbd> has 4 bytes, the equivalent of <kbd>value = test[i].y;</kbd> in assembly language will look like <kbd>mov edx, [ebx+ecx*8+4]</kbd>. Then, the equivalent of <kbd>p = &amp;test[i].y;</kbd> in assembly language will look like <kbd>lea esi, [ebx+ecx*8+4]</kbd>. Indeed, without using LEA, the address can still be calculated with arithmetic instructions. However, calculating for the address could be done much more easily using LEA:</p>
<pre>; using MUL and ADD<br/>mov ecx, 1111h<br/>mov ebx, 2222h<br/>mov eax, 2              ; eax = 2<br/>mul ecx                 ; eax = 2222h<br/>add eax, ebx            ; eax = 4444h<br/>add eax, 1              ; eax = 4445h<br/><br/>; using LEA<br/>mov ecx, 1111h<br/>mov ebx, 2222h<br/>lea eax, [ecx*2+ebx+1]  ; eax = 4445h</pre>
<p>The preceding code shows that the six lines of code can be optimized to three lines using the LEA instruction.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Arithmetic operations</h1>
                
            
            
                
<p>x86 instructions are based on the CISC architecture, where arithmetical instructions such as ADD, SUB, MUL, and DIV have a more low-level set of operations behind them. Arithmetical instructions work with the help of a set of flags that indicates certain conditions to be met during the operation.</p>
<p class="mce-root"/>


            

            
        
    </div>



  
<div><h1 class="header-title">Addition and subtraction</h1>
                
            
            
                
<p>In addition (ADD) and subtraction (SUB), the OF, SF, and CF flags are affected. Let's see some examples of usage as instruction.</p>
<p><kbd>add eax, ecx</kbd> adds whatever value is in the <kbd>ecx</kbd> register to the value in <kbd>eax</kbd>. The results of adding <kbd>eax</kbd> and <kbd>ecx</kbd> goes into <kbd>eax</kbd>.</p>
<p>Let's take the following example to see how it sets the OF, SF and CF flags:</p>
<pre>mov ecx, 0x0fffffff<br/>mov ebx, 0x0fffffff<br/>add ecx, ebx</pre>
<p>The registers are DWORDs. The <kbd>ecx</kbd> and <kbd>ebx</kbd> registers were set with <kbd>0x0fffffff</kbd> (‭268,435,455‬), adding these results to <kbd>0x1ffffffe</kbd> (‭536,870,910‬). SF was not set, since the result did not touch the most significant bit (MSB). CF was not set because the result is still within the capacity of a <kbd>DWORD</kbd>. Assuming that both were signed numbers, the result is still within the capacity of a signed <kbd>DWORD</kbd> number:</p>
<pre>mov ecx, 0x7fffffff<br/>mov ebx, 0x7fffffff<br/>add ecx, ebx</pre>
<p>The result in <kbd>ecx</kbd> becomes <kbd>0xfffffffe</kbd> (<kbd>-2</kbd>). <kbd>CF = 0</kbd>; <kbd>SF = 1</kbd>; <kbd>OF = 1</kbd>. Assuming that both <kbd>ecx</kbd> and <kbd>ebx</kbd> were unsigned, the CF flag will not be set. Assuming that both <kbd>ecx</kbd> and <kbd>ebx</kbd> were signed numbers and both are positive numbers, the <kbd>OF</kbd> flag will be set. And since the most significant bit becomes <kbd>1</kbd>, the <kbd>SF</kbd> flag is also set.</p>
<p>Now, how about adding two negative numbers? Let's consider the following example:</p>
<pre>mov ecx, 0x80000000<br/>mov ebx, 0x80000000<br/>add ecx, ebx</pre>
<p>Basically, we're adding both <kbd>ecx</kbd> and <kbd>ebx</kbd>, containing <kbd>0x80000000</kbd> (-2,147,483,648), the result of which becomes zero (0). <kbd>CF = 1</kbd>; <kbd>SF = 0</kbd>; <kbd>OF = 1</kbd>. The SF flag was not set since the <kbd>MSB</kbd> of the result is 0. Adding both MSB of ecx and ebx will definitely exceed the capacity of a <kbd>DWORD</kbd> value. At the signed number perspective, the OF flag is also set, since adding both negative values exceeds the signed <kbd>DWORD</kbd> capacity.</p>
<p class="mce-root"/>
<p>Let's try the borrow concept in this next example:</p>
<pre>mov ecx, 0x7fffffff<br/>mov edx, 0x80000000<br/>sub ecx, edx</pre>
<p>What happens here is that we are subtracting <kbd>0x80000000</kbd> (-2,147,483,648) from <kbd>0x7fffffff</kbd> (‭2,147,483,647‬). In fact, what we are expecting is the sum of 2,147,483,648 and 2,147,483,647. The result in <kbd>ecx</kbd> becomes <kbd>0xffffffff</kbd> (-1). CF = 1; SF = 1; OF = 1. Remember that we are doing a subtraction operation, thereby causing CF to be set, due to borrowing. The same goes for the OF flag.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Increment and decrement instructions</h1>
                
            
            
                
<p>The INC instruction simply adds 1, while DEC subtracts 1. The following code results in <kbd>eax</kbd> becoming zero (0):</p>
<pre>mov eax, 0xffffffff<br/>inc eax</pre>
<p>The following code results in <kbd>eax</kbd> becoming <kbd>0xffffffff</kbd>:</p>
<pre>mov eax, 0<br/>dec eax</pre>


            

            
        
    </div>



  
<div><h1 class="header-title">Multiplication and division instructions</h1>
                
            
            
                
<p>MUL is used for multiplication and DIV for division. In multiplication, we expect that multiplying values would exceed the capacity of the register value. Hence the product is stored in AX, <kbd>DX:AX</kbd> or <kbd>EDX:EAX</kbd> (long or <kbd>QWORD</kbd>):</p>
<pre>mov eax, 0x80000000<br/>mov ecx, 2<br/>mul ecx</pre>
<p>The product stored in eax is zero (0), and <kbd>edx</kbd> now contains <kbd>0x00000001</kbd>. <kbd>SF =0</kbd>; <kbd>CF = 1</kbd>; and <kbd>OF = 1</kbd>.</p>
<p class="mce-root">For division, the dividend is placed in <kbd>AX</kbd>, <kbd>DX:AX</kbd>, or <kbd>EDX:EAX</kbd>, and after the division operation, the quotient is placed in <kbd>AL</kbd>, <kbd>AX</kbd>, or <kbd>EAX</kbd>. The remainder is stored in <kbd>AH</kbd>, <kbd>DX</kbd>, or <kbd>EDX</kbd>.</p>
<p class="mce-root"/>


            

            
        
    </div>



  
<div><h1 class="header-title">Other signed operations</h1>
                
            
            
                
<p class="mce-root"><strong>NEG</strong></p>
<p class="mce-root">This operation does a two's complement.</p>
<p class="mce-root">Consider the following as an example: <kbd>NEG EAX</kbd> or <kbd>NEG dword ptr [00403000]</kbd>.</p>
<p>If <kbd>EAX</kbd> were <kbd>01h</kbd>, it becomes <kbd>FFFFFFFFh</kbd> (-1).</p>
<p class="mce-root"><strong>MOVSX</strong></p>
<p class="mce-root">This moves a <kbd>BYTE</kbd> to WORD or WORD to <kbd>DWORD</kbd>, including the sign. It is a more flexible instruction than CBW, CWDE, CWD, since it accommodates operands.</p>
<p class="mce-root">Consider the following as an example: <kbd>MOVSX EAX, BX</kbd>.</p>
<p>If BX were <kbd>FFFFh</kbd> (-1) and the sign flag is set, EAX will be <kbd>FFFFFFFFh</kbd> (-1).</p>
<p class="mce-root"><strong>CBW</strong></p>
<p>Similar to MOVSX, it converts a <kbd>BYTE</kbd> into <kbd>WORD</kbd>, including the sign. The affected register is AL and AX. This is an instruction without any operands and is similar to MOVSX.  The effect turns the byte AL extend to its word counterpart, AX.   Such conversion is dentoed with a "-&gt;" sign.  For example,  <kbd>AL -&gt; AX</kbd> means we are extending the 8-bit number to a 16-bit without compromising the stored value.</p>
<p>If AL were <kbd>FFh</kbd> (-1), AX will be <kbd>FFFFh</kbd> (-1).</p>
<p class="mce-root"><strong>CWDE</strong></p>
<p>This is similar to CBW, but converts a <kbd>WORD</kbd> into <kbd>DWORD</kbd>. It affects <kbd>AX-&gt;EAX</kbd>.</p>
<p class="mce-root"><strong>CWD</strong></p>
<p>This is similar to CBW, but converts a <kbd>WORD</kbd> into <kbd>DWORD</kbd>. It affects <kbd>AX-&gt; DX:AX</kbd>.</p>
<p class="mce-root"><strong>IMUL/IDIV</strong></p>
<p>This performs MUL and DIV, but accepts operands from other registers or memory.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    </div>



  
<div><h1 class="header-title">Bitwise algebra</h1>
                
            
            
                
<p class="mce-root">Boolean algebra or bitwise operations are necessary in low-level programming since it can perform simple calculations by changing the bits of a number. It is commonly used in cryptography's obfuscation and decoding.</p>
<p class="mce-root"><strong>NOT</strong></p>
<p class="mce-root">This operation reverses the bits.</p>
<p class="mce-root">Consider the following as an example: <kbd>NOT AL</kbd></p>
<p class="mce-root">If AL equals <kbd>1010101b</kbd> (<kbd>55h</kbd>), it becomes <kbd>10101010b</kbd> (<kbd>AAh</kbd>).</p>
<p class="mce-root"><strong>AND</strong></p>
<p class="mce-root">This operation sets <kbd>bit</kbd> to <kbd>1</kbd> if both are <kbd>1</kbd>s, otherwise it sets <kbd>bit</kbd> to <kbd>0</kbd>.</p>
<p class="mce-root">Consider the following as an example: <kbd>AND AL, AH</kbd></p>
<p class="mce-root">If AL equals <kbd>10111010b</kbd> (<kbd>BAh</kbd>) and AH equals <kbd>11101101b</kbd> (<kbd>EDh</kbd>), AL becomes <kbd>10101000b</kbd> (<kbd>A8h</kbd>).</p>
<p class="mce-root"><strong>OR</strong></p>
<p class="mce-root">This operation sets <kbd>bit</kbd> to <kbd>0</kbd> if both are <kbd>0</kbd>s, else it sets <kbd>bit</kbd> to <kbd>1</kbd>.</p>
<p class="mce-root">Consider the following as an example: <kbd>OR AL, AH</kbd></p>
<p class="mce-root">If AL equals <kbd>10111010b</kbd> (<kbd>BAh</kbd>) and AH equals <kbd>11101100b</kbd> (<kbd>ECh</kbd>), AL becomes <kbd>11111110b</kbd> (<kbd>FEh</kbd>).</p>
<p class="mce-root"><strong>XOR</strong></p>
<p class="mce-root">This operation sets bit to <kbd>0</kbd> if both bits are equal, else it sets bit to <kbd>1</kbd>.</p>
<p class="mce-root">Consider the following as an example: <kbd>XOR EAX, EAX</kbd></p>
<p class="mce-root">XOR-ing the same value will become <kbd>0</kbd>. Thus <kbd>EAX</kbd> becomes <kbd>0</kbd>:</p>
<p class="mce-root"><kbd>XOR AH, AL</kbd></p>
<p class="mce-root">If AH were <kbd>100010b</kbd> (<kbd>22h</kbd>) and AL were <kbd>1101011b</kbd> (<kbd>6Bh</kbd>), AH becomes <kbd>1001001b</kbd> (<kbd>49h</kbd>).</p>
<p class="mce-root"/>
<p class="mce-root"><strong>SHL/SAL</strong></p>
<p class="mce-root">This operation shifts bits to the left.</p>
<p class="mce-root">Consider the following as an example: <kbd>SHL AL, 3</kbd></p>
<p class="mce-root">If <kbd>AL</kbd> were <kbd>11011101b</kbd> (<kbd>DDh</kbd>), shifting it to the left by <kbd>3</kbd> makes AL equal to <kbd>11101000b</kbd> (<kbd>E8h</kbd>).</p>
<p class="mce-root"><strong>SHR/SAR</strong></p>
<p class="mce-root">This operation shifts bits to the right.</p>
<p class="mce-root">Consider the following as an example: <kbd>SHR AL, 3</kbd></p>
<p class="mce-root">If <kbd>AL</kbd> were <kbd>11011101b</kbd> (<kbd>DDh</kbd>), shifting it to the right by <kbd>3</kbd> makes AL equal to <kbd>011011b</kbd> (<kbd>1Bh</kbd>).</p>
<p class="mce-root"><strong>ROL</strong></p>
<p class="mce-root">This operation rotates bits to the left.</p>
<p class="mce-root">Consider the following as an example: <kbd>ROL AL, 3</kbd></p>
<p class="mce-root">if <kbd>AL</kbd> were <kbd>11011101b</kbd> (<kbd>DDh</kbd>), rotating it to the left by <kbd>3</kbd> makes AL equal to <kbd>11101110b</kbd> (<kbd>EEh</kbd>).</p>
<p class="mce-root"><strong>ROR</strong></p>
<p class="mce-root">This operation rotates bits to the right.</p>
<p class="mce-root">Consider the following as an example: <kbd>ROR AL, 3</kbd></p>
<p class="mce-root">If <kbd>AL</kbd> were <kbd>11011101b</kbd> (<kbd>DDh</kbd>), rotating it to the right by <kbd>3</kbd> makes AL equal to <kbd>10111011b</kbd> (<kbd>BBh</kbd>).</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    </div>



  
<div><h1 class="header-title">Control flow</h1>
                
            
            
                
<p>The beauty of a program is that we can carry out a number of different behaviors based on condition and state. For example, we can make a certain task repeat until a counter reaches a defined maximum. In C programming, the program's flow is controlled by instructions such as the <kbd>if-then-else</kbd> and <kbd>for-loop</kbd> statements. The following are common instructions used in assembly language, in conjunction with program control flow. The affected register in this is the index pointer IP/EIP, which holds the current address where the next instruction to execute is located.</p>
<pre>JMP</pre>
<p>Short for jump, this means that the operand is an address that it will go to. It sets the EIP to the next instruction line. There are two main variations for the address: direct and indirect.</p>
<p>A <kbd>JMP</kbd> using a direct address would literally jump to the given address. Consider as an example: <kbd>JMP  00401000</kbd>. This will set the <kbd>EIP</kbd> to <kbd>00401000h</kbd>.</p>
<p>A <kbd>JMP</kbd> using an indirect address would jump to an address that can only be known when the jump is executed. The address has to be retrieved or calculated somehow prior to the <kbd>JMP</kbd> instruction. Here are some examples:</p>
<pre>jmp   eax<br/>jmp   dword ptr [00403000]<br/>jmp   dword ptr [eax+edx]<br/>jmp   dowrd ptr [eax]<br/>jmp   dword ptr [ebx*4+eax]</pre>
<p><strong>CALL and RET</strong></p>
<p>Similar to <kbd>JMP</kbd>, this goes to the address stated in the operand, but stores the address of the next instruction to the stack after the CALL instruction. The address is stored in the stack and will be used by the <kbd>RET</kbd> instruction later to point <kbd>EIP</kbd> back to it. For example, consider the following:</p>
<pre class="mce-root">Address            Instruction<br/>00401000           CALL 00401100<br/>00401005           MOV ECX, EAX<br/>00401007<br/>...<br/>00401100           MOV EAX, F00BF00B<br/>00401105           RET</pre>
<p class="mce-root"/>
<p>When the CALL happens at the address <kbd>00401000</kbd>, the top of the stack will contain the value <kbd>00401005h</kbd>, which will be the return address. The code passes it to the instruction at the address <kbd>00401100</kbd>, where <kbd>EAX</kbd> is set to <kbd>F00bF00Bh</kbd>. Then the <kbd>RET</kbd> instruction retrieves the return address from the top of the stack and sets the EIP.  A subroutine or procedure is the term used for the lines of instructions from the call.</p>
<p>The <kbd>RET</kbd> instruction can optionally have an operand. The operand is the number of stack <kbd>DWORDs</kbd> it will release before retrieving the return address. This is useful when the stack is used within the subroutine as it serves as a cleanup of the used stack.</p>
<div><p><strong>Conditional jumps</strong></p>
</div>
<p>These are jumps that depend on the flags and the counter register:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td class="CDPAlignCenter CDPAlign"><strong>Instruction</strong></td>
<td class="CDPAlignCenter CDPAlign"><strong>Flags</strong></td>
<td class="CDPAlignCenter CDPAlign"><strong>Description</strong></td>
</tr>
<tr>
<td><kbd>JZ/JE</kbd></td>
<td>ZF = 1</td>
<td>Jump if zero/Jump if equal</td>
</tr>
<tr>
<td><kbd>JNZ/JNE</kbd></td>
<td>ZF = 0</td>
<td>Jump if not zero/Jump if not equal</td>
</tr>
<tr>
<td><kbd>JS</kbd></td>
<td>SF = 1</td>
<td>Jump if sign</td>
</tr>
<tr>
<td><kbd>JNS</kbd></td>
<td>SF = 0</td>
<td>Jump if not sign</td>
</tr>
<tr>
<td><kbd>JC/JB/JNAE</kbd></td>
<td>CF = 1</td>
<td>Jump if carry/Jump if below/Jump if not above or equal</td>
</tr>
<tr>
<td><kbd>JNC/JNB/JAE</kbd></td>
<td>CF = 0</td>
<td>Jump if not carry/jump if not below/Jump if above or equal</td>
</tr>
<tr>
<td><kbd>JO</kbd></td>
<td>OF = 1</td>
<td>Jump if overflow</td>
</tr>
<tr>
<td><kbd>JNO</kbd></td>
<td>OF = 0</td>
<td>Jump if not overflow</td>
</tr>
<tr>
<td><kbd>JA/JNBE</kbd></td>
<td>CF = 0 and ZF = 0</td>
<td>Jump if above/Jump if not below or equal</td>
</tr>
<tr>
<td><kbd>JNA/JBE</kbd></td>
<td>CF = 1 or ZF = 1</td>
<td>Jump if not above/Jump if below or equal</td>
</tr>
<tr>
<td><kbd>JG/JNLE</kbd></td>
<td>ZF = 0 and SF = OF</td>
<td>Jump if greater/Jump if not less or equal</td>
</tr>
<tr>
<td><kbd>JNG/JLE</kbd></td>
<td>ZF = 1 or SF != OF</td>
<td>Jump if not greater/Jump if less or equal</td>
</tr>
<tr>
<td><kbd>JL/JNGE</kbd></td>
<td>SF != OF</td>
<td>Jump if less/Jump if not greater or equal</td>
</tr>
<tr>
<td><kbd>JNL/JGE</kbd></td>
<td>SF = OF</td>
<td>Jump if not less/Jump if greater or equal</td>
</tr>
<tr>
<td><kbd>JP/JPE</kbd></td>
<td>PF = 1</td>
<td>Jump if parity/Jump if parity is even</td>
</tr>
<tr>
<td><kbd>JNP/JPO</kbd></td>
<td>PF = 0</td>
<td>Jump if not parity/Jump if parity is odd</td>
</tr>
<tr>
<td><kbd>JCXZ</kbd></td>
<td>CX = 0</td>
<td>Jump if CX is zero.</td>
</tr>
<tr>
<td><kbd>JECXZ</kbd></td>
<td>ECX = 0</td>
<td>Jump if ECX is zero.</td>
</tr>
<tr>
<td><kbd>LOOP</kbd></td>
<td>ECX &gt; 0</td>
<td>Jump if ECX is not zero. Decrements ECX.</td>
</tr>
<tr>
<td><kbd>LOOPE</kbd></td>
<td>ECX &gt; 0 and ZF = 1</td>
<td>Jump if ECX is not zero and zero flag is set. Decrements ECX.</td>
</tr>
<tr>
<td><kbd>LOOPNE</kbd></td>
<td>ECX &gt; 0 and ZF = 0</td>
<td>Jump if ECX is not zero and zero flag is not set. Decrements ECX.</td>
</tr>
</tbody>
</table>
<p><strong>Flagging instructions</strong></p>
<p class="mce-root">Besides the arithmetic, bit-wise operations, interrupts, and return values from functions, these instructions are also able to set flags.</p>
<p><strong>CMP</strong> performs a SUB instruction on the first and second operands, but does not modify the registers or the immediate value. It only affects the flags.</p>
<p><strong>TEST</strong> performs an AND instruction on the first and second operands, but does not modify the registers or the immediate value. It only affects the flags.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Stack manipulation</h1>
                
            
            
                
<p class="mce-root">The stack is a memory space where data is temporarily stored. Adding and removing data in the stack is in a first-in-last-out method. Subroutines compiled from programs in C initially allocate space in the stack, called a stack frame, for its uninitialized variables. The address of the top of the stack is stored in the ESP register:</p>
<div><img src="img/2c2c1b04-c690-41f9-972c-bdc59768bcbf.png" style="width:33.92em;height:20.75em;" width="696" height="425"/></div>
<p>The stack is controlled by two common instructions: <kbd>PUSH</kbd> and <kbd>POP</kbd>.</p>
<p><strong>PUSH</strong> decreases the top-of-stack address by a <kbd>DWORD</kbd> size, for a 32-bit address space, then stores the value from its operand.</p>
<p class="mce-root"/>
<p>Consider the following as an example: <kbd>PUSH 1</kbd></p>
<p>If the top of the stack, stored in ESP, is at address <kbd>002FFFFCh</kbd>, then the ESP becomes <kbd>002FFFF8h</kbd> and stores <kbd>1</kbd> at the new ESP address.</p>
<p><strong>POP</strong> retrieves the value from the top of the stack (ESP) then stores it to the register or memory space indicated in the operand. Then ESP is increased by a <kbd>DWORD</kbd> size. </p>
<p>Consider the following as an example: <kbd>POP EAX</kbd></p>
<p>If the address of the top of the stack, stored in ESP, is at address <kbd>002FFFF8h</kbd>, and the stored <kbd>DWORD</kbd> value at the top of the stack is <kbd>0xDEADBEEF</kbd>, then <kbd>0xDEADBEEF</kbd> will be stored in <kbd>EAX</kbd>, while ESP becomes <kbd>002FFFFCh</kbd>.</p>
<p><strong>PUSHA/PUSHAD</strong> both push all the general purpose registers to the stack in this order (for 32-bit builds): <kbd>EAX</kbd>, <kbd>ECX</kbd>, <kbd>EDX</kbd>, <kbd>EBX</kbd>, <kbd>EBP</kbd>, <kbd>ESP</kbd>, <kbd>EBP</kbd>, <kbd>ESI</kbd>, and <kbd>EDI</kbd>. <kbd>PUSHA</kbd> is intended for 16-bit operands, while <kbd>PUSHAD</kbd> is for 32-bit operands. However, both may be synonymous to each other, adapting to the current operand size.</p>
<p><strong>POPA/POPAD</strong> both pop all the general purpose registers from the stack and retrieved in a reverse order as stored by <kbd>PUSHA</kbd>/<kbd>PUSHAD</kbd>.</p>
<p><strong>PUSHF</strong> pushes the <kbd>EFLAGS</kbd> to stack.</p>
<p><strong>POPF</strong> pops the <kbd>EFLAGS</kbd> from stack.</p>
<p><strong>ENTER</strong> is commonly used at the start of a subroutine. It is used to create a stack frame for the subroutine. Internally, <kbd>ENTER 8,0</kbd> may roughly be equivalent to the following:</p>
<pre>push ebp                      ; save the current value of ebp<br/>mov ebp, esp                  ; stores current stack to ebp<br/>add esp, 8                    ; create a stack frame with a size of 8 bytes</pre>
<p><kbd>LEAVE</kbd><strong> </strong>is used to reverse what the <kbd>ENTER</kbd> instruction did eventually destroying the stack frame created.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Tools – builder and debugger</h1>
                
            
            
                
<p>Before we proceed with more instructions, it would be best to try actually programming with assembly language. The tools we will need are a text editor, the assembly code builder, and the debugger.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Popular assemblers</h1>
                
            
            
                
<div><p>All programming languages need to be built to become an executable on the system platform that the program was built for. Unless you want to enter each opcode byte in a binary file, developers have made tools to convert that source code to an executable that contains code that the machine can understand. Let's take a look at some of the most popular assembly language builders today.</p>
</div>


            

            
        
    </div>



  
<div><h1 class="header-title">MASM</h1>
                
            
            
                
<p>Also known as Microsoft Macro Assembler, MASM has been around for more than 30 years. It is maintained by Microsoft and is part of the Visual Studio product. It was developed for compiling x86 source code to executable code. </p>
<p>Compiling takes two steps: compiling the source into an object file, then linking all necessary modules required by the object file into a single executable.</p>
<div><img src="img/05a5158f-4a56-4937-b53b-d8679d4349f3.png" style="width:40.92em;height:32.08em;" width="570" height="447"/></div>
<p>The MASM package comes along with a text editor that has the menu containing the compiler and linker to build the source as an executable. This comes very handy as there is no need to go to the command line to run the compiler and linker to build the executable. A simple "<kbd>Console Build All</kbd>" command on the following source generates an executable that can be run in the command terminal:</p>
<div><img style="font-size: 1em;" src="img/7f6bf1c8-9526-49ca-8ba6-f9fa3530185f.png" width="696" height="518"/></div>
<p>MASM can be downloaded from <a href="http://www.masm32.com/">http://www.masm32.com/</a>.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">NASM</h1>
                
            
            
                
<p><strong>NASM</strong> is the abbreviation of <strong>Netwide Assembler</strong>. NASM is very similar to MASM with slight differences between its syntax, directives, and variable declaration. A great thing about NASM is that sectioning of code and data is easily identified:</p>
<div><img src="img/5b418ac9-d780-473b-839b-f2da606d8f7c.png" style="width:24.33em;height:15.42em;" width="313" height="198"/></div>
<p>Both MASM and NASM also require compiling and linking to build the executable:</p>
<div><img src="img/3e1eb06b-897f-465c-bb71-92cd4a60f41b.png" style="width:33.83em;height:19.42em;" width="455" height="261"/></div>
<p>However, unlike MASM, the installer package does not have its own editor. NASM is very popular in the Linux community due to its development as opensource software. The package contains only the compiler for the object file; you'll have to download a GCC  compiler to generate the executable.</p>
<p>The official website for downloading NASM is at <a href="https://www.nasm.us/">https://www.nasm.us/</a>. For Windows, MinGW (<a href="http://www.mingw.org/">http://www.mingw.org/</a>) can be used to generate the executable.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">FASM</h1>
                
            
            
                
<p>FASM, or Flat Assembler, is similar MASM and NASM. Like MASM, it has its own source editor. Like NASM, the sections are easily identifiable and configured, and the software comes in flavors for both Windows and Linux:</p>
<div><img src="img/bb02f798-7ebf-42d1-9582-61ae313a338d.png" style="width:35.42em;height:35.08em;" width="465" height="461"/></div>
<p>FASM can be downloaded from <a href="http://flatassembler.net/">http://flatassembler.net/</a>.</p>
<p>In our assembly language programming, we will use FASM, since we can use its editor in both Windows and Linux.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">x86 Debuggers</h1>
                
            
            
                
<p>Debuggers are program developers' tools for tracing through their code.  These tools are used to validate that the program  follows the expected behavior.  With a debugger, we can trace our code line per line.  We get to see every instruction in action as it make changes to the registers and data stored in the memory.  In reversing, debuggers are used to analyze programs at its low-level. With what we learned about assembly language, the target compiled program, and a debugger, we are able to do reverse engineering.   </p>
<p>Besides the tools introduced in this book,  there are a lot of tools available in the internet that may have more or less features.  The point is that reverse engineering rely on the tools and we need to keep ourselves updated with the latest tool. Feel free to download other tools that you want to explore and see which one makes your reversing feel more comfortable. </p>
<p> </p>


            

            
        
    </div>



  
<div><h1 class="header-title">WinDbg</h1>
                
            
            
                
<p>Developed by Microsoft to perform debugging on Microsoft Windows, <kbd>WinDbg</kbd> is a powerful tool that can debug in user and kernel mode. It can load memory dumps and crash dumps caused by errors flagged by Windows itself. In kernel mode, it can be used to remotely debug a device driver or a Windows operating system. It can load symbol files linked to the program that aid the developer or analyst in identifying the proper library function format and other information.</p>
<p class="mce-root"/>
<p><kbd>WinDbg</kbd> has a graphical user interface, and by default, shows a command box where you can type in and enter commands. You can add a set of information windows and dock them. It can show the disassembly, registers and flags, the stack (using the memory dump window), and a memory dump of whichever address entered:</p>
<div><img src="img/5dbd1ab2-e79e-4484-8ad7-e06a7c380859.png" width="909" height="658"/></div>
<p><kbd>Windbg</kbd> can be downloaded from <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/.">https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/.</a></p>
<p class="mce-root"/>


            

            
        
    </div>



  
<div><h1 class="header-title">Ollydebug</h1>
                
            
            
                
<p>This is the most popular debugger on the x86 32-bit Windows platform due to its lightweight package file size. Its default interface shows the important information needed by a reverse engineer: a disassembly view where tracing happens; registers and flags panes; and the stack and memory views.</p>
<div><img src="img/e2ddfff3-b669-4358-ad27-c87246f0c788.png" width="858" height="592"/></div>
<p>OllyDebug can be downloaded from <a href="http://www.ollydbg.de/">http://www.ollydbg.de/</a>.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    </div>



  
<div><h1 class="header-title">x64dbg</h1>
                
            
            
                
<p>This debugger is most recommended as the developers keep this up-to-date, working with the community. It also supports both 64- and 32-bit Windows platforms with a lot of useful plugins available. It has a similar interface as Ollydebug.</p>
<div><img src="img/8ef58c36-fd12-42e1-bd98-7400c929b7e8.png" width="870" height="632"/></div>
<p><kbd>x64dbg</kbd> can be downloaded from <a href="https://x64dbg.com/">https://x64dbg.com/</a>.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Hello World</h1>
                
            
            
                
<p>We are going to use <kbd>FASM</kbd> for building our first assembly language program. And we will debug the executable using <kbd>x64dbg</kbd>.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Installation of FASM</h1>
                
            
            
                
<p>Using our Windows setup, download FASM from <a href="http://flatassembler.net/">http://flatassembler.net/</a>, <a href="http://flatassembler.net/">then extract FASM into a folder of your choice:</a></p>
<div><img src="img/874ec904-69c3-461e-bc2b-6fb260e5f8d8.png" style="width:15.08em;height:20.08em;" width="183" height="244"/></div>
<p>Run <kbd>FASMW.EXE</kbd> to bring up the <kbd>FASM</kbd> GUI.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">It works!</h1>
                
            
            
                
<div><p>In your text editor, write down the following code, or you can simply do a Git clone of the data at <a href="https://github.com/PacktPublishing/Mastering-Reverse-Engineering/blob/master/ch3/fasmhello.asm">https://github.com/PacktPublishing/Mastering-Reverse-Engineering/blob/master/ch3/fasmhello.asm</a>.<a href="https://github.com/PacktPublishing/Mastering-Reverse-Engineering/blob/master/ch3/fasmhello.asm"/></p>
</div>
<div><pre>format PE CONSOLE<br/>entry start<br/><br/>include '%include%\win32a.inc' <br/><br/>section '.data' data readable writeable <br/>  message db 'Hello World!',0<br/>  msgformat db '%s',0<br/><br/>section '.code' code readable executable <br/>  start:<br/>    push message<br/>    push msgformat<br/>    call [printf]<br/>    push 0<br/>    call [ExitProcess]<br/><br/>section '.idata' import data readable writeable <br/>  library kernel32, 'kernel32.dll', \<br/>          msvcrt, 'msvcrt.dll'<br/>  import kernel32, ExitProcess, 'ExitProcess'<br/>  import msvcrt, printf, 'printf'</pre></div>
<p>Save it by clicking on File-&gt;Save as..., then click on Run-&gt;Compile:</p>
<div><img src="img/fd0bc3e2-c137-493b-923b-2fe735592745.png" style="width:34.92em;height:34.67em;" width="461" height="457"/></div>
<p>The executable file will be located where the source was saved:</p>
<div><img src="img/033636a3-403a-4022-a97f-719688e1af09.png" style="width:21.33em;height:12.00em;" width="277" height="156"/></div>
<p>If "<kbd>Hello World!</kbd>" did not show up, one thing to note is that this is a console program. You'll have to open up a command terminal and run the executable from there:</p>
<div><img src="img/789c36b3-17b6-4b7c-842e-f46d71f4f63d.png" width="668" height="331"/></div>


            

            
        
    </div>



  
<div><h1 class="header-title">Dealing with common errors when building</h1>
                
            
            
                
<p class="mce-root"><strong>Write Failed Error</strong> – This means that the builder or compiler is not able to write to the output file. It is possible that the executable file it was going to build to is still running. Try looking for the program that was run previously and terminate it. You can also terminate it from the process list or Task Manager.</p>
<p><strong>Unexpected Characters</strong> – Check for the syntax at the indicated line. Sometimes the included files also need to be updated because of changing syntax on recent versions of the builder.</p>
<p><strong>Invalid argument</strong> – Check for the syntax at the indicated line. There might be missing parameters of a definition or a declaration.</p>
<p><strong>Illegal instruction</strong> – Check for the syntax at the indicated line. If you are sure that the instruction is valid, it might be that the builder version doesn't match where the instruction was valid. While updating the builder to the most recent version, also update the source to comply with the recent version.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Dissecting the program </h1>
                
            
            
                
<p>Now that we have built our program and got it working, let's discuss what the program contains and is intended for. </p>
<p>A program is mainly structured with a code section and a data section. The code section, as its name states, is where program codes are placed. On the other hand, the data section is where the data, such as text strings, used by the program code is located. There are requirements before a program can be compiled. These requirements define how the program will be built. For example, we can tell the compiler to build this program as a Windows executable, instead of a Linux executable. We can also tell the compiler which line in the code should the program start running. An example of a program structure is given here:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/9c1e0b16-c1e2-4849-b2c3-5bbb2b908af0.png" style="width:9.75em;height:27.75em;" width="195" height="555"/></p>
<p>We can also define the external library functions that the program will be using. This list is described under a separate sections called the Import section. There are various sections that can be supported by a compiler. An example of these extended sections include the resource section, which contains data such as icons and images.</p>
<p>With the a basic picture of a what a program is structured, let see how our program was written. The first line, <kbd>format PE CONSOLE</kbd>, indicates that the program will be compiled as a Windows PE executable file and built to run on the console, better known in Windows as Command Prompt.</p>
<p>The next line, <kbd>entry start</kbd>, means that the program will start running code located at the <kbd>start</kbd> label. The name of the label can be changed as desired by the programmer. The next line, <kbd>include '%include%\win32a.inc'</kbd>, will add declarations from the FASM library file <kbd>win32a.inc</kbd>. The declared functions expected are for calling the <kbd>printf</kbd> and <kbd>ExitProcess</kbd> API functions discussed in the <kbd>idata</kbd> section.</p>
<p class="mce-root"/>
<p>There are three sections built in this program: the <kbd>data</kbd>, <kbd>code</kbd>, and <kbd>idata</kbd> sections. The section names here are labeled as <kbd>.data</kbd>, <kbd>.code</kbd>, and <kbd>.idata</kbd>. The permissions for each section are also indicated as either <kbd>readable</kbd>, <kbd>writeable</kbd>, and <kbd>executable</kbd>. The <kbd>data</kbd> section is where integers and text strings are placed and listed using the define byte (<kbd>db</kbd>) instruction. The <kbd>code</kbd> section is where lines of instruction code are executed. The <kbd>idata</kbd> section is where imported API functions are declared.</p>
<p>On the next line, we see that the data section is defined as a <kbd>writeable</kbd> section:</p>
<pre>section '.data' data readable writeable</pre>
<p>The program's <kbd>.data</kbd> section contains two constant variables, <kbd>message</kbd> and <kbd>msgformat</kbd>. Both text strings are <kbd>ASCIIZ</kbd> (<kbd>ASCII-Zero</kbd>) strings, which means that they are terminated with a zero (0) byte. These variables are defined with the <kbd>db</kbd> instruction:</p>
<pre> message db 'Hello World!',0<br/> msgformat db '%s',0</pre>
<p>The next line defines the code section. It is defined with read and execute permissions:</p>
<pre>section '.code' code readable executable</pre>
<p>It is in the <kbd>.code</kbd> section where the <kbd>start:</kbd> label is and where our code is. Label names are prefixed with a colon character.</p>
<p>In C programming, <kbd>printf</kbd> is a function commonly used to print out messages to the console using the C syntax, as follows:</p>
<p><kbd>int printf ( const char * format, ... );</kbd></p>
<p>The first parameter is the message containing format specifiers. The second parameter contains the actual data that fills up the format specifiers. In assembly language perspective, the <kbd>printf</kbd> function is an API function that is in the <kbd>msvcrt</kbd> library. An API function is set up by placing the arguments in the memory stack space before calling a function. If your program is built in C, a function that requires 3 parameters (for example, <kbd>myfunction(arg1, arg2, arg3)</kbd>) will have the following as an equivalent in assembly language:</p>
<pre>push &lt;arg3&gt;<br/>push &lt;arg2&gt;<br/>push &lt;arg1&gt;<br/>call myfunction</pre>
<p class="mce-root"/>
<p>For a 32-bit address space, the <kbd>push</kbd> instruction is used to write a <kbd>DWORD</kbd> (32 bits) of data on the top of the stack. The address of the top of the stack is stored in the ESP register. When a <kbd>push</kbd> instruction is executed, the ESP decreases by 4. If the argument is a text string or a data buffer, the address is push-ed to the stack. If the argument is a number value, the value is directly push-ed to the stack.</p>
<p>Following the same API calling structure, with two arguments, our program called <kbd>printf</kbd> in this manner:</p>
<pre> push message<br/> push msgformat<br/> call [printf]</pre>
<p>In the data section, the addresses, labeled as <kbd>message</kbd> and <kbd>msgformat</kbd>, are pushed to the stack as a setup before calling the <kbd>printf</kbd> function. Addresses are usually placed in square brackets, <kbd>[]</kbd>. As discussed previously, the value at the address is used instead. The <kbd>printf</kbd> is actually a label that is the local address in the program declared in the <kbd>.idata</kbd> section. <kbd>[printf]</kbd> then means that we are using the address of the <kbd>printf</kbd> API function from the <kbd>msvcrt</kbd> library. Thus, <kbd>call [printf]</kbd> will execute the <kbd>printf</kbd> function from the <kbd>msvcrt</kbd> library.</p>
<p>The same goes for <kbd>ExitProcess</kbd>. <kbd>ExitProcess</kbd> is a <kbd>kernel32</kbd> function that terminates the running process. It requires a single parameter, which is the exit code. An exit code of 0 means that the program will terminate without any errors:</p>
<pre> push 0 <br/> call [ExitProcess]</pre>
<p>In C syntax, this code is equivalent to <kbd>ExitProcess(0)</kbd>, which terminates the program with a success result defined with zero.</p>
<p>The program's <kbd>.idata</kbd> section contains external functions and is set with read and write permissions:</p>
<pre>section '.idata' import data readable writeable</pre>
<p>In the following code snippet, there are two portions. The first part indicates which library files the functions are located in. The <kbd>library</kbd> command is used to set the libraries required, and uses the syntax <kbd>library &lt;library name&gt;, &lt;library file&gt;</kbd>. A backslash, <kbd>\</kbd>, is placed to indicate that the next line is a continuation of the current line:</p>
<pre> library kernel32, 'kernel32.dll', \<br/>           msvcrt, 'msvcrt.dll'</pre>
<p>Once the libraries are declared, specific API functions are indicated using the <kbd>import</kbd> command. The syntax is <kbd>import &lt;library name&gt;, &lt;function name&gt;, &lt;function name in library file&gt;</kbd>. Two external API functions are imported here, <em>kernel32</em>'s <em>ExitProcess</em> and <em>msvcrt</em>'s <em>printf:</em></p>
<pre> import kernel32, ExitProcess, 'ExitProcess'<br/> import msvcrt, printf, 'printf'</pre>
<p>A annotated version of the program can be found at <a href="https://github.com/PacktPublishing/Mastering-Reverse-Engineering/blob/master/ch3/FASM%20commented.txt">https://github.com/PacktPublishing/Mastering-Reverse-Engineering/blob/master/ch3/FASM%20commented.txt</a></p>
<p>The library of API functions can be found in the MSDN library (<a href="https://msdn.microsoft.com/en-us/library">https://msdn.microsoft.com/en-us/library</a>), which also has an offline version packaged in the Visual Studio installer. It contains detailed information about what the API function is for and how to use it. The online version looks like the following:</p>
<div><img src="img/bb928665-6664-4b30-83ca-ee18a0962334.png" width="931" height="672"/></div>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    </div>



  
<div><h1 class="header-title">After Hello</h1>
                
            
            
                
<p>We encountered an external call to the <kbd>printf</kbd> and <kbd>ExitProcess</kbd> API functions. These specific functions were developed for Windows as a means of communication between the user-mode and the kernel-mode. Generally, for most operating systems, the kernel is responsible for literally displaying the output on the monitor, writing files to the disk, reading keyboard strokes, transmitting data to USB ports, sending data to the printer, transmitting data to the network wire, and so forth. In essence, everything that has something to do with hardware has to go through the kernel. Our program, however, is in the user-mode, and we use the APIs to tell the kernel to do stuff for us.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Calling APIs</h1>
                
            
            
                
<div><div><p>Calling APIs within our program just requires us to define the library file where the API function is, and the API name itself. As we did with our Hello World program, we import the API function by setting it up in the import section:</p>
<pre>section '.idata' import data readable writeable     ; import section has read and write permissions<br/>  library kernel32, 'kernel32.dll', \               ; functions came from kernel32 and msvcrt dlls<br/>          msvcrt, 'msvcrt.dll'<br/>  import kernel32, ExitProcess, 'ExitProcess'       ; program will use ExitProcess and printf functions<br/>  import msvcrt, printf, 'printf'</pre>
<p>And then we call the APIs with a CALL instruction, as follows:</p>
<pre>    call [printf]<br/>    call [ExitProcess]</pre></div>
</div>
<p class="mce-root"/>


            

            
        
    </div>



  
<div><h1 class="header-title">Common Windows API libraries</h1>
                
            
            
                
<p><strong>KERNEL32</strong> contains base functions of Windows that are responsible for file I/O operations and memory management, including processes and threads management. Some functions are helpers for calling more native APIs in the NTDLL library.</p>
<p><strong>USER32</strong> contains functions that deal with the display and graphical interface, such as program windows, menu, and icons. It also contains functions that controls window messages.</p>
<p class="mce-root"/>
<p><strong>ADVAPI32</strong> contains functions that has to do with the Windows registry.</p>
<p><strong>MSVCRT</strong> contains standard C library functions from Microsoft Visual C++ runtime, such as printf, scanf, malloc, strlen, fopen, and getch.</p>
<p><strong>WS2_32</strong>, <strong>WININET</strong>, <strong>URLMON</strong>, and <strong>NETAPI32</strong> are libraries that contain functions that have to do with networking and internet communication.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Short list of common API functions</h1>
                
            
            
                
<p>The API functions can be categorized based on their purposes. A complete list can be found at the MSDN Library, but the most common ones are listed here:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td><strong>Purpose</strong></td>
<td>
<p class="mce-root CDPAlignCenter CDPAlign"><strong>API functions</strong></p>
</td>
</tr>
<tr>
<td><strong>Console output</strong></td>
<td><kbd>KERNEL32!GetStdHandle, MSVCRT!printf</kbd></td>
</tr>
<tr>
<td><strong>File handling</strong></td>
<td><kbd>KERNEL32!ReadFile, KERNEL32!WriteFile, KERNEL32!CreateFile</kbd></td>
</tr>
<tr>
<td><strong>Memory management</strong></td>
<td><kbd>KERNEL32!VirtualAlloc, KERNEL32!VirtualProtect, MSVCRT!malloc</kbd></td>
</tr>
<tr>
<td><strong>Process and threads</strong></td>
<td><kbd>KERNEL32!ExitProcess, KERNEL32!CreateProcess, KERNEL32!CreateThread, SHELL32!ShellExecute</kbd></td>
</tr>
<tr>
<td><strong>Window management</strong></td>
<td>
<p><kbd>USER32!MessageBoxA, USER32!CreateWindowExA, </kbd></p>
<p><kbd>USER32!RegisterWindowMessageW</kbd></p>
</td>
</tr>
<tr>
<td><strong>Strings</strong></td>
<td><kbd>MSVCRT!strlen, MSVCRT!printf</kbd></td>
</tr>
<tr>
<td><strong>Network communication</strong></td>
<td>
<p><kbd>WININET!InternetAttemptConnect, WS2_32!socket, WS2_32!connect, URLMON!URLDownloadToFile</kbd></p>
</td>
</tr>
<tr>
<td><strong>Cryptography</strong></td>
<td><kbd>CryptDecrypt, CryptEncrypt</kbd></td>
</tr>
<tr>
<td><strong>Registry</strong></td>
<td><kbd>RegDeleteKey, RegCreateKey, RegQueryValueExW, RegSetValueExW</kbd></td>
</tr>
</tbody>
</table>
<p> </p>


            

            
        
    </div>



  
<div><h1 class="header-title">Debugging</h1>
                
            
            
                
<p>At certain points, our program may produce unpredictable errors or invalid output. In that case, we need to trace what went wrong, by debugging each line of code. But before that, there are some general debug commands we need to know.</p>
<p class="mce-root"/>
<p class="mce-root">Single-stepping a program means debugging per line of code. There are two modes to single step: step into and step over. During debugging, when the line being debugged is a CALL instruction, single-step debugging continues in the subroutine when a <strong>step into</strong> mode is used. The <strong>step over</strong> mode, however doesn't enter the subroutine, but rather lets the subroutine finish up running and the single step continues on the line after the CALL instruction. See the following comparison:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td>Step into</td>
<td>Step over</td>
</tr>
<tr>
<td>
<pre>    CALL 00401000 ; &lt;-- STEP INTO SUBROUTINE<br/>    MOV  EBX, EAX<br/>    ...<br/>00401000:  <br/>    MOV EAX, 37173 ; &lt;- DEBUG POINTER GOES HERE<br/>    RET<br/>           </pre></td>
<td>
<pre>    CALL 00401000 ; &lt;-- STEP OVER SUBROUTINE<br/>    MOV  EBX, EAX ; &lt;- DEBUG POINTER GOES HERE<br/>    ...<br/>00401000:  <br/>    MOV EAX, 37173<br/>    RET<br/><br/></pre></td>
</tr>
</tbody>
</table>
<p> </p>
<p>A <strong>run</strong> or <strong>continue</strong> makes the debugger execute instructions continuously until the program terminates, encounters an error, or until it encounters a manually set breakpoint.</p>
<p>Placing a <strong>breakpoint</strong> is a way to enable to the debugger to interrupt a code that was set to freely run. For example, if I placed a breakpoint at address 0040200A in the following code, and let the debugger automatically run every instruction starting from 00402000, the debugger stops at address 0040200A and leaves the user to continue doing single steps or run:</p>
<pre>00402000  push 0040100D<br/>00402005  push 0040100D<br/>0040200A  call dword ptr [printf]  ; &lt;-- breakpoint set here<br/>00402010  push 0<br/>00402012  call dword ptr [ExitProcess]</pre>
<p>Let's debug our Hello World program.</p>
<p>Download x64dbg from <a href="https://x64dbg.com/">https://x64dbg.com/</a>.</p>
<p class="mce-root"/>
<p>It is a ZIP archive that you will have to extract. And once extracted, open the x96dbg.exe from the release folder. This will show the launcher dialog where you get to select x32dbg (for 32-bit debugging) and x64dbg (for 64-bit debugging) as your debugger:</p>
<div><img class="alignnone size-full wp-image-649 image-border" src="img/cda8c465-709d-42de-9e08-e09bfaab749f.png" style="width:31.58em;height:33.92em;" width="379" height="407"/></div>
<p class="mce-root"/>
<p>The Hello World program we developed is a 32-bit program, thus, select x32dbg. Then click on File-&gt;Open, then browse and open the helloworld.exe program. Opening it will show you where the EIP is at in the disassembly window as follows:</p>
<div><img class="alignnone size-full wp-image-650 image-border" src="img/62671264-1b8c-49d4-8d23-6afd32415c6f.png" style="width:73.00em;height:52.25em;" width="876" height="627"/></div>
<p>At the bottom of the window, it says: "System breakpoint reached!" EIP is at a high-memory region address and the window title also indicates "Module: ntdll.dll - Thread: Main Thread." All of this suggests that we are not yet in the helloworld program, but rather still in the ntdll.dll code that loads up the helloworld program to memory, initializes it and then starts to run it. If you go to Options-&gt;Preferences, and in the Events table of the Settings window, by default, the System Breakpoint* is checked. This causes the debugger to pause in the ntdll.dll before we even reach our helloworld code. Uncheck the System Breakpoint*, click on Save, then exit the debugger, as shown here:</p>
<div><img class="alignnone size-full wp-image-651 image-border" src="img/5cd8c14a-4bd3-4524-a7d2-d9b71e2973bc.png" style="width:29.42em;height:41.33em;" width="389" height="547"/></div>
<p>Now that we have removed the System Breakpoint, repeat loading the helloworld program. The EIP should now be in the helloworld code:</p>
<div><img class="alignnone size-full wp-image-652 image-border" src="img/24d781b2-f654-431d-acf8-d24936f65f21.png" style="width:73.00em;height:52.25em;" width="876" height="627"/></div>
<p class="mce-root"/>
<p>Click on the Debug menu. You should see that there are keyboard keys assigned to Step into, Step over, Run and more debugging options:</p>
<div><img class="alignnone size-full wp-image-653 image-border" src="img/1a0c8fcf-67f7-461a-8227-ca1a1e49d4b8.png" style="width:72.92em;height:51.92em;" width="875" height="623"/></div>
<p>The stack frame window is located at the lower right pane. Take note of the information there, then press <kbd><em>F7</em></kbd> or <em>F8</em> to do a single step. The <kbd>PUSH helloworld.401000</kbd> instruction just placed the address of "<kbd>Hello World</kbd>" text string at the top of the stack. At the upper right pane where the registers and flags are, all changes have their text colored red. With the stack moving its address, ESP should change. And since we are now on the next line of instruction code, EIP should have also changed.</p>
<p>Do another single step to push the address of "<kbd>%s</kbd>" to the stack. You should now be in address <kbd>0040200A</kbd>. At this point, doing a step over will execute the <kbd>printf</kbd> function and be at address 00402010. Out of curiosity, let's do a step into instead. This leads us in the <kbd>msvcrt</kbd> library, where the <kbd>printf</kbd> function is:</p>
<div><img class="alignnone size-full wp-image-654 image-border" src="img/97fe9783-f71b-4277-9ba7-3914935d1475.png" style="width:73.00em;height:52.25em;" width="876" height="627"/></div>
<p class="mce-root"/>
<p class="CDPAlignLeft CDPAlign">To get back to our <kbd>helloworld</kbd> program, we can do a "<kbd>Run to user code</kbd>," which has a mapped key of <em>Alt </em>+ <em>F9</em> or an "<kbd>Execute till return</kbd>" <em>Ctrl </em>+ <em>F9</em>. The user code pertains to our hello world program. Doing a "<kbd>Run to user code</kbd>" will bring us to address <kbd>00402010</kbd>, which is the instruction after the <kbd>printf</kbd> call. Doing an "<kbd>Execute till return</kbd>" will bring us to the address where the <kbd>RET</kbd> instruction is. Let's do an "<kbd>Execute till return</kbd>" instead:</p>
<div><img class="alignnone size-full wp-image-655 image-border" src="img/a6190ea8-0505-49f7-a5a0-bab9faef4bea.png" style="width:73.00em;height:52.25em;" width="876" height="627"/></div>
<p>Now take a look at the stack. As discussed previously about the <kbd>CALL-RET</kbd> instructions, a <kbd>CALL</kbd> stores the address of the next instruction at the top of the stack. At this point, the address stored at the top of the stack is <kbd>00402010</kbd>. Make a single step and we should be back in our <kbd>hello world</kbd> program.</p>
<p>Just continue doing step overs. The last two instructions should terminate the program and the debugging will stop.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    </div>



  
<div><h1 class="header-title">Summary</h1>
                
            
            
                
<p>Assembly language is a low-level language that uses instructions to communicate directly with the computer system. Logic used in computers is based on an on-and-off concept, from which binary 1s and 0s were derived. We have learned how to read and write binary from various number bases, and how to do arithmetic and bitwise computations.</p>
<p>We introduced popular assemblers and debuggers that we can use to build and validate our program. Then, we used FASM to code and build our Win32 low-level hello world program that uses APIs to communicate with the kernel. We validated our built executable program using <kbd>x64dbg</kbd> to debug it. Debugging our hello world program is a good start for us to get introduced to the world of reverse engineering.</p>
<p>Practice makes perfect. We have a listed a few suggested programs that can be developed using assembly language.</p>
<p>Knowing the lowest level of a code is a good start for our reverse engineering journey. As you finish up this book, assembly language will feel somewhat like a walk in the park.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Further reading</h1>
                
            
            
                
<p>Intel's documentation contains the complete list of x86 instructions and describes the syntax and use of each instruction in assembly language. You can get these documents from <a href="http://www.intel.com/products/processor/manuals/">http://www.intel.com/products/processor/manuals/</a>.</p>


            

            
        
    </div>



  </body></html>