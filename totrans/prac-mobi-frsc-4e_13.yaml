- en: Android App Analysis, Malware, and Reverse Engineering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Third-party applications are commonly used by smartphone users. Android users
    download and install several apps from app stores such as Google Play. During
    forensic investigations, it is often helpful to perform an analysis of these apps
    to retrieve valuable data and to detect any malware. For instance, a photo vault
    app might lock sensitive images present on a device. Hence, it would be of great
    significance to have the knowledge to identify the passcode for the photo vault
    app.
  prefs: []
  type: TYPE_NORMAL
- en: Also, apps such as Facebook, WhatsApp, Skype, and so on are widely used these
    days, and they are often the source of valuable data that aids in cracking a case.
    Hence, it is important to know what kind of data these apps store and the location
    of this data. While the data extraction and data recovery techniques we discussed
    in earlier chapters provide access to valuable data, app analysis helps us gain
    information about the specifics of an application, such as preferences and permissions.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing widely used Android apps to retrieve valuable data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Techniques to reverse engineer an Android application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Android malware
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analyzing widely used Android apps to retrieve valuable data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: On Android, everything the user interacts with is an application. While some
    apps are preinstalled by the device manufacturer, others are downloaded and installed
    by the user. For example, even routine functions, such as contacts, calls, SMS,
    and so on, are performed through their respective apps. Thus, Android app analysis
    is crucial during the course of an investigation. Several third-party apps, such
    as WhatsApp, Facebook, Skype, Chrome browser, and so on, are used widely, and
    they handle a lot of valuable information. Depending on the type of application,
    most of these apps store sensitive information on the device's internal memory
    or SD card. Analyzing them may provide information about the location details
    of the user, their communication with others, and more. Using the forensic techniques
    we described earlier, it is possible to get access to the data stored by these
    applications. However, you, as a forensic examiner, need to develop the necessary
    skills to convert the available data into useful data. This is achieved when you
    have a comprehensive understanding of how the application handles data.
  prefs: []
  type: TYPE_NORMAL
- en: As we discussed in previous chapters, all applications store their data in the
    `/data/data` folder by default. Apps also store certain other data on the SD card,
    if they want to, by asking permission at the time of installation. Information
    about applications present on the device can be gathered by inspecting the contents
    of the `/data/data` folder, but this is not straightforward as it requires analyzing
    each individual app folder under this path. As an alternative, you can inspect
    the `packages.list` file present under `/data/system`. This file contains information
    about all the apps, along with their package names and data paths.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be performed using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output of the preceding command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/07bd4eb4-20af-4cfc-9003-e3219e2aa2b2.png)'
  prefs: []
  type: TYPE_IMG
- en: Content of the packages.list file
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's look specifically at some third-party apps that are widely used and
    handle valuable data.
  prefs: []
  type: TYPE_NORMAL
- en: The following apps are only being covered to make you familiar with the kind
    of data that can be extracted and the possible locations where the data can be
    obtained. You will need to take appropriate permissions and should abide by the
    legal rules before performing these tasks on a device. As we explained in [Chapter
    8](b1621e6e-80a3-495e-a288-c8db601149f8.xhtml), *Android Forensic Setup and Pre-Data
    Extraction Techniques*, the following techniques only work after the device has
    been rooted.
  prefs: []
  type: TYPE_NORMAL
- en: Facebook Android app analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Facebook Android app is one of the most widely used social networking applications.
    It stores its information in the `/data/data` folder, within the `com.facebook.katana`
    package. The following details provide an overview of the kind of information
    that can be gathered across various files:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Facebook contacts**: Information about the user''s Facebook contacts can
    be retrieved by analyzing the `contacts_db2` database, which is present under
    the following path:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Path**: `/data/data/com.facebook.katana/databases/contacts_db2`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `contacts_db2` database (SQLite file) contains a table named contacts, which
    contains most of the user's information, such as their first name, last name,
    display name, and URL for display picture.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Facebook notifications**: Information about a user''s notifications can be
    gathered by analyzing the `notification_db` database, which is present under the
    following path:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Path**: `/data/data/com.facebook.katana/databases/notifications_db`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `gql_notifications` table present under the preceding path holds the user's
    information. The `seen_state` column confirms whether a notification has been
    seen or not. The `updated` column points to the time when the notification was
    updated. The `gql_payload` column contains the notification and the sender information.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Facebook messages**: A Facebook message conversation may be of crucial importance
    in several cases and can be viewed by analyzing the `threads_db2` database:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Path**: `/data/data/com.facebook.katana/databases/threads_db2`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Videos from newsfeed**: The `/video-cache` folder contains videos that have
    been downloaded from the user''s newsfeed. Note that these are not the videos
    posted by the user, but rather they are the videos that appeared on their newsfeed:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Path**: `/data/data/com.facebook.katana/files/video-cache`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Images from newsfeed**: The `/images` folder contains various images that
    appear on the user''s profile, such as the ones from their newsfeed and contact
    profile pictures. Several directories are present within this folder and images
    may be stored in formats other than `.jpg`, such as `.cnt`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Path**: `/data/data/com.facebook.katana/cache/images`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Newsfeed data**: The `newfeed_db` database contains data shown to the user
    on their newsfeed. As shown in the following screenshot, analyzing this database
    would provide valuable information, such as when a particular story was loaded
    by the device (the `fetched_at` column), if a particular story was seen by the
    user (the `seen_state` column), and where the corresponding files of a story are
    stored on the device (the `cache_file_path` column):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Path**: `/data/data/com.facebook.katana/databases/newsfeed_db`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/49a0d2c5-1d9b-482f-afdc-45327787d546.png)'
  prefs: []
  type: TYPE_IMG
- en: The Facebook newsfeed.db file analyzed in SQLite browser
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding screenshot, `fetched_at` specifies the date and time when
    this information is fetched. Notice that the app uses Linux epoch time, also known
    as Unix time or Posix time, to store this information. This format is often used
    by multiple apps and, hence, is worth taking a look at. Linux epoch time is stored
    as the number of seconds (or milliseconds) since midnight on January 1, 1970\.
    There are several online sites, such as [https://www.epochconverter.com/](https://www.epochconverter.com/),
    that can readily convert the Linux epoch time into a normal format. For example,
    the following screenshot shows Linux epoch time 1,577,881,839 converted into a
    normal format:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7072a6d0-d3ec-4498-a617-cd9faa509832.png)'
  prefs: []
  type: TYPE_IMG
- en: Example of time format
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have performed an analysis of the Facebook app, let's perform a
    similar analysis with our next application, which is WhatsApp.
  prefs: []
  type: TYPE_NORMAL
- en: WhatsApp Android app analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'WhatsApp is the most popular chat (audio and video) messaging service and is
    used by more than a billion people across the globe. It stores its information
    under the `/data/data` folder, with the package name, `com.whatsapp`. The following
    is an overview of the important files that are of interest from a forensic perspective:'
  prefs: []
  type: TYPE_NORMAL
- en: '**User''s profile pic**: The user''s profile picture is saved with the`me.jpg` filename
    and is present under the following path:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Path**: `/data/data/com.whatsapp/me.jpg`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**User''s phone number (associated with WhatsApp)**: The `me` file that''s
    present under the main folder contains the phone number that is associated with
    the user''s WhatsApp account. Note that this may or may not be the phone number
    that is associated with the SIM:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Path**: `/data/data/com.whatsapp/me`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Contacts profile pic**: The `/avatars` directory contains thumbnails of the
    profile pictures of the user''s contacts (who use WhatsApp):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Path**: `/data/data/com.whatsapp/files/Avatars`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Chat messages**: All message-related information, including chats and sender
    details, is present in the `msgstore.db` file, which is present at the following
    location:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Path**: `/data/data/com.whatsapp/databases/msgstore.db`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**WhatsApp files**: Most of the files shared with WhatsApp, such as images,
    videos, and audio messages, are stored on the SD card in the following location:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Path**: `/sdcard/WhatsApp/Media`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Both sent and received files are stored separately here in their respective
    folder names.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will look at another application that is used for telecommunication
    and specializes in providing video chat and voice calls: Skype.'
  prefs: []
  type: TYPE_NORMAL
- en: Skype Android app analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Skype is an app that offers video chat and voice call services. The application''s
    data is stored under the `/data/data` folder, with the package name `com.skype.raider`.
    The following are some important artifacts that can be extracted by analyzing
    the Skype app:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Username and IP address**: The `shared.xml` file present under the following
    path contains information about the username and the last IP address that connected
    to Skype:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Path**: `/data/data/com.skype.raider/files/shared.xml`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Profile picture**: The user''s profile picture is present in the `/thumbnails`
    directory, whose path is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Path**: `/data/data/com.skype.raider/files/<username>/thumbnails/`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Call logs**: Information about call logs made from Skype is available in
    the `main.db` file. Analyzing this file gives us a lot of information:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Path**: `/data/data/com.skype.raider/files/<username>/main.db/`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, the `duration` table provides information about call duration,
    the `start_timestamp` field gives the start time of a call, and the `creation_timestamp`
    field indicates when the call is initiated (this includes unanswered calls). The
    `type` column indicates whether the call was incoming (value= `1`) or outgoing
    (value= `2`).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Chat messages**: The `messages` table present in the `main.db` file contains
    all the chat messages. The `author` and `from_dispname` columns provide information
    about who wrote the message. The `timestamp` column shows the date/time of the
    message. The `body_xml` column contains the content of the message:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Path**: `/data/data/com.skype.raider/files/<username>/main.db/`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Files transferred**: The `Transfers` table contains information about transferred
    files, such as the filename, the size of the file, and their location on the device:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Path**: `/data/data/com.skype.raider/files/<username>/main.db/`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The actual images or files that are received will be stored on an SD card. If
    a file is downloaded, it will be in the `Downloads` folder in the root of the
    SD.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Group chats**: The `ChatMembers` table shows a list of users who are present
    in a particular chat. The `adder` column shows the user who initiated the conversation:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Path**: `/data/data/com.skype.raider/files/<username>/main.db/`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, we will perform an analysis on the Gmail application.
  prefs: []
  type: TYPE_NORMAL
- en: Gmail Android app analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Gmail is a widely used email service offered by Google. The application data
    is saved under the `/data/data` folder, with the package name `com.google.android.gm`.
    The following are the important artifacts that can be extracted by analyzing the
    Gmail app:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Account details**: The XML files present under `/shared_prefs` confirm the
    email account details. Details of other accounts, which are linked to the current
    email, can be identified from the `Gmail.xml` file:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Path**: `/data/data/com.google.android.gm/cache/<username>@gmail.com`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Attachments**: Attachments that are recently used in both sending and receiving
    emails are saved to the `/cache` directory. This is valuable because it gives
    us access to items that have been deleted from the email service too. Each row
    also contains a `messages_conversation` value. This value can be compared with
    the `conversations` table of the email attachment. The `filename` column identifies
    the path on the device where the file is located. The following is the exact path
    for this folder:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Path**: `/data/data/com.google.android.gm/cache/<username>@gmail.com`:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/66d5e627-1946-46c8-a729-16cad9ba6c46.png)'
  prefs: []
  type: TYPE_IMG
- en: List of attachments present under Gmail's cache directory
  prefs: []
  type: TYPE_NORMAL
- en: '**Email subject**: The subject of this email can be recovered by analyzing
    the `conversations` table present in the `mailstore.<username>@gmail.com.db` file:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Path**: `/data/data/com.google.android.gm/databases/mailstore.<username>@gmail.com.db`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Search history**: Any text searches that were made within the app are stored
    in the `suggestions.db` file, which is present at the following location:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Path**: `/data/data/com.google.android.gm/databases/suggestions.db`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's wrap up this section by performing a final analysis on the Google Chrome
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Google Chrome Android app analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Google Chrome is the default web browser on Google Pixel and many other devices,
    and it is used widely to browse the internet. The application data is present
    under the `/data/data` folder, with the package name, `com.android.chrome`. The
    following are the important artifacts that can be extracted by analyzing the Gmail
    app:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Profile picture**: The profile picture of the user is stored with the `Google
    Profile Picture.png` filename in the following location:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Path**: `/data/data/com.android.chrome/app_chrome/Default/ Google Profile
    Picture.png`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bookmarks**: The `Bookmarks` file contains information about all the bookmarks
    synced with the account. Details such as the site name, URL, and the time when
    it was bookmarked can be gathered by analyzing this file:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Path**: `/data/data/com.android.chrome/app_chrome/Default/Bookmarks`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Browsing history**: The `History.db` file contains the user''s web history
    stored in various tables. For example, as shown in the following screenshot, the
    `keyword_search_terms` table contains information about the searches that were
    made using the Chrome browser:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/6a6bb125-9825-4ca7-bfd8-aef1fa43939f.png)'
  prefs: []
  type: TYPE_IMG
- en: Google Chrome browsing history
  prefs: []
  type: TYPE_NORMAL
- en: The `segments` table contains a list of sites visited by the user (but not all
    of the sites). It's interesting to note that Chrome stores the data belonging
    to not just the device, but the account in general. In other words, information
    about sites that have been visited from other devices using the same account is
    also stored on the device; for example, the `URLs` table contains the browsing
    history for a Google account across several devices.
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Path**: `/data/data/com.android.chrome/app_chrome/Default/History`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Login Data**: The `Login Data` database contains the login information of
    different sites saved in the browser. The site URL, along with the username and
    password, is stored in the respective tables:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Path**: `/data/data/com.android.chrome/app_chrome/Default/Login Data`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Frequently visited sites**: The `Top Sites` database contains a list of frequently
    visited sites:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Path**: `/data/data/com.android.chrome/app_chrome/Default/Top Sites`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Other data**: Other information, such as the phone numbers or email addresses
    entered by the user during form fills across different sites, is stored in the
    `Web Data` database. Any tables that are present within this database contain
    autofill data:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Path**: `/data/data/com.android.chrome/app_chrome/Default/Web Data`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have analyzed the different third-party apps, we will look at the
    techniques we can use to reverse engineer Android apps.
  prefs: []
  type: TYPE_NORMAL
- en: Techniques to reverse engineer an Android application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may need to deal with applications that stand as a barrier to accessing
    the required information. For instance, take the case of the gallery on a phone
    that is locked by an *AppLock* application. In this case, in order to access the
    pictures and videos stored in the gallery, you first need to enter the passcode
    to the *AppLock*. Hence, it would be interesting to know how the *AppLock* app
    stores the password on the device. You might look into the SQLite database files.
    However, if they are encrypted, then it's hard to even tell that it's a password.
    Reverse engineering applications would be helpful in such cases where you want
    to better understand the application and how the application stores the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'To state it in simple terms, reverse engineering is the process of retrieving
    source code from an executable. Reverse engineering an Android app is done in
    order to understand the functionality of the app, the data storage, the security
    mechanisms in place, and more. Before we proceed to learn how to reverse engineer
    an Android app, here is a quick recap of the Android apps:'
  prefs: []
  type: TYPE_NORMAL
- en: All the applications that are installed on the Android device are written in
    the Java programming language.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When a Java program is compiled, we get bytecode. This is sent to a dex compiler,
    which converts it into Dalvik bytecode.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thus, the class files are converted into dex files using a dx tool. Android
    uses something called **Dalvik virtual machine** (**DVM**) to run its applications.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JVM's bytecode consists of one or more class files, depending on the number
    of Java files that are present in an application. Regardless, a Dalvik bytecode
    is composed of only one dex file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thus, the dex files, XML files, and other resources that are required to run
    an application are packaged into an Android package file (an APK file). These
    APK files are simply collections of items within ZIP files. Therefore, if you
    rename an APK extension file to a `.zip` file, then you will be able to see the
    contents of the file. However, before you can do this, you need to get access
    to the APK file of the application that is installed on the phone. Here is how
    the APK file corresponding to an application can be accessed.
  prefs: []
  type: TYPE_NORMAL
- en: Extracting an APK file from an Android device
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Apps that come preinstalled with the phone are stored in the `/system/app`
    directory. Third-party applications that are downloaded by the user are stored
    in the `/data/app` folder. The following method helps you gain access to the APK
    files on the device; it works on both rooted and non-rooted devices:'
  prefs: []
  type: TYPE_NORMAL
- en: Identify the package name of the app by issuing the `# adb.exe shell pm list
    packages` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following is the output of the preceding command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/845bd1f9-74f7-4b82-96ec-9abb26ac9bd4.png)'
  prefs: []
  type: TYPE_IMG
- en: List of package names present on the device
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in the preceding command-line output, the list of package names is
    displayed. Try to find a match between the app in question and the package name.
    Usually, the package names are very much related to the app names. Alternatively,
    you can use the Android Market or Google Play to identify the package name easily.
    The URL for an app in Google Play contains the package name, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5d24586a-85b6-47b0-a70f-58aa01a2ddf1.png)'
  prefs: []
  type: TYPE_IMG
- en: Facebook App in the Google Play Store
  prefs: []
  type: TYPE_NORMAL
- en: 'Identify the full pathname of the APK file for the desired package by issuing
    the `adb shell pm path` command, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7de67300-77f9-4d01-8d4e-a4856a021b23.png)'
  prefs: []
  type: TYPE_IMG
- en: Identifying full pathname of APK
  prefs: []
  type: TYPE_NORMAL
- en: 'Pull the APK file from the Android device to the forensic workstation using
    the `adb pull` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/62c3987d-21df-4837-a593-eccc2d453207.png)'
  prefs: []
  type: TYPE_IMG
- en: adp pull command
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s analyze the contents of an APK file. An Android package is a container
    for an Android app''s resources and executables. It''s a zipped file that contains
    the following files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AndroidManifest.xml`: This contains information about the permissions and
    more.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`classes.dex`: This is the class file that''s been converted into a dex file
    by the dex compiler.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Res`: The application''s resources, such as the image files, sound files,
    and more, are present in this directory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Lib`: This contains native libraries that the application may use.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`META-INF`: This contains information about the application''s signature and
    signed checksums for all the other files in the package.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once the APK file has been obtained, you can proceed to reverse engineer the
    Android application.
  prefs: []
  type: TYPE_NORMAL
- en: Steps to reverse engineer Android apps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'APK files can be reverse-engineered in different ways to get the original code.
    The following is one method that uses the `dex2jar` and JD-GUI tools to gain access
    to the application code. For our example, we will examine the `com.twitter.android-1.apk`
    file. The following are the steps to successfully reverse engineer the APK file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Rename the APK extension to ZIP to see the contents of the file. Rename the
    `com.twitter.android-1.apk` file to `twitter.android-1.zip` and extract the contents
    of this file using any file archiver application. The following screenshot shows
    the files that were extracted from the original file, `twitter.android-1.zip`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d6a4ff00-b5ed-41df-902e-4c9c3984a9b9.png)'
  prefs: []
  type: TYPE_IMG
- en: Extracted files of an APK file
  prefs: []
  type: TYPE_NORMAL
- en: The `classes.dex` file that we discussed previously can be accessed after extracting
    the contents of the APK file. This dex file needs to be converted into a class
    file in Java. This can be done using the `dex2jar` tool.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Download the `dex2jar` tool from [https://github.com/pxb1988/dex2jar](https://github.com/pxb1988/dex2jar),
    drop the `classes.dex` file into the `dex2jar` tools directory, and issue the
    following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'When the preceding command is successfully run, it creates a new `classes -dex2jar.jar`
    file in the same directory, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/306e7996-4fdd-40e4-b5c3-91e85a53d654.png)'
  prefs: []
  type: TYPE_IMG
- en: The classes-dex2jar.jar file created by the dex2jar tool
  prefs: []
  type: TYPE_NORMAL
- en: 'To view the contents of this JAR file, you can use a tool such as JD-GUI. As
    shown in the following screenshot, the files present in an Android application
    and the corresponding code can be seen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5c1a2e05-7b7f-49d4-b819-626efaf2a5e1.png)'
  prefs: []
  type: TYPE_IMG
- en: The JD-GUI tool
  prefs: []
  type: TYPE_NORMAL
- en: Once we get access to the code, it is easy to analyze how the application stores
    the values, permissions, and more information that may be helpful to bypass certain
    restrictions. When malware is found on a device, this method to decompile and
    analyze the application may prove useful, as it will show what is being accessed
    by the malware and provide clues to where the data is being sent. The following
    sections focus on Android malware in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Android malware
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As Android's market share continues to increase, so do attacks or malware targeted
    at Android users. Mobile malware is a broad term that refers to a piece of software
    that performs unintended actions and includes Trojans, spyware, adware, ransomware,
    and others. According to pandasecurity, Android devices are 50 times more infected
    with malware compared to iOS devices ([https://www.pandasecurity.com/mediacenter/mobile-security/android-more-infected-than-ios/](https://www.pandasecurity.com/mediacenter/mobile-security/android-more-infected-than-ios/)).
    In 2019, the famous Agent Smith malware alone infected almost 25 million Android
    devices, as per a Cybersecurity Hub news report ([https://www.cshub.com/malware/articles/incident-of-the-week-malware-infects-25m-android-phones](https://www.cshub.com/malware/articles/incident-of-the-week-malware-infects-25m-android-phones)).
  prefs: []
  type: TYPE_NORMAL
- en: One of the primary reasons for this situation is that, unlike Apple's App Store,
    which is tightly controlled by the company, Google's Play Store is an open ecosystem
    without any detailed upfront security reviews. Malware developers can easily move
    their apps to the Play Store and thereby distribute their apps. Google now has
    a malware-detecting software named Google Bouncer, which will automatically scan
    an uploaded app for malware, but attackers have figured out several ways to remain
    undetected. Moreover, Android officially allows us to load apps that have been
    downloaded over the internet (side-loading), unlike iOS, which does not allow
    unsigned apps.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, as shown in the following screenshot, when the Unknown sources
    option is selected on an Android device, it allows the user to install apps that
    have been downloaded from any site over the internet:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a0adb506-9287-4311-9910-5cc3ef4bb143.png)'
  prefs: []
  type: TYPE_IMG
- en: Side-loading option in Android
  prefs: []
  type: TYPE_NORMAL
- en: 'The third-party app stores that host Android apps are known to be hubs of malware.
    This prompted Google to roll out the *Verify Apps* feature starting from Android
    4.2, which scans apps locally on Android devices to look for malicious activities,
    such as SMS abuse. As shown in the following screenshot, the Verify apps feature
    may warn the user, or in some cases may even block the installation. However,
    this is an opt-in service, so users can disable this feature if they wish to:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c7b30de6-5536-4636-9e17-8c16bff545e3.png)'
  prefs: []
  type: TYPE_IMG
- en: Verify apps feature in Android
  prefs: []
  type: TYPE_NORMAL
- en: 'Starting with Android Oreo, Google has rolled out a new feature called Play
    Protect, which is a better version of the verifying apps feature. The primary
    job of Play Protect is to block or warn the users of malicious or harmful apps
    that have been installed on the Android device. For example, as shown in the following
    screenshot, the Play Protect feature may show a warning message during the app''s
    installation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/17406d6b-4d5c-42a7-87a4-8c35c6f35eff.png)'
  prefs: []
  type: TYPE_IMG
- en: Play Protect feature
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's have a look at the types of malware.
  prefs: []
  type: TYPE_NORMAL
- en: Types of Android malware
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are different kinds of malware types that can infect an Android device.
    The following are some of the most common ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Banking malware**: It can be distributed as fake banking applications to
    steal banking credentials typed by the users, or steal any other sensitive personal
    information from the user''s account. Banking Trojans can intercept or modify
    banking transactions and perform dangerous actions such as sending, deleting,
    and intercepting SMS messages, as well as keylogging.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Spyware**: Spyware monitors, logs, and sends important information from the
    target device to the attacker''s server. This information might comprise SMS messages,
    recorded phone calls, screenshots, keylogs, emails, or any other application data
    that may be of interest to the attacker. BusyGasper, a spyware identified by Kaspersky
    Lab experts in early 2018, not only possesses common spyware capabilities, such
    as collecting information from popular messаging applications, such as WhatsApp,
    Viber, and Facebook, but it also has device sensor listeners, including motion
    detectors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Adware**: Adware is another popular malicious or unwanted application type
    that is very common on Android devices. It is relatively easy to detect, as the
    victim will receive continuous popups and ads on their device''s screen. Such
    unwanted programs are not always harmless, since popups may result in downloading
    another piece of malware, including the types already mentioned – spyware and
    banking Trojans.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ransomware**: The main targets of ransomware are Windows-based desktop computers
    and servers, but it also exists on mobile platforms, and on Android in particular.
    Usually, it only locks the device screen with a ransom note, but sometimes it
    encrypts users'' data as well.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Crypto-mining malware**: Cryptocurrencies are extremely popular nowadays,
    so this type of malicious program is available even for mobile platforms, such
    as Android. The goal of such applications is to mine cryptocurrency, using a victim''s
    device computation capacity. Occasionally, this type of malware can even put smartphone
    hardware at risk.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advanced malware is also capable of rooting the device and installing new apps.
    For example, the Android Mazar malware, which was discovered in Feb 2016, spreads
    via text messages and is capable of gaining administrator rights on phones, allowing
    it to wipe handsets, make calls, or read texts.
  prefs: []
  type: TYPE_NORMAL
- en: A full list of Android malware families and their capabilities is available
    at [https://forensics.spreitzenbarth.de/android-malware/](https://forensics.spreitzenbarth.de/android-malware/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Once malware gets into a device, it can perform dangerous actions, some of
    which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Send and read your text messages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Steal sensitive data, such as pictures, videos, and credit card numbers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manipulate files or data present on the device
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Send SMS to a premium-rated number
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Infect your browser and steal any data typed into its Change device settings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wipe all data present on the device
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lock the device until a ransom is paid
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Display advertisements continuously
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have understood the different types of malware, we will see how
    the malware spreads in your device.
  prefs: []
  type: TYPE_NORMAL
- en: How does Android malware spread?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An Android device can be infected with malware in several different ways. The
    following are some of the possible ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Repackaging legitimate application**: This is the most common method used
    by attackers. First, the attacker downloads a legitimate application and disassembles
    it. Then, they add their malicious code and reassemble the application. The new
    malicious application now functions exactly as the legitimate application does,
    but it also performs malicious activity in the background. This kind of application
    is commonly found in third-party Android app stores and is downloaded by many
    people.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Exploiting Android vulnerabilities**: In this scenario, an attacker exploits
    the bugs or the vulnerabilities that are discovered in the Android platform to
    install their malicious application or to perform any unwanted actions. For example,
    installer hijacking, which was identified in 2015, has been exploited by attackers
    to replace an Android application with malware during installation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bluetooth and MMS propagation**: Malware is also spread via Bluetooth and
    MMS. The victim receives the malware when the device is in discoverable mode,
    for example, when it can be seen by other Bluetooth-enabled devices. In the case
    of MMS, the malware is attached to the message, just like how computer viruses
    are sent through email attachments. However, in both these methods, the user has
    to agree, at least once, to run the file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**App downloading a malicious update**: In this case, the app that was originally
    installed does not contain any malicious code, but a function present within the
    code will download malicious commands at runtime. This can be done via a stealthy
    update or user update. For example, the Plankton malware uses stealthy updates
    that directly download a JAR file from a remote server and do not need any user
    permission. In the case of user updates, the user has to allow the app to download
    the new version of the app.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Remote install**: The attacker may compromise the credentials of the user''s
    account on the device and thereby remotely install apps on the device. This generally
    happens in targeted scenarios and is less frequent compared to the previous two
    methods we just described.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we've looked at the possible ways in which the Android malware can
    spread, let's try to identify the presence of malware in your device.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying Android malware
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'From a forensic perspective, it''s important to identify the presence of any
    malware on the device prior to performing any analysis. This is because malware
    can alter the state of the device or contents on the device, thereby making the
    analysis or the results inconsistent. There are tools available on the market
    that can analyze the physical extraction to identify malware. For example, Cellebrite
    UFED Physical Analyzer has BitDefender''s anti-malware technology, which scans
    for malware. As shown in the following screenshot, once the physical image has
    been loaded into the tool, the file can be scanned for malware:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/64f84e23-3bfc-40eb-bd46-20a7f256645f.png)'
  prefs: []
  type: TYPE_IMG
- en: Scanning for malware in UFED Physical Analyzer
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the scan starts, the BitDefender software tries to unpack the `.apk` files
    and looks for infected or malicious files. This process is automatic and the tool
    points to the malicious apps, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9b4514e2-3949-4b28-b3b1-abc4cb275bc7.png)'
  prefs: []
  type: TYPE_IMG
- en: Malware scanner results in UFED Physical Analyzer
  prefs: []
  type: TYPE_NORMAL
- en: 'The tool simply points out that something malicious is present on the device.
    The forensic investigator has to then manually confirm whether this is a valid
    issue by analyzing the respective application. This is where the reverse engineering
    skills that we discussed in the previous sections need to be leveraged. Once the
    application has been reverse-engineered and the code has been obtained, it is
    recommended that you take a look at the `AndroidManifest.xml` file to find out
    the app permissions. This will be helpful for understanding where the app stores
    the data, what resources it is trying to access, and more. For example, a Flashlight
    application does not need read/write access to your SD card data, or to make a
    phone call:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/516bfec6-8b29-482e-b80e-3e834b262e12.png)'
  prefs: []
  type: TYPE_IMG
- en: Permissions in the AndroidManifest.xml file
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, you can also upload the `.apk` file to VirusTotal, a free service
    that can be used to analyze suspicious files for malware. VirusTotal will scan
    your file against 55 antivirus engines. It's also important to note that the tool
    may not identify a valid case if the details are obfuscated in the `.apk` file.
    Hence, as a forensic investigator, it's important to develop the necessary skills
    to reverse engineer any suspicious apps and analyze the code to identify malicious
    behavior.
  prefs: []
  type: TYPE_NORMAL
- en: In some investigations, the nature of the malware that is present on a device
    may also result in arriving at certain crucial conclusions, which may affect the
    outcome of the case. For example, consider an internal investigation in a corporation
    that involves sending abusive messages to other employees. Identifying malware
    on the device that sends the messages would help solve the case.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Android app analysis helps a forensic investigator look for valuable data in
    relevant locations on a device. Reverse engineering Android apps is the process
    of retrieving source code from an APK file. Using certain tools, such as `dex2jar`,
    Android apps can be reverse-engineered in order to understand their functionality
    and data storage, identify malware, and more. In this chapter, we performed analysis
    on different android applications and we are now able to retrieve data from them.
    We also learned about different types of Android malware and how to identify them.
    Tools such as UFED Physical Analyzer come with BitDefender software, which can
    automatically scan for malware.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter covers performing forensics on Windows Phone devices.
  prefs: []
  type: TYPE_NORMAL
