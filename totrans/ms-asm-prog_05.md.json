["```\nsection '.data' data readable writeable\n   *; Current date and birth date*\n *; The dates are arranged in a way most suitable*\n *; for use with XMM registers*\n   cday   dd 9               *; Current day of the month*\n   cyear  dd 2017            *; Current year*\n   bday   dd 16              *; Birth date day of the month*\n   byear  dd 1979            *; Birth year*\n\n   cmonth dd 5               *; 1-based number of current month*\n          dd 0              \n   bmonth dd 1               *; 1-based number of birth month*\n          dd 0\n\n   *; These values are used for calculation of days*\n *; in both current and birth dates*\n   dpy    dd 1.0\n          dd 365.25\n\n   *; This table specifies number of days since the new year*\n *; till the first day of specified month.*\n *; Table's indices are zero based*\nmonthtab:\n         dd 0   *; January*\n         dd 31  *; February*\n         dd 59  *; March*\n         dd 90  *; April*\n         dd 120 *; May*\n         dd 151 *; June*\n         dd 181 *; July*\n         dd 212 *; August*\n         dd 243 *; September*\n         dd 273 *; October*\n         dd 304 *; November*\n         dd 334 *; December*\n\n align 16\n *; Biorhythmic periods*\n T       dd 23.0 *; Physical*\n         dd 28.0 *; Emotional*\n         dd 33.0 *; Intellectual*\n\n pi_2    dd 6.28318 *; 2xPI - used in formula*\n\n align 16\n *; Result storage*\n *; Arranged as table:*\n *; Physical : Emotional : Intellectual : padding*\n output  rd 20 * 4\n\n*; '.idata' section: contains import information,* \n*; is readable, is writeable*\nsection '.idata' import data readable writeable\n\n*; 'library' macro from 'win32a.inc' creates* \n*; proper entry for importing*\n*; functions from a dynamic link library.* \n*; For now it is only 'kernel32.dll'.*\nlibrary kernel, 'kernel32.dll'\n\n*; 'import' macro creates the actual entries* \n*; for functions we want to import from a dynamic link library*\nimport kernel,\\\n exitProcess, 'ExitProcess'\n```", "```\nformat PE GUI                             *; Specify output file format*\nentry _start                              *; Specify entry point*\ninclude 'win32a.inc'                      *; Include some macros*\nsection '.text' code readable executable  *; Start code section*\n```", "```\n*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;*\n*;*\n*; Entry point*\n*;*\n*;-----------------------------------------------------*\n_start:\n   mov ecx, 20                     *; Length of biorhythm data to* \n *; produce*\n\n   mov eax, [bmonth]               *; Load birth month*\n   dec eax                         *; Decrement it in order to address* \n *; 0-based array*\n\n   mov eax, [monthtab + eax * 4]   *; Replace month with number of days*\n *; since New Year*\n   mov [bmonth], eax               *; Store it back*\n\n   mov eax, [cmonth]               *; Do the same for current month*\n   dec eax\n   mov eax, [monthtab + eax * 4]\n   mov [cmonth], eax\n\n   xor eax, eax                *; Reset EAX as we will use it as counter*\n```", "```\n   movaps xmm0, xword[cday]    *; Load the day/year parts of both dates*\n   movapd xmm1, xword[cmonth]  *; Load number of days since Jan 1st for both dates*\n   cvtdq2ps xmm0, xmm0         *; Convert loaded values to single precision floats*\n   cvtdq2ps xmm1, xmm1\n```", "```\n   movq xmm2, qword[dpy]  *; Load days per year into lower half of XMM2*\n   movlhps xmm2, xmm2     *; Duplicate it to the upper half*\n```", "```\naddps xmm1, xmm0      *; Summation of day of the month with days since January 1st*\nmulps xmm2, xmm1      *; Multiplication of years by days per year*\nhaddps xmm2, xmm2     *; Final summation of days for both dates*\nhsubps xmm2, xmm2     *; Subtraction of birth date from current date*\n```", "```\nmovd xmm3, [dpy]       *; Load 1.0 into the lower double word of XMM3*\nmovlhps xmm3, xmm3     *; Duplicate it to the third double word of XMM3*\nmovsldup xmm3, xmm3    *; Duplicate it to the second and fourth double words of XMM3*\n```", "```\nmovd xmm4, [pi_2]\nmovlhps xmm4, xmm4\nmovsldup xmm4, xmm4\n```", "```\nmovaps xmm1, xword[T]\nlea eax, [output]\n```", "```\n.calc_loop:\n   addps xmm2, xmm3    *; Increment the number of days by 1.0*\n   movaps xmm0, xmm4   *; Set XMM0 to contain 2*PI values*\n   mulps xmm0, xmm2    *; Actually do the 2*PI*t*\n   divps xmm0, xmm1    *; And complete by (2*PI*t)/T*\n```", "```\n   call adjust        *; Adjust values for sine computations*\n```", "```\n   call sin_taylor_series  *; Compute sine for each value*\n```", "```\n   movaps [eax], xmm0     *; Store the result of current iteration*\n\n   add eax, 16\n   loop .calc_loop\n\n   push 0\n   call [exitProcess]\n```", "```\n*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;*\n*;*\n*; Value adjustment before calculation of SIN()*\n*; Parameter is in XMM0 register*\n*; Return value is in XMM0 register*\n*;-----------------------------------------------------*\nadjust:\n   push ebp\n   mov ebp, esp\n   sub esp, 16 * 2      *; Create the stack frame for local variables*\n```", "```\n   movups [ebp - 16], xmm1      *; Store XMM1 and XMM2 registers*\n   movups [ebp - 16 * 2], xmm2\n```", "```\nreturn v - 2*PI*floorf(v/(2*PI));\n```", "```\nmovd xmm1, [pi_2]        *; Load singles of the XMM1 register with 2*PI*\nmovlhps xmm1, xmm1\nmovsldup xmm1, xmm1\n```", "```\n   movaps xmm2, xmm0           *; Move the input parameter to XMM2*\n   divps xmm2, xmm1            *; Divide its singles by 2*PI*\n   roundps xmm2, xmm2, 1b      *; Floor the results*\n   mulps xmm2, xmm1            *; Multiply floored results by 2*PI*\n   subps xmm0, xmm2            *; Subtract resulting values from the* \n *; input parameter*\n\n   movups xmm2, [ebp - 16 * 2] *; Restore the XMM2 and XMM1 registers*\n   movups xmm1, [ebp - 16]\n\n   mov esp, ebp                *; \"Destroy\" the stack frame and return*\n   pop ebp\n   ret\n```", "```\n*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;*\n*;*\n*; Calculation of SIN() using the Taylor Series*\n*; approximation:*\n*; sin(x) = x - x^3/3! + x^5/5! - x^7/7! + x^9/9! ...*\n*; Values to calculate the SIN() of are in XMM0 register*\n*; Return values are in XMM0 register*\n*;-----------------------------------------------------*\nsin_taylor_series:\n   push ebp                       *; Create stack frame for 5 XMM registers*\n   mov ebp, esp\n   sub esp, 5 * 16\n   push eax ecx                   *; Temporarily store EAX and ECX*\n   xor eax, eax                   *; and set them to 0*\n   xor ecx, ecx\n\n   movups [ebp - 16], xmm1        *; Temporarily store XMM1 to XMM5 on stack or, to be more*\n   movups [ebp - 16 * 2], xmm2    *; precise, in local variables.*\n   movups [ebp - 16 * 3], xmm3\n   movups [ebp - 16 * 4], xmm4\n   movups [ebp - 16 * 5], xmm5\n\n   movaps xmm1, xmm0              *; Copy the parameter to XMM1 and XMM2*\n   movaps xmm2, xmm0\n\n   mov ecx, 3                     *; Set ECX to the first exponent*\n```", "```\n\n.l1:\n   movaps xmm0, xmm2     *; Exponentiate the initial parameter*\n   call pow\n   movaps xmm3, xmm0\n\n   call fact             *; Calculate the factorial of current exponent*\n   movaps xmm4, xmm0\n\n   divps xmm3, xmm4      *; Divide the exponentiated parameter by the factorial of the exponent*\n   test eax, 1           *; Check iteration for being odd number, add the result to accumulator*\n *; subtract otherwise*\n   jnz .plus\n   subps xmm1, xmm3\n   jmp @f\n.plus:\n   addps xmm1, xmm3\n@@:                     *; Increment current exponent by 2*\n   add ecx, 2           \n   inc eax\n   cmp eax, 8           *; and continue till EAX is 8*\n   jb .l1\n\n   movaps xmm0, xmm1    *; Store results into XMM0*\n```", "```\n   movups xmm1, [ebp - 16]\n   movups xmm2, [ebp - 16 * 2]\n   movups xmm3, [ebp - 16 * 3]\n   movups xmm4, [ebp - 16 * 4]\n   movups xmm5, [ebp - 16 * 5]\n\n   pop ecx eax\n   mov esp, ebp\n   pop ebp\n   ret\n```", "```\n*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;*\n*;*\n*; Trivial exponentiation function*\n*; Parameters are:*\n*; Values to exponentiate in XMM0*\n*; Exponent is in ECX*\n*; Return values are in XMM0*\n*;-----------------------------------------------------*\npow:\n   push ebp\n   mov ebp, esp\n   sub esp, 16\n\n   push ecx\n   dec ecx                    *; The inputs are already x1 so we decrement the exponent*\n   movups [ebp - 16], xmm1\n\n   movaps xmm1, xmm0          *; We will be mutliplying XMM0 by XMM1*\n.l1:\n   mulps xmm0, xmm1\n   loop .l1\n\n   movups xmm1, [ebp - 16]\n   pop ecx\n   mov esp, ebp\n   pop ebp\n   ret\n```", "```\n*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;*\n*;*\n*; Simple calculation of factorial*\n*; Parameter is in ECX (number to calculate the factorial of)*\n*; Return value is in XMM0 register*\n*;-----------------------------------------------------*\nfact:\n   push ebp\n   mov ebp, esp\n   sub esp, 16 * 3\n\n   push ecx\n   movups [ebp - 16], xmm1\n   movups [ebp - 16 * 2], xmm2\n   mov dword[ebp - 16 * 3], 1.0\n   movd xmm2, [ebp - 16 * 3]\n   movlhps xmm2, xmm2\n   movsldup xmm2, xmm2\n   movaps xmm0, xmm2\n   movaps xmm1, xmm2\n\n.l1:\n   mulps xmm0, xmm1\n   addps xmm1, xmm2\n   loop .l1\n\n   movups xmm2, [ebp - 16 * 2]\n   movups xmm1, [ebp - 16]\n   pop ecx\n   mov esp, ebp\n   pop ebp\n   ret\n```"]