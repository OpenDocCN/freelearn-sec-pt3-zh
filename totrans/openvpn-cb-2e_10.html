<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch10"/>Chapter 10.  Advanced Configuration </h1></div></div></div><p> In this chapter, we will cover:</p><div><ul class="itemizedlist"><li class="listitem">Including configuration files in config files</li><li class="listitem">Multiple remotes and remote-random</li><li class="listitem">Inline certificates</li><li class="listitem">Connection blocks</li><li class="listitem">Details of <code class="literal">ifconfig-pool-persist</code></li><li class="listitem">Connecting using a SOCKS proxy</li><li class="listitem">Connecting via an HTTP proxy</li><li class="listitem">Connecting via an HTTP proxy with authentication</li><li class="listitem">IP-less setups - <code class="literal">ifconfig-noexec</code></li><li class="listitem">Port sharing with an HTTPS server</li><li class="listitem">Routing features - <code class="literal">redirect-private</code>, <code class="literal">allow-pull-fqdn</code></li><li class="listitem">Filtering out pushed options</li><li class="listitem">Handing out public IP addresses</li></ul></div><div><div><div><div><h1 class="title"><a id="ch10lvl1sec107"/>Introduction</h1></div></div></div><p>The recipes in this last chapter will cover the advanced configuration of OpenVPN. This chapter will focus on some of the less well-known configuration options that OpenVPN offers, as well as some advanced recipes for real-life deployments. The recipes will cover both advanced server configuration, such as the use of connection blocks and inline certificates, as well as advanced client configuration, such as using a proxy server to connect to an OpenVPN server.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec108"/>Including configuration files in config files</h1></div></div></div><p>One of the lesser-known possibilities when using configuration files is the ability to include other configuration files. This can be especially handy when setting up a complex OpenVPN server, where multiple OpenVPN instances are offered simultaneously. The common configuration directives can be stored in a single file, whereas the connection-specific parts can be stored in a file for each instance. In this recipe, we will set up two OpenVPN instances, one using UDP and the other using TCP as the transport protocol.</p><p>Note that this option does not allow for the sharing of VPN IP address ranges between instances.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec403"/>Getting ready</h2></div></div></div><p>Set up the client and server certificates using the first recipe from <a class="link" title="Chapter 2.  Client-server IP-only Networks" href="part0025.xhtml#aid-NQU21">Chapter 2</a>, <em>Client-server IP-only Networks</em>. For this recipe, the server computer was running CentOS 6 Linux and OpenVPN 2.3.11.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec404"/>How to do it...</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">First, create the common configuration file:<pre class="programlisting">        dev tun 
 
        ca       /etc/openvpn/cookbook/ca.crt 
        cert     /etc/openvpn/cookbook/server.crt 
        key      /etc/openvpn/cookbook/server.key 
        dh       /etc/openvpn/cookbook/dh2048.pem 
        tls-auth /etc/openvpn/cookbook/ta.key 0 
 
        persist-key 
        persist-tun 
        keepalive 10 60 
 
        push "route 10.198.0.0 255.255.0.0" 
        topology subnet 
 
        user  nobody 
        group nobody 
 
        daemon 
</pre><p>Save it as <code class="literal">example10-1-common.conf</code>. Note that this configuration file does not include a protocol specification or server line. Also, note that we will be using the same server certificate for both OpenVPN instances.</p></li><li class="listitem">Next, create the following server configuration file for UDP-based connections:<pre class="programlisting">        config example10-1-common.conf 
 
        proto udp 
        port 1194 
        server 10.200.0.0 255.255.255.0 
 
        log-append /var/log/openvpn-udp.log 
</pre><p>Save it as <code class="literal">example10-1-server1.conf</code>.</p></li><li class="listitem">And createa server configuration file for TCP-based connections:<pre class="programlisting">        config example10-1-common.conf 
 
        proto tcp 
        port 443 
        server 10.201.0.0 255.255.255.0 
 
        log-append /var/log/openvpn-tcp.log 
</pre><p>Save it as <code class="literal">example10-1-server2.conf</code>. This instance is listening on the HTTPS port<code class="literal">443</code>, which is an often-used trick to circumvent very strict firewalls, or to work around a badly configured firewall.</p></li><li class="listitem">Start both servers:<pre class="programlisting">
<strong>[root@server]# openvpn --config example10-1-server1.conf</strong>
<strong>[root@server]# openvpn --config example10-1-server2.conf</strong>
</pre><p>Check the log files to see if both the servers have successfully started.</p></li></ol><div></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec405"/>How it works...</h2></div></div></div><p>OpenVPN configuration files are treated very similarly to command line options. As the <code class="literal">--config</code> command line option is used almost always, it is also possible to use it inside a configuration file again. This allows for a split in the configuration options, where directives that are common to all OpenVPN instances can be stored in a single file for easy maintenance. The instance-specific directives (such as the <code class="literal">server</code> directive) can then be stored in much smaller configuration files, which are also less likely to change over time. This again eases maintenance of a large-scale OpenVPN server setup.</p><p>OpenVPN has a built-in protection mechanism to avoid including the same configuration file recursively.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec109"/>Multiple remotes and remote-random</h1></div></div></div><p>OpenVPN has (limited) built-in support for automatic failover and load-balancing: if the connection to one OpenVPN server cannot be established, then the next configured server is chosen. The <code class="literal">remote-random</code> directive can be used to load-balance many OpenVPN clients across multiple OpenVPN servers. In this recipe, we will set up two OpenVPN servers and then use the <code class="literal">remote-random</code> directive to have a client choose either one of the two servers.</p><p>Note that OpenVPN does not offer transparent failover, in which case the existing connections are transparently migrated to another server. Transparent failover is much harder to achieve with a VPN setup (not just OpenVPN), as the secure session keys need to be migrated from one server to the other as well. This is currently not possible with OpenVPN.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec406"/>Getting ready</h2></div></div></div><p>We will use the following network layout:</p><div><img src="img/image00431.jpeg" alt="Getting ready"/></div><p style="clear:both; height: 1em;"> </p><p>Set up the client and server certificates using the first recipe from <a class="link" title="Chapter 2.  Client-server IP-only Networks" href="part0025.xhtml#aid-NQU21">Chapter 2</a>, <em>Client-server IP-only Networks</em>. For this recipe, the server computer was running CentOS 6 Linux and OpenVPN 2.3.11. The client was running Fedora 22 Linux and OpenVPN 2.3.11. Keep the configuration file, <code class="literal">basic-udp-server.conf</code>, from the <em>Server-side routing</em> recipe from <a class="link" title="Chapter 2.  Client-server IP-only Networks" href="part0025.xhtml#aid-NQU21">Chapter 2</a>, <em>Client-server IP-only Networks</em>, as well as the client configuration file, <code class="literal">basic-udp-client.conf</code> at hand.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec407"/>How to do it...</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Start both servers:<pre class="programlisting">
<strong>[root@server1]# openvpn --config basic-udp-server.conf</strong>
<strong>[root@server2]# openvpn --config basic-udp-server.conf</strong>
</pre><p>Check the log files to see that both the servers have successfully started.</p><p>Note that we can use the exact same configuration file on both servers. By using masquerading, the VPN clients will appear to come from either <code class="literal">server1</code> or <code class="literal">server2</code>.</p></li><li class="listitem">Set up masquerading on both servers:<pre class="programlisting">
<strong>[root@server1]# iptables -t nat -I POSTROUTING -o eth0 \</strong>
<strong>    -j MASQUERADE</strong>
<strong>[root@server2]# iptables -t nat -I POSTROUTING -o eth0 \</strong>
<strong>    -j MASQUERADE</strong>
</pre></li><li class="listitem">Create the client configuration file:<pre class="programlisting">        client 
        proto udp 
        remote openvpnserver1.example.com 1194 
        remote openvpnserver2.example.com 1194 
        remote-random 
        dev tun 
        nobind 
 
        remote-cert-tls server 
        tls-auth /etc/openvpn/cookbook/ta.key 1 
        ca       /etc/openvpn/cookbook/ca.crt 
        cert     /etc/openvpn/cookbook/client1.crt 
        key     /etc/openvpn/cookbook/client1.key 
</pre></li><li class="listitem">Save it as <code class="literal">example10-2-client.conf</code>.</li><li class="listitem">Start the client:<pre class="programlisting">
<strong>[root@client]# openvpn --config example10-2-client.conf</strong>
</pre></li></ol><div></div><p>The OpenVPN client will randomly choose which server to connect to.</p><p>After the connection has been established, stop the first OpenVPN process on the server that the client connected to:</p><pre class="programlisting">
<strong>[root@server1]# killall openvpn</strong>
</pre><p>And wait for the client to reconnect. After the default timeout period, the client will reconnect to an alternate server.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec408"/>How it works...</h2></div></div></div><p>When the OpenVPN client starts up and <code class="literal">remote-random</code> is specified, it randomly picks a server from the list of available remote servers. If the VPN connection to this server cannot be established, it will pick the next server from the list, and so on. When the VPN connection is dropped, for example, due to a failing server, the OpenVPN client will try to reconnect after a default timeout period. In the server configuration file used in the <em>Server-side routing</em> recipe from <a class="link" title="Chapter 2.  Client-server IP-only Networks" href="part0025.xhtml#aid-NQU21">Chapter 2</a>, <em>Client-server IP-only Networks</em>, the timeout period is configured using the <code class="literal">keepalive</code> option.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec409"/>There's more...</h2></div></div></div><p>When setting up a failover OpenVPN solution there are many things to consider, some of which are outlined here.</p><div><div><div><div><h3 class="title"><a id="ch10lvl3sec83"/>Mixing TCP and UDP-based setups</h3></div></div></div><p>It is also possible to mix TCP and UDP-based setups by specifying the protocol type with the <code class="literal">remote</code> directive:</p><pre class="programlisting">remote openvpnserver1.example.com 1194 udp 
remote openvpnserver2.example.com 1194 tcp 
</pre><p>It is much handier to use connection blocks in this case. The use of connection blocks is explained later in this chapter.</p></div><div><div><div><div><h3 class="title"><a id="ch10lvl3sec84"/>Advantage of using TCP-based connections</h3></div></div></div><p>There is one major advantage when using a TCP-based setup in combination with a failover solution. If the OpenVPN server to which a client is connected is unavailable, the TCP connection will fail almost immediately. This leads to a very short timeout period after which the OpenVPN client will try to reconnect. With a UDP-based setup, the client cannot so easily detect whether the server is unavailable and must first wait for the <code class="literal">keepalive</code> timeout to pass.</p></div><div><div><div><div><h3 class="title"><a id="ch10lvl3sec85"/>Automatically reverting to the first OpenVPN server</h3></div></div></div><p>A question that is asked from time to time is whether it is possible to configure OpenVPN to also support automatic reverting: a second OpenVPN instance is set up to provide a failover solution. When the main OpenVPN server is unavailable, the backup instance takes over. However, when the main OpenVPN server comes back online, the clients are not automatically reconnected to the main server. For this, a client reset (or server reset of the second OpenVPN instance) is required. It is possible to achieve this using scripting but it depends largely on what type of connectivity is considered acceptable: it takes some time for an OpenVPN client to detect when the remote server is not responding and to reconnect. The VPN connectivity will be intermittent in such a setup. Especially when the network connection to the main OpenVPN server is not stable, this can lead to very low availability.</p><p>A quick and dirty method to have all clients revert back to the first server is to use the management interface on the second server and disconnect all clients.</p></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec410"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem">The <em>Server-side routing</em> recipe from <a class="link" title="Chapter 2.  Client-server IP-only Networks" href="part0025.xhtml#aid-NQU21">Chapter 2</a>, <em>Client-server IP-only Networks</em>, which explains the basic setup of OpenVPN</li><li class="listitem">The C<em>onnection blocks</em> recipe, which shows an alternate and more flexible method for supporting multiple servers in a single client configuration file</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec110"/>Inline certificates</h1></div></div></div><p>To ease the deployment of OpenVPN configuration, and public and private key files, a new feature is available to include all of them in a single file. This is done by integrating the contents of the <code class="literal">ca</code>, <code class="literal">cert</code>, <code class="literal">key</code>, and optionally the <code class="literal">tls-auth</code> file into the client configuration file itself. In this recipe, we will set up such a configuration file and use it to connect to our standard OpenVPN server.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec411"/>Getting ready</h2></div></div></div><p>We will use the following network layout:</p><div><img src="img/image00432.jpeg" alt="Getting ready"/></div><p style="clear:both; height: 1em;"> </p><p>Set up the client and server certificates using the first recipe from <a class="link" title="Chapter 2.  Client-server IP-only Networks" href="part0025.xhtml#aid-NQU21">Chapter 2</a>, <em>Client-server IP-only Networks</em>. For this recipe, the server computer was running CentOS 6 Linux and OpenVPN 2.3.11. The client was running Fedora 22 Linux and OpenVPN 2.3.11. Keep the configuration file, <code class="literal">basic-udp-server.conf</code>, from the <em>Server-side routing</em> recipe from <a class="link" title="Chapter 2.  Client-server IP-only Networks" href="part0025.xhtml#aid-NQU21">Chapter 2</a>, <em>Client-server IP-only Networks</em> at hand, as well as the client configuration file, <code class="literal">basic-udp-client.conf</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec412"/>How to do it...</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">First, start the server:<pre class="programlisting">
<strong>[root@server]# openvpn --config basic-udp-server.conf</strong>
</pre></li><li class="listitem">Create the client configuration file:<pre class="programlisting">        client 
        proto udp 
        remote openvpnserver.example.com 
        port 1194 
        dev tun 
        nobind 
 
        remote-cert-tls server 
        key-direction 1 
 
        &lt;ca&gt; 
        -----BEGIN CERTIFICATE----- 
        # insert base64 blob from ca.crt 
        -----END CERTIFICATE----- 
        &lt;/ca&gt; 
 
        &lt;cert&gt; 
        -----BEGIN CERTIFICATE----- 
        # insert base64 blob from client1.crt 
        -----END CERTIFICATE----- 
        &lt;/cert&gt; 
 
        &lt;key&gt; 
        -----BEGIN PRIVATE KEY----- 
        # insert base64 blob from client1.key 
        -----END PRIVATE KEY----- 
        &lt;/key&gt; 
 
        &lt;tls-auth&gt; 
        -----BEGIN OpenVPN Static key V1----- 
        # insert ta.key 
        -----END OpenVPN Static key V1----- 
        &lt;/tls-auth&gt; 
</pre><p>Insert the contents of the <code class="literal">ca.crt</code>, <code class="literal">client1.crt</code>, <code class="literal">client1.key</code> and <code class="literal">ta.key</code> files in the configuration. Save it as <code class="literal">example10-3-client.conf</code>.</p></li><li class="listitem">Then, connect the client:<pre class="programlisting">
<strong>[root@client]# openvpn --config example10-3-client.conf</strong>
</pre></li></ol><div></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec413"/>How it works...</h2></div></div></div><p>When OpenVPN parses the configuration file, it scans for the directives <code class="literal">ca</code>, <code class="literal">cert</code>, <code class="literal">key</code>, and <code class="literal">tls-auth</code>, (and <code class="literal">dh</code> for server configuration files), but also for XML-like blobs starting with <code class="literal">&lt;ca&gt;</code>, <code class="literal">&lt;cert&gt;</code>, <code class="literal">&lt;key&gt;</code>, <code class="literal">&lt;tls-auth&gt;</code> and <code class="literal">&lt;dh&gt;</code> respectively. If an XML-like block is found, then the contents of this XML-like block are then read and treated in the same manner as when a file is specified. When all the required configuration files or blocks are present, the connection is established.</p><p>Note that it is not required to treat all of the aforementioned configuration directives in the same manner. It is also possible to only specify an inline-block for the CA certificate and <code class="literal">tls-auth</code> files, as these files tend to be static for all the clients.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec414"/>There's more...</h2></div></div></div><p>As stated in the first version of the OpenVPN 2 Cookbook, it was also possible to specify an inline file using the <code class="literal">[[inline]]</code> tag. However, this tag was never properly documented and starting with OpenVPN 2.3 it is no longer functional.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec111"/>Connection blocks</h1></div></div></div><p>Similar to the inline certificates used in the previous recipe, it is also possible to specify connection blocks. These connection blocks are treated as multiple definitions for remote servers and they are tried in order until a VPN connection is established. The advantage of using a connection block is that for each remote server, server-specific parameters can be specified, such as the protocol (UDP or TCP), the remote port, whether a proxy server should be used, and so on.</p><p>In this recipe, we will set up two servers, one listening on a UDP port and the other on a TCP port. We will then configure the OpenVPN client to try the first server using a UDP connection. If the connection cannot be established, the client will attempt to connect to the second server using a TCP connection.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec415"/>Getting ready</h2></div></div></div><p>We will use the following network layout:</p><div><img src="img/image00433.jpeg" alt="Getting ready"/></div><p style="clear:both; height: 1em;"> </p><p>Set up the client and server certificates using the first recipe from <a class="link" title="Chapter 2.  Client-server IP-only Networks" href="part0025.xhtml#aid-NQU21">Chapter 2</a>, <em>Client-server IP-only Networks</em>. For this recipe, the server computer was running CentOS 6 Linux and OpenVPN 2.3.11. The client was running Fedora 22 Linux and OpenVPN 2.3.11. Keep the configuration file, <code class="literal">basic-udp-server.conf</code>, from the <em>Server-side routing</em> recipe from <a class="link" title="Chapter 2.  Client-server IP-only Networks" href="part0025.xhtml#aid-NQU21">Chapter 2</a>, <em>Client-server IP-only Networks</em>, as well as the server configuration file, <code class="literal">example8-9-server.conf</code>, from the <em>Tuning TCP-based connections</em> recipe from <a class="link" title="Chapter 8. Performance Tuning" href="part0092.xhtml#aid-2NNJO1">Chapter 8</a>, <em>Performance Tuning</em>.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec416"/>How to do it...</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Start both the servers:<pre class="programlisting">
<strong>[root@server1]# openvpn --config basic-udp-server.conf</strong>
<strong>[root@server2]# openvpn --config example8-9-server.conf</strong>
</pre></li><li class="listitem">Check the log files to check that both the servers have successfully started.</li><li class="listitem">Create the client configuration file:<pre class="programlisting">        client 
        dev tun 
 
        &lt;connection&gt; 
        remote openvpnserver1.example.com 
        proto udp 
        port 1194 
        &lt;/connection&gt; 
 
        &lt;connection&gt; 
        remote openvpnserver2.example.com 
        proto tcp 
        port 1194 
        &lt;/connection&gt; 
 
        remote-cert-tls server 
        ca       /etc/openvpn/cookbook/ca.crt 
        cert     /etc/openvpn/cookbook/client1.crt 
        key      /etc/openvpn/cookbook/client1.key 
        tls-auth /etc/openvpn/cookbook/ta.key 1 
</pre></li><li class="listitem">Save it as <code class="literal">example10-4-client.conf</code>.</li><li class="listitem">Start the client:<pre class="programlisting">
<strong>[root@client]# openvpn --config example10-4-client.conf</strong>
</pre></li><li class="listitem">After the connection has been established, stop the first OpenVPN process on the server that the client connected to:<pre class="programlisting">
<strong>[root@server1]# killall openvpn</strong>
</pre><p>And wait for the client to reconnect. After the default timeout period, the client will reconnect to the alternate server using the TCP protocol.</p></li></ol><div></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec417"/>How it works...</h2></div></div></div><p>When the OpenVPN client starts up, it attempts to connect to the server specified in the first <code class="literal">&lt;connection&gt;</code> block. If that connection fails, it will try the next <code class="literal">&lt;connection&gt;</code> block entry and so forth. When an OpenVPN server becomes unavailable or is stopped, the client will automatically restart and try to connect to the first available OpenVPN server again.</p><p>The OpenVPN client first parses the global directives, which are specified outside the <code class="literal">&lt;connection&gt;</code> blocks. For each block, the global directives are then overruled using block-specific directives. This makes it easier to specify in the <code class="literal">&lt;connection&gt; </code>blocks only those parameters that are different for each connection.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec418"/>There's more...</h2></div></div></div><p>Connection blocks, as well as inline certificates, are very handy features to easily distribute OpenVPN configurations using a single file. However, a consequence of these features is that the use of the command line to overrule the directives specified in the configuration file becomes harder, if not impossible. There are a few other things to keep in mind when using connection blocks.</p><div><div><div><div><h3 class="title"><a id="ch10lvl3sec86"/>Allowed directives inside connection blocks</h3></div></div></div><p>There are only a few directives allowed inside a connection block:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">bind</code> and <code class="literal">bind-ipv6</code></li><li class="listitem"><code class="literal">connect-retry</code>, <code class="literal">connect-retry-max</code>, and <code class="literal">connect-timeout</code></li><li class="listitem"><code class="literal">explicit-exit-notify</code></li><li class="listitem"><code class="literal">float</code></li><li class="listitem"><code class="literal">http-proxy</code>, <code class="literal">http-proxy-option</code>, <code class="literal">http-proxy-retry</code>, and <code class="literal">http-proxy-timeout</code></li><li class="listitem"><code class="literal">link-mtu</code> and <code class="literal">link-mtu-extra</code></li><li class="listitem"><code class="literal">local lport</code></li><li class="listitem"><code class="literal">mssfix</code></li><li class="listitem"><code class="literal">nobind</code></li><li class="listitem"><code class="literal">port</code></li><li class="listitem"><code class="literal">proto</code></li><li class="listitem"><code class="literal">remote</code> and <code class="literal">rport</code></li><li class="listitem"><code class="literal">socks-proxy</code> and <code class="literal">socks-proxy-retry</code></li><li class="listitem"><code class="literal">tun-mtu</code> and <code class="literal">tun-mtu-extra</code></li></ul></div><p>All other directives are considered global and can only be specified once.</p></div><div><div><div><div><h3 class="title"><a id="ch10lvl3sec87"/>Pitfalls when mixing TCP and UDP-based setups</h3></div></div></div><p>Connection blocks make it very easy to mix TCP and UDP-based setups. The downside is that the global parameters specified in the configuration file must be valid for both the TCP and UDP-based setups.</p></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec419"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem">The <em>Multiple remotes and remote-random </em>recipe earlier in this chapter, which explains how to achieve the same setup without using connection blocks</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec112"/>Details of ifconfig-pool-persist</h1></div></div></div><p>One of the options available in OpenVPN that can lead to a lot of confusion is <code class="literal">ifconfig-pool-persist</code>. This directive tells the OpenVPN server to maintain a persistent list of IP addresses handed out to different clients. When a client reconnects at a later time, the previously-used address is reused. This is only one of three methods for assigning static addresses to an OpenVPN client. The other two methods are:</p><div><ul class="itemizedlist"><li class="listitem">Using an <code class="literal">ifconfig-push</code> statement in a client-connect script</li><li class="listitem">Using an <code class="literal">ifconfig-push</code> statement in a client-configuration file</li></ul></div><p>Both of these take precedence over the entries found in the <code class="literal">ifconfig-pool-persist</code> file. Experience has shown that it is often a good idea to temporarily disable this option when an OpenVPN setup is not working properly.</p><p>In this recipe, we will demonstrate how to use <code class="literal">ifconfig-pool-persist</code> and what the pitfalls are.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec420"/>Getting ready</h2></div></div></div><p>We will use the following network layout:</p><div><img src="img/image00434.jpeg" alt="Getting ready"/></div><p style="clear:both; height: 1em;"> </p><p>Set up the client and server certificates using the first recipe from <a class="link" title="Chapter 2.  Client-server IP-only Networks" href="part0025.xhtml#aid-NQU21">Chapter 2</a>, <em>Client-server IP-only Networks</em>. For this recipe, the server computer was running CentOS 6 Linux and OpenVPN 2.3.11. The client was running Fedora 22 Linux and OpenVPN 2.3.11. Keep the configuration file, <code class="literal">basic-udp-server.conf</code>, from the <em>Server-side routing</em> recipe from <a class="link" title="Chapter 2.  Client-server IP-only Networks" href="part0025.xhtml#aid-NQU21">Chapter 2</a>, <em>Client-server IP-only Networks</em> at hand, as well as the client configuration file, <code class="literal">basic-udp-client.conf</code>, from the same recipe. The second client was running Windows 7 64 bit and OpenVPN 2.3.11. For this client, keep the client configuration file, <code class="literal">basic-udp-client.ovpn</code>, from the <em>Using an ifconfig-pool block</em> recipe from <a class="link" title="Chapter 2.  Client-server IP-only Networks" href="part0025.xhtml#aid-NQU21">Chapter 2</a>, <em>Client-server IP-only Networks</em> at hand.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec421"/>How to do it...</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Create the server configuration file by adding the following line to the <code class="literal">basic-udp-server.conf</code> file:<pre class="programlisting">
<strong>ifconfig-pool-persist /etc/openvpn/cookbook/ipp.txt</strong>
</pre></li><li class="listitem">Save it as <code class="literal">example10-4-server.conf</code> file.</li><li class="listitem">Start the server:<pre class="programlisting">
<strong>[root@server]# openvpn --config example10-4-server.conf</strong>
</pre><p>An empty file, <code class="literal">/etc/openvpn/cookbook/ipp.txt</code>, will be created as the server starts up.</p></li><li class="listitem">Connect the first client:<pre class="programlisting">
<strong>[root@client]# openvpn --config basic-udp-client.conf</strong>
</pre><p>Normally, this client will be assigned <code class="literal">10.200.0.2</code>, which is the first available IP address in the <code class="literal">server</code> IP range.</p></li><li class="listitem">Stop both the client and the server. List the contents of the <code class="literal">ipp.txt</code> file:<pre class="programlisting">
<strong>[root@server]# cat /etc/openvpn/cookbook/ipp.txt</strong>
<strong>client1,10.200.0.2</strong>
</pre></li><li class="listitem">Start the server again. Now, connect the second client, which has a different certificate:<div><img src="img/image00435.jpeg" alt="How to do it..."/></div><p style="clear:both; height: 1em;"> </p><p>This client will now be assigned the address <code class="literal">10.200.0.3</code>. Without the <code class="literal">ifconfig-pool-persist</code> option, it would have been assigned the first available address, which is  <code class="literal">10.200.0.2</code>.</p></li></ol><div></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec422"/>How it works...</h2></div></div></div><p>When the OpenVPN server starts, it reads the <code class="literal">ipp.txt</code> file, if it exists, and it tries to re-assign the IP addresses to the client certificates found in the file. Whenever an OpenVPN client with one of the existing client certificates connects, it is assigned the address found in the <code class="literal">ipp.txt</code> file, unless the server VPN IP address space is too small for the number of already-connected clients. In that case, the client receives the first available address from the server VPN IP address space.</p><p>The first client that connected received the first available address, <code class="literal">10.200.0.2</code>, from the VPN IP server address range. When the OpenVPN server shuts down, this information is recorded in the <code class="literal">ipp.txt</code> file. The second time the OpenVPN server started, this information was reloaded and the address, <code class="literal">10.200.0.2</code>, was held in reserve for the client with certificate <code class="literal">client1</code>. When the second client connected with certificate <code class="literal">client2</code>, it received the next available address in the server VPN IP address range, which is <code class="literal">10.200.0.3</code>. When the server shuts down again, this information is also recorded in the <code class="literal">ipp.txt</code> file.</p><p>This means that from now on, the first client will always receive the <code class="literal">.2</code> address and the second client the <code class="literal">.3</code> address. However, it is not a guarantee that the listed IP addresses will be assigned to a particular client certificate. The exception occurs when many VPN clients connect to the server. If the VPN IP address range is exhausted and the first client is not connected at that time, its address is recycled for other VPN clients. If the client with certificate <code class="literal">client1</code> then tries to connect to the server, it will be assigned the first available address. For a guaranteed assignment, a <code class="literal">client-config-dir</code> file should be used.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec423"/>There's more...</h2></div></div></div><p>When using the <code class="literal">ifconfig-pool-persist</code> directive, there are a few pitfalls to watch out for.</p><div><div><div><div><h3 class="title"><a id="ch10lvl3sec88"/>Specifying the update interval</h3></div></div></div><p>Because we did not explicitly specify an update interval, the <code class="literal">ipp.txt</code> file is updated every 600 seconds (10 minutes). This can also be seen by looking at the <code class="literal">ipp.txt</code> file right after a new client connects: the newly-found client certificate and VPN IP are not listed in the <code class="literal">ipp.txt</code> file until the first update interval passes or when the OpenVPN server process shuts down.</p><p>It is also possible to specify an update interval of 0 seconds, which means that the <code class="literal">ipp.txt</code> file is never updated. This causes the OpenVPN server to associate IP addresses with the client certificate names found in the <code class="literal">ipp.txt</code> file at the startup but these associations will never change afterwards.</p></div><div><div><div><div><h3 class="title"><a id="ch10lvl3sec89"/>Caveat - the duplicate-cn option</h3></div></div></div><p>The <code class="literal">duplicate-cn</code> option can be used to allow the same client certificate to connect to the same server a number of times. If this option is used, the <code class="literal">ifconfig-pool-persist</code> option becomes useless, as the same client certificate will be connected twice. This means that the OpenVPN server has to hand out two different IP addresses to each client and the entry in the <code class="literal">ipp.txt</code> file becomes meaningless.</p></div><div><div><div><div><h3 class="title"><a id="ch10lvl3sec90"/>When topology net30 is used</h3></div></div></div><p>When the server option <code class="literal">topology net30</code> is used, the format of the <code class="literal">ipp.txt</code> file is slightly different. In the <code class="literal">net30</code> topology mode, each client is assigned a <code class="literal">/30</code> network address consisting of four IP addresses: the network address, the VPN server endpoint address, the actual client VPN IP address, and the broadcast address for the <code class="literal">/30</code> network. In the <code class="literal">ipp.txt</code> file, the first of these is recorded:</p><pre class="programlisting">client1,10.200.0.4 
client2,10.200.0.8 
</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec113"/>Connecting using a SOCKS proxy</h1></div></div></div><p>Under certain circumstances, it is not possible to directly connect to an OpenVPN server. This happens most often when firewalls are restricting UDP-based traffic. In such cases, OpenVPN can connect to an OpenVPN server via an intermediary host known as a proxy. OpenVPN supports two types of proxies, SOCKS and HTTP-based, both of which work only using TCP-based configurations. This recipe will outline how to access an OpenVPN server via a SOCKS proxy, whereas the next two recipes will show how to use an HTTP proxy, both with and without authentication.</p><p>SOCKS proxies can very easily be set up using almost any SSH client. On Linux and Mac OS X, it can be done using the <code class="literal">ssh</code> or <code class="literal">slogin</code> commands, whereas, on Windows, the free SSH client PuTTY can be used. In this recipe, we will use SSH on a Linux client to set up a public SOCKS proxy. A Windows OpenVPN client will connect using this proxy.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec424"/>Getting ready</h2></div></div></div><p>We will use the following network layout:</p><div><img src="img/image00436.jpeg" alt="Getting ready"/></div><p style="clear:both; height: 1em;"> </p><p>Set up the client and server certificates using the first recipe from <a class="link" title="Chapter 2.  Client-server IP-only Networks" href="part0025.xhtml#aid-NQU21">Chapter 2</a>, <em>Client-server IP-only Networks</em>. For this recipe, the server computer was running CentOS 6 Linux and OpenVPN 2.3.12. The client was running Windows 7 64 bit and OpenVPN 2.3.10. Keep the configuration file, <code class="literal">example8-9-server.conf</code>, from the <em>Tuning TCP-based connections</em> recipe from <a class="link" title="Chapter 8. Performance Tuning" href="part0092.xhtml#aid-2NNJO1">Chapter 8</a>, <em>Performance Tuning</em> at hand. For the client, keep the configuration file, <code class="literal">basic-tcp-client.ovpn</code>, from <em>Using an ifconfig-pool block</em> recipe from the <a class="link" title="Chapter 2.  Client-server IP-only Networks" href="part0025.xhtml#aid-NQU21">Chapter 2</a>, <em>Client-server IP-only Networks</em> at hand.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec425"/>How to do it...</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Start the server:<pre class="programlisting">
<strong>[root@server]# openvpn --config example8-9-server.conf</strong>
</pre></li><li class="listitem">Right-click on the OpenVPN GUI tray icon and select <strong>Settings</strong>. Fill in the name or IP address of the <strong>SOCKS proxy</strong> host, and then click on <strong>OK</strong>:<div><img src="img/image00437.jpeg" alt="How to do it..."/></div><p style="clear:both; height: 1em;"> </p></li><li class="listitem">Set up a <strong>SOCKS proxy</strong> by setting up an SSH connection on the intermediary proxy host. The destination address for the SSH connection is a server which can reach the OpenVPN server:<pre class="programlisting">
<strong>[socks-proxy]$ ssh -g -D 1080 remote-host.example.com</strong>
</pre></li><li class="listitem">Now start the OpenVPN client in another terminal window:<div><img src="img/image00438.jpeg" alt="How to do it..."/></div><p style="clear:both; height: 1em;"> </p><div><img src="img/image00439.jpeg" alt="How to do it..."/></div><p style="clear:both; height: 1em;"> </p></li><li class="listitem">The connection log will show that OpenVPN first connects to the remote proxy host (in this screenshot, the IP address <code class="literal">192.168.3.17</code> was used). This connection is then forwarded to the OpenVPN server and the VPN is established:<div><img src="img/image00440.jpeg" alt="How to do it..."/></div><p style="clear:both; height: 1em;"> </p></li></ol><div></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec426"/>How it works...</h2></div></div></div><p>A <strong>SOCKS proxy</strong> host acts as an intermediary between the (OpenVPN) client and the server. SOCKS proxies can also be configured in most web browsers and are often used to gain access through a hotel or corporate firewall. The client first connects to the <strong>SOCKS proxy</strong> host and then requests a new connection to the actual endpoint, which is the OpenVPN server in this case. If the connection is allowed by the SOCKS host, the connection is established and the VPN connection can be set up.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec427"/>There's more...</h2></div></div></div><p>Before using a proxy host to set up a VPN connection, there are a few things to consider:</p><div><div><div><div><h3 class="title"><a id="ch10lvl3sec91"/>Performance</h3></div></div></div><p>Proxy hosts tend to have a severe impact on the performance of a VPN setup. Both the bandwidth and the latency are usually affected when proxy hosts are used. This is mostly caused by having to connect to a separate host. There is little that can be done about this drop in performance.</p></div><div><div><div><div><h3 class="title"><a id="ch10lvl3sec92"/>SOCKS proxies via SSH</h3></div></div></div><p>SSH can be a very handy tool to set up a <strong>SOCKS proxy</strong> host, over which an OpenVPN connection can be set up. Apart from the drawback mentioned above, this introduces another penalty: both the SSH connection and the VPN connection will normally be encrypted. Thus, tunneling traffic over an encrypted VPN link, which in itself is tunneled over an encrypted SSH link, is double encrypted!</p><p>A question that you should ask yourself if you are tunneling VPN traffic over an SSH tunnel is: why? What type of traffic needs to be tunneled over a VPN link that cannot be tunneled via a SOCKS-over-SSH tunnel? Most modern web browsers and e-mail clients have built-in support for SOCKS hosts, eliminating the need for a full-blown VPN. File sharing protocols such as Windows file sharing (<strong>Common Internet File System</strong> (<strong>CIFS</strong>)) can also be tunneled over an SSH connection. In those cases, a VPN tunnel adds only extra complexity.</p></div><div><div><div><div><h3 class="title"><a id="ch10lvl3sec93"/>SOCKS proxies using plain-text authentication</h3></div></div></div><p>In OpenVPN 2.2 and higher, support is added to connect to a SOCKS proxy that required authentication. For OpenVPN 2.2, plain-text authentication support is added. Though the name "plain text" may suggest otherwise, the authentication mechanism is secure, as the connection to the <strong>SOCKS proxy</strong> host is encrypted first.</p></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec428"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem">The next two recipes in this chapter will deal with connecting an OpenVPN client to a server via an HTTP proxy</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec114"/>Connecting via an HTTP proxy</h1></div></div></div><p>As stated in the previous recipe, it is not possible to directly connect to an OpenVPN server under certain circumstances. In such cases, OpenVPN can connect to an OpenVPN server via an intermediary host known as a proxy. This recipe will outline how to access an OpenVPN server via an roxy.</p><p>The HTTP proxy used in this recipe is a Linux-based Apache <code class="literal">httpd</code> server with the <code class="literal">mod_proxy</code> module loaded. This module can be configured to allow <code class="literal">CONNECT</code> requests. This type of request is needed to connect to secure web servers (HTTPS) as well as to an OpenVPN server. If the <code class="literal">CONNECT</code> request is not allowed, then the HTTP proxy cannot be used to set up an OpenVPN connection.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec429"/>Getting ready</h2></div></div></div><p>We will use the following network layout:</p><div><img src="img/image00441.jpeg" alt="Getting ready"/></div><p style="clear:both; height: 1em;"> </p><p>Set up the client and server certificates using the first recipe from <a class="link" title="Chapter 2.  Client-server IP-only Networks" href="part0025.xhtml#aid-NQU21">Chapter 2</a>, <em>Client-server IP-only Networks</em>. For this recipe, the server computer was running CentOS 6 Linux and OpenVPN 2.3.12. The client was running Windows 7 64 bit and OpenVPN 2.3.11. Keep the configuration file, <code class="literal">example8-9-server.conf</code>, from the <em>Tuning TCP-based connections</em> recipe from <a class="link" title="Chapter 8. Performance Tuning" href="part0092.xhtml#aid-2NNJO1">Chapter 8</a>, <em>Performance Tuning</em>, as well as the client configuration file, <code class="literal">example8-9.ovpn</code>, from the same recipe.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec430"/>How to do it...</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Start the server:<pre class="programlisting">
<strong>[root@server]# openvpn --config example8-9-server.conf</strong>
</pre></li><li class="listitem">Modify the client configuration file, <code class="literal">example8-9.ovpn</code>, by adding the lines:<pre class="programlisting">
<strong>http-proxy http-proxy-host 80</strong>
<strong>verb 4</strong>
</pre><p>Here, <code class="literal">http-proxy-host</code> is either the name or the IP address of the host running the HTTP proxy software. In this recipe, the HTTP proxy was running on the HTTP default port <code class="literal">80</code>. Save the configuration file as <code class="literal">example10-6.ovpn</code>.</p></li><li class="listitem">Start the client, and then check the connection log.<p>The connection log will show that the OpenVPN client first connects to the HTTP proxy host and then sends an <code class="literal">HTTP 'CONNECT'</code> request to connect to the OpenVPN server:</p><div><img src="img/image00442.jpeg" alt="How to do it..."/></div><p style="clear:both; height: 1em;"> </p><p>The HTTP proxy host responds with the HTTP code <code class="literal">200</code> meaning <code class="literal">OK</code>, after which the VPN connection is established.</p></li></ol><div></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec431"/>How it works...</h2></div></div></div><p>An HTTP proxy host acts as an intermediary between the (OpenVPN) client and the server. HTTP proxies can be configured in most web browsers and are often used to gain access through a hotel or a corporate firewall. The client first connects to the HTTP proxy host and then requests a new connection to the actual endpoint using the <code class="literal">HTTP 'CONNECT'</code> request. If the HTTP proxy host allows the <code class="literal">CONNECT</code> request, the HTTP code <code class="literal">200</code> is returned and the connection to the OpenVPN server is granted. From here on, the OpenVPN connection is set up in a similar fashion to a regular TCP-based setup.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec432"/>There's more...</h2></div></div></div><p>When using an HTTP proxy host to connect to an OpenVPN server, there are a few caveats.</p><div><div><div><div><h3 class="title"><a id="ch10lvl3sec94"/>http-proxy options</h3></div></div></div><p>There are a few options available in OpenVPN to configure the way in which OpenVPN connects with the HTTP proxy host:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">http-proxy-timeout</code> (<code class="literal">n</code>): This sets the timeout when connecting to the HTTP proxy host to (<code class="literal">n</code>) seconds. The default value is 5 seconds.</li><li class="listitem"><code class="literal">http-proxy-option AGENT</code> (<code class="literal">string</code>): This sets the HTTP agent to (<code class="literal">string</code>) when connecting to the HTTP proxy host. Some proxies allow connections from "well-known" web browsers only.</li><li class="listitem"><code class="literal">http-proxy-option VERSION 1.1</code>: This sets the HTTP protocol version to 1.1. The default is HTTP/1.0. OpenVPN 2.1 is not fully HTTP/1.1 compliant when connecting to an HTTP proxy host, causing some proxies to refuse access. This is fixed in OpenVPN 2.2.</li></ul></div></div><div><div><div><div><h3 class="title"><a id="ch10lvl3sec95"/>Dodging firewalls</h3></div></div></div><p>Please note that OpenVPN makes no attempt to hide itself from a firewall. Modern firewalls that perform the so-called deep-packet inspection can easily detect the type of traffic that OpenVPN is using to connect to the OpenVPN server and can block access based on that.</p></div><div><div><div><div><h3 class="title"><a id="ch10lvl3sec96"/>Performance</h3></div></div></div><p>Similar to SOCKS proxies, HTTP proxy hosts tend to have an impact on the performance of a VPN setup. Both the bandwidth and the latency are usually affected when proxy hosts are used. This is mostly caused by having to connect to a separate host.</p></div><div><div><div><div><h3 class="title"><a id="ch10lvl3sec97"/>Using the OpenVPN GUI</h3></div></div></div><p>In Windows, you can also the use OpenVPN GUI application to set up an HTTP proxy server:</p><div><img src="img/image00443.jpeg" alt="Using the OpenVPN GUI"/></div><p style="clear:both; height: 1em;"> </p></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec433"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem">The previous and next recipes in this chapter deal with connecting via a <strong>SOCKS proxy </strong>host and connecting via an HTTP proxy with authentication</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec115"/>Connecting via an HTTP proxy with authentication</h1></div></div></div><p>In the previous recipe, a plain HTTP proxy was used to connect to an OpenVPN server. As a follow-up, in this recipe we will show how an OpenVPN connection can be set up when the HTTP proxy server requires authentication.</p><p>The HTTP proxy used in this recipe is a Linux-based Apache <code class="literal">httpd</code> server with the <code class="literal">mod_proxy</code> module loaded and configured for basic authentication.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec434"/>Getting ready</h2></div></div></div><p>We will use the following network layout:</p><div><img src="img/image00444.jpeg" alt="Getting ready"/></div><p style="clear:both; height: 1em;"> </p><p>Set up the client and server certificates using the first recipe from <a class="link" title="Chapter 2.  Client-server IP-only Networks" href="part0025.xhtml#aid-NQU21">Chapter 2</a>, <em>Client-server IP-only Networks</em>. For this recipe, the server computer was running CentOS 6 Linux and OpenVPN 2.3.12. The client was running Fedora 22 Linux and OpenVPN 2.3.11. Keep the configuration file, <code class="literal">example8-9-server.conf</code>, from the <em>Tuning TCP-based connections</em> recipe from <a class="link" title="Chapter 8. Performance Tuning" href="part0092.xhtml#aid-2NNJO1">Chapter 8</a>, <em>Performance Tuning</em>, as well as the client configuration file, <code class="literal">basic-tcp-client.conf</code>, from the <em>Server-side routing</em> recipe from <a class="link" title="Chapter 2.  Client-server IP-only Networks" href="part0025.xhtml#aid-NQU21">Chapter 2</a>, <em>Client-server IP-only Networks</em> at hand.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec435"/>How to do it...</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Start the server:<pre class="programlisting">
<strong>[root@server]# openvpn --config example8-9-server.conf</strong>
</pre></li><li class="listitem">Set up the HTTP proxy server to support basic authentication. For the Apache <code class="literal">httpd</code> server used in this recipe, the following <code class="literal">proxy.conf</code> file was used:<pre class="programlisting">        LoadModule proxy_module modules/mod_proxy.so 
        LoadModule proxy_balancer_module modules/mod_proxy_balancer.so 
        LoadModule proxy_ftp_module modules/mod_proxy_ftp.so 
        LoadModule proxy_http_module modules/mod_proxy_http.so 
        LoadModule proxy_connect_module modules/mod_proxy_connect.so 
 
        ProxyRequests On 
        ProxyVia On 
        AllowCONNECT 1194 
        KeepAlive on 
 
        &lt;Proxy *&gt; 
            Order deny,allow 
            Deny from all 
            Require user cookbook 
            AuthType Basic 
            AuthName "Password Required" 
            AuthUserFile /etc/httpd/conf/proxy-password 
        &lt;/Proxy&gt; 
</pre></li><li class="listitem">Create the <code class="literal">proxy-password</code> file using Apache's <code class="literal">htpasswd</code> command:<pre class="programlisting">
<strong>  [root@proxyhost]# cd /etc/httpd/conf</strong>
<strong>[root@proxyhost]# htpasswd -c proxy-password cookbook</strong>
</pre></li><li class="listitem">Add the following lines to the client configuration file, <code class="literal">basic-tcp-client.conf</code>:<pre class="programlisting">        verb 5 
        http-proxy proxy.example.com 80 /etc/openvpn/cookbook/proxypass 
</pre></li><li class="listitem">Save the configuration file as <code class="literal">example10-7-client.conf</code>.</li><li class="listitem">Create a plain-text file containing the username and password created in step 3; for example, by using:<pre class="programlisting">
<strong>[client]# echo -e "cookbook\ncookbook" &gt; proxy-password</strong>
</pre></li><li class="listitem">Start the client and wait for the connection to be established:<pre class="programlisting">
<strong>[client]# openvpn --config example10-7-client.conf</strong>
</pre></li><li class="listitem">Next, we take a closer look at the client logfile. If the right username and password are entered, the HTTP proxy grants access to connect to the OpenVPN server and the VPN connection is established:<pre class="programlisting">
<strong>Attempting to establish TCP connection with     
        [AF_INET]proxy.example.com:80 [nonblock]</strong>
<strong>TCP connection established with [AF_INET]proxy.example.com:80</strong>
<strong>Send to HTTP proxy: 'CONNECT openvpnserver.example.com:1194   
        HTTP/1.0'</strong>
<strong>Attempting Basic Proxy-Authorization</strong>
<strong>HTTP proxy returned: 'HTTP/1.0 200 Connection Established'</strong>
<strong>TCPv4_CLIENT link local: [undef]</strong>
<strong>TCPv4_CLIENT link remote: [AF_INET]proxy.example.com:80</strong>
<strong>TLS: Initial packet from [AF_INET]proxy.example.com:80,      
        sid=3593eadc c87fb5d4</strong>
<strong>VERIFY OK: depth=1, C=US, O=Cookbook 2.4, CN=Cookbook 2.4 CA, 
        emailAddress=openvpn@example.com</strong>
<strong>Validating certificate key usage</strong>
<strong>++ Certificate has key usage  00a0, expects 00a0</strong>
<strong>VERIFY KU OK</strong>
<strong>Validating certificate extended key usage</strong>
<strong>++ Certificate has EKU (str) TLS Web Server Authentication, 
        expects TLS Web Server Authentication</strong>
<strong>VERIFY EKU OK</strong>
<strong>VERIFY OK: depth=0, C=US, O=Cookbook 2.4, CN=openvpnserver</strong>
<strong>Data Channel Encrypt: Cipher 'BF-CBC' initialized with 128 bit 
        key</strong>
</pre><p>As can be seen from the connection log, the OpenVPN client attempts basic proxy authorization when connecting to the HTTP proxy server. If the authentication is successful, the HTTP proxy grants access to the client to connect to the server.</p></li></ol><div></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec436"/>How it works...</h2></div></div></div><p>Similar to the previous recipe, the OpenVPN client first connects to the HTTP proxy host. It attempts to authenticate to the HTTP proxy using basic authentication, using the username and password supplied in the proxy password file, <code class="literal">/etc/openvpn/cookbook/proxypass</code>. After successful authentication, the client then sends an <code class="literal">HTTP 'CONNECT'</code> request to connect to the OpenVPN server. From here on, the OpenVPN connection is set up in a similar fashion to a regular TCP-based setup.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec437"/>There's more...</h2></div></div></div><p>OpenVPN supports multiple authentication mechanisms when connecting to an HTTP proxy.</p><div><div><div><div><h3 class="title"><a id="ch10lvl3sec98"/>NTLM proxy authorization</h3></div></div></div><p>OpenVPN also supports HTTP proxies that use NTLM proxy authorization, where <strong>NTLM</strong> stands for <strong>NT Lan Manager</strong>. Typically, this type of proxy is used in a Microsoft Windows environment. Unfortunately, OpenVPN's implementation of NTLM authorization is rather limited. It does not send out proper NTLMSSP messages and it works only with a very limited set of proxies. To enable support for this type of proxy add <code class="literal">http-proxy proxyhost proxyport stdin ntlm</code> or <code class="literal">http-proxy proxyhost proxyport stdin ntlm2</code>, where <code class="literal">stdin</code> instructs OpenVPN to query the username and password on the command prompt.</p></div><div><div><div><div><h3 class="title"><a id="ch10lvl3sec99"/>Authentication methods</h3></div></div></div><p>OpenVPN also supports HTTP <code class="literal">digest</code> authentication, which is more secure than the plain-text authentication outlined in this recipe. You can also use the option <code class="literal">auto-nct</code> with the <code class="literal">http-proxy</code> authentication directive to reject weak proxy authentication methods.</p></div><div><div><div><div><h3 class="title"><a id="ch10lvl3sec100"/>OpenVPN GUI limitations</h3></div></div></div><p>The current OpenVPN GUI does not allow you to specify a username or password in the GUI. This was supported in older versions of the Windows OpenVPN GUI application. As this feature is not widely used it was removed during the rewrite of the GUI.</p></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec438"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem">The previous recipe in this chapter, where a connection is established using an HTTP proxy without extra authentication</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec116"/>IP-less setups - ifconfig-noexec</h1></div></div></div><p>The goal of this recipe is to create an OpenVPN tunnel without assigning IP addresses to the endpoints of the tunnel. In a routed network setup, this ensures that the tunnel endpoints can never be reached through themselves, which adds some security and can also make the routing tables a bit shorter. In the OpenVPN configuration files, an IP address needs to be specified, but it is never assigned to the tunnel interface.</p><p>This recipe has only been tested on Linux systems, as it requires some network-interface configuration that is not available on other platforms.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec439"/>Getting ready</h2></div></div></div><p>We will use the following network layout:</p><div><img src="img/image00445.jpeg" alt="Getting ready"/></div><p style="clear:both; height: 1em;"> </p><p>Make sure that the client and server are not on the same local network. If the client and server can contact each other directly then this recipe will fail. Set up the client and server certificates using the first recipe from <a class="link" title="Chapter 2.  Client-server IP-only Networks" href="part0025.xhtml#aid-NQU21">Chapter 2</a>, <em>Client-server IP-only Networks</em>. In this recipe, the server computer was running CentOS 6 Linux and OpenVPN 2.3.12. The client was running Fedora 22 Linux and OpenVPN 2.3.11. Keep the server config file, <code class="literal">example3-1-server.conf</code>, from the <em>Simple configuration - non-bridged</em> recipe from <a class="link" title="Chapter 3. Client-server Ethernet-style Networks" href="part0038.xhtml#aid-147LC1">Chapter 3</a>, <em>Client-server Ethernet-style Networks</em>.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec440"/>How to do it...</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Create the server configuration file by adding a line to the <code class="literal">example3-1-server.conf</code> file:<pre class="programlisting">
<strong>route 192.168.4.0 255.255.255.0 192.168.99.1</strong>
</pre></li><li class="listitem">Save it as <code class="literal">example10-8-server.conf</code>.</li><li class="listitem">Start the server:<pre class="programlisting">
<strong>[root@server]# openvpn --config example10-8-server.conf</strong>
</pre></li><li class="listitem">Create the client configuration file:<pre class="programlisting">        client 
        proto udp 
        remote openvpnserver.example.com 
        port 1194 
 
        dev tap 
        nobind 
 
        remote-cert-tls server 
        tls-auth /etc/openvpn/cookbook/ta.key 1 
        ca       /etc/openvpn/cookbook/ca.crt 
        cert     /etc/openvpn/cookbook/client1.crt 
        key      /etc/openvpn/cookbook/client1.key 
 
        script-security 2 
        ifconfig-noexec 
        up /etc/openvpn/cookbook/example10-8-up.sh 
 
        route-noexec 
        route-up /etc/openvpn/cookbook/example10-8-route-up.sh 
</pre></li><li class="listitem">Save it as <code class="literal">example-10-8-client.conf</code>.</li><li class="listitem">Next, create the <code class="literal">example10-8-up.sh</code> script:<pre class="programlisting">        #!/bin/bash 
 
        /sbin/ifconfig $1 0.0.0.0 up 
        # needed for TAP interfaces !!! 
        echo 1 &gt; /proc/sys/net/ipv4/conf/$1/proxy_arp 
</pre></li><li class="listitem">Save it as <code class="literal">/etc/openvpn/cookbook/example10-8-up.sh</code>.</li><li class="listitem">Similarly, create the <code class="literal">example10-8-route-up.sh</code> script:<pre class="programlisting">        #!/bin/bash 
 
        # add an explicit route back to the VPN endpoint 
        /sbin/ip route add $route_vpn_gateway/32 dev $dev 
 
        n=1; 
        while [ $n -le 100 ] 
        do 
          network=`env | sed -n \  
             "/^"route_network_${n}=/s/^route_network_${n}=//p"`" 
          netmask=`env | sed -n \ 
             "/^"route_netmask_${n}=/s/^route_netmask_${n}=//p"`" 
 
          if [ -z "$"network" -o -z "$"netmask" ] 
          then 
            break 
          fi 
 
          /sbin/ip route add $network/$netmask dev $dev 
          let n=n+1 
        done 
</pre></li><li class="listitem">Save it as <code class="literal">/etc/openvpn/cookbook/example10-8-route-up.sh</code>.</li><li class="listitem">Make sure both scripts are executable and both of them start the client:<pre class="programlisting">
<strong>[[root@client]# chmod 755 /etc/openvpn/cookbook/example10-8*.sh</strong>
<strong>[root@client]# openvpn --config example10-8-client.conf</strong>
</pre></li><li class="listitem">After the client successfully connects to the OpenVPN server, check the <code class="literal">tap0</code> interface and the routing tables, and verify that you can ping the server:<pre class="programlisting">
<strong>[root@client]# ip addr show tap0</strong>
<strong>13: tap0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc  
        pfifo_fast state UNKNOWN group default qlen 100</strong>
<strong>    link/ether b6:b3:0e:41:d5:4d brd ff:ff:ff:ff:ff:ff</strong>
<strong>    inet6 fe80::b4b3:eff:fe41:d54d/64 scope link </strong>
<strong>       valid_lft forever preferred_lft forever</strong>
<strong>[root@client]# netstat-rn</strong>
<strong>Kernel IP routing table</strong>
<strong>Destination Gateway  Genmask       Flags[...]  Iface</strong>
<strong>192.168.4.0 0.0.0.0  255.255.255.0 U   0 0 0 eth0</strong>
<strong>10.198.0.0  0.0.0.0  255.255.0.0   U   0 0 0 tap0</strong>
<strong>[...]</strong>
<strong>[root@client]# ping -c 2 192.168.99.1</strong>
<strong>PING 192.168.99.1 (192.168.99.1) 56(84) bytes of data.</strong>
<strong>64 bytes from 192.168.99.1: icmp_seq=1 ttl=64 time=25.7 ms</strong>
<strong>64 bytes from 192.168.99.1: icmp_seq=2 ttl=64 time=26.2 ms</strong>
</pre></li></ol><div></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec441"/>How it works...</h2></div></div></div><p>The OpenVPN server allocates an IP address for the client, but that does not mean that the client interface actually needs to assign these addresses. The <code class="literal">example10-8-up.sh</code> script does exactly this.</p><p>Some older Linux kernels refuse to add a route without an address being assigned to an interface. Hence, we assign the address <code class="literal">0.0.0.0</code> to the <code class="literal">tun0</code> interface. To add the routes that are pushed by the server, a special <code class="literal">route-up</code> script is used, <code class="literal">example10-8-route-up.sh</code>, which brings up all the routes.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec442"/>There's more...</h2></div></div></div><p>Please note the following when considering an IP-less setup.</p><div><div><div><div><h3 class="title"><a id="ch10lvl3sec101"/>Point-to-point and TUN-style networks</h3></div></div></div><p>This recipe can also be used in a point-to-point style environment, where static keys are used to connect two networks. Similarly, it can also be used in a TUN-style setup.</p></div><div><div><div><div><h3 class="title"><a id="ch10lvl3sec102"/>Routing and firewalling</h3></div></div></div><p>At first, this recipe might seem odd. The advantage of this setup is that the OpenVPN client itself is not reachable by other machines on the VPN. This is handy when connecting many clients to an OpenVPN server, but some clients are used as gateways to the networks behind them (for example, to connect a remote office to the OpenVPN server). By not assigning the remote office gateway an IP address, there is no risk of the gateway itself being attacked from the remote VPN side. Also, server-side firewalling and <code class="literal">iptables</code> rules can be slightly shorter in this scenario, as there will be no traffic coming from the OpenVPN client with the VPN source address. This is also the reason why the server configuration has an explicit route to the client-side network:</p><pre class="programlisting">route 192.168.4.0 255.255.255.0 192.168.99.1 
</pre><p>It also explains why this recipe will fail if the VPN client and server are on the same local area network. If the VPN client can contact the VPN server directly then the VPN server will not be able to determine which traffic needs to go inside the tunnel and which traffic needs to be sent directly to the client.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec117"/>Port sharing with an HTTPS server</h1></div></div></div><p>A common OpenVPN setup to allow road warriors to reach the home office is to have OpenVPN listen on the secure web server (HTTPS) port  <code class="literal">443</code>. The downside is that you can no longer use that port on the OpenVPN server to actually host a secure website. OpenVPN 2.1 introduces a new <code class="literal">port-sharing</code> directive, enabling dual use of a TCP port. All traffic that is detected as OpenVPN traffic is processed by the OpenVPN server itself, and all other traffic is forwarded to another (local) machine and/or port.</p><p>In this recipe, we will set up an OpenVPN server to share TCP port <code class="literal">443</code> with a web server and we will show that both OpenVPN and a web browser can successfully connect to this server.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec443"/>Getting ready</h2></div></div></div><p>We will use the following network layout:</p><div><img src="img/image00446.jpeg" alt="Getting ready"/></div><p style="clear:both; height: 1em;"> </p><p>Set up the client and server certificates using the first recipe from <a class="link" title="Chapter 2.  Client-server IP-only Networks" href="part0025.xhtml#aid-NQU21">Chapter 2</a>, <em>Client-server IP-only Networks</em>. For this recipe, the server computer was running CentOS 6 Linux and OpenVPN 2.3.12. The client was running Windows 7 64 bit and OpenVPN 2.3.10. Keep the server configuration file, <code class="literal">example8-9-server.conf</code>, from the <em>Tuning TCP-based connections</em> recipe from <a class="link" title="Chapter 8. Performance Tuning" href="part0092.xhtml#aid-2NNJO1">Chapter 8</a>, <em>Performance Tuning</em> at hand, as well as the client configuration file, <code class="literal">example8-9.ovpn</code>, from the same recipe.</p><p>On the server computer, a secure web server was running on port <code class="literal">8443</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec444"/>How to do it...</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Create the server configuration file by modifying the <code class="literal">example8-9-server.conf</code> file. Change the following line:<pre class="programlisting">
<strong>port 1194</strong>
</pre><p>Change it to the following:</p><pre class="programlisting">
<strong>port 443</strong>
<strong>port-share localhost 8443</strong>
</pre><p>Save it as <code class="literal">example10-9-server.conf</code>.</p></li><li class="listitem">Start the server:<pre class="programlisting">
<strong>[root@server]# openvpn --config example10-9-server.conf</strong>
</pre></li><li class="listitem">Next, modify the client configuration file, <code class="literal">example8-9.ovpn</code>, by also changing the port to <code class="literal">443</code>. Save the client configuration file as <code class="literal">example10-9.ovpn</code>.</li><li class="listitem">Start the client and verify that the client can connect to the VPN server.</li><li class="listitem">After the client has connected, start a web browser and browse to:<pre class="programlisting">        https://openvpnserver.example.com 
</pre><p>The OpenVPN server log file will show lines similar to the following:</p><pre class="programlisting">        ... Re-using SSL/TLS context 
        ... TCP connection established with &lt;client-ip&gt;:53356 
        ... TCPv4_SERVER link local: [undef] 
        ... TCPv4_SERVER link remote: &lt;client-ip&gt;:53356 
        ... &lt;client-ip&gt;:53356 Non-OpenVPN client protocol detected 
</pre></li></ol><div></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec445"/>How it works...</h2></div></div></div><p>When <code class="literal">port-share</code> is used, OpenVPN will inspect the incoming traffic on port <code class="literal">443</code>. If this traffic is a part of an OpenVPN session or if it is an initial OpenVPN handshake, then the OpenVPN server processes it by itself. If it is not recognizable as OpenVPN traffic, it is forwarded out to the host and port specified in the <code class="literal">port-share</code> directive.</p><p>Hence, it is the OpenVPN server process that is always listening on port <code class="literal">443</code>. The web server must be listening on a different host, interface, or port. With this setup, the same port can be used to offer two different services.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec446"/>There's more...</h2></div></div></div><p>The web server that OpenVPN forwards its traffic to must be a secure (HTTPS) web server. This is due to the nature of the inbound SSL traffic on the OpenVPN server itself. It is not possible to forward the traffic to a regular (HTTP) web server. If the traffic is forwarded to port <code class="literal">80</code>, the Apache web server used in this recipe, the following error will appear in the web server error log file:</p><pre class="programlisting">[error] [client 127.0.0.1] Invalid method in request \x16\x03\x01 
</pre><div><div><div><div><h3 class="title"><a id="ch10lvl3sec103"/>Alternatives</h3></div></div></div><p>There are many alternatives available that can achieve the same functionality. One example tool that can distinguish between OpenVPN, SSL (HTTPS), and SSH traffic is the Linux-based <code class="literal">sslh</code> tool.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec118"/>Routing features - redirect-private, allow-pull-fqdn</h1></div></div></div><p>Over the years, the routing features of OpenVPN have expanded. Most notably, there are quite a few options for the <code class="literal">redirect-gateway</code> directive, as well as several other less well-known routing directives:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">redirect-private</code>: This option behaves very similar to the <code class="literal">redirect-gateway</code> directive, especially when the new parameters are used, but it does not alter the default gateway.</li><li class="listitem"><code class="literal">allow-pull-fqdn</code>: This allows the client to pull DNS names from the OpenVPN server. Previously, only IP addresses could be pushed or pulled. This option cannot be pushed and needs to be added to the client configuration itself.</li><li class="listitem"><code class="literal">route-nopull</code>: All the options are pulled by a client from the server, except for the routing options. This can be particularly handy when troubleshooting an OpenVPN setup.</li><li class="listitem"><code class="literal">max-routes n</code>: This defines the maximum number of routes that may be defined or pulled from a remote server.</li></ul></div><p>In this recipe, we will focus on the <code class="literal">redirect-private</code> directive and its parameters, as well as the <code class="literal">allow-pull-fqdn</code> parameter.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec447"/>Getting ready</h2></div></div></div><p>We will use the following network layout:</p><div><img src="img/image00447.jpeg" alt="Getting ready"/></div><p style="clear:both; height: 1em;"> </p><p>Set up the client and server certificates using the first recipe from <a class="link" title="Chapter 2.  Client-server IP-only Networks" href="part0025.xhtml#aid-NQU21">Chapter 2</a>, <em>Client-server IP-only Networks</em>. For this recipe, the server computer was running CentOS 6 Linux and OpenVPN 2.3.12. The client was running Windows 7 64 bit and OpenVPN 2.3.11. Keep the configuration file, <code class="literal">basic-udp-server.conf</code>, from the <em>Server-Side routing</em> recipe from <a class="link" title="Chapter 2.  Client-server IP-only Networks" href="part0025.xhtml#aid-NQU21">Chapter 2</a>, <em>Client-server IP-only Networks</em>, as well as the client configuration file, <code class="literal">basic-udp-client.ovpn</code>, from the <em>Using an ifconfig-pool block</em> recipe from <a class="link" title="Chapter 2.  Client-server IP-only Networks" href="part0025.xhtml#aid-NQU21">Chapter 2</a>, <em>Client-server IP-only Networks</em>.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec448"/>How to do it...</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Append the following lines to the <code class="literal">basic-udp-server.conf</code> file:<pre class="programlisting">        push "redirect-private bypass-dhcp bypass-dns" 
        push "route server.example.com" 
</pre></li><li class="listitem">Save it as <code class="literal">example10-10-server.conf</code>.</li><li class="listitem">Start the server:<pre class="programlisting">
<strong>[root@server]# openvpn --config example10-10-server.conf</strong>
</pre></li><li class="listitem">Append the following line to the client configuration file, <code class="literal">basic-udp-client.ovpn</code>, and save it as <code class="literal">example10-10.ovpn</code>:<pre class="programlisting">        allow-pull-fqdn 
</pre></li><li class="listitem">Start the client:<div><img src="img/image00448.jpeg" alt="How to do it..."/></div><p style="clear:both; height: 1em;"> </p></li><li class="listitem">Watch the routing table after the connection has been established.<p>If the DHCP or DNS server was on a different subnet than the client itself, then a new route will have been added. This is to ensure that DHCP requests still go to the local DHCP server and are not sent over the VPN tunnel.</p><p>A route for the host <code class="literal">server.example.com</code> will have been added.</p></li></ol><div></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec449"/>How it works...</h2></div></div></div><p>The <code class="literal">bypass-dhcp</code> and <code class="literal">bypass-dns</code> options for the directives, <code class="literal">redirect-gateway</code> and <code class="literal">redirect-private</code>, cause the OpenVPN client to add an extra route to the DHCP and DNS servers if they are on a different network. In large-scale networks, the DNS server is often not found on the local subnet that the client is connected to. If the route to this DNS server is altered to go through the VPN tunnel after the client has connected, this will cause at the very least a serious performance penalty. More likely, the entire DNS server will become unreachable.</p><p>The <code class="literal">allow-pull-fqdn</code> directive enables the use of a DNS name instead of an IP address when specifying a route. Especially, if a dedicated route to a host with a dynamic IP address needs to be made, this is very useful.</p><p>Note that the <code class="literal">allow-pull-fqdn</code> directive cannot be pushed from the server.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec450"/>There's more...</h2></div></div></div><p>Apart from the directives explained in this recipe, there are more routing directives available to control if and how routes are added to the client.</p><div><div><div><div><h3 class="title"><a id="ch10lvl3sec104"/>The route-nopull directive</h3></div></div></div><p>The <code class="literal">route-nopull</code> directive causes the client to pull all the information from the server but not the routes. This can be very useful for debugging a faulty server setup. It does not mean that no routes are added at all by the OpenVPN client. Only the routes that are specified using <code class="literal">push "route"</code> will be ignored. Starting with OpenVPN 2.4, it is also possible to filter out options that are pushed from the server to the client. The next recipe will go into detail on this.</p></div><div><div><div><div><h3 class="title"><a id="ch10lvl3sec105"/>The max-routes directive</h3></div></div></div><p>The <code class="literal">max-routes</code> directive is introduced in OpenVPN 2.1, as version 2.1 allows an administrator to push many more routes when compared to OpenVPN 2.0. To prevent a client from being overloaded with routes, the option <code class="literal">max-routes n</code> is added, where <code class="literal">n</code> is the maximum number of routes that can be defined in the client configuration file and/or can pulled from the server.</p><p>The default value for this parameter is <code class="literal">100</code>.</p></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec451"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem">The next recipe in this chapter, where options that are pushed from the server to the client are filtered before they are applied</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec119"/>Filtering out pushed options</h1></div></div></div><p>Starting with OpenVPN 2.4, it is now possible to filter out options pushed from the OpenVPN server to the client. This allows users to have more control over the network routes and addresses that are pushed from the server.</p><p>This recipe will show how this new feature of OpenVPN works.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec452"/>Getting ready</h2></div></div></div><p>We will use the following network layout:</p><div><img src="img/image00449.jpeg" alt="Getting ready"/></div><p style="clear:both; height: 1em;"> </p><p>Set up the client and server certificates using the first recipe from <a class="link" title="Chapter 2.  Client-server IP-only Networks" href="part0025.xhtml#aid-NQU21">Chapter 2</a>, <em>Client-server IP-only Networks</em>. For this recipe, the server computer was running CentOS 6 Linux and OpenVPN 2.3.12. The client was running Windows 7 64 bit and OpenVPN 2.4_alpha2. For the server, keep the configuration file, <code class="literal">example9-2-server.conf</code>, from the <em>Linux - using pull-resolv-conf</em> recipe, from <a class="link" title="Chapter 9. OS Integration" href="part0103.xhtml#aid-3279U1">Chapter 9</a>, <em>OS Integration</em> at hand. For the client, keep the configuration file, <code class="literal">basic-udp-client.ovpn</code>, from the <em>Using an ifconfig-pool block</em> recipe from <a class="link" title="Chapter 2.  Client-server IP-only Networks" href="part0025.xhtml#aid-NQU21">Chapter 2</a>, <em>Client-server IP-only Networks</em>.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec453"/>How to do it...</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Start the server:<pre class="programlisting">
<strong>[root@server]# openvpn --config example9-2-server.conf</strong>
</pre></li><li class="listitem">Append the following line to the client configuration file, <code class="literal">basic-udp-client.ovpn</code>, and save it as <code class="literal">example10-11.ovpn</code>:<pre class="programlisting">        pull-filter ignore "dhcp-option DNS" 
</pre></li><li class="listitem">Start the client:<div><img src="img/image00450.jpeg" alt="How to do it..."/></div><p style="clear:both; height: 1em;"> </p></li><li class="listitem">View the client log file by selecting <code class="literal">View Log</code> in the OpenVPN GUI. The log file will contain lines similar to the following:<pre class="programlisting">        PUSH: Received control message: 'PUSH_REPLY,dhcp-option DNS
        192.168.3.1,route-gateway 10.200.0.1,topology subnet,ping 
        10,ping-restart 60,ifconfig 10.200.0.2 255.255.255.0' 
        Pushed option removed by filter: 'dhcp-option DNS 192.168.3.1' 
</pre></li><li class="listitem">Verify that the DNS settings on the client have not been altered using a tool such as <code class="literal">ipconfig /all</code>.</li></ol><div></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec454"/>How it works...</h2></div></div></div><p>The <code class="literal">pull-filter</code> directive accepts several parameters:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">accept t</code>: Accepts the pushed option <code class="literal">t</code> from the server</li><li class="listitem"><code class="literal">ignore t</code>: Ignores the pushed option <code class="literal">t</code> from the server, but doesn't abort the connection</li><li class="listitem"><code class="literal">reject t</code>: Rejects the pushed option <code class="literal">t</code> from the server and abort the VPN connection</li></ul></div><p>Each option can be specified multiple times, with the last occurrence overriding earlier lines.</p><p>By adding the line <code class="literal">pull-filter ignore "dhcp-option DNS"</code> to the client configuration file, we ignore any pushed line that starts with <code class="literal">dhcp-option DNS</code>. Therefore, no DNS settings are accepted from the VPN server. This option can be applied to all options that are pushed from the server.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec120"/>Handing out the public IPs</h1></div></div></div><p>With the <code class="literal">topology subnet</code> feature that OpenVPN offers, it becomes feasible to hand out public IP addresses to connecting clients. For this recipe, we will show how such a setup can be realized. We will re-use a technique from the <em>Proxy-ARP</em> recipe from <a class="link" title="Chapter 2.  Client-server IP-only Networks" href="part0025.xhtml#aid-NQU21">Chapter 2</a>, <em>Client-server IP-only Networks</em>, to make the VPN clients appear as if they are a part of the remote network. If a dedicated IP address block is available for the VPN clients, then this is not required. The advantage of using the <code class="literal">proxy-arp</code> method is that it allows us to use only part of an expensive public IP address block.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec455"/>Getting ready</h2></div></div></div><p>For this recipe, the server computer was running CentOS 6 Linux and OpenVPN 2.3.12. The client computer was running Windows 7 64 bit and OpenVPN 2.3.11. Keep the client configuration file, <code class="literal">basic-udp-client.ovpn</code>, from the <em>Using an ifconfig-pool block</em> recipe from Chapter 2, <em>Client-Server IP-Only Networks</em>.</p><p>To test this recipe, a public IP address block of 16 addresses was used, but here, we will list a private address block instead (<code class="literal">10.0.0.0/255.255.255.240</code>). This block is used as follows:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">10.0.0.18</code>: This is used for the server's VPN IP address</li><li class="listitem"><code class="literal">10.0.0.19</code>: Not available</li><li class="listitem"><code class="literal">10.0.0.20</code> -<code class="literal">10.0.0.25</code>: Available for VPN clients</li><li class="listitem"><code class="literal">10.0.0.26</code>: Not available</li><li class="listitem"><code class="literal">10.0.0.27</code>: The LAN address of the OpenVPN server itself</li><li class="listitem"><code class="literal">10.0.0.28</code> -<code class="literal">10.0.0.29</code>: Not available</li><li class="listitem"><code class="literal">10.0.0.30</code>: The router on the remote LAN</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec456"/>How to do it...</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Create the server configuration file:<pre class="programlisting">        mode server 
        tls-server 
        proto udp 
        port 1194 
        dev tun 
 
        ifconfig 10.0.0.18 255.255.255.240 
        ifconfig-pool 10.0.0.20 10.0.0.25 
        push "route 10.0.0.27 255.255.255.255 net_gateway" 
        push "route-gateway 10.0.0.30" 
        push "redirect-gateway def1" 
 
        tls-auth /etc/openvpn/cookbook/ta.key 0 
        ca       /etc/openvpn/cookbook/ca.crt 
        cert     /etc/openvpn/cookbook/server.crt 
        key      /etc/openvpn/cookbook/server.key 
        dh       /etc/openvpn/cookbook/dh2048.pem 
 
        persist-key 
        persist-tun 
        keepalive 10 60 
 
        topology subnet 
        push "topology subnet" 
 
        script-security 2 
        client-connect    /etc/openvpn/cookbook/proxyarp-connect.sh 
        client-disconnect /etc/openvpn/cookbook/proxyarp-disconnect.sh 
 
        #user  nobody 
        #group nobody 
 
        daemon 
        log-append /var/log/openvpn.log 
</pre><p>Note that this server configuration cannot be run as user <code class="literal">nobody</code>. Save the configuration file as <code class="literal">example10-12-server.conf</code>.</p></li><li class="listitem">Next, create the <code class="literal">proxyarp-connect.sh</code> script:<pre class="programlisting">        #!/bin/bash 
        /sbin/arp -i eth0  -Ds $ifconfig_pool_remote_ip eth0 pub 
        /sbin/ip route add ${ifconfig_pool_remote_ip}/32 dev tun0 
</pre></li><li class="listitem">Save it as <code class="literal">/etc/openvpn/cookbook/proxyarp-connect.sh</code>.</li><li class="listitem">Similarly, create the <code class="literal">proxyarp-disconnect.sh</code> script:<pre class="programlisting">        #!/bin/bash 
        /sbin/arp -i eth0  -d $ifconfig_pool_remote_ip 
        /sbin/ip route del ${ifconfig_pool_remote_ip}/32 dev tun0 
</pre></li><li class="listitem">Save it as <code class="literal">/etc/openvpn/cookbook/proxyarp-disconnect.sh</code>.</li><li class="listitem">Make sure that both the scripts are executable, then start the server:<pre class="programlisting">
<strong>[root@server]# cd /etc/openvpn/cookbook</strong>
<strong>[root@server]# chmod 755 proxy-connect.sh proxy-disconnect.sh</strong>
<strong>[root@server]# openvpn --config example10-12-server.conf</strong>
</pre></li><li class="listitem">Next, start the client. The IP address assigned to the client should be <code class="literal">10.0.0.20</code>.</li><li class="listitem">Use the client to browse the Internet and check its IP address by surfing, for example, to <a class="ulink" href="http://www.whatismyip.com">http://www.whatismyip.com</a>.</li></ol><div></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec457"/>How it works...</h2></div></div></div><p>Some notes on the server configuration file, the directives:</p><pre class="programlisting">ifconfig 10.0.0.18 255.255.255.240 
ifconfig-pool 10.0.0.20 10.0.0.25 
</pre><p>Set up a pool of (public) IP address for the clients to use. Because not all of these addresses are available in the <code class="literal">/28</code> block, we cannot simply use:</p><pre class="programlisting">server 10.0.0.18 255.255.255.240 
</pre><p>The next statement is to ensure that the VPN server itself is reached via the regular network and not via the VPN tunnel itself:</p><pre class="programlisting">push "route 10.0.0.27 255.255.255.255 net_gateway" 
</pre><p>In order to redirect all traffic via the VPN tunnel, we need to explicitly state the new default gateway and <code class="literal">redirect-gateway</code>:</p><pre class="programlisting">push "route-gateway 10.0.0.30" 
push "redirect-gateway def1" 
</pre><p>Normally, the following statement will also cause the topology setting to be pushed to the VPN clients:</p><pre class="programlisting">topology subnet 
</pre><p>But, as we're not using the <code class="literal">server</code> directive, this does not happen automatically. By explicitly pushing the topology, we ensure that the clients will also use the correct settings.</p><p>The  <code class="literal">client-connect</code> and <code class="literal">client-disconnect</code> scripts are very similar to the ones used in the <em>Proxy-ARP</em> recipe from <a class="link" title="Chapter 2.  Client-server IP-only Networks" href="part0025.xhtml#aid-NQU21">Chapter 2</a>, <em>Client-server IP-only Networks</em>. By using a handy feature of the Linux <code class="literal">arp</code> command, we can make the remote clients appear to be part of the local network.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec458"/>There's more...</h2></div></div></div><p>The <code class="literal">topology subnet</code> feature was introduced in OpenVPN 2.1 and is essential to making this recipe practical. Without this feature, each client would be handed out a miniature <code class="literal">/30</code> network, which means that each client would use up to four public IP addresses. This made the deployment of handing out public IP addresses to VPN clients very expensive.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec459"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem">The <em>Proxy-ARP</em> recipe from <a class="link" title="Chapter 2.  Client-server IP-only Networks" href="part0025.xhtml#aid-NQU21">Chapter 2</a>, <em>Client-server IP-only Networks</em>, which explains in more detail how the Linux/UNIX Proxy-ARP feature works</li></ul></div></div></div></body></html>