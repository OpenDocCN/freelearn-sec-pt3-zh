["```\n\n    $ sudo dnf install -y containers-common crun \\ \n    iptables netavark nftables slirp4netns \\\n    composer-cli cockpit cockpit-composer \\\n    skopeo buildah runc podman\n    ```", "```\n\n    $ sudo systemctl enable cockpit.socket\n    ```", "```\n\n    $ sudo systemctl start cockpit.socket\n    ```", "```\n\n    $ sudo systemctl status cockpit.socket\n    ```", "```\n    ● cockpit.socket - Cockpit Web Service Socket\n         Loaded: loaded (/usr/lib/systemd/system/cockpit.socket; enabled; preset: disabled)\n         Active: active (listening) since Fri 2024-08-09 12:39:24 EDT; 1 month 13 days ago\n    Triggers: ● cockpit.service\n           Docs: man:cockpit-ws(8)\n         Listen: [::]:9090 (Stream)\n          Tasks: 0 (limit: 38320)\n         Memory: 648.0K (peak: 2.5M)\n            CPU: 26ms\n         CGroup: /system.slice/cockpit.socket\n    Aug 09 12:39:24 bm03.local systemd[1]: Starting cockpit.socket - Cockpit Web Service Socket...\n    centos-bootc repository.\n    ```", "```\n\n    $ cd ~\n    ```", "```\n\n    $ mkdir -p ~/.config/containers\n    ```", "```\n\n    registries.conf file to contain the defined contents:\n\n    ```", "```\n\n    Set the file’s contents to match the following and save the file:\n\n    ```", "```\n\n    ```", "```\n\n    $ cd ~\n    ```", "```\n\n    quay.io via the command line. Use your own user account and the password you have previously set in order to access the quay.io registry:\n\n    ```", "```\n\n    If the login was successful, you will receive the following message:\n\n    ```", "```\n\n    ```", "```\n\n    $ podman pull quay.io/centos-bootc/centos-bootc:stream9\n    ```", "```\n    ((( output truncated)))\n    Copying blob 775d29f76a39 done   |\n    Copying blob 7eff373befa3 done   |\n    Copying blob 8c789e616763 done   |\n    Copying blob fd730fb4a24b done   |\n    Copying blob 54246c915569 done   |\n    Copying blob 232fb94490b0 done   |\n    Copying blob ad312c5c40cc done   |\n    Copying blob bd9ddc54bea9 done   |\n    Copying config a1163a9d15 done   |\n    Writing manifest to image destination\n    a1163a9d15d2f9a3f7f81748baf8fbcfc69690ed38030e770fe2006c090b0f83\n    ```", "```\n\n    $ podman images\n    ```", "```\n    REPOSITORY                         TAG         IMAGE ID      CREATED       SIZE\n    quay.io/centos-bootc/centos-bootc  stream9     a1163a9d15d2  43 hours ago  1.52 GB\n    ```", "```\n\n    $ vi mycontainerfile.cf\n    ```", "```\n    FROM quay.io/centos-bootc/centos-bootc:stream9\n    #install the lamp components\n    RUN dnf install -y httpd mariadb mariadb-server php-fpm php-mysqlnd && dnf clean all\n    #start the services automatically on boot\n    RUN systemctl enable httpd mariadb php-fpm\n    #create an awe inspiring home page (all one command line)\n    RUN echo '<h1 style=\"text-align:center;\">Welcome to My Appliance</h1> <?php phpinfo(); ?>' >> /var/www/html/index.php\n    ```", "```\n\n$ podman build -f mycontainerfile.cf -t quay.io/[my_account]/bootc/lamp-bootc:latest\n```", "```\n\nSTEP 1/4: FROM quay.io/centos-bootc/centos-bootc:stream9\nSTEP 2/4: RUN dnf install -y httpd mariadb mariadb-server php-fpm php-mysqlnd && dnf clean all\n--> Using cache a525b1bb126820c8522199f6d42b292210f06e4d178efbc148d97a92b94a64ed\n--> a525b1bb1268\nSTEP 3/4: RUN systemctl enable httpd mariadb php-fpm\n--> Using cache 9400a8bbc0287454ae0db9f42f9b49e518daf2b410fd3c3d0bb91a8b58e0a2a3\n--> 9400a8bbc028\nSTEP 4/4: RUN echo '<h1 style=\"text-align:center;\">Welcome to My Appliance</h1> <?php phpinfo(); ?>' >> /var/www/html/index.php\n--> Using cache 4bcb220e3de6429f9f83264e84f064f2101c715c78e1104e388d11f6007b560e\nCOMMIT quay.io/matt_st_onge/bootc/lamp-bootc:latest\n--> 4bcb220e3de6\nSuccessfully tagged quay.io/matt_st_onge/bootc/lamp-bootc:latest\n4bcb220e3de6429f9f83264e84f064f2101c715c78e1104e388d11f6007b560e\n```", "```\n\n$ podman run -d --rm --name lamp -p 8080:80 \\ \nquay.io/[my_account]/bootc/lamp-bootc:latest\n```", "```\n\n7d9c474d9dd4e6ab32d910c72775cdb111adfed764f29887c110461ca67c54a6\n```", "```\n\n    $ podman exec -it lamp /bin/bash\n    ```", "```\n\n    bash-5.1# exit\n    ```", "```\n\n    lamp.\n    ```", "```\n\n$ podman push quay.io/[my_account]/bootc/lamp-bootc:latest\n```", "```\n\n(((output truncated)))\nCopying blob 7685af3680f8 skipped: already exists\nCopying blob 9046686a9227 skipped: already exists\nCopying blob d1c1676ee4e9 skipped: already exists\nCopying blob 7a1c4a9ce068 skipped: already exists\nCopying blob 0811ec9b544a done   |\nCopying blob abef090ec865 done   |\nCopying blob 6394663daed5 done   |\nCopying blob 2daf40f13a19 skipped: already exists\nCopying blob 9dad063a624b skipped: already exists\nCopying config 8a4585ebc8 done   |\nWriting manifest to image destination\n```", "```\n\nmykickstart.ks look similar (with your substitutions) to this:\n\n```", "```\n\n\t\t\t\t1.  Now, we will install the `lorax` software package, which will enable us to create a custom installer ISO image:\n\n    ```", "```\n    ((( output truncated)))\n    mkksiso command, which is part of the lorax RPM package we just installed. This will create a custom installer for us:\n    ```", "```\n\n\t\t\tImportant note\n\t\t\tYou will need to substitute exact paths of your own here.\n\t\t\tFor example,\n\t\t\t`sudo mkksiso --ks /``home/mstonge/mykickstart.ks \\`\n\t\t\t`/``home/mstonge/CentOS-Stream-9-latest-x86_64-dvd1.iso \\`\n\t\t\t`/``home/mstonge/mycustominstaller.iso`\n\n```", "```\n\n\t\t\tThe output for this step is significantly long. I have truncated it here to prevent my editor from murdering me. The part you must pay attention to is the last line, which confirms the operation has completed successfully and that it wrote your custom ISO image:\n\n```", "```\n\n\t\t\t\t1.  Now that we have our own custom installer ISO image, let’s create boot media. For this step, you will need to use Fedora Media Writer. It should already be on your system; if not, download it first. If you need assistance downloading or installing the tool (which works on all major platforms), check out this reference link: [https://docs.fedoraproject.org/en-US/fedora/latest/preparing-boot-media/#_fedora_media_writer](https://docs.fedoraproject.org/en-US/fedora/latest/preparing-boot-media/#_fedora_media_writer).\n\n\t\t\tImportant note\n\t\t\tThis step may be optional if you are working with virtual machines – you might be able just to boot from the ISO file itself within the hypervisor.\n\t\t\tLet’s look at how Fedora Media Writer can simplify the creation of boot media.\n\n\t\t\t\t\t![Figure 9.7 – Fedora Media Writer](img/B22104_09_07.jpg)\n\n\t\t\tFigure 9.7 – Fedora Media Writer\n\n\t\t\t\t1.  Here, you select the ISO image and the USB thumb drive that you want to commit the bootable image to.\n\n\t\t\t\t\t![Figure 9.8 – Choosing ISO images](img/B22104_09_08.jpg)\n\n\t\t\tFigure 9.8 – Choosing ISO images\n\t\t\tAs the Fedora Media Writer requires elevated access, you’ll be prompted for authentication to achieve `sudo` status.\n\n\t\t\t\t\t![Figure 9.9 – Elevated permissions – authentication](img/B22104_09_09.jpg)\n\n\t\t\tFigure 9.9 – Elevated permissions – authentication\n\t\t\tIt will definitely take a few minutes to render the ISO image to the physical media. Have patience, grab a beverage, and enjoy the break.\n\n\t\t\t\t\t![Figure 9.10 - ISO build in progress](img/B22104_09_10.jpg)\n\n\t\t\tFigure 9.10 - ISO build in progress\n\t\t\tOnce the ISO build is completed, you’ll be greeted by this screen.\n\n\t\t\t\t\t![](img/B22104_09_11.jpg)\n\n\t\t\tFigured 9.11 – ISO image created\n\t\t\tYou can now remove the thumb drive from the USB port. We’re just moments away from installation. You’ve successfully created your own custom installer. Let’s move on and put it to good use.\n\t\t\tExercise 4 – initial installation\n\t\t\tIn this exercise, we will install our first **Image Mode system** with our newly created custom installer. You will boot the test system from the newly created thumb drive (or from the ISO file we just created in the case of a virtual machine). You may need to interrupt your system’s normal boot process to get it to boot from the USB thumb drive.\n\t\t\tSit back, relax, and watch the magic happen. Let’s move on to deploying our first system leveraging the automated installer that we just created:\n\n\t\t\t\t1.  With your newly created boot media, use it to boot (or create a new virtual machine). If you are booting onto physical hardware, you need to be aware of some things before your installation:\n    1.  Ensure all previous partitions are removed from the drive (especially the **UEFI** partition) before the installation process begins.\n    2.  Ensure that, within your **UEFI BIOS**, any previous entries for **Secure Boot** are removed (**RESET**) and that **Secure Boot** is set to **DISABLED** before the installation.\n    3.  Boot your system from the USB media (physical hardware) or directly from the ISO image (virtual machine). This is an automated install and it will notify you upon completion (or failure).\n\n    Here’s what a successful text-based unattended installation looks like.\n\n\t\t\t\t\t![Figure 9.12 – Installation success!](img/B22104_09_12.jpg)\n\n\t\t\tFigure 9.12 – Installation success!\n\n\t\t\t\t1.  Once the installation is complete, test your login credentials at the console.\n\n\t\t\t\t\t![Figure 9.13 – First login to our new appliance](img/B22104_09_13.jpg)\n\n\t\t\tFigure 9.13 – First login to our new appliance\n\n\t\t\t\t1.  Next, let’s determine the IP address of our new system:\n\n    ```", "```\n\n    Your output should indicate that you have successfully obtained a DHCP address. Make a note of that IP address.\n\n    \t\t\t\t2.  Now, let’s open a web browser on another machine and test the LAMP stack.\n\n    Go to the IP address that you found in the previous step.\n\n    Your result should look something like this:\n\n\t\t\t\t\t![Figure 9.14 – Viewing your appliance’s application](img/B22104_09_14.jpg)\n\n\t\t\tFigure 9.14 – Viewing your appliance’s application\n\t\t\tWelcome to the new world where, if you can create a container, you can build a whole system. Let’s now move on to how we update these awesome beasts.\n\t\t\tExercise 5 – creating an updated container\n\t\t\tIn this exercise, we will make updates to our previously built container image, which will in turn provide updates to our Image Mode machine:\n\n\t\t\t\t1.  Your new appliance is defined by its container image. To create an update for your appliance, all we need to do is create a new container and then publish it to our registry. In this step, we will start by creating a new container file called `mycontainerfile2.cf`:\n\n    ```", "```\n\n    The contents of your file should look like this. Don’t forget to save the file:\n\n    ```", "```\n\n    \t\t\t\t2.  Build the new version of your container image:\n\n\t\t\tImportant note\n\t\t\tReplace your own Quay.io username where `[my_account]` appears in the command line. You may also have to log in to Quay before running this command (see *Exercise 1*, *step 13*).\n\n```", "```\n\n\t\t\tThe output for this one is significantly long. I have truncated the output in a few locations, so what we can see here is more of a short summary:\n\n```", "```\n\n\t\t\t\t1.  Now that you’ve rebuilt your container image, feel free to test it in the same way we did in a previous exercise, or don’t (it’s optional). We do, however, have to push this new image to our registry and set it as the latest version:\n\n\t\t\tImportant note\n\t\t\tReplace your own Quay.io username where `[my_account]` appears in the command line.\n\n```", "```\n\n\t\t\tThe output from this command has been truncated significantly due to its length. You can expect your output to resemble this:\n\n```", "```\n\n\t\t\tWow! This is all that you have to do if you want your system to pick up an update automatically. As we are impatient creatures, let’s move on to the next exercise and force the update manually.\n\t\t\tExercise 6 – updating your system\n\t\t\tIn this exercise, we will leverage the latest updates to the container you have created to improve and update our bootable container (bootc) machine.\n\t\t\tImportant note\n\t\t\tYour machine will check for updates automatically every few hours. The default time check period can be modified.\n\t\t\tLog back into the console of your appliance machine. Run the following as root:\n\n```", "```\n\n\t\t\tYour machine will pull down its updates and reboot itself automatically.\n\t\t\tWell done! You have not only created your first bootc machine, but you have established an update mechanism and successfully updated your new machine. Congratulations!\n\t\t\tSuccess! You have updated your appliance by adding the web console to your image. Although you probably cannot log in as root, I hope you know that you can add additional users in the kickstart if you want to rebuild or you can add a user in your console now. Here, we only wanted to show just how easy it is to create an update. It works… gorgeously.\n\n\t\t\t\t\t![Figure 9.15 – Appliance is updated with new functionality](img/B22104_09_15.jpg)\n\n\t\t\tFigure 9.15 – Appliance is updated with new functionality\n\t\t\tI hope that you have enjoyed walking through these exercises and that they have inspired thoughts as to how you could leverage this technology to build a better appliance. Additionally, I hope you continue to experiment and add to what we’ve covered in this chapter in your own lab.\n\t\t\tSummary\n\t\t\tThanks for sticking with me. I never said this journey would be easy. rpm-ostree has been around now for several years, but its time in the limelight has been overshadowed by bootc and bootable container images, an upcoming technology that builds upon its positive facets and the management is much simpler.\n\t\t\tIn this chapter, we have done an overview of the option of deploying your Linux appliance as an immutable system. I truly believe this technology could fill an entire book itself, so I do use the term overview quite sparingly. As this does greatly enhance the security of the system, it clearly will add some additional complexity to your build and support processes. Now that you’ve been armed with the knowledge of the tools you may need, you will clearly have some homework to do to determine whether this methodology is right for your team or your product. If time permits, I highly recommend your team does additional research into the feasibility of leveraging this technology in your future solutions. I know that may be a heavy lift. So, let’s now move on to the next chapter, where we will dive deep into the art of tamper-proofing.\n\n```"]