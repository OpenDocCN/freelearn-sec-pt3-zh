<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer312">
			<h1 id="_idParaDest-144"><a id="_idTextAnchor156"/>Chapter <a id="_idTextAnchor157"/>11: Malware Detection and Analysis with macOS Memory Forensics</h1>
			<p>Previously, attacks on macOS, as well as the development of specific malware for this operating system, were single events and were often limited to trivial adware. In 2020–2021, the main threat to macOS was still the adware <strong class="bold">Shlayer</strong> (<a href="https://redcanary.com/threat-detection-report/threats/shlayer/">https://redcanary.com/threat-detection-report/threats/shlayer/</a>), but we are increasingly seeing targeted attacks with advanced threat actors behind them. A good example is <strong class="bold">APT32</strong> or <strong class="bold">OceanLotus</strong>, a Vietnamese-linked group, which targeted macOS users with backdoors, delivered via malicious Microsoft Word documents.</p>
			<p>The growing popularity of macOS in enterprise environments has triggered the appearance of various macOS post-exploitation tools: <strong class="bold">MacShellSwift</strong>, <strong class="bold">MacC2</strong>, <strong class="bold">PoshC2</strong>, and the <strong class="bold">Empire</strong> post-exploitation framework. Moreover, <strong class="bold">Malware-as-a-Service</strong> for macOS (<a href="https://www.computerworld.com/article/3626431/scary-malware-as-a-service-mac-attack-discovered.html">https://www.computerworld.com/article/3626431/scary-malware-as-a-service-mac-attack-discovered.html</a>) has already appeared on darknet forums. </p>
			<p>Not surprisingly, new devices powered by M1 chips have not escaped the attention of cyber criminals either. Thus, <strong class="bold">Red Canary</strong> specialists recently discovered a new malware, Silver Sparrow, targeting Macs equipped with the new M1 processors (<a href="https://www.macworld.co.uk/news/new-malware-m1-mac-3801981/">https://www.macworld.co.uk/news/new-malware-m1-mac-3801981/</a>). </p>
			<p>All this news tells us one thing: we need to know the tools and understand macOS analysis techniques. That is what this chapter will focus on. </p>
			<p>Here are the topics that will be covered:</p>
			<ul>
				<li><a id="_idTextAnchor158"/><a id="_idTextAnchor159"/>Learning the peculiarities of macOS analysis with Volatility</li>
				<li>Investigating network connections</li>
				<li>Analyzing processes and process memory</li>
				<li>Recovering the filesystem </li>
				<li>Obtaining user application data</li>
				<li>Searching for malicious activity</li>
			</ul>
			<h1 id="_idParaDest-145"><a id="_idTextAnchor160"/>Learning the peculiarities of macOS analysis with Volatility</h1>
			<p>In the previous chapter, we talked about the difficulties you may encounter when creating <a id="_idIndexMarker563"/>memory dumps and corresponding profiles for Volatility on macOS. However, that is not all. As you remember, Volatility relies <a id="_idIndexMarker564"/>on the Kernel Debug Kit to create macOS profiles in order to get all the data you need for parsing. This data is critical to the tool's performance because the data structures and algorithms used change from one kernel version to the next. At the same time, Apple no longer includes all the type information in the KDK, which leads to errors in the execution of many plugins. Another problem is that some Volatility plugins for macOS use Intel-specific data. Thus, plugins that work on memory dumps pulled from hosts on Intel may not work with dumps pulled from hosts on M1. Further on, we will use plugins that work for both Intel and M1 where it is possible, and where it is impossible, we will try to specify all the nuances. Besides, since the analysis methodology itself and searching for anomalies in macOS memory dumps will not differ significantly from those in Windows and Linux, this time we will focus on discussing tools and methods for obtaining certain information, rather than on the investigation methodology itself.</p>
			<h1 id="_idParaDest-146"><a id="_idTextAnchor161"/>Technical requirements</h1>
			<p>To analyze macOS memory dumps, we will use both Linux and Windows systems. We will still work with Volatility 2.6.1 running on Ubuntu 21.04 (Hirsute) and programs such as Bulk Extractor will run on Windows. For the examples, we will use memory dumps from macOS Sierra 10.12.6, however, all the described manipulations can be applied to newer macOS versions as well.</p>
			<h1 id="_idParaDest-147"><a id="_idTextAnchor162"/>Investigating network connections</h1>
			<p>Network activity <a id="_idIndexMarker565"/>analysis helps us determine which processes are establishing network connections, as well as which IP addresses and ports are being used. Since most malware and post-exploitation tools establish network connections, investigating network activity is one of our top priorities. In the case of macOS, Volatility offers a number of plugins to examine network interfaces, active network connections, and the contents of routing tables.</p>
			<p>We can use the <strong class="source-inline">mac_ifconfig</strong> plugin to get information about the configuration of the network interfaces of the host under investigation:</p>
			<div>
				<div id="_idContainer292" class="IMG---Figure">
					<img src="Images/Figure_11.1_B17056.jpg" alt="Figure 11.1 – Volatility mac_ifconfig output&#13;&#10;" width="946" height="311"/>
				</div>
			</div>
			<p class="figure-caption"> </p>
			<p class="figure-caption">Figure 11.1 – Volatility mac_ifconfig output</p>
			<p>As you <a id="_idIndexMarker566"/>can see in the figure, this plugin provides information about the names of interfaces, their assigned IP and MAC addresses, as well as the set promiscuous mode.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">Promiscuous mode is a mode for a network interface controller that forces the controller to pass all the incoming traffic to the CPU, rather than passing only frames that the controller is programmed to receive.</p>
			<p>In our case, we see the following interfaces:</p>
			<ul>
				<li><strong class="source-inline">lo0</strong> – Loopback Interface</li>
				<li><strong class="source-inline">gif0</strong> – Software Network Interface</li>
				<li><strong class="source-inline">stf0</strong> – 6to4 Tunnel Interface</li>
				<li><strong class="source-inline">en0</strong> – Ethernet with IPv4 and IPv6 addresses</li>
				<li><strong class="source-inline">utun0</strong> – VPN and Back to My Mac Interface</li>
			</ul>
			<p>You can use the <strong class="source-inline">mac_netstat</strong> and <strong class="source-inline">mac_network_conns</strong> plugins to get information about network connections. The first plugin will show us information about both active connections and open sockets:</p>
			<div>
				<div id="_idContainer293" class="IMG---Figure">
					<img src="Images/Figure_11.2_B17056.jpg" alt="Figure 11.2 – Volatility mac_netstat output&#13;&#10;" width="1254" height="334"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.2 – Volatility mac_netstat output</p>
			<p>At the <a id="_idIndexMarker567"/>same time, <strong class="source-inline">mac_network_conns</strong> provides information only about network connections:</p>
			<div>
				<div id="_idContainer294" class="IMG---Figure">
					<img src="Images/Figure_11.3_B17056.jpg" alt="Figure 11.3 – Volatility mac_network_conns output" width="1244" height="310"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.3 – Volatility mac_network_conns output</p>
			<p>In addition to network connection analysis, Volatility provides the possibility to study the routing table. The <strong class="source-inline">mac_route</strong> plugin is suitable for this:</p>
			<div>
				<div id="_idContainer295" class="IMG---Figure">
					<img src="Images/Figure_11.4_B17056.jpg" alt="Figure 11.4 – Volatility mac_route output&#13;&#10;" width="1650" height="311"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.4 – Volatility mac_route output</p>
			<p>In the output of this plugin, we can see source and destination IP addresses, the name of the interface, and starting from OS X 10.7, we can also see sent/received statistics and expiration/delta times.</p>
			<p>Another way to inspect network activity is to use the Bulk Extractor tool and the well-known net parser:</p>
			<p class="source-code">&gt; .\bulk_extractor.exe -o .\output\ -x all -e net .\MacSierra_10_12_6_16G23ax64</p>
			<p>As a <a id="_idIndexMarker568"/>result, we get the <strong class="source-inline">packets.pcap</strong> file, which contains <a id="_idIndexMarker569"/>the network capture from the memory dump. To analyze this file we can, as before, use <strong class="bold">Wireshark</strong>:</p>
			<div>
				<div id="_idContainer296" class="IMG---Figure">
					<img src="Images/Figure_11.5_B17056.jpg" alt="Figure 11.5 – Network capture analysis&#13;&#10;" width="1105" height="622"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.5 – Network capture analysis</p>
			<p>In this way, we can get information about the network activity on macOS. A natural complement to investigating the network is to look at active processes. This is what we will talk about next.</p>
			<h1 id="_idParaDest-148"><a id="_idTextAnchor163"/>Analyzing processes and process memory</h1>
			<p>Processes can be analyzed both to look for anomalies and identify potentially malicious processes, and <a id="_idIndexMarker570"/>to observe user activity. As before, Volatility provides a <a id="_idIndexMarker571"/>number of plugins for obtaining data about processes and their memory. For example, the <strong class="source-inline">mac_pslist</strong>, <strong class="source-inline">mac_pstree</strong>, and <strong class="source-inline">mac_tasks</strong> plugins can be used to get a list of processes. From a practical point of view, <strong class="source-inline">mac_tasks</strong> is considered the most reliable source of information on active processes. This plugin, unlike <strong class="source-inline">mac_pslist</strong>, enumerates tasks and searches for the process objects instead of relying on a linked list of processes, which can be corrupted during macOS memory acquisition. Nevertheless, during testing on the latest versions of the operating system, the <strong class="source-inline">mac_pstree</strong> plugin turns out to be the most efficient, correctly displaying results for macOS on both Intel and M1 chips. </p>
			<p>The plugins are launched in the same way as for Windows and Linux:</p>
			<div>
				<div id="_idContainer297" class="IMG---Figure">
					<img src="Images/Figure_11.6_B17056.jpg" alt="Figure 11.6 – Volatility mac_pstree output&#13;&#10;" width="1042" height="314"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.6 – Volatility mac_pstree output</p>
			<p>In addition to the list of processes themselves, we are of course also interested in the arguments used to start these processes. To get this data, we can use the <strong class="source-inline">mac_psaux</strong> plugin:</p>
			<div>
				<div id="_idContainer298" class="IMG---Figure">
					<img src="Images/Figure_11.7_B17056.jpg" alt="Figure 11.7 – Volatility mac_psaux output&#13;&#10;" width="1650" height="592"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.7 – Volatility mac_psaux output</p>
			<p>In the output of this plugin, you can find not only arguments but also full paths to executable files. However, when working with memory dumps taken from macOS on an M1 chip, this plugin can work incorrectly and cause errors. </p>
			<p>In addition <a id="_idIndexMarker572"/>to the startup arguments of the processes, we should <a id="_idIndexMarker573"/>not forget about the history of the command line. In this case, we can use the <strong class="source-inline">mac_bash</strong> plugin, which retrieves commands executed in the shell, and the <strong class="source-inline">mac_bash_hash</strong> plugin, which displays the command alias hash table. Another way to find such information is to investigate the memory of the processes related to the Terminal application. We can extract executables and process memory for analysis with the <strong class="source-inline">mac_procdump</strong> and <strong class="source-inline">mac_memdump</strong> plugins respectively. However, at the moment, these plugins only correctly extract data for memory dumps obtained from hosts with an Intel chip. Despite this, for both Intel and M1 chips, we still have an opportunity to examine allocated memory blocks in each process, their permissions, and the names of the mapped files. This can be done with the <strong class="source-inline">mac_proc_maps</strong> plugin:</p>
			<div>
				<div id="_idContainer299" class="IMG---Figure">
					<img src="Images/Figure_11.8_B17056.jpg" alt="Figure 11.8 – Volatility mac_proc_maps output&#13;&#10;" width="1247" height="446"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.8 – Volatility mac_proc_maps output</p>
			<p>As you can see in <em class="italic">Figure 11.8</em>, in the output of this plugin, we can find information about the <a id="_idIndexMarker574"/>files used by the process as well as their full path on disk. If necessary, we <a id="_idIndexMarker575"/>can also retrieve these memory blocks with the <strong class="source-inline">mac_dump_maps</strong> plugin. If we are interested in a particular block, we can specify its start address with the <strong class="source-inline">-s</strong> option, as shown next:</p>
			<div>
				<div id="_idContainer300" class="IMG---Figure">
					<img src="Images/Figure_11.9_B17056.jpg" alt="Figure 11.9 – Volatility mac_dump_maps results&#13;&#10;" width="1246" height="224"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.9 – Volatility mac_dump_maps results</p>
			<p>As you can see, the contents of the first Siri process memory block have been successfully extracted and can be analyzed separately by additional tools. This way, we can try to extract executables, libraries, and other files. However, there is one more way of analyzing and extracting process-related files. Let's discuss it.</p>
			<h1 id="_idParaDest-149"><a id="_idTextAnchor164"/>Recovering the filesystem </h1>
			<p>The methods <a id="_idIndexMarker576"/>of dealing with the filesystem in macOS memory are also not unique. First of all, we can examine the open file descriptors of a process using the <strong class="source-inline">mac_lsof</strong> plugin. Its launch, as well as the output format, does not differ from the corresponding plugin for Linux:</p>
			<div>
				<div id="_idContainer301" class="IMG---Figure">
					<img src="Images/Figure_11.10_B17056.jpg" alt="Figure 11.10 – Volatility mac_lsof output&#13;&#10;" width="1250" height="468"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.10 – Volatility mac_lsof output</p>
			<p>As you see, here <a id="_idIndexMarker577"/>we can also use the <strong class="source-inline">-p</strong> option to identify a specific process and see the files related to it. In addition, we can collect information about all the files stored in the file cache. The <strong class="source-inline">mac_list_files</strong> plugin will help us with this:</p>
			<div>
				<div id="_idContainer302" class="IMG---Figure">
					<img src="Images/Figure_11.11_B17056.jpg" alt="Figure 11.11 – Volatility mac_list_files output&#13;&#10;" width="1247" height="530"/>
				</div>
			</div>
			<p class="figure-caption"> </p>
			<p class="figure-caption">Figure 11.11 – Volatility mac_list_files output</p>
			<p>You can use the <strong class="source-inline">mac_recover_filesystem</strong> plugin to export files. Of course, Volatility also has the <strong class="source-inline">mac_dump_file</strong> plugin, for exporting specific files, but at the moment, this plugin shows poor results with the latest versions of macOS. The process for starting the <strong class="source-inline">mac_recover_filesystem</strong> plugin also remains the same:</p>
			<p class="source-code">$ vol.py --plugins=profiles -f /mnt/hgfs/flash/MacSierra_10_12_6_16G23ax64 </p>
			<p class="source-code">--profile=MacSierra_10_12_6_16G23ax64 mac_recover_filesystem </p>
			<p class="source-code">-D /mnt/hgfs/flash/output/</p>
			<p>The contents <a id="_idIndexMarker578"/>of the output folder in our case look like this:</p>
			<div>
				<div id="_idContainer303" class="IMG---Figure">
					<img src="Images/Figure_11.12_B17056.jpg" alt="Figure 11.12 – Volatility mac_recover_filesystem results&#13;&#10;" width="1079" height="494"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.12 – Volatility mac_recover_filesystem results</p>
			<p>This way, we can recover the main locations and various files from the cached filesystem. Here, you can also find files related to a user's bash history:</p>
			<div>
				<div id="_idContainer304" class="IMG---Figure">
					<img src="Images/Figure_11.13_B17056.jpg" alt="Figure 11.13 – Recovered bash history files&#13;&#10;" width="1075" height="445"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.13 – Recovered bash history files</p>
			<p>The disadvantage of the plugin is that it currently does not work correctly on memory dumps collected from hosts with an M1 chip. If you work with older versions of macOS, you can <a id="_idIndexMarker579"/>also use the <strong class="bold">PhotoRec</strong> tool, which supports the HFS+ filesystem. This option is available <a id="_idIndexMarker580"/>for versions before High Sierra, since the default filesystem for mac computers using macOS 10.13 or later is APFS.</p>
			<p>As you can see, exporting files from macOS memory is not an easy task, especially when it comes to the latest versions of the operating system. Nevertheless, there are some positive aspects. One of them is the ability to retrieve data from specific user applications quite easily. </p>
			<h1 id="_idParaDest-150"><a id="_idTextAnchor165"/>Obtaining user application data</h1>
			<p>By default, macOS users have access to built-in applications from Apple, such as Calendar, Contacts, and Notes. Due to their quality and convenience, these applications have won <a id="_idIndexMarker581"/>the love of users, as well as the interest of investigators. Volatility provides a set of ready-to-use plugins allowing you to extract data from the above-mentioned applications. For example, to retrieve events from <strong class="source-inline">Calendar.app</strong>, you can use the <strong class="source-inline">mac_calendar</strong> plugin. To retrieve the contents of Notes messages, you can use <strong class="source-inline">mac_notesapp</strong>, and for contacts from <strong class="source-inline">Contacts.app</strong>, you can use <strong class="source-inline">mac_contacts</strong>:</p>
			<p class="source-code">$ vol.py --plugins=profiles -f /mnt/hgfs/flash/MacSierra_10_12_6_16G23ax64 </p>
			<p class="source-code">--profile=MacSierra_10_12_6_16G23ax64 mac_contacts</p>
			<p class="source-code">Volatility Foundation Volatility Framework 2.6.1</p>
			<p class="source-code">&lt;edited&gt;</p>
			<p class="source-code">AppleappleAppleapple Apple ?5E</p>
			<p class="source-code">Johnyphish Johny phish Johny</p>
			<p>Once you have this data, you can use regular expressions or YARA rules with the <strong class="source-inline">mac_yarascan</strong> plugin to try to find more information about the contact. For example, the email address associated with the contact.</p>
			<p>Since we are talking about user activity, we should not forget the more general plugins that allow us to get data on what programs the user is running or what devices have been connected. In the first case, we use those same plugins to analyze the running processes. At the same time, if there is a need to associate a process with a specific user, we can <a id="_idIndexMarker582"/>use the <strong class="source-inline">mac_list_sessions</strong> plugin, which enumerates sessions from the session hash table. The way this plugin works is as follows:</p>
			<div>
				<div id="_idContainer305" class="IMG---Figure">
					<img src="Images/Figure_11.14_B17056.jpg" alt="Figure 11.14 – Volatility mac_list_sessions output&#13;&#10;" width="941" height="356"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.14 – Volatility mac_list_sessions output</p>
			<p>In this way, we get information about the process ID, its name, and the name of the associated user. </p>
			<p>With connected devices, we can turn to the familiar <strong class="source-inline">mac_mount</strong> and <strong class="source-inline">mac_dmesg</strong> plugins:</p>
			<div>
				<div id="_idContainer306" class="IMG---Figure">
					<img src="Images/Figure_11.15_B17056.jpg" alt="Figure 11.15 – Volatility mac_mount and mac_dmesg plugins&#13;&#10;" width="1245" height="444"/>
				</div>
			</div>
			<p class="figure-caption">  </p>
			<p class="figure-caption">Figure 11.15 – Volatility mac_mount and mac_dmesg plugins</p>
			<p>As you can see in <em class="italic">Figure 11.15</em>, these plugins are full analogues to the Linux plugins of the same name.</p>
			<p>Another interesting plugin for retrieving user data is <strong class="source-inline">mac_keychaindump</strong>. As the name implies, this plugin tries to recover possible keychain keys. Subsequently, if the recovery is successful, you can try to use <strong class="source-inline">Chainbreaker2</strong> (<a href="https://github.com/n0fate/chainbreaker">https://github.com/n0fate/chainbreaker</a>) and get the data on the name, account, password, as well as timestamps for the creation and last modification of the record in the keychain. However, it is important to keep in mind that at the time of writing the book, the last officially supported version of macOS is Catalina.</p>
			<p>Of course, we should <a id="_idIndexMarker583"/>not forget to analyze processes related to browsers, email agents, and messengers, as they can contain a lot of useful data, including the URLs visited, email addresses, and conversations. To get this data, we can analyze the memory of relevant processes using the <strong class="source-inline">mac_memdump</strong> or <strong class="source-inline">mac_dump_maps</strong> plugins along with keyword, regular expression, or YARA rules searches. On the other hand, we can use the <strong class="bold">Bulk</strong> <strong class="bold">Extractor</strong> tool and the <strong class="bold">email </strong>parser to retrieve URLs and email addresses:</p>
			<div>
				<div id="_idContainer307" class="IMG---Figure">
					<img src="Images/Figure_11.16_B17056.jpg" alt="Figure 11.16 – Bulk Extractor email parser&#13;&#10;" width="1125" height="397"/>
				</div>
			</div>
			<p class="figure-caption"> </p>
			<p class="figure-caption">Figure 11.16 – Bulk Extractor email parser</p>
			<p>In the output folder, we are interested in two files – <strong class="source-inline">email_histogram.txt</strong> and <strong class="source-inline">url_histogram.txt</strong>, which contain all the email addresses and URLs extracted from the memory dump, respectively:</p>
			<div>
				<div id="_idContainer308" class="IMG---Figure">
					<img src="Images/Figure_11.17_B17056.jpg" alt="Figure 11.17 – Extracted URLs&#13;&#10;" width="972" height="564"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.17 – Extracted URLs</p>
			<p>This way, we can <a id="_idIndexMarker584"/>analyze different user data. Our last topic of discussion will be the searching for and investigation of malicious activity.</p>
			<h1 id="_idParaDest-151"><a id="_idTextAnchor166"/>Searching for malicious activity</h1>
			<p>Searching for malicious activity in macOS basically boils down to the basic elements we dealt with <a id="_idIndexMarker585"/>in the previous chapters: looking for suspicious network connections, looking for anomalies in processes, looking for code injection, looking for traces of hooking techniques used, and examining the commands executed in the shell. For example, <strong class="bold">Shlayer</strong> uses the <a id="_idIndexMarker586"/>shell to download the payload using the <strong class="bold">curl</strong> utility and <strong class="source-inline">-f0L</strong> as one of the command-line arguments, and to unpack a protected archive into a directory under <strong class="source-inline">/tmp</strong> using the <strong class="source-inline">unzip</strong> command. At the same time, running scripts and commands in the shell can be used in more sophisticated attacks when threat actors have direct access to the host.</p>
			<p>To look for code injection, we can use the familiar <strong class="source-inline">mac_malfind</strong> plugin. However, please note here that running the plugin on memory dumps taken from hosts on the M1 chip may cause execution errors:</p>
			<div>
				<div id="_idContainer309" class="IMG---Figure">
					<img src="Images/Figure_11.18_B17056.jpg" alt="Figure 11.18 – Volatility mac_malfind output &#13;&#10;" width="1245" height="358"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.18 – Volatility mac_malfind output </p>
			<p>This method comes in handy for detecting injections made with <strong class="source-inline">ptrace</strong> or the <strong class="source-inline">NSCreateObjectFileImageFromMemory</strong> API. Also, be prepared for a lot of false-positive results, which will need to be double-checked. </p>
			<p>Do not forget <a id="_idIndexMarker587"/>about the injection of malicious libraries into processes either. In this case, the <strong class="source-inline">mac_proc_maps</strong> and <strong class="source-inline">mac_dyld_maps</strong> plugins can be useful. If the malicious library tries to hide itself, the <strong class="source-inline">mac_ldrmodules</strong> plugin, which compares the output of <strong class="source-inline">mac_proc_maps</strong> with the list of libraries obtained from <strong class="source-inline">libdl</strong>, can be used:</p>
			<div>
				<div id="_idContainer310" class="IMG---Figure">
					<img src="Images/Figure_11.19_B17056.jpg" alt="Figure 11.19 – Volatility mac_ldrmodules output &#13;&#10;" width="1650" height="329"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.19 – Volatility mac_ldrmodules output </p>
			<p>If necessary, you can also extract libraries of interest using the <strong class="source-inline">mac_librarydump</strong> plugin, which extracts any executable from process memory.</p>
			<p>One of the distinguishing features of malicious activity analysis in macOS is the search for traces of persistence, because in this operating system the techniques used for persistence will be different from those discussed earlier. The most common techniques used by threat <a id="_idIndexMarker588"/>actors and malware are the following MITRE ATT&amp;CK sub-techniques:</p>
			<ul>
				<li><strong class="source-inline">T1547.011</strong>: Plist Modification</li>
				<li><strong class="source-inline">T1547.007</strong>: Re-Opened Applications</li>
				<li><strong class="source-inline">T1547.015</strong>: Login Items</li>
				<li><strong class="source-inline">T1543.001</strong>: Launch Agent</li>
				<li><strong class="source-inline">T1543.004</strong>: Launch Daemon</li>
				<li><strong class="source-inline">T1546.004</strong>: Unix Shell Configuration Modification</li>
				<li><strong class="source-inline">T1053.003</strong>: Cron</li>
			</ul>
			<p>The first two sub-techniques can be used for both persistence and privilege escalation. To do so, attackers can modify or add paths to executables, add command-line arguments, and insert key/pair values to property list files (<strong class="source-inline">plist</strong>) in auto-run locations. To find traces of <a id="_idIndexMarker589"/>these sub-techniques, you can analyze <strong class="source-inline">plist</strong> files in <strong class="source-inline">~/LaunchAgents</strong> and <strong class="source-inline">~/Library/Application</strong> <strong class="source-inline">Support/com.apple.backgroundtaskmanagementagent/backgrounditems.btm</strong> locations. Also do not forget to check <strong class="source-inline">~/Library/Preferences/com.apple.loginwindow.plist</strong>, <strong class="source-inline">~/Library/Preferences/ByHost/com.apple.loginwindow.*.plist</strong> and an application's <strong class="source-inline">Info.plist</strong> files. You can try to extract these files from the cached filesystem or check on the host itself. </p>
			<p>The Login Items, Launch Agent, and Launch Daemon sub-techniques use a similar approach. You should check <strong class="source-inline">~/Library/Application Support/com.apple.backgroundtaskmanagementagent/backgrounditems.btm</strong>, <strong class="source-inline">~/Library /Preferences/com.apple.loginitems.plist</strong>, and the application's <strong class="source-inline">/Contents /Library/Loginltems/</strong> to find their traces. You should also check for new <strong class="source-inline">plist</strong> files in <strong class="source-inline">/System/Library/LaunchAgents</strong>, <strong class="source-inline">/Library/LaunchAgents/</strong>, <strong class="source-inline">/Library /LaunchDaemons/</strong>, and <strong class="source-inline">~/Library/LaunchAgents/</strong>. </p>
			<p>The Unix Shell Configuration Modification sub-technique is associated with modifying the files used when running the Terminal application. Terminal basically uses <strong class="source-inline">zsh</strong>, which is the default shell for all macOS versions since macOS Catalina. Please note that, for legacy programs, <strong class="source-inline">/etc/bashrc</strong> is executed on startup. As a result, we should check <strong class="source-inline">/etc/profile</strong> and <strong class="source-inline">/etc/profile.d</strong>, along with <strong class="source-inline">~/.bash_profile</strong>, to find traces of this sub-technique. You can also check the <strong class="source-inline">/etc/shells</strong> file where the list of file paths for valid shells is located.</p>
			<p>The last sub-technique is similar to the one we saw in <a href="B17056_09_Final_JM_ePub.xhtml#_idTextAnchor141"><em class="italic">Chapter 9</em></a>, <em class="italic">Malicious Activity Detection</em>, so we will not go into it here in detail. However, it is worth mentioning that the <strong class="source-inline">T1547.006</strong>: Kernel Modules and Extensions sub-technique, which involves loading a malicious <strong class="source-inline">kext</strong> using the <strong class="source-inline">kextload</strong> command, was also popular for earlier versions <a id="_idIndexMarker590"/>of macOS. However, since macOS Catalina, kernel extensions have been deprecated on macOS systems. Nevertheless, Volatility provides plugins to explore loaded kernel modules and extensions: <strong class="source-inline">mac_lsmod</strong> and <strong class="source-inline">mac_lsmod_kext_map</strong>:</p>
			<div>
				<div id="_idContainer311" class="IMG---Figure">
					<img src="Images/Figure_11.20_B17056.jpg" alt="Figure 11.20 – Volatility mac_lsmod output &#13;&#10;" width="1247" height="401"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.20 – Volatility mac_lsmod output </p>
			<p>You can also use the <strong class="source-inline">mac_moddump</strong> plugin to export the specified kernel extension to disk. This sub-technique has often been used by rootkits to get persistence and escalate privileges.</p>
			<p>In general, as with Linux rootkits, macOS rootkits are now extremely hard to come by. However, even for this rare case, we have a number of plugins that allow us to detect the different <a id="_idIndexMarker591"/>hooking techniques used by this type of malware:</p>
			<ul>
				<li><strong class="source-inline">mac_apihooks</strong> – Checks for API hooks and allows you to detect inline hooking along with the Hooking Relocation Tables.</li>
				<li><strong class="source-inline">mac_check_sysctl</strong> – Lists all <strong class="source-inline">sysctl</strong> values and handlers. Since sysctl is an interface that allows userland components to communicate with the kernel, it was widely used by different rootkits. <strong class="source-inline">Sysctl</strong> hooks provide an opportunity to hide rootkit data and create backdoors.</li>
				<li><strong class="source-inline">mac_check_trap_table</strong> – Checks whether trap table entries are hooked. Trap table was implemented to satisfy requests to the BSD layer of OS X and macOS. Replacing trap table entries can be used for rootkit implementation, so it is also of interest to threat actors and malware.</li>
				<li><strong class="source-inline">mac_notifiers</strong> – Detects rootkits that add hooks into I/O Kit. I/O Kit is a set of different tools and APIs that provides an opportunity to interact with hardware devices and can be abused by rootkits.</li>
				<li><strong class="source-inline">mac_trustedbsd</strong> – Lists malicious <strong class="source-inline">trustedbsd</strong> policies. The TrustedBSD subsystem <a id="_idIndexMarker592"/>allows you to control access to system resources through policies that determine which processes can access which resources. Often these policies are one of the targets of rootkits.</li>
			</ul>
			<p>By searching for anomalies and traces of manipulation of the aforementioned objects, we can thus detect rootkits on macOS.</p>
			<h1 id="_idParaDest-152"><a id="_idTextAnchor167"/>Summary</h1>
			<p>The process of analyzing macOS memory dumps itself is not very different from that of Windows or Linux. However, there are a number of nuances to be considered. </p>
			<p>First, Volatility profiles for the latest versions of macOS are hardly available, and at the moment, the only more or less adequate way to get them is to use proprietary memory dumping solutions, where profiles can be created automatically along with the dump. </p>
			<p>Secondly, not all of the Volatility plugins that work fine on older versions of macOS show good results on the latest versions of the operating system. In addition, the performance of the plugins may depend on the architecture of the chip used on the target host from which the dump was taken.</p>
			<p>Third, the tools that we used for file recovery from Windows and Linux, such as PhotoRec, will not be so helpful for macOS versions starting from macOS High Sierra, as they lack APFS support.</p>
			<p>Otherwise, the methods of analysis of memory dumps themselves remain the same. When analyzing user activity, we tend to focus on running applications and the dynamic data they contain, Apple applications such as Calendar or Contacts, data from the Keychain, and mounted devices. To detect malicious activity, we focus on examining network connections, looking for anomalies in processes, detecting injected code and libraries, and detecting persistence techniques used.</p>
		</div>
	</div></body></html>