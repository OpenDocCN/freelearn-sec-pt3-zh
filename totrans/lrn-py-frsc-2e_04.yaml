- en: Working with Serialized Data Structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we'll develop greater skills while working with nested lists
    and dictionaries by manipulating **JavaScript Object Notation** (**JSON**) structured
    data. Our artifact of interest is raw Bitcoin account data that contains, among
    other things, a list of all sent and received transactions. We'll access this
    dataset using a web **Application Programming Interface** (**API**) and parse
    it in a manner conducive to analysis.
  prefs: []
  type: TYPE_NORMAL
- en: APIs are created for software products and allow programmers to interface with
    the software in defined ways. Publicly accessible APIs aren't always available
    for the given software. When available, they expedite code development by offering
    methods to interact with the software, as the APIs will handle lower-level implementation
    details. Developers implement APIs to encourage others to build supporting programs
    and, additionally, control the manner in which other developers' code interacts
    with their software. By creating an API, developers are giving other programmers
    a controlled manner of interfacing with their program.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we'll use the web API from [https://www.blockchain.info](https://www.blockchain.info)
    to query and receive Bitcoin account information for a given Bitcoin address.
    The JSON data that this API generates can be converted into Python objects using
    the JSON module from the standard library. Instructions and examples of their
    API can be found at [https://www.blockchain.info/api/blockchain_api](https://www.blockchain.info/api/blockchain_api).
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Discussing and manipulating serialized structures including **Extensible Markup
    Language** (**XML**) and JSON data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating logs with Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reporting results in a CSV output format
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code for this chapter was developed and tested using Python 2.7.15 and Python
    3.7.1\. The `bitcoin_address_lookup.v1.py` and `bitcoin_address_lookup.v2.py`
    scripts were developed to work with Python 3.7.1 and not Python 2.7.15.
  prefs: []
  type: TYPE_NORMAL
- en: Serialized data structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Serialization is a process whereby data objects are preserved during storage
    on a computer system. Serializing data preserves the original type of the object.
    That's to say, we can serialize dictionaries, lists, integers, or strings into
    a file. Sometime later, when we deserialize this file, those objects will still
    maintain their original data type. Serialization is great because if, for example,
    we stored script objects to a text file, we wouldn't be able to feasibly reconstruct
    those objects into their appropriate data types as easily. As we know, reading
    a text file reads in data as a string.
  prefs: []
  type: TYPE_NORMAL
- en: XML and JSON are the two common examples of plain text-encoded serialization
    formats. You may already be accustomed to analyzing these files in forensic investigations.
    Analysts familiar with mobile device forensics will likely recognize application-specific
    XML files containing account or configuration details. Let's look at how we can
    leverage Python to parse XML and JSON files.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the `xml` module to parse any markup language that includes XML
    and HTML data. The following `book.xml` file in the text contains the details
    about this book. If you''ve never seen XML data before, the first thing you may
    note is that it''s similar in structure to HTML, another markup language, where
    contents are surrounded by opening and closing tags, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: For analysts, XML and JSON files are easy to read because they're in plain text.
    However, a manual review becomes impractical when working with files containing
    thousands of lines. Fortunately, these files are highly structured, and even better,
    they're meant to be used by programs.
  prefs: []
  type: TYPE_NORMAL
- en: 'To explore XML, we need to use the `ElementTree` class from the `xml` module,
    which will parse the data and allow us to iterate through the children of the
    root node. In order to parse the data, we must specify the file being parsed.
    In this case, our `book.xml` file is located in the same working directory as
    the Python interactive prompt. If this weren''t the case, we would need to specify
    the file path in addition to the filename. If you''re using Python 2, please make
    sure to import `print_function` from `__future__ `. We use the `getroot()` function
    to access the root-level node, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'With the root element, let''s use the `find()` function to search for the first
    instance of the `authors` tag in the XML file. Each element has different properties,
    such as `tag`, `attrib`, and `text`. The `tag` element is a string that describes
    the data, which in this case is `authors`. An attribute(s) or `attrib` are stored
    in a dictionary if present. Attributes are values assigned within a tag. For example,
    we could have created a `chapter` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The attributes for this object would be a dictionary with the keys number, title,
    and count and their respective values. To access the content between the tags
    (for example, `chapterNumber`), we would need to use the `text` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the `findall()` function to find all occurrences of a specified
    child tag. In the following example, we''re looking for every instance of `chapters/element` found
    in the dataset. Once found, we can use list indices to access specific tags within
    the `element` parent tag. In this case, we only want to access the chapter number
    and title in the first two positions of the element. Look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: There are a number of other methods we can use to process markup language files
    using the `xml` module. For the full documentation, please see [https://docs.python.org/3/library/xml.etree.elementtree.html](https://docs.python.org/3/library/xml.etree.elementtree.html)[.](https://docs.python.org/3/library/xml.etree.elementtree.html)
  prefs: []
  type: TYPE_NORMAL
- en: 'With XML covered, let''s look at that same example stored as JSON data and,
    more importantly, how we use Python to interpret that data. Later, we''re going
    to create a JSON file named `book.json`; note the use of keys, such as title,
    authors, publisher, and their associated values are separated by a colon. This
    is similar to how a dictionary is structured in Python. In addition, note the
    use of the square brackets for the `chapters` key and then how the embedded dictionary-like
    structures are separated by commas. In Python, this `chapters` structure is interpreted
    as a list containing dictionaries once it''s loaded with the `json` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'To parse this data structure using the `json` module, we use the `loads()`
    function. Unlike our XML example, we need to first open a file object before we
    can use `loads()` to convert the data. In the next code block, the `book.json`
    file, which is located in the same working directory as the interactive prompt,
    is opened and its contents are read into the `loads()` method. As an aside, we
    can use the `dump()` function to perform the reverse operation and convert Python
    objects into the JSON format for storage. As with the XML code block, if you''re
    using Python 2, please import `print_function` from `__future__`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The module's `loads()` method reads the JSON file's string content and rebuilds
    the data into Python objects. As you can see in the preceding code, the overall
    structure is stored in a dictionary with key and value pairs. JSON is capable
    of storing the original data type of the objects. For example, `pageCount` is
    deserialized as an integer and `title` as a string object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Not all the data is stored in the form of dictionaries. The `chapters` key
    is rebuilt as a list. We can use a `for` loop to iterate through `chapters` and
    print out any pertinent details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: To be clear, the `chapters` key was stored as a list in the JSON file and contained
    nested dictionaries for each `chapter` element. When iterating through the list
    of dictionaries, we stored and then printed values associated with the dictionary
    keys to the user. We'll be using this exact technique on a larger scale to parse
    our Bitcoin JSON data. More details regarding the `json` module can be found at
    [https://docs.python.org/3/library/json.html](https://docs.python.org/3/library/json.html).
    Both the XML and JSON example files used in this section are available in the
    code bundle for this chapter. Other modules exist, such as `pickle` and `shelve`,
    which can be used for data serialization. However, they won't be covered in this
    book.
  prefs: []
  type: TYPE_NORMAL
- en: A simple Bitcoin web API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Bitcoin has caught the world by storm and is making headlines; it's the most
    successful and famous—or infamous, depending on whom you speak to—decentralized
    cryptocurrency. Bitcoin is regarded as an "anonymous" online cash substitute.
    SilkRoad, an illegal marketplace on the Tor network, which has been shut down,
    accepted Bitcoin as payment for illicit goods or services. Since gaining popularity,
    some websites and brick and mortar stores accept Bitcoins for payment. It has
    also gained vast public attention for climbing to unforeseen heights as its value
    rose well above everyone's expectations.
  prefs: []
  type: TYPE_NORMAL
- en: Bitcoin assigns individuals addresses to store their Bitcoins. These users can
    send or receive Bitcoins by specifying the address they would like to use. In
    Bitcoin, addresses are represented as 34 case-sensitive alphanumeric characters.
    Fortunately, all transactions are stored publicly on the blockchain. The blockchain
    keeps track of the time, input, output, and values for each transaction. In addition,
    each transaction is assigned a unique transaction hash.
  prefs: []
  type: TYPE_NORMAL
- en: Blockchain explorers are programs that allow an individual to search the blockchain.
    For example, we can search for a particular address or transaction of interest.
    One such blockchain explorer is at [https://www.blockchain.com/explorer](https://www.blockchain.com/explorer) and
    is what we'll use to generate our dataset. Let's take a look at some of the data
    we'll need to parse.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our script will ingest the JSON-structured transaction data, process it, and
    output this information to examiners in an analysis-ready state. After the user
    inputs the address of interest, we''ll use the `blockchain.info` API to query
    the blockchain and pull down the relevant account data, including all associated
    transactions, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll query the preceding URL by replacing `%btc_address%` with the actual
    address of interest. For this exercise, we''ll be investigating the `125riCXE2MtxHbNZkRtExPGAfbv7LsY3Wa`
    address. If you open a web browser and replace `%btc_address%` with the address
    of interest, we can see the raw JSON data that our script will be responsible
    for parsing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This is a more complicated version of our previous JSON example; however, the
    same rules apply. Starting with `hash160`, there's general account information,
    such as the address, number of transactions, balance, and total sent and received.
    Following that is the transaction array, denoted by the square brackets, that
    contains each transaction the address was involved in.
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking at an individual transaction, a few keys stand out, such as the `addr`
    value from the input and output lists, time, and hash. When we iterate through
    the `txs` list, these keys will be used to reconstruct each transaction and display
    that information to the examiner. We have the following transaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As with the previous chapter, we'll approach this task in a modular way by iteratively
    building our script. Besides working with serialized data structures, we're also
    going to introduce the concepts of creating logs and writing data to CSV files.
    Like `argparse`, the `logging` and `csv` modules will feature regularly in our
    forensic scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Our first iteration – bitcoin_address_lookup.v1.py
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first iteration of our script will focus primarily on ingesting and processing
    the data appropriately. In this script, we'll print out transaction summaries
    for the account to the console. In later iterations, we'll add logging and outputting
    data to a CSV file. This script has been written and tested specifically for Python
    3.7.1\. The usage of the `urllib` library, a library we use to make HTTP requests,
    is structured differently in Python 2 and 3\. In the final iteration of this script,
    we'll demonstrate the necessary code to make this script Python 2 and 3 compatible.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll use five modules in the initial version of the script. The `argparse`, `json`, `urllib`,
    and `sys` modules are all part of the standard library. The `unix_converter` module
    is the mostly unmodified script that we wrote in [Chapter 2](b09a5e87-9ada-41cb-ba04-bd61c744bf99.xhtml), *Python
    Fundamentals*, and is used here to convert Unix timestamps into the Bitcoin transaction
    data. The specific version of this module is available in the provided code for
    this chapter. Both `argparse` and `urllib` have been used previously for user
    input and web requests, respectively. The `json` module is responsible for loading
    our transaction data into Python objects that we can manipulate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Our script's logic is handled by five functions. The `main()` function, defined
    on line 42, serves as the coordinator between the other four functions. First,
    we pass the address supplied by the user to the `get_address()` function. This
    function is responsible for calling the `blockchain.info` API using `urllib` and
    returning the JSON data containing the transactions for that address.
  prefs: []
  type: TYPE_NORMAL
- en: 'Afterward, `print_transactions()` is called to traverse the nested dictionaries
    and lists and print out transaction details. In `print_transactions()`, function
    calls are made to `print_header()` and `get_inputs()`. The `print_header()` function
    is responsible for printing out non-transaction data, such as the number of transactions,
    current balance, and total sent and received values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'As seen before, we use `argparse` to create an `ArgumentParser` object and
    add the appropriate argument. Our only argument, `ADDR`, is a positional argument
    representing the Bitcoin address of interest. We call the `main()` function on
    line 145 and pass the `ADDR` argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'A flow diagram of our script can be seen as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fe65d8a5-f688-45fc-964f-29f78b22e0d4.png)'
  prefs: []
  type: TYPE_IMG
- en: Exploring the main() function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `main()` function is relatively simple. First, on line 48 we call the `get_address()`
    function and store the result in a variable named `raw_account`. This variable
    contains our JSON-formatted transaction data. In order to manipulate this data,
    we use the `json.loads()` function to deserialize the JSON data and store it in
    the account variable. At this point, our account variable is a series of dictionaries
    and lists that we can begin to traverse, which is exactly what we do in the `print_transactions()`
    function called on line 50:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Understanding the get_address() function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is an integral, though a potentially error-prone, component of our script
    because it relies on the user correctly supplying data. The code itself is just
    a simple data request. However, when working with user supplied arguments, it
    isn''t safe to assume that the user gave the script the correct data. Considering
    the length and somewhat random-looking sequence of a Bitcoin address, it''s entirely
    possible that the user might supply an incorrect address. We''ll catch any instance
    of `URLError` from the `urllib.error` module to handle a malformed input. `URLError`
    isn''t part of the built-in exceptions we''ve talked about before and is a custom
    exception defined by the `urrlib` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'On line 62, we insert the user-supplied address into the `blockchain.info`
    API call using the string `format()` method. Then, we try to return the data requested
    using the `urllib.request.urlopen()` function. If the user supplies an invalid
    address or if the user doesn''t have an internet connection, `URLError` will be
    caught. Once the error has been caught, we notify the user and exit the script,
    calling `sys.exit(1)` on line 67:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Working with the print_transactions() function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This function handles the bulk of the processing logic in our code. This function
    traverses the transactions, or `txs`, list of embedded dictionaries from the loaded
    JSON data.
  prefs: []
  type: TYPE_NORMAL
- en: For each transaction, we'll print out its relative transaction number, the transaction
    hash, and the time of the transaction. Both the hash and time keys are easy to
    access as their values are stored in the outermost dictionary. The input and output
    details of the transaction are stored in an inner dictionary mapped to the input
    and output keys.
  prefs: []
  type: TYPE_NORMAL
- en: As is often the case, the time value is stored in Unix time. Luckily, in [Chapter
    2](b09a5e87-9ada-41cb-ba04-bd61c744bf99.xhtml), *Python Fundamentals*, we wrote
    a script to handle such conversions, and once more we'll reuse this script by
    calling the `unix_converter()` method. The only change made to this function was
    removing the UTC label as these time values are stored in local time.
  prefs: []
  type: TYPE_NORMAL
- en: Because we imported `unix_converter` as `unix`, we must refer to the module
    as `unix`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a quick look at the data structure we're dealing with. Imagine if
    we could pause the code during execution and inspect contents of variables, such
    as our account variable. At this point in this book, we'll just show you the contents
    of the `account` variable at this stage of execution. Later on in this book, we'll
    more formally discuss debugging in Python using the `pdb` module.
  prefs: []
  type: TYPE_NORMAL
- en: More information on the Python Debugger (`pdb`) is available in the documentation
    at [https://docs.python.org/3/library/pdb.html](https://docs.python.org/3/library/pdb.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we can see the keys mapped to the first transaction
    in the `txs` list within the `account` dictionary. The `hash` and `time` keys
    are mapped to string and integer objects, respectively, which we can preserve
    as variables in our script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to access the input and output details for the transaction. Let''s
    take a look at the `out` dictionary. By looking at the keys, we can immediately
    identify the address, `addr`, and `value` sent as being valuable information.
    With an understanding of the layout and what data we want to present to the user,
    let''s take a look at how we process each transaction in the `txs` list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Before printing details of each transaction, we call and print basic account
    information parsed by the `print_header()` helper function to the console on line
    77\. On line 79, we begin to iterate through each transaction in the `txs` list.
    We''ve wrapped the list with the `enumerate()` function to update our counter,
    and the first variable in the `for` loop, `i`, to keep track of which transaction
    we''re processing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'For each transaction, we print the relative transaction number, `hash`, and
    `time`. As we saw earlier, we can access `hash` or `time` by supplying the appropriate
    key. Remember that we do need to convert the Unix timestamp stored in the `time`
    key. We accomplish this by passing the value to the `unix_converter()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'On line 84, we begin to traverse the output list in the outside dictionary.
    This list is made up of multiple dictionaries with each representing an output
    for a given transaction. The keys we''re interested in these dictionaries are
    the `addr` and `value` keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Be aware that the `value` value (not a typo) is stored as a whole number rather
    than a float and so a transaction of 0.025 BTC is stored as 2,500,000\. We need
    to multiply this value by 10^(-8) to accurately reflect the value of the transaction.
    Let''s call our helper function, `get_inputs()`, on line 85\. This function will
    parse the input for the transaction separately and return the data in a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: On line 86, we check to see whether there's more than one input address. That
    conditional will dictate what our print statement looks like. Essentially, if
    there's more than one input address, each address will be joined with an ampersand
    to clearly indicate the additional addresses.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `print` statements on lines 87 and 91 use the string formatting method
    to appropriately display our processed data in the console. In these strings,
    we use the curly braces to denote three different variables. We use the `join()`
    function to convert a list into a string by joining on some delimiter. The second
    and third variables are the output `addr` and `value` keys, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Note how the designation for the value object is different from the rest. Because
    our value is a float, we can use string formatting to properly display the data
    to the correct precision. In the format descriptor, `{:.8f}`, the `8` represents
    the number of decimal places we want to allow. If there are more than eight decimal
    places, the value is rounded to the nearest number. `f` lets the `format()` method
    know that the input is expected to be of the float type. This function, while
    responsible for printing out the results to the user, uses two helper functions
    to perform its job.
  prefs: []
  type: TYPE_NORMAL
- en: The print_header() helper function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `print_header()` helper function prints the account information to the
    console before transactions are printed. Specifically, the address, number of
    transactions, current balance, and total Bitcoins sent and received are displayed
    to the user. Take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'On lines 105 through 113, we print our values of interest using the string
    formatting method. During our program design, we chose to create this as a separate
    function in order to improve our code readability. Functionally, this code could
    have easily been, and originally was, in the `print_transactions()` function.
    It was separated to compartmentalize the different phases of execution. The purpose
    of the print statement on line 113 is to create a line of 22 left-aligned equal
    signs to visually separate the account information from the transactions in the
    console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The get_inputs() helper function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This helper function is responsible for obtaining the addresses responsible
    for sending the transaction. This information is found within multiple nested
    dictionaries. As there could be more than one input, we must iterate through one
    or more elements in the input list. As we find input addresses, we add them to
    an input list that''s instantiated on line 123, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'For each input, there''s a dictionary key, `prev_out`, the value of which is
    another dictionary. The information we''re looking for is mapped to the `addr`
    key within this inner dictionary. We append these addresses to our input list,
    which we return on line 126 after the `for` loop execution ends:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Running the script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s run our script and see the fruits of our labor. In the output mentioned
    later in the text, we can see that first the header information is printed to
    the user, followed by a number of transactions. The value objects are properly
    represented with the appropriate precision. For this particular example, there
    are four input values. Using the `'' & ''.join(inputs)` statement allows us to
    more clearly separate the different input values from each other:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/46aaf00a-753d-4210-a081-15ba98cecdc6.png)'
  prefs: []
  type: TYPE_IMG
- en: With our proof-of-concept complete, we can now iterate through and resolve some
    inherent issues in our current build. One problem is that we're not recording
    any data about the execution of our script. For example, an examiner's notes should
    contain the time, any errors or issues, and results of forensic processes. In
    the second iteration, we'll tackle this issue with the logging module. This module
    will store a log of our program's execution so the analyst has notes of when the
    program started, stopped, and any other relevant data regarding the process.
  prefs: []
  type: TYPE_NORMAL
- en: Our second iteration – bitcoin_address_lookup.v2.py
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This iteration fixes one issue of our script by recording the details of execution.
    Really, we're using a log to create a chain of custody for the script. Our chain
    of custody will inform another party what our script did at various points in
    time and any errors encountered. Did we mention the traditional purpose of logging
    is for debugging? Nevertheless, our forensically commandeered log will be suitable
    in either scenario. This will serve as a brief tutorial on the basics of the logging
    module by using it in a real example. For more examples and references, please
    refer to the documentation at [https://docs.python.org/3/library/logging.html](https://docs.python.org/3/library/logging.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve added two modules to our imports: `os` and `logging`. If the user supplies
    the log file directory, we''ll use the `os` module to append that directory and
    update the path of our log. In order to write a log, we''ll use the `logging`
    module. Both of these modules are part of the standard library. See the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Due to the additional code, our functions are defined later on in the script.
    However, their flow and purpose remain the same as before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve added a new optional argument, `-l`, on line 155\. This optional argument
    can be used to specify the desired directory to write the log to. If it isn''t
    supplied, the log is created in the current working directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'On line 159, we check whether the optional argument, `-l`, was supplied by
    the user. If it is, we use the `os.path.join()` function to append our desired
    log filename to the supplied directory and store it in a variable named `log_path`.
    If the optional argument isn''t supplied, our `log_path` variable is just the
    filename of the log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The logging object is created on line 165 using the `logging.basicConfig()`
    method. This method accepts a variety of keyword arguments. The `filename` keyword
    argument is the file path and the name of our log file that we stored in the `log_path`
    variable. The `level` keyword sets the level of the log. There are five different
    logging levels, in the default order of lowest to highest urgency:'
  prefs: []
  type: TYPE_NORMAL
- en: '`DEBUG`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`INFO`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WARN` (default level)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ERROR`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CRITICAL`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If the level isn''t supplied, the log defaults to `WARN`. The level of the
    log ends up being very important. A log will only record an entry if the message
    is at the same level or higher than the log level. By setting the log to the `DEBUG`
    level, the lowest level, we can write messages of any level to the log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Each level has a different significance and should be used appropriately. The
    `DEBUG` level should be used when logging technical details about program execution.
    The `INFO` level can be used to record the program start, stop, and success of
    various phases of execution. The remaining levels can be used when detecting potentially
    anomalous execution, when an error is generated, or at critical failures.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `format` keyword specifies how we want to structure the log itself. Our
    log will have the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, this format will create a log file with the local time when the
    entry is added, the appropriate level, and any message, all separated by pipes.
    To create an entry in the log, we can call the `debug()`, `info()`, `warn()`,
    `error()`, or `critical()` methods on our logging object and pass in the message
    as a string. For example, based on the following code, we would expect to see
    the following entry generated in our log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Finally, the `filemode='w'` argument is used to overwrite previous entries in
    the log every time the script is executed. This means that only entries from the
    most recent execution will be stored in the log. If we wanted to append each execution
    cycle to the end of the log, we would omit this keyword argument. When omitted,
    the default file mode is a which, as you learned in [Chapter 1](8764f55f-76ef-4890-afbd-2fd1b6d39210.xhtml),
    *Now for Something Complete**l**y Different*, allows us to append to the bottom
    of a pre-existing file.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can begin writing information to the log after it has been configured. On
    lines 172 and 173, we record details of the user''s system before program execution.
    We write this to the log at the `DEBUG` level due to the technically low-level
    nature of the content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This version of our script is largely the same and follows the same flow schematic
    as seen previously.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying the main() function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `main()` function, defined on line 44, is largely untouched. We''ve added
    two `INFO` level messages to the log regarding the script''s execution on lines
    50 and 52\. The remainder of the method follows as seen in the first iteration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Improving the get_address() function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With the `get_address()` method, we''ve continued adding logging messages to
    our script. This time, when catching `URLError`, we stored the `Exception` object
    as `e` to extract additional information from it for debugging:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'For `URLError`, we''ll want to log the `code`, `headers`, and `reason` attributes.
    These attributes contain information, such as the HTML error code—for example,
    `404` for a web page that isn''t found—and a description of the reason for the
    error code. We''ll store this data to preserve the context surrounding the error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Elaborating on the print_transactions() function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We define the `print_transaction()` function on line 81\. We''ve made a few
    alterations to the function, starting on line 88 where we added an entry to log
    the current execution phase. Take a look at the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'For the conditional statement starting on line 99, we add different cases using
    `if`, `elif`, and `else` statements to handle when the number of input values
    is greater than, equal to, or other than one. While rare, the first ever Bitcoin
    transaction, for example, had no input address. When an input address is absent,
    it''s ideal to write a warning in the log that there are no detected inputs and
    print this information for the user, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Running the script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The remaining functions, `print_header()` and `get_inputs()`, weren't changed
    from the previous iteration. The entire code won't require modifications between
    iterations. By building a strong output module, we were able to avoid any adjustments
    to the reporting.
  prefs: []
  type: TYPE_NORMAL
- en: 'While results are still displayed in the console, we now have a written log
    of the program execution. Running the script with a specified `-l` switch will
    allow us to store the log in a specific directory. Otherwise, the current working
    directory is used. The following are the contents of the log after the script
    completed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f33ac7b6-4ef6-44fd-a3d4-6bf235db5d4d.png)'
  prefs: []
  type: TYPE_IMG
- en: With logging accomplished, we've identified yet another area of enhancement
    for our code. For this particular address, we have a manageable number of transactions
    that get printed to the console. Imagine a case where there are hundreds of transactions
    for a single address. Navigating that output and being able to identify a specific
    transaction of interest isn't that straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: Mastering our final iteration – bitcoin_address_lookup.py
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the final iteration, we'll write the output of our script to a CSV file rather
    than the console. This allows examiners to quickly filter and sort data in a manner
    conducive to analysis.
  prefs: []
  type: TYPE_NORMAL
- en: On line 4, we've imported the `csv` module that's a part of the standard library.
    Writing to a CSV file is fairly simple compared with other output formats, and
    most examiners are very comfortable with manipulating spreadsheets.
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned previously in this chapter, in this final iteration of our script,
    we''ve added the necessary logic to detect whether Python 2 or Python 3 is being
    used to call the script. Depending on the version of Python, the appropriate `urllib`
    or `urllib2` functions are imported into this script. Note that we directly import
    the function, `urlopen()`, and `URLError`, which we plan to use so that we may
    call them directly in the script. This allows us to avoid using additional conditional
    statements later on to identify whether we should call `urllib` or `urllib2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The main focus of this final iteration is the addition of the new function,
    `csv_writer()`. This function is responsible for writing the data returned by
    `parse_transactions()` to a CSV file. We'll need to modify the current version
    of `print_transactions()` to return the parsed data rather than printing it to
    the console. While this won't be an in-depth tutorial on the `csv` module, we'll
    discuss the basics of using this module in the current context. We'll use the
    `csv` module extensively and explore additional features throughout this book.
    Documentation for the `csv` module can be found at [http://docs.python.org/3/library/csv.html](http://docs.python.org/3/library/csv.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s first open an interactive prompt to practice creating and writing to
    a CSV file. First, let''s import the `csv` module that will allow us to create
    our CSV file. Next, we create a list named `headers`, which will store the column
    headers of our CSV file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Next, we'll open a file object using the built-in `open()` method with the appropriate
    file mode. In Python 2, a CSV file object should be opened in the `rb` or `wb`
    modes for reading and writing, respectively. In this case, we'll be writing to
    a CSV file so let's open the file in the `wb` mode. The `w` stands for write,
    and the `b` stands for binary mode.
  prefs: []
  type: TYPE_NORMAL
- en: In Python 3, a CSV file should be opened in the `w` mode with a newline character
    specified, as demonstrated here: `open('test.csv', 'w', newline='')`.
  prefs: []
  type: TYPE_NORMAL
- en: 'With our connection to the file object, `csvfile`, we now need to create a
    writer or reader (depending on our desired goal) and pass in the file object.
    There are two options—the `csv.writer()` or `csv.reader()` methods; both expect
    a file object as their input and accept various keyword arguments. The list object
    meshes well with the `csv` module, requiring little code to write the data to
    a CSV file. It isn''t difficult to write a dictionary and other objects to a CSV
    file, but is out of scope here and will be covered in later chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The `writer.writerow()` method will write one row using the supplied list.
    Each element in the list will be placed in sequential columns on the same row.
    If, for example, the `writerow()` function is called again with another list input,
    the data will now be written one row below the previous write operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: In practical situations, we've found that using nested lists is one of the simplest
    ways of iterating through and writing each row. In our final iteration, we'll
    store the transaction details in a list and append them within another list. We
    can then iterate through each transaction while writing the details to the CSV
    as we go along.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with any file object, be sure to flush any data that''s in a buffer to the
    file and then close the file. Forgetting these steps aren''t the end of the world
    as Python will mostly handle this automatically, but they''re highly recommended.
    After executing these last lines of code, a file called `test.csv` will be created
    in your working directory with the `Date`, `Name`, and `Description` headers as
    the first row. This same code will also work with the `csv` module in Python 3,
    with the exception of modifying the initial `open()` function as demonstrated
    previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve renamed the `print_transactions()` function to `parse_transactions()`
    to more accurately reflect its purpose. In addition, on line 159 we''ve added
    a `csv_writer()` function to write our transaction results to a CSV file. All
    other functions are similar to the previous iteration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we''ve added a new positional argument named `OUTPUT`. This argument
    represents the name and/or path for the CSV output. On line 230, we pass this
    output argument to the `main()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The following flow diagram exemplifies the differences between the first two
    iterations and our final version:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/48a314b5-c2b7-42f8-bb5a-462973d76d21.png)'
  prefs: []
  type: TYPE_IMG
- en: Enhancing the parse_transactions() function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This function, which was previously named `print_transactions()`, is used to
    process the transaction data so it can be ingested by our `csv_writer()`. Please
    note that the `print_header()` function call has now been moved into the `main()`
    function. We''re also now passing an output argument to `parse_transactions()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'As we''ve seen previously, we must first iterate through the `transactions`
    list. As we traverse the data, we''ll append it to a transaction list, which is
    created on line 104\. This list represents a given transaction and its data. After
    we''re finished appending transaction data, we append this list to the `transactions` list
    that serves as a container for all of the transactions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to match an output address with its value, we create an `outputs`
    dictionary on line 107\. On line 114, we create a key representing the address
    and value sent to it. Note that we use the newline character, `\n`, on lines 115
    through 117 when combining multiple output addresses and their values so they''re
    visually separate within one cell. We''ve also performed the same action in the
    `get_inputs()` function to handle multiple input values. This was a design choice
    we made because we''ve seen that there can be multiple output addresses. Rather
    than placing these in their own columns, we''ve opted to place them all in one
    column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'On line 118, we created a new value using the `sum()` built-in function, to
    sum the output values together. The `sum()` function is quite handy and accepts
    a list of `int` or `float` types as input and returns the sum:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have all of our desired transaction details in the `transaction` list.
    We append the transaction to the `transactions` list on line 119\. Once all transactions
    have been added to the `transactions` list, we call the `csv_writer()` method
    and pass in our `transactions` list and `output` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Once again, we've made no modifications to the `print_header()` or `get_address()`
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: Developing the csv_writer() function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'On line 159, we define our `csv_writer()` function. Before writing our transaction
    data to a CSV file, we log our current execution phase and create a `headers`
    variable. This `headers` list represents the columns in our spreadsheet and will
    be the first row written to the file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: As with any user-supplied data, we must account for the possibility that the
    supplied data could be incorrect or generate an exception. For example, the user
    could specify a non-existent directory in the output path argument. On lines 173
    and 175, we open the `csvfile` in the appropriate manner, depending on the version
    of Python being used, and write our CSV data under one `try` and `except` clause.
    If there's an issue with the user-supplied output, we'll receive an `IOError`
    exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'We create our writer object on line 177 and write our `headers`, before iterating
    through our transactions list. Every transaction within the transactions list
    is written on its own row. Finally, on lines 181 and 182, we flush and close the
    CSV file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'If `IOError` is generated, we write the error message and contextual information
    to the log before exiting with an error (any nonzero exit). If there are no errors
    generated, we log the completion of the script and exit without errors (also known
    as a zero exit), as seen on line 191 through 193:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Running the script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This iteration finally addresses the remaining issue we identified, which is
    a means of processing the data into an examination-ready state. Now if an address
    had hundreds or thousands of transactions, the examiner can analyze that data
    more efficiently than if it were displayed in a console.
  prefs: []
  type: TYPE_NORMAL
- en: This being said, as with most things, there's always room for improvement. For
    example, the way in which we've handled multiple input and output values means
    that it will have more than one address in a specific cell. This can be annoying
    when trying to filter for a specific address. The point here is that a script
    is never truly finished being developed and is always an ongoing process.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run the script, we now must supply two arguments: the Bitcoin address and
    desired output. The following is an example of usage and output printed to the
    console when running our script:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/719183b2-b791-4dcb-a05c-8d7391c5adda.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `transactions.csv` file will be written to the current working directory
    as specified. The following screenshot captures what this spreadsheet might look
    like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/135e3159-d3f2-4399-9ee6-37117663dfd9.png)'
  prefs: []
  type: TYPE_IMG
- en: Challenge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For an additional challenge, modify the script so that each output and input
    address has its own cell. We recommend approaching this by determining the maximum
    number of input values or output addresses in a list of transactions. Knowing
    these values, you could build a conditional statement to modify the header so
    that it has the appropriate number of columns. In addition, you would need to
    write logic to skip those columns when you don't have multiple input or output
    values in order to preserve the correct spacing of data.
  prefs: []
  type: TYPE_NORMAL
- en: While specific to Bitcoin, examples in the wild may require similar logic when
    there exists a dynamic relationship between two or more data points. Tackling
    this challenge will help develop a logical and practical methodology that can
    be applied in future scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we gained greater familiarity with common serialized structures,
    Bitcoin, and CSV and with working with nested lists and dictionaries. Being able
    to manipulate lists and dictionaries is a vital skill, as data is often stored
    in mixed nested structures. Remember to always use the `type()` method to determine
    what type of data you're working with.
  prefs: []
  type: TYPE_NORMAL
- en: For this script, we (the authors) played around with the JSON data structure
    in the Python interactive prompt before writing the script. This allowed us to
    understand how to traverse the data structure correctly and the best manner to
    do so before writing any logic. The Python interactive prompt is an excellent
    sandbox to implement new features or to test new code. The code for this project
    can be downloaded from GitHub or Packt, as described in the *Preface*.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll discuss a different method to store structured data.
    While learning how to integrate databases into our scripts, we'll create an active
    file listing script that stores all of its data in an SQLite3 format. Doing this
    will allow us to become more comfortable with storing and retrieving data from
    databases in Python using two different modules.
  prefs: []
  type: TYPE_NORMAL
