<html><head></head><body>
        

                            
                    <h1 class="header-title">Social Engineering</h1>
                
            
            
                
<p>Social engineering is when an attacker manipulates or tricks a victim into performing an action or providing private information. This is often done by impersonating a trusted person, creating a sense of urgency, or creating a false pretext to push the victim to act. The action may be as simple as divulging information, or more complex like downloading and executing malware.</p>
<p>We cover honeypots in this chapter, even though they are sometimes intended to trick bots and not humans. The goal is to intentionally deceive, which is the core of social engineering. We provide basic honeypot examples including TCP and HTTP honeypots.</p>
<p>There are many other types of social engineering that are not covered in this book. This includes physical or in-person situations, such as tailgating and pretending to be a maintenance worker, as well as other digital and remote methods such as phone calls, SMS messages, and social media messaging.</p>
<p>Social engineering can be a grey area legally. For example, even if a company gives you the full scope to social engineer their employees, it does not give you permission for phishing an employee's personal email credentials. Be conscious of both the legal and ethical boundaries.</p>
<p>In this chapter, we will specifically cover the following topics:</p>
<ul>
<li>Gathering intel on an individual using Reddit's JSON REST API</li>
<li>Sending phishing emails with SMTP</li>
<li>Generating QR codes and base64 encoding images</li>
<li>Honeypots</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Gathering intel via JSON REST API</h1>
                
            
            
                
<p>REST with JSON are becoming the de facto interface for web APIs. Every API is different, so the primary objective of this example is to show how to process JSON data from a REST endpoint.</p>
<p>This example will take Reddit username as an argument, and print the recent posts and comments by that user to get an idea of what topics they discuss. Reddit was chosen for this example because no authentication is required for certain endpoints, making it easy to test. Other services that provide REST APIs that you could query for intel gathering are Twitter and LinkedIn.</p>
<p>Remember, the emphasis of this example is to provide an example of parsing JSON from a REST endpoint. Since every API is different, this example should serve as a reference when writing your own programs to interact with JSON APIs. A data structure must be defined to match the response from the JSON endpoint. In this example, the data structure created matches the Reddit response.</p>
<p>When working with JSON in Go, you first need to define the data structures, and then use theÂ <kbd>Marshal</kbd> and <kbd>Unmarshal</kbd> functions to encode and decode between the raw string and structured data formats. The following example creates a data structure that matches the structure of the JSON returned by Reddit. The <kbd>Unmarshal</kbd> function is then used to convert the string into a Go data object. You don't have to create a variable for every piece of data in the JSON. You can omit the fields you don't need.</p>
<p>The data in the JSON response is nested into many levels, so we will make use of anonymous structs. This prevents us from having to create a separate named type for every single level of nesting. This example creates one named struct with all of the nested levels stored as embedded anonymous structs.</p>
<p>The variable names in the Go data structs do not match the variable names provided in the JSON response, so the JSON variable name is provided right after the data type is defined in the structs. This allows the variables to be properly mapped from the JSON data to the Go struct. This is often necessary due to the case-sensitive nature of the variable names in a Go data structure.</p>
<p>Note that every web service has its own terms of service, which may limit or restrict the way you access their site. Some sites have rules against scraping and others have rate limits. While it may not be a criminal offense, the service may block your account or IP address for violating terms of service. Be sure to read the terms of service for every website or API you interact with.</p>
<p>The code for this example is as follows:</p>
<pre>package main<br/><br/>import (<br/>   "encoding/json"<br/>   "fmt"<br/>   "io/ioutil"<br/>   "log"<br/>   "net/http"<br/>   "os"<br/>   "time"<br/>)<br/><br/>// Define the structure of the JSON response<br/>// The json variable names are specified on<br/>// the right since they do not match the<br/>// struct variable names exactly<br/>type redditUserJsonResponse struct {<br/>   Data struct {<br/>      Posts []struct { // Posts &amp; comments<br/>         Data struct {<br/>            Subreddit  string  `json:"subreddit"`<br/>            Title      string  `json:"link_title"`<br/>            PostedTime float32 `json:"created_utc"`<br/>            Body       string  `json:"body"`<br/>         } `json:"data"`<br/>      } `json:"children"`<br/>   } `json:"data"`<br/>}<br/><br/>func printUsage() {<br/>   fmt.Println(os.Args[0] + ` - Print recent Reddit posts by a user<br/><br/>Usage: ` + os.Args[0] + ` &lt;username&gt;<br/>Example: ` + os.Args[0] + ` nanodano<br/>`)<br/>}<br/><br/>func main() {<br/>   if len(os.Args) != 2 {<br/>      printUsage()<br/>      os.Exit(1)<br/>   }<br/>   url := "https://www.reddit.com/user/" + os.Args[1] + ".json"<br/><br/>   // Make HTTP request and read response<br/>   response, err := http.Get(url)<br/>   if err != nil {<br/>      log.Fatal("Error making HTTP request. ", err)<br/>   }<br/>   defer response.Body.Close()<br/>   body, err := ioutil.ReadAll(response.Body)<br/>   if err != nil {<br/>      log.Fatal("Error reading HTTP response body. ", err)<br/>   }<br/><br/>   // Decode response into data struct<br/>   var redditUserInfo redditUserJsonResponse<br/>   err = json.Unmarshal(body, &amp;redditUserInfo)<br/>   if err != nil {<br/>      log.Fatal("Error parson JSON. ", err)<br/>   }<br/><br/>   if len(redditUserInfo.Data.Posts) == 0 {<br/>      fmt.Println("No posts found.")<br/>      fmt.Printf("Response Body: %s\n", body)<br/>   }<br/><br/>   // Iterate through all posts found<br/>   for _, post := range redditUserInfo.Data.Posts {<br/>      fmt.Println("Subreddit:", post.Data.Subreddit)<br/>      fmt.Println("Title:", post.Data.Title)<br/>      fmt.Println("Posted:", time.Unix(int64(post.Data.PostedTime), <br/>         0))<br/>      fmt.Println("Body:", post.Data.Body)<br/>      fmt.Println("========================================")<br/>   }<br/>} </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Sending phishing emails with SMTP</h1>
                
            
            
                
<p>Phishing is the process in which an attacker tries to obtain sensitive information via a fake email or some other form of communication designed to look like a legitimate email from a trusted source.</p>
<p>Phishing is often done via email, but can also be done over the phone, on social media, or via text messages. We are focusing on the email method. Phishing can be done on a large scale, where a generic email is sent out to a large number of recipients hoping someone will take the bait. The <em>Nigerian prince</em> email scam was a popular phishing campaign. Other emails offering incentives are popular and work relatively well, such as offering an iPhone giveaway or a gift card if they participate and follow the link you provided and logging in with their credentials. Phishing emails also often mimic legitimate senders using real signatures and company logos. A sense of urgency is often created to convince the victim to act quickly without following standard procedures.</p>
<p>You can gather emails using the program from <a href="1b5ddb7b-00f9-47df-947c-e4d0ebeb94e5.xhtml" target="_blank">Chapter 10</a>, <em>Web Scraping</em>, that extracts emails from web pages. Combine the email extraction capability with the web crawler example provided, and you have a powerful tool for scraping emails off a domain.</p>
<p><strong>Spear phishing</strong> is a term for targeted phishing that focuses on a small number of targets, maybe even just one specific target. Spear phishing requires more research and targeting, tailoring an email specific to the person, creating a believable pretext, perhaps impersonating someone they do know. Spear phishing takes more work, but it increases the likelihood of fooling a user, and reduces your chances of getting caught by spam filters.</p>
<p>When attempting a spear phishing campaign, you should first gather as much information about your target before crafting the email. Earlier in this chapter, we talked about using JSON REST APIs to gather data on a target. You can also use the word count program and the headings grabber program from <a href="1b5ddb7b-00f9-47df-947c-e4d0ebeb94e5.xhtml" target="_blank">Chapter 10</a>, <em>Web Scraping</em>, if your target individual or organization has a website. Gathering the most common words and headings of a website can be a fast way of learning what industry the target belongs to or what products and services they may offer.</p>
<p>The Go standard library comes with an SMTP package for sending emails. Go also has a <kbd>net/mail</kbd> package for parsing emails (<a href="https://golang.org/pkg/net/mail/" target="_blank">https://golang.org/pkg/net/mail/</a>). The <kbd>mail</kbd> package is relatively small and is not covered in this book, but it allows you to parse the full text of an email into a message type that lets you extract the body and headers individually. This example is focused on how to send an email with the SMTP package.</p>
<p>The configuration variables are all defined at the top of the source code. Be sure to set proper SMTP host, port, sender, and password. Common SMTP ports are <kbd>25</kbd> for unencrypted access, and portsÂ <kbd>465</kbd> and <kbd>587</kbd> are often used for encrypted access. The settings will all depend on the configuration of your SMTP server. This example will not run correctly without first setting the proper server and credentials. If you have a Gmail account, you can reuse most of the prepopulated values and just replace the sender and password.</p>
<p>If you are sending the mail using Gmail and using the two-factor authentication, you will need to create an application specific password at <a href="https://security.google.com/settings/security/apppasswords" target="_blank">https://security.google.com/settings/security/apppasswords</a>. If you are not using two-factor authentication, then enable less secure applications at <a href="https://myaccount.google.com/lesssecureapps" target="_blank">https://myaccount.google.com/lesssecureapps</a>.</p>
<p>This program creates and sends two example emails, one text and one HTML. It is also possible to send a combined text and HTML email, where the email client chooses which version to render. This can be done using the <kbd>Content-Type</kbd> header to <kbd>multipart/alternative</kbd> and setting a boundary to distinguish where the text email ends and the HTML email starts. Sending a combined text and HTML email is not covered here, but is worth mentioning. You can learn more about the <kbd>multipart</kbd> content type, <em>RFC 1341</em>, at <a href="https://www.w3.org/Protocols/rfc1341/7_2_Multipart.html" target="_blank">https://www.w3.org/Protocols/rfc1341/7_2_Multipart.html</a>.</p>
<p>Go also provides a <kbd>template</kbd> package that allows you to create a template file with variable placeholders, and then populate the placeholders with data from a struct. The templates are useful if you want to separate the template files from the source code, allowing you to modify the templates without recompiling the application. The following example does not use a template, but you can read more about templates at <a href="https://golang.org/pkg/text/template/">https://golang.org/pkg/text/template/</a>:</p>
<pre>package main<br/><br/>import (<br/>   "log"<br/>   "net/smtp"<br/>   "strings"<br/>)<br/><br/>var (<br/>   smtpHost   = "smtp.gmail.com"<br/>   smtpPort   = "587"<br/>   sender     = "sender@gmail.com"<br/>   password   = "SecretPassword"<br/>   recipients = []string{<br/>      "recipient1@example.com",<br/>      "recipient2@example.com",<br/>   }<br/>   subject = "Subject Line"<br/>)<br/><br/>func main() {<br/>   auth := smtp.PlainAuth("", sender, password, smtpHost)<br/><br/>   textEmail := []byte(<br/>      `To: ` + strings.Join(recipients, ", ") + `<br/>Mime-Version: 1.0<br/>Content-Type: text/plain; charset="UTF-8";<br/>Subject: ` + subject + `<br/><br/>Hello,<br/><br/>This is a plain text email.<br/>`)<br/><br/>   htmlEmail := []byte(<br/>      `To: ` + strings.Join(recipients, ", ") + `<br/>Mime-Version: 1.0<br/>Content-Type: text/html; charset="UTF-8";<br/>Subject: ` + subject + `<br/><br/>&lt;html&gt;<br/>&lt;h1&gt;Hello&lt;/h1&gt;<br/>&lt;hr /&gt;<br/>&lt;p&gt;This is an &lt;strong&gt;HTML&lt;/strong&gt; email.&lt;/p&gt;<br/>&lt;/html&gt;<br/>`)<br/><br/>   // Send text version of email<br/>   err := smtp.SendMail(<br/>      smtpHost+":"+smtpPort,<br/>      auth,<br/>      sender,<br/>      recipients,<br/>      textEmail,<br/>   )<br/>   if err != nil {<br/>      log.Fatal(err)<br/>   }<br/><br/>   // Send HTML version<br/>   err = smtp.SendMail(<br/>      smtpHost+":"+smtpPort,<br/>      auth,<br/>      sender,<br/>      recipients,<br/>      htmlEmail,<br/>   )<br/>   if err != nil {<br/>      log.Fatal(err)<br/>   }<br/>}</pre>
<p>Â </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Generating QR codes</h1>
                
            
            
                
<p>A <strong>Quick Response</strong> (<strong>QR</strong>) code is a two-dimensional barcode. It stores more information than a traditional one-dimensional line barcode. They were originally developed in the Japanese automotive industry, but have been adopted by other industries. QR codes were approved as an international standard by ISO in 2000. The latest specification can be found at <a href="https://www.iso.org/standard/62021.html" target="_blank">https://www.iso.org/standard/62021.html</a>.</p>
<p>QR codes can be found on some billboards, posters, handouts, and other advertising material. QR codes are also used frequently in transactions. You might see QR codes on train tickets or when sending and receiving cryptocurrency such as Bitcoin. Some authentication services such as two-factor authentication utilize QR codes for convenience.</p>
<p>QR codes are good for social engineering because a human can't tell just by looking at a QR code if it is malicious or not. Often times the QR code contains a URL that is loaded immediately, leaving the user open to risk. If you create a believable pretext, you may convince a user to trust the QR code.</p>
<p>The package used in this example is called <kbd>go-qrcode</kbd> and is available at <a href="https://github.com/skip2/go-qrcode" target="_blank">https://github.com/skip2/go-qrcode</a>. This is a third-party library available on GitHub and not supported by Google or the Go team. The <kbd>go-qrcode</kbd> package utilizes the standard library image packages: <kbd>image</kbd>, <kbd>image/color</kbd>, andÂ <kbd>image/png</kbd>.</p>
<p>Install theÂ <kbd>go-qrcode</kbd>Â package with the following command:</p>
<pre><strong>go get github.com/skip2/go-qrcode/...</strong></pre>
<p>The ellipsis (<kbd>...</kbd>) in <kbd>go get</kbd> is a wildcard. It will also install all subpackages.</p>
<p>According to the package author, the maximum capacity of the QR code varies based on the content encoded and the error recovery level. The maximum capacity is 2,953 bytes, 4,296 alphanumeric characters, 7,089 numeric digits, or a combination.</p>
<p>There are two main points being demonstrated in this program. First is how to generate the QR code in the form of raw PNG bytes, and then the data to be embedded within an HTML page is base64 encoded. The full HTML <kbd>img</kbd> tag is generated, given as an output to standard output, and can be copied and pasted directly into an HTML page. The second part demonstrates how to simply generate the QR code and have it written directly to a file.</p>
<p>This example generates a QR code in the format of a PNG image. Let's provide the text you want to encode and the output filename as command-line arguments, and the program will output the image with your data encoded as a QR image:</p>
<pre>package main 
<br/>import (<br/>   "encoding/base64"<br/>   "fmt"<br/>   "github.com/skip2/go-qrcode"<br/>   "log"<br/>   "os"<br/>)<br/><br/>var (<br/>   pngData        []byte<br/>   imageSize      = 256 // Length and width in pixels<br/>   err            error<br/>   outputFilename string<br/>   dataToEncode   string<br/>)<br/><br/>// Check command line arguments. Print usage<br/>// if expected arguments are not present<br/>func checkArgs() {<br/>   if len(os.Args) != 3 {<br/>      fmt.Println(os.Args[0] + `<br/><br/>Generate a QR code. Outputs a PNG file in &lt;outputFilename&gt;.<br/>Also outputs an HTML img tag with the image base64 encoded to STDOUT.<br/><br/> Usage: ` + os.Args[0] + ` &lt;outputFilename&gt; &lt;data&gt;<br/> Example: ` + os.Args[0] + ` qrcode.png https://www.devdungeon.com`)<br/>      os.Exit(1)<br/>   }<br/>   // Because these variables were above, at the package level<br/>   // we don't have to return them. The same variables are<br/>   // already accessible in the main() function<br/>   outputFilename = os.Args[1]<br/>   dataToEncode = os.Args[2]<br/>}<br/><br/>func main() {<br/>   checkArgs()<br/><br/>   // Generate raw binary data for PNG<br/>   pngData, err = qrcode.Encode(dataToEncode, qrcode.Medium, <br/>      imageSize)<br/>   if err != nil {<br/>      log.Fatal("Error generating QR code. ", err)<br/>   }<br/><br/>   // Encode the PNG data with base64 encoding<br/>   encodedPngData := base64.StdEncoding.EncodeToString(pngData)<br/><br/>   // Output base64 encoded image as HTML image tag to STDOUT<br/>   // This img tag can be embedded in an HTML page<br/>   imgTag := "&lt;img src=\"data:image/png;base64," + <br/>      encodedPngData + "\"/&gt;"<br/>   fmt.Println(imgTag) // For use in HTML<br/><br/>   // Generate and write to file with one function<br/>   // This is a standalone function. It can be used by itself<br/>   // without any of the above code<br/>   err = qrcode.WriteFile(<br/>      dataToEncode,<br/>      qrcode.Medium,<br/>      imageSize,<br/>      outputFilename,<br/>   )<br/>   if err != nil {<br/>      log.Fatal("Error generating QR code to file. ", err)<br/>   }<br/>} </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Base64 encoding data</h1>
                
            
            
                
<p>In the previous example, the QR code was base64 encoded. Since this is a common task, it is worth covering how to encode as well as decode. Any time binary data needs to be stored or transmitted as a string, base64 encoding is useful.</p>
<p>This example demonstrates a very simple use case of encoding and decoding a byte slice. The two important functions for base64 encoding and decoding are <kbd>EncodeToString()</kbd> and <kbd>DecodeString()</kbd>:</p>
<pre>package main<br/><br/>import (<br/>   "encoding/base64"<br/>   "fmt"<br/>   "log"<br/>)<br/><br/>func main() {<br/>   data := []byte("Test data")<br/><br/>   // Encode bytes to base64 encoded string.<br/>   encodedString := base64.StdEncoding.EncodeToString(data)<br/>   fmt.Printf("%s\n", encodedString)<br/><br/>   // Decode base64 encoded string to bytes.<br/>   decodedData, err := base64.StdEncoding.DecodeString(encodedString)<br/>   if err != nil {<br/>      log.Fatal("Error decoding data. ", err)<br/>   }<br/>   fmt.Printf("%s\n", decodedData)<br/>} </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Honeypots</h1>
                
            
            
                
<p>Honeypots are fake services you set to catch attackers. You intentionally put a service up with the intention of luring attackers, tricking them into thinking the service is real and contains some kind of sensitive information. Often, the honeypot is disguised to look like an old, outdated, and vulnerable server. Logging or alerts can be attached to the honeypot to quickly identify a potential attacker. Having a honeypot on your internal network may alert you of an attacker before any systems are compromised.</p>
<p>When attackers compromise a machine, they often use the compromised machine to continue enumerating, attacking, and pivoting. If a honeypot on your network detects strange behavior coming from another machine on your network, such as port scans or login attempts, the machine behaving strangely might be compromised.</p>
<p>There are many different kinds of honeypots. It could be anything from a simple TCP listener that logs any connection, a fake HTML page with a login form field, or a full blown web application that looks like a real employee portal. If the attacker thinks they have found a critical application, they are more likely to spend time trying to gain access. If you lay out attractive honeypots, you might get the attacker to spend the majority of their time working on a useless honeypot. If detailed logging is kept, you can learn about what methods the attacker is using, what tools they have, and perhaps even their location.</p>
<p>There are a few other types of honeypots worth mentioning, but not demonstrated in this book:</p>
<ul>
<li><strong>SMTP honeypot</strong>: This simulates an open email relay that spammers abuse to catch spammers trying to use your mailer.</li>
<li><strong>Web crawler honeypot</strong>: These are the hidden web pages that are not intended to be reached by a person, but links to it are hidden in the public places of your website, such as HTML comments, to catch spiders, crawlers, and scrapers.</li>
<li><strong>Database honeypot</strong>: This is a fake or real database with verbose logging to detect attackers, that may also contain fake data to see what information attackers are interested in.</li>
<li><strong>Honeynet</strong>: This is an entire network full of honeypots, made to look like a real network to the extent of automating or faking client traffic to the honeypot services to simulate real users.</li>
</ul>
<p>Attackers may be able to spot obvious honeypot services and avoid them. I recommend that you go with one of two extremes: making the honeypot mimic a real service as closely as possible, or making the service a total black box that does not give away any information to the attacker.</p>
<p>We cover very basic examples in this section, to help you understand the concept of honeypots and give you a template to create your own more customized honeypots. First, a basic TCP socket honeypot is demonstrated. This will listen on a port and log any connections and data it receives. To accompany this example, a TCP testing tool is provided. It behaves like a primitive version of Netcat, allowing you to send a single message to a server via standard input. This can be used to test the TCP honeypot or to extend and use for other applications. The last example is an HTTP honeypot. It provides a login form that logs attempts to authenticate, but always returns an error.</p>
<p>Make sure that you understand the risks of honeypots on your network. If you leave a honeypot running without keeping the underlying operating system updated, you are potentially adding a real risk to your network.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">TCP honeypot</h1>
                
            
            
                
<p>The simplest honeypot we will start with is a TCP honeypot. This will log any TCP connection received and any data received from the client.</p>
<p>It will respond with an authentication failure message. Since it logs any data received from the client, it will log any username and passwords they attempt to authenticate with. You can learn about their attack methods by inspecting what authentication methods they are attempting, since it acts like a black box and does not give any clues as to what authentication mechanism it might use. You can use the logs to see if they are treating it like an SMTP server, which may indicate a spammer, or maybe they are trying to authenticate with a database indicating they are looking for information. Studying the actions of an attacker can be very insightful and even enlighten to with the vulnerabilities you did not already know about. An attacker may use a service fingerprinting tool on the honeypot, and you might be able to identify patterns in their attack methods and find ways to block them. If an attacker tries to log in using real user credentials, that user is likely compromised.</p>
<p>This example will log high-level requests such as HTTP requests as well as low level connections such as a TCP port scanner. TCP connect scans will be logged, but TCP <kbd>SYN</kbd> only (stealth) scans will not be detected:</p>
<pre>package main<br/><br/>import (<br/>   "bytes"<br/>   "log"<br/>   "net"<br/>)<br/><br/>func handleConnection(conn net.Conn) {<br/>   log.Printf("Received connection from %s.\n", conn.RemoteAddr())<br/>   buff := make([]byte, 1024)<br/>   nbytes, err := conn.Read(buff)<br/>   if err != nil {<br/>      log.Println("Error reading from connection. ", err)<br/>   }<br/>   // Always reply with a fake auth failed message<br/>   conn.Write([]byte("Authentication failed."))<br/>   trimmedOutput := bytes.TrimRight(buff, "\x00")<br/>   log.Printf("Read %d bytes from %s.\n%s\n",<br/>      nbytes, conn.RemoteAddr(), trimmedOutput)<br/>   conn.Close()<br/>}<br/><br/>func main() {<br/>   portNumber := "9001" // or os.Args[1]<br/>   ln, err := net.Listen("tcp", "localhost:"+portNumber)<br/>   if err != nil {<br/>       log.Fatalf("Error listening on port %s.\n%s\n",<br/>          portNumber, err.Error())<br/>   }<br/>   log.Printf("Listening on port %s.\n", portNumber)<br/>   for {<br/>      conn, err := ln.Accept()<br/>      if err != nil {<br/>         log.Println("Error accepting connection.", err)<br/>      }<br/>      go handleConnection(conn)<br/>   }<br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">The TCP testing tool</h1>
                
            
            
                
<p>In order to test our TCP honeypot, we need to send it some TCP traffic. We can use any existing network tool, including a web browser or a FTP client to hit the honeypot. A great tool for this is also Netcat, the TCP/IP Swiss army knife. Instead of using Netcat though, let's create our own simple clone. It will simply read and write data over TCP. The input and output will be through standard input and standard output respectively, allowing you to use the keyboard and Terminal or pipe data in or out of files and other applications.</p>
<p>This tool can be used as a general purpose network testing tool, and if you have any intrusion detection system or other monitoring you want to test, it may be useful. This program will take data from standard input and send it over the TCP connection, then read any data the server sends back and print it to standard output. When running this example, you must pass the host and port as a single string with a colon separator, like this: <kbd>localhost:9001</kbd>. Here is the code for the simple TCP testing tool:</p>
<pre>package main<br/><br/>import (<br/>   "bytes"<br/>   "fmt"<br/>   "log"<br/>   "net"<br/>   "os"<br/>)<br/><br/>func checkArgs() string {<br/>   if len(os.Args) != 2 {<br/>      fmt.Println("Usage: " + os.Args[0] + " &lt;targetAddress&gt;")<br/>      fmt.Println("Example: " + os.Args[0] + " localhost:9001")<br/>      os.Exit(0)<br/>   }<br/>   return os.Args[1]<br/>}<br/><br/>func main() {<br/>   var err error<br/>   targetAddress := checkArgs()<br/>   conn, err := net.Dial("tcp", targetAddress)<br/>   if err != nil {<br/>      log.Fatal(err)<br/>   }<br/>   buf := make([]byte, 1024)<br/><br/>   _, err = os.Stdin.Read(buf)<br/>   trimmedInput := bytes.TrimRight(buf, "\x00")<br/>   log.Printf("%s\n", trimmedInput)<br/><br/>   _, writeErr := conn.Write(trimmedInput)<br/>   if writeErr != nil {<br/>      log.Fatal("Error sending data to remote host. ", writeErr)<br/>   }<br/><br/>   _, readErr := conn.Read(buf)<br/>   if readErr != nil {<br/>      log.Fatal("Error when reading from remote host. ", readErr)<br/>   }<br/>   trimmedOutput := bytes.TrimRight(buf, "\x00")<br/>   log.Printf("%s\n", trimmedOutput)<br/>} </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">HTTP POST form login honeypot</h1>
                
            
            
                
<p>When you deploy this on the network, unless you are doing intentional testing, any form submission is a red flag. This means that someone is making an attempt to log in to your fake server. Since there is no legitimate purpose for it, only an attacker would have any reason to attempt to gain access. There will be no real authentication or authorization, just a facade to make the attacker think they are attempting to log in. The Go HTTP package does support HTTP 2 by default in Go 1.6+. Read more about the <kbd>net/http</kbd> package at <a href="https://golang.org/pkg/net/http/" target="_blank">https://golang.org/pkg/net/http/</a>.</p>
<p>The following program will act as a web server with a login page, that just logs form submissions to standard output. You can run this server and then try to log in via the browser, and the log in attempt will be printed to Terminal, which runs the server:</p>
<pre>package main 
<br/>import (<br/>   "fmt"<br/>   "log"<br/>   "net/http"<br/>)<br/><br/>// Correctly formatted function declaration to satisfy the<br/>// Go http.Handler interface. Any function that has the proper<br/>// request/response parameters can be used to process an HTTP request.<br/>// Inside the request struct we have access to the info about<br/>// the HTTP request and the remote client.<br/>func logRequest(response http.ResponseWriter, request *http.Request) {<br/>   // Write output to file or just redirect output of this <br/>   // program to file<br/>   log.Println(request.Method + " request from " +  <br/>      request.RemoteAddr + ". " + request.RequestURI)<br/>   // If POST not empty, log attempt.<br/>   username := request.PostFormValue("username")<br/>   password := request.PostFormValue("pass")<br/>   if username != "" || password != "" {<br/>      log.Println("Username: " + username)<br/>      log.Println("Password: " + password)<br/>   }<br/><br/>   fmt.Fprint(response, "&lt;html&gt;&lt;body&gt;")<br/>   fmt.Fprint(response, "&lt;h1&gt;Login&lt;/h1&gt;")<br/>   if request.Method == http.MethodPost {<br/>      fmt.Fprint(response, "&lt;p&gt;Invalid credentials.&lt;/p&gt;")<br/>   }<br/>   fmt.Fprint(response, "&lt;form method=\"POST\"&gt;")<br/>   fmt.Fprint(response, <br/>      "User:&lt;input type=\"text\" name=\"username\"&gt;&lt;br&gt;")<br/>   fmt.Fprint(response, <br/>      "Pass:&lt;input type=\"password\" name=\"pass\"&gt;&lt;br&gt;")<br/>   fmt.Fprint(response, "&lt;input type=\"submit\"&gt;&lt;/form&gt;&lt;br&gt;")<br/>   fmt.Fprint(response, "&lt;/body&gt;&lt;/html&gt;")<br/>}<br/><br/>func main() {<br/>   // Tell the default server multiplexer to map the landing URL to<br/>   // a function called logRequest<br/>   http.HandleFunc("/", logRequest)<br/><br/>   // Kick off the listener using that will run forever<br/>   err := http.ListenAndServe(":8080", nil)<br/>   if err != nil {<br/>      log.Fatal("Error starting listener. ", err)<br/>   }<br/>} </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">HTTP form field honeypots</h1>
                
            
            
                
<p>In the previous example, we talked about creating a fake login form to detect someone attempting to log in. What if we want to identify whether it is a bot or not? The ability to detect a bot trying to log in can also be useful on a production site to block bots. One method of identifying automated bots is to use honeypot form fields. Honeypot form fields are input fields on an HTML form, which are hidden from the user and expected to be blank when the form is submitted by a human. A bot will still find the honeypot fields in the form and try to fill them out.</p>
<p>The goal is to trick bots into thinking that the form fields are real while keeping it hidden from users. Some bots will use regular expressions to look for keywords such asÂ <kbd>user</kbd> or <kbd>email</kbd> and fill out only those fields; so honeypot fields often use names such asÂ <kbd>email_address</kbd>Â or <kbd>user_name</kbd>Â to appear like a normal field. If the server receives data in those fields, it can assume that the form was submitted by a bot.</p>
<p>If we took the login form in the previous example and added a hidden form field named <kbd>email</kbd>, a bot might try to fill it out while a human would not see it. Form fields could be hidden using CSS or the <kbd>hidden</kbd> attribute on the <kbd>input</kbd> element. I recommend that you use CSS located in a separate style sheet to hide honeypot form fields, because a bot can easily determine if the form field had the <kbd>hidden</kbd> attribute, but would have a harder time detecting if the input was hidden using a style sheet.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Sandboxing</h1>
                
            
            
                
<p>One related technique that is not demonstrated in this chapter, but is worth mentioning, is sandboxing. Sandboxing serves a different purpose from a honeypot, but they both make an effort to create an environment that looks legitimate, but is actually tightly controlled and monitored. An example of sandboxing is the creation of a virtual machine with no network connectivity, which logs all file changes and attempted network connections to see if anything suspicious happens.</p>
<p>Sometimes, a sandbox environment can be detected by looking at the number of CPUs and the RAM. If the malicious application detects a system with a small amount of resources, say 1 CPU and 1 GB RAM, then it is likely not to be a modern desktop machine and may be a sandbox. Malicious software writers have learned to fingerprint sandbox environments and program the application to bypass any malicious actions if it suspects that it is being run within a sandbox.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>After reading this chapter, you should now understand the general concept of social engineering and be able to provide a few examples. You should understand how to interact with the REST APIs using JSON, generate QR codes and base64 encode data, and send emails using SMTP. You should also be able to explain the concept of a honeypot and understand how to implement your own honeypot or extend these examples for your own needs.</p>
<p>What other types of honeypots can you think of? What are the common services that get brute forced or attacked frequently? How can you customize or expand upon the social engineering examples? Can you think of any other services that you can query for information gathering?</p>
<p>In the next chapter, we'll cover post exploitation topics, such as deploying a bind shell, reverse bind shell, or web shells; cross compiling; finding writable files; and modifying file timestamps, permission, and ownership.</p>


            

            
        
    </body></html>