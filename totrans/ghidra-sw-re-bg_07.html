<html><head></head><body><div><p>&#13;
			<h1 id="_idParaDest-69"><em class="italic"><a id="_idTextAnchor082"/>Chapter 5</em>: Reversing Malware Using Ghidra</h1>&#13;
			<p><a id="_idTextAnchor083"/>In this chapter, we will introduce reverse engineering malware using Ghidra. By using Ghidra, you will be able to analyze executable binary files containing malicious code.</p>&#13;
			<p>This chapter is a great opportunity to put into practice the knowledge acquired during <a href="B16207_01_Final_SK_ePub.xhtml#_idTextAnchor017"><em class="italic">Chapter 1</em></a>, <em class="italic">Getting Started with Ghidra</em>, and <a href="B16207_02_Final_SK_ePub.xhtml#_idTextAnchor031"><em class="italic">Chapter 2</em></a>, <em class="italic">Automating RE Tasks with Ghidra Scripts</em>, about Ghidra's features and capabilities. To put this knowledge into practice, we will analyze the Alina <strong class="bold">Point of Sale</strong> (<strong class="bold">PoS</strong>) malware. This malware basically scrapes the RAM memory of PoS systems to steal credit card and debit card information.</p>&#13;
			<p><a id="_idTextAnchor084"/><a id="_idTextAnchor085"/>Our approach will start by setting up a safe analysis environment, then we will look for malware indicators in the malware sample, and, finally, we will conclude by performing in-depth malware analysis using Ghidra.</p>&#13;
			<p>In this chapter, we're going to cover the following main topics: </p>&#13;
			<ul>&#13;
				<li>Setting up the environment</li>&#13;
				<li>Looking for malware indicators</li>&#13;
				<li>Dissecting interesting malware sample parts</li>&#13;
			</ul>&#13;
			<h1 id="_idParaDest-70"><a id="_idTextAnchor086"/>Technical requirements </h1>&#13;
			<p>The requirements for this chapter are as follows: </p>&#13;
			<ul>&#13;
				<li>VirtualBox, an x86 and AMD64/Intel64 virtualization software: <a href="https://www.virtualbox.org/wiki/Downloads">https://www.virtualbox.org/wiki/Downloads</a></li>&#13;
				<li>VirusTotal, an online malware analysis tool that aggregates many antivirus engines and online engines for scanning: <a href="https://www.virustotal.com/">https://www.virustotal.com/</a></li>&#13;
			</ul>&#13;
			<p>The GitHub repository containing all the necessary code for this chapter can be found at <a href="https://github.com/PacktPublishing/Ghidra-Software-Reverse-Engineering-for-Beginners/tree/master/Chapter05">https://github.com/PacktPublishing/Ghidra-Software-Reverse-Engineering-for-Beginners/tree/master/Chapter05</a>.</p>&#13;
			<p>Check out the following link to see the Code in Action video: <a href="https://bit.ly/3ou4OgP">https://bit.ly/3ou4OgP</a></p>&#13;
			<h1 id="_idParaDest-71"><a id="_idTextAnchor087"/>Setting up the environment</h1>&#13;
			<p>At the time <a id="_idIndexMarker155"/>of writing this book, the public version of Ghidra has no debugging support for binaries. This <a id="_idIndexMarker156"/>limits the scope of Ghidra to static analysis, meaning files are analyzed without being executed.</p>&#13;
			<p>But, of course, Ghidra static analysis can complement the dynamic analysis performed by any existing debugger of your choice (such as x64dbg, WinDbg, and OllyDbg). Both types of analysis can be performed in parallel.</p>&#13;
			<p>Setting up an environment for malware analysis is a broad topic, so we will cover the basics of using Ghidra for this purpose. Keep in mind that the golden rule when setting up a malware analysis environment is to isolate it from your computer and network. Even if you are performing static analysis, it is recommended to set up an isolated environment because you have no guarantee that the malware won't exploit some Ghidra vulnerability and get executed anyway.</p>&#13;
			<p class="callout-heading">The CVE-2019-17664 and CVE-2019-17665 Ghidra vulnerabilities</p>&#13;
			<p class="callout">I found two vulnerabilities on Ghidra that could lead to the unexpected execution of malware when it is named: <code>cmd.exe</code> or <code>jansi.dll</code>. At the time of writing this book, CVE-2019-17664 is not fixed yet: <a href="https://github.com/NationalSecurityAgency/ghidra/issues/107">https://github.com/NationalSecurityAgency/ghidra/issues/107</a>.</p>&#13;
			<p>In order to analyze malware, you can use a physical computer (restorable to a clean state via hard disk drive backups) or a virtual one. The first option is more realistic but slower when restoring the backup and more expensive.</p>&#13;
			<p>You also have to isolate your network. A good example to illustrate the risk is ransomware encrypting the shared folders during analysis.</p>&#13;
			<p>Let's use a VirtualBox virtualized environment, with read-only (for safety reasons) shared folders in order to transfer files from the host machine to the guest and no internet connection as it is not necessary for static analysis.</p>&#13;
			<p>Then, we follow these steps:</p>&#13;
			<ol>&#13;
				<li>Install VirtualBox by downloading it from the following link: <a href="https://www.virtualbox.org/wiki/Downloads">https://www.virtualbox.org/wiki/Downloads</a> </li>&#13;
				<li>Create a new VirtualBox virtual machine or download it from Microsoft: <a href="https://aka.ms/windev_VM_virtualbox">https://aka.ms/windev_VM_virtualbox</a></li>&#13;
				<li>Set up a VirtualBox read-only shared folder, allowing you to transfer files from the host machine to the guest: https://www.virtualbox.org/manual/ch04.html#sharedfolders.</li>&#13;
				<li>Transfer Ghidra and its required dependencies to the guest machine, install it, and also transfer <a id="_idIndexMarker157"/>the malware <a id="_idIndexMarker158"/>you are interested in analyzing.</li>&#13;
			</ol>&#13;
			<p>Additionally, you can transfer your own arsenal of Ghidra scripts and extensions.</p>&#13;
			<h1 id="_idParaDest-72"><a id="_idTextAnchor088"/>Looking for malware indicators</h1>&#13;
			<p>As you probably remember from <a id="_idIndexMarker159"/>previous chapters, Ghidra works with projects containing zero or more files. Alina malware consists of two components: a Windows driver (<code>rt.sys</code>) and a Portable Executable (<code>park.exe</code>). Therefore, a compressed Ghidra project (<code>alina_ghidra_project.zip</code>) containing both components can be found in the relevant GitHub project created for this book.</p>&#13;
			<p>If you want to get the Alina malware sample as is instead of a Ghidra project, you can also find it in the GitHub project (<code>alina_malware_sample.zip</code>), compressed and protected with the password <code>infected</code>. It is quite common to share malware in this way so that it does not accidentally get infected.</p>&#13;
			<p>Next, we will try to quickly guess what kind of malware we are dealing with in general terms. To do that, we will look for strings, which can be revealing in many cases. We will also check external sources, which can be useful if the malware has been analyzed or classified. Finally, we will analyze its capabilities by looking for <strong class="bold">Dynamic Linking Library</strong> (<strong class="bold">DLL</strong>) functions.</p>&#13;
			<h2 id="_idParaDest-73"><a id="_idTextAnchor089"/>Looking for strings</h2>&#13;
			<p>Let's start by opening the Ghidra project and double-clicking on the <code>park.exe</code> file from the Ghidra project in <a id="_idIndexMarker160"/>order to analyze it using <code>park.exe</code> outside of the Ghidra project as it is malware and your system can get infected. A good starting point is to list the strings of the file. We'll go to <strong class="bold">Search</strong> | <strong class="bold">For Strings…</strong> and start to analyze it:</p>&#13;
			<div>&#13;
				<div>&#13;
					<img src="img/B16207_05_001.jpg" alt="Figure 5.1 – Some interesting strings found in park.exe&#13;&#10;"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption"> </p>&#13;
			<p class="figure-caption">Figure 5.1 – Some interesting strings found in park.exe</p>&#13;
			<p>As shown in the preceding screenshot, the user <code>Benson</code> seems to have compiled this malware. This information could be useful to investigate the attribution of this malware. There are a lot of suspicious strings here.</p>&#13;
			<p>For instance, it is hard to imagine the reason behind a legitimate program making reference to <code>windefender.exe</code>. Also, <code>SHELLCODE_MUTEX</code> and <strong class="bold">System Service Dispatch Table</strong> (<strong class="bold">SSDT</strong>) hooking references are both explicitly malicious. </p>&#13;
			<p class="callout-heading">System Service Dispatch Table</p>&#13;
			<p class="callout">SSDT is an array of addresses to kernel routines for 32-bit Windows operating systems or an array of relative offsets to the same routines for 64-bit Windows operating systems.</p>&#13;
			<p>A quick overview of the strings of the program can sometimes reveal whether it is malware or not without further analysis. Simple and powerful.</p>&#13;
			<h2 id="_idParaDest-74"><a id="_idTextAnchor090"/>Intelligence information and external sources</h2>&#13;
			<p>It is also useful to investigate <a id="_idIndexMarker161"/>the information found using external sources such as intelligence tools. For instance, as shown in the following screenshot, we identified two domains when looking for strings, which can be investigated using VirusTotal:</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B16207_05_002.jpg" alt="Figure 5.2 – Two domains found in strings&#13;&#10;"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption"> </p>&#13;
			<p class="figure-caption">Figure 5.2 – Two domains found in strings</p>&#13;
			<p>To analyze a URL in VirusTotal, go to the following link, write the domain, and click on the magnifying glass icon to proceed: <a href="https://www.virustotal.com/gui/home/url">https://www.virustotal.com/gui/home/url</a>:</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B16207_05_003.jpg" alt="Figure 5.3 – Searching for the URL to be analyzed&#13;&#10;"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption">Figure 5.3 – Searching for the URL to be analyzed</p>&#13;
			<p>Search results are dynamic and might change from time to time. In this case, both domains produce positive results in VirusTotal. The results can be viewed at <a href="https://www.virustotal.com/gui/url/422f1425108ae35666d2f86f46f9cf565141cf6601c6924534cb7d9a536645bc/detection">https://www.virustotal.com/gui/url/422f1425108ae35666d2 f86f46f9cf565141cf6601c6924534cb7d9a536645bc/detection:</a></p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B16207_05_004.jpg" alt="Figure 5.4 – Two domains found in strings&#13;&#10;"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption">Figure 5.4 – Two domains found in strings</p>&#13;
			<p>Apart from that, VirusTotal can provide more <a id="_idIndexMarker162"/>useful information that you can find by browsing through the page. For instance, it<a id="_idTextAnchor091"/> detected that the <code>javaoracle2.ru</code> domain was also referenced by other suspicious files:</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B16207_05_005.jpg" alt="Figure 5.5 – Malware threats referencing javaoracle2.ru &#13;&#10;"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption">Figure 5.5 – Malware threats referencing javaoracle2.ru </p>&#13;
			<p>When analyzing malware, it is recommended to review public resources before starting the analysis because it can bring you a lot of useful information for the starting point.</p>&#13;
			<p class="callout-heading">How to look for malware indicators</p>&#13;
			<p class="callout">When looking for malware indicators, don't just try to look for strings used for malicious purposes, but also look for anomalies. Malware is usually easily recognized for multiple reasons: some strings will never be found in goodware files and the code could be artificially complex.</p>&#13;
			<p>It is also interesting to check the imports of the file in order to investigate its capabilities.</p>&#13;
			<h2 id="_idParaDest-75"><a id="_idTextAnchor092"/>Checking import functions</h2>&#13;
			<p>As the binary references <a id="_idIndexMarker163"/>some malicious servers, it must implement some kind of network communication. In this case, this communication is performed via an HTTP protocol, as shown in the following import functions located in Ghidra's CodeBrowser <strong class="bold">Symbol Tree</strong> window:</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B16207_05_006.jpg" alt="Figure 5.6 – HTTP communication-related imports&#13;&#10;"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption"> </p>&#13;
			<p class="figure-caption">Figure 5.6 – HTTP communication-related imports</p>&#13;
			<p>Looking at <code>ADVAPI32.DLL</code>, we can identify functions named <strong class="bold">Reg*</strong> that allow us to work with the Windows Registry, while others that mention the word <strong class="bold">Service</strong> or <strong class="bold">SCManager</strong> allow us to interact with the Windows Service Control Manager, which enables us to load drivers:</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B16207_05_007.jpg" alt="Figure 5.7 – Windows Registry- and Service Control Manager-related imports&#13;&#10;"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption"> </p>&#13;
			<p class="figure-caption">Figure 5.7 – Windows Registry- and Service Control Manager-related imports</p>&#13;
			<p>There are <a id="_idIndexMarker164"/>really a lot of imports from <code>KERNEL32.DLL</code>, so, as well as many other things, it allows us to interact with and perform actions related to named pipes, files, and processes:</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B16207_05_008.jpg" alt="Figure 5.8 – HTTP communication&#13;&#10;"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption"> </p>&#13;
			<p class="figure-caption">Figure 5.8 – HTTP communication</p>&#13;
			<p class="callout-heading">Runtime imports</p>&#13;
			<p class="callout">Remember that libraries imported at runtime and/or functions resolved at runtime will not be listed in <strong class="bold">Symbol Tree</strong>, so be aware that the capabilities of the program may not have been fully identified.</p>&#13;
			<p>We have identified a lot of things with a very quick analysis. If you are experienced, you will know <a id="_idIndexMarker165"/>malware code patterns, leading to mentally matching API functions with strings and easily inferring what the malware will try to do when given the previously shown information.</p>&#13;
			<h1 id="_idParaDest-76"><a id="_idTextAnchor093"/>Dissecting interesting malware sample parts </h1>&#13;
			<p>As mentioned before, this <a id="_idIndexMarker166"/>malware consists of two components: a Portable Executable file (<code>park.exe</code>) and a Windows driver file (<code>rk.sys</code>).</p>&#13;
			<p>When more than one malicious file is found on a computer, it is quite common that one of them generates the other(s). As <code>park.exe</code> can be executed by double-clicking on it, while <code>rk.sys</code> must be loaded by another component such as the Windows Service Control Manager or another driver, we can initially assume that <code>park.exe</code> was executed and then it dropped <code>rk.sys</code> to the disk. In fact, during our static analysis of the imports, we notice that <code>park.exe</code> has APIs to deal with the Windows Service Control Manager. As shown in the following screenshot, this file starts with the following pattern: <code>4d 5a 90 00</code>. The starting bytes are also used as the signature of files; these signatures are <a id="_idIndexMarker167"/>also known as magic numbers <a id="_idIndexMarker168"/>or magic bytes. In this case, the signature indicates that this file is a Portable Executable (the file format for executables, object code, DLLs, and others used in 32-bit and 64-bit versions of Windows operating systems):</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B16207_05_009.jpg" alt="Figure 5.9 – rk.sys file overview&#13;&#10;"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption"> </p>&#13;
			<p class="figure-caption">Figure 5.9 – rk.sys file overview</p>&#13;
			<p>By calculating the difference between the start address and the end address, we obtained the size of the <a id="_idIndexMarker169"/>file, which is <code>0x51ff</code>, which will be used later for extracting the <code>rk.sys</code> file embedded in <code>park.exe</code>. It is a great idea to use the Python interpreter for this simple calculation:</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B16207_05_010.jpg" alt="Figure 5.10 – rk.sys file size&#13;&#10;"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption"> </p>&#13;
			<p class="figure-caption">Figure 5.10 – rk.sys file size</p>&#13;
			<p>Then, we open <code>park.exe</code> and look for the file by clicking on <code>4D 5A 90 00</code> pattern. Click on <strong class="bold">Search All</strong> to see all occurrences:</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B16207_05_011.jpg" alt="Figure 5.11 – Looking for PE headers&#13;&#10;"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption"> </p>&#13;
			<p class="figure-caption">Figure 5.11 – Looking for PE headers</p>&#13;
			<p>You will see two occurrences of this header pattern. The first one corresponds to the header of <a id="_idIndexMarker170"/>the file we are analyzing, which is <code>park.exe</code>, while the second one corresponds to the embedded <code>rk.sys</code>:</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B16207_05_012.jpg" alt="Figure 5.12 – PE headers found in park.exe&#13;&#10;"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption"> </p>&#13;
			<p class="figure-caption">Figure 5.12 – PE headers found in park.exe</p>&#13;
			<p>As we know now that it starts at the <code>0x004f6850</code> address and, as calculated before using the Python interpreter, is <code>0x51FF</code> bytes in size, we can select those bytes by clicking on <strong class="bold">Select</strong> | <strong class="bold">Bytes...</strong>, entering the length in bytes to select, starting from the current address and, finally, clicking on <strong class="bold">Select Bytes</strong>:</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B16207_05_013.jpg" alt="Figure 5.13 – Selecting the rk.sys file inside park.exe&#13;&#10;"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption"> </p>&#13;
			<p class="figure-caption">Figure 5.13 – Selecting the rk.sys file inside park.exe</p>&#13;
			<p>By right-clicking <a id="_idIndexMarker171"/>on the selected bytes and choosing <strong class="bold">Extract and Import…</strong>, which is also available with the <em class="italic">Ctrl</em> + <em class="italic">Alt</em> + <em class="italic">I</em> hotkey, we get the following screen, where a data file is added to the project containing the selected bytes:</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B16207_05_014.jpg" alt="Figure 5.14 – The data chunk is added to the project as a *.tmp file&#13;&#10;"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption"> </p>&#13;
			<p class="figure-caption">Figure 5.14 – The data chunk is added to the project as a *.tmp file</p>&#13;
			<p>We identified all the malware components. Now, let's analyze the malware from the entry point of the program.</p>&#13;
			<h2 id="_idParaDest-77"><a id="_idTextAnchor094"/>The entry point function</h2>&#13;
			<p>Let's analyze <code>park.exe</code>. We <a id="_idIndexMarker172"/>start by opening it <a id="_idIndexMarker173"/>with <code>entry</code> function in <strong class="bold">Symbol Tree</strong> to do that:</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B16207_05_015.jpg" alt="Figure 5.15 – Entry point function&#13;&#10;"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption"> </p>&#13;
			<p class="figure-caption">Figure 5.15 – Entry point function</p>&#13;
			<p>The decompilation of this function looks readable. <code>__security__init_cookie</code> is a memory corruption protection function introduced by the compiler, so go ahead with <code>__tmainCRTStartup</code> by double-clicking on it. There are a lot of functions recognized by Ghidra here, so let's focus on the only function not recognized yet – <code>thunk_FUN_00455f60</code>:</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B16207_05_016.jpg" alt="Figure 5.16 – The WinMain function unrecognized&#13;&#10;"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption"> </p>&#13;
			<p class="figure-caption">Figure 5.16 – The WinMain function unrecognized</p>&#13;
			<p>This is the main <a id="_idIndexMarker174"/>function of the program. If you have some C++ background, you will also notice that <code>__wincmdln</code> initializes <a id="_idIndexMarker175"/>some global variables, the environment, and the heap for the process, and then the <code>WinMain</code> function is called. So, the <code>thunk_FUN_00455f60</code> function, following <code>__wincmdln</code>, is the <code>WinMain</code> function. Let's rename <code>thunk_FUN_00455f60</code> to <code>WinMain</code> by pressing the <em class="italic">L</em> key while focusing on <code>thunk_FUN_00455f60</code>:</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B16207_05_017.jpg" alt="Figure 5.17 – Renaming the thunk_FUN_00455f60 function to WinMain&#13;&#10;"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption">Figure 5.17 – Renaming the thunk_FUN_00455f60 function to WinMain</p>&#13;
			<p>Ghidra allows you to rename variables and functions, introduce comments, and modify the disassembly and decompiled code in a lot of aspects. This is essential when reverse engineering malware:</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B16207_05_018.jpg" alt="Figure 5.18 – The WinMain function with some irrelevant code (lines 5–19) omitted&#13;&#10;"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption"> </p>&#13;
			<p class="figure-caption">Figure 5.18 – The WinMain function with some irrelevant code (lines 5–19) omitted</p>&#13;
			<p>We took those steps to identify where the malware starts to analyze its flow from the beginning, but there are <a id="_idIndexMarker176"/>some functions in <a id="_idIndexMarker177"/>the decompiled code listing that we don't know anything about. So, our job here is to reveal their functionality in order to understand the malware.</p>&#13;
			<p>Keep in mind that malware analysis is a time-consuming task, so don't waste your time with the details, but also don't forget anything important. Next, we will analyze each of the functions listed in the <code>WinMain</code> decompiled code. We will start analyzing the first function, which is located on line <code>20</code> and is named <code>thunk_FUN_00453340</code>.</p>&#13;
			<h2 id="_idParaDest-78"><a id="_idTextAnchor095"/>Analyzing the 0x00453340 function</h2>&#13;
			<p>We will <a id="_idIndexMarker178"/>start by analyzing <a id="_idIndexMarker179"/>the first function, <code>thunk_FUN_00453340</code>:</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B16207_05_019.jpg" alt="Figure 5.19 – Partial code of the FUN_00453340 function&#13;&#10;"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption"> </p>&#13;
			<p class="figure-caption">Figure 5.19 – Partial code of the FUN_00453340 function</p>&#13;
			<p>It is creating a class using <code>operator_new</code> and then calling its constructor: <code>thunk_FUN_0044d440</code>.</p>&#13;
			<p>In this function, you will see some Windows API calls. Then, you can rename (by pressing the <em class="italic">L</em> key) the local variables, making the code more readable:</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B16207_05_020.jpg" alt="Figure 5.20 – Renaming a function parameter computerName&#13;&#10;"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption"> </p>&#13;
			<p class="figure-caption">Figure 5.20 – Renaming a function parameter computerName</p>&#13;
			<p>You can do this according to the Microsoft documentation (<a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getcomputernamea">https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getcomputernamea</a>):</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B16207_05_021.jpg" alt="Figure 5.21 – Looking for API information in the Microsoft docs&#13;&#10;"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption"> </p>&#13;
			<p class="figure-caption">Figure 5.21 – Looking for API information in the Microsoft docs</p>&#13;
			<p>In fact, it is also possible to fully modify a function by clicking on <strong class="bold">Edit Function Signature</strong>:</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B16207_05_022.jpg" alt="Figure 5.22 – Editing a function signature&#13;&#10;"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption"> </p>&#13;
			<p class="figure-caption">Figure 5.22 – Editing a function signature</p>&#13;
			<p>In this case, this function is <code>strcpy</code>, which copies the <code>errorretriving</code> string to the end of the <code>computerName</code> string (which has a <code>NULL</code> value <a id="_idIndexMarker180"/>when this line is reached). Then, we <a id="_idIndexMarker181"/>can modify the signature according to its name and parameters.</p>&#13;
			<p>We can also modify the calling convention for the function. This is important because some important details depend on the calling convention: </p>&#13;
			<ul>&#13;
				<li>How parameters are passed to the function (by register or pushed onto the stack)</li>&#13;
				<li>Designates the callee function or the calling function with the responsibility of cleaning the stack</li>&#13;
			</ul>&#13;
			<p>Refer to the following screenshot to see how <code>thunk_FUN_004721f0</code> is renamed to <code>strcpy</code>:</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B16207_05_023.jpg" alt="Figure 5.23 – Function signature editor&#13;&#10;"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption"> </p>&#13;
			<p class="figure-caption">Figure 5.23 – Function signature editor</p>&#13;
			<p>We can <a id="_idIndexMarker182"/>also set the <a id="_idIndexMarker183"/>following pre-comment on line <code>105</code> – <code>0x1a = CSIDL_APPDATA</code>:</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B16207_05_024.jpg" alt="Figure 5.24 – Setting a pre-comment&#13;&#10;"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption"> </p>&#13;
			<p class="figure-caption">Figure 5.24 – Setting a pre-comment</p>&#13;
			<p>This indicates that the second parameter of <code>SHGetFolderPathA</code> means the <code>%APPDATA%</code> directory:</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B16207_05_025.jpg" alt="Figure 5.25 – Pre-comment in the decompiled code&#13;&#10;"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption"> Figure 5.25 – Pre-comment in the decompiled code</p>&#13;
			<p>After some analysis, you will notice that this function makes an RC4-encrypted copy of the malware as <code>windefender.exe</code> in <code>%APPDATA%\ntkrnl\</code>.</p>&#13;
			<h2 id="_idParaDest-79"><a id="_idTextAnchor096"/>Analyzing the 0x00453C10 function</h2>&#13;
			<p>Sometimes, the <a id="_idIndexMarker184"/>decompiled code is not correct and is incomplete; so, also check the disassembly listing. In <a id="_idIndexMarker185"/>this case, we are dealing with a list of strings representing files to delete but in the decompiled code, it is not shown:</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B16207_05_026.jpg" alt="Figure 5.26 – Showing a list of strings&#13;&#10;"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption">Figure 5.26 – Showing a list of strings</p>&#13;
			<p>This function is cleaning previous infections by deleting these files. As you can see, the malware tries to be a little stealthy using names of legitimate programs. Let's rename this function <code>cleanPreviousInfections</code> and continue with other functions.</p>&#13;
			<h2 id="_idParaDest-80"><a id="_idTextAnchor097"/>Analyzing the 0x0046EA60 function</h2>&#13;
			<p>This function <a id="_idIndexMarker186"/>creates a named <code>\\\\.\\pipe\\spark</code> pipe, which is an <strong class="bold">Inter-Process Communication</strong> (<strong class="bold">IPC</strong>) mechanism:</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B16207_05_027.jpg" alt="Figure 5.27 – Creating a named pipe&#13;&#10;"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption"> </p>&#13;
			<p class="figure-caption">Figure 5.27 – Creating a named pipe</p>&#13;
			<p class="callout-heading">Inter-process communication</p>&#13;
			<p class="callout">IPC is a mechanism that allows processes to communicate with each other and synchronize their actions. The communication between these processes can be seen as a method of co-operation between them.</p>&#13;
			<p>Since a named pipe is created, we can expect to see some kind of communication between malware components using it.</p>&#13;
			<h2 id="_idParaDest-81"><a id="_idTextAnchor098"/>Analyzing the 0x0046BEB0 function</h2>&#13;
			<p>This function sets up the command and control URL:</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B16207_05_028.jpg" alt="Figure 5.28 – Command and control domains and endpoints&#13;&#10;"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption"> </p>&#13;
			<p class="figure-caption">Figure 5.28 – Command and control domains and endpoints</p>&#13;
			<h2 id="_idParaDest-82"><a id="_idTextAnchor099"/>Analyzing the 0x0046E3A0 function</h2>&#13;
			<h2 id="_idParaDest-83"><a id="_idTextAnchor100"/>By analyzing this function, we notice that the pipe is used for some kind of synchronization. The <code>CreateThread</code> API <a id="_idIndexMarker187"/>function receives as <a id="_idIndexMarker188"/>parameters the function to execute as a thread and an argument to pass to the function; so, when a thread creation appears, we have to analyze a new function – in this case, <code>lpStartAddress_00449049</code>:</h2>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B16207_05_029.jpg" alt="Figure 5.29 – Persisting the malware every 30 seconds&#13;&#10;"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption"> </p>&#13;
			<p class="figure-caption">Figure 5.29 – Persisting the malware every 30 seconds</p>&#13;
			<p>Interesting. An infinite loop iterates every <code>30000</code> milliseconds (30 seconds), performing persistence. Let's analyze the <code>thunk_FUN_00454ba0</code> function:</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B16207_05_030.jpg" alt="Figure 5.30 – Persistence via the Run registry key&#13;&#10;"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption"> </p>&#13;
			<p class="figure-caption">Figure 5.30 – Persistence via the Run registry key</p>&#13;
			<p>It is opening the <code>Run</code> registry key, which is executed when the Microsoft Windows user session starts. This is commonly used by malware to persist the infection because it will be executed every time the computer starts. Let's rename the function <code>persistence</code>.</p>&#13;
			<h2 id="_idParaDest-84"><a id="_idTextAnchor101"/>Analyzing the 0x004559B0 function</h2>&#13;
			<p>This function deals with services via Service Control Manager APIs such as <code>OpenSCManagerA</code> or <code>OpenServiceA</code>:</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B16207_05_031.jpg" alt="Figure 5.31 – Using the Service Control Manager to open a service&#13;&#10;"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption"> </p>&#13;
			<p class="figure-caption">Figure 5.31 – Using the Service Control Manager to open a service</p>&#13;
			<p>After some <a id="_idIndexMarker189"/>renaming, we notice that it checks whether <a id="_idIndexMarker190"/>users have the administrative privileges that are necessary to create services. If they do, it deletes previous rootkit instances (a rootkit is an application that allows us to hide system elements: processes, files, and so on… but in this case, malware elements), writes the rootkit to disk, and finally, creates a service with the rootkit again. As you can see, the service is called <code>Windows Host Process</code> and the rootkit is installed in <code>%APPDATA%</code> (or <code>C:\</code> if not available) and named <code>rk.sys</code>:</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B16207_05_032.jpg" alt="Figure 5.32 – Installing the rootkit but deleting the previous one if it exists&#13;&#10;"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption"> </p>&#13;
			<p class="figure-caption">Figure 5.32 – Installing the rootkit but deleting the previous one if it exists</p>&#13;
			<p>So, let's rename this function <code>installRookit</code>.</p>&#13;
			<h2 id="_idParaDest-85"><a id="_idTextAnchor102"/>Analyzing the 0x004554E0 function</h2>&#13;
			<p>It is trying <a id="_idIndexMarker191"/>to open the <code>explorer.exe</code> process, which is <a id="_idIndexMarker192"/>supposed to be the shell of the user:</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B16207_05_033.jpg" alt="Figure 5.33 – Opening explorer.exe&#13;&#10;"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption"> </p>&#13;
			<p class="figure-caption">Figure 5.33 – Opening explorer.exe</p>&#13;
			<p>As you can see, it creates a mutex, which is a synchronization mechanism, and prevents opening the <code>explorer.exe</code> process twice. The mutex name is very characteristic and is <a id="_idIndexMarker193"/>hardcoded. We can use it as an <code>7YhngylKo09H</code>.</p>&#13;
			<p>When analyzing malware, there are code patterns and API sequences that are like an open book:</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B16207_05_034.jpg" alt="Figure 5.34 – Injecting code into the explorer.exe process&#13;&#10;"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption"> </p>&#13;
			<p class="figure-caption">Figure 5.34 – Injecting code into the explorer.exe process</p>&#13;
			<p>In this case, you can see the following:</p>&#13;
			<ul>&#13;
				<li><code>VirtualAllocEx</code>: To allocate <code>0x3000</code> bytes of memory to the <code>explorer.exe</code> process with the <code>0x40</code> flag meaning <code>PAGE_EXECUTE_READWRITE</code> (allowing you to write and execute code here)</li>&#13;
				<li><code>WriteProcessMemory</code>: Writes the <a id="_idIndexMarker194"/>malicious code <a id="_idIndexMarker195"/>into <code>explorer.exe</code></li>&#13;
				<li><code>CreateRemoteThread</code>: Creates a new thread in the <code>explorer.exe</code> process in order to execute the code.</li>&#13;
			</ul>&#13;
			<p>We can rename <code>thunk_FUN_004555b0</code> to <code>injectShellcodeIntoExplorer</code>. </p>&#13;
			<p>We now understand its parameters:</p>&#13;
			<ul>&#13;
				<li>The explorer process handler in order to inject code into it</li>&#13;
				<li>The pointer to the <a id="_idIndexMarker196"/>code to inject (also known as shellcode)</li>&#13;
				<li>The size of the code to inject, which is <code>0x616</code> bytes<p class="callout-heading">Shellcode</p><p class="callout">The term "shellcode" was historically used to describe code executed by a target program due to a vulnerability exploit and used to open a remote shell – that is, an instance of a command-line interpreter – so that an attacker could use that shell to further interact with the victim's system.</p></li>&#13;
			</ul>&#13;
			<p>By double-clicking on the <strong class="bold">shellcode</strong> parameter, we can see the bytes of the shellcode, but by pressing the <em class="italic">D</em> key, we can also convert it into code:</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B16207_05_035.jpg" alt="Figure 5.35 – Converting the shellcode into code in order to analyze it with Ghidra&#13;&#10;"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption"> </p>&#13;
			<p class="figure-caption">Figure 5.35 – Converting the shellcode into code in order to analyze it with Ghidra</p>&#13;
			<p>By clicking on <a id="_idIndexMarker197"/>some string of <code>shellcode</code>, you can see the <a id="_idIndexMarker198"/>strings used stored in the same order as used by the program, so you can deduce what the program is doing by reading its strings:</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B16207_05_036.jpg" alt="Figure 5.36 – Quickly analyzing code by reading its strings&#13;&#10;"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption"> </p>&#13;
			<p class="figure-caption">Figure 5.36 – Quickly analyzing code by reading its strings</p>&#13;
			<p>We have an encrypted copy of the malware in <code>%APPDATA%\ntkrnl</code> as we know from a previous analysis. It is decrypted using the password <code>7YhngylKo09H</code>. Then, a <code>windefender.exe</code>-decrypted malware is created and finally executed via <code>ShellExecuteA</code>. This is performed in an infinite loop controlled by a mutex mechanism, as indicated in the final string, <code>SHELLCODE_MUTEX</code>.</p>&#13;
			<p class="callout-heading">Mutex</p>&#13;
			<p class="callout">A mutex object is a synchronization object whose state can be non-signaled or signaled, depending, respectively, on whether it is owned by a thread or not.</p>&#13;
			<p>So, we can rename <code>thunk_FUN_004554e0</code> to <code>explorerPersistence</code>.</p>&#13;
			<h2 id="_idParaDest-86"><a id="_idTextAnchor103"/>Analyzing the 0x0046C860 function</h2>&#13;
			<p>After <a id="_idIndexMarker199"/>initializing the class using <code>operator_new</code>, calls are <a id="_idIndexMarker200"/>made to its <code>thunk_FUN_0046c2c0</code> constructor. As you can see, we have a thread to analyze here:</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B16207_05_037.jpg" alt="Figure 5.37 – Thread creation&#13;&#10;"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption"> </p>&#13;
			<p class="figure-caption">Figure 5.37 – Thread creation</p>&#13;
			<p>The <code>lpStartAddress_00447172</code> function consists of an infinite loop, which calls to our analyzed <code>setupC&amp;C</code> function, so we <a id="_idIndexMarker201"/>can expect some <strong class="bold">Command and Control</strong> (<strong class="bold">C&amp;C</strong>) communication. C&amp;C is the server controlling and receiving information from the malware sample. It is administered by the attacker:</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B16207_05_038.jpg" alt="Figure 5.38 – C&amp;C communication loop&#13;&#10;"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption"> </p>&#13;
			<p class="figure-caption">Figure 5.38 – C&amp;C communication loop</p>&#13;
			<p>Let's click on one of the function strings and see what happens. We can also make it a beautifier. Click on the <strong class="bold">Create Array…</strong> option to join null bytes by selecting these bytes and right-clicking on it:</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B16207_05_039.jpg" alt="Figure 5.39 – Converting data into types and structures&#13;&#10;"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption"> </p>&#13;
			<p class="figure-caption">Figure 5.39 – Converting data into types and structures</p>&#13;
			<p>It seems to be strings of HTTP parameters for C&amp;C communication as it is quite common to use this <a id="_idIndexMarker202"/>protocol. The most relevant <a id="_idIndexMarker203"/>string is <code>cardinterval</code>. What does card interval mean?</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B16207_05_040.jpg" alt="Figure 5.40 – C&amp;C communication HTTP parameters&#13;&#10;"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption"> </p>&#13;
			<p class="figure-caption">Figure 5.40 – C&amp;C communication HTTP parameters</p>&#13;
			<p>Let's rename this function <code>C&amp;Ccommunication</code> and move on with the next function.</p>&#13;
			<h2 id="_idParaDest-87"><a id="_idTextAnchor104"/>Analyzing the 0x0046A100 function</h2>&#13;
			<p>Again, we have a <code>thunk_FUN_00464870</code> constructor calling an <code>lpStartAddress_04476db</code> thread function. Let's focus our attention on the thread function:</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B16207_05_041.jpg" alt="Figure 5.41 – A mathematical function&#13;&#10;"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption"> </p>&#13;
			<p class="figure-caption">Figure 5.41 – A mathematical function</p>&#13;
			<p>This function is a little bit complex. We can see a lot of math operations, and due to this, a lot of numeric data types. Don't waste your time! Instead, rename it to <code>mathAlgorithm</code> and come back to it later if needed.</p>&#13;
			<p>The next function iterates over <a id="_idIndexMarker204"/>processes and uses the <code>__stricmp</code> function to skip processes of the <a id="_idIndexMarker205"/>blacklist, which contains Windows processes and common applications. We can assume it is looking for a non-common application:</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B16207_05_042.jpg" alt="Figure 5.42 – Blacklisted processes&#13;&#10;"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption"> </p>&#13;
			<p class="figure-caption">Figure 5.42 – Blacklisted processes</p>&#13;
			<p>By analyzing the <code>lpStartAddress0047299</code> thread function located in <code>FUN_0045c570</code>, we notice that it scraps the process memory looking for something:</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B16207_05_043.jpg" alt="Figure 5.43 – Reading the process memory&#13;&#10;"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption"> </p>&#13;
			<p class="figure-caption">Figure 5.43 – Reading the process memory</p>&#13;
			<p>It first <a id="_idIndexMarker206"/>obtains the memory region permissions <a id="_idIndexMarker207"/>via <code>VirtualQueryEx</code> and checks whether it is in the <code>MEM_IMAGE</code> state, which indicates that the memory pages within the region are mapped into the view of an image section. It also protects <code>PAGE_READWRITE</code>.</p>&#13;
			<p>Then, it calls to <code>ReadProcessMemory</code> to read the memory, and finally, it looks for credit card numbers in <code>FUN_004607c0</code>:</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B16207_05_044.jpg" alt="Figure 5.44 – Memory-scrapping the process&#13;&#10;"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption"> </p>&#13;
			<p class="figure-caption">Figure 5.44 – Memory-scrapping the process</p>&#13;
			<p>As you can see, the <code>local_28</code> variable is <code>0x10</code> bytes (<code>0x10</code> means the 16 digits of a credit <a id="_idIndexMarker208"/>card number) in size and the first byte of it is being <a id="_idIndexMarker209"/>compared with the number <code>3</code>, as shown in the table I printed using the Python interpreter. This malware implements the Luhn algorithm for credit card number checksum validation during its scraping:</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B16207_05_045.jpg" alt="Figure 5.45 – Renamed functions in WinMain&#13;&#10;"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption"> </p>&#13;
			<p class="figure-caption">Figure 5.45 – Renamed functions in WinMain</p>&#13;
			<p>Luhn makes it possible to check numbers (credit card numbers, in this case) via a control key (called checksum, which <a id="_idIndexMarker210"/>is a number of the number, which makes it possible to check the others). If a character is misread or badly written, then Luhn's algorithm will detect this error.</p>&#13;
			<p>Luhn is well-known <a id="_idIndexMarker211"/>because Mastercard, <strong class="bold">American Express</strong> (<strong class="bold">AmEx</strong>), Visa, and all other credit cards use it.</p>&#13;
			<h1 id="_idParaDest-88"><a id="_idTextAnchor105"/>Summary</h1>&#13;
			<p>In this chapter, you learned how to analyze malware using Ghidra. We analyzed Alina POS malware, which is rich in features, namely pipes, threads, the <code>ring0</code> rootkit, shellcode injection, and memory-scrapping.</p>&#13;
			<p>You have also learned how bad guys earn money every day with cybercriminal activities. In other words, you learned about carding skills.</p>&#13;
			<p>In the next chapter of this book, we will cover scripting malware analysis to work faster and better when improving our analysis of Alina POS malware.</p>&#13;
			<h1 id="_idParaDest-89"><a id="_idTextAnchor106"/>Questions </h1>&#13;
			<ol>&#13;
				<li value="1">What kind of information provides the imports of a Portable Executable file during malware analysis? What can be done by combining both the <code>LoadLibrary</code> and <code>GetProcAddress</code> API functions?</li>&#13;
				<li>Can the disassembly be improved in some way when dealing with a C++ program, as in this case?</li>&#13;
				<li>What are the benefits of malware when injecting code into another process compared to executing it in the current process?</li>&#13;
			</ol>&#13;
			<h1 id="_idParaDest-90"><a id="_idTextAnchor107"/>Further reading </h1>&#13;
			<p>You can refer to the following links for more information on the topics covered in this chapter:</p>&#13;
			<ul>&#13;
				<li>During the analysis performed in this chapter, we didn't need to use all of Ghidra's features. Check out the following Ghidra cheat sheet for further details: <a href="https://ghidra-sre.org/CheatSheet.html">https://ghidra-sre.org/CheatSheet.html</a></li>&#13;
				<li><em class="italic">Learning Malware Analysis</em>, <em class="italic">Monnappa K A</em>, <em class="italic">June 2018:</em> <a href="https://www.packtpub.com/eu/networking-and-servers/learning-malware-analysis">https://www.packtpub.com/eu/networking-and-servers/learning-malware-analysis</a></li>&#13;
				<li>Alina, the latest POS malware – PandaLabs analysis: <a href="https://www.pandasecurity.com/en/mediacenter/pandalabs/alina-pos-malware/">https://www.pandasecurity.com/en/mediacenter/pandalabs/alina-pos-malware/</a></li>&#13;
				<li><em class="italic">Fundamentals of Malware Analysis</em>, <em class="italic">Munir Njenga</em>, <em class="italic">March 2018</em> [Video]: <a href="https://www.packtpub.com/networking-and-servers/fundamentals-malware-analysis-video">https://www.packtpub.com/networking-and-servers/fundamentals-malware-analysis-video</a></li>&#13;
				<li>Hybrid analysis – analyze and detect known threats: <a href="https://www.hybrid-analysis.com/?lang=es">https://www.hybrid-analysis.com/?lang=es</a> </li>&#13;
			</ul>&#13;
		</div>&#13;
	</div></body></html>