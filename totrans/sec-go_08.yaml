- en: Brute Force
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Brute force attacks, also called exhaustive key attacks, are when you try every
    possible combination for an input until you eventually get the right combination.
    The most common example is brute forcing passwords. You can try every combination
    of characters, letters, and symbols, or you could use a dictionary list as a base
    for passwords. You can find dictionaries and prebuilt word lists based on common
    passwords online or you can create your own.
  prefs: []
  type: TYPE_NORMAL
- en: There are different types of brute force password attacks. There are online
    attacks such as trying to log in to a website or database repeatedly. Online attacks
    are much slower due to network latency and bandwidth limitations. Services may
    also rate limit or lockout accounts after too many failed attempts. On the other
    hand, there are also offline attacks. An example of an offline attack is when
    you have a database dump full of hashed passwords on your local hard disk and
    you can brute force it with no limitation, except the physical hardware. Serious
    password crackers build computers with several powerful graphics cards tuned for
    cracking, which cost tens of thousands of dollars.
  prefs: []
  type: TYPE_NORMAL
- en: One thing to note about online brute force attacks is that they are very easy
    to detect, cause a lot of traffic, can put a heavy load on servers and even bring
    them down completely, and are illegal unless you have permission. Permission can
    be misleading when it comes to online services. For example, just because you
    have an account on a service such as Facebook does not mean you have permission
    to brute force attack your own account. Facebook still owns the servers and you
    do not have permission to attack their site even if it is only against your account.
    Even if you are running your own service such as an SSH service on an Amazon server,
    you still do not have the permission to do a brute force attack. You must request
    and get special permission for penetration testing to or from an Amazon resource.
    You can use your own virtual machines for testing locally.
  prefs: []
  type: TYPE_NORMAL
- en: 'The webcomic *xkcd* has a comic that perfectly relates to the topic of brute
    forcing passwords:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/17987bbd-217b-435f-b4eb-bb536d16c4de.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Source: https://xkcd.com/936/'
  prefs: []
  type: TYPE_NORMAL
- en: 'Most, if not all of these attacks, can be protected using one or more of the
    following techniques:'
  prefs: []
  type: TYPE_NORMAL
- en: Strong passwords (ideally passphrases or keys)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing rate limiting/temporary lockouts on failed attempts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a CAPTCHA
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding two-factor authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Salting passwords
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Limiting access to the server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This chapter will cover several brute force examples including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: HTTP basic authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTML login forms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SSH password authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Databases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Brute forcing HTTP basic authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'HTTP basic authentication is when you provide a username and password with
    your HTTP request. You can pass it as part of the URL in modern browsers. Consider
    this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'When adding basic authentication programmatically, the credentials are provided
    as an HTTP header named `Authorization`, which contains a value of `username:password`
    base64 encoded and prefixed with `Basic`, separated by a space. Consider the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Web servers typically respond with a `401 Access Denied` code when the authentication
    fails, and they should respond with a `2xx` success code such as `200 OK`.
  prefs: []
  type: TYPE_NORMAL
- en: This example will take a URL and a `username` value and attempt to log in using
    the passwords generated.
  prefs: []
  type: TYPE_NORMAL
- en: To reduce the effectiveness of attacks like these, implement a rate-limiting
    feature or account lockout feature after a number of failed log in attempts.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you need to build your own password list from scratch, try starting with
    the most common passwords documented in Wikipedia at [https://en.wikipedia.org/wiki/List_of_the_most_common_passwords](https://en.wikipedia.org/wiki/List_of_the_most_common_passwords).
    Here is a short example you can save as `passwords.txt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Save the list in the preceding code block as a text file with one password
    on each line. The name is not important since you provide the password list filename
    as a command-line argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Brute forcing the HTML login form
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just about every website with a user system provides a login form on a web page.
    We can write a program that will submit the login form repeatedly. This example
    assumes that there is no CAPTCHA, rate limit, or other deterring mechanisms on
    the web application. Remember not to perform this attack against any production
    site or any site you do not own or have permission. If you want to test it, I
    recommend that you set up a local web server and test only locally.
  prefs: []
  type: TYPE_NORMAL
- en: Every web form can be created with different names for the `username` and `password`
    fields, so the names of those fields will need to be provided on each run and
    must be specific to the URL being targeted.
  prefs: []
  type: TYPE_NORMAL
- en: View the source or inspect the target form to get the `name` attribute from
    the input elements as well as the target `action` attribute from the `form` element.
    If no action URL is provided in the `form` element, then it defaults to the current
    URL. One other important piece of information is the method used on the form.
    Login forms should be `POST`, but it is possible that they are coded poorly and
    use a `GET` method. Some login forms use JavaScript to submit the form and may
    completely bypass the standard form method. Sites that use logic like this will
    require more reverse engineering to determine what the final post destination
    really is and how the data is formatted. You can use an HTML proxy or use the
    network inspector in the browser to view the XHR requests.
  prefs: []
  type: TYPE_NORMAL
- en: Later chapters will talk about web crawling and querying within the `DOM` interface
    to find specific elements based on name or CSS selectors, but this chapter will
    not discuss trying to auto-detect the form field and identify the proper input
    elements. This step must be done manually here, but, once it is identified, the
    brute force attack can run on its own.
  prefs: []
  type: TYPE_NORMAL
- en: To protect against attacks like these, implement a CAPTCHA system or a rate-limiting
    feature.
  prefs: []
  type: TYPE_NORMAL
- en: Note that every web application can have their own way of authenticating. This
    is not a one-size-fits-all solution. It provides an example of a basic `HTTP POST`
    form login, but will need to be modified slightly for different applications.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Brute forcing SSH
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Secure Shell or SSH supports a few authentication mechanisms. If a server only
    supports public key authentication, a brute force attempt is near futile. This
    example will only look at password authentication with SSH.
  prefs: []
  type: TYPE_NORMAL
- en: To protect against attacks like these, implement rate-limiting or a tool such
    as fail2ban that locks out accounts for a short duration when a number of failed
    login attempts are detected. Also disable the root remote login. Some people like
    to put SSH on a non-standard port, but end up putting it on high number non-restricted
    ports such as `2222`, which is not a good idea. If you use a high number non privileged
    port such as `2222`, another low privilege user could hijack the port and start
    running their own service in its place if it ever went down. Put your SSH daemon
    on a port lower than `1024` if you want to change it from the default.
  prefs: []
  type: TYPE_NORMAL
- en: This attack is obviously noisy in the logs, easy to detect, and blocked by things
    such as fail2ban. If you are doing a penetration test though, checking whether
    rate limiting or account locking is present can serve as a quick way. If no rate
    limiting or temporary account lockout is configured, brute force and DDoS are
    potential risks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running this program requires an SSH package from [golang.org](http://www.golang.org).
    You can get it using this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'After installing the `ssh` package required, you can run the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Brute forcing database login
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Database logins can be automated and brute forced just like the other methods.
    In the previous brute force examples, the majority of the code is the same. The
    major difference between the applications is the function that actually tests
    the authentication. Instead of repeating all that code again, these snippets will
    simply demonstrate how to log in to the various databases. Modify the previous
    brute force scripts to test for one of these instead of the SSH or HTTP method.
  prefs: []
  type: TYPE_NORMAL
- en: To protect against this, limit access to a database to only the machines that
    need it and disable root remote login.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go does not provide any database drivers in the standard library, only the
    interfaces. Therefore, all of these database examples require a third-party package
    from GitHub, as well as a running instance of the database to connect to. This
    book does not cover how to install and configure these database services. Each
    of these packages can be installed using the `go get` command:'
  prefs: []
  type: TYPE_NORMAL
- en: 'MySQL: [https://github.com/go-sql-driver/mysql](https://github.com/go-sql-driver/mysql)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'MongoDB: [https://github.com/go-mgo/mgo](https://github.com/go-mgo/mgo)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'PostgreSQL: [https://github.com/lib/pq](https://github.com/lib/pq)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This example combines all three database libraries and provides one tool that
    can brute force MySQL, MongoDB, or PostgreSQL. The database type is specified
    as one of the command-line arguments, along with the username, host, password
    file, and database name. MongoDB and MySQL do not require a database name such
    as PostgreSQL, so it is optional when not using the  `postgres` option. A special
    variable called `loginFunc` is created to store the login function associated
    with the specified database type. This is the first time we''ve used a variable
    to hold a function. The login function is then used to perform the brute force
    attack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having read this chapter, you will now understand how a basic brute force attack
    works against different applications. You should be able to adapt the examples
    given here to attack different protocols based on your needs.
  prefs: []
  type: TYPE_NORMAL
- en: Remember, these examples can be dangerous and potentially cause a denial of
    service, and it is not recommended that you run them against production services
    unless it is for the purpose of testing your brute force safeguards. Only perform
    these tests against services that you control, have permission to test, and understand
    the repercussions. You should never use these examples or these types of attacks
    against services you don't own, or you could break laws and land yourself in serious
    legal trouble.
  prefs: []
  type: TYPE_NORMAL
- en: There are fine legal lines that can be hard to distinguish for tests. For example,
    if you are renting a hardware appliance, you technically do not own it, and need
    permission to test it even if it is located in your data center. Similarly, if
    you are renting hosting services from a provider such as Amazon, you must get
    their permission before performing penetration tests or you might suffer consequences
    for violating terms of service.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at web applications with Go and how to harden
    them and increase security using best practices such as HTTPS, using secure cookies
    and secure HTTP headers, escaping HTML output, and adding logging. It also explores
    how to consume a web application as a client by making requests, using a client
    SSL certificate, and using proxies.
  prefs: []
  type: TYPE_NORMAL
