- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Trusted Platform Module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Commonly just called **TPM**, short for **Trusted Platform Module**, this security-focused
    microcontroller chipset uses advanced cryptography to store critical or sensitive
    information. This could be in the form of credentials, passwords, biometrics,
    encryption keys, or other very sensitive data.
  prefs: []
  type: TYPE_NORMAL
- en: The exercises in this chapter will challenge your perceptions of what can or
    should be automated in an appliance. In this chapter, we will build upon methodologies
    to leverage this tool to further automate your encrypted passphrase authentication
    within your solutions, as initially introduced in [*Chapter 6*](B22104_06.xhtml#_idTextAnchor213).
    TPM, when leveraged properly, can become your enabler to a higher level of security
    and positive end-user experience. That said, TPM is not without its drawbacks
    and eccentric warts. It is notoriously not user-friendly and, sometimes, some
    of its registers can be unreliable. Whether or not this is a hardware or software
    issue, I know not. Regardless, I will demonstrate how to manipulate it for success.
  prefs: []
  type: TYPE_NORMAL
- en: 'Whether you choose to leverage TPM or not is not a simple decision to make.
    Weigh the pros and cons. It can truly take your appliance to the next level if
    you let it. This chapter will have the following headings:'
  prefs: []
  type: TYPE_NORMAL
- en: What is TPM?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring TPM by example
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s get started.
  prefs: []
  type: TYPE_NORMAL
- en: What is TPM?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Beyond being one of hundreds of chips on your motherboard that most people could
    never identify, TPM is rapidly becoming a mission-essential tool for most operating
    systems. As of this book’s writing, the average Linux system does not even require
    you to have TPM activated. Other operating systems, such as Microsoft Windows
    11, actually require it for the operating system to be installed.
  prefs: []
  type: TYPE_NORMAL
- en: TPM provides mechanisms to securely store a variety of information securely.
    These objects can be (but are not limited to) license keys, user credentials,
    encryption keys, or other types of data that provide for the consumption of said
    data without user interactions.
  prefs: []
  type: TYPE_NORMAL
- en: There are different types of TPM implementation – firmware, discrete, and integrated
    TPM. TPM can also be done via software (aka virtual TPM) but it can possibly be
    worked around since it has no more protection than any other software programs
    running on top of your operating system. Avoid software TPM unless it’s a last
    resort.
  prefs: []
  type: TYPE_NORMAL
- en: '**Firmware TPMs** take advantage of the system CPU’s trusted execution functions.
    This, by default, creates what is known as a **trust anchor** for that system.
    These can only be cleared by being physically present at the console and cleared
    out via setting in the **UEFI BIOS**. These are the most commonly found – in my
    opinion, the most reliable as well.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Discrete TPMs** are similar to firmware-based TPMs except that they are controlled
    outside of the UEFI BIOS through other APIs and software. Discrete TPMs leverage
    functionality within your CPU itself rather than the firmware. If you replace
    your CPU or change your operating system, you will lose all the TPM data previously
    stored. Otherwise, these are virtually just as good as those in one’s firmware.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, there are the **integrated TPMs**; these are chipsets that perform
    many functions but also have the TPM functionality built in. This type of TPM
    functionality is the least common in the field.
  prefs: []
  type: TYPE_NORMAL
- en: I’ve been asked *“Is using one over the others leaving oneself vulnerable?”*.
    The short and correct answer is that not using any TPM solution is what may leave
    one’s solution vulnerable. All TPM implementations work. Which you choose is solely
    based on your own criteria and what is available for your chosen platform.
  prefs: []
  type: TYPE_NORMAL
- en: Currently, the gold standard is TPM version 2.0\. TPM 2.0 is feature-rich and
    can store multiple keys and values. It is found virtually on all the latest servers,
    PCs, and laptops. Its algorithms and built-in cryptography are impressive.
  prefs: []
  type: TYPE_NORMAL
- en: Older systems may have the earlier implementation of TPM 1.2\. This version
    has limited capacity and lesser-strength cryptography, yet it is leaps and bounds
    better than not having anything.
  prefs: []
  type: TYPE_NORMAL
- en: Most government requirements standards globally set TPM 1.2 as a minimum requirement
    for any system that touches sensitive data. Of course, TPM 2.0 is requisite on
    the most sensitive platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now move on to a brief history of TPM.
  prefs: []
  type: TYPE_NORMAL
- en: The history of TPM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I’ll summarize a quick historical overview for you, and I’ll intentionally keep
    it brief and spare you any drudgery. TPM was the result of brainstorming by a
    technology industry think tank called *Trusted Computing Group* back in 2009\.
    This concept was turned into a global standard by the **International Organization
    for Standardization** (**ISO**) in conjunction with the **International Electrotechnical
    Commission** (**IEC**). Hence, TPM was born as *ISO/IEC 11889:2009*.
  prefs: []
  type: TYPE_NORMAL
- en: TPM 1.2 became a global standard back in 2011 and reigned for many years. It
    was only replaced by TPM 2.0 in 2019 as the *ISO/IEC 11889:2015* publication.
    Sadly, it is now considered insufficient and obsolete by most security organizations.
    I still say using a TPM 1.2 module is better than using nothing. So clearly, you
    can make your own decisions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a graphical description of how TPM works (credit, Wikipedia, [https://upload.wikimedia.org/wikipedia/commons/thumb/b/be/TPM.svg/2880px-TPM.svg.png](https://upload.wikimedia.org/wikipedia/commons/thumb/b/be/TPM.svg/2880px-TPM.svg.png)):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1 – TPM description](img/B22104_07_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.1 – TPM description
  prefs: []
  type: TYPE_NORMAL
- en: TPM 2.0 is still, as of this book’s publishing, the global standard. The exercises
    in this chapter will solely focus on TPM version 2.0\. So, let’s move on to those
    exercises now.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring TPM by example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this exercise, we’ll implement the automation of a storage volume’s decryption
    by storing an encryption passphrase within the TPM securely. Doing such in a real-world
    appliance makes your solution more secure and prevents having to share the encryption
    passphrase with the public, hence, by nature, making your solution vastly more
    secure.
  prefs: []
  type: TYPE_NORMAL
- en: Requirements for the exercise
  prefs: []
  type: TYPE_NORMAL
- en: For this lab, I installed Fedora40 (Workstation Edition) onto bare-metal hardware.
    During this installation, I created a 500 MiB encrypted XFS filesystem mounted
    onto `/data`. I used `TPMmaster2024` as the encryption key.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s what that setup looked like during the creation process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2 – Encrypted filesystem setup during Fedora installation](img/B22104_07_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.2 – Encrypted filesystem setup during Fedora installation
  prefs: []
  type: TYPE_NORMAL
- en: 'Upon completion of the installation, when the system boots, we are prompted
    to enter the **LUKS key** in order to boot and mount that filesystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.3 – Entering the LUKS key manually at boot](img/B22104_07_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.3 – Entering the LUKS key manually at boot
  prefs: []
  type: TYPE_NORMAL
- en: For this exercise, I recommend you add a really small LUKS encrypted partition
    to an existing test machine without doing a complete reinstall. It’s up to you.
    In my example, I’ve used a non-system partition/filesystem, but in production,
    you would be encrypting almost everything except for `/boot` and the EFI partition.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise – enabling TPM 2 in conjunction with LUKS encryption
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, let’s ensure that your system actually has the correct hardware. We’ll
    browse the logs to see whether a TPM 2.0 module was found at the last boot cycle.
    If this doesn’t return good results, you may not have the requisite hardware for
    this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The output for this command can be somewhat lengthy, so I will not be displaying
    all of the possible output here for this instance. The key thing to observe in
    the output you get from running the command is `TPM2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: If you didn’t get any `TPM2` output, it’s probably safe to say that your lab
    hardware is insufficient for the exercises in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we’ve established you have a TPM version 2.0 module, let’s ensure
    it is set up properly in the UEFI BIOS. Reboot your machine, interrupt the boot
    process so that you can enter the UEFI BIOS setup, and then go to your TPM configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.4 – UEFI BIOS – setting up TPM](img/B22104_07_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.4 – UEFI BIOS – setting up TPM
  prefs: []
  type: TYPE_NORMAL
- en: You may have more than one option for TPM; if so, choose **Firmware TPM** over
    **Discrete TPM**. Set the chipset to **Enabled**, and to ensure that there’s nothing
    legacy left inside the chip, clear it before proceeding. Do not forget to save
    and exit your UEFI BIOS (and reboot).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s install the packages we’ll need to automate the decryption process leveraging
    our TPM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The output for this is rather lengthy, so I have truncated what is displayed.
    What is important is that your package installations are completed successfully:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We’re not done yet. There are more packages that we must ensure are installed
    properly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The output for this command is rather verbose, so I have truncated it to only
    show what I recommend that you check for on your execution (i.e., the package
    installations completed successfully – please note that some packages may already
    have been installed previously depending on how you configured your lab machine):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we’ll need to determine the exact device name for our encrypted device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This command is rather important in its lengthy output as it will guide you
    as to how your disks are carved out and the sizes of filesystems:'
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Your system’s output might vary from the results I have – make note of how your
    disks are carved out. This will be important in this exercise.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: So, for example, my block device is `/dev/sda8` (please note that yours will
    be different).
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll take that information and feed it into the next command, which will bind
    our key into TPM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Please note that this command will ask you to authenticate to use elevated
    permissions. Then, it will ask you to confirm the existing LUKS passphrase you
    wish to use to automatically decrypt the volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s tell `systemd` to always use the TPM2 module first when trying to
    access that drive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This command will ask you to confirm the existing LUKS passphrase:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: All right, we’re not done yet. We’ll use `dracut` to regenerate the proper settings
    for booting.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, the output for this will be exhaustingly extensive, but I do ask that
    you pay close attention to your own output results. Here, I will truncate my results
    and only highlight the end state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we’ve configured the new booting parameters and kernel image, it’s time
    to reboot your system. If all goes well, you will *not* be prompted to enter your
    LUKS password (it’ll be done for you automatically thanks to TPM):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: TPM2 can be rather problematic. Depending on your system, it’s common to have
    to rebind LUKS passphrases with `clevis` after some patching cycles.
  prefs: []
  type: TYPE_NORMAL
- en: TPM is known to be troublesome, if not uncooperative, to Linux. Many Linux developers
    are working hard to iron out the issues. I suspect that, in the near future, as
    these issues are resolved, we’ll see some distributions forcing TPM2 usage in
    the same manner that Windows does today.
  prefs: []
  type: TYPE_NORMAL
- en: I trust you enjoyed this platform exercise module. (See what I did there? Dad
    jokes – sorry, hahaha!)
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered TPM, its versions, and its history. I kept it brief
    in order to not bore you to death. The point of this book is to help you understand
    how to make things more secure rather than being an anthology of technological
    evolution.
  prefs: []
  type: TYPE_NORMAL
- en: You got a rare glimpse into how this understated TPM technology can aid you
    in automating your appliance’s security. Although TPM is an imperfect solution,
    it has its merits and its risks. More importantly, you should consider implementing
    TPM to automate your encrypted filesystems with your product.
  prefs: []
  type: TYPE_NORMAL
- en: In our next chapter, we’ll go even deeper into disk encryption functionality.
    Let’s move on.
  prefs: []
  type: TYPE_NORMAL
- en: Join our community on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the authors and other
    readers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/embeddedsystems](https://packt.link/embeddedsystems)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B22104_Discord_QR.jpg)'
  prefs: []
  type: TYPE_IMG
