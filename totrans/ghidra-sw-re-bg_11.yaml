- en: '*Chapter 9*: Scripting Binary Audits'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Auditing binaries is a time-consuming task, so it is recommended to automate
    the process as much as possible. When auditing a software project, hunting some
    kind of vulnerabilities such as logical issues or architectural issues leading
    to vulnerabilities cannot be automated but, in some other cases, such as memory
    corruption vulnerabilities, they are generic and capable of being automated using,
    for instance, a Ghidra script developed for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn how to automate the task of looking for vulnerabilities
    in executable binaries using Ghidra. You will analyze how a Ghidra script developed
    by Zero Day Initiative works by looking for vulnerable calls to `sscanf` (a C
    library that reads formatted data from a string) in order to automate the bug
    hunting process explained in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we will discuss PCode, Ghidra's intermediate language, allowing you
    to abstract your scripts from the processor's architecture.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Looking for vulnerable functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Looking for `sscanf` callers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analyzing the caller function using PCode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The requirements for this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The GitHub repository containing all the necessary code for this chapter: [https://github.com/PacktPublishing/Ghidra-Software-Reverse-Engineering-for-Beginners/tree/master/Chapter09](https://github.com/PacktPublishing/Ghidra-Software-Reverse-Engineering-for-Beginners/tree/master/Chapter09)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sscanf`: A Zero Day Initiative Ghidra script for automated bug hunting by
    modeling vulnerable code: [https://github.com/thezdi/scripts/blob/master/sscanf/sscanf_ghidra.py](https://github.com/thezdi/scripts/blob/master/sscanf/sscanf_ghidra.py)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Mingw-w64: GCC compiler for Windows 64- and 32-bit architectures: [http://mingw-w64.org/doku.php](http://mingw-w64.org/doku.php)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'GNU ARM Embedded Toolchain: A suite of tools for compiling C, C++, and ASM
    targeting ARM architectures. It allows us to cross-compile our source code targeting
    the ARM platform: [https://developer.arm.com/tools-and-software/open-source-software/developer-tools/gnu-toolchain/gnu-rm/downloads](https://developer.arm.com/tools-and-software/open-source-software/developer-tools/gnu-toolchain/gnu-rm/downloads)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you want to learn more about toolchains, please, refer to the Packt book
    *Mastering Embedded Linux Programming - Second Edition*, *Chris Simmonds*, *June
    2017*: [https://subscription.packtpub.com/book/networking_and_servers/9781787283282](https://subscription.packtpub.com/book/networking_and_servers/9781787283282).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Check out the following video to see the Code in Action: [https://bit.ly/2Io58y6](https://bit.ly/2Io58y6)'
  prefs: []
  type: TYPE_NORMAL
- en: Looking for vulnerable functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you remember from the previous chapter, when looking for vulnerabilities,
    we started by looking for unsafe C/C++ functions listed in the symbols table.
    Unsafe C/C++ functions are likely to introduce vulnerabilities because it's up
    to the developer to check the parameters passed to the function. Therefore, they
    have the opportunity to commit a programming error with safety implications.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, we will analyze a script that looks for the use of variables
    expected to be initialized by `sscanf` without validating the proper initialization:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: When compiling this code and executing it, the result is unpredictable. Since
    the `data` variable is initialized to an empty string in line `01`, when `sscanf`
    is called in line `04`, it is not able to read the `name` string and the `age`
    integer from the `data` buffer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, `name` and `age` contain some unpredictable values when retrieving
    their values on lines `05` and `06`, respectively. During an execution, in my
    case (it will probably be different for you), it produced the following unpredictable
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'To fix this vulnerability, you must check the return value of `sscanf` because,
    on success, this function returns the number of values successfully scanned from
    the given buffer. Only use the `age` and `name` variables in cases where both
    are successfully read:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, you will learn how to look for the `sscanf` functions in
    the symbols table in order to hunt for the kinds of vulnerabilities covered in
    this section.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving unsafe C/C++ functions from the symbols table
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As you know from [*Chapter 2*](B16207_02_Final_SK_ePub.xhtml#_idTextAnchor031),
    *Automating RE Tasks with Ghidra Scripts*, when developing a `GhidraScript` script
    to automate a task, the following states are available from scripting:'
  prefs: []
  type: TYPE_NORMAL
- en: '`currentProgram`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`currentAddress`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`currentLocation`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`currentSelection`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`currentHighlight`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To obtain a symbols table instance of the current program, the Zero Day Initiative
    script calls to the `getSymbolTable()` method from `currentProgram`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'And to pick all symbols related to the `_sscanf` function, we call the `getSymbols()`
    method from the symbols table instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, if there are no symbols in the `list_of_scanfs` list, our static analysis
    indicates that the program is not vulnerable to unsafe `_sscanf` calls, so we
    can return:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, it is straightforward to look for unsafe functions using Ghidra
    scripting; this kind of script can be easily implemented using the Ghidra API.
    Remember you have a quick reference to it in [*Chapter 6*](B16207_06_Final_SK_ePub.xhtml#_idTextAnchor108),
    *Scripting Malware Analysis*.
  prefs: []
  type: TYPE_NORMAL
- en: Decompiling the program using scripting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Decompiling allows you to retrieve the program''s disassembly, which is the
    view of the program that we use when looking for vulnerabilities. The following
    Zero Day Initiative script code snippet is responsible for decompiling the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Let me explain the steps taken in the preceding code snippet in order to perform
    decompilation:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Getting a `DecompilerOptions` instance: In order to decompile the program,
    we need to obtain a decompiler object for a single decompile process. We start
    by instantiating a `decompiler_options` object (line `00`).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Retrieving options relevant to the decompiling process: To set the options,
    we use the `grabFromToolAndProgram()` API, passing to it the tool options specific
    to the decompiler and the target program, which is relevant to the decompiling
    process.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ghidra classes implementing Ghidra's interface tools (`FrontEndTool`, `GhidraTool`,
    `ModalPluginTool`, `PluginTool`, `StandAlonePluginTool`, `TestFrontEndTool`, and
    `TestTool`) have associated options grouped by category.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: So, to obtain the decompiler category options (options relevant to decompiling)
    of the current tool (which is `PluginTool`), the code snippet uses the option
    service to retrieve the relevant decompiling options (lines `01`–`05`).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Setting values to the retrieved decompiling options: After retrieving the options
    relevant for decompiling, the code snippet gets the appropriate decompiler option
    values using the `grabFromToolAndProgram`() API, passing to it the tool options
    and the target program (lines `06`–`10`).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, the code snippet obtains an instance of the decompiler and sets the decompiler
    options to it (lines `11`–`15`).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Setting values to the retrieved decompiling options: Finally, the code snippet
    checks whether it is able to decompile the program by calling to the `openProgram()`
    API (lines `16`–`18`).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After obtaining a configured decompiler that is able to decompile the program,
    we can start looking for callers of the `_sscanf` unsafe function.
  prefs: []
  type: TYPE_NORMAL
- en: Looking for sscanf callers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you know, finding an unsafe function in the program does not necessarily
    mean that the program is vulnerable. To confirm if a function is vulnerable we
    need to analyze the caller functions and analyze the parameters passed to the
    unsafe function.
  prefs: []
  type: TYPE_NORMAL
- en: Enumerating caller functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following code snippet can be used to identify the caller functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code snippet looks for caller functions making use of the function
    manager. It can be easily retrieved by calling to the `getFunctionManager()` function,
    as shown in line `01`.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we can iterate over the list of `_sscanf` symbols, checking whether
    those symbols are functions, because we are interested in `_sscanf` functions
    (lines `02` and `03`).
  prefs: []
  type: TYPE_NORMAL
- en: For every `_sscanf` symbol function identified, we enumerate its references
    (line `04`).
  prefs: []
  type: TYPE_NORMAL
- en: The function referencing `_sscanf` is the caller function, so we can use the
    `getFunctionContaining()` API to retrieve the caller function (lines `05`–`07`).
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we can decompile the caller by using the `decompileFunction()` Ghidra
    API (lines `08`–`13`).
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will analyze the resulting `caller_function_decompiled`
    object using PCode to determine whether it is or isn't vulnerable.
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing the caller function using PCode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Ghidra can work with both assembly language and PCode. PCode is an abstraction
    of the assembly level, meaning that if you develop a script using PCode, you are
    automatically supporting all the assembly languages that offer translation from
    PCode. (At the time of writing this book, the following processors are supported:
    6502, 68000, 6805, 8048, 8051, 8085, AARCH64, ARM, Atmel, CP1600, CR16, DATA,
    Dalvik, HCS08, HCS12, JVM, MCS96, MIPS, PA-RISC, PIC, PowerPC, RISCV, Sparc, SuperH,
    SuperH4, TI_MSP430, Toy, V850, Z80, TriCore, and x86.) Really powerful, right?'
  prefs: []
  type: TYPE_NORMAL
- en: PCode to assembly-level translation
  prefs: []
  type: TYPE_NORMAL
- en: 'PCode assembly is generated with a processor specification language named SLEIGH:
    [https://ghidra.re/courses/languages/html/sleigh.html](https://ghidra.re/courses/languages/html/sleigh.html).
    You can check the current list of supported processors and their SLEIGH specifications
    here: [https://github.com/NationalSecurityAgency/ghidra/tree/master/Ghidra/Processors](https://github.com/NationalSecurityAgency/ghidra/tree/master/Ghidra/Processors).'
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand PCode, you must be familiar with three key concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Address space**: A generalization of the indexed memory (RAM) that a typical
    processor has access to. The following screenshot shows a PCode code snippet highlighting
    address space references:![Figure 9.1 – Address space in PCode'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '](img/B16207_09_001.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 9.1 – Address space in PCode
  prefs: []
  type: TYPE_NORMAL
- en: '**Varnode**: The unit of data manipulated by PCode. A sequence of bytes in
    some address space is represented by the address and the number of bytes (constant
    values are also varnodes). The following screenshot shows a PCode code snippet
    highlighting varnodes:![Figure 9.2 – Varnodes in PCode'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '](img/B16207_09_002.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 9.2 – Varnodes in PCode
  prefs: []
  type: TYPE_NORMAL
- en: '**Operation**: One or many PCode operations enables to emulate a processor
    instruction. PCode operations allow arithmetic, data moving, branching, logical,
    Boolean, floating-point, integer comparison, extension/truncation, and managed
    code. The following screenshot shows a PCode code snippet highlighting operations:![Figure
    9.3 – Operations in PCode'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '](img/B16207_09_003.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 9.3 – Operations in PCode
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also learn PCode and how to distinguish between address space/varnode/operation
    in practice. To learn it this way, right-click on the instruction and choose **Instruction
    Info…** to see the details:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.4 – Retrieving information of a PCode instruction'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16207_09_004.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.4 – Retrieving information of a PCode instruction
  prefs: []
  type: TYPE_NORMAL
- en: PCode mnemonics are self-explanatory. But for better understanding the PCode
    assembly listing, please check the PCode reference.
  prefs: []
  type: TYPE_NORMAL
- en: PCode reference
  prefs: []
  type: TYPE_NORMAL
- en: 'The list of PCode operations are fully documented here: [https://ghidra.re/courses/languages/html/pcodedescription.html](https://ghidra.re/courses/languages/html/pcodedescription.html).
    You can also check out the `PcodeOp` Java autogenerated documentation: [https://ghidra.re/ghidra_docs/api/ghidra/program/model/pcode/PcodeOp.html](https://ghidra.re/ghidra_docs/api/ghidra/program/model/pcode/PcodeOp.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Even though PCode is a powerful tool, it cannot act as a complete substitute
    for assembly language. Let's compare both to better understand this.
  prefs: []
  type: TYPE_NORMAL
- en: PCode versus assembly language
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When comparing assembly language with PCode, we can notice that assembly language
    is more human-readable because one assembly instruction is translated into one
    or more PCode operations (one-to-many translation) making it more verbose. On
    the other hand, PCode offers more granularity, allowing you to control every operation
    step by step instead of doing a lot of things using a single instruction (that
    is, move a value and update the flags at the same time).
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in conclusion, PCode is preferable for scripting development while assembly
    language is preferable when code is being analyzed by humans:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.5 – Comparing both _sum disassembly listings: x86 assembly versus
    PCode'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16207_09_005.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.5 – Comparing both _sum disassembly listings: x86 assembly versus
    PCode'
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will use PCode to analyze the caller function stored
    in the `caller_function_decompiled` variable.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving PCode and analyzing it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start by retrieving the PCode decompilation from the `caller_function_decompiled`
    variable. To do so, we only need access to the `highFunction` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Every PCode basic block is constructed from PCode operations. We can access
    the PCode operations of `caller_pcode` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also determine whether the operation is a `CALL` operation targeting
    `sscanf` by checking whether the PCode operation is `CALL` and whether its first
    operand is the address of `sscanf`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The `CALL` operation on PCode will usually have the following three input values:'
  prefs: []
  type: TYPE_NORMAL
- en: '`input0`: The call target'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`input1`: The destination'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`input2`: The format string'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The rest of the parameters are variables where the values retrieved from the
    format string will be stored. So, we can calculate how many variables are given
    to `sscanf` using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: After calculating the number of variables given to `sscanf`, we can determine
    whether the output of `CALL` (the number of values read from the input buffer
    of `sscanf`) is checked in the right way – meaning, to see whether all variables
    (the counter is stored on the integer `num_variables`) were successfully read.
  prefs: []
  type: TYPE_NORMAL
- en: 'It could be that the return value of `sscanf` is not ever checked, so the script
    that we are analyzing starts performing this check, reporting this vulnerability
    indicator if detected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, the script checks the **descendants**. Ghidra uses the term descendants
    when referring to the subsequent uses of a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'It looks for integer equality comparisons containing the output of `sscanf`
    as operand and stores the value it is comparing with in the `comparand_var` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, it checks whether the comparand value is a constant value, and if
    it is less than the number of variables passed to `sscanf`, the script reports
    it because some variable could be used without being properly initialized:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: As you can guess, this script logic can be applied to detect multiple kinds
    of vulnerabilities; for instance, it can be easily adapted in order to detect
    use-after-free vulnerabilities. To do so, you can look for `free` function calls
    and determine whether the freed buffer is used after that.
  prefs: []
  type: TYPE_NORMAL
- en: Using the same PCode-based script in multiple architectures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we will analyze the following vulnerable program but compiled
    in two flavors – ARM and x86\. Thanks to PCode, we will code the script only once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the program is vulnerable because it checks whether `return_value`
    is equal to `1`, but there are two variables (`name` and `age`) given to the `sscanf`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can compile the program for both x86 and the ARM processor:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use Ming-w64 to compile it for the x86 architecture (don''t worry about whether
    it''s 32 or 64 bits; it doesn''t matter for this experiment) to produce an `sscanf_x
    86.exe` executable binary file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use GNU Arm Embedded Toolchain to compile it for ARM to produce an `sscanf_arm.exe`
    binary file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We have to perform some minor changes in the `sscanf` script developed by Zero
    Day Initiative in order to make it also work for ARM. These modifications are
    not related to PCode. Modifications are necessary because Ghidra detects the `sscanf`
    symbol instead of `_sscanf` and it is also detected as `SymbolNameRecordIterator`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.6 – Symbol tree and type identification of sscanf in an ARM binary'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16207_09_006.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.6 – Symbol tree and type identification of sscanf in an ARM binary
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we modify it to also include the `sscanf` symbol while calling the `next()`
    method to retrieve the first element (the function) of our given `SymbolNameRecordIterator`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'As the last step, we execute the script after the analysis, setting the `postScript`
    option. We execute Ghidra in headless mode over the `vunls` directory containing
    both executable files – `sscanf_x86.exe` and `sscanf_arm.exe`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'The result will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.7 – Running a single sscanf_ghidra.py script over the x86 and ARM
    binaries'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16207_09_007.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.7 – Running a single sscanf_ghidra.py script over the x86 and ARM binaries
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, by using PCode, you can write a script once and support all
    architectures without worrying about it.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, PCode allows you to automate the bug hunting process, having
    fine-grained control due to the single assignment property accomplished by PCode.Fine-grained
    control can be very useful with bug hunting. For instance, for checking whether
    some program input exists that can reach a vulnerable function, it is easier to
    use PCode than assembly language, because assembly operations usually modify a
    lot of stuff (registers, memory, flags, and more) in a single operation.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use Ghidra to automatically audit program
    binaries to hunt for bugs on them. We started scripting to look for vulnerable
    functions in the symbols table, then we continued by looking for the callers of
    those functions, and, finally, we analyzed the caller functions to determine whether
    those functions are vulnerable or not.
  prefs: []
  type: TYPE_NORMAL
- en: You learned how to script a binary auditing process using Ghidra and how to
    do so using PCode and its benefits. You also learned why PCode cannot entirely
    substitute for assembly language in manual analysis.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter of this book, we will cover how to extend Ghidra using plugins.
    We mentioned this in [*Chapter 4*](B16207_04_Final_SK_ePub.xhtml#_idTextAnchor063),
    *Using Ghidra Extensions*, but this topic deserves special mention because it
    allows you to deeply extend Ghidra in a powerful way.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the difference between SLEIGH and PCode?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is PCode easier to read for humans than assembly language? Why is PCode useful?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can refer to the following links for more information on the topics covered
    in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Mindshare: Automated bug hunting by modeling vulnerable code: [https://www.thezdi.com/blog/2019/7/16/mindshare-automated-bug-hunting-by-modeling-vulnerable-code](https://www.thezdi.com/blog/2019/7/16/mindshare-automated-bug-hunting-by-modeling-vulnerable-code)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'River Loop Security: Working with Ghidra''s PCode to identify vulnerable function
    calls: [https://www.riverloopsecurity.com/blog/2019/05/pcode/](https://www.riverloopsecurity.com/blog/2019/05/pcode/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Three Heads Are Better Than One: Mastering NSA''s Ghidra Reverse Engineering
    Tool*: [https://github.com/0xAlexei/INFILTRATE2019/blob/master/INFILTRATE%20Ghidra%20Slides.pdf](https://github.com/0xAlexei/INFILTRATE2019/blob/master/INFILTRATE%20Ghidra%20Slides.pdf)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
