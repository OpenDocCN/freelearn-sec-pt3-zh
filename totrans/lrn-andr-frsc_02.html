<html><head></head><body><div><h1 class="header-title">Setting up the Android Forensic Environment</h1>
                
            
            
                
<p>Before starting a forensic examination, you need a workstation. A forensic analyst needs to be in total control of their workstation at all times. This chapter will take you through everything that is necessary to have an established forensic setup for examining Android devices. The following topics are going to be covered in this chapter:</p>
<ul>
<li>Android forensic setup</li>
<li>Android Debug Bridge</li>
<li>Rooting Android</li>
</ul>


            

            
        
    </div>



  
<div><h1 class="header-title">Android forensic setup</h1>
                
            
            
                
<p>Setting up a sound and well-controlled forensic environment is crucial before the start of any investigation. Start with a fresh and forensically sterile computer. A forensically sterile computer is one that prevents the potential of cross-contamination and doesn't introduce unwanted data. This is to ensure that the software present on the machine does not interfere with the current investigation. Install basic software, such as the ones mentioned in the following list, which are necessary to connect to the device and to perform analysis:</p>
<ul>
<li>Android SDK</li>
<li>Drivers for mobile devices</li>
<li>Office packages</li>
<li>Tools used for analysis</li>
</ul>
<p class="mce-root"/>


            

            
        
    </div>



  
<div><h1 class="header-title">Android SDK</h1>
                
            
            
                
<p>It's important that we begin the discussion with Android Studio and the Android SDK. <strong>Android Studio</strong> is a fully-fledged <strong>Integrated Development Environment</strong> (<strong>IDE</strong>), and contains everything needed to build a full app from the ground up. The Android <strong>Software Development Kit</strong> (<strong>SDK</strong>) is a subset of Android Studio, including only the tools needed to communicate with a device via the command line. It includes software libraries, APIs, emulator, reference material, and many other tools that not only help to create Android applications but also provide documentation and utilities that help significantly in forensic analysis of Android devices. Having sound knowledge of the Android SDK can help you understand the particulars of a device that, in turn, aid during investigation.</p>
<p>During examination, the SDK helps us to connect to the device and access the data. The SDK is supported in Windows, Linux, and OS X and can be downloaded for free at <a href="https://developer.android.com/studio">https://developer.android.com/studio</a>.</p>
<p>For the purposes of this book, only the SDK is needed. It can be found at the previous link under the <em>Command line tools only</em> section.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Installing the Android SDK</h1>
                
            
            
                
<p>The following is a step-by-step procedure to install the Android SDK on a Windows 10 machine:</p>
<ol>
<li>Before the start of the Android SDK installation, make sure the system has the latest <strong>Java Development Kit</strong> (<strong>JDK</strong>) installed, as the Android SDK is dependent on Java SE Development Kit. JDK can be downloaded from <a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html">http://www.oracle.com/technetwork/java/javase/downloads/index.html</a>. Select the correct download based on your operating system.</li>
<li>Download the latest version of SDK tools package from <a href="https://developer.android.com/studio/#command-tools">https://developer.android.com/studio/#command-tools</a>. </li>
<li>Unzip the archive you have just downloaded at the location of your choice. That's it: you're ready to go.</li>
</ol>
<p class="mce-root"/>
<p>Let's look at the most interesting parts of the SDK tools from a forensic point of view:</p>
<ul>
<li><kbd>apkanalyzer</kbd>: This allows you to examine the contents of an APK file in a fast and efficient manner. For example, you can collect information about application ID, version code, and version name and analyze the contents of its manifest, the DEX files inside it, as well as resources, such as texts, images, and strings. You can find it under <kbd>\sdk\tools\bin</kbd>.</li>
<li><kbd>avdmanager</kbd>: This allows you to create and manage <strong>Android Virtual Devices</strong> (<strong>AVDs</strong>) using the command line. Such AVDs can help you with malware analysis or can be used for testing if you don't have a physical Android device, but want to research different applications for new forensic artifacts. You can find it under <kbd>\sdk\tools\bin</kbd>.</li>
<li><kbd>emulator</kbd>: This QEMU-based device-emulation tool that allows you to debug and test applications, including malicious ones, in an actual Android runtime environment. You can find it under <kbd>\sdk\emulator</kbd>.</li>
<li><kbd>sdkmanager</kbd>: This helps you to keep your SDK tools updated. With this tool you can view, install, update, and uninstall packages. You can find it under <kbd>\sdk\tools\bin</kbd>.</li>
<li><kbd>adb</kbd> or Android Debug Bridge: This is a command-line tool that allows you to communicate with a device. It can be used not only for installing applications or copying data from a device, but also can provide a forensic examiner with a Unix shell. You can find it under <kbd>\sdk\platform-tools</kbd>.</li>
<li><kbd>fastboot</kbd>: This allows you to flash a device different system images. It can be used, for example, for flashing custom recovery images—you'll learn about them later in this chapter. You can find it under <kbd>\sdk\platform-tools</kbd>.</li>
</ul>
<p>It's important to note that so-called SDK platform tools are not included in SDK tools by default, and you'll have to install it; here is how to do it:</p>
<pre><strong>sdkmanager.bat "platform-tools"</strong></pre>
<div><p>If you think that you don't need all of the SDK tools, but want to work only with platform tools, you can get it on Android Developers (<a href="https://developer.android.com/studio/releases/platform-tools">https://developer.android.com/studio/releases/platform-tools</a>). All you need to start using these tools is to extract contents of the downloaded archive to a directory of your choice.</p>
</div>
<p class="mce-root"/>


            

            
        
    </div>



  
<div><h1 class="header-title">Android Virtual Device</h1>
                
            
            
                
<p>With the Android SDK installed, you can create an AVD, which is an emulator that runs on the workstation. An emulator is often used by developers when creating new applications. However, an emulator is also considered helpful during forensic investigation as it allows the investigator to understand how certain applications behave and to understand how installation of an application affects the device. Another advantage is you can design an emulator with the desired version. This is especially helpful when working with devices running on older versions of Android. Also, AVD comes with root as default.</p>
<p>The following steps will guide you to create an AVD on the workstation:</p>
<ol>
<li>Make sure you have the <kbd>emulator</kbd> subdirectory under <kbd>\sdk</kbd>; if not, run the following command to install it: <kbd>sdkmanager.bat "emulator"</kbd>.</li>
<li>We need a system image for our virtual device, for example, <kbd>system-images;android-28;google_apis;x86</kbd>; you can download it this way: <kbd>sdkmanager.bat "system-images;android-28;google_apis;x86"</kbd>.</li>
<li>Now we can create an AVD using <kbd>avdmanager</kbd>: <kbd>avdmanager.bat create avd -k "system-images;android-28;google_apis;x86" -n test</kbd>. As you may have already guessed, the <kbd>k</kbd> switch allows you to choose a system image, and the <kbd>n</kbd> switch allows you to choose a name for the AVD.</li>
<li>It's time to launch it! Use <kbd>emulator.exe</kbd> to do it: <kbd>emulator.exe -avd test</kbd>. The following is a screenshot of an AVD after a successful launch:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-549 image-border" src="img/9db01dc7-8326-4dd4-9638-608c0ecf0fd8.png" style="width:19.92em;height:32.17em;" width="316" height="511"/></p>
<p>Android Virtual Device (AVD) running Android 9 (Pie)</p>
<p>An emulator can be used to configure email accounts, install applications, surf the internet, send text messages, and so on. Forensic analysts and security engineers can learn a great deal about Android and how it operates by leveraging the emulator and examining the network, filesystem, and data artifacts. The data created when working on an emulator is stored in your home directory, in a folder named <kbd>.android</kbd>. For instance, in our example, the details about the test AVD that we created earlier are stored in <kbd>C:\Users\0136\.android\avd\test.avd</kbd>. There are several files present under this directory and the following are some of the files of interest for a forensic analyst:</p>
<ul>
<li><kbd>cache.img</kbd>: This is the disk image of the <kbd>/cache</kbd> partition.</li>
<li><kbd>sdcard.img</kbd>: This is the disk image of the SD card partition.</li>
<li><kbd>Userdata-qemu.img</kbd>: This is the disk image of the <kbd>/data</kbd> partition. The <kbd>/data</kbd> partition contains valuable information about the device user.</li>
</ul>
<ul>
<li><kbd>config.ini</kbd>: This file contains information about the system image used.</li>
<li><kbd>hardware-qemu.ini</kbd>: This file contains the emulator's hardware options, such as architecture, RAM size, and screen type.</li>
</ul>


            

            
        
    </div>



  
<div><h1 class="header-title">Connecting and accessing Android devices from the workstation</h1>
                
            
            
                
<p>In order to extract information from an Android device, it first needs to be connected to the workstation. As mentioned earlier, care should be taken to make sure that the workstation is forensically sterile and used only for the purpose of investigation. A forensically sterile workstation is one that has a proper build and is free from malware. So, if you are familiar with virtual machines and snapshots, it may be a good idea for mobile forensics in general and Android forensics in particular, as you can have a perfectly clean workstation every time you need to examine a new device.</p>
<p>When a device is connected to the computer, changes can be made to the device, and so it is crucial that the forensic examiner maintains control over the device at all times. In the world of mobile forensics, using write protection mechanisms may not be of great help as they prevent successful acquisition of the device. This is because during acquisition certain commands need to be pushed to the device to extract necessary data. What is more, sometimes even small applications need to be installed in order to extract more data from the device or, for example, to root it.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Identifying the correct device cable</h1>
                
            
            
                
<p>An Android device can be connected to a workstation using the physical USB interface of the device. This physical USB interface allows the device to connect, share data, and recharge from a computer. USB interfaces may change from manufacturer to manufacturer, also from device to device. There are different types, such as micro-USB, USB-C, and some other less popular proprietary formats. The following is a brief description of the most widely used connector types:</p>
<p class="mce-root"/>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td>
<p><strong>Connector type</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>Micro-USB</td>
<td>It is approximately 6 by 1.5 mm in size, with two corners cut off to form a trapezoid.</td>
</tr>
<tr>
<td>
<p>USB-C</p>
</td>
<td>
<p>It is 8.4 by 2.6 mm in size, in the form of a rectangle with round corners.</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>Hence, the first step in acquisition is to identify what kind of device cable is required.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Installing device drivers</h1>
                
            
            
                
<p>A mobile device can communicate with the computer only when the necessary device drivers are installed on it. Without the necessary drivers, the computer may not be able to identify and work with the connected device. Since Android is allowed to be modified and customized by the manufacturers, there is no single generic driver that would work for all Android devices. Each manufacturer has its own proprietary drivers and distributes them along with the phone. Hence, it is important to identify the specific device driver that needs to be installed. Of course, some of the Android forensic toolkits do come with some generic drivers or a set of the most frequently used drivers, but they may not work with all models of Android phones. Some Windows operating systems are able to auto detect and install the drivers once the device is plugged in but, more often than not, it fails. The device drivers for each manufacturer can be found on their respective websites.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Accessing the device</h1>
                
            
            
                
<p>After installing the necessary device drivers, connect the Android device to the computer directly using the USB cable in order to access it. It is important to use genuine, manufacturer-specific cables because universal cables may not work properly with certain devices and the investigator may encounter certain driver issues. Some of the devices may not be USB 3.0 compatible, which may lead to failed driver installations. In that case, it's recommended to try switching to USB 2.0 ports. Once the device is connected, it will appear as a new drive and you can access the files on the external storage. Some older Android devices may not be accessible unless the Connect storage to PC option (present under Settings | USB utilities) is enabled on the device.</p>
<p>In this case, after connecting the device through USB, the Turn on USB storage option needs to be selected, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-550 image-border" src="img/e64cc8f2-d38a-4609-a75a-6cd032a4bf22.png" style="width:45.17em;height:33.83em;" width="579" height="434"/></p>
<p>USB mass storage connection</p>
<p>This is because older Android devices required USB mass storage mode for transferring files between computer and the device. The latest Android devices use MTP or PTP protocols, as there were some issues with the USB mass storage protocol. With USB mass storage, the drive makes itself completely available to the computer, just as if it were an internal drive. But the problem is that the device that is accessing the storage needs exclusive access to it. In other words, when the device drive is connected to the computer, it has to be disconnected from the Android operating system running on the device in order to work. So any files or apps stored on the SD card or USB storage would be unavailable when it was connected to the computer. In <strong>Media Transfer Protocol</strong> (<strong>MTP</strong>), the Android device doesn't expose its entire storage to Windows. Instead, when you connect a device to your computer, the computer queries the device and the device responds with a list of files and directories it offers. If the computer has to download a file, it sends a request to the file from the device, and the device will send the file over the connection. <strong>Picture Transfer Protocol</strong> (<strong>PTP</strong>) is also similar to MTP and is commonly used by digital cameras. In this mode, Android device will work with digital camera applications that support PTP but not MTP. On the latest devices, you can select either MTP or PTP options under Settings | Storage | USB computer connection.</p>
<div><p>On some Android devices, the option to select MTP and PTP protocols is provided only after connecting the device to the computer. After the device is connected, watch the <strong>notifications</strong> bar at the top of your screen and you will see a USB symbol appear. Pull down the notifications and you will find an option to switch between MTP and PTP.</p>
</div>
<p>As shown in the following screenshot, the MTP and PTP options are shown only after connecting the device to a computer and pulling down the notifications bar:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-551 image-border" src="img/e6e50f20-7668-420e-9c0a-44ee3ed22455.png" style="width:23.50em;height:41.83em;" width="720" height="1280"/></p>
<p>Changing USB connection mode on an Android device</p>
<p>The default selection is Charging. When the File transfers option is selected, it is mounted as a disk drive. When the device is mounted as a disk drive, you will be able to access the SD card present on the device.</p>
<p>From a forensic point of view, the SD card has a significant value as it may contain files that are important for an investigation. Most of the images and large files related to multimedia are stored in this external storage. SD cards are commonly formatted with the FAT32 filesystem, but you might also encounter some having exFAT and some other filesystems. As discussed in <a href="1e7a3a23-96c6-4085-9981-44b579bb2a7f.xhtml" target="_blank"/><a href="1e7a3a23-96c6-4085-9981-44b579bb2a7f.xhtml" target="_blank">Chapter 1</a>, <em>Introducing Android Forensics</em>, please note that most of the recent devices have emulated SD card feature that uses the devices NAND flash to create a non-removable SD card. Thus, all the sensitive files present on external storage can be accessed in this way. However, the core application data stored under <kbd>/data/data</kbd> will remain on the device and cannot be accessed this way.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Android Debug Bridge</h1>
                
            
            
                
<p>In Android forensics, <strong>Android Debug Bridge</strong> (<strong>ADB</strong>) plays a very crucial role. It is present under the <kbd>&lt;sdk_path&gt;/platform-tools</kbd> location. In order to work with ADB, the USB-Debugging option needs to be enabled. On most Android phones and tablets, you can access this under Settings | Developer Options, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-552 image-border" src="img/669f6339-782d-4787-9e4c-786321e3fe04.png" style="width:26.17em;height:8.67em;" width="594" height="197"/></p>
<p>USB debugging option</p>
<p>However, this may not be the case with all the devices, as different devices have different environments and configuration features. Sometimes, the examiner might have to use certain techniques to access the Developer Options on a few devices. These techniques are device-specific and need to be researched and determined by the forensic analyst based on the device type and model.</p>
<div><p>On some devices, the Developer Options menu is hidden and can be turned on by tapping the <strong>Build Number</strong> field (present under Settings | System | About Phone) seven times.</p>
</div>
<p>Once the USB Debugging option is selected, the device will run the ADB daemon (<kbd>adbd</kbd>) in the background and will continuously look for a USB connection. The daemon will usually run under a non-privileged shell user account and so doesn't provide access to internal application data. But on rooted phones <kbd>adbd</kbd> will run under the root account and hence provides access to all of the data. On the workstation (where the Android SDK is installed), <kbd>adbd</kbd> will run as a background process. Also, on the same workstation, a client program will run that can be invoked from a shell by issuing the <kbd>adb</kbd> command that we are going to see in the following sections. When the ADB client is started, it first checks whether an ADB daemon is already running. If there isn't, it initiates a new process to start the ADB daemon. The daemons communicate over their local host on the <kbd>5555</kbd> through <kbd>5585</kbd> ports. The even port communicates with the device's console, while the odd port is for ADB connections. The ADB client program communicates with the local <kbd>adbd</kbd> over the <kbd>5037</kbd> port.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Using ADB to access the device</h1>
                
            
            
                
<p>As stated before, ADB is a powerful tool that allows you to communicate with the Android device. We will now look at how to use ADB and access certain parts of the device that cannot be accessed normally. It is important to note that the collection of data through ADB may or may not be accepted as evidence in court depending on the respective laws of the country. The following sections list some of the commonly used ADB commands and their meaning and usage in a logical sequence.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Detecting a connected device</h1>
                
            
            
                
<p>After connecting the device to the workstation and before issuing other ADB commands, it is helpful to know whether the Android device is properly connected to the ADB server. This can be done using the ADB devices command, which lists out all of the devices that are connected to the computer as shown in the following command lines. This would also list the emulator if it is running at the time of issuing the command:</p>
<pre><strong>adb devices</strong><br/><strong>List of devices attached</strong><br/><strong>52037762b835835b     device</strong></pre>
<div><p>Remember that, if necessary drivers are not installed, then the preceding command would show a blank message. If you encounter that situation, download the necessary drivers from the manufacturer and install them.</p>
</div>
<p class="mce-root"/>
<p class="mce-root"/>
<p>As seen in the preceding command lines, the output contains the serial number of the device followed by the connection state. The serial number is a unique string used by ADB to identify each Android device. The possible connection state values and their meaning is explained in the following lines:</p>
<ul>
<li><strong>Offline</strong>: The instance is not connected to ADB or is not responding.</li>
<li><strong>Device</strong>: The instance is connected to the ADB server.</li>
<li><strong>No device</strong>: There's no device connected.</li>
<li><strong>Unauthorized</strong>: USB debugging isn't authorized.</li>
</ul>


            

            
        
    </div>



  
<div><h1 class="header-title">Directing commands to a specific device</h1>
                
            
            
                
<p>If more than one device is connected to the system, you must specify the target device while issuing the commands. For example, consider the following case:</p>
<pre><strong>adb devices</strong><br/><strong>List of devices attached</strong><br/><strong>4df16ac5115e4e04       device</strong><br/><strong>7f1c864544456o6e        device</strong></pre>
<p>As shown in the preceding command-line output, there are two devices attached to the workstation. In this case, <kbd>adb</kbd> needs to be used along with the <kbd>–s</kbd> option to issue commands to the device of your choice:</p>
<pre><strong>adb shell -s 4df16ac5115e4e04</strong></pre>
<p>Similarly, the <kbd>d</kbd> switch can be used to direct an <kbd>adb</kbd> command to the only attached USB device, and the <kbd>e</kbd> switch can be used to direct an <kbd>adb</kbd> command to the only running emulator instance.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Issuing shell commands</h1>
                
            
            
                
<p>As mentioned in <a href="1e7a3a23-96c6-4085-9981-44b579bb2a7f.xhtml" target="_blank">Chapter 1</a>, <em>Introducing Android Forensics</em>, Android runs on a Linux kernel and so provides a way to access the shell. Using <kbd>adb</kbd>, you can access a shell to run several commands on an Android device. For those who are not familiar with Linux environment, Linux shell refers to a special program that allows you to interact with it by entering certain commands from the keyboard; the shell will execute the commands and display its output. More details about how things work on Linux environment have been provided under the <em>Rooting Android device</em> section in this chapter.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The <kbd>adb shell</kbd> command can be used to enter into a remote shell, as shown in the following command-line output. Once you enter the shell, you can execute most of the Linux commands:</p>
<pre><strong>adb shell</strong><br/><strong>shell@android:/ $</strong></pre>
<p>After executing the command, observe that the shell prompt is displayed to the user where commands can be executed on the device. For instance, as shown in the following command line, the <kbd>ls</kbd> command can be used to view all of the files within a directory:</p>
<pre><strong>shell@android:/ $ ls</strong><br/><strong>acct</strong><br/><strong>adb_keys</strong><br/><strong>bin</strong><br/><strong>bugreports</strong><br/><strong>cache</strong><br/><strong>charger</strong><br/><strong>config</strong><br/><strong>d</strong><br/><strong>data</strong><br/><strong>default.prop</strong><br/><strong>dev</strong><br/><strong>etc</strong><br/><strong>...</strong></pre>
<p>The following section explains some of the most widely used Linux commands that are very helpful while interacting with an Android device.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Basic Linux commands</h1>
                
            
            
                
<p>We will now take a look at some of the Linux commands and their usage with respect to Android device:</p>
<ul>
<li><kbd>ls</kbd>: The <kbd>ls</kbd> command (with no option) lists files and directories present in the current directory. With the <kbd>l</kbd> switch, this command shows files and directories and their size, modified date and time, the owner of the file and its permission, and so on, as shown in the following command-line output:</li>
</ul>
<pre style="padding-left: 60px"><strong>shell@android:/ $ ls -l</strong><br/><strong>dr-xr-xr-x 64 root root 0 2018-09-16 13:21 acct</strong><br/><strong> -rw-r--r-- 1 root root 724 2018-07-31 17:54 adb_keys</strong><br/><strong> lrw-r--r-- 1 root root 11 2018-07-31 18:13 bin -&gt; /system/bin</strong><br/><strong> lrw-r--r-- 1 root root 50 2018-07-31 18:13 bugreports -&gt; /data/user_de/0/com.android.shell/files/bugreports</strong><br/><strong> drwxrwx--- 2 system cache 4096 2018-07-31 17:54 cache</strong><br/><strong> lrw-r--r-- 1 root root 13 2018-07-31 18:13 charger -&gt; /sbin/charger</strong><br/><strong> drwxr-xr-x 4 root root 0 2018-09-16 13:21 config</strong><br/><strong> lrw-r--r-- 1 root root 17 2018-07-31 18:13 d -&gt; /sys/kernel/debug</strong><br/><strong> drwxrwx--x 39 system system 4096 2018-09-16 13:21 data</strong><br/><strong> lrw------- 1 root root 23 2018-07-31 18:13 default.prop -&gt; system/etc/prop.default</strong><br/><strong> drwxr-xr-x 15 root root 2580 2018-09-16 13:21 dev</strong><br/><strong> lrw-r--r-- 1 root root 11 2018-07-31 18:13 etc -&gt; /system/etc</strong><br/><strong>...</strong></pre>
<p>Similarly, the following are a few options that can be used along with the <kbd>ls</kbd> command:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td>
<p><strong>Option</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>a</kbd></p>
</td>
<td>
<p>Lists hidden files</p>
</td>
</tr>
<tr>
<td>
<p><kbd>c</kbd></p>
</td>
<td>
<p>Displays files by timestamp</p>
</td>
</tr>
<tr>
<td>
<p><kbd>d</kbd></p>
</td>
<td>
<p>Displays only directories</p>
</td>
</tr>
<tr>
<td>
<p><kbd>n</kbd></p>
</td>
<td>
<p>Displays the long format listing, with GID and UID numbers</p>
</td>
</tr>
<tr>
<td>
<p><kbd>R</kbd></p>
</td>
<td>
<p>Displays subdirectories as well</p>
</td>
</tr>
<tr>
<td>
<p><kbd>t</kbd></p>
</td>
<td>
<p>Displays files based on timestamp</p>
</td>
</tr>
<tr>
<td>
<p><kbd>u</kbd></p>
</td>
<td>
<p>Displays the file access time</p>
</td>
</tr>
</tbody>
</table>
<p><br/>
Depending on the requirement, one or more of these options can be used by the investigator to view the details.</p>
<ul>
<li><kbd>cat</kbd>: The <kbd>cat</kbd> command reads one or more files and prints them to standard output, as shown in the following command lines:</li>
</ul>
<pre style="padding-left: 60px"><strong>shell@android:/ $ cat adb_keys</strong><br/><strong>QAAAADeVcId5z+6WTzB5Qtyj4RMBmP3IsbHsiLC2Q8EpmIRDAHywZ45jjUENg+2NF4TUnXlBAU0LyycR/ER7/EZBUjTaLE09gWJuMbZQ4RcwFjM9nnhHquctYFNB4MzobWNDeZxdYXaDEqzycEij50ae3zZ3H5F7eVSoCvwaulOWf3oxwxaeWQsDBNt0EX0yqznfxO2GIPQhwzOdtYQsAxJye16OaazCHCsXLwMNcuZLDYpH37em71S/mUfz8hwDrDlnN0CqnpQcvXW6Q0dE1RdkJZP+FCmbYCMautkEJR5vx70Xrfv1PE+2rXzXw582h8i8Ctq8V567l7DDRLaoyO4FtST4Lw/toV3KgTcVmHo7FHhhuml5ZNUwAMtBxkw8sDOTaoU9o5LjcPZdxK+0Iik/XFFZz2IxlNxQsmn9zErA7mJghkEjuZ2L4ZxPPB38HuCiCBXjTNecX2S4QPeOTVSq+VTHi9tHwN+9fKcYIwhczMg7JSNIxHDVOlLudjwzISSmWfp2/0i9J8nUHHH8jmXOe+bHv6QvFvzUl/8wtyV+prS5EcJ6sAqoCqu1Xr+9FdKqmjyNyYK3K6fZTkAetjLFuTJat/lkqUfiIL1B3chQyRP09mEk8EklWpugo0chec17ZL3Vv0CPPJIy/2rTITZDj7MKwdZi7kEAo6Rgcg/ypAESuHlMWQEAAQA= android-eng@google</strong></pre>
<ul>
<li>The <kbd>&gt;</kbd> operator can be used to combine multiple files into one. The <kbd>&gt;&gt;</kbd> operator can be used to append to an existing file.</li>
<li><kbd>cd</kbd>: The <kbd>cd</kbd> command is used to change from one directory to another. This is much used while navigating from one folder to another. The following example shows commands used to change to system folder:</li>
</ul>
<pre style="padding-left: 60px"><strong>shell@android:/ $ cd /data</strong><br/><strong>shell@android:/data $</strong></pre>
<ul>
<li><kbd>cp</kbd>: The <kbd>cp</kbd> command can be used to copy a file from one location to another. The syntax for this command is as follows:</li>
</ul>
<pre style="padding-left: 60px"><strong>$ cp [options] &lt;source&gt; &lt;destination&gt;</strong></pre>
<p>Here are the main options for the command:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td style="width: 70.8182px">
<p><strong>Option</strong></p>
</td>
<td style="width: 426.182px">
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td style="width: 70.8182px"><kbd>s</kbd></td>
<td style="width: 426.182px">
<p>Creates a <kbd>symlink</kbd> function instead of a copy</p>
</td>
</tr>
<tr>
<td style="width: 70.8182px"><kbd>l</kbd></td>
<td style="width: 426.182px">
<p>Creates a hard link instead of a copy</p>
</td>
</tr>
<tr>
<td style="width: 70.8182px"><kbd>R</kbd></td>
<td style="width: 426.182px">
<p>Copies files in subdirectories recursively</p>
</td>
</tr>
<tr>
<td style="width: 70.8182px"><kbd>p</kbd></td>
<td style="width: 426.182px">
<p>Preserves timestamps, ownership, and mode</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<ul>
<li><kbd>chmod</kbd>: The <kbd>chmod</kbd> command is used to change the access permissions to filesystem objects (files and directories). It may also alter special mode flags. The syntax for this command is as follows:</li>
</ul>
<pre style="padding-left: 60px" class="mce-root"><strong>$ chmod [option] mode files</strong></pre>
<p style="padding-left: 60px" class="mce-root">For example, <kbd>chmod 777</kbd> on a file gives permission to everyone to read, write, and execute.</p>
<ul>
<li><kbd>dd</kbd>: The <kbd>dd</kbd> command is used to copy a file, converting and formatting it according to the operands. With Android, the <kbd>dd</kbd> command can be used to create a bit-by-bit image of the Android device. More details about the imaging are covered in <a href="b5ab11df-1911-4deb-accd-f92c74650e6d.xhtml" target="_blank">Chapter 4</a>, <em>Extracting Data Logically from Android Devices</em>. The following is the syntax that needs to be used with this command:</li>
</ul>
<pre style="padding-left: 60px"><strong>$ dd if=/test/file of=/sdcard/sample.image</strong></pre>
<ul>
<li><kbd>rm</kbd>: The <kbd>rm</kbd> command can be used to delete files or directories. The following is the syntax for this command:</li>
</ul>
<pre style="padding-left: 60px"><strong>$ rm file_name</strong></pre>
<ul>
<li><kbd>grep</kbd>: The <kbd>grep</kbd> command is used to search files or output for a particular pattern. The following example shows how to search a <kbd>default.prop</kbd> file for <kbd>secure</kbd>:</li>
</ul>
<pre style="padding-left: 60px"><strong>shell@android:/ # cat default.prop | grep secure</strong><br/><strong>ro.secure=1</strong></pre>
<ul>
<li><kbd>pwd</kbd>: The <kbd>pwd</kbd> command displays the current working directory. For example, the following command-line output shows that the current working directory is <kbd>/data</kbd>:</li>
</ul>
<pre style="padding-left: 60px"><strong>shell@android:/data $ pwd</strong><br/><strong>/data</strong></pre>
<ul>
<li><kbd>mkdir</kbd>: The <kbd>mkdir</kbd> command is used to create a new directory. The following is the syntax for this command:</li>
</ul>
<pre style="padding-left: 60px"><strong>$ mkdir [options] directory</strong></pre>
<p style="padding-left: 60px">Using the <kbd>p</kbd> switch, you can also create parent directory if you need it.</p>
<ul>
<li><kbd>exit</kbd>: The <kbd>exit</kbd> command can be used to exit the shell you are in. Just type <kbd>exit</kbd> in the shell to exit from it.</li>
</ul>


            

            
        
    </div>



  
<div><h1 class="header-title">Installing an application</h1>
                
            
            
                
<p>During forensic analysis, there might be cases where you need to install a few applications on the device in order to extract some data. To do so, you can use the <kbd>adb install</kbd> command. Along with this command, as shown in the following command-line output, you need to specify the path to the <kbd>.apk</kbd> file that you want to install:</p>
<pre><strong>adb install C:\test.apk</strong><br/><strong>Success</strong></pre>
<p>However, it is important to note that installing third-party apps may not accepted in a court of law. Hence, a forensic investigator needs to be cautious before installing any third-party app on the device.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    </div>



  
<div><h1 class="header-title">Pulling data from the device</h1>
                
            
            
                
<p>You can use the <kbd>adb pull</kbd> command to pull the files present on the Android device to the local workstation. The following is the syntax for using this command:</p>
<pre><strong>adb pull &lt;remote&gt; &lt;local&gt;</strong></pre>
<p><kbd>&lt;remote&gt;</kbd> refers to the path of the file on the Android device and <kbd>&lt;local&gt;</kbd> refers to the location on the local workstation where the file needs to be stored. For instance, the following command-line output shows a <kbd>Sample.png</kbd> file being pulled from the Android device to a <kbd>temp</kbd> folder on the computer:</p>
<pre><strong>adb.exe pull /sdcard/Pictures/MyFolder/Sample.png C:\temp</strong><br/><strong>[100%] /sdcard/Pictures/MyFolder/Sample.png</strong></pre>
<p>However, on a normal Android phone, you will not be able to download all of the files using the <kbd>adb pull</kbd> command because of inherent security features enforced by the operating system. For example, files present in the <kbd>/data/data</kbd> folder cannot be accessed in this manner on an Android device that is not rooted. More details about this topic have been covered in <a href="b5ab11df-1911-4deb-accd-f92c74650e6d.xhtml" target="_blank">Chapter 4</a>, <em>Extracting Data Logically from Android Device</em>.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Pushing data to the device</h1>
                
            
            
                
<p>You can use the <kbd>adb push</kbd> command to copy files from the local workstation to the Android device. The following is the syntax for using this command:</p>
<pre><strong>adb push &lt;local&gt; &lt;remote&gt;</strong></pre>
<p><kbd>&lt;local&gt;</kbd> refers to the location of the file on the local workstation and <kbd>&lt;remote&gt;</kbd> refers to the path on the Android device where the file needs to be stored. For instance, the following command-line output shows <kbd>filetest.pngcopied</kbd> from the computer to the <kbd>Pictures</kbd> folder of an Android device:</p>
<pre><strong>adb push C:\temp\test.png /sdcard/Pictures</strong><br/><strong>[100%] /sdcard/Pictures/test.png</strong></pre>
<p>You can only push the files to those folders for which the user account has privileges.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Restarting the ADB server</h1>
                
            
            
                
<p>In some cases, you might need to terminate the ADB server process and then restart it. For example, if <kbd>adb</kbd> does not respond to a command, you can terminate the server and restart it and that may resolve the problem.</p>
<p>To stop the ADB server, use the <kbd>kill-server</kbd> command. You can then restart the server by issuing any other <kbd>adb</kbd> command.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Recovery and fastboot</h1>
                
            
            
                
<p>Before dealing with the process of rooting, it is necessary to understand about boot loader, recovery, and fastboot modes in Android. The following sections explain these in detail.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Recovery mode</h1>
                
            
            
                
<p>An Android phone can be seen as a device having three main partitions: boot loader, Android ROM, and recovery. <em>Boot loader</em> is present in the first partition and is the first program that runs when the phone is powered on. The primary job of this boot loader is to take care of low-level hardware initialization and to boot into other partitions. It usually loads the Android partition, commonly referred to as <strong>Android ROM</strong>, by default. Android ROM contains all of the operating system files that are necessary to run the device. The <em>recovery</em> partition, commonly referred to as stock recovery, is the one that is used to delete all user data and files, or to perform system updates.</p>
<p>Both of these operations can be started from the running Android system or by manually booting into the recovery mode. For example, when you do a factory reset on your phone, recovery is what boots up and erases the files and data. Likewise, with updates, the phone boots into recovery mode to install the latest updates that are written directly to the Android ROM partition. Hence, recovery mode is the screen that you see when you install any official update on the device.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Accessing recovery mode</h1>
                
            
            
                
<p>The recovery image is stored on the recovery partition and consists of a Linux image with a simple user interface controlled by hardware buttons. Recovery mode can be accessed in two ways:</p>
<ul>
<li>By pressing a certain keypress combination when booting the device (usually by holding the Volume+, Volume-, and Power buttons during the boot up)</li>
<li>By issuing the <kbd>adb reboot recovery</kbd> command to a booted Android system</li>
</ul>
<p>The following is a screenshot of a stock recovery mode on an Android device:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-553 image-border" src="img/909305b1-5cc8-4650-ad92-29fe7415c076.jpg" style="width:22.17em;height:16.33em;" width="398" height="293"/></p>
<p>Android stock recovery</p>
<p>The stock Android recovery is intentionally very limited in functionality. It has the options to reboot the system, apply updates from ADB and SD card, factory reset, and so on. However, custom recovery offers many more options.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Custom recovery</h1>
                
            
            
                
<p>A custom recovery is a recovery environment created by a third party. It can be used to replace the default, stock recovery environment with a customized recovery environment on the target device. Here is a list of the most common features that can be found in custom recovery:</p>
<ul>
<li>It provides full backup and restores functionality (such as NANDroid).</li>
<li>It allow unsigned update packages or allows signed packages with custom keys.</li>
<li>It selectively mounts device partitions and SD card.</li>
<li>It provides USB mass storage access to SD card or data partitions.</li>
<li>It provides full ADB access, with the ADB daemon running as root.</li>
<li>There's a fully featured BusyBox binary. BusyBox is a collection of powerful command line tools in a single binary executable.</li>
</ul>
<p>There are several custom recovery images available in the market today, such as ClockworkMod recovery, TeamWin Recovery Project, and so on. The following screenshot shows the options available with <strong>TeamWin Recovery Project (TWRP) 3.0.0.0</strong>:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-554 image-border" src="img/02a83390-48e6-468d-baf9-d696c56bb2ba.png" style="width:20.50em;height:31.75em;" width="341" height="527"/></p>
<p>TWRP recovery</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Viewing log data</h1>
                
            
            
                
<p>In Android, the <kbd>logcat</kbd> command provides a way to view system debug output. Logs from various applications and portions of the system are collected in a series of circular buffers, which can then be viewed and filtered by using this command:</p>
<pre><strong>adb.exe logcat</strong><br/><strong>--------- beginning of system</strong><br/><strong> 09-17 10:04:52.463 2477 2477 I vold : Vold 3.0 (the awakening) firing up</strong><br/><strong> 09-17 10:04:52.463 2477 2477 V vold : Detected support for: exfat ext4 f2fs ntfs vfat</strong><br/><strong> 09-17 10:04:52.475 2477 2482 D vold : e4crypt_init_user0</strong><br/><strong> 09-17 10:04:52.475 2477 2482 D vold : e4crypt_prepare_user_storage for volume null, user 0, serial 0, flags 1</strong><br/><strong> 09-17 10:04:52.475 2477 2482 D vold : Preparing: /data/system/users/0</strong><br/><strong> 09-17 10:04:52.476 2477 2482 D vold : Preparing: /data/misc/profiles/cur/0</strong><br/><strong> 09-17 10:04:52.476 2477 2482 D vold : Preparing: /data/system_de/0</strong><br/><strong> 09-17 10:04:52.477 2477 2482 D vold : Preparing: /data/misc_de/0</strong><br/><strong> 09-17 10:04:52.477 2477 2482 D vold : Preparing: /data/user_de/0</strong><br/><strong> 09-17 10:04:52.477 2477 2482 D vold : e4crypt_unlock_user_key 0 serial=0 token_present=0</strong><br/><strong> 09-17 10:04:52.712 2477 2480 D vold : Disk at 7:64 changed</strong><br/><strong> 09-17 10:04:52.933 2590 2590 I android.hardware.wifi@1.0-service: Wifi Hal is booting up...</strong><br/><strong> 09-17 10:04:53.023 2619 2619 I installd: installd firing up</strong><br/><strong> 09-17 10:04:53.166 2627 2627 I wificond: wificond is starting up...</strong><br/><strong> 09-17 10:04:53.285 2626 2666 I /system/bin/storaged: storaged: Start</strong><br/><strong> 09-17 10:04:55.120 2760 2760 I SystemServer: InitBeforeStartServices</strong><br/><strong> 09-17 10:04:55.122 2760 2760 I SystemServer: Entered the Android system server!</strong><br/><strong> 09-17 10:04:55.358 2760 2760 I SystemServer: StartServices</strong><br/><strong> 09-17 10:04:55.358 2760 2760 I SystemServer: Reading configuration...</strong><br/><strong> 09-17 10:04:55.358 2760 2760 I SystemServer: ReadingSystemConfig</strong><br/><strong> 09-17 10:04:55.359 2760 2760 I SystemServer: StartInstaller</strong><br/><strong> 09-17 10:04:55.360 2760 2760 I SystemServiceManager: Starting com.android.server.pm.Installer</strong><br/><strong> 09-17 10:04:55.362 2760 2760 I SystemServer: DeviceIdentifiersPolicyService</strong><br/><strong> 09-17 10:04:55.362 2760 2760 I SystemServiceManager: Starting com.android.server.os.DeviceIdentifiersPolicyService</strong><br/><strong> 09-17 10:04:55.363 2760 2760 I SystemServer: StartActivityManager</strong><br/><strong> 09-17 10:04:55.363 2760 2760 I SystemServiceManager: Starting com.android.server.am.ActivityManagerService$Lifecycle</strong><br/><strong> 09-17 10:04:55.382 2760 2760 I ActivityManager: Memory class: 192</strong><br/><strong> 09-17 10:04:55.406 2760 2760 D BatteryStatsImpl: Reading daily items from /data/system/batterystats-daily.xml</strong><br/><strong> 09-17 10:04:55.421 2760 2777 E BatteryExternalStatsWorker: no controller energy info supplied for telephony</strong><br/><strong>...</strong></pre>
<p>The log message shown here is just a sample message and, during investigation, logs need to be carefully analyzed to gather information on location details, data/time information, application details, and so on. Each log begins with a message type indicator as described in the following table:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td>
<p><strong>Message type</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p>V</p>
</td>
<td>
<p>Verbose</p>
</td>
</tr>
<tr>
<td>
<p>D</p>
</td>
<td>
<p>Debug</p>
</td>
</tr>
<tr>
<td>
<p>I</p>
</td>
<td>
<p>Information</p>
</td>
</tr>
<tr>
<td>
<p>W</p>
</td>
<td>
<p>Warning</p>
</td>
</tr>
<tr>
<td>
<p>E</p>
</td>
<td>
<p>Error</p>
</td>
</tr>
<tr>
<td>
<p>F</p>
</td>
<td>
<p>Fatal</p>
</td>
</tr>
<tr>
<td>
<p>S</p>
</td>
<td>
<p>Silent</p>
</td>
</tr>
</tbody>
</table>
<p> </p>


            

            
        
    </div>



  
<div><h1 class="header-title">Rooting Android</h1>
                
            
            
                
<p>Rooting is a word that is very often heard with respect to Android devices. As a forensic examiner, it is essential to understand this in detail. This would help you to gain knowledge that is required to understand the internals of the device and gain expertise on several issues that are encountered during an investigation. Rooting Android phones has become a common phenomenon and very often rooted phones are encountered during investigations. Also, depending upon the situation and data to be extracted, the examiner themself has to root the device in order to extract certain data. The following sections cover rooting an Android device and other related concepts in detail.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">What is rooting?</h1>
                
            
            
                
<p>To understand rooting, it is essential to understand how Unix-like systems work. The original Unix operating system, on which Linux and other Unix-like systems are based, was designed from the very beginning as a multiuser system. This is primarily because personal computers did not yet exist and hence it was necessary to have a mechanism for separating and protecting the resources of the individual users while allowing them to use the system simultaneously. But in order to perform privileged tasks such as granting and revoking powers for ordinary users and accessing critical system files to repair or upgrade the system, it was necessary to have a system administrator account that has superuser access. So, we have two types of accounts: normal user accounts that have fewer privileges and a superuser or <strong>root account</strong> that has all of the privileges.</p>
<p>Hence, <em>root</em> is the username or account that by default has access to all commands and files on a Linux or other Unix-like operating system. It is also referred to as the root account, root user, and the superuser. So, in Linux, the root user has the power to start/stop any system service, edit/delete any file, change the privileges of other users, and so on. We have learned earlier that Android uses the Linux kernel and hence most of the concepts present in Linux are applicable to Android as well. However, when you buy an Android phone, normally it does not let you log in as a root user. Rooting an Android phone is all about gaining this root access on the device to perform actions that are not normally allowed on the device.</p>
<p>It is also important to understand the difference between <em>rooting</em> and <em>jailbreaking,</em> as both are often wrongly assumed to be the same. Jailbreaking a device running an Apple iOS operating system allows you to remove certain restrictions and limitations put in place by Apple. For instance, Apple does not allow sideloading unsigned applications on the device. So, by jailbreaking, you can install applications that are not approved by Apple. In contrast, Android by functionality allows sideloading of applications. Jailbreaking a phone involves bypassing several security restrictions simultaneously. Hence, gaining root access on the device is only one of the aspects of jailbreaking a device.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Why root?</h1>
                
            
            
                
<p>Rooting is often performed by many people with the goal of overcoming limitations that carriers and hardware manufacturers put on Android devices. By rooting an Android device you can alter or replace system applications and settings, run specialized apps that require administrator-level permissions, or perform operations that are otherwise inaccessible to a normal Android user, such as uninstalling the default apps (especially the bloatware) that come along with the phone. Rooting is also done for extreme customization; for instance, new, customized ROMs could be downloaded and installed. However, from a forensic analysis point of view, the main reason for rooting is to gain access to those parts of the system that are normally not accessible. Most of the public root tools will result in a permanent root where the changes persist even after rebooting the device. In the temporary root, the changes are lost once the device reboots. Temporary roots should always be preferred in forensic cases.</p>
<p>As explained in <a href="1e7a3a23-96c6-4085-9981-44b579bb2a7f.xhtml" target="_blank">Chapter 1</a>, <em>Introducing Android Forensics</em>, in Linux systems, each user is assigned a unique <strong>User ID</strong> (<strong>UID</strong>) and users are segregated so that one user does not access the data of another user. Similarly, in Android each application is assigned a UID and is run as a separate process. App UIDs are usually assigned in the order that they are installed, starting from 10001. These IDs are stored in the <kbd>packages.xml</kbd> file in <kbd>/data/system</kbd>. This file, in addition to storing UIDs, stores the Android permissions of each program as described in its manifest file. The private data of each application is stored in the <kbd>/data/data</kbd> location and is accessible only to that application. Hence, during the course of an investigation, data present under this location cannot be accessed. But rooting a phone would allow you to access the data present in any location. It is important to keep in mind that rooting a phone has several implications, as described in the following:</p>
<ul>
<li><strong>Security risk</strong>: Rooting a phone might expose the device to security risks. For instance, imagine a malicious app that has access to the entire operating system and to the data of all of the other apps installed on the device.</li>
<li><strong>Bricking of your device</strong>: If rooting is not done in the proper manner it might result in bricking your device. Bricking is a word commonly used with those phones that are dead or cannot be turned on in any way.</li>
<li><strong>Voiding your warranty</strong>: Depending on the manufacturer and carrier, rooting a device may void your warranty since it exposes the device to several threats.</li>
<li><strong>Forensic implications</strong>: Rooting an Android device will allow an investigator to access a larger set of data, but it involves the alteration of certain portions of the device. Hence, a device should be rooted only when it is absolutely necessary.</li>
</ul>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    </div>



  
<div><h1 class="header-title">Fastboot mode</h1>
                
            
            
                
<p>Fastboot is a protocol that can be used to re-flash partitions on your device. It is one of the tools that comes along with the Android SDK and is an alternative to the recovery mode for doing installations and updates and for unlocking the boot loader in some cases. While in fastboot, you can modify the filesystem images from a computer over a USB connection. Hence, it is one of the ways to install the recovery images and to just boot in some cases. Once the phone is booted into fastboot, you can flash image files to the internal memory. For example, the previously discussed custom recovery images such as TWRP recovery can be flashed in this manner. </p>
<p>All you need is to type a few commands. First, reboot the device into bootloader/fastboot mode:</p>
<pre><strong>adb reboot bootloader</strong></pre>
<p>Then, flash TWRP using the following command:</p>
<pre><strong>fastboot flash recovery twrp.img</strong></pre>
<p>Now you can reboot the device using the following command:</p>
<pre><strong>fastboot reboot</strong></pre>
<p>Before flashing TWRP, make sure you've read the thread about target devices at the XDA Developers forum (<a href="https://forum.xda-developers.com/">https://forum.xda-developers.com/</a>).</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Locked and unlocked boot loaders</h1>
                
            
            
                
<p>Boot loaders may be locked or unlocked. Locked boot loaders don't allow you to perform modifications to the device's firmware by implementing restrictions at the boot loader level, usually done through cryptographic signature verification. Hence, unsigned code cannot be flashed to the device. In other words, in order to run any recovery image or your own operating system, the boot loader needs to be unlocked first. Unlocking the boot loader could result in serious security implications. If the device is lost or stolen, all data on it can be recovered by an attacker simply by uploading a custom Android boot image or flashing a custom recovery image. After doing so, the attacker has full access to the data contained on the device. Because of this reason, a factory data reset is performed on the phone when unlocking a locked boot loader so that all of the data is erased. Hence, it is important to perform this only when it is absolutely necessary. Some devices have ways to unlock them officially. For these devices, the boot loader can be unlocked by putting the device into fastboot mode and running the <kbd>fastboot oem unlock</kbd> command. This will unlock the boot loader and do a complete wipe of the Android device.</p>
<p>Some other manufacturers provide unlocking through different means, for instance, through their website. The following screenshot shows the Xiaomi website providing support for unlocking Xiaomi devices:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-555 image-border" src="img/c964fdcb-4938-44cc-a751-6c09d35980c6.png" style="width:42.08em;height:26.08em;" width="912" height="566"/></p>
<p>Xiaomi website providing support to unlock boot loader</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How to root</h1>
                
            
            
                
<p>This section is based on whether the underlying boot loader is locked or unlocked. Gaining root access on a device with an unlocked boot loader is very easy, while gaining root access on a device with a locked boot loader is not so straightforward. The following sections explain this in detail.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Rooting an unlocked boot loader</h1>
                
            
            
                
<p>In Unix-like systems, the superuser is a special user account used for system administration and has privileges to access and modify all of the files in an operating system. The process of rooting mainly involves copying the <kbd>su</kbd> (superuser) binary to a location in the current process's path (<kbd>/system/xbin/su</kbd>) and granting it executable permissions with the <kbd>chmod</kbd> command. Hence, the first step here is to unlock the boot loader. As explained in the <em>Locked and unlocked boot loaders </em>section, depending on the device in question, unlocking a boot loader can be done either through fastboot mode or through following a vendor specific boot loader unlock procedure.</p>
<p class="mce-root"/>
<p>The <kbd>su</kbd> binary is usually accompanied by an Android application, such as SuperUser, that provides a graphical prompt each time an application requests root access, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-874 image-border" src="img/a3a6451e-e09a-42fc-8bc5-60b70f92c904.png" style="width:18.75em;height:21.75em;" width="541" height="419"/></p>
<p>Superuser request</p>
<p>Once the boot loader is unlocked, you can make all of the desired changes to the device. Hence, copying the <kbd>su</kbd> binary and granting it executable permissions can be done in many ways. The most common method is to boot a custom recovery image. This allows copying the <kbd>su</kbd> binary into the system partition and setting the appropriate permissions through a custom update package.</p>
<p class="mce-root">Here is how to root a Samsung Galaxy S7 (International SM-G930F/FD/X, Korean SM-G930K/L/S, and Canadian SM-G930W8 Exynos models):</p>
<ol>
<li>Make sure <strong>OEM unlock</strong> is enabled in Developer options.</li>
<li>Download ODIN (available here: <a href="https://build.nethunter.com/samsung-tools/Odin_3.12.3.zip">https://build.nethunter.com/samsung-tools/Odin_3.12.3.zip</a>) and extract the contents of the archive in the directory of your choice.</li>
<li>Download the TWRP image (available here: <a href="http://teamw.in/devices/samsunggalaxys7.html">http://teamw.in/devices/samsunggalaxys7.html</a>).</li>
<li>Reboot your device into Download mode. To do this, hold the [Volume Down] + [Home] buttons while your device reboots. Once you see the Download mode warning screen, press [Volume Up] to continue.</li>
</ol>
<ol start="5">
<li>Start Odin and put the TWRP image in the [AP] slot; don't forget to disable <strong>Auto-Reboot</strong>. Start flashing the recovery.</li>
<li>To exit Download mode, hold [Volume Down] + [Home] + [Power]; when the screen blanks, immediately change [Volume Down] to [Volume Up].</li>
<li>Allow system modifications by swiping right.</li>
<li>Download <strong>SuperSU</strong> (available here: <a href="https://download.chainfire.eu/supersu">https://download.chainfire.eu/supersu</a>).</li>
<li>Transfer the archive with SuperSU to the device via MTP, and install it via the corresponding TWRP option.</li>
</ol>
<div><p>Since Android version 4.1, a new feature called sideload mode has been introduced. This feature allows applying an update ZIP over ADB without copying it to the device beforehand. To sideload an update, run the <kbd>adb sideload su-package.zip</kbd> command, where <kbd>su-package.zip</kbd> is the filename of the update package on your computer.</p>
</div>
<p>Alternately, you can also modify a factory image to add an <kbd>su</kbd> binary. This can be done by unpacking an ext4 formatted system image, adding a <kbd>su</kbd> binary and repacking it. If this image is flashed, it will contain the <kbd>su</kbd> binary and the device will be rooted.</p>
<div><p>Rooting is a highly device-specific process and hence forensic investigator needs to be cautious before applying these techniques on any Android device.</p>
</div>


            

            
        
    </div>



  
<div><h1 class="header-title">Rooting a locked boot loader</h1>
                
            
            
                
<p>When the boot loader is locked and cannot be unlocked through any available means, rooting the device requires finding a security flaw that can be exploited. But before that, it is important to identify the type of boot loader lock. It can vary depending on the manufacturer and software version. With some mobiles, fastboot access may not be allowed, but you can still flash using the manufacturer's proprietary flashing protocol, such as Samsung ODIN. Some devices enforce signature verification on selected partitions only, such as boot and recovery. Hence, it may not be possible to boot into custom recovery. However, you can still modify the factory image to include <kbd>su</kbd> binary, as explained in the previous section.</p>
<p>If the boot loader cannot be unlocked through any means, then the only option is to find some vulnerability on the device that allows us to exploit and add <kbd>su</kbd> binary. The vulnerability can be in the Android kernel or in a process running as root or any other issue. It is device-specific and needs to be researched extensively before trying it on any device.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The following are the most popular applications for Android rooting:</p>
<ul>
<li>Kingo (<a href="https://www.kingoapp.com/">https://www.kingoapp.com/</a>)</li>
<li>Root Genius (<a href="http://www.shuame.com/en/root/">http://www.shuame.com/en/root/</a>)</li>
<li>iRoot (<a href="http://www.iroot.com/">http://www.iroot.com/</a>)</li>
</ul>


            

            
        
    </div>



  
<div><h1 class="header-title">ADB on a rooted device</h1>
                
            
            
                
<p>We have already seen how the ADB tool can be used to interact with the device and execute certain commands on the device. However, on a normal Android phone, certain locations such as <kbd>/data/data</kbd> cannot be accessed. For example, the following shows the command-line output when trying to access <kbd>/data/data</kbd> on a normal device:</p>
<pre><strong>adb shell</strong><br/><strong>shell@android:/ $ cd /data/data</strong><br/><strong>cd /data/data</strong><br/><strong>shell@android:/data/data $ ls</strong><br/><strong>ls: .: Permission denied</strong></pre>
<p>This is because the private data of all of the applications is stored in this folder and so the security is enforced by the Android. Only the root user has access to this location. Hence, on a rooted device, you will be able to see all of the data under this location, as shown in the following command lines:</p>
<pre><strong>adb shell</strong><br/><strong>shell@android:/ $ su</strong><br/><strong>shell@android:/ # ls /data/data</strong><br/><strong>android</strong><br/><strong> com.android.backupconfirm</strong><br/><strong> com.android.bips</strong><br/><strong> com.android.bluetooth</strong><br/><strong> com.android.bluetoothmidiservice</strong><br/><strong> com.android.calllogbackup</strong><br/><strong> com.android.camera2</strong><br/><strong> com.android.captiveportallogin</strong><br/><strong> com.android.carrierconfig</strong><br/><strong> com.android.carrierdefaultapp</strong><br/><strong> com.android.cellbroadcastreceiver</strong><br/><strong> com.android.certinstaller</strong><br/><strong> com.android.companiondevicemanager</strong><br/><strong> com.android.contacts</strong><br/><strong> com.android.cts.ctsshim</strong><br/><strong> com.android.cts.priv.ctsshim</strong><br/><strong> com.android.defcontainer</strong><br/><strong> com.android.development</strong><br/><strong> com.android.dialer</strong><br/><strong> com.android.documentsui</strong><br/><strong> com.android.dreams.basic</strong><br/><strong> com.android.dreams.phototable</strong><br/><strong> com.android.egg</strong><br/><strong> com.android.email</strong><br/><strong> com.android.emergency</strong><br/><strong> com.android.externalstorage</strong><br/><strong> com.android.facelock</strong><br/><strong> com.android.gallery3d</strong><br/><strong>...</strong></pre>
<p>As shown in the previous code, all of the application's private data can now be seen easily by navigating to the respective folders. Hence, the ADB tool on a rooted device is very powerful and allows an examiner to access all of the data of applications installed on the device, provided the device is not pattern or PIN protected or registered to the machine with an RSA key.</p>
<div><p>Sometimes, even on a rooted phone, you would see the permission denied message. In such cases, after executing the <kbd>adb shell</kbd> command, try entering SuperUser mode by typing <kbd>su</kbd>. If root is enabled, you will see <kbd>#</kbd> without asking for the password.</p>
</div>


            

            
        
    </div>



  
<div><h1 class="header-title">Summary</h1>
                
            
            
                
<p>Setting up a proper forensic environment is crucial prior to conducting investigation on an Android device. The Android SDK installation is necessary to use tools such as ADB, which come along with it. Using ADB, an examiner can communicate with the device, view folders on the device, pull data, and copy data to the device. However, not all folders can be accessed on a normal phone in this manner, since the device's security enforcements prevent an examiner from viewing locations that contain private data. Hence, rooting a device solves this issue, as it provides unlimited access to all the data present on the device. Rooting a device with an unlocked boot loader is straightforward, while rooting a device with a locked boot loader involves exploiting some security bugs.</p>
<p>With this knowledge on accessing the device, we will now cover how data is organized on an Android device and many other details in <a href="615ae74c-4301-46e6-92f2-387637bebd38.xhtml" target="_blank">Chapter 3</a>, <em>Understanding Data Storage on Android Devices.</em></p>


            

            
        
    </div>



  </body></html>