- en: Static and Dynamic Reversing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like a patient in a hospital, a file needs to undergo some triage to determine
    the right allocation of resources. The result of the file assessment will tell
    us what tools need to be used, what kind of reversing steps need to be taken,
    and what resources will be used. The steps involved in carrying out reversing
    are categorized into static and dynamic analysis.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will introduce the methods and tools used in assessing a
    file. We will be focusing on a 32-bit Windows operating system for our examples.
    This will be followed by an examination of tools we can use for static and dynamic
    analysis. This chapter can help you to generate a checklist that will serve as
    a guide for you to retrieve all information on a file in the least amount of time.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Gain an understanding of Target assessment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Perform static analysis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Perform dynamic analysis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assessment and static analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A file needs to undergo an initial assessment in order for us to determine
    what tools and analysis methods will be required. This process also helps us to
    create a strategy for analyzing the file. Doing such an assessment requires carrying
    out a light static analysis. Here are some ideas for assessment that may serve
    as our guide:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Where did it originate from:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One of the purposes of reverse engineering is to help network administrators
    prevent similar malware from infiltrating the network. Knowing where a file came
    from would be helpful in securing the channel used to transmit it. For example,
    if the file being analyzed was determined to have been an email attachment, network
    administrators should secure the email server.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Existing information:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Searching the internet for already existing information can be very helpful.
    There might be existing analyses that has been done on the file. We would be able
    to determine what behaviors to expect, which will help hasten the analysis.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Viewing the file and extracting its text strings:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using tools to view the file help us to determine the type of file. Extracting
    readable text from the file also gives us hints of what messages, functions, and
    modules it will use when opened or executed.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'File information:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the file type?
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Header and type analysis
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Static analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Static analysis will help us make notes of what we will do during dynamic analysis.
    With knowledge of the `x86` assembly language, we should be able to understand
    a disassembled `Win32 PE` file and its branches. Doing so, we would be able to
    prepare the right tools to read, open, and debug the file based on its file type,
    and also understand the file's structure based on its file format.
  prefs: []
  type: TYPE_NORMAL
- en: We begin static analysis by determining the file type, then move on to understanding
    the file format. We can extract text strings that might help us instantly identify
    useful information, such as the API function used, which library modules it will
    use, what high level language the file was compiled from, registry keys it will
    try to access, and websites or IP addresses it might try to connect to.
  prefs: []
  type: TYPE_NORMAL
- en: File types and header analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The type of file is the most important piece of information that sets off the
    whole analysis. If the file type is a Windows executable, a preset of `PE` tools
    will be prepared. If the file type is a Word document, the sandbox environment
    we are going to use will have to be installed with Microsoft Office and analysis
    tools that can read the `OLE` file format. If the given target for analysis is
    a website, we may need to prepare browser tools that can read HTML and debug Java
    scripts or Visual Basic scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Extracting useful information from file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It would be fun to manually parse each piece of information about a file using
    file viewing tools, such as HxD ([https://mh-nexus.de/en/hxd/](https://mh-nexus.de/en/hxd/)).
    But, since searching for documentation about the file would take some time, there
    are existing tools that were developed for reverse engineers. These tools, readily
    available on the internet, can easily extract and display file information, and
    have features that can identify what type of file it is. This extracted information
    helps us determine what type of file we are dealing with.
  prefs: []
  type: TYPE_NORMAL
- en: PEid and TrID
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PEid and TrID are the tools that are able to detect the type of file, the compiler
    used, the encrypting tool, and the packer and protector used. Compressed executables
    are better known as packers. Some examples of these packers are UPX, PECompact,
    and Aspack. Protectors, on the other hand, are somewhat like packers, but rather
    more advanced in the sense that the original compiled code would be protected
    from being reversed easily. Examples of protectors include Themida, AsProtect,
    and Enigma Protector.
  prefs: []
  type: TYPE_NORMAL
- en: 'Protector software is usually commercial software. Neither tool is updated
    anymore but both still work very well. Here''s a screenshot of PEiD''s main interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/aa2462af-d655-4c28-9973-20df5425d1e0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here''s a screenshot of how `TrID` can be used in a Linux Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4d832653-cf9c-485e-884f-ed62c20c50d4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'At the time of writing, these tools could be downloaded at the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: PEid is available from [http://www.softpedia.com/get/Programming/Packers-Crypters-Protectors/PEiD-updated.shtml](http://www.softpedia.com/get/Programming/Packers-Crypters-Protectors/PEiD-updated.shtml).
    [](http://www.softpedia.com/get/Programming/Packers-Crypters-Protectors/PEiD-updated.shtml)
    TriD is available at [http://mark0.net/soft-trid-e.html](http://mark0.net/soft-trid-e.html).
  prefs: []
  type: TYPE_NORMAL
- en: python-magic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is a Python module that is able to detect the file type. However, unlike
    PEiD and TrID, it also detects compilers and packers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/474f937f-639c-42b2-8565-c5b10878e1da.png)'
  prefs: []
  type: TYPE_IMG
- en: It can be downloaded at [https://pypi.org/project/python-magic/](https://pypi.org/project/python-magic/).
  prefs: []
  type: TYPE_NORMAL
- en: file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Linux has a built-in command known as **file**. **file** is based on the `libmagic`
    library, and is able to determine file types of various file formats:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8386d977-f4fa-40d7-a5b1-c960bc37b0fd.png)'
  prefs: []
  type: TYPE_IMG
- en: MASTIFF
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MASTIFF is an static analyzer framework. It works on Linux and Mac. As a framework,
    the static analysis is based on plugins from the MASTIFF author and from the community.
  prefs: []
  type: TYPE_NORMAL
- en: 'These plugins include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**trid** : This is used for identifying file types.'
  prefs: []
  type: TYPE_NORMAL
- en: '**ssdeep** : `ssdeep` is a fuzzy hash calculator. A fuzzy hash, or context
    triggered piecewise hashes (`CTPH`), can be used to identify nearly identical
    files. This is useful for identifying variants of a malware family.'
  prefs: []
  type: TYPE_NORMAL
- en: '**pdftools** : A plugin by Didier Stevens. This extracts information about
    PDF files.'
  prefs: []
  type: TYPE_NORMAL
- en: '**exiftool** : This shows info, from image files.'
  prefs: []
  type: TYPE_NORMAL
- en: '**pefile** : This shows information about PE files.'
  prefs: []
  type: TYPE_NORMAL
- en: '**disitool** : This is another Python script from Didier Stevens. This is used
    to extract digital signatures from signed executables.'
  prefs: []
  type: TYPE_NORMAL
- en: '**pyOLEscanner** : This is a tool used to extract information from OLE file
    types, such as Word documents and Excel spreadsheets.'
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of MASTIFF at work can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6516bd44-c318-439c-b3a9-76a0f2082b52.png)'
  prefs: []
  type: TYPE_IMG
- en: MASTIFF can be downloaded from [https://github.com/KoreLogicSecurity/mastiff](https://github.com/KoreLogicSecurity/mastiff).
  prefs: []
  type: TYPE_NORMAL
- en: Other information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As part of static information gathering, a file is given its own unique hash.
    These hashes are used to identify a file from a database of file information.
    Hash information generally helps analysts share information about the file, without
    transmitting the file itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of MASTIFF''s `file_info` result on a test file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f8f0d228-9306-49fe-b424-b70d53d1d97d.png)'
  prefs: []
  type: TYPE_IMG
- en: PE executables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PE executables are programs that work on Windows. Executable files have the
    `.exe` extension. Dynamic link libraries uses the same PE file format and use
    the `.dll` file extension. Windows device driver programs, also in PE file format,
    use the `.sys` extension. There are also other extensions that use the PE file
    format, such as screensavers (`.scr`).
  prefs: []
  type: TYPE_NORMAL
- en: 'The PE file format has a header, which is divided into the MZ header, along
    with its DOS stub and the PE header, followed by the data directories and section
    tables, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00d2f852-d39c-4aa4-b0fd-7d4b43e2c34a.png)'
  prefs: []
  type: TYPE_IMG
- en: The file format follows the original `MSDOS EXE` format, but was extended for
    Windows using the PE header. If a Windows program were run in an MSDOS environment,
    it would display this message: `This program cannot be run in DOS mode.`
  prefs: []
  type: TYPE_NORMAL
- en: The code that displays this message is part of the DOS stub.
  prefs: []
  type: TYPE_NORMAL
- en: The PE header's section table contains all the information about where code
    and data are located in the file, and how it will be mapped into the memory when
    it gets loaded as a process. The PE header contains the address where the program
    begins to execute code—a location known as the entry point—and will be set in
    the EIP register.
  prefs: []
  type: TYPE_NORMAL
- en: 'The data directories contain addresses of tables that, in turn, contain information
    such as the import table. The import table contains the libraries and APIs that
    will be used by the program. The table follows a structure that points to a set
    of addresses, pointing, in turn, to the names of libraries and their respective
    export functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1836364c-bd2e-4019-b0eb-b4d51b551935.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `peinfo` module used in `MASTIFF` is able to display the imported libraries
    and functions, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fcd61863-d72d-48d5-8a49-d4329ba8f724.png)'
  prefs: []
  type: TYPE_IMG
- en: '`HxD` and `HIEW` are popular binary editors used in this chapter; `HxD`, being
    the more popular, is free, and can easily be used to make binary edits to a file.
    More information and a download link can be found at [https://mh-nexus.de/en/hxd/](https://mh-nexus.de/en/hxd/).
    If you try using `HxD`, you''ll see something similar to this screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c242bbb6-783e-43a1-9ea4-b928a97d1e1d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Another useful hex-editing tool is `HIEW` (Hacker''s View). The demo and free
    versions are able to parse through a `PE` header. This tool can also show exports
    and imported API functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a0506bee-48e2-45d9-a01b-459883d30afe.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The statically imported modules, libraries, and functions are hints on what
    we can expect the program to access. Consider, for example, that if the `PE` file
    imports the `KERNEL32.DLL` library, then we should expect the file to contain
    core APIs that may access files, processes, and threads, or dynamically load other
    libraries and import functions. Here are some of the more common libraries that
    we should take note of:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ADVAPI32.DLL` : This library contains functions that will access the registry.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MSVCRXX.DLL`  (where XX is a version number. Examples are the libraries `MSVCRT.DLL`
    and `MSVCR80.DLL`) – This contains Microsoft Visual C runtime functions. This
    tells us straight away that the program was compiled using Visual C.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WININET.DLL` : This library contains functions that accesses the internet.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`USER32.DLL` : This contains window-control functions related to anything displayed
    on the monitor, such as dialog boxes, showing message boxes, and positioning window
    boxes where they should be.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NTDLL.DLL` : This library contains native functions that directly interact
    with the kernel system. `KERNEL32.DLL` and libraries like `USER32.DLL`, `WININET.DLL`,
    and `ADVAPI32.DLL`  have functions that are used to forward information to the
    native functions to perform actual system-level operations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deadlisting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Deadlisting is an analysis method where we get to analyze a file's disassembled
    or decompiled code, and map out the flow of events that will happen when it executes.
    The resulting illustrated flow will serve as a guide for dynamic analysis.
  prefs: []
  type: TYPE_NORMAL
- en: IDA (Interactive Disassembler)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We previously introduced the IDA tool to show the disassembly of a given file.
    It has a graph-view feature that shows an overview of blocks of code and the branching
    of conditional flow. In deadlisting, we try to describe each block of code and
    what possible results it will give. This gives us an idea of what the program
    does.
  prefs: []
  type: TYPE_NORMAL
- en: Decompilers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some high-level programs are compiled using p-code, such as C# and Visual Basic
    (p-code version). On the contrary, a decompiler attempts to recreate the high-level
    source code based on the p-code. A high-level syntax usually has an equivalent
    block of p-code that can by identified by the decompiler.
  prefs: []
  type: TYPE_NORMAL
- en: Programs compiled using the C language are laid to a file in plain assembly
    language. But since it is still a high-level language, some blocks of code can
    be identified back to their C syntax. The paid version of IDA Pro has an expensive,
    but very useful plugin, called Hex-Rays, that can identify these blocks of code
    and recreate the C source code.
  prefs: []
  type: TYPE_NORMAL
- en: ILSpy – C# Decompiler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A popular tool used to decompile a C# program is ILSpy. Some decompilers will
    leave the analyst with just the source being statically analyzed as is. But, in
    ILSpy, it is possible to save the decompiled source as a Visual Studio project.
    This enables the analyst to compile and debug it for dynamic analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dynamic analysis is a type of analysis that requires live execution of the code.
    In static analysis, the farthest we can go is with deadlisting. If, for example,
    we encounter a code that decrypts or decompresses to a huge amount of data, and
    if we want to see the contents of the decoded data, then the fastest option would
    be to do dynamic analysis. We can run a debug session and let that area of code
    run for us. Both static analysis and dynamic analysis work hand in hand. Static
    analysis helps us identify points in the code where we need a deeper understanding
    and some actual interaction with the system. By following static analysis with
    dynamic analysis, we can also see actual data, such as file handles, randomly
    generated numbers, network socket and packet data, and API function results.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are existing tools that can carry out an automated analysis, which runs
    the program in a sandbox environment. These tools either log the changes during
    runtime, or in between snapshots:'
  prefs: []
  type: TYPE_NORMAL
- en: Cuckoo (open source) – This tool is deployed locally. It requires a host and
    sandbox client(s). The host serves as a web console to which files are submitted
    for analysis. The files are executed in the sandbox, and all activities are logged
    and then sent back to the host server. The report can be viewed from the web console.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RegShot (free) - This tool is used to take a snapshot of the registry and file
    system before and after running a program. The difference between the snapshots
    enables the analyst to determine what changes happened. The changes may include
    changes made by the operating system, and it is up to the analyst to identify
    which changes were caused by the program.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sandboxie (freemium) - This tool is used in the environment where the program
    will be run. It is claimed that internally, it uses isolation technology. In essence,
    the isolation technology allocates disk space, to which disk writes will only
    happen at the time the program is executed by Sandboxie. This enables Sandboxie
    to determine changes by looking only at the isolated space. A download link and
    some more information about Sandboxie can be found at [https://www.sandboxie.com/HowItWorks](https://www.sandboxie.com/HowItWorks).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Malwr (free) - This is a free online service that uses Cuckoo. Files can be
    submitted at [https://malwr.com/](https://malwr.com/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ThreatAnalyzer (paid) - Originally known as CWSandbox, this is the most popular
    sandboxing technology used in the security industry for automating the extraction
    of information from a piece of running malware. The technology has improved a
    lot, especially with its reporting. In addition, it reports descriptive behaviors
    found, including a cloud query about the submitted file. It can cater to customized
    rules and flexible Python plugins to bring up behaviors seen by the analyst.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Payload Security's Hybrid Analysis (free) - One of the most popular free online
    services, like Malwr, with report contents similar to that of ThreatAnalyzer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Submitting files to online services reduce the need to set up a host-sandbox
    environment. However, some would still prefer to set up their own, to avoid having
    files shared to the community or an online service.
  prefs: []
  type: TYPE_NORMAL
- en: For malware analysis, it is advisable to do automated analysis and network information
    gathering at the time the file was received. Sites from which malware retrieve
    further data might not be available if authorities act fast enough to take such
    sites down.
  prefs: []
  type: TYPE_NORMAL
- en: Memory regions and the mapping of a process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In dynamic analysis, it is important to know what the memory looks like when
    a program gets loaded and then executed.
  prefs: []
  type: TYPE_NORMAL
- en: Since Windows and Linux are capable of multitasking, every process has its own
    **Virtual Address Space (VAS)**. For a 32-bit operating system, the VAS has a
    size of 4 GB. Each VAS is mapped to the physical memory using its respective page
    table and is managed by the operating system's kernel. So how do multiple VASes
    fit in the physical memory? The operating system manages this using paging. The
    paging has a list of used and unused memory, including privilege flags. If the
    physical memory is not enough, then paging can use disk space as an form of extended
    physical memory. A process and its module dependencies don't use up the whole
    4 GB of space, and only these virtually allocated memory segments are listed as
    used in the page tables and mapped in the physical memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'A VAS is divided into two regions: user space and kernel space, with the kernel
    space located in the higher address region. The division of virtual space differs
    between Windows and Linux:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/664a936f-51f3-4213-880c-ffc38bc1db71.png)'
  prefs: []
  type: TYPE_IMG
- en: Every VAS has a kernel space listed in the page tables as a space that has exclusive
    privileges. Generally, these privileges are called kernel mode and user mode.
    These are specifically identified as protection rings. The kernel has a privilege
    of ring 0, while the applications that we use are run on ring 3 privilege. Device
    drivers are in the ring 1 or ring 2 layers, and are also identified as having
    kernel-mode privileges. If user-mode programs try to directly access the kernel
    space in kernel mode, a page fault is triggered.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once a VAS is enabled, the user space is initially allocated for the stack,
    heap, the program, and the dynamic libraries. Further allocations are caused by
    the program at runtime by requesting memory using APIs, such as `malloc` and `VirtualAlloc`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7cc17c91-e137-4106-b08f-5ca519ba4904.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The preceding screenshot is a mapped view when `jbtest.exe` had just been loaded
    in 32-bit Windows. Here is a more descriptive standard layout of a program in
    a virtual allocated space under Windows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/800ba473-2d11-42de-8307-5c592c009d67.png)'
  prefs: []
  type: TYPE_IMG
- en: Process and thread monitoring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Monitoring the processes and threads, especially those that were created by
    the file we are analyzing, tells us that there are more behaviors occurring than
    is obvious. A process can create multiple threads, which tells us that it might
    be doing several behaviors at the same time. A created process tells us that a
    new program was just executed.
  prefs: []
  type: TYPE_NORMAL
- en: In Windows, the termination, creation, and opening of a process can be monitored
    by third-party tools such as Process Monitor. Though there are built-in tools,
    such as Task Manager, that can show information about processes, some third-party
    tools can give more detail about the processes and the threads tied to it.
  prefs: []
  type: TYPE_NORMAL
- en: Network traffic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The communicated data between a server and a client computer can only be seen
    during dynamic analysis. The packet captured during transmission will help the
    analyst understand what the program is sending to a server and how it will respond
    to any such data received.
  prefs: []
  type: TYPE_NORMAL
- en: Popular tools, such as Wireshark and Fiddler, are used to capture packets of
    data and store them as `pcap` files. In Linux, the `tcpdump` tool is commonly
    used to do the same thing.
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring system changes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For Windows, there are three aspects we need to monitor: memory, disk, and
    registry. File monitoring tools look at created, modified, or deleted files and
    directories. On the other hand, registry monitoring tools look at created, updated,
    or deleted registry keys, values, and data. We can use tools such as `FileMon`
    and `RegMon` to do this job.'
  prefs: []
  type: TYPE_NORMAL
- en: Post-execution differences
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Comparing differences between snapshots taken before and after running the executable
    shows all the system changes that happened. For this type of analysis, any events
    that happened in between are not identified. This is useful for finding out how
    a software installer installed a program. And as a result, the difference comes
    in handy, especially when manually uninstalling a piece of software. The tool
    used here is RegShot.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Deadlisting gives us most of the information we need, including the program's
    branching flow. Now, we have an opportunity to validate the path that the program
    will follow when doing debugging. We get to see the data that are temporarily
    stored in the registers and memory. And instead of manually trying to understand
    a decryption code, debugging it would easily show the resulting decrypted data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Tools used for debugging in Windows include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`OllyDebug`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`x86dbg`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IDA Pro`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Tools used for debugging Linux include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`gdb`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`radare2`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Try it yourself
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To try out the tools we have learned about, let''s try doing some static analysis
    on `ch4_2.exe`. To help out, here''s a list of what we need to find:'
  prefs: []
  type: TYPE_NORMAL
- en: 'File information:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: file type
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: imported DLLs and APIs
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: text strings
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: file hash
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: What the file does
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Jumping right into getting file information, we will use TrID ([http://mark0.net/soft-trid-e.html](http://mark0.net/soft-trid-e.html))
    to identify the file type. Execute the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The TrID result tells us that we have here a Windows 32-bit executable file
    that is UPX packed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/449c55a6-ab9c-408d-9d76-3b7762093a72.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Knowing that this is a UPX packed file, we can try the UPX ([https://upx.github.io/](https://upx.github.io/))
    tool''s decompress feature to help us restore the file back to its original form
    before it was packed. A packed file is a compressed executable file that decompresses
    and then executes the program during runtime. The primary purpose of a packed
    file is to reduce the file size of executables while retaining the program''s
    original  behavior. We will be discussing more about packers in [*Chapter 10*](1dd193b9-0d30-425a-b593-f3b6bcce3414.xhtml),
    *Packing and Encryption*, of this book. For now, let''s just unpack this file
    with the UPX tool using the `-d` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This results to the file being expanded back to its original form:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4f903d05-ec27-4bdf-9b12-15b10a665c15.png)'
  prefs: []
  type: TYPE_IMG
- en: 'And if we use `TrID` this time, we should get a different result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/18765e82-1a78-42e9-b239-18a8920c4aa9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'It is still a Windows executable file, so we can use CFF Explorer to check
    for more information:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e2d58160-cafa-4741-bb25-c7a05186361d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'On the left pane, if we select Import Directory, we should see a list of imported
    library files and API functions it will use, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6dba3eaa-2f0c-4272-9f40-4aabf5f35faa.png)'
  prefs: []
  type: TYPE_IMG
- en: Clicking on `USER32.dll`, we see that the `MessageBoxA` API is going to be used
    by the program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the bintext ([http://b2b-download.mcafee.com/products/tools/foundstone/bintext303.zip](http://b2b-download.mcafee.com/products/tools/foundstone/bintext303.zip))
    tool, we can see a list of text strings found in the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/473e0328-74e1-4037-9036-11ca8411be2c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'These appear to be the notable text strings, which suggest that the program
    checks for the time and displays various greetings. It will probably retrieve
    a file from the internet. It may do something about the `File.txt` file. But all
    these are just educated guesses, which makes good practice for reversing, as it
    helps use to build an overview of the relationship between each aspect of our
    analysis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The hash (MD5, SHA1, SHA256) of a file will help as a reference to every file
    we analyze. There are a lot of file hash-generating tools available in the internet.
    To generate the hashes of this file, we chose a tool called HashMyFiles. This
    is a tool compiled for Windows OS and can be added to the context menu (right-click)
    of the Windows Explorer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3ba6a73b-d820-4195-805e-daa71edd8dcb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'It can display the file''s `CRC`, `MD5`, `SHA1`, `SHA-256`, `SHA-512`, and
    `SHA-384`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Usually, we only take either `MD5`, `SHA1`, or `SHA256`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We should not forget the file size and the creation time using a simple file
    property check:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/acf21dd1-2b1d-4a96-a749-223e79541616.png)'
  prefs: []
  type: TYPE_IMG
- en: The Modified date is more relevant in terms of when the file was actually compiled.
    The Created date is when the file was written or copied to the directory where
    it is now. That means that the first time the file was built, both the Created
    and Modified dates were the same.
  prefs: []
  type: TYPE_NORMAL
- en: To statically analyze the file's behavior, we will be using a disassembly tool
    known as IDA Pro. A freeware version of IDA Pro can be found at [https://www.hex-rays.com/products/ida/support/download_freeware.shtml](https://www.hex-rays.com/products/ida/support/download_freeware.shtml).
    But, if you can afford the luxury of its paid version, which we highly recommend,
    please do purchase it. We find the features and supported architectures of the
    paid version way better. But for this book, we will be using every available tool
    that does not require purchasing.
  prefs: []
  type: TYPE_NORMAL
- en: There are currently two known free versions of IDA Pro. We have made backups
    of the tool available at [https://github.com/PacktPublishing/Mastering-Reverse-Engineering/tree/master/tools/Disassembler%20Tools](https://github.com/PacktPublishing/Mastering-Reverse-Engineering/tree/master/tools/Disassembler%20Tools).
    And since we are dealing with a 32-bit Windows executable file, select the 32-bit
    version.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once IDA Pro is installed, open up `cha4_2.exe` inside. Wait for the auto-analysis
    to complete and it will redirct the disassembly to the `WinMain` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fc46e48f-ae83-437a-89db-68b7e6102919.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Scrolling down will show more disassembly code that we learned in [*Chapter
    3*](c296c377-99c9-422d-b021-ce72b3d731dc.xhtml), *The Low-Level Language*. For
    deadlisting behaviors, we usually look for instructions that call APIs. The very
    first API we encounter is a call to `GetSystemTime`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/af6fa114-88dc-46b1-8ce9-fb62405eeba4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Following the code, we encounter these API functions in this sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '`vsprintf_s`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`MessageBoxA`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`InternetOpenA`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`InternetConnectW`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`InternetOpenUrlA`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`memset`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`InternetReadFile`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`InternetCloseHandle`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`strcpy_s`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`CreateFileA`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`WriteFile`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`CloseHandle`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`RegCreateKeyExW`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`RegSetValueExA`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With what we learned in [*Chapter 3*](c296c377-99c9-422d-b021-ce72b3d731dc.xhtml),
    *The Low Level Language*, try to follow the code and deduce what the file will
    do without executing it. To help out, here are the expected behaviors of the program:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Displaying a message depending on the current system time. The messages can
    be one of the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Good Morning`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Good Afternoon`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Good Evening`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`` `Nice Night` ``'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading the contents of a file from the internet, decrypting the contents, and
    saving it to a file named `File.txt`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Making a registry key, `HKEY_CURRENT_USER\Software\Packt`, and storing the same
    decrypted data in the `Reversing` registry value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This may take a long time for beginners, but with continuous practice, analysis
    will be done at a fast pace.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Both approaches to analysis, static and dynamic, have their means to extract
    information and are required to properly analyze a file. Before doing dynamic
    analysis, it is recommended to start with static analysis first. We stick to our
    goal of generating an analysis report from the information we get. The analyst
    is not limited to using just the tools and resources outlined here to conduct
    an analysis—any information from the internet is useful, but validating it with
    your own analysis will stand as proof. Taking all items from the file, such as
    notable text strings, imported API functions, system changes, code flows, and
    possible blocks of behaviors are important, as these may be useful when building
    an overview of the file.
  prefs: []
  type: TYPE_NORMAL
- en: The result of the static analysis draws together the approach and resources
    that need to be prepared for dynamic analysis. For example, if the static analysis
    identified the file as a `Win32` PE file executable, then tools for analyzing
    PE files will need to be prepared.
  prefs: []
  type: TYPE_NORMAL
- en: As part of dynamic analysis, we discussed about **Virtual Allocated Space (VAS)**
    and how a program is mapped in memory along with its library dependencies. This
    information comes in handy when attempting reversing in further chapters.
  prefs: []
  type: TYPE_NORMAL
- en: We also introduced a few tools that we can use to engage in both static and
    dynamic approaches, and ended this chapter with a brief exercise on a 32-bit Windows
    PE executable file. In the next chapter, we will show more use of some of these
    tools as we reverse-engineer files.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The files used in this chapter can be downloaded from [https://github.com/PacktPublishing/Mastering-Reverse-Engineering](https://github.com/PacktPublishing/Mastering-Reverse-Engineering).
    [](https://github.com/PacktPublishing/Mastering-Reverse-Engineering)
  prefs: []
  type: TYPE_NORMAL
