<html><head></head><body><div><h1 class="header-title">Tools of the Trade</h1>
                
            
            
                
<p class="mce-root">In the previous chapters, we used some simple reversing tools, such as PEiD, CFF Explorer, IDA Pro, and OllyDbg, which aided us in our reversing adventure. This chapter explores and introduces more tools we can use and choose from. The selection of tools depend on the analysis required. For example, if a file was identified as an ELF file type, we'd need to use tools for analyzing a Linux executable. </p>
<p class="mce-root">This chapter covers tools for Windows and Linux, categorized for static and dynamic analysis. There are a lot of tools available out there—don't limit yourself to the tools discussed in this book.</p>
<p class="mce-root">In this chapter, you will achieve the following learning outcomes:</p>
<ul>
<li>Setting up tools</li>
<li>Understanding static and dynamic tools for Windows, and Linux</li>
<li>Understanding support tools</li>
</ul>


            

            
        
    </div>



  
<div><h1 class="header-title">Analysis environments</h1>
                
            
            
                
<p class="mce-root">The environment setup in reverse engineering is crucial to the result. We need a sandbox environment where we can dissect and play with the file, without worrying that we may break something. And since the most popular operating systems are Microsoft Windows and Linux, let's discuss using these operating systems in a virtual environment.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Virtual machines</h1>
                
            
            
                
<p class="mce-root">From the first chapter, we introduced using VirtualBox as our desktop virtualization system. The reason we chose VirtualBox was because of it being freeware. But besides VirtualBox, choosing the right sandboxing software depends on user preferences and requirements. There are pros and cons for every piece of sandboxing software, so it is worth exploring those on offer to find out which software you prefer. Here's a small list of virtualization software:</p>
<ul>
<li><strong>VMWare Workstation:</strong> This is a commercial, and widely popular, piece of virtualization software. VMWare Workstation can be downloaded from<strong> <a href="https://www.vmware.com">https://www.vmware.com</a></strong>.</li>
<li><strong>VirtualBox:</strong> This is free and open source virtualization software. It can be downloaded from <strong><a href="https://www.virtualbox.org">https://www.virtualbox.org</a></strong>.</li>
<li><strong>Qemu (Quick Emulator):</strong> This is actually not virtualization software, but rather, an emulator. Virtualization software uses virtualization features of the CPU, but uses real CPU resources to do this, while emulators simply imitate a CPU and its resources. That is, running an operating system in a virtualized environment uses the real CPU, while running an operating system in an emulated environment uses an imitated CPU. The Qemu module can be installed from Linux standard repositories. It has ports for both Windows and macOS, and can be downloaded from<strong> <a href="https://www.qemu.org">https://www.qemu.org</a></strong>.</li>
<li><strong>Bochs:</strong> An emulator that is limited to emulating the x86 CPU architecture. It is released as an open source and usually used for debugging the <strong>Master Boot Record</strong> (<strong>MBR</strong>) of small disk images. See <a href="http://bochs.sourceforge.net">http://bochs.sourceforge.net</a> for more details.</li>
<li class="mce-root"><strong>Microsoft Hyper-V:</strong> A virtualization feature of selected Microsoft Windows versions, including Windows 10. Activate it from the following menu like so:</li>
</ul>
<div><strong><img src="img/cc7392a0-6f87-4a4e-890b-ac46805a6e01.png" style="width:28.92em;height:23.92em;" width="415" height="368"/></strong></div>
<ul>
<li class="mce-root"><strong>Parallels:</strong> A commercial virtualization program, primarily designed to run Windows in a macOS host. More information about this piece of software can be found at<strong> </strong><a href="https://www.parallels.com/">https://www.parallels.com/</a>.<a href="https://www.parallels.com/"><br/></a></li>
</ul>
<p>The advantage of emulators is that other CPU architectures, such as ARM, can be emulated. Unlike virtualization software, emulators depend on the bare-metal machine's hypervisor. The drawback is possible slow performance as every emulated instruction is interpreted.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Windows</h1>
                
            
            
                
<p class="mce-root">It is recommended to do analysis on a 32- or 64-bit Windows 10 system, or the most recent version on offer. At the least, Windows 7 can still be used, since it is light and has a stable environment for running executable files. As much as possible, selecting the most popular and widely used version of Windows will be the best choice. Choosing old versions such as XP may not be very helpful, unless the program we are going to reverse was solely built for Windows XP.</p>
<p class="mce-root">At the time of writing, there are two ways we can get Windows for our analysis<strong>:</strong></p>
<ul>
<li>Install Windows 10 from an installer or ISO image that can be downloaded from <a href="https://www.microsoft.com/en-us/software-download/windows10">https://www.microsoft.com/en-us/software-download/windows10</a>. <a href="https://www.microsoft.com/en-us/software-download/windows10"/></li>
<li>Deploy the Windows appliance used for testing old versions of Edge and Internet Explorer. The appliance can be downloaded from <strong><a href="https://developer.microsoft.com/en-us/microsoft-edge/tools/vms">https://developer.microsoft.com/en-us/microsoft-edge/tools/vms</a>.<a href="https://developer.microsoft.com/en-us/microsoft-edge/tools/vms"/></strong></li>
</ul>
<p class="mce-root">These downloads do not have any license installed, and will expire within a short period. For the second option in the preceding list, after the deploying the appliance, it is best to take an initial snapshot <em>before</em> running the virtual machine. Reverting to this initial snapshot should reset the expiration back to when the appliance was deployed. Further snapshots should also be created, containing configuration updates and installed tools.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Linux</h1>
                
            
            
                
<p class="mce-root">Linux can easily be downloaded due to it being open source. Popular systems are usually forked from Debian or Red Hat systems. But since most of the tools developed for analysis are built under Debian-based systems, we selected Lubuntu as our analysis environment.<strong> </strong></p>
<div><strong>Lubuntu</strong> is a light version of Ubuntu<strong>.</strong></div>
<p class="mce-root">However, we are not leaving Red Hat-based systems from our list. If a program was designed to run only on Red Hat-based systems, we should do our dynamic reversing and debugging on a Red Hat-based system. As noted, reverse engineering requires not only the tools fit for the target, but the environment as well.</p>
<p class="mce-root">Lubuntu can be downloaded from <a href="https://lubuntu.net">https://lubuntu.net</a>. But, if you prefer using Ubuntu, you can download the installer from <strong><a href="https://www.ubuntu.com">https://www.ubuntu.com</a></strong>.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Information gathering tools</h1>
                
            
            
                
<p class="mce-root">Knowing what we are dealing with prepares us further. For example, if a file were identified as a Windows executable, we then prepare Windows executable tools. Information gathering tools helps us identify what the file type is and its properties. The information gathered becomes a part of the analysis profile. These tools are categorized as file type identifying, hash calculating, text string gathering, and monitoring tools.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">File type information</h1>
                
            
            
                
<p class="mce-root">These tools gather primary information about a file. The data gathered includes the filename, file size, file type, and file type-specific properties. The result of these tools enables the analyst to plan how to analyze the file:</p>
<ul>
<li class="mce-root"><strong>PEiD:</strong> A tool used to identify the file type, the packer, and compiler. It is built to run in Windows. It is not maintained, but still very useful.</li>
<li><strong>TrID:</strong> A command-line tool similar to PEiD. This tool has Windows and Linux versions. It can read a community-driven signature database of various file types.</li>
<li><strong>CFF Explorer:</strong> This tool is primarily used to read and make edits in a PE format file. It runs under Windows and has a lot of features, such as listing processes and dumping processes to a file. It can also be used to rebuild a process dump.</li>
<li><strong>PE Explorer: </strong>Another tool used to read and edit the structure of PE files. It can also unpack a number of executable compressed programs, such as UPX, Upack, and NSPack. PE Explorer only runs in Windows.</li>
<li><strong>Detect-it-Easy (DiE): </strong>Downloaded from <a href="https://github.com/horsicq/Detect-It-Easy">https://github.com/horsicq/Detect-It-Easy</a>, DiE is an open source tool that uses a community-driven set of algorithmic signatures to identify files. The tool has builds for Windows and Linux.</li>
<li><strong>ExifTool: </strong>This tool was primarily designed to read and edit the metadata of image files with an EXIF file format. It was further developed to extend features for other file formats, including PE files. ExifTool is available for Windows and Linux and can be downloaded from <strong><a href="https://sno.phy.queensu.ca/~phil/exiftool/">https://sno.phy.queensu.ca/~phil/exiftool/</a></strong>.</li>
</ul>


            

            
        
    </div>



  
<div><h1 class="header-title">Hash identifying</h1>
                
            
            
                
<p class="mce-root">Information gathering also includes identifying a file by its hash. Not only does the hash help validate a transferred file; it is also commonly used as a unique ID for a file analysis profile:</p>
<ul>
<li>
<p><strong>Quickhash:</strong> This is an open source tool available for Windows, Linux, and macOS that generates the MD5, SHA1, SHA256, and SHA512 of any file. It can be downloaded from<strong> <a href="https://quickhash-gui.org/">https://quickhash-gui.org/</a></strong>.</p>
</li>
<li class="mce-root"><strong>HashTab: </strong>This tool runs in Windows and can be integrated as a tab in the properties information of a file. It calculates the MD5, SHA1, and a couple of hash algorithms.</li>
<li><strong>7-zip:</strong> This tool is actually a file archiver, but it has an extension tool that can be enabled to calculate the hash of a file in MD5, SHA1, SHA256, and so forth.</li>
</ul>


            

            
        
    </div>



  
<div><h1 class="header-title">Strings</h1>
                
            
            
                
<p class="mce-root">Text-string gathering tools are mainly used to quickly identify possible functions or messages used by the program. It is not always true that every text string is used by the program. Program flow still depends on conditions set in the program. However, the string locations in the file can be used as markers that the analyst can trace back:</p>
<ul>
<li class="mce-root"><strong>SysInternals Suite's strings: </strong>This is a command-line tool for Windows that shows the list of text strings in any type of file.</li>
<li><strong>BinText: </strong>This is a GUI-based Windows tool that can display the ASCII and Unicode text strings for any given file.</li>
</ul>


            

            
        
    </div>



  
<div><h1 class="header-title">Monitoring tools</h1>
                
            
            
                
<p class="mce-root">Without manually digging deeper into the program's algorithm, simply running the program can give plenty of information about its behavior. Monitoring tools usually work by placing sensors in common or specific system library functions, then logging the parameters used. Using monitoring tools is a fast way to produce an initial behavior analysis of a program:</p>
<ul>
<li class="mce-root"><strong>SysInternals Suite's Procmon or Process Monitor: </strong>Running only on Windows, this is a real-time monitoring tool that monitors processes, thread, filesystem, and registry events. It can be downloaded from <a href="https://docs.microsoft.com/en-us/sysinternals/downloads/procmon">https://docs.microsoft.com/en-us/sysinternals/downloads/procmon</a> and is a part of the SysInternals Suite package.</li>
<li><strong>API Monitor: </strong>This powerful tool helps reverse engineering by monitoring API calls as the program runs. The analyst has to set which API the tool needs to hook. Once an API is hooked, all user-mode processes using the API will be logged. API Monitor can be downloaded from <a href="http://www.rohitab.com/apimonitor">http://www.rohitab.com/apimonitor</a>.</li>
</ul>
<ul>
<li><strong>CaptureBAT: </strong>In addition to what Process Monitor can do, this command-line tool is also capable of monitoring network traffic.</li>
</ul>


            

            
        
    </div>



  
<div><h1 class="header-title">Default command-line tools</h1>
                
            
            
                
<p class="mce-root">There are a couple of useful tools that are already built into the operating system we are working on. These come in handy when third party tools are not available:</p>
<ul>
<li class="mce-root"><strong>strings:</strong> This is a Linux command used to list the strings found in a given file.</li>
<li><strong>md5sum: </strong>This is a Linux command used to calculate the MD5 hash of a given file.</li>
<li><strong>file:</strong> This is a command line in Linux used to identify files. It uses the libmagic library.</li>
</ul>


            

            
        
    </div>



  
<div><h1 class="header-title">Disassemblers</h1>
                
            
            
                
<p class="mce-root">Disassemblers are tools used to look at the low-level code of a program compiled from either a high-level language, or of the same low-level language. As part of analysis, deadlisting and recognizing the blocks of code help to build up the behavior of the program. It is then be easier to identify only code blocks that need to be thoroughly debugged, without running through the whole program code:</p>
<ul>
<li>
<p><strong>IDA Pro:</strong> A popular tool used in the software security industry to disassemble various low-level language built on the x86 and ARM architectures. It has a wide list of features. It can generate a graphical flow of code, showing code blocks and branching. It also has scripting that can be used to parse through the code and disassemble it into more meaningful information. IDA Pro has an extended plugin, called Hex-Rays, that is capable of identifying assembly codes to its equivalent C source or syntax. The free version of IDA Pro can be downloaded from <strong><a href="https://www.hex-rays.com/products/ida/support/download_freeware.shtml">https://www.hex-rays.com/products/ida/support/download_freeware.shtml</a></strong>.</p>
</li>
<li class="mce-root"><strong>Radare: </strong>Available on Windows, Linux, and macOS, this open source tool shows the disassembled equivalent of a given program. It has a command-line interface view, but there are existing plugins that can show it using the computer's browser. Radare's source can be downloaded and built from <a href="https://github.com/radare/radare2">https://github.com/radare/radare2</a>. Information on how to install binaries can be found at its website, available at<strong> <a href="https://rada.re">https://rada.re</a></strong>.</li>
<li><strong>Capstone:</strong> This is an open source disassembly and decompiler engine. The engine is used by many disassembly and decompiler tools, such as Snowman. Information about this tool can be found at <strong><a href="https://www.capstone-engine.org/">https://www.capstone-engine.org/</a></strong>.</li>
<li><strong>Hopper:</strong> A disassembly tool for Linux and macOS operating systems. It has a similar interface as IDA Pro and is capable of debugging using GDB. </li>
<li><strong>BEYE: </strong>Also known as Binary EYE, this is a hex viewer and editing tool with the addition of a disassembly view mode. BEYE is available for Windows and Linux. It can be downloaded from<strong> <a href="https://sourceforge.net/projects/beye/">https://sourceforge.net/projects/beye/</a></strong>.</li>
<li><strong>HIEW:</strong> Also known as Hacker's View, is similar to BEYE, but has better information output for PE files. The paid version of HIEW has more features supporting a lot of file types and machine architectures.</li>
</ul>


            

            
        
    </div>



  
<div><h1 class="header-title">Debuggers</h1>
                
            
            
                
<p class="mce-root">When debugging tools are used, this would mean that we are in the code-tracing phase of our analysis. Debuggers are used to step in every instruction the program is supposed to do. In the process of debugging, actual interaction and changes in memory, disk, network, and devices can be identified:</p>
<ul>
<li class="mce-root"><strong>x86dbg:</strong> This is a Windows user-mode debugger. It is open source and can debug 32- and 64-bit programs. It is capable of accepting plugins written by users. The source code can be downloaded from <a href="https://github.com/x64dbg">https://github.com/x64dbg</a>. The builds can be downloaded from <a href="https://x64dbg.com">https://x64dbg.com</a>.</li>
<li><strong>IDA Pro:</strong> Paid versions of IDA Pro are capable of debugging using the same disassembly interface. It is very useful when you want to see a graphical view of decrypted code.</li>
</ul>
<ul>
<li class="mce-root"><strong>OllyDebug:</strong> A popular Windows debugger, due to its portability and rich features. It can accommodate plugins written by its users, adding capabilities such as unpacking a loaded executable compressed file (by reaching the original entry point) and memory dumping. Ollydebug can be downloaded from <a href="http://www.ollydbg.de/">http://www.ollydbg.de/</a>.</li>
<li><strong>Immunity Debugger:</strong> The interface of this program looks like a highly improved version of OllyDebug. It has plugin support for Python and other tools. Immunity Debugger can be downloaded from Immunity, Inc.'s site at <a href="https://www.immunityinc.com/products/debugger/">https://www.immunityinc.com/products/debugger/</a>. Older versions can be found at <a href="https://github.com/kbandla/ImmunityDebugger">https://github.com/kbandla/ImmunityDebugger/</a>.</li>
<li><strong>Windbg:</strong> A debugger developed by Microsoft. The interface is quite plain, but can be configured to show every kind of information needed by a reverser. It is capable of being set up to remotely debug device drivers, software in the kernel levels, and even a whole Microsoft operating system.</li>
<li><strong>GDB:</strong> Also known as GNU Debugger, GDB is originally a debugger developed for Linux and a couple of other operating systems. It is capable of debugging not only low-level languages but also used for debugging high-level languages such as C, C++, and Java. GDB can also be used in Windows. GDB uses a command-line interface, but there are existing GUI programs that use GDB for a more informative look.</li>
<li><strong>Radare:</strong> Radare also has a debugger packaged along with it. It can also do remote debugging by using GDB remotely. Its interface is command line-based but has an integrated visual view. Its developers also made a better visual view using the browser. Basically, compared with GDB, Radare would be much preferred. It is also primarily built for Linux, but has compiled binaries on offer for Windows and macOS.</li>
</ul>


            

            
        
    </div>



  
<div><h1 class="header-title">Decompilers</h1>
                
            
            
                
<p class="mce-root">Disassemblers are used to show the low-level code of a compiled high-level program. Decompilers, on the other hand, attempt to show the high-level source code of the program. These tools work by identifying blocks of low-level code that match with corresponding syntax in the high-level program. It is expected that these tools won't be able to show what the original program's source code looks like, but nonetheless, they help speed up analysis with a better view of the program's pseudo code:</p>
<ul>
<li class="mce-root"><strong>Snowman:</strong> This is a C and C++ decompiler. It can run as a standalone tool, or as an IDA Pro plugin. The source can be found at <a href="https://github.com/yegord/snowman">https://github.com/yegord/snowman</a>, while its compiled binaries can be downloaded from <a href="https://derevenets.com/">https://derevenets.com/</a>. It is available for Windows and Linux.</li>
<li><strong>Hex-Rays: </strong>This is also a C and C++ decompiler and runs as a plugin for IDA Pro. It is sold commercially as part of IDA Pro. Users should expect this to have a better decompiled output than Snowman.</li>
<li><strong>dotPeek: </strong>This is a free .NET decompiler by Jetbrains. It can be downloaded from <a href="https://www.jetbrains.com/decompiler/">https://www.jetbrains.com/decompiler/</a>.</li>
<li><strong>iLSpy:</strong> This is an open source .NET decompiler. The source and pre-compiled binaries can be found at <a href="https://github.com/icsharpcode/ILSpy">https://github.com/icsharpcode/ILSpy</a>.</li>
</ul>


            

            
        
    </div>



  
<div><h1 class="header-title">Network tools</h1>
                
            
            
                
<p class="mce-root">The following is a list of tools that are used to monitor the network:</p>
<ul>
<li class="mce-root"><strong>tcpdump:</strong> This is a Linux-based tool used to capture network traffic. It can be installed from the default repositories.</li>
<li><strong>Wireshark: </strong>This tool is capable of monitoring network traffic. Incoming and outgoing network traffic, including packet information and data, is logged in real time. Originally named Ethereal, Wireshark is available for Windows, Linux, and macOS, and can be downloaded from <a href="https://www.wireshark.org/">https://www.wireshark.org/</a>.</li>
<li><strong>mitmproxy: </strong>Also known as Man-In-The-Middle Proxy. As its name states, it is set up as a proxy, and thus able to control and monitor network traffic before data is either sent externally or received by internal programs.</li>
<li><strong>inetsim:</strong> Essentially, this tool fakes network and internet connectivity, thereby trapping any network traffic sent externally by a program. This is very useful for analyzing malware, preventing it from sending data externally, while having knowledge of where it connects to and what data it tries to send.</li>
</ul>


            

            
        
    </div>



  
<div><h1 class="header-title">Editing tools</h1>
                
            
            
                
<p class="mce-root">There may be instances where we need to modify the contents of a program to make it work properly, or validate a code behavior. Modifying data in a file can also change the code flow where conditional instructions may happen. Changing instructions can also work around anti-debugging tricks:</p>
<ul>
<li class="mce-root"><strong>HxD Hex Editor:</strong> A Windows binary file viewer and editor. You can use this to view the binary contents of a file.</li>
<li><strong>Bless:</strong> A Linux binary file viewer and editor.</li>
<li><strong>Notepad++:</strong> A Windows text editor, but can also read binary files, though reading binary files with hexadecimal digits would require a hex-editing plugin. Still, this is useful for reading and analyzing scripts, due to its wide range of supported languages, including Visual Basic and JavaScript.</li>
<li><strong>BEYE:</strong> A useful tool for viewing and editing any file type. BEYE is available for Windows and Linux. </li>
<li><strong>HIEW: </strong>The feature that makes this software worthwhile is its ability to do on-the-fly encryption using assembly language. </li>
</ul>


            

            
        
    </div>



  
<div><h1 class="header-title">Attack tools</h1>
                
            
            
                
<p class="mce-root">There may be cases where we need to craft our own packets to fool the program into thinking that it is receiving live data from the network. Though these tools are primarily developed to generate exploited network packets for penetration testing, these can also be used for reverse engineering:</p>
<ul>
<li class="mce-root"><strong>Metasploit</strong> (<a href="https://www.metasploit.com/">https://www.metasploit.com/</a>): This is a framework with scripts that can generate exploited packets to send to the target for penetration tests. The scripts are modular and users can develop their own scripts.</li>
<li><strong>ExploitPack</strong> (<a href="http://exploitpack.com/">http://exploitpack.com/</a>): This has the same concept as Metasploit, though is maintained by a different group of researchers.</li>
</ul>


            

            
        
    </div>



  
<div><h1 class="header-title">Automation tools</h1>
                
            
            
                
<p class="mce-root">Developing our own programs to do analysis may sometimes be a must. For example, if the program contains a decryption algorithm, we can develop a separate program that can run the same algorithm that may be used for similar programs with the same decryption algorithm. If we wanted to identify variants of the file we were analyzing, we could automate the identification for incoming files using one of the following:</p>
<ul>
<li class="mce-root"><strong>Python:</strong> This scripting language is popular because of it availability across multiple platforms. It is pre-installed in Linux operating systems; compiled binaries for Windows can be downloaded from <a href="https://www.python.org/">https://www.python.org/</a>. </li>
<li><strong>Yara:</strong> A tool and language from the developers of VirusTotal. It is capable of searching the contents of files for a set of binary or text signatures. Its most common application is in searching for malware remnants in a compromised system.</li>
<li><strong>Visual Studio:</strong> A piece of Microsoft software for coding and building programs. It can be used by reverse engineers when decompiled programs need to be debugged graphically. For example, we can debug a decompiled C# program using Visual Studio, instead of trying to understand each p-code of disassembled C# codes.</li>
</ul>


            

            
        
    </div>



  
<div><h1 class="header-title">Software forensic tools</h1>
                
            
            
                
<p class="mce-root">Reverse engineering includes analyzing the post-execution of a program. This entails gathering and determining objects and events from memory and disk images. With these tools, we can analyze the suspended state of an operating system with the process of the program being analyzed still in running memory. </p>
<p class="mce-root">Here is a list of different forensic software that can be downloaded:</p>
<ul>
<li class="mce-root">Digital Forensics Framework (<a href="https://github.com/arxsys/dff">https://github.com/arxsys/dff</a>)</li>
<li>Open Computer Forensics Architecture</li>
</ul>
<p class="mce-root">                                   <a href="https://github.com/DNPA/OcfaArch">https://github.com/DNPA/OcfaArch</a></p>
<p class="mce-root"><a href="https://github.com/DNPA/OcfaLib">                    https://github.com/DNPA/OcfaLib</a></p>
<p class="mce-root"><a href="https://github.com/DNPA/OcfaModules">                    https://github.com/DNPA/OcfaModules</a></p>
<p class="mce-root"><a href="https://github.com/DNPA/OcfaDocs">                    https://github.com/DNPA/OcfaDocs</a></p>
<p class="mce-root"><a href="https://github.com/DNPA/OcfaJavaLib">                    https://github.com/DNPA/OcfaJavaLib</a></p>
<ul>
<li class="mce-root">CAINE (<a href="https://www.caine-live.net/">https://www.caine-live.net/</a>)</li>
<li>X-Ways Forensics Disk Tools (<a href="http://www.x-ways.net/forensics/">http://www.x-ways.net/forensics/</a>)</li>
<li>SIFT (<a href="https://digital-forensics.sans.org/community/downloads">https://digital-forensics.sans.org/community/downloads</a>)</li>
<li>SleuthKit (<a href="http://www.sleuthkit.org/">http://www.sleuthkit.org/</a>)</li>
<li>LibForensics (<a href="https://code.google.com/archive/p/libforensics/">https://code.google.com/archive/p/libforensics/</a>)</li>
<li>Volatility (<a href="https://github.com/volatilityfoundation">https://github.com/volatilityfoundation</a>): </li>
</ul>
<p class="mce-root">In malware analysis, Volatility is one of the popular pieces of open source software used. It is able to read suspended states of virtual machines. The advantage of such tools is that malware, such as rootkits, that try to hide themselves from user domains can be extracted using memory forensic tools.</p>
<ul>
<li class="mce-root">BulkExtractor (<a href="http://downloads.digitalcorpora.org/downloads/bulk_extractor/">http://downloads.digitalcorpora.org/downloads/bulk_extractor/</a>)</li>
<li>PlainSight (<a href="http://www.plainsight.info/index.html">http://www.plainsight.info/index.html</a>)</li>
<li>Helix3 (<a href="http://www.e-fense.com/products.php">http://www.e-fense.com/products.php</a>)</li>
<li>RedLine (<a href="https://www.fireeye.com/services/freeware/redline.html">https://www.fireeye.com/services/freeware/redline.html</a>)</li>
<li>Xplico (<a href="https://www.xplico.org/">https://www.xplico.org/</a>)</li>
</ul>


            

            
        
    </div>



  
<div><h1 class="header-title">Automated dynamic analysis</h1>
                
            
            
                
<p class="mce-root">These are tools used to automatically gather information by running the program in an enclosed sandbox.</p>
<ul>
<li class="mce-root"><strong>Cuckoo:</strong> This is a piece of Python-coded software deployed in Debian-based operating systems. Usually, Cuckoo is installed in the hosting Ubuntu system, and sends files to be analyzed in the VMWare or VirtualBox sandbox clients. Its development is community-driven, and as such, a lot of open source plugins are available for download.</li>
<li><strong>ThreatAnalyzer:</strong> Sold commercially, ThreatAnalyzer, previously known as CWSandbox, has been popular in the anti-virus community for its ability to analyze malware and return very useful information. And because users are able to develop their own rules, ThreatAnalyzer, as a backend system, can be used to determine if a submitted file contains malicious behaviors or not.</li>
<li><strong>Joe Sandbox:</strong> This is another commercial tool that shows meaningful information about the activities that a submitted program carries out when executed.</li>
<li><strong>Buster Sandbox Analyzer (BSA): </strong>The setup of BSA is different from the first three tools. This one does not require a client sandbox. It is installed in the sandbox environment. The concept of this tool is to allocate disk space where a program can run. After running, everything that happened in the space is logged and restored back afterwards. It is still recommended to use BSA in an enclosed environment. </li>
<li><strong>Regshot: </strong>this is a tool used to capture a snapshot of the disk and registry. After running a program, the user can take a second snapshot. The difference of the snapshots can be compared, thereby showing what changes were made in the system. Regshot should be run in an enclosed environment.</li>
</ul>


            

            
        
    </div>



  
<div><h1 class="header-title">Online service sites</h1>
                
            
            
                
<p class="mce-root">There are existing online services that can also aid us in our reversing.</p>
<ul>
<li class="mce-root"><strong>VirusTotal:</strong> This submits a file or a URL and cross-references it with a list of detections from various security programs. The result gives us an idea if the file is indeed malicious or not. It can also show us some file information, such as the SHA256, MD5, file size, and any indicators.</li>
<li><strong>Malwr:</strong> Files submitted here will be submitted to a backend Cuckoo system.</li>
<li><strong>Falcon Sandbox:</strong> This is also known as hybrid-analysis, and is an online automated analysis system developed by Payload Security. Results from Cuckoo and hybrid-analysis uncover similar behaviors, but one may show more information than the other. This may depend on how the client sandbox was set up. If, say, the .NET framework was not installed in the sandbox, submitted .NET executables will not run as expected.</li>
<li><strong>whois.domaintools.com:</strong> This is a site that shows the whois information about a domain or URL. This may come in handy, especially when trying to determine which country or state a program is trying to connect to.</li>
<li><strong>robtex.com:</strong> A similar site to whois, that shows historical info and a graphical tree of what a given site is connected to.</li>
<li><strong>debuggex.com:</strong> This is an online regular expressions service, where you can test your regex syntax. This can come in handy when developing scripts, or reading scripts or codes that contain regular expressions.</li>
</ul>
<p>Submitting files or URLs to these online sites would mean that you are sharing information to their end. It would be best to ask for the permission of the owner of the file or URL before submitting.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Summary</h1>
                
            
            
                
<p class="mce-root">In this chapter, we listed some of the tools used for reverse engineering. We tried to categorized the tools based on their purposes. But just as how we choose every piece of software that we use, the reverser's preferred set of tools depend on the packed features they contain, how user-friendly they are, and most importantly, whether or not they have the features required to do the job. We have covered the tools we can use for static analysis, including binary viewer and disassembly tools. We also listed useful debugging tools that we can use for Windows and Linux.</p>
<p class="mce-root">From the list, I personally recommend HIEW, x86dbg, IDA Pro, Snowman, and iLSpy for Windows analysis of PE binary executables. And on the Linux side, BEYE, Radare, GDB, and IDA Pro are great for analyzing ELF files.</p>
<p class="mce-root">We also covered some online services that can help us gain more information about sites we extracted from the analysis. We also introduced systems that can automate analysis, when we are going to deal with a lot of files. In addition, we listed a few forensic tools that we can use to analyze suspended memory.</p>
<p class="mce-root">As always, these tools have their pros and cons, and those eventually chosen will depend on the user and the type of analysis needed. The tools each have their own unique capability and comfort. For the next chapters, we will be using a mix of these tools. We may not use all of them, but we'll use what will get the analysis done.</p>
<p class="mce-root">In the next chapter, we'll learn more tools as we engage in reverse engineering on Linux platforms.</p>


            

            
        
    </div>



  </body></html>