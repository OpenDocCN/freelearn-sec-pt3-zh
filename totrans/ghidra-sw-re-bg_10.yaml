- en: '*Chapter 8*: Auditing Program Binaries'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you will learn about auditing executable binary files. It consists
    of analyzing binary programs to identify their vulnerabilities. It is interesting
    for us because this is another common Ghidra use case. Furthermore, if you find
    an unknown vulnerability in a program, in most cases, you will be able to hack
    computers without needing to convince the user to perform some action via social
    engineering.
  prefs: []
  type: TYPE_NORMAL
- en: You will walk through a review of the main memory corruption vulnerabilities
    (that is, integer overflows, buffer overflow, format strings, and so on) while
    approaching them with Ghidra. Finally, you will learn how these vulnerabilities
    can be exploited in practice.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding memory corruption vulnerabilities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding vulnerabilities using Ghidra
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploiting a simple stack-based buffer overflow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The requirements for this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'MinGW64 – GCC compiler support for Windows: [https://mingw-w64.org/](https://mingw-w64.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Olly Debugger 1.10 (OllyDBG) – A debugger for Microsoft Windows platforms.
    Other versions of OllyDBG do exist but this version is very stable and works well
    with x86 32-bit binaries: [http://www.ollydbg.de/odbg110.zi](http://www.ollydbg.de/odbg110.zi)p'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'FTPShell Client 6.7: A real-world application that makes use of the `strcpy`
    function: [https://www.exploit-db.com/apps/40d5fda024c3fc287fc841f23998ec27-fa_ftp_setup.msi](https://www.exploit-db.com/apps/40d5fda024c3fc287fc841f23998ec27-fa_ftp_setup.msi)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The GitHub repository containing all the necessary code for this chapter: [https://github.com/PacktPublishing/Ghidra-Software-Reverse-Engineering-for-Beginners/tree/master/Chapter08](https://github.com/PacktPublishing/Ghidra-Software-Reverse-Engineering-for-Beginners/tree/master/Chapter08)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following link to see the Code in Action video: [https://bit.ly/3lP7hRa](https://bit.ly/3lP7hRa)'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding memory corruption vulnerabilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a lot of types of software vulnerabilities. In an effort to categorize
    software weakness types, arose the **Common Weakness Enumeration** (**CWE**).
    If you want to know what kind of vulnerabilities exist, I recommend you check
    out the entire list, which you can find at [https://cwe.mitre.org/data/index.html](https://cwe.mitre.org/data/index.html).
  prefs: []
  type: TYPE_NORMAL
- en: We will be focusing on memory corruption vulnerabilities. This kind of vulnerability
    happens when a program tries to access a memory region without having access privileges
    to it.
  prefs: []
  type: TYPE_NORMAL
- en: These kinds of vulnerabilities are typical in the C/C++ programming languages
    because a programmer has direct memory access, allowing us to commit memory access
    mistakes. They are not possible in the Java programming language, which is considered
    a memory-safe programming language because its runtime error detection checks
    and prevents such errors, although the **Java Virtual Machine** (**JVM**) is also
    susceptible to memory corruption vulnerabilities ([https://media.blackhat.com/bh-ad-11/Drake/bh-ad-11-Drake-Exploiting_Java_Memory_Corruption-WP.pdf](https://media.blackhat.com/bh-ad-11/Drake/bh-ad-11-Drake-Exploiting_Java_Memory_Corruption-WP.pdf)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Before addressing memory corruption vulnerabilities, we need to cover two memory
    allocation mechanisms: automatic memory allocation (which takes place on the stack
    of the program) and dynamic memory allocation (which takes place on the heap).
    There''s static allocation as well, which we are going to omit for this book (which
    is performed in the C programming language via the `static` keyword, but is not
    relevant here).'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will cover buffer overflow, which causes memory corruption when trying
    to use more memory than is allocated. And finally, since more protection mechanisms
    are being developed to mitigate buffer overflows, we will cover format string
    vulnerabilities, which enable the leaking of program information, allowing confidential
    data to be seen, but also enable learning about program memory addresses, making
    it possible to bypass some state-of-the-art memory corruption countermeasures.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the stack
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The stack of a computer works like a stack of plates. You can put plates onto
    the stack but, when removing plates, you can only remove the last plate put onto
    the stack. Let''s see this with an example. The function `sum` (check line `00`)
    is supposed to perform the sum of its arguments, so the following code performs
    the operation `1 + 3` and stores the result in the `result` variable (check line
    `05`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Compile the previous code, targeting the x86 (32-bit) architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'If we analyze the resulting binary using Ghidra, the line `05` is translated
    into the following assembly code lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1 – Ghidra assembly overview of the sum function'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16207_08_001.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.1 – Ghidra assembly overview of the sum function
  prefs: []
  type: TYPE_NORMAL
- en: A stack frame is a frame of data that gets pushed onto the stack. In the case
    of a call stack, a stack frame would represent a function call and its argument
    data. The current stack frame is located between the memory address stored in
    `ESP` (whose purpose is to point at the top of the stack) and `EBP` (whose purpose
    is to point at the base of the stack). As you can see, it pushes onto the stack
    the values `0x1` and `0x3` in reverse order regarding our code. It puts the integer
    `0x1` at the top of the stack (at the memory address pointed to by `ESP`) and
    also puts the integer `0x3` just before. The `_sum` function, corresponding to
    `sum` (check line `00`) in our code, is called and the result is expected to be
    returned in the `EAX` register, which is also stored on the stack using a `MOV`
    operation. Notice that when a `CALL` operation is performed, the address of the
    next instruction is pushed onto the stack and then it transfers the control to
    the callee function.
  prefs: []
  type: TYPE_NORMAL
- en: In order to perform function calls, a convention is necessary to agree where
    the caller function places the parameters (into registers or onto the stack).
    If they are placed into registers, then the convention must specify which registers.
    It is also necessary to decide the order in which the parameters are placed. Who
    cleans the stack? The caller or the callee function? Where is the return value
    placed after returning from the function? As is evident, it is necessary to establish
    a calling convention.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, parameters are pushed onto the stack by the caller function, and
    the callee function, `_sum`, is responsible for clearing the stack and returning
    the value using the `EAX` register. This is called the **cdecl** convention, which
    stands for **C declaration**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s take a look at the `_sum` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2 – Program allowing you to sum numbers'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16207_08_002.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.2 – Program allowing you to sum numbers
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the stack base address of the caller function is pushed onto
    the stack by the callee function via the `PUSH EBP` instruction (line `1`). Next,
    the `MOV EBP, ESP` instruction (line `2`) establishes that the top of the stack
    of the caller (the address stored in `ESP`) is the bottom of the callee function.
    In other words, the stack frame of the callee function is over the stack frame
    of the caller function.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, there is no stack allocation, which is can be performed via the
    `SUB ESP, 0xXX` operation, where `0xXX` is the amount of stack memory to allocate.
  prefs: []
  type: TYPE_NORMAL
- en: Both parameters, `a` and `b`, are taken from the stack and stored in registers.
    The `ADD` operation (line `5`) is responsible for summing both registers and storing
    the result in the `EAX` register.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the stack frame of the caller function is restored via `POP EBP` (line
    `6`), and the control is transferred to the caller function via `RET` (line `7`),
    which takes the next instruction to execute stored on the stack by the `CALL`
    instruction of the caller, and transfers the execution to it.
  prefs: []
  type: TYPE_NORMAL
- en: In conclusion, the stack memory is available until the function exits and it
    is not necessary to free it.
  prefs: []
  type: TYPE_NORMAL
- en: Stack-based buffer overflow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A stack-based buffer overflow (CWE-121: [https://cwe.mitre.org/data/definitions/121.html](https://cwe.mitre.org/data/definitions/121.html))
    happens when a buffer allocated in the stack is overwritten beyond its limits.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we can see a program that reserves 10 bytes of memory
    (see line `01`) and then copies the first argument given to the program into this
    buffer (see line `02`). Finally, the program returns `0`, but this is not relevant
    in this case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Compile the program targeting the x86 (32-bit) architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The vulnerability happens because there are no length checks over the argument
    to copy into the buffer. So, if more than 200 bytes are copied into the buffer
    via `_strcpy`, some stuff stored on the stack apart from the buffer variable will
    be overwritten. Let''s take a look at it using Ghidra:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.3 – A stack-based overflow on _strcpy'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16207_08_003.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.3 – A stack-based overflow on _strcpy
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, when the code is compiled, the buffer is located at `ESP +
    0x18` and `ptr_source` is at `Stack[-0xec]`, meaning that the buffer length is
    `0xec - 0x18 = 212` bytes. So, the code of the binary file is different than the
    source code written in C since the buffer was expected to be 10 bytes in size.
    See the following screenshot of the Ghidra decompiler:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.4 – A compiler optimization applied over the local buffer variable'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16207_08_004.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.4 – A compiler optimization applied over the local buffer variable
  prefs: []
  type: TYPE_NORMAL
- en: The aforementioned difference between the source code and the binary file happens
    due to compiler optimization. Notice that modifications and vulnerabilities can
    also be introduced by the compiler (for example, the compiler tends to remove
    uses of the `memset` function during the optimization phase when the targeted
    buffer is not used after, so it is not safe to use `memset` for zeroing memory).
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the heap
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes, the programmer doesn't know how much memory will be needed at runtime
    or maybe they need to store some information that must survive to the exit of
    the function. It is in these cases that the programmer uses functions like the
    `malloc()` C standard function to dynamically allocate memory.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the memory is allocated by the operating system in a heap structure,
    and the programmer is responsible for freeing it, for instance, using the `free()`
    C standard function.
  prefs: []
  type: TYPE_NORMAL
- en: If the programmer forgets to call the `free()` function, the memory resource
    will not be freed until the program finishes its execution (because modern operating
    systems are sufficiently smart to release the resource when the program finishes).
  prefs: []
  type: TYPE_NORMAL
- en: Heap-based buffer overflow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A heap-based buffer overflow (CWE-122: [https://cwe.mitre.org/data/definitions/122.html](https://cwe.mitre.org/data/definitions/122.html))
    happens when a buffer allocated in the heap is overwritten beyond its limits.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This vulnerability is very similar to a stack-based buffer overflow but, in
    this case, the buffer is explicitly allocated via some function such as `malloc()`
    performing a heap dynamic allocation of memory. Let''s see an example of this
    vulnerability:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Compile the program targeting the x86 (32-bit) architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This code is analogous to the stack-based buffer overflow but the vulnerability
    happens in the heap. As you can see on line `02`, `10` bytes of memory are allocated
    in the heap, and then, on line `03`, it is overwritten by the first argument of
    the program that is bigger than `10` bytes.
  prefs: []
  type: TYPE_NORMAL
- en: Usually, heap-based buffer overflows are considered more difficult to exploit
    than stack-based buffer overflows because the exploitation requires understanding
    how the heap structure works, which is an operating system-dependent structure
    and, therefore, a more complex topic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how it looks on Ghidra:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.5 – A heap-based overflow on _strcpy'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16207_08_005.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.5 – A heap-based overflow on _strcpy
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the size passed to `_malloc` is `0xa`. No optimizations are
    performed by the compiler because it is a dynamic allocation. After the `malloc`
    allocation, the pointer to the buffer is stored, then a pointer to the vector
    of program arguments, `_Argv`, is retrieved and, since it contains an array of
    pointers (one `dword` per pointer), `0x4` is added to `EAX` in order to skip the
    first parameter (which is the name of the program) and go to the first argument.
  prefs: []
  type: TYPE_NORMAL
- en: Next to it, the call to the insecure `_strcpy` function happens and, finally,
    the allocated buffer is released via `_free`.
  prefs: []
  type: TYPE_NORMAL
- en: Format strings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A format string vulnerability (CWE-134: [https://cwe.mitre.org/data/definitions/134.html](https://cwe.mitre.org/data/definitions/134.html))
    happens when the program uses a function that accepts a format string from an
    external source. Check out the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Compile the program targeting the x86 (32-bit) architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The first argument given to the program is assigned to the string pointer on
    line `01` and is passed directly to the `printf()` function, which prints a format
    string.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use it not only to crash the program but also to retrieve information.
    For instance, you can use `%p` to retrieve information from the stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: These kinds of vulnerabilities are very important nowadays because they are
    helpful to bypass **Address Space Layout Randomization** (**ASLR**) anti-exploit
    protection. ASLR prevents the attacker from knowing the base address where the
    binary is loaded (and, therefore, any other address), making it hard to control
    the program flow but, for instance, if you leak the content of some address in
    memory using a format string vulnerability, you will be able to calculate the
    base address (or any arbitrary binary address) using offsets relative to the leaked
    data.
  prefs: []
  type: TYPE_NORMAL
- en: Format string attack
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to learn more about the details on how to retrieve information
    using format strings and how to exploit it, check out the following OWASP URL:
    [https://owasp.org/www-community/attacks/Format_string_attack](https://owasp.org/www-community/attacks/Format_string_attack)'
  prefs: []
  type: TYPE_NORMAL
- en: The exploiting topic is broad. These are not the only existing types of memory-corruption
    vulnerabilities (that is, use after free, double free, integer overflow, off-by-one,
    and so on were not covered here), but we've covered the basics.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will discuss how to manually look for vulnerabilities using Ghidra.
  prefs: []
  type: TYPE_NORMAL
- en: Finding vulnerabilities using Ghidra
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The vulnerabilities covered in the previous section are all related to unsafe
    C functions so, when looking for vulnerabilities, you can start checking whether
    the program makes use of any of them.
  prefs: []
  type: TYPE_NORMAL
- en: After identifying an unsafe function, the next step is to check the parameters
    and/or previous checks over the parameters to determine whether the function is
    being used properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to perform the experiment on a real-world application, please install
    FTPShell Client 6.7\. The installation steps are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Download the installer and execute it: https://www.exploit-db.com/apps/40d5fda024c3fc287fc841f23998ec27-fa_ftp_setup.msi.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Next** when the wizard menu appears:![Figure 8.6 – FTPShell Client
    6 Setup Wizard
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16207_08_006.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.6 – FTPShell Client 6 Setup Wizard
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Accept the FTPShell Client license and click on **Next**:![Figure 8.7 – Accepting
    the FTPShell Client license
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16207_08_007.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.7 – Accepting the FTPShell Client license
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Choose the location where the program will be installed and click on **Next**:![Figure
    8.8 – Choosing the FTPShell Client install location
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16207_08_008.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.8 – Choosing the FTPShell Client install location
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Proceed to install:![Figure 8.9 – Installing FTPShell Client
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16207_08_009.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.9 – Installing FTPShell Client
  prefs: []
  type: TYPE_NORMAL
- en: 'After the installation process, you will find the principal binary of the program
    at the following location:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'To prepare the lab for our experiment of looking for vulnerable functions in
    `ftpshell.exe`, we will need to create a Ghidra project containing the `ftpshell.exe`
    binary. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Ghidra project with the name of `FtpShell`. The steps to create
    a Ghidra project were explained in [*Chapter 1*](B16207_01_Final_SK_ePub.xhtml#_idTextAnchor017),
    *Getting Started with Ghidra*, in the *Creating a new Ghidra project* section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `ftpshell.exe` binary to it. The steps to add a binary to a Ghidra project
    were explained in [*Chapter 1*](B16207_01_Final_SK_ePub.xhtml#_idTextAnchor017),
    *Getting Started with Ghidra*, in the *Importing files to a Ghidra project* section:![Figure
    8.10 – Resulting FTPShell Ghidra project
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16207_08_010.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.10 – Resulting FTPShell Ghidra project
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Analyze the file. The steps to analyze a Ghidra project were explained in [*Chapter
    1*](B16207_01_Final_SK_ePub.xhtml#_idTextAnchor017), *Getting Started with Ghidra*,
    in the *Performing and configuring Ghidra analysis* section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Some functions that you can look for are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Some functions that can lead to stack-based buffer overflow vulnerabilities:
    `strcpy`, `strcat`, `strncat`, `gets()`, `memcpy()`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some functions that can lead to heap-based buffer overflow vulnerabilities:
    `malloc()`, `calloc()`, `resize()`, `free()`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some functions that can lead to format string vulnerabilities: `prinft()`,
    `fprintf()`, `sprintf()`, `snprintf()`, `vsprintf()`, `vprintf()`, `vsnprintf()`,
    `vfprintf()`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can apply a filter to the `strcpy`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.11 – Filtering functions to locate _strcpy'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16207_08_011.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.11 – Filtering functions to locate _strcpy
  prefs: []
  type: TYPE_NORMAL
- en: 'Right-click on the results and click on **Show References to Ctrl+Shift+F**
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.12 – Finding references to _strcpy'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16207_08_012.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.12 – Finding references to _strcpy
  prefs: []
  type: TYPE_NORMAL
- en: 'Choosing the mentioned option will show you the list of program functions calling
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.13 – References to _strcpy'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16207_08_013.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.13 – References to _strcpy
  prefs: []
  type: TYPE_NORMAL
- en: By disassembling the caller function, you can analyze whether the length checks
    applied to the string are sufficient to prevent exceeding the destination buffer
    length.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following screenshot, you can see a call to `lstrlenA` in order to calculate
    the length of the source buffer and store the length in `iVar1`, following an
    `if` condition taking into account the value of `iVar1` and finally the unsafe
    function `lstrcpyA`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.14 – Some length checks before the call to _strcpy'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16207_08_014.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.14 – Some length checks before the call to _strcpy
  prefs: []
  type: TYPE_NORMAL
- en: A very efficient technique to find vulnerabilities is called **fuzzing**. It
    consists of monitoring the target application and sending data to it, expecting
    the program to crash for some given input.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, when the program crashes, you can start a debugging session on the
    target and analyze what happens when this input is given to the program. Ghidra
    can be a useful companion to your favorite debugger in this situation because
    you can rename variables and show the decompiled code, basically, offering support
    for issues that the debugger lacks.
  prefs: []
  type: TYPE_NORMAL
- en: Fuzzing is very easy to understand but is a very complex topic because it is
    difficult to develop an efficient fuzzer. When developing a fuzzer, you have to
    choose whether it is better to generate program inputs from scratch or take an
    existing input (for example, a PDF file) and mutate it. If you decide to generate
    inputs, you will need to generate inputs that are likely to crash the program.
    On the other hand, if you mutate an existing input, you will need to guess what
    portions are likely to crash the program when being mutated. There is not currently
    a strong mathematical basis to make this decision, so it is hard and very empirical-based.
  prefs: []
  type: TYPE_NORMAL
- en: Exploiting a simple stack-based buffer overflow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will cover exploiting. It consists of writing a program
    or a script that takes advantage of a vulnerability.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, we will exploit our stack overflow sample application to execute
    arbitrary code on the system. The following code is what we want to exploit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the `–m32` flag of the MinGW64 compiler, we compile the code for the
    x86 architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can check that it works correctly when the first argument is short:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can check that it works correctly when the first argument is short
    but crashes when the argument is long because the stack overflow vulnerability
    is triggered:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.15 – Triggering the overflow to cause Denial of Service (DoS)'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16207_08_015.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.15 – Triggering the overflow to cause Denial of Service (DoS)
  prefs: []
  type: TYPE_NORMAL
- en: 'To exploit a stack overflow vulnerability, you will need to do two things:'
  prefs: []
  type: TYPE_NORMAL
- en: Take control of the program flow in order to redirect it to your malicious code
    (also known as the payload or shellcode).
  prefs: []
  type: TYPE_NORMAL
- en: Inject the malicious code you wanted to execute (or reuse existing code).
  prefs: []
  type: TYPE_NORMAL
- en: 'We know from the decompiled code of the binary that the buffer is 212 bytes
    in size, so we can write 212 characters without triggering the stack-based overflow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Since `strcpy` uses the `cdecl` calling convention, `EBP` will be removed from
    the stack by the function, so 4 bytes will be removed from the stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.16 – Ghidra identifying the cdecl calling convention for strcpy'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16207_08_016.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.16 – Ghidra identifying the cdecl calling convention for strcpy
  prefs: []
  type: TYPE_NORMAL
- en: 'We can adapt the payload by subtracting 4 bytes corresponding to `EBP` from
    our padding of A''s and adding 4 bytes of B''s to overwrite the return address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'If we continue overwriting, due to the `CALL` instruction executed by the caller,
    which places the address of the next instruction to execute onto the stack, we
    will be able to control the program flow, accomplishing our first goal. So, we
    will be able to overwrite the `EIP` register with an arbitrary value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The complete **Probe of Concept** (**PoC**) Python code looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that it works correctly because the `EPB` register was overwritten
    by `0x42424242`, which is the ASCII representation of `BBBB`, and the `EIP` register
    was also overwritten by `0x43434343`, which is the ASCII representation of `CCCC`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.17 – Investigating the buffer overflow crash with a debugger'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16207_08_017.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.17 – Investigating the buffer overflow crash with a debugger
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, as the payload, I will use the following shellcode, which spawns a calculator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Please, never execute shellcode without knowing what it does. It could be malware.
    Instead, dump the shellcode to a file using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Import the resulting `shellcode.bin` fille to Ghidra, choosing an adequate
    language. In this case, the adequate assembly language is **x86:LE:32:System Management
    Mode: default**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.18 – Importing the shellcode to Ghidra'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16207_08_018.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.18 – Importing the shellcode to Ghidra
  prefs: []
  type: TYPE_NORMAL
- en: 'Press the *D* key while focusing on the first byte of the shellcode:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.19 – Converting shellcode bytes to code'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16207_08_019.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.19 – Converting shellcode bytes to code
  prefs: []
  type: TYPE_NORMAL
- en: 'And try to understand what the shellcode is doing. In this case, it spawns
    a calculator:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.20 – Analyzing the shellcode'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16207_08_020.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.20 – Analyzing the shellcode
  prefs: []
  type: TYPE_NORMAL
- en: 'The chosen strategy to execute the shellcode, in this case, will be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Put the shellcode at the beginning, letting it be at the top of the stack, which
    is pointed to by the `ESP` register. We know the value of `ESP` because we see
    it in the debugger, `0x0028FA08` (we have to put the value in reverse order due
    to the endianness and also can omit the byte zero).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, add the padding in order to trigger the stack overflow, and after, let's
    place the value of `ESP` because `EIP` will be overwritten with this value, triggering
    the execution of our shellcode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following code implements the aforementioned strategy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let''s execute the exploit and see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.21 – Executing the exploit'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16207_08_021.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.21 – Executing the exploit
  prefs: []
  type: TYPE_NORMAL
- en: It works as expected. The calculator was successfully spawned.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use Ghidra to manually analyze program binaries
    to find bugs. We started by talking about memory corruption vulnerabilities. Next,
    we talked about how to find them and how to exploit them.
  prefs: []
  type: TYPE_NORMAL
- en: You learned how to look for vulnerabilities in both source code and assembly
    code. Finally, you learned how to develop a simple stack-based overflow exploit
    and how to dump shellcode to disk in order to analyze it.
  prefs: []
  type: TYPE_NORMAL
- en: The knowledge acquired in this chapter will allow you to look for software vulnerabilities
    even if the source code is not available. After identifying a vulnerability, you
    will be able to exploit it. On the other hand, when using exploits developed by
    a third party, you will be able to understand them and decide whether it is safe
    to execute the exploit or not by analyzing the shellcode.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter of this book, we will cover scripting a binary audit using
    Ghidra. You will learn the power of PCode intermediate representation, a very
    important feature of Ghidra that makes the tool different from its competitors.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Is memory corruption a unique type of software vulnerability? State some types
    of memory corruption vulnerability not covered here and explain them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is `strcpy` considered an unsafe function?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: State three binary protection methods that prevent memory corruption exploitation.
    Is it impossible to exploit software when it's protected with these mechanisms?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can refer to *Penetration Testing with Shellcode*, *Hamza Megahed*, *February
    2018* for more information on topics covered in this chapter: [https://www.packtpub.com/eu/networking-and-servers/penetration-testing-shellcode](https://www.packtpub.com/eu/networking-and-servers/penetration-testing-shellcode)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Common Weakness Enumeration** (**CWE**). CWE-14: Compiler Removal of Code
    to Clear Buffers. [https://cwe.mitre.org/data/definitions/14.html](https://cwe.mitre.org/data/definitions/14.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
