- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Childproofing the Solution: Protection from the End-User and Their Environment'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will give you a crash course on child-proofing your appliance while
    ensuring a positive customer experience. Yeah. Both must be done in parallel.
    Delivering a masterful UI is absolutely a challenge that will require a little
    extra effort in the solution’s development. Just know in advance that your efforts
    here will pay back in adoption rates exponentially.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn crucial information like why locking the end-user
    out of the operating system is crucial to security. Additionally, you will gain
    an understanding of some key security concerns at the hardware level. We shall
    also review where the hosted applications themselves are solely what the end-users
    really need to access. Finally, we’ll wrap up the chapter by providing you with
    a deeper understanding of UI design implications that can enhance your appliance’s
    chances for success.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter has the following main headings:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to childproofing (i.e., protecting the appliance from the end-user)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensuring hardware-level protections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operating-system-level and application protections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a UI to simplify configuration while providing a great User Experience
    (UX)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to child-proofing (i.e., protecting the appliance from the end-user)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How to perform **child-proofing** of an appliance prototype is definitely one
    of my favorite conversations to have with product teams. Please indulge me and
    allow me to elaborate. This process may be the single greatest factor in determining
    what meets the definition of an appliance. All efforts to keep the final solution
    secure and focused solely on its predetermined function are crucial. The end-users
    must be properly guided on the initial setup requirements and kept within your
    guardrails of what you choose to allow them to access beyond the application/function
    of the appliance.
  prefs: []
  type: TYPE_NORMAL
- en: There are many efforts to be considered here. How will my product’s end-users
    actually access the solution? What can be done to minimize or prevent any end-user
    from obtaining unauthorized elevated or root access? What automation will need
    to be put in place and obscured via the appliance’s UI?
  prefs: []
  type: TYPE_NORMAL
- en: A prime example of what I am describing here is preventing the end-user from
    leveraging an escape key sequence to *escape* from your application regardless
    of whether it is console-based or graphical. I call this *No Escape!* This is
    achieved through thoughtful modification of the general console settings or editing
    a keymap. Of all the possible guardrails we will cover in this chapter, I consider
    this a mandatory first step.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s proceed onward to securing hardware access.
  prefs: []
  type: TYPE_NORMAL
- en: Ensuring hardware-level protections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Okay, I know that we’ve discussed this before, in [*Chapter 8*](B22104_08.xhtml#_idTextAnchor248)
    ... I feel that I must remind you that this is real. Ensuring that the end-user
    cannot change the configuration is key here. You have two main responsibilities
    in this realm. The first responsibility is the securing of the solution and the
    second responsibility is prevention of the end-user from controlling the operating
    system. By achieving both, you guarantee that your team controls the end-user
    experience.
  prefs: []
  type: TYPE_NORMAL
- en: If you create a user interface that simplifies how your appliance can operate
    securely, ultimately the appliance will be easy to use yet the end-user need not
    know how it works. I implore you to consider all these factors. Remove the end-user
    from all access to the operating system.
  prefs: []
  type: TYPE_NORMAL
- en: Create an experience where the end-user can trust that you have achieved, above
    all else, a secure but user-friendly platform. This is truly the field of dreams.
    This is what we all aspire to create. This should be our legacy.
  prefs: []
  type: TYPE_NORMAL
- en: Hardware security is something we have covered in quite some depth. Yet still,
    I feel that we must revisit this conversation, if just briefly. So, let’s dive
    in. Forgive me in advance, but I will reiterate a few details in this chapter.
    This is meant to protect you and your solution. So, let’s now move on to how to
    properly configure your BIOS settings.
  prefs: []
  type: TYPE_NORMAL
- en: Tamper-proofing with BIOS security
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, I want to reinforce what I have been building upon for many
    chapters up to this point. Choose your security settings carefully. Please understand
    the pros and cons of each configuration option. Not every setting will offer the
    best outcome. Some, if not most, have caveats as we have reviewed and we shall
    continue to dive deeper.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing to lock down the BIOS admin password is a double-edged sword. Yes,
    you can completely ensure that the end-user cannot change anything in the BIOS…
    But… That also ensures that your support team is in the business of replacing
    a unit – not servicing it remotely. Feel free to revisit [*Chapter 8*](B22104_08.xhtml#_idTextAnchor248)
    if you need more ideas on BIOS and boot security functions.
  prefs: []
  type: TYPE_NORMAL
- en: This is where your support plan is crucial. Know what it is and own it. Let’s
    move on to the next hardware security option.
  prefs: []
  type: TYPE_NORMAL
- en: USB disablement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I’m on the fence about this security precaution and method of tamper-proofing
    and I’ll elaborate why. Disabling the USB ports on a system, whether through a
    BIOS setting or via the operating system, can be an elaborate security measure
    or one that perpetually guarantees your support model is not one of troubleshooting
    but of direct replacement. Elimination of the ability to connect a device (like
    a USB thumb drive) adds another layer of security by preventing data transfer,
    unauthorized booting to a different OS, or the running of code on the device that
    your team has never authorized.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing this level of security is a significant decision. Or… Maybe it’s not.
    For some solutions, the decision to disable USB is a no-brainer. Let’s use a couple
    of examples here to state a case for the disablement of any possible external
    USB ports on the chassis of the solution.
  prefs: []
  type: TYPE_NORMAL
- en: The first example is a hypothetical mobile ventilator used by hospitals and
    ambulance crews and with other installations across the healthcare industry. It
    has an LED display and all of its controls are built into a touch screen. Disabling
    the USB ports is a pure tamper-proofing effort. As most of these ventilators might
    never be attached to a network or be left waiting in hallways and closets for
    that all-too-crucial moment when their services are needed, tamper-proofing is
    critical. These machines are subject to government scrutiny and certification.
    So, updates are left to trained personnel anyway.
  prefs: []
  type: TYPE_NORMAL
- en: My second hypothetical example is a visual targeting system in a military vehicle.
    This appliance has its own display and custom hardwired controls. USB disablement
    is implied as this appliance will never be updated nor maintained in the field
    and will only receive service from trained engineers when the vehicle itself goes
    into the maintenance depot by those who work for the firm that built the solution.
    Field soldiers have no access, nor should they have access to the underlying system.
  prefs: []
  type: TYPE_NORMAL
- en: So that’s plenty of reasons in the *pro* bucket. Here’s a couple for the *con*
    bucket. I’ll use the example of a medical imaging system. It could be an MRI or
    a CAT scanner – one of those hypotheticals. These are complex yet very well-maintained
    systems. They must be. They are not maintained by the hospitals that own (or lease)
    them. Regular maintenance is part of the support agreement when one acquires such
    an expensive toy. On average, these complex solutions are maintained on a monthly
    or quarterly schedule by field engineers who are sent by the manufacturer. These
    support engineers will absolutely need USB access to run diagnostics, patching
    operations, etc. The hospital staff is not remotely involved in this and these
    systems are kept in secure rooms with limited access, so tampering is far less
    of a concern.
  prefs: []
  type: TYPE_NORMAL
- en: My second example is a patient monitoring solution appliance for healthcare
    that requires a persistent connection with a keyboard, mouse, and, more importantly,
    a specified USB speaker that is used to alert the nurses at the nurses’ station.
  prefs: []
  type: TYPE_NORMAL
- en: My final example against the disabling of USB ports applies to any physical
    appliance where perhaps the normal UI is delivered through a kiosk-like touch
    screen. If there is to be any support activity on said device, a physical keyboard
    and mouse may be needed to simply navigate the interface until help from support
    can remediate a situation. This is just an oversimplification of how I believe
    that, at a minimum, allowing for a keyboard and mouse to connect may always be
    necessary.
  prefs: []
  type: TYPE_NORMAL
- en: For this set of security precautions, I trust that you and your team will weigh
    the pros and cons. Let’s move on to the next tamper-proofing option.
  prefs: []
  type: TYPE_NORMAL
- en: Case tamper-proofing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is an option with limited value in the end game. Very few hardware manufacturers
    have enabled this level of detail. To determine if your end-user has actually
    opened a case without your permission or guidance is an effort in futility.
  prefs: []
  type: TYPE_NORMAL
- en: I say, who cares if they open up the system’s case? If your team has properly
    locked down the operating system and the BIOS, there’s little, if anything, a
    malicious actor can do to break the system. They surely will not be able to add
    new hardware without your help. Nor should they ever be allowed to do so.
  prefs: []
  type: TYPE_NORMAL
- en: At best, this will only be highlighted when the case has been *opened* by displaying
    a message at the system’s boot time (assuming one can even see the console) ...
    For this type of lockdown, if your hardware even supports it, you (and your team)
    wouldn’t know, and the end-user might have the ability to erase this altogether
    from any logs if, in fact, there is nothing preventing them from entering and
    altering the BIOS settings.
  prefs: []
  type: TYPE_NORMAL
- en: Oddly enough, this is where technology vendors could take a hint from the transportation
    industry – more specifically, trucking and shipping. Your enclosure will require
    something like a lock or anti-tamper clamp or numbered tag to prevent the end-user
    from opening the case (somewhat). Some examples are easily obtained via Amazon.
    Anything like this could greatly enhance and protect your product from being tampered
    with. I would recommend having something like the examples custom-made. You should
    consider two pieces of information to be placed on the tag itself. First, place
    a serial number that you track internally that is bound to the hardware that you
    sold that customer. Secondly, have a warning that breaking the seal invalidates
    any warranties (for your protection).
  prefs: []
  type: TYPE_NORMAL
- en: 'Examples from Amazon:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Steel Security Cable Seal – Amazon: [https://www.amazon.com/dp/B0CTJZL4QX/ref=sspa_dk_detail_1?pd_rd_i=B0CTJZL4QX&pd_rd_w=2YM0o&content-id=amzn1.sym.8c2f9165-8e93-42a1-8313-73d3809141a2&pf_rd_p=8c2f9165-8e93-42a1-8313-73d3809141a2&pf_rd_r=TAADTD9FHXQ62YCV3V3W&pd_rd_wg=IKKNk&pd_rd_r=cf146379-ab39-49c5-bb8a-048e05de0a7b&s=office-products&sp_csd=d2lkZ2V0TmFtZT1zcF9kZXRhaWw&th=1](https://www.amazon.com/dp/B0CTJZL4QX/ref=sspa_dk_detail_1?pd_rd_i=B0CTJZL4QX&pd_rd_w=2YM0o&content-id=amzn1.sym.8c2f9165-8e93-42a1-8313-73d3809141a2&pf_rd_p=8c2f9165-8e93-42a1-8313-73d3809141a2&pf_rd_r=TAADTD9FHXQ62YCV3V3W&pd_rd_wg=IKKNk&pd_rd_r=cf146379-)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Locking tags for Containers, Cargo... – Amazon: [https://www.amazon.com/Numbered-Security-Anti-Tamper-Self-Locking-Container/dp/B07QXWS9DV/ref=asc_df_B07QXWS9DV/?tag=hyprod-20&linkCode=df0&hvadid=693270340443&hvpos=&hvnetw=g&hvrand=8112534262958122670&hvpone=&hvptwo=&hvqmt=&hvdev=c&hvdvcmdl=&hvlocint=&hvlocphy=9001911&hvtargid=pla-757440487320&mcid=3443569f9f6738f8a4a870639b788988&th=1](https://www.amazon.com/Numbered-Security-Anti-Tamper-Self-Locking-Container/dp/B07QXWS9DV/ref=asc_df_B07QXWS9DV/?tag=hyprod-20&linkCode=df0&hvadid=693270340443&hvpos=&hvnetw=g&hvrand=8112534262958122670&hvpone=&hvptwo=&hvqmt=&hvdev=c&hvdvcmdl=&hvlocint=&h)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As there are a few ways of tamper-proofing your case and protecting the hardware
    itself, I will humbly acknowledge that not all methods may be appropriate for
    your solution. Choose wisely. Let’s now move forward to how you might look into
    locking down the operating system for your solution.
  prefs: []
  type: TYPE_NORMAL
- en: Operating-system-level and application protections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Right, here’s where things might get a wee bit complicated. I know you may
    feel a bit of apprehension when I make such a statement. So, with that in mind,
    I offer this disclaimer: I do not know your application. How could I? I (and you)
    must trust that your team does.'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, I am going to challenge you and your team to build a comprehensive
    interface that isn’t just for your application but user access, updates, etc.
    The more that you can obscure with your application/user interface the more secure
    your appliance will be. This, along with the next few sections, are dedicated
    to how you can make that happen. This challenge I present to you may ultimately
    determine the success or failure of your product. The more effort you put forth
    in providing a rich and enjoyable user experience, the more likely the end customers
    are to applaud your product and adopt it wholesale.
  prefs: []
  type: TYPE_NORMAL
- en: These actions are not just for security but can absolutely create a rich and
    enjoyable end-user experience. Let’s dive into a few of these factors now.
  prefs: []
  type: TYPE_NORMAL
- en: Minimizing access to root
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By definition, an appliance should be easy to use but not require the end-user
    to be vastly skilled in the intricacies of managing the application nor the operating
    system. These factors are implied. If the end-user’s organization had the skills
    (or the desire) to maintain such solutions, they ultimately would have built them
    themselves.
  prefs: []
  type: TYPE_NORMAL
- en: Hence, my recommendations are brutally prescriptive in this thought process.
    I cringe as I write this, yet I feel that you should adopt this mentality as well.
    It will ultimately protect your support team from countless unnecessary calls.
    Tamper-proof your solution. Yes, I just said it. The more you prevent the end-user
    from directly accessing the operating system, the more secure your solution will
    be.
  prefs: []
  type: TYPE_NORMAL
- en: Failing to do so and an end-user acquiring root access could create a significant
    emotional event for your appliance. At this point, they can do anything they want
    with your appliance. Shall I list some of the horrors that could be created? Oh,
    yes. I shall.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have an end-user that has root access, they could possibly carry out
    any of the following acts with or without malicious intent:'
  prefs: []
  type: TYPE_NORMAL
- en: Add or remove software
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Alter the system’s configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add or remove users from the system or applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remove security precautions or configurations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Alter or delete logs to cover their tracks (or delete logging altogether)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make a change in the system that renders your appliance unusable for the purpose
    it was procured for
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I haven’t even really mentioned the truly evil, malicious activities that could
    possibly occur. For those, I will allow your imagination to roam free. Enjoy!
    Perhaps now you understand why I implore you and your team to take every reasonable
    step to protect your solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Regardless of how your solution is accessed or interacted with, having these
    settings obscured from all end-users and handled behind the scenes will guarantee
    the security and stability (hopefully the longevity too) of your solution.
  prefs: []
  type: TYPE_NORMAL
- en: SUDO and restricting console access
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Depending on how exactly your solution is designed and implemented, this next
    recommendation may not be feasible. Well… at least as it might have been originally
    envisioned. Please open your mind. I’m trying to save you from future pain.
  prefs: []
  type: TYPE_NORMAL
- en: This is where I’m going to reiterate some best practices that I hope you already
    know. Minimize or totally eliminate end-user access directly to the operating
    system. An appliance *SHOULD* be a black box. The end-users should only have access
    to the services for which the solution was designed to create, along with any
    administrative tasks not already automated by the solution.
  prefs: []
  type: TYPE_NORMAL
- en: For the administrative tasks, I feel it is paramount to obscure and remove the
    end-user from directly accessing operating system too. Giving your user base root
    access will literally ensure that, at some point, some malicious (or accidental)
    end-users will break something intentionally, reverse engineer the solution, or
    – even worse – reconfigure the system to do malicious activities.
  prefs: []
  type: TYPE_NORMAL
- en: So, how can we achieve this? It’s not difficult actually. Behind your graphical
    or web UI, have scripts that are run as a non-root user account that has restricted
    sudo capabilities. That’s the easiest way to keep the user out of the OS or the
    shell.
  prefs: []
  type: TYPE_NORMAL
- en: But what if the end-user can log into the system and has terminal access...
    Limit what they can see. Limit what they can execute. Ensure that what they are
    allowed to execute is controlled by ACLs, SUID, SGID, and other mechanisms set
    within the files’ permissions. Furthermore, I would present a limited interface
    (even if shell-based) to any user who has access to the system, with the only
    exception being the access you have created for your support personnel (if any).
  prefs: []
  type: TYPE_NORMAL
- en: In this, the end-user can be seen as an enemy – willing or accidental. Hence,
    every effort that you can create within your interfaces to prevent direct operating
    systems access should be seen as mandatory. Let’s move on.
  prefs: []
  type: TYPE_NORMAL
- en: Non-interactive LUKS encryption
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have covered several ways of ensuring disk encryption (without end-user interaction)
    extensively in *Chapters 6* and *7*; however, I would feel remiss in not mentioning
    it again, as this is also seen as another way to child-proof one’s solution.
  prefs: []
  type: TYPE_NORMAL
- en: In using automated disk encryption, you take the responsibility out of the end-user’s
    hands, along with the access to alter it maliciously. Not automating this creates
    a poor end-user experience and leaves your solution vulnerable. As I know that
    you already understand my point, I’ll say let’s move on.
  prefs: []
  type: TYPE_NORMAL
- en: Keeping users in the application space
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What does he mean by keeping the users in the application space? Good question.
    For that, I have a great recommendation. Please allow me to elaborate.
  prefs: []
  type: TYPE_NORMAL
- en: Another great way of ultimately preventing your application or your end-users
    from compromising the operating system is to keep all the end-users as application-level
    users, not operating-system-level users. In doing this, your applications’ interface
    is all they can interact with – forever. By this, I mean the end-user only has
    a user account in your application stack, which is controlled by the application,
    not within Linux itself. This prevents the end-user from ever accessing a command-line
    shell.
  prefs: []
  type: TYPE_NORMAL
- en: Think of this in the same manner as application sandboxing... but we’re doing
    it with the end-users... It’s a great layer of separation that adds a protective
    layer of security to your solution.
  prefs: []
  type: TYPE_NORMAL
- en: Application auto-launch at boot
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ensuring that your interface and applications automatically start up at boot
    is assumed, but I recommend taking it a step further. Run them with **systemd**
    as a non-root user.
  prefs: []
  type: TYPE_NORMAL
- en: Here’s an example of how to set up systemd and `myapplication`. Enabling linger
    allows for the application or service to run appropriately under a non-root user’s
    login without interactions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start and enable your application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'To ensure the service runs even when the `$USER` is not logged in, we’ll need
    to use `linger`. Remember that `$USER` is the user account you want to run your
    applications/services: as.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now your application will run as the defined user at each startup sequence without
    any elevated or root access. By employing the customizations detailed in this
    section, we’ve taken more steps to ensure system security and stability. Now let’s
    move on and look into how we can provide a great user experience whilst ensuring
    security.
  prefs: []
  type: TYPE_NORMAL
- en: Building a UI to simplify configuration while providing a great User Experience
    (UX)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At some point, your prospective customers have made the executive decision to
    seek a commercially ready solution to a problem that they have encountered. This
    fateful decision was whether to build a solution in-house versus buying one built
    by someone else. This truly is an important fact to keep in mind. At some point
    – hopefully soon – someone will choose to buy your future product!
  prefs: []
  type: TYPE_NORMAL
- en: 'Honor those who make that decision by giving them a positive and rewarding
    **User Experience** (**UX**). Delivering them a secure solution is simply implied.
    They have placed their trust in your company even more if your solution is a security-services-focused
    appliance. Trust, in this case, also equals responsibility. Your team is responsible
    for creating an appliance that doesn’t need the customers’ IT staff to be rocket
    scientists, or perhaps even an IT staff at all, to assist with the consumption
    of services from your solution. I challenge you to go beyond that and deliver
    to the end-customers an interface that goes above and beyond in the following
    areas:'
  prefs: []
  type: TYPE_NORMAL
- en: Exceeds all expectations in terms of intuitiveness (i.e., the users can navigate
    with ease)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provides the proper number of details to the end-user and doesn’t over-burden
    them with administration concerns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accounts for all support and configuration needs that could arise so as the
    end-user should never need to get direct access to the operating system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provides the end-users with the ability to consume the appliance’s functionality
    without extensive training
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A secure and successful appliance experience can be highlighted by how much
    planning and automation goes into its interface. These decisions are made early
    in the design phase and are implemented here. Regardless of how the user interacts
    with the appliance, obscuring or totally removing the operating system from the
    user base is crucial. Let’s explore some examples of both text and web UI’s.
  prefs: []
  type: TYPE_NORMAL
- en: Initial config – text UI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this set of example screens, I’ll be showing you a bare-bones text UI for
    an initial configuration of an appliance. For argument’s sake, let’s assume the
    end-user has a keyboard connected and has console access.
  prefs: []
  type: TYPE_NORMAL
- en: For this type of initial configuration UI, you’ll need to set, at minimum, a
    non-root user for them to log in as and, hopefully, upon the login as this user,
    they are given only the ability to run this simple setup utility.
  prefs: []
  type: TYPE_NORMAL
- en: Our first screenshot here simulates a welcome screen for the end-user. You may
    also want to add in other friendly messages like *Thank you for choosing us…*
    or something similar.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.1 – Text UI – welcome screen](img/B22104_10_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.1 – Text UI – welcome screen
  prefs: []
  type: TYPE_NORMAL
- en: Once past the welcome screen, the end-user would be presented with a main menu
    of configuration options.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.2 – Text UI – main menu](img/B22104_10_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.2 – Text UI – main menu
  prefs: []
  type: TYPE_NORMAL
- en: Let’s also assume this appliance serves some function on a network. So, let’s
    help the end-user define the network settings. They will simply give the attribute
    values and your automation behind the scenes is what really makes the configuration
    changes, limiting what the end-user can access and do – no root access.
  prefs: []
  type: TYPE_NORMAL
- en: So, these next few screens will show the interactions where the end-user defines
    the network settings and is eventually asked to confirm them so they can be saved
    and applied.
  prefs: []
  type: TYPE_NORMAL
- en: The first setting the user may be prompted for is the appliance’s hostname.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.3 – Text UI – network configuration – start](img/B22104_10_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.3 – Text UI – network configuration – start
  prefs: []
  type: TYPE_NORMAL
- en: 'As we continue further into the network configuration, IP addressing begins:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.4 – Text UI – network configuration – in progress](img/B22104_10_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.4 – Text UI – network configuration – in progress
  prefs: []
  type: TYPE_NORMAL
- en: There are more network settings as we progress. Here, we are displaying a few
    more settings inward where netmask and DNS settings can be configured.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.5 – Text UI – network configuration – continued](img/B22104_10_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.5 – Text UI – network configuration – continued
  prefs: []
  type: TYPE_NORMAL
- en: Next, as best practice, we shall always prompt them to confirm (or cancel) at
    the end before the settings are committed to the running configuration.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.6 – Text UI – network configuration – confirmation](img/B22104_10_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.6 – Text UI – network configuration – confirmation
  prefs: []
  type: TYPE_NORMAL
- en: Now your automation behind the scenes is doing the actual configuration work.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.7 – Text UI – network configuration – execution behind the scenes](img/B22104_10_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.7 – Text UI – network configuration – execution behind the scenes
  prefs: []
  type: TYPE_NORMAL
- en: So, there you have it – a simple network configuration for a text-based appliance.
    Try to keep things as simple as possible yet consider adding all facets of your
    appliance’s usage and configuration to such a menu system. Obscure all operating
    system operations, whilst protecting the system from the end-user as well.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s move on to what a simulated minimal web configuration interface may look
    like.
  prefs: []
  type: TYPE_NORMAL
- en: Initial config – web UI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Web-based interfaces allow for a much more aesthetically pleasing experience
    but require more programming. You’ll still be collecting the same information
    as the text UI did but instead of instantly calling sudo scripts, the web UI will
    leverage sudo scripts called by `cgi-bin GET` or `POST` operations. I’m not remotely
    going to teach you how to program webpages as there are literally hundreds of
    books that could do a better job at that than I could.
  prefs: []
  type: TYPE_NORMAL
- en: I will, however, mention that for the initial configuration, you should consider
    leveraging a pre-defined and documented IP address for the new end-user to access
    your initial setup pages.
  prefs: []
  type: TYPE_NORMAL
- en: In the new few screenshots, we’ll be looking at a simulated walk-through of
    a simplified web UI for the initial appliance configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with a welcome webpage. Greet your new customer and let them know
    the system is working! This page politely indicates that we will need to do some
    basic configuration work before the end-user can begin to consume the services
    this appliance provides.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.8 – Web UI – welcome screen](img/B22104_10_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.8 – Web UI – welcome screen
  prefs: []
  type: TYPE_NORMAL
- en: From the welcome page, we select **Start Initial Configuration** and enter a
    simulated main menu with simple navigation selections available on a sidebar.
    From here, the end-user is presented with several obvious options that should
    also remain available beyond the initial configuration event.
  prefs: []
  type: TYPE_NORMAL
- en: In this main configuration menu, the end-user will have some key options that
    should be planned for accordingly – administrative access, user access, network
    configuration, factory reset, and, of course, a way to process updates.
  prefs: []
  type: TYPE_NORMAL
- en: As the end-user is anxious to get started using this appliance, logical first
    steps include guiding the end-user to set an admin password and then configure
    the networking/hostname.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we’ll see what a simplified web-based UI for an appliance’s
    administration main menu should contain at a minimum.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.9 – Web UI – main appliance configuration menu](img/B22104_10_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.9 – Web UI – main appliance configuration menu
  prefs: []
  type: TYPE_NORMAL
- en: Assume that we had selected **Network Configuration** here and we want to set
    up the basic networking settings for this appliance. Basic needs for this type
    of initial configuration should always include not just network configuration
    but also having the ability for the end-user to assign a proper hostname so that
    the system can also be referenced by their own DNS systems.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B22104_10_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Fig 10.10 – Web UI – network configuration
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve guided our new end-user through a crisp basic appliance configuration
    process, they can leverage your product for all the great services it provides
    them. Eventually, as with any computer system nowadays, the appliance will require
    patching and updates, which leads us to our next section.
  prefs: []
  type: TYPE_NORMAL
- en: Update controls – text UI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Your appliance’s end-user experience would not be complete unless you add in
    a method for the appliance to get updated. By updates, I refer to operating systems
    bug fixes and enhancements, application patches and enhancements, new features,
    and even firmware updates if your solution is physical.
  prefs: []
  type: TYPE_NORMAL
- en: Creating this type of interface also creates a boundary layer from what the
    end-user can do and what the appliance can do for itself. We must remove any possible
    need or excuse for any end-user to demand access directly to the operating system
    itself.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the use case and deployment methodology, the interface should account
    for how updates are to be presented. Air-gapped systems will not be able to go
    out to the internet and check for their updates, so the interface should be able
    to ingest updates alternatively. USB thumb drives, tarballs, and ISO images are
    all examples of ways that one could deliver updates to the end-user, however,
    the end-user would then need to deliver them to the interface and the appliance
    should process them without the end-user having access to the operating system.
  prefs: []
  type: TYPE_NORMAL
- en: Here’s an example of what appliance update controls may look like in a text
    UI, where the appliance has access to the internet to check for its updates.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.11 – Text UI update menu](img/B22104_10_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.11 – Text UI update menu
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we’ve addressed the fundamental needs of being able to provide updates
    to our appliances, we can move on to our next crucial end-user function: appliance
    resets.'
  prefs: []
  type: TYPE_NORMAL
- en: Factory reset controls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Every good appliance should have a way of resetting itself back to its factory-new
    persona. Creating this experience for the end-users will also make it much simpler
    for them to reprovision an appliance onto a different network or location within
    their organization, by removing any stored application data or previous configuration.
    This type of functionality also gives the customers peace of mind that their possibly
    sensitive data has been erased if they are shipping a unit back to your company.
    The next screenshots will show examples of what this could look like on a text
    UI and webpage.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with an example web UI reset function page. This page would present
    a two-step process that ensures they really know that the machine will go back
    to a brand-new state (all data and configuration erased). To achieve this state,
    they would first have to check the checkbox in the interface and then press the
    **RESET** button.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: I would also recommend having a pop-up window asking them to confirm that yet
    again if you really want to be user-friendly.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.12 – Webpage factory reset example](img/B22104_10_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.12 – Webpage factory reset example
  prefs: []
  type: TYPE_NORMAL
- en: And here’s an example reset in a text UI. The end-user is presented with a prompt
    to confirm that they really want to reset the appliance back to its factory-new
    configuration and erase all data. Just like with the web example shown previously,
    they always have the ability to simply cancel the operation.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.13 – Example factory reset in text UI](img/B22104_10_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.13 – Example factory reset in text UI
  prefs: []
  type: TYPE_NORMAL
- en: I trust that these simulations of functions needed in your future UI have been
    insightful. Yours, of course, will obviously look far more refined and be well
    in line with your company’s branding guidelines for your products. By establishing
    a secure UI/end-user environment, you’ve ensured another factor of security for
    your solution – tamper-proofing. Let’s now move on to our end-of-chapter summary.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Thanks again for driving onward on this journey with me. In this chapter, we’ve
    reviewed why locking down our appliances is vital. We have recapped some hardware
    and storage security options to consider. Best of all, we’ve identified key ways
    of ensuring a great user experience while maintaining security by obscuring the
    operating system access away from the end-user.
  prefs: []
  type: TYPE_NORMAL
- en: In our next chapter, we’ll take a deep dive into all the available informational
    resources that can help you and your team stay ahead of the threat landscape.
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 3: The Build Chain, Appliance Lifecycle, and Continuous Improvement'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this part, we’ll review additional hardening processes for your appliances
    and explore how to apply some crucial government security standards to systems
    and how best to capture information from all avenues to continuously improve your
    appliances throughout their lifecycle.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part has the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 11*](B22104_11.xhtml#_idTextAnchor339), *Knowing the Threat Landscape
    – Staying Informed*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 12*](B22104_12.xhtml#_idTextAnchor364), *Are My Devices’ Communications
    and Interactions Secure?*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 13*](B22104_13.xhtml#_idTextAnchor400), *Applying Government Security
    Standards – System Hardening*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 14*](B22104_14.xhtml#_idTextAnchor430), *Customer and Community Feedback
    Loops*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
