<html><head></head><body><div class="chapter" title="Chapter&#xA0;7.&#xA0;Using Python for Memory Forensics"><div class="titlepage"><div><div><h1 class="title"><a id="ch07"/>Chapter 7. Using Python for Memory Forensics</h1></div></div></div><p>Now that you have performed investigations in the infrastructure (refer to <a class="link" href="ch04.html" title="Chapter 4. Using Python for Network Forensics">Chapter 4</a>, <span class="emphasis"><em>Using Python for Network Forensics</em></span>), common IT equipment (refer to <a class="link" href="ch03.html" title="Chapter 3. Using Python for Windows and Linux Forensics">Chapter 3</a>, <span class="emphasis"><em>Using Python for Windows and Linux Forensics</em></span>), and even in the virtualized (refer to <a class="link" href="ch05.html" title="Chapter 5. Using Python for Virtualization Forensics">Chapter 5</a>, <span class="emphasis"><em>Using Python for Virtualization Forensics</em></span>) and mobile worlds (refer to <a class="link" href="ch06.html" title="Chapter 6. Using Python for Mobile Forensics">Chapter 6</a>, <span class="emphasis"><em>Using Python for Mobile Forensics</em></span>), in this chapter, we will show you how to investigate in volatile memory with the help of Volatility, a Python-based forensics framework, on the following platforms:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Android</li><li class="listitem" style="list-style-type: disc">Linux</li></ul></div><p>After showing you some basic Volatility plugins for Android and Linux and how to get the required RAM dump for analysis, we will go hunting for malware in RAM. Therefore, we will use YARA rules—based on pattern matching—and combine them with the power of Volatility.</p><div class="section" title="Understanding Volatility basics"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec30"/>Understanding Volatility basics</h1></div></div></div><p>In general, memory <a id="id403" class="indexterm"/>forensics follow the same pattern as other forensic investigations:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Selecting the target of the investigation.</li><li class="listitem">Acquiring forensic data.</li><li class="listitem">Forensic analysis.</li></ol></div><p>In the previous chapters, we already presented various technologies on how to select the target of an investigation, for example, starting from the system with unusual settings in the virtualization layer.</p><p>The acquisition of forensic data for memory analysis is highly dependent on the environment and we will discuss it in the <span class="emphasis"><em>Using Volatility on Linux</em></span> and <span class="emphasis"><em>Using Volatility on Android</em></span> sections of this chapter.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip15"/>Tip</h3><p>
<span class="strong"><strong>Always consider the virtualization layer as data source</strong></span>
</p><p>Acquisition of memory from a running operating system always requires administrative access to this system and it is an intrusive process, that is, the process of data acquisition changes the memory data. Moreover, advanced malware is capable of manipulating the memory management of the operation system to prevent its acquisition. Therefore, always check and try to acquire the memory on the hypervisor layer as described in <a class="link" href="ch05.html" title="Chapter 5. Using Python for Virtualization Forensics">Chapter 5</a>, <span class="emphasis"><em>Using Python for Virtualization Forensics</em></span>.</p></div></div><p>The, by far, most prominent tool for the analysis of memory data is <span class="strong"><strong>Volatility</strong></span>. Volatility is available at<a id="id404" class="indexterm"/> the Volatility Foundation on <a class="ulink" href="http://www.volatilityfoundation.org/">http://www.volatilityfoundation.org/</a>.</p><p>The tool is written in Python and can be used free of charge under the terms of the GNU <span class="strong"><strong>General Public License</strong></span> (<span class="strong"><strong>GPL</strong></span>) version 2. Volatility is able to read memory dumps in various file<a id="id405" class="indexterm"/> formats, for example, hibernation<a id="id406" class="indexterm"/> files, raw memory dumps, VMware memory snapshot files, and the <span class="strong"><strong>Linux Memory Extractor</strong></span> (<span class="strong"><strong>LiME</strong></span>) format produced by the LiME module, which will be discussed later in this chapter.</p><p>The most important terms in the Volatility world are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Profile</strong></span>: A profile<a id="id407" class="indexterm"/> helps Volatility in interpreting the memory offsets and structures of memory. The profile is dependent on the operating system, especially the OS kernel, machine, and CPU architecture. Volatility contains a variety of profiles for the most common use cases. In the <span class="emphasis"><em>Using Volatility on Linux</em></span> section of this chapter, we will describe how to create your profiles.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Plugin</strong></span>: Plugins<a id="id408" class="indexterm"/> are used to perform actions on the memory dump. Every Volatility command that you use calls a plugin to perform the corresponding action. For example, to get a list of all the processes that were running during the memory dump of a Linux system, the <code class="literal">linux_pslist</code> plugin is used.</li></ul></div><p>Volatility provides a comprehensive documentation and we recommend that you get familiar with all the module descriptions to get the most usage out of Volatility.</p></div></div>
<div class="section" title="Using Volatility on Android"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec31"/>Using Volatility on Android</h1></div></div></div><p>To analyze volatile memory from Android devices, you will first need LiME. LiME is a <span class="strong"><strong>Loadable Kernel Module</strong></span> (<span class="strong"><strong>LKM</strong></span>) that gives access to the whole RAM of the device and can dump it to <a id="id409" class="indexterm"/>a physical SD card or network. After <a id="id410" class="indexterm"/>acquiring the volatile memory dump with LiME, we will show you how to install and configure Volatility to parse the RAM dump. In the last section, we will demonstrate how to get specific information out of the RAM dump.</p><div class="section" title="LiME and the recovery image"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec40"/>LiME and the recovery image</h2></div></div></div><p>LiME is a Loadable Kernel Module (LKM) that allows for volatile memory acquisition from Linux and Linux-based devices, such as Android. This makes LiME unique, as it is the first tool that allows for full memory captures on Android devices. It also minimizes its interaction between user and kernel space processes during acquisition, which allows it to produce memory captures that are more forensically sound than those of other tools<a id="id411" class="indexterm"/> designed for Linux memory acquisition.</p><p>In order to use<a id="id412" class="indexterm"/> LiME on Android, it has to be cross-compiled for the used kernel on the device in question. In the following sections, we will see how these steps are performed for a Nexus 4 with Android 4.4.4 (however, this approach can be adapted to every Android-based device for which the kernel—or at least the kernel<a id="id413" class="indexterm"/> configuration—is available as open source).</p><p>First of all, we <a id="id414" class="indexterm"/>have to install some additional <a id="id415" class="indexterm"/>packages on our lab system, as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user@lab:~$ sudo apt-get install bison g++-multilib git gperf libxml2-utils make python-networkx zlib1g-dev:i386 zip openjdk-7-jdk</strong></span>
</pre></div><p>After installing all the required packages, we now need to configure the access to USB devices. Under GNU/Linux systems, regular users directly can't access USB devices by default. The system needs to be configured to allow such access. This is done by creating a file named <code class="literal">/etc/udev/rules.d/51-android.rules</code> (as the root user) and inserting the following lines in it:</p><div class="informalexample"><pre class="programlisting"># adb protocol on passion (Nexus One)
SUBSYSTEM=="usb", ATTR{idVendor}=="18d1", ATTR{idProduct}=="4e12", MODE="0600", OWNER="user"
# fastboot protocol on passion (Nexus One)
SUBSYSTEM=="usb", ATTR{idVendor}=="0bb4", ATTR{idProduct}=="0fff", MODE="0600", OWNER="user"
# adb protocol on crespo/crespo4g (Nexus S)
SUBSYSTEM=="usb", ATTR{idVendor}=="18d1", ATTR{idProduct}=="4e22", MODE="0600", OWNER="user"
# fastboot protocol on crespo/crespo4g (Nexus S)
SUBSYSTEM=="usb", ATTR{idVendor}=="18d1", ATTR{idProduct}=="4e20", MODE="0600", OWNER="user"
# adb protocol on stingray/wingray (Xoom)
SUBSYSTEM=="usb", ATTR{idVendor}=="22b8", ATTR{idProduct}=="70a9", MODE="0600", OWNER="user"
# fastboot protocol on stingray/wingray (Xoom)
SUBSYSTEM=="usb", ATTR{idVendor}=="18d1", ATTR{idProduct}=="708c", MODE="0600", OWNER="user"
# adb protocol on maguro/toro (Galaxy Nexus)
SUBSYSTEM=="usb", ATTR{idVendor}=="04e8", ATTR{idProduct}=="6860", MODE="0600", OWNER="user"
# fastboot protocol on maguro/toro (Galaxy Nexus)
SUBSYSTEM=="usb", ATTR{idVendor}=="18d1", ATTR{idProduct}=="4e30", MODE="0600", OWNER="user"
# adb protocol on panda (PandaBoard)
SUBSYSTEM=="usb", ATTR{idVendor}=="0451", ATTR{idProduct}=="d101", MODE="0600", OWNER="user"
# adb protocol on panda (PandaBoard ES)
SUBSYSTEM=="usb", ATTR{idVendor}=="18d1", ATTR{idProduct}=="d002", MODE="0600", OWNER="user"
# fastboot protocol on panda (PandaBoard)
SUBSYSTEM=="usb", ATTR{idVendor}=="0451", ATTR{idProduct}=="d022", MODE="0600", OWNER="user"
# usbboot protocol on panda (PandaBoard)
SUBSYSTEM=="usb", ATTR{idVendor}=="0451", ATTR{idProduct}=="d00f", MODE="0600", OWNER="user"
# usbboot protocol on panda (PandaBoard ES)
SUBSYSTEM=="usb", ATTR{idVendor}=="0451", ATTR{idProduct}=="d010", MODE="0600", OWNER="user"
# adb protocol on grouper/tilapia (Nexus 7)
SUBSYSTEM=="usb", ATTR{idVendor}=="18d1", ATTR{idProduct}=="4e42", MODE="0600", OWNER="user"
# fastboot protocol on grouper/tilapia (Nexus 7)
SUBSYSTEM=="usb", ATTR{idVendor}=="18d1", ATTR{idProduct}=="4e40", MODE="0600", OWNER="user"
# adb protocol on manta (Nexus 10)
SUBSYSTEM=="usb", ATTR{idVendor}=="18d1", ATTR{idProduct}=="4ee2", MODE="0600", OWNER="user"
# fastboot protocol on manta (Nexus 10)
SUBSYSTEM=="usb", ATTR{idVendor}=="18d1", ATTR{idProduct}=="4ee0", MODE="0600", OWNER="user"</pre></div><p>Now the most time<a id="id416" class="indexterm"/> consuming part is coming—checking the source<a id="id417" class="indexterm"/> code of the Android version that is used. Depending <a id="id418" class="indexterm"/>on the speed of the hard drive and<a id="id419" class="indexterm"/> Internet connection, this step can take several hours so plan it in advance. Furthermore, keep it in mind that the source code is pretty big so use a second partition with at least 40 GB of free space. We install the source code for Android 4.4.4 as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user@lab:~$ mkdir ~/bin</strong></span>

<span class="strong"><strong>user@lab:~$ PATH=~/bin:$PATH</strong></span>

<span class="strong"><strong>user@lab:~$ curl https://storage.googleapis.com/git-repo-downloads/repo &gt; ~/bin/repo</strong></span>

<span class="strong"><strong>user@lab:~$ chmod a+x ~/bin/repo</strong></span>

<span class="strong"><strong>user@lab:~$ repo init -u https://android.googlesource.com/platform/manifest -b android-4.4.4_r1</strong></span>

<span class="strong"><strong>user@lab:~$ repo sync</strong></span>
</pre></div><p>After we have installed the source code for Android 4.4.4, we now need the sources for the kernel running on the device in question. For the Nexus 4 that we are using here, the right kernel is<a id="id420" class="indexterm"/> the <span class="strong"><strong>mako</strong></span> kernel. A list of all available kernels for<a id="id421" class="indexterm"/> Google phones can be found at <a class="ulink" href="http://source.android.com/source/building-kernels.html">http://source.android.com/source/building-kernels.html</a>.</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user@lab:~$ git clone https://android.googlesource.com/device/lge/mako-kernel/kernel</strong></span>

<span class="strong"><strong>user@lab:~$ git clone https://android.googlesource.com/kernel/msm.git</strong></span>
</pre></div><p>Now that we<a id="id422" class="indexterm"/> have all the sources needed to cross-compile LiME, it <a id="id423" class="indexterm"/>is time to get LiME itself:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user@lab:~$ git clone https://github.com/504ensicsLabs/LiME.git</strong></span>
</pre></div><p>After<a id="id424" class="indexterm"/> cloning the <code class="literal">git</code> repository to our lab<a id="id425" class="indexterm"/> machine, now we have to set some environmental variables that are needed during the build process:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user@lab:~$ export SDK_PATH=/path/to/android-sdk-linux/</strong></span>

<span class="strong"><strong>user@lab:~$ export NDK_PATH=/path/to/android-ndk/</strong></span>

<span class="strong"><strong>user@lab:~$ export KSRC_PATH=/path/to/kernel-source/</strong></span>

<span class="strong"><strong>user@lab:~$ export CC_PATH=$NDK_PATH/toolchains/arm-linux-androideabi-4.9/prebuilt/linux-x86/bin/</strong></span>

<span class="strong"><strong>user@lab:~$ export LIME_SRC=/path/to/lime/src</strong></span>
</pre></div><p>Next, we need to get the current kernel configuration from the device in question and copy it to the correct location in the LiME source. On our Nexus 4, this is possible by entering the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user@lab:~$ adb pull /proc/config.gz</strong></span>

<span class="strong"><strong>user@lab:~$ gunzip ./config.gz</strong></span>

<span class="strong"><strong>user@lab:~$ cp config $KSRC_PATH/.config</strong></span>

<span class="strong"><strong>user@lab:~$ cd $KSRC_PATH </strong></span>

<span class="strong"><strong>user@lab:~$ make ARCH=arm CROSS_COMPILE=$CC_PATH/arm-eabi-modules_prepare</strong></span>
</pre></div><p>Before we can build the LiME kernel module, we need to write our customized Makefile:</p><div class="informalexample"><pre class="programlisting">obj-m := lime.o
lime-objs := main.o tcp.o disk.o
KDIR := /path/to/kernel-source
PWD := $(shell pwd)
CCPATH := /path/to/android-ndk/toolchains/arm-linux-androideabi-4.4.4/prebuilt/linux-x86/bin/
default:
 $(MAKE) ARCH=arm CROSS_COMPILE=$(CCPATH)/arm-eabi- -C $(KDIR) M=$(PWD) modules</pre></div><p>With the<a id="id426" class="indexterm"/> help of this Makefile, we can build the kernel module<a id="id427" class="indexterm"/> that is needed to get the volatile memory from an Android <a id="id428" class="indexterm"/>device. Entering <code class="literal">make</code> can start this<a id="id429" class="indexterm"/> process.</p><p>In the following example, we will demonstrate how to push our newly generated kernel module to the device in question and dump the whole volatile memory to our lab environment through TCP.</p><p>If you have a device on which the kernel doesn't allow loading modules on the fly, you should consider creating your own recovery image (for example, a custom version of <span class="strong"><strong>TWRP</strong></span> or <span class="strong"><strong>CWM</strong></span>), include the LiME kernel module and flash it to the device in question. If you are fast enough during the flashing operation, there is nearly no data lost (for more information, refer to <a class="ulink" href="https://www1.informatik.uni-erlangen.de/frost">https://www1.informatik.uni-erlangen.de/frost</a>).</p><p>The LiME module offers three different image formats that can be used to save a captured memory image on the disk: raw, padded, and lime. The third format—lime— is discussed in detail as it is our format of choice. The lime format has been especially developed to be used in conjunction with Volatility. It is supposed to allow easy analysis with Volatility and a special address space has been added to deal with this format. Every memory dump that is based on the lime format has a fixed size header, containing specific address space information for each memory range. This eliminates the need to have additional paddings just to fill up unmapped or memory mapped I/O regions. The LiME header specification is listed in the following:</p><div class="informalexample"><pre class="programlisting">typedef struct {
  unsigned int magic;         // Always 0x4C694D45 (LiME)
  unsigned int version;         // Header version number
  unsigned long long s_addr;     // Starting address of physical RAM
  unsigned long long e_addr;     // Ending address of physical RAM
  unsigned char reserved[8];     // Currently all zeros
  } __attribute__ ((__packed__)) lime_mem_range_header;</pre></div><p>To get such a dump from the Android device in question, connect to the Android device through <code class="literal">adb</code> and enter the following commands:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user@lab:~$ adb push lime.ko /sdcard/lime.ko</strong></span>
<span class="strong"><strong>user@lab:~$ adb forward tcp:4444 tcp:4444</strong></span>
<span class="strong"><strong>user@lab:~$ adb shell</strong></span>
<span class="strong"><strong>nexus4:~$ su</strong></span>
<span class="strong"><strong>nexus4:~$ insmod /sdcard/lime.ko "path=tcp:4444 format=lime"</strong></span>
</pre></div><p>On the lab<a id="id430" class="indexterm"/> machine, enter the following command to accept the<a id="id431" class="indexterm"/> data sent through TCP port 4444 from the Android device<a id="id432" class="indexterm"/> to the local lab machine:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user@lab:~$ nc localhost 4444 &gt; nexus4_ram.lime</strong></span>
</pre></div><p>If the<a id="id433" class="indexterm"/> preceding commands are executed successfully, you will now have a RAM dump that can be further analyzed with the help of Volatility or other tools (refer to the next section).</p></div><div class="section" title="Volatility for Android"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec41"/>Volatility for Android</h2></div></div></div><p>After acquiring a dump file that represents the physical memory of the target system with the tools that we created in the previous section, we intend to extract data artifacts from it. Without an in-depth analysis of Android's memory structures, we would only be able to extract known<a id="id434" class="indexterm"/> file formats such as JPEG, or just the JPEG headers with the EXIF data (with tools such as <span class="strong"><strong>PhotoRec</strong></span>) or simple ASCII strings, which are stored in a contiguous fashion (with common Linux tools such as <span class="strong"><strong>strings</strong></span>) that could be used to <a id="id435" class="indexterm"/>brute force passwords on the devices in question. This approach <a id="id436" class="indexterm"/>is very limited as it can be used for any disk or memory dump but does not focus on OS and application-specific structures. As we intend to extract whole data objects from the Android system, we will make use of the popular forensic investigation framework for volatile memory: <span class="strong"><strong>Volatility</strong></span>.</p><p>In this section, we will use a version of Volatility with ARM support (you need version 2.3 at least). Given a memory image, Volatility can extract running processes, open network sockets, memory maps for each process, and kernel modules.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note20"/>Note</h3><p>Before a memory image can be analyzed, a Volatility profile must be created that is passed to the Volatility framework as a command line parameter. Such Volatility profile is a<a id="id437" class="indexterm"/> set of <span class="strong"><strong>vtype</strong></span> definitions and optional symbol addresses that Volatility uses to locate sensitive information and parse it.</p></div></div><p>Basically, a<a id="id438" class="indexterm"/> profile is a compressed archive that contains two files, as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">System.map</code> file contains symbol names and addresses of static data structures in the Linux kernel. In case of Android, this file is found in the kernel source tree after the kernel compilation.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">module.dwarf</code> file emerges on compiling a module against the target kernel and extracting the DWARF debugging information from it.</li></ul></div><p>In order to create a <code class="literal">module.dwarf</code> file, a utility called <code class="literal">dwarfdump</code> is required. The Volatility source tree contains the <code class="literal">tools/linux</code> directory. If you run <code class="literal">make</code> in this directory, the command compiles the module and produces the desired DWARF file. Creating the actual profile is done by simply running the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user@lab $ zip Nexus4.zip module.dwarf System.map</strong></span>
</pre></div><p>The resulting ZIP file needs to be copied to <code class="literal">volatility/plugins/overlays/linux</code>. After successfully copying the file, the profile shows up in the profiles section of the Volatility help output.</p><p>Although the support of Android in Volatility is quite new, there is a large amount of Linux plugins that are working perfectly on Android too. For example:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">linux_pslist</code>: It enumerates all running processes of a system similar to the Linux ps command</li><li class="listitem" style="list-style-type: disc"><code class="literal">linux_ifconfig</code>: This plugin simulates the Linux <code class="literal">ifconfig</code> command</li><li class="listitem" style="list-style-type: disc"><code class="literal">linux_route_cache</code>: It reads and prints the route cache that stores the recently used routing entries in a hash table</li><li class="listitem" style="list-style-type: disc"><code class="literal">linux_proc_maps</code>: This plugin acquires memory mappings of each individual process</li></ul></div><p>If you<a id="id439" class="indexterm"/> are interested in how to write custom Volatility plugins and parse unknown structures in <span class="strong"><strong>Dalvik Virtual Machine</strong></span> (<span class="strong"><strong>DVM</strong></span>), please take a look at the following paper written by me and my colleagues: <span class="emphasis"><em>Post-Mortem Memory Analysis of Cold-Booted Android Devices</em></span> (refer to <a class="ulink" href="https://www1.informatik.uni-erlangen.de/filepool/publications/android.ram.analysis.pdf">https://www1.informatik.uni-erlangen.de/filepool/publications/android.ram.analysis.pdf</a>).</p><p>In the<a id="id440" class="indexterm"/> next section, we will exemplarily show how to reconstruct the specific application data with the help of LiME and Volatility.</p></div><div class="section" title="Reconstructing data for Android"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec42"/>Reconstructing data for Android</h2></div></div></div><p>Now, we will <a id="id441" class="indexterm"/>see how to reconstruct application data with the help of Volatility and custom made plugins. Therefore, we have chosen the call history and keyboard cache. If you are investigating on a common Linux or Windows system, there is already a large amount of plugins that are available, as you will see in the last section of this chapter. Unfortunately, on Android, you have to write your own plugins.</p><div class="section" title="Call history"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec19"/>Call history</h3></div></div></div><p>One of our goals is to recover the list of recent incoming and outgoing phone calls from an Android <a id="id442" class="indexterm"/>memory dump. This list is loaded when the phone app is opened. The responsible process for the phone app and call history is <code class="literal">com.android.contacts</code>. This process loads the <code class="literal">PhoneClassDetails.java</code> class file that models the data of all telephone calls in a history structure. One instance of this class is in memory per history entry. The data fields for each instance are typical meta information of a call, as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Type (incoming, outgoing, or missed)</li><li class="listitem" style="list-style-type: disc">Duration</li><li class="listitem" style="list-style-type: disc">Date and time</li><li class="listitem" style="list-style-type: disc">Telephone number</li><li class="listitem" style="list-style-type: disc">Contact name</li><li class="listitem" style="list-style-type: disc">Assigned photo of the contact</li></ul></div><p>To automatically extract and display this metadata, we provide a Volatility plugin called <code class="literal">dalvik_app_calllog</code>, which is shown as follows:</p><div class="informalexample"><pre class="programlisting">class dalvik_app_calllog(linux_common.AbstractLinuxCommand):
     
     def __init__(self, config, *args, **kwargs):
          linux_common.AbstractLinuxCommand.__init__(self, config, *args, **kwargs)
          dalvik.register_option_PID(self._config)
          dalvik.register_option_GDVM_OFFSET(self._config)
          self._config.add_option('CLASS_OFFSET', short_option = 'c', default = None,
          help = 'This is the offset (in hex) of system class PhoneCallDetails.java', action = 'store', type = 'str')

     def calculate(self):
          # if no gDvm object offset was specified, use this one
          if not self._config.GDVM_OFFSET:
               self._config.GDVM_OFFSET = str(hex(0x41b0))

          # use linux_pslist plugin to find process address space and ID if not specified
          proc_as = None
          tasks = linux_pslist.linux_pslist(self._config).calculate()
          for task in tasks:
               if str(task.comm) == "ndroid.contacts":
                    proc_as = task.get_process_address_space()
                    if not self._config.PID:
                         self._config.PID = str(task.pid)
                    break

          # use dalvik_loaded_classes plugin to find class offset if not specified
          if not self._config.CLASS_OFFSET:
              classes = dalvik_loaded_classes.dalvik_loaded_classes(self._config).calculate()
              for task, clazz in classes:
                   if (dalvik.getString(clazz.sourceFile)+"" == "PhoneCallDetails.java"):
                        self._config.CLASS_OFFSET = str(hex(clazz.obj_offset))
                        break

          # use dalvik_find_class_instance plugin to find a list of possible class instances
          instances = dalvik_find_class_instance.dalvik_find_class_instance(self._config).calculate()
          for sysClass, inst in instances:
               callDetailsObj = obj.Object('PhoneCallDetails', offset = inst, vm = proc_as)
               # access type ID field for sanity check
               typeID = int(callDetailsObj.callTypes.contents0)
               # valid type ID must be 1,2 or 3
               if (typeID == 1 or typeID == 2 or typeID == 3):
                    yield callDetailsObj

     def render_text(self, outfd, data):
          self.table_header(outfd, [    ("InstanceClass", "13"),
                                        ("Date", "19"),
                                        ("Contact", "20"),
                                        ("Number", "15"),
                                        ("Duration", "13"),
                                        ("Iso", "3"),
                                        ("Geocode", "15"),
                                        ("Type", "8")                                      
                                        ])
          for callDetailsObj in data:
               # convert epoch time to human readable date and time
               rawDate = callDetailsObj.date / 1000
               date =    str(time.gmtime(rawDate).tm_mday) + "." + \
                         str(time.gmtime(rawDate).tm_mon) + "." + \
                         str(time.gmtime(rawDate).tm_year) + " " + \
                         str(time.gmtime(rawDate).tm_hour) + ":" + \
                         str(time.gmtime(rawDate).tm_min) + ":" + \
                         str(time.gmtime(rawDate).tm_sec)

               # convert duration from seconds to hh:mm:ss format
               duration =     str(callDetailsObj.duration / 3600) + "h " + \
                              str((callDetailsObj.duration % 3600) / 60) + "min " + \
                              str(callDetailsObj.duration % 60) + "s"

               # replace call type ID by string
               callType = int(callDetailsObj.callTypes.contents0)
               if callType == 1:
                    callType = "incoming"
               elif callType == 2:
                    callType = "outgoing"
               elif callType == 3:
                    callType = "missed"
               else:
                    callType = "unknown"

               self.table_row(     outfd,
                                   hex(callDetailsObj.obj_offset),
                                   date,
                                   dalvik.parseJavaLangString(callDetailsObj.name.dereference_as('StringObject')),
                                   dalvik.parseJavaLangString(callDetailsObj.formattedNumber.dereference_as('StringObject')),
                                   duration,               
                                   dalvik.parseJavaLangString(callDetailsObj.countryIso.dereference_as('StringObject')),
                                   dalvik.parseJavaLangString(callDetailsObj.geoCode.dereference_as('StringObject')),
                                   callType)</pre></div><p>This plugin<a id="id443" class="indexterm"/> accepts the following command line parameters:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">-o</code>: For an offset to the gDvm object</li><li class="listitem" style="list-style-type: disc"><code class="literal">-p</code>: For a process ID (PID)</li><li class="listitem" style="list-style-type: disc"><code class="literal">-c</code>: For an offset to the PhoneClassDetails class</li></ul></div><p>If some of these parameters are known and passed on to the plugin, the runtime of the plugin reduces significantly. Otherwise, the plugin has to search for these values in RAM itself.</p></div><div class="section" title="Keyboard cache"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec20"/>Keyboard cache</h3></div></div></div><p>Now, we want<a id="id444" class="indexterm"/> to have a look at the cache of the default keyboard application. Assuming that no further inputs were given after unlocking the screen and the smartphone is protected by a PIN, this PIN is equal to the last user input, which can be found in an Android memory dump as a UTF-16 Unicode string. The Unicode string of the last user input is created by the <code class="literal">RichInputConnection</code> class in the <code class="literal">com.android.inputmethod.latin</code> process and is stored in a variable called <code class="literal">mCommittedTextBeforeComposingText</code>. This variable is like a keyboard buffer, that is, it stores the last typed and confirmed key strokes of the on-screen keyboard. To recover the last user input, we provide a Volatility plugin called <code class="literal">dalvik_app_lastInput</code>, as follows:</p><div class="informalexample"><pre class="programlisting">class dalvik_app_lastInput(linux_common.AbstractLinuxCommand):
     
     def __init__(self, config, *args, **kwargs):
          linux_common.AbstractLinuxCommand.__init__(self, config, *args, **kwargs)
          dalvik.register_option_PID(self._config)
          dalvik.register_option_GDVM_OFFSET(self._config)
          self._config.add_option('CLASS_OFFSET', short_option = 'c', default = None,
          help = 'This is the offset (in hex) of system class RichInputConnection.java', action = 'store', type = 'str')
     
     def calculate(self):

          # if no gDvm object offset was specified, use this one
          if not self._config.GDVM_OFFSET:
               self._config.GDVM_OFFSET = str(0x41b0)

          # use linux_pslist plugin to find process address space and ID if not specified
          proc_as = None     
          tasks = linux_pslist.linux_pslist(self._config).calculate()
          for task in tasks:
               if str(task.comm) == "putmethod.latin":                    
                    proc_as = task.get_process_address_space()
                    self._config.PID = str(task.pid)
                    break

          # use dalvik_loaded_classes plugin to find class offset if not specified
          if not self._config.CLASS_OFFSET:
              classes = dalvik_loaded_classes.dalvik_loaded_classes(self._config).calculate()
              for task, clazz in classes:
                   if (dalvik.getString(clazz.sourceFile)+"" == "RichInputConnection.java"):
                        self._config.CLASS_OFFSET = str(hex(clazz.obj_offset))
                        break

          # use dalvik_find_class_instance plugin to find a list of possible class instances
          instance = dalvik_find_class_instance.dalvik_find_class_instance(self._config).calculate()
          for sysClass, inst in instance:
               # get stringBuilder object
               stringBuilder = inst.clazz.getJValuebyName(inst, "mCommittedTextBeforeComposingText").Object.dereference_as('Object')
               # get superclass object
               abstractStringBuilder = stringBuilder.clazz.super.dereference_as('ClassObject')
               
               # array object of super class
               charArray = abstractStringBuilder.getJValuebyName(stringBuilder, "value").Object.dereference_as('ArrayObject')
               # get length of array object
               count = charArray.length
               # create string object with content of the array object
               text = obj.Object('String', offset = charArray.contents0.obj_offset,
               vm = abstractStringBuilder.obj_vm, length = count*2, encoding = "utf16")
               yield inst, text

     def render_text(self, outfd, data):
          self.table_header(outfd, [    ("InstanceClass", "13"),
                                        ("lastInput", "20")                                 
                                        ])
          for inst, text in data:

               self.table_row(     outfd,
                                   hex(inst.obj_offset),
                                   text)</pre></div><p>Actually, this<a id="id445" class="indexterm"/> plugin not only recovers PINs but also arbitrary user inputs that were given last; this might be an interesting artifact of digital evidence in many cases. Similar to the preceding plugin, it accepts the same three command line parameters: <code class="literal">gDvm offset</code>, <code class="literal">PID</code>, and <code class="literal">class file offset</code>. If none, or only some, of these parameters are given, the plugin can also automatically determine the missing values.</p></div></div></div>
<div class="section" title="Using Volatility on Linux"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec32"/>Using Volatility on Linux</h1></div></div></div><p>In the following <a id="id446" class="indexterm"/>section, we will describe memory acquisition techniques and sample use cases to use Volatility for Linux memory forensics.</p><div class="section" title="Memory acquisition"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec43"/>Memory acquisition</h2></div></div></div><p>If the system<a id="id447" class="indexterm"/> is not virtualized and therefore, there is no way of getting the memory directly from the hypervisor layer; then even for Linux, our tool of choice is LiME.</p><p>However, unlike in Android, the tool installation and operation is a lot easier because we generate and run LiME directly on Linux system; however, many steps are quite similar as you will notice in the following paragraphs.</p><p>First, determine<a id="id448" class="indexterm"/> the exact kernel version, which is running on the system, that is to be analyzed. If there is no sufficient documentation available, then you may run the following command to get the kernel version:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user@forensic-target $ uname –a</strong></span>
<span class="strong"><strong>Linux forensic-target 3.2.0-88-generic #126-Ubuntu SMP Mon Jul 6 21:33:03 UTC 2015 x86_64 x86_64 x86_64 GNU/Linux</strong></span>
</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip16"/>Tip</h3><p>
<span class="strong"><strong>Use the configuration management in enterprise environments</strong></span>
</p><p>Enterprise environments often run configuration management systems that show you the kernel version and Linux distribution of your target system. Asking your customer to provide you with this data or even a system with an identical kernel version and software environment can help you in reducing the risk of incompatibilities between the LiME module and your forensic target.</p></div></div><p>In your lab environment, prepare the LiME kernel module for memory acquisition. To compile the module, make sure you have the correct kernel source code version available for your target and then issue the following build command in the <code class="literal">src</code> directory of LiME:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user@lab src $ make -C /usr/src/linux-headers-3.2.0-88-generic M=$PWD</strong></span>
</pre></div><p>This should create the <code class="literal">lime.ko</code> module in the current directory.</p><p>On the target system, this kernel module can be used to dump the memory to disk, as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user@forensic-target $ sudo insmod lime.ko path=/path/to/dump.lime format=lime</strong></span>
</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note21"/>Note</h3><p>We recommend choosing a path on the network to write the image to. This way, the changes made to the local system are minimal. Transferring the image over network is also an option. Just follow the description in the <span class="emphasis"><em>Using Volatility on Android</em></span> section.</p></div></div></div><div class="section" title="Volatility for Linux"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec44"/>Volatility for Linux</h2></div></div></div><p>Volatility comes <a id="id449" class="indexterm"/>with a wide range of <span class="emphasis"><em>profiles</em></span>. These profiles are used by Volatility to interpret the memory dump. Unfortunately, the wide variety of Linux kernels, system architectures, and kernel configurations make it impossible to ship the profiles to all versions of Linux kernels.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip17"/>Tip</h3><p>
<span class="strong"><strong>Listing all the profiles of Volatility</strong></span>
</p><p>The list of all available profiles can be retrieved with the <code class="literal">vol.py --info</code> command.</p></div></div><p>Consequently, it may be necessary to create your own profile as an ideal match to the forensic target. The Volatility framework supports this step by providing a dummy module that must be compiled against the kernel headers of the target system. This module is available in the Volatility distribution in the <code class="literal">tools/linux</code> subdirectory. Compile it— similar to LiME— but with debug settings enabled:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user@lab src $ make -C /usr/src/linux-headers-3.2.0-88-generic CONFIG_DEBUG_INFO=y M=$PWD</strong></span>
</pre></div><p>This creates <code class="literal">module.ko</code>. There is no need to load this module; all we need is its debug information. We <a id="id450" class="indexterm"/>use the <code class="literal">dwarfdump</code> tool, which is available as an installation package in most Linux distributions, to extract this debug information:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user@lab $ dwarfdump -di module.ko &gt; module.dwarf</strong></span>
</pre></div><p>The next step in the creation of our profile is to acquire the <code class="literal">System.map</code> file of the target system or a system with identical architecture, kernel version, and kernel configuration. The <code class="literal">System.map</code> file may be found in the <code class="literal">/boot</code> directory. Often, the kernel version is included in the filename, therefore be sure to select the <code class="literal">System.map</code> file for the running kernel of the forensic target system.</p><p>Put <code class="literal">module.dwarf</code> and <code class="literal">System.map</code> into a zip archive, which will become our Volatility profile, as shown in the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user@lab $ zip Ubuntu3.2.0-88.zip module.dwarf System.map</strong></span>
</pre></div><p>As shown in the example, the name of the ZIP file should reflect the distribution and kernel version.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note22"/>Note</h3><p>Make sure that you do not add additional path information to the zip archive. Otherwise, Volatility may fail to load the profile data.</p></div></div><p>Copy the new profile to the Linux profile directory of Volatility, as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user@lab $ sudo cp Ubuntu3.2.0-88.zip /usr/local/lib/python2.7/dist-packages/volatility-2.4-py2.7.egg/volatility/plugins/overlays/linux/</strong></span>
</pre></div><p>Instead of using the system-wide profile directory, you may also choose a new one and add the <code class="literal">--plugins=/path/to/profiles</code> option to your Volatility command line.</p><p>Finally, you need to get the name of your new profile for further use. Therefore, use the following call:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user@lab $ vol.py --info</strong></span>
</pre></div><p>The output should contain one additional line showing the new profile, as shown in the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Profiles</strong></span>
<span class="strong"><strong>--------</strong></span>
<span class="strong"><strong>LinuxUbuntu3_2_0-88x64 - A Profile for Linux Ubuntu3.2.0-88 x64</strong></span>
</pre></div><p>To use this <a id="id451" class="indexterm"/>profile, add <code class="literal">--profile=LinuxUbuntu3_2_0-88x64</code> as the command line argument for all subsequent calls to <code class="literal">vol.py</code>.</p></div><div class="section" title="Reconstructing data for Linux"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec45"/>Reconstructing data for Linux</h2></div></div></div><p>All plugins that <a id="id452" class="indexterm"/>analyze Linux memory dumps have the <code class="literal">linux_</code> prefix. Therefore, you should use the Linux version of the plugins. Otherwise, you may get an error message notifying that the module is not supported in the selected profile.</p><div class="section" title="Analyzing processes and modules"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec21"/>Analyzing processes and modules</h3></div></div></div><p>A typical first <a id="id453" class="indexterm"/>step in the analysis of a memory dump is <a id="id454" class="indexterm"/>to list all running processes and loaded kernel modules.</p><p>The following is how to carve out all running processes from a memory dump with Volatility:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user@lab $ vol.py --profile=LinuxUbuntu3_2_0-88x64 --file=memDump.lime linux_pslist</strong></span>
<span class="strong"><strong>Volatility Foundation Volatility Framework 2.4</strong></span>

<span class="strong"><strong>Offset             Name                 Pid             Uid             Gid    DTB                Start Time</strong></span>
<span class="strong"><strong>------------------ -------------------- --------------- --------------- ------ ------------------ ----------</strong></span>
<span class="strong"><strong>0xffff8802320e8000 init                 1               0               0      0x000000022f6c0000 2015-08-16 09:51:21 UTC+0000</strong></span>
<span class="strong"><strong>0xffff8802320e9700 kthreadd             2               0               0      ------------------ 2015-08-16 09:51:21 UTC+0000</strong></span>

<span class="strong"><strong>0xffff88022fbc0000 cron                 2500            0               0      0x000000022cd38000 2015-08-16 09:51:25 UTC+0000</strong></span>
<span class="strong"><strong>0xffff88022fbc1700 atd                  2501            0               0      0x000000022fe28000 2015-08-16 09:51:25 UTC+0000</strong></span>
<span class="strong"><strong>0xffff88022f012e00 irqbalance           2520            0               0      0x000000022df39000 2015-08-16 09:51:25 UTC+0000</strong></span>
<span class="strong"><strong>0xffff8802314b5c00 whoopsie             2524            105             114    0x000000022f1b0000 2015-08-16 09:51:25 UTC+0000</strong></span>
<span class="strong"><strong>0xffff88022c5c0000 freshclam            2598            119             131    0x0000000231fa7000 2015-08-16 09:51:25 UTC+0000</strong></span>
</pre></div><p>As shown<a id="id455" class="indexterm"/> in the output, the <code class="literal">linux_pslist</code> plugin<a id="id456" class="indexterm"/> iterates the kernel structure by describing active processes, that is, it starts from the <code class="literal">init_task</code> symbol and iterates the <code class="literal">task_struct-&gt;tasks</code> linked list. The plugin gets a list of all running processes, including their offset address in the memory, process name, process ID (PID), numerical ID of the user and group of the process (UID, and GID), and start time. The <span class="strong"><strong>Directory Table Base</strong></span> (<span class="strong"><strong>DTB</strong></span>) can be used in the further analysis to translate physical into <a id="id457" class="indexterm"/>virtual addresses. Empty DTB entries relate, most likely, to a kernel thread. For example, <code class="literal">kthreadd</code> in our example output.</p></div><div class="section" title="Analyzing networking information"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec22"/>Analyzing networking information</h3></div></div></div><p>The memory<a id="id458" class="indexterm"/> dump contains various information about the network activity of our forensic target system. The following examples show how to utilize Volatility to derive the information about the recent network activity.</p><p>The <span class="strong"><strong>Address Resolution Protocol</strong></span> (<span class="strong"><strong>ARP</strong></span>) <span class="strong"><strong>cache</strong></span> of the Linux kernel maps MAC addresses <a id="id459" class="indexterm"/>to IP addresses. Before a network communication on the <span class="emphasis"><em>local network</em></span> is established, the Linux kernel sends an ARP request to get the information about the corresponding MAC address for a given destination IP address. The response is cached in memory for re-use to further communicate with this IP address on the local network. Consequently, ARP cache entries indicate the systems on the local network that the forensic target was communicating with.</p><p>To read the ARP cache from a Linux memory dump, use the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user@lab $ vol.py --profile=LinuxUbuntu3_2_0-88x64 --file=memDump.lime linux_arp</strong></span>
<span class="strong"><strong>[192.168.167.22                            ] at 00:00:00:00:00:00    on eth0</strong></span>
<span class="strong"><strong>[192.168.167.20                            ] at b8:27:eb:01:c2:8f    on eth0</strong></span>
</pre></div><p>This extract from the output shows that the system had a cache entry for the <code class="literal">192.168.167.20 </code>destination address with <code class="literal">b8:27:eb:01:c2:8f</code> being the corresponding MAC address. The first entry is most likely a cache entry that results from an unsuccessful communication attempt, that is, the <code class="literal">192.168.167.22</code> communication partner did not send a response to an ARP request that was transmitted from the system and therefore, the corresponding ARP cache entry remained at its initial value of <code class="literal">00:00:00:00:00:00</code>. Either the communication partner was not reachable or it is simply nonexistent.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note23"/>Note</h3><p>If large parts of your local subnet show up in the ARP cache with multiple entries having a MAC address of 00:00:00:00:00:00, then this is an indicator of the scanning activity, that is, the system has tried to detect other systems on the local network.</p></div></div><p>For further <a id="id460" class="indexterm"/>network analysis, it might be worth checking the list of MAC addresses that are retrieved from the ARP cache against the systems that are supposed to be on the local subnet. While this technique is not bulletproof (as MAC addresses can be forged), it might help in discovering rogue network devices.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note24"/>Note</h3><p>
<span class="strong"><strong>Looking up the hardware vendor for a MAC address</strong></span>
</p><p>The prefix of a MAC address reveals the hardware vendor of the corresponding network hardware. Sites such as <a class="ulink" href="http://www.macvendorlookup.com">http://www.macvendorlookup.com</a> provide an indication of the hardware vendor of a network card.</p></div></div><p>If we look up the hardware vendor for the <code class="literal">b8:27:eb:01:c2:8f</code> MAC address from our example, it shows that this device was manufactured by the Raspberry Pi Foundation. In a standard office or data center environment, these embedded devices are rarely used and it is definitely worth checking whether this device is benign.</p><p>To get an overview of the network activity at the time the memory dump was created, Volatility provides the means to emulate the <code class="literal">linux_netstat</code> command, as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user@lab $ vol.py --profile=LinuxUbuntu3_2_0-88x64 --file=memDump.lime linux_netstat</strong></span>
<span class="strong"><strong>TCP      192.168.167.21  :55622 109.234.207.112  :  143 ESTABLISHED           thunderbird/3746</strong></span>
<span class="strong"><strong>UNIX 25129          thunderbird/3746</strong></span>
<span class="strong"><strong>TCP      0.0.0.0         : 7802 0.0.0.0         :    0 LISTEN                      skype/3833</strong></span>
</pre></div><p>These three lines are only a small excerpt from the typical output of this command. The first line shows that the <code class="literal">thunderbird</code> process with the <code class="literal">3746</code> PID has an active <code class="literal">ESTABLISHED</code> network connection to the IMAP server (TCP port <code class="literal">143</code>) with the <code class="literal">109.234.207.112</code> IP address. The second line merely shows a socket of UNIX type that is used for <span class="strong"><strong>Inter-Process Communication</strong></span> (<span class="strong"><strong>IPC</strong></span>). The last entry shows that <code class="literal">skype</code> with the <code class="literal">3833</code> PID is a <a id="id461" class="indexterm"/>waiting <code class="literal">LISTEN</code> for incoming connections on TCP port <code class="literal">7802</code>.</p><p>Volatility can also be used to narrow down the list of processes to those with raw network access. Typically, this kind of access is only required for <span class="strong"><strong>Dynamic Host Configuration Protocol</strong></span> (<span class="strong"><strong>DHCP</strong></span>) clients, network diagnostics, and, of course, malware in order to construct <a id="id462" class="indexterm"/>arbitrary packets on the network interface, for example, conduct a so-called ARP cache poisoning attack. The following shows how to list the processes with raw network sockets:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user@lab $ vol.py --profile=LinuxUbuntu3_2_0-88x64 --file=memDump.lime linux_list_raw</strong></span>
<span class="strong"><strong>Process          PID    File Descriptor Inode             </strong></span>
<span class="strong"><strong>---------------- ------ --------------- ------------------</strong></span>
<span class="strong"><strong>dhclient           2817               5              15831</strong></span>
</pre></div><p>Here, only<a id="id463" class="indexterm"/> the DHCP client is detected to have the raw network access.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip18"/>Tip</h3><p>
<span class="strong"><strong>Rootkit detection modules</strong></span>
</p><p>Volatility provides a variety of mechanisms in order to detect typical rootkit behavior, for example, interrupt hooking, manipulations of the network stack, and hidden kernel modules. We recommend getting familiar with these modules as they can speed up your analysis. Furthermore, check for module updates on a regular basis to leverage new malware detection mechanisms being built in to Volatility.</p></div></div><p>Some generic methods and heuristics for malware detection are combined in the <code class="literal">linux_malfind</code> module. This module looks for suspicious process memory mappings and produces a list of possibly malicious processes.</p></div><div class="section" title="Malware hunting with the help of YARA"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec23"/>Malware hunting with the help of YARA</h3></div></div></div><p>
<span class="strong"><strong>YARA</strong></span> itself <a id="id464" class="indexterm"/>is a tool that is able to match a given<a id="id465" class="indexterm"/> pattern in arbitrary files and datasets. The corresponding rules—also known as signatures—are a great way to search for known malicious files in dumps of hard drives or memory.</p><p>In this section, we want to demonstrate how to search for given malware in an acquired memory dump of a Linux machine. Therefore, you can use two different procedures that we will discuss in the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Searching the memory dump directly with the help of YARA</li><li class="listitem" style="list-style-type: disc">Using <code class="literal">linux_yarascan</code> and Volatility</li></ul></div><p>The first option has one big disadvantage; as we already know, memory dumps contain fragmented data that is normally contiguous. This fact makes it prone to failure if you are searching this dump for known signatures as they are not necessarily in the order you are searching them.</p><p>The second<a id="id466" class="indexterm"/> option—using <code class="literal">linux_yarascan</code>—is more fail-safe as it uses Volatility and knows the structure of the acquired memory<a id="id467" class="indexterm"/> dump. With the help of this knowledge, it is able to resolve the fragmentation and search reliable for known signatures. Although, we are using <code class="literal">linux_yarascan</code> on Linux, this module is also available for Windows (<code class="literal">yarascan</code>) and Mac OS X (<code class="literal">mac_yarascan</code>).</p><p>The main capabilities of this module are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Scan given processes in the memory dump for a given YARA signature</li><li class="listitem" style="list-style-type: disc">Scan the complete range of kernel memory</li><li class="listitem" style="list-style-type: disc">Extract the memory areas to disk that contain positive results to the given YARA rules</li></ul></div><p>The full list of possible command line options can be seen on entering <code class="literal">vol.py linux_yarascan –h</code>
</p><p>Basically, you can search in many different ways. The simplest way of using this module is by searching for a given URL in the memory dump. This can be done by entering the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user@lab $ vol.py --profile=LinuxUbuntu3_2_0-88x64 --file=memDump.lime linux_yarascan –-yara-rules="microsoft.com" --wide</strong></span>

<span class="strong"><strong>Task: skype pid 3833 rule r1 addr 0xe2be751f</strong></span>
<span class="strong"><strong>0xe2be751f  6d 00 69 00 63 00 72 00 6f 00 73 00 6f 00 66 00   m.i.c.r.o.s.o.f.</strong></span>
<span class="strong"><strong>0xe2be752f  74 00 2e 00 63 00 6f 00 6d 00 2f 00 74 00 79 00   t...c.o.m./.t.y.</strong></span>
<span class="strong"><strong>0xe2be753f  70 00 6f 00 67 00 72 00 61 00 70 00 68 00 79 00   p.o.g.r.a.p.h.y.</strong></span>
<span class="strong"><strong>0xe2be754f  2f 00 66 00 6f 00 6e 00 74 00 73 00 2f 00 59 00   /.f.o.n.t.s./.Y.</strong></span>
<span class="strong"><strong>0xe2be755f  6f 00 75 00 20 00 6d 00 61 00 79 00 20 00 75 00   o.u...m.a.y...u.</strong></span>
<span class="strong"><strong>0xe2be756f  73 00 65 00 20 00 74 00 68 00 69 00 73 00 20 00   s.e...t.h.i.s...</strong></span>
<span class="strong"><strong>0xe2be757f  66 00 6f 00 6e 00 74 00 20 00 61 00 73 00 20 00   f.o.n.t...a.s...</strong></span>
<span class="strong"><strong>0xe2be758f  70 00 65 00 72 00 6d 00 69 00 74 00 74 00 65 00   p.e.r.m.i.t.t.e.</strong></span>
<span class="strong"><strong>0xe2be759f  64 00 20 00 62 00 79 00 20 00 74 00 68 00 65 00   d...b.y...t.h.e.</strong></span>
<span class="strong"><strong>0xe2be75af  20 00 45 00 55 00 4c 00 41 00 20 00 66 00 6f 00   ..E.U.L.A...f.o.</strong></span>
<span class="strong"><strong>0xe2be75bf  72 00 20 00 74 00 68 00 65 00 20 00 70 00 72 00   r...t.h.e...p.r.</strong></span>
<span class="strong"><strong>0xe2be75cf  6f 00 64 00 75 00 63 00 74 00 20 00 69 00 6e 00   o.d.u.c.t...i.n.</strong></span>
<span class="strong"><strong>0xe2be75df  20 00 77 00 68 00 69 00 63 00 68 00 20 00 74 00   ..w.h.i.c.h...t.</strong></span>
<span class="strong"><strong>0xe2be75ef  68 00 69 00 73 00 20 00 66 00 6f 00 6e 00 74 00   h.i.s...f.o.n.t.</strong></span>
<span class="strong"><strong>0xe2be75ff  20 00 69 00 73 00 20 00 69 00 6e 00 63 00 6c 00   ..i.s...i.n.c.l.</strong></span>
<span class="strong"><strong>0xe2be760f  75 00 64 00 65 00 64 00 20 00 74 00 6f 00 20 00   u.d.e.d...t.o...</strong></span>
<span class="strong"><strong>Task: skype pid 3833 rule r1 addr 0xedfe1267</strong></span>
<span class="strong"><strong>0xedfe1267  6d 00 69 00 63 00 72 00 6f 00 73 00 6f 00 66 00   m.i.c.r.o.s.o.f.</strong></span>
<span class="strong"><strong>0xedfe1277  74 00 2e 00 63 00 6f 00 6d 00 2f 00 74 00 79 00   t...c.o.m./.t.y.</strong></span>
<span class="strong"><strong>0xedfe1287  70 00 6f 00 67 00 72 00 61 00 70 00 68 00 79 00   p.o.g.r.a.p.h.y.</strong></span>
<span class="strong"><strong>0xedfe1297  2f 00 66 00 6f 00 6e 00 74 00 73 00 2f 00 59 00   /.f.o.n.t.s./.Y.</strong></span>
<span class="strong"><strong>0xedfe12a7  6f 00 75 00 20 00 6d 00 61 00 79 00 20 00 75 00   o.u...m.a.y...u.</strong></span>
<span class="strong"><strong>0xedfe12b7  73 00 65 00 20 00 74 00 68 00 69 00 73 00 20 00   s.e...t.h.i.s...</strong></span>
<span class="strong"><strong>0xedfe12c7  66 00 6f 00 6e 00 74 00 20 00 61 00 73 00 20 00   f.o.n.t...a.s...</strong></span>
<span class="strong"><strong>0xedfe12d7  70 00 65 00 72 00 6d 00 69 00 74 00 74 00 65 00   p.e.r.m.i.t.t.e.</strong></span>
<span class="strong"><strong>0xedfe12e7  64 00 20 00 62 00 79 00 20 00 74 00 68 00 65 00   d...b.y...t.h.e.</strong></span>
<span class="strong"><strong>0xedfe12f7  20 00 45 00 55 00 4c 00 41 00 20 00 66 00 6f 00   ..E.U.L.A...f.o.</strong></span>
<span class="strong"><strong>0xedfe1307  72 00 20 00 74 00 68 00 65 00 20 00 70 00 72 00   r...t.h.e...p.r.</strong></span>
<span class="strong"><strong>0xedfe1317  6f 00 64 00 75 00 63 00 74 00 20 00 69 00 6e 00   o.d.u.c.t...i.n.</strong></span>
<span class="strong"><strong>0xedfe1327  20 00 77 00 68 00 69 00 63 00 68 00 20 00 74 00   ..w.h.i.c.h...t.</strong></span>
<span class="strong"><strong>0xedfe1337  68 00 69 00 73 00 20 00 66 00 6f 00 6e 00 74 00   h.i.s...f.o.n.t.</strong></span>
<span class="strong"><strong>0xedfe1347  20 00 69 00 73 00 20 00 69 00 6e 00 63 00 6c 00   ..i.s...i.n.c.l.</strong></span>
<span class="strong"><strong>0xedfe1357  75 00 64 00 65 00 64 00 20 00 74 00 6f 00 20 00   u.d.e.d...t.o...</strong></span>
</pre></div><p>A more<a id="id468" class="indexterm"/> complex but also a more realistic way<a id="id469" class="indexterm"/> is to search for a given YARA rule. The following YARA rule was made to identify whether a system has been infected with the <code class="literal">Derusbi</code> malware family:</p><div class="informalexample"><pre class="programlisting">rule APT_Derusbi_Gen
{
meta:
  author = "ThreatConnect Intelligence Research Team"
strings:
  $2 = "273ce6-b29f-90d618c0" wide ascii
  $A = "Ace123dx" fullword wide ascii
  $A1 = "Ace123dxl!" fullword wide ascii
  $A2 = "Ace123dx!@#x" fullword wide ascii
  $C = "/Catelog/login1.asp" wide ascii
  $DF = "~DFTMP$$$$$.1" wide ascii
  $G = "GET /Query.asp?loginid=" wide ascii
  $L = "LoadConfigFromReg failded" wide ascii
  $L1 = "LoadConfigFromBuildin success" wide ascii
  $ph = "/photoe/photo.asp HTTP" wide ascii
  $PO = "POST /photos/photo.asp" wide ascii
  $PC = "PCC_IDENT" wide ascii
condition:
  any of them
}</pre></div><p>If we save<a id="id470" class="indexterm"/> this rule as <code class="literal">apt_derusbi_gen.rule</code>, we can search for it in the acquired memory dump by entering the following<a id="id471" class="indexterm"/> command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user@lab $ vol.py --profile=LinuxUbuntu3_2_0-88x64 --file=memDump.lime linux_yarascan --yara-file=apt_derusbi_gen.rule --wide</strong></span>
</pre></div><p>The result will only show us a short preview that can be enlarged by using the <code class="literal">--size</code> option.</p><p>If you are investigating a predefined scenario (for example, if you already know that the system has been attacked by a known group), you can copy all your rules in one single rule file and search the memory dump for all the rules in the file at once. Volatility and <code class="literal">linux_yarascan</code> will display every hit and its corresponding rule number. This makes it much faster to scan for known malicious behavior in a memory dump.</p><p>There is a vast number of sources for YARA signatures that are available in the wild and we will only mention some of the most important ones here to help you, starting with the malware hunt as shown in the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The YARA signature<a id="id472" class="indexterm"/> exchange group on Google Groups: <a class="ulink" href="http://www.deependresearch.org/">http://www.deependresearch.org/</a></li><li class="listitem" style="list-style-type: disc">Signatures from AlienVault Labs: <a class="ulink" href="https://github.com/AlienVault-Labs/AlienVaultLabs/tree/master/malware_analysis">https://github.com/AlienVault-Labs/AlienVaultLabs/tree/master/malware_analysis</a></li><li class="listitem" style="list-style-type: disc">Antivirus <a id="id473" class="indexterm"/>signatures that can be built <a id="id474" class="indexterm"/>with the help of ClamAV and recipe 3-3 out of the Malware Analyst's Cookbook: <a class="ulink" href="https://code.google.com/p/malwarecookbook/source/browse/trunk/3/3/clamav_to_yara.py">https://code.google.com/p/malwarecookbook/source/browse/trunk/3/3/clamav_to_yara.py</a></li></ul></div></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec33"/>Summary</h1></div></div></div><p>In this chapter, we provided an overview of memory forensics using the Volatility framework. In the examples, we demonstrated memory acquisition techniques for Android and Linux systems and saw how to use LiME on both systems. We used Volatility to get information about running processes, loaded modules, possibly malicious activity, and recent network activity. The latter is useful to trace the activities of an attacker through the network.</p><p>In the last example in this chapter, we demonstrated how to search for a given malware signature or other highly flexible pattern-based rules in such a memory dump. These YARA signatures or rules help in identifying suspicious activities or files really fast.</p><p>Furthermore, we demonstrated how to get the keyboard cache as well as call history from an Android device.</p></div>
<div class="section" title="Where to go from here"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec34"/>Where to go from here</h1></div></div></div><p>If you like to test the tools and knowledge gained from this book, we have the following two tips for you:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Create a lab with two virtual machines—<span class="strong"><strong>Metasploit</strong></span> and <span class="strong"><strong>Metasploitable</strong></span>. Try to hack into your <span class="strong"><strong>Metasploitable</strong></span> system and perform a forensic analysis afterwards. Are you able to reconstruct the attack and gather all the Indicators of Compromise?</li><li class="listitem" style="list-style-type: disc">Get some old hard drives, which are no longer used but have been used regularly in the past. Perform a forensic analysis on these drives and try to reconstruct as much data as possible. Are you able to reconstruct former operations on these drives?</li></ul></div><p>If you like to enhance your knowledge on some of the topics that were covered in this book, the following books are a really good choice:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Practical Mobile Forensics</em></span> by <span class="emphasis"><em>Satish Bommisetty</em></span>, <span class="emphasis"><em>Rohit Tamma</em></span>, <span class="emphasis"><em>Heather Mahalik</em></span>, <span class="emphasis"><em>Packt Publishing</em></span></li><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>The Art of Memory Forensics: Detecting Malware and Threats in Windows, Linux, and Mac Memory</em></span> by <span class="emphasis"><em>Michael Hale Ligh</em></span>, <span class="emphasis"><em>Andrew Case</em></span>, <span class="emphasis"><em>Jamie Levy</em></span> and <span class="emphasis"><em>AAron Walters</em></span>, <span class="emphasis"><em>Wiley India</em></span></li><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Handbook of Digital Forensics and Investigation</em></span> by <span class="emphasis"><em>Eoghan Casey</em></span>, <span class="emphasis"><em>Academic Press</em></span></li></ul></div></div></body></html>