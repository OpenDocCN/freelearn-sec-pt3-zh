["```\n       call next_instruction \n    next_instruction:\n       pop rax\n       *; the rest of the code*\n```", "```\n*; The following call would be encoded as (address is underlined):*\n*; 0xff 0x1d 0x00 0x10 0x40 0x00*\ncall far [0x00401000] \n\n*; or as*\n*; 0xff 0x2d 0x00 0x10 0x40 0x00*\njmp far [0x00401000]\n```", "```\nlea rax, [my_proc]\ncall rax\n```", "```\n*; This goes into code section*\n push my_proc\n lea    rax, [rsp]\n call   qword [rax]\n add  rsp, 8\n call  qword [my_proc_address]\n *;*\n *;*\n my_proc:\n     ret\n\n *; This goes into data section*\n my_proc_address dq my_proc\n```", "```\ncall my_proc\n *; or*\n jmp some_label\n```", "```\n *; This portion goes into the code section.*\n *; Assuming the RBP register contains the stack frame address*\n *; and the size of the frame is 0x50 bytes.*\n lea rdi, [rbp – 0x50]\n lea rsi, [my_string]\n mov ecx, my_string_len\n rep movsb\n\n *; And this portion goes into the data section*\n my_string db ‘Just some string’,0\n my_string_len = $ - my_string\n```", "```\n mov al, [name_of_variable]\n *; or*\n mov [name_of_another_variable], eax\n```", "```\n*; This goes into code section.*\n    xor  rax, rax\n    *; inc rax                     ; Increment RAX in order to call the second procedure*\n    lea  rbx, [indices]\n    add  rax, rbx\n    lea  rbx, [my_proc_address]\n    add  bl, [rax]\n    mov rbx, [rbx]\n    call qword rbx\n    *; The rest of the code*\n\n   align 8\n my_proc0:\n    push rbp\n    mov  rbp, rsp\n    xor  eax, eax\n    mov  rsp, rbp\n    pop  rbp\n    ret\n\n   align 8\n my_proc1:\n    push rbp\n    mov  rbp, rsp\n    xor  eax, eax\n    inc  eax\n    mov  rsp, rbp\n    pop  rbp\n    ret       \n\n *; And the following goes into data section*\n indices              db 0, 8\n    align 8\n    my_proc_address      dq my_proc0, my_proc1\n```", "```\nmov rbx, [rbx]\n```", "```\ncall qword [rbx]\n```", "```\nint my_proc0()\n {\n    return 0;\n }\n\n int my_proc1()\n {\n    return 1;\n }\n\n int call_func(int selector)\n {\n    int (*funcs[])(void) = {my_proc0, my_proc1};\n    return funcs[selector]();\n }\n```", "```\nlea rbx, [my_proc_address]\n```", "```\nxor rax, rax\n *; inc rax                 ; increment RAX to call the second procedure*\n lea rbx, [my_proc_address]\n call qword [rbx + rax * 8]\n\n *; or even a more convenient one*\n\n xor rax, rax\n *; inc rax*\n call qword[my_proc_address + rax * 8]\n```", "```\nlea rbx, [my_variable]\n```", "```\nlea rbx, [rip + (my_variable – next_instruction)]\n```", "```\n*; This goes into the code section*\nmov   word [far_ptr + 4], fs   *; Store FS selector to the selector part of the far_ptr*\nlgs   edx, [far_ptr]           *; Load the pointer*\nmov   eax, [gs:edx]            *; Load EAX with the address of the TIB*\nmov   eax, [eax + 0x30]        *; Load EAX with the address of the PEB*\n\n*; This goes into the data section*\nfar_ptr   dp 0                 *; Six bytes far pointer:*\n *;     four bytes offset*\n *;     two bytes segment selector*\n```", "```\nmov   eax, [fs:0x30]\n```"]