<html><head></head><body>
		<div><h1 id="_idParaDest-286" class="chapter-number"><a id="_idTextAnchor946"/>9</h1>
			<h1 id="_idParaDest-287"><a id="_idTextAnchor947"/>Reversing Bytecode Languages – .NET, Java, and More</h1>
			<p>The beauty of cross-platform compiled programs is in their flexibility as you don’t need to spend lots of effort porting each program to different systems. In this chapter, we will learn how malware authors are trying to leverage these advantages for malicious purposes. In addition, you will be provided with an arsenal of techniques and tools whose aim is to make analysis quick and efficient.</p>
			<p>In this chapter, we will cover the following topics: </p>
			<ul>
				<li>The basic theory of bytecode languages</li>
				<li>.NET explained</li>
				<li>.NET malware analysis</li>
				<li>The essentials of Visual Basic </li>
				<li>Dissecting Visual Basic samples </li>
				<li>The internals of Java samples </li>
				<li>Analyzing compiled Python threats<a id="_idTextAnchor948"/><a id="_idTextAnchor949"/><a id="_idTextAnchor950"/></li>
			</ul>
			<h1 id="_idParaDest-288"><a id="_idTextAnchor951"/>The basic theory of bytecode languages</h1>
			<p>.NET, Java, Python, and many other languages are designed to be cross-platform. The corresponding source <a id="_idIndexMarker1330"/>code doesn’t get compiled into an assembly language (such as Intel, ARM, and so on), but gets compiled into an intermediate language that is called bytecode language. Bytecode <a id="_idIndexMarker1331"/>language is a type of language that’s close to assembly languages, but it can easily be executed by an interpreter or compiled on the fly into a native language (this depends on the CPU and operating system it is getting executed in) in <a id="_idIndexMarker1332"/>what’s called <strong class="bold">Just-<a id="_idTextAnchor952"/>in-Time</strong> (<strong class="bold">JIT</strong>) compilin<a id="_idTextAnchor953"/>g.</p>
			<h2 id="_idParaDest-289"><a id="_idTextAnchor954"/>Object-oriented programming</h2>
			<p>Most of these bytecode languages<a id="_idIndexMarker1333"/> follow state-of-the-art technologies in the programming and development fields. They implement what’s<a id="_idIndexMarker1334"/> called <strong class="bold">object-oriented programming </strong>(<strong class="bold">OOP</strong>). If you’ve never heard of it, OOP is based on the concept of <strong class="bold">objects</strong>. These<a id="_idIndexMarker1335"/> objects contain properties (sometimes called fields or attributes) and contain procedures (sometimes called functions or methods). These objects can interact with each other.</p>
			<p>Objects can be different instances<a id="_idIndexMarker1336"/> of the same design or blueprint, which is known as a <strong class="bold">class</strong>. The following diagram shows a class for a car and different instances or objects of that class:</p>
			<div><div><img src="img/Figure_9.1_B18500.jpg" alt="Figure 9.1 – A car class and three diﬀerent objects&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.1 – A car class and three diﬀerent ob<a id="_idTextAnchor955"/>jects</p>
			<p>In this class, there are attributes such as fuel and speed, as well as methods such as <code>accelerate()</code> and <code>stop()</code>. Some objects could interact with each other and call <a id="_idTextAnchor956"/>these methods or directly modify the attrib<a id="_idTextAnchor957"/>utes.</p>
			<h2 id="_idParaDest-290"><a id="_idTextAnchor958"/>Inheritance</h2>
			<p>Another important concept to <a id="_idIndexMarker1337"/>understand is inheritance. Inheritance allows a subclass to inherit (or include) all the attributes and methods that are included in the parent class (with the code inside). This subclass can have more attributes or methods, and it ca<a id="_idTextAnchor959"/>n even reimplement a method included in the parent class (sometimes called a super or superc<a id="_idTextAnchor960"/>lass).</p>
			<h2 id="_idParaDest-291"><a id="_idTextAnchor961"/>Polymorphism</h2>
			<p>Inheritance allows one class<a id="_idIndexMarker1338"/> to represent many different types of objects in what’s called <a id="_idIndexMarker1339"/>polymorphism. A <code>Shape</code> class can represent different subclasses, such as <code>Line</code>, <code>Circle</code>, <code>Square</code>, and others. A drawing application can loop through all <code>Shape</code> objects (regardless of their subclasses) and execute a <code>paint()</code> method to paint them on the screen or the program canvas without having to deal with each class separately.</p>
			<p>Since the <code>Shape</code> class has the <code>paint()</code> method and each of its subclasses has an implementation of it, it becomes much easier for the application to just execute the <code>paint()</code> method, regardless of its impleme<a id="_idTextAnchor962"/><a id="_idTextAnchor963"/>ntation.</p>
			<h1 id="_idParaDest-292"><a id="_idTextAnchor964"/>.NET explained</h1>
			<p>.NET languages (mainly C# and VB.NET) are languages<a id="_idIndexMarker1340"/> that were designed by Microsoft to be cross-platform. The corresponding source code is compiled into a bytecode language, originally named <strong class="bold">Microsoft Intermediate Language</strong> (<strong class="bold">MSIL</strong>), which is <a id="_idIndexMarker1341"/>now known as <strong class="bold">Common Intermediate Language</strong> (<strong class="bold">CIL</strong>). This language gets executed by the <strong class="bold">Common Language Runtime</strong> (<strong class="bold">CLR</strong>), which is an application virtual machine that provi<a id="_idTextAnchor965"/>des memory management and exception<a id="_idTextAnchor966"/> handling.</p>
			<h2 id="_idParaDest-293"><a id="_idTextAnchor967"/>.NET file structure</h2>
			<p>The .NET file <a id="_idIndexMarker1342"/>structure is based on <a id="_idIndexMarker1343"/>the PE structure that we described in <a href="B18500_03.xhtml#_idTextAnchor084"><em class="italic">Chapter 3</em></a>, <em class="italic">Basic Static and Dynamic Analysis for x86/x64</em>. The .NET structure starts with a PE header that contains the last but one entry in the data directory pointing to .NET’s special <strong class="bold">CLR header</strong> (<strong class="bold">CO<a id="_idTextAnchor968"/><a id="_idTextAnchor969"/><a id="_idTextAnchor970"/>R20 header</strong>).</p>
			<h3>.NET COR20 header</h3>
			<p>The <code>.text</code> section and contains basic information about the .NET file, as shown in the following screenshot:</p>
			<div><div><img src="img/Figure_9.2_B18500.jpg" alt="Figure 9.2 – CLR header (COR20 header) and CLR streams&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.2 – CLR header (COR20 header) and CLR streams</p>
			<p>Some of the values of this structure are as follows:</p>
			<ul>
				<li><strong class="bold">cb</strong>: Represents the size of the header (always 0x48)</li>
				<li><strong class="bold">MajorRuntimeVersion</strong> and <strong class="bold">MinorRuntimeVersion</strong>: Always with values of 2 and 5 (even wit<a id="_idTextAnchor971"/>h runtime 4)</li>
				<li><strong class="bold">Metadata address and size</strong>: This contains all the CLR streams, which will be described later</li>
				<li><code>0x6000012</code> value, we have the following:<ul><li><code>#~</code> stream (we will talk about streams in detail later). In the <a id="_idIndexMarker1345"/>following screenshot, we can see that it corresponds to the <code>Methods</code> table.</li><li><code>Main</code>:</li></ul></li>
			</ul>
			<div><div><img src="img/Figure_9.3_B18500.jpg" alt="Figure 9.3 – The entry point method in the methods table in the ﬁrst stream, #~&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.3 – The entry point method in the methods table in the ﬁrst stream, #~</p>
			<p>Now, let’s talk ab<a id="_idTextAnchor972"/><a id="_idTextAnchor973"/><a id="_idTextAnchor974"/>out<a id="_idIndexMarker1346"/> streams.</p>
			<h3>Metadata streams</h3>
			<p>Metadata contains five sections<a id="_idIndexMarker1347"/> that are similar to the PE file sections, but they<a id="_idIndexMarker1348"/> are called streams. The streams’ names start with <code>#</code> and are as follows:</p>
			<ul>
				<li><code>Methods</code> table has an ID of 0x6). </li>
				<li><code>#~</code> stream. This includes the methods’ names, classes’ names, and so on. Here, each item starts with its length, followed by the string, and then the next item’s length followed by the string, and so on.</li>
				<li><code>#Strings</code> stream, but it contains the strings that are used by the application itself, as shown in the following screenshot (with the same structure of item length followed by the string):</li>
			</ul>
			<div><div><img src="img/Figure_9.4_B18500.jpg" alt="Figure 9.4 – The #US Unicode string started with the length and was followed by the actual string&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.4 – The #US Unicode string started with the length and was followed by the actual string</p>
			<ul>
				<li><strong class="bold">#GUID</strong>: Stores the unique identifiers (GUIDs).</li>
				<li><code>#US</code> and <code>#Strings</code>, but it contains all Binary data related to the <a id="_idIndexMarker1349"/>application. It has the same format as the item length, followed by the data blob.</li>
			</ul>
			<p>So, this is the structure of the .NET application. Now, let’s look at how<a id="_idTextAnchor975"/> to distinguish the .NET application from other ex<a id="_idTextAnchor976"/>ecutable files.</p>
			<h2 id="_idParaDest-294"><a id="_idTextAnchor977"/>How to identify a .NET application from PE characteristics</h2>
			<p>The first way that a .NET PE file <a id="_idIndexMarker1350"/>can be identified is by using a <strong class="bold">PEiD</strong> or <strong class="bold">CFF Explorer</strong> that includes signatures that cover .NET applications, as shown in the followin<a id="_idTextAnchor978"/>g screenshot:</p>
			<div><div><img src="img/Figure_9.5_B18500.jpg" alt="Figure 9.5 – PEiD detecting that malware is a .NET application&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.5 – PEiD detecting that malware is a .NET application</p>
			<p>The second way is to<a id="_idIndexMarker1351"/> check the import table inside the data directory. .NET applications always import only one API, which is <code>_CorExeMain</code> from <code>mscoree.dll</code>, as shown here:</p>
			<div><div><img src="img/Figure_9.6_B18500.jpg" alt="Figure 9.6 – .NET application import table&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.6 – .NET applicati<a id="_idTextAnchor979"/>on import table</p>
			<p>Finally, you can check the last but one (15th) entry in the data directory, which represents the CLR header. If it’s populated (that is, contains values other than <code>NULL</code>), then it’s a .NET a<a id="_idTextAnchor980"/>pplication, and this should be a CLR header (you can use CFF Explorer <a id="_idTextAnchor981"/>to check that).</p>
			<h2 id="_idParaDest-295"><a id="_idTextAnchor982"/>The CIL language instruction set</h2>
			<p>The CIL (also known as MSIL) language<a id="_idIndexMarker1352"/> is quite similar to <strong class="bold">Reduced Instruction Set Computer</strong> (<strong class="bold">RISC</strong>) assembly languages. However, it <a id="_idIndexMarker1353"/>doesn’t include any registers, and all the variables, classes, fields, methods, and so on are accessed through their ID in the streams and their tables. Local variables are also accessed through their ID in methods. Most of the code is based on loading variables and constants into the stack, performing an operation (whose result is stored on the stack), and popping this result back into a local variable or field in an object.</p>
			<p>This language consists of a set of opcodes and arguments for these opcode<a id="_idTextAnchor983"/>s (if necessary). Most of the opcodes take up 1 byte. Let’s take a look at the instructions <a id="_idTextAnchor984"/>in this language.</p>
			<h3>Pushing into stack instructions</h3>
			<p>There are many<a id="_idIndexMarker1354"/> instructions for storing values or IDs in the stack. These can be accessed later by an operation or stored in another variable. Here are some examples of them:</p>
			<div><div><img src="img/B18500_09_Table1.jpg" alt=""/>
				</div>
			</div>
			<p class="callout-heading">Important Note </p>
			<p class="callout"><a id="_idTextAnchor985"/>For all the instructions that take an ID, they take an ID in a 2-byte form. There is a shorter version of them that has the <code>.s</code> suffix added to them, which takes an ID in a 1-byte form.</p>
			<p>The instructions that deal <a id="_idIndexMarker1355"/>with the constants or elements of an array (<code>ldc</code> and <code>ldelem</code>) take a suffix that describes the type of that value. Here are the used types:</p>
			<div><div><img src="img/B18500_09_Table2.jpg" alt=""/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor986"/></p>
			<p>Now, let’s learn how to pull a value from the stack out into another variable or field.</p>
			<h3><a id="_idTextAnchor987"/>Pulling out a value from the stack</h3>
			<p>Here are the instructions <a id="_idIndexMarker1356"/>that let you pull out (pop) a value or a reference from the stack into another variable or field:</p>
			<div><div><img src="img/B18500_09_Table3.jpg" alt=""/>
				</div>
			</div>
			<p class="callout-heading">Important Note</p>
			<p class="callout">The instructions that take IDs also have a shorter version with the <code>.s</code> suffix. Some instructions, such as <code>stind</code> and <code>stelem</code>, may have a value type suffix as well (such as <code>.i4</code> or <code>.r8</code>).</p>
			<h3><a id="_idTextAnchor988"/><a id="_idTextAnchor989"/><a id="_idTextAnchor990"/>Mathematical and logical operations</h3>
			<p>The CIL language implements<a id="_idIndexMarker1357"/> the same operations that you will see in any assembly language, such as <code>add</code>, <code>sub</code>, <code>shl</code>, <code>shr</code>, <code>xor</code>, <code>or</code>, <code>and</code>, <code>mul</code>, <code>div</code>, <code>not</code>, <code>neg</code>, <code>rem</code> (the remainder from a division), and <code>nop</code> (for no operation).</p>
			<p>These instructions take their arguments from the stack and save the result back into the stack. These can be stored in a variable using any store instruction (such as <code>stloc</code>).<a id="_idTextAnchor991"/><a id="_idTextAnchor992"/></p>
			<h3>Branching instructions</h3>
			<p>This is the last important <a id="_idIndexMarker1358"/>set of instructions to learn. These instructions are related to branching and conditional jumps. These instructions are not so different from the assembly languages either, but they depend on the stack values for comparing and branching:</p>
			<div><div><img src="img/B18500_09_Table4.jpg" alt=""/>
				</div>
			</div>
			<p>Now, let’s put this knowledge into practice and learn how the source code would translate into these instructions.</p>
			<h2 id="_idParaDest-296"><a id="_idTextAnchor993"/>CIL language into higher-level languages</h2>
			<p>So far, we’ve discussed the various IL language instructions and the key differentiating factors of a .NET application, as well as its file structure. In this section, we will take a look at how these higher-level languages (VB.NET, C#, and others), as well as their statements, <a id="_idTextAnchor994"/>branches, and loops, get converted into CIL language.</p>
			<h3><a id="_idTextAnchor995"/>Local variable assignments</h3>
			<p>Here is an example of setting a<a id="_idIndexMarker1359"/> local variable value with a constant value of <code>10</code>:</p>
			<pre>X = 10;<a id="_idTextAnchor996"/></pre>
			<p>This will be converted into the following:</p>
			<pre>ldc.i4 10  // pushes an int32 constant with value 10 to the stack
stloc.0  // pops a value to local variable 0 (X) from stack</pre>
			<p>Easy peasy.<a id="_idTextAnchor997"/><a id="_idTextAnchor998"/></p>
			<h3>Local variable assignment with a method return value</h3>
			<p>Here is another more complicated <a id="_idIndexMarker1360"/>example that shows you how to call a method, push its arguments to the stack, and store the return value in a local variable (here, it’s calling a static method from a class directly and not a virtual method from an object):</p>
			<pre class="source-code">
Process[] Process = System.Diagnostics.Process::GetProcessesByName("App01");</pre>
			<p>The intermediate code looks like this:</p>
			<pre>ldstr "App01" // here, ldstr accesses that string by its ID and the string itself is located in the #US stream
call class [System]System.Diagnostics.Process[] [System]System.Diagnostics.Process::GetProcessesByName(string)
Stloc.0       // store the return value in local variable 0 (X<a id="_idTextAnchor999"/><a id="_idTextAnchor1000"/>)</pre>
			<h3>Basic branching statements</h3>
			<p>For <code>if</code> statements, the <a id="_idIndexMarker1361"/>C# code looks like this:</p>
			<pre class="source-code">
if (X == 50)
{
  Y = 20;
}</pre>
			<p>The corresponding IL code will look like this (here, we are adding the line numbers for branching instructions):</p>
			<pre>00: ldloc.0  // load local variable 0 (X)
01: ldc.i4.s 50  // load int32 constant with value 50 into the stack
02: bne 5       // if not equal, branch/jump to line number 5
03: ldc.i4.s 20 // load int32 constant with value 20 into the stack
04: stloc.1     // place the value 20 from the stack to the local variable 1 (Y)
05: nop       // here, it could be any code that goes after the If statement
06: nop</pre>
			<p>These instructions will also help us understand the next topic – loop<a id="_idTextAnchor1001"/><a id="_idTextAnchor1002"/><a id="_idTextAnchor1003"/>s.</p>
			<h3>Loops statements</h3>
			<p>The last example we will<a id="_idIndexMarker1362"/> cover in this section is the <code>for</code> loop. This statement is more complicated than <code>if</code> statements and even more complicated than the <code>while</code> statement for loops. However, it’s more widely used in C#, and understanding it will help you understand other complicated statements in the IL language. The C# code looks like this:</p>
			<pre class="source-code">
for (i = 0; i &lt; 50; i++)
{
  X = i + 20;
}</pre>
			<p>The equivalent IL code <a id="_idIndexMarker1363"/>will look like this:</p>
			<pre>00: ldc.i4.0 // pushes a constant with value 0
01: stloc.0  // stores it in local variable 0 (i). This represents i = 0
02: br 11    // unconditional branching to line 11
03: ldloc.0  // loads variable 0 (i) into stack
04: ldc.i4.s 20 // loads an int32 constant with value 20 into stack
05: add      // adds both values from the stack and pushes the result back to stack (i + 20)
06: stloc.1  // stores the result in a local variable 1 (X)
07: ldloc.0  // loads local variable 0 (i)
08: ldc.i4.1 // pushes a constant value of 1
09: add      // adds both values
10: stloc.0  // stores the result in local variable i (i++)
11: ldloc.0  // loads again local variable i (this is the branching destination)
12: ldc.i4.s 50 // loads an int32 constant with value 50 into stack
13: blt.s 3  // compares both values from stack (i and 50) and branches to line number 3 if the first value is lower</pre>
			<p>That’s it for the .NET file structure and IL language. Now, let’s learn ho<a id="_idTextAnchor1004"/>w to analyze .NET malw<a id="_idTextAnchor1005"/>are.</p>
			<h1 id="_idParaDest-297"><a id="_idTextAnchor1006"/>.NET malware analysis</h1>
			<p>As you may know, .NET applications are <a id="_idIndexMarker1364"/>easy to disassemble and decompile so that they become as close to the original source code as possible. This leaves malware more exposed to reverse engineering. We will describe multiple obfuscation techniques in this section, together with the deobfuscation process. First, let’s explore the available tools for .NET reverse enginee<a id="_idTextAnchor1007"/><a id="_idTextAnchor1008"/><a id="_idTextAnchor1009"/>ring.</p>
			<h2 id="_idParaDest-298"><a id="_idTextAnchor1010"/>.NET analysis tools</h2>
			<p>Here are the most well-known tools <a id="_idIndexMarker1365"/>for decompiling and analysis:</p>
			<ul>
				<li><strong class="bold">ILSpy</strong>: This is a good <a id="_idIndexMarker1366"/>decompiler for static analysis, but it can’t debug malware.</li>
				<li><strong class="bold">dnSpy</strong>: Based on ILSpy <a id="_idIndexMarker1367"/>and dnlib, it’s a disassembler and decompiler that also allows you to debug and patch code.</li>
				<li><strong class="bold">.NET reflector</strong>: A commercial <a id="_idIndexMarker1368"/>decompiler tool for static analysis and debugging in Visual Studio.</li>
				<li><strong class="bold">.NET IL Editor (DILE)</strong>: Another<a id="_idIndexMarker1369"/> powerful tool that allows you to disassemble and debug .NET applications.</li>
				<li><strong class="bold">dotPeek</strong>: A tool that’s used to<a id="_idIndexMarker1370"/> decompile malware into C# code. It’s good for static analysis and for recompiling and debugging with the help of Visual Studio.</li>
				<li><strong class="bold">Visual Studio</strong>: Visual Studio is<a id="_idIndexMarker1371"/> the main IDE for .NET languages. It allows you to compile the source code and debug .NET applications.</li>
				<li><strong class="bold">SOSEX</strong>: A plugin for WinDbg that<a id="_idIndexMarker1372"/> simplifies .NET debugging.</li>
			</ul>
			<p>Here are the most well-known deobfuscation tools:</p>
			<ul>
				<li><strong class="bold">de4dot</strong>: Based on dnlib as <a id="_idIndexMarker1373"/>well, it is very useful for deobfuscating samples that have been obfuscated by known obfuscation tools</li>
				<li><strong class="bold">NoFuserEx</strong>: A deobfuscator for the <a id="_idIndexMarker1374"/>ConfuserEx obfuscator</li>
				<li><strong class="bold">Detect It Easy (DiE)</strong>: A good tool for <a id="_idIndexMarker1375"/>detecting.NET obfuscators</li>
			</ul>
			<p>In the following examples, we are<a id="_idIndexMarker1376"/> going to mainly us<a id="_idTextAnchor1011"/>e the dnSpy tool.</p>
			<h2 id="_idParaDest-299"><a id="_idTextAnchor1012"/>Static and dynamic analysis</h2>
			<p>Now, we will learn how to <a id="_idIndexMarker1377"/>perform static analysis and dynamic analysis, and then patch the sample to delete or modify th<a id="_idTextAnchor1013"/><a id="_idTextAnchor1014"/><a id="_idTextAnchor1015"/>e obfuscator code.</p>
			<h3>.NET static analysis</h3>
			<p>Multiple tools can help you<a id="_idIndexMarker1378"/> disassemble and decompile a sample, and even convert it completely into C# or VB.NET source code. For example, you can use <strong class="bold">dnSpy</strong> to decompile <a id="_idIndexMarker1379"/>a sample by just dragging and dropping it into the application interface. This is what this application looks like:</p>
			<div><div><img src="img/Figure_9.7_B18500.jpg" alt="Figure 9.7 – Static analysis of a malicious sample with dnSpy&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.7 – Static analysis of a malicious sample with dnSpy</p>
			<p>You can click on <strong class="bold">File </strong>| <strong class="bold">Export To Project</strong> to export the decompiled source code into a Visual Studio project. Now, you can read the source code, modify it, write comments on it, or modify the names of<a id="_idIndexMarker1380"/> the functions for better analysis. dnSpy can show the actual IL language of the sample if you right-click and choose <strong class="bold">Edit IL Language</strong> from the menu.</p>
			<p>To go to the main function, you can right-click on the program (from the sidebar) and choose <code>OnRun</code>, <code>OnStartup</code>, or <code>OnCreateMainForm</code>, as well as in forms. When analyzing code associated with forms, start from their constructor (<code>.ctor</code>) and pay attention to what function is being added to <code>base.Load</code>, as well as what functions are called after this. Some methods, such as the form’s <code>OnLoad</code> method, may be<a id="_idTextAnchor1016"/> overridden as well.</p>
			<p>Another tool that you could use is <strong class="bold">dotPeek</strong>. It’s a <a id="_idIndexMarker1381"/>free tool that can also decompile a sample and export it to C# source code. It has a very similar interface to Visual Studio. You can also analyze the CIL language using IDA.</p>
			<p>Finally, a standard <code>ildasm.exe</code> tool can disassemble <a id="_idIndexMarker1382"/>and export the IL code of a sample:</p>
			<pre class="source-code">
ildasm.exe &lt;malware_sam<a id="_idTextAnchor1017"/><a id="_idTextAnchor1018"/>ple&gt; /output output.il</pre>
			<h3>.NET dynamic analysis</h3>
			<p>For debugging, there are fewer tools to use. dnSpy is a complete solution when it comes to static and dynamic analysis. It allows you to set breakpoints and step into and step over for debugging. It also shows the variables’ values.</p>
			<p>To start debugging, you<a id="_idIndexMarker1383"/> need to set a breakpoint on the entry point of the sample. Another option is to export the source code to C#, and then recompile and debug the program in Visual Studio, which will give you full control over the execution. Visual Studio also shows the variables’ values and has lots of features to facilitate debugging.</p>
			<p>If the sample is too obfuscated to debug or export to C# code by dotPeek or Dnspy, you can rely on <code>ildasm.exe</code> to export the sample code in IL language and use <code>ilasm.exe</code> to compile it again with debug information. Here is how to recompile it with <code>ilasm.exe</code>:</p>
			<pre>ilasm.exe /debug output.il /output=&lt;new sample exe file&gt;</pre>
			<p>With the <code>/debug</code> argument, a <code>.pdb</code> file for the sample has been created, which includes<a id="_idTextAnchor1019"/><a id="_idTextAnchor1020"/> its debug information.</p>
			<h3>Patching a .NET sample</h3>
			<p>There are multiple ways to<a id="_idIndexMarker1384"/> modify the sample code for deobfuscating, simplifying the code, or forcing the execution to go through a specific path. The first option is to use the dnSpy patching capability. In dnSpy, you can edit any method or class by right-clicking, selecting <strong class="bold">Edit Method (C#)</strong>, modifying the code, and recompiling. You can also export the whole project, modify the source code, go to <strong class="bold">Edit Method (C#)</strong>, and click on the C# icon to import a source code file to be compiled by replacing the original code of that class. You can also modify the malware source code (after exporting) in Visual Studio and rec<a id="_idTextAnchor1021"/>ompile it for debugging.</p>
			<p>In dnSpy, you can modify the local variables’ names by selecting <strong class="bold">Edit IL Instruction</strong> from the menu and selecting <strong class="bold">Locals</strong> to modify them by their local variable names, as shown in the following screenshot. Concerning the classes and methods, you can modify their names just by updating them using the <strong class="bold">Edit Method (C#)</strong> or <strong class="bold">Edit Class (C#)</strong> options:</p>
			<div><div><img src="img/Figure_9.8_B18500.jpg" alt="Figure 9.8 – Editing local variables in dnSpy&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.8 – Editing local variables in dnSpy</p>
			<p>You can also edit the IL <a id="_idIndexMarker1385"/>code directly by selecting <strong class="bold">Edit IL Instruction</strong> and modifying the instructions. This allows you to choose the instruction and t<a id="_idTextAnchor1022"/>he field or vari<a id="_idTextAnchor1023"/>able you want to access.</p>
			<h2 id="_idParaDest-300"><a id="_idTextAnchor1024"/>Dealing with obfuscation</h2>
			<p>In this section, we will look at <a id="_idIndexMarker1386"/>different common obfuscation techniques for .NET samples and lear<a id="_idTextAnchor1025"/><a id="_idTextAnchor1026"/><a id="_idTextAnchor1027"/>n how to deobfuscate them.</p>
			<h3>Obfuscated names for classes, methods, and others</h3>
			<p>One of the most common obfuscation<a id="_idIndexMarker1387"/> techniques is to obfuscate the names of the classes, methods, variables, fields, and so on – basically everything that has a name.</p>
			<p>Obfuscation can get even harder if you obfuscate the names into other alphabets or other symbols (since the names are in Unicode), such as Chinese or Japanese.</p>
			<p>You can try to deobfuscate such samples automatically by running the <strong class="bold">de4dot</strong> deobfuscator from the command line, like so:</p>
			<pre>de4dot.exe &lt;sample&gt;</pre>
			<p>This will rename all the obfuscated names, as shown in the following screenshot (the HammerDuke sample is shown here):</p>
			<div><div><img src="img/Figure_9.9_B18500.jpg" alt="Figure 9.9 – The Hammerduke malware before and after running de4dot to deobfuscate the names&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.9 – The Hammerduke malware before and after running de4dot to deobfuscate the names</p>
			<p>You can also rename the methods manually to add more meaningful names by right-clicking on the method <a id="_idIndexMarker1388"/>and then selecting <strong class="bold">Edit Method</strong> or clicking <em class="italic">Alt</em> + <em class="italic">Enter</em> and changing the name of the method. After that, you need to save the module and reload it for the changes to be put into effect.</p>
			<p>You can also edit local variable names by right-clicking on the method and choosing <strong class="bold">Edit Method Body</strong> or <strong class="bold">Edit IL Instruc<a id="_idTextAnchor1028"/><a id="_idTextAnchor1029"/><a id="_idTextAnchor1030"/>tions</strong> and choosing <strong class="bold">Locals</strong>.</p>
			<h3>Encrypted strings inside the Binary</h3>
			<p>Another common<a id="_idIndexMarker1389"/> technique used by .NET malware is encrypting its strings. This approach hides these strings from signature-based tools, as well as from less experienced malware analysts. Working with encrypted strings requires finding the decryption function and setting a breakpoint on each of its calls, as shown in the following screenshot:</p>
			<div><div><img src="img/Figure_9.10_B18500.jpg" alt="Figure 9.10 – The Samsam ransomware encrypted strings getting decrypted in memory&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.10 – The Samsam ransomware encrypted strings g<a id="_idTextAnchor1031"/>etting decrypted in memory</p>
			<p>Sometimes, there <a id="_idIndexMarker1390"/>are hard-to-reach encrypted strings, so you may not see them decrypted in the default execution of the malware – for example, because the C&amp;C is down, or maybe there are additional C&amp;C addresses that won’t get decrypted if the first C&amp;C is working. In these cases, you can do any of the following:</p>
			<ul>
				<li>You can try to use de4dot to decrypt the encrypted strings by giving it the method ID. You can find the method ID by checking the <code>Methods</code> table in the <code>#~</code> stream, as shown in the following screenshot:</li>
			</ul>
			<div><div><img src="img/Figure_9.11_B18500.jpg" alt="Figure 9.11 – The Samsam ransomware myﬀ11() decryption function, ID 0x0600000C&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.11 – The Samsam ransomware myﬀ11() decryption function, ID 0x0600000C</p>
			<p>Then, you can decrypt the strings dynamically using the following command:</p>
			<pre><strong class="bold">de4dot &lt;sample&gt; --strtyp delegate --strtok &lt;decryption method ID&gt;</strong></pre>
			<ul>
				<li>You can modify the entry point code and add a call to the decryption function to decrypt the strings. The <a id="_idIndexMarker1391"/>preceding screenshot is created by repointing calls to the decryption functions, including the encrypted strings. For dnSpy to process this code, you must use these strings by changing an object field or calling <code>System.Console.Writeline()</code> to print that string to the console. You will need to save the module after modifying it and reopen it for the changes to be put into effect.</li>
			</ul>
			<p>Another option is to export the whole malware source code from dnSpy by clicking on <strong class="bold">File </strong>| <strong class="bold">Export To Project</strong> (other tools may have similar functionality), modifying it, and then recompiling it with Visual <a id="_idTextAnchor1032"/><a id="_idTextAnchor1033"/><a id="_idTextAnchor1034"/>Studio before debugging it.</p>
			<h3>The sample is obfuscated using an obfuscator</h3>
			<p>There are many .NET obfuscators<a id="_idIndexMarker1392"/> publicly available. They are generally supposed to be used for protecting intellectual property, but they are also commonly used by malware authors to protect their samples from reverse engineering. There are multiple tools for detecting known packers, such as <strong class="bold">Detect It Easy </strong>(<strong class="bold">DiE</strong>), as shown in the<a id="_idIndexMarker1393"/> following screenshot:</p>
			<div><div><img src="img/Figure_9.12_B18500.jpg" alt="Figure 9.12 – Detect it Easy detecting the obfuscator (ConfuserEx) used to protect against malware&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.12 – Detect it Easy detecting the obfuscator (ConfuserEx) used to protect against malware</p>
			<p>You can also use the de4dot tool to detect the obfuscator by only running the <code>de4dot.exe -d &lt;sample&gt;</code> command or deobfuscate the sample using the <a id="_idTextAnchor1035"/><code>de4dot.exe &lt;sample&gt;</code> command.</p>
			<p>For custom and unknown <a id="_idIndexMarker1394"/>obfuscators, you will need to go through debugging and patching processes to deal with them. Before doing so, check different sources, if there are solutions or deobfuscators for it. If the obfuscator is shareware, you may be able to communicate with the authors and get their aid to deobfuscate the sample (as these ob<a id="_idTextAnchor1036"/>fuscators are not designed to help malware authors protect their samples).</p>
			<h3>Compile after delivery and proxy code execution</h3>
			<p>Instead of distributing <a id="_idIndexMarker1395"/>malicious .NET binaries directly, attackers may also attempt to dynamically compile the malicious payload on the victim’s machine using the standard <code>csc.exe</code> utility. This approach is commonly used with the help of scripts, which we will cover in the next chapter.</p>
			<p>In addition, attackers may use the standard <code>InstallUtil.exe</code> tool to load malicious .NET samples instead of <a id="_idIndexMarker1396"/>executing them directly. The main advantage of this approach for attackers is the fact that in this case, all the associated activity will be done on behalf of the signed legitimate application. It is important to know that in this case, the execution of the loaded module will start from the class inherited from the standard <code>System.Configuration.Install.Installer</code> class.</p>
			<h3>Dynamically loaded code blocks</h3>
			<p>Sometimes, malware<a id="_idIndexMarker1397"/> may decrypt or decode the next block of code and load it dynamically using, for instance, the standard <code>AppDomain.CurrentDomain.Load</code> method. In this case, it is possible to reach the first instruction of this payload in dnSpy by stepping into this method and tracing the code until the <code>UnsafeInvokeInternal</code> -&gt; <code>RuntimeMethodHandle.InvokeMethod</code> control transfer point is reached. Here is an example from the AgentTesla malware:</p>
			<div><div><img src="img/Figure_9.13_B18500.jpg" alt="Figure 9.13 – Transferring control to the payload inside AppDomain.CurrentDomain.Load&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.13 – Transferring control to the payload inside AppDomain.CurrentDomain.Load</p>
			<p>Once the first line of the embedded payload is reached, dnSpy will handle the rest, decompiling this newly introduced block of code and adding it to the <strong class="bold">Assembly Explorer</strong> panel to be used for static analysis.</p>
			<p>That’s it for .NET-based malware; we have learned everything we need to know to start analyzing the corresponding samples efficiently. Now, let’s talk about t<a id="_idTextAnchor1037"/>hreats written in Visual Basic.</p>
			<h1 id="_idParaDest-301"><a id="_idTextAnchor1038"/>The essentials of Visual Basic</h1>
			<p>Visual Basic is a high-level programming<a id="_idIndexMarker1398"/> language developed by Microsoft and based on the BASIC family of languages. Initially, its main feature was its ability to quickly create graphical interfaces and good integration with the COM model, which<a id="_idIndexMarker1399"/> fostered easy access to <strong class="bold">ActiveX Data Objects</strong> (<strong class="bold">ADOs</strong>).</p>
			<p>The last version of it was released in 1998 and the extended support for it ended in 2008. However, all modern Windows operating systems keep supporting it and, while it is rarely used by APT actors, many mass malware families are still written on it. In addition, many malicious packers use this programming language, often detected as Vbcrypt/VBKrypt or something<a id="_idIndexMarker1400"/> similar. Finally, <strong class="bold">Visual Basic for Applications </strong>(<strong class="bold">VBA</strong>), which is still widely used in Microsoft Office applications and was even upgraded to version 7 in 2010, is largely the same language as VB6 and uses the same runtime library.</p>
			<p>In this section, we will dive into two different compilation modes supported by the latest version of Visual Basic (which is 6.0 at the time of writing) and provide recommendations on <a id="_idTextAnchor1039"/><a id="_idTextAnchor1040"/>how to analyze samples using them.</p>
			<h2 id="_idParaDest-302"><a id="_idTextAnchor1041"/>File structure</h2>
			<p>The compiled Visual<a id="_idIndexMarker1401"/> Basic samples look like standard MZ-PE executables. They can easily be recognized by a unique imported DLL, <code>MSVBVM60.DLL</code> (<code>MSVBVM50.DLL</code> was used for the older version). PEiD tool is generally very good at identifying this programming language (when the sample is not packed, obviously):</p>
			<div><div><img src="img/Figure_9.14_B18500.jpg" alt="Figure 9.14 – PEiD identifying Visual Basic&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.14 – PEiD identifying Visual Basic</p>
			<p>At the entry point of the<a id="_idIndexMarker1402"/> sample, we can expect to see a call to the <code>ThunRTMain</code> (<code>MSVBVM60.100</code>) runtime function:</p>
			<div><div><img src="img/Figure_9.15_B18500.jpg" alt="Figure 9.15 – Entry point of the Visual Basic sample&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.15 – Entr<a id="_idTextAnchor1042"/>y point of the Visual Basic sample</p>
			<p>The <code>Thun</code> prefix here is a reference to the original project’s name, <strong class="bold">BASIC Thunder</strong>. This function receives a pointer to the following structure:</p>
			<div><div><img src="img/B18500_09_Table5.jpg" alt=""/>
				</div>
			</div>
			<p>Now, let’s take<a id="_idIndexMarker1403"/> a look at the <code>ProjectInfo</code> structure:</p>
			<div><div><img src="img/B18500_09_Table6.jpg" alt=""/>
				</div>
			</div>
			<p><a id="_idTextAnchor1043"/>Here, one of the most interesting fields is <code>NativeCode</code>. This field can be used to figure out whether the sample has been compiled as p-code or native code. Now, let’s see why this <a id="_idTextAnchor1044"/>information is important.</p>
			<h2 id="_idParaDest-303"><a id="_idTextAnchor1045"/>P-code versus native code</h2>
			<p>Starting from Visual Basic 5, the<a id="_idIndexMarker1404"/> language supports two compilation modes: p-code and native code (before p-code was the only option). To understand the differences between them, we need to understand what p-code is.</p>
			<p><code>P-code</code>, which stands for packed code or pseudocode, is an intermediate language with an instruction format similar to machine code. In other words, it is a form of bytecode. The main reason behind introducing it is to reduce the program’s size at the expense of execution speed. When the sample is compiled as p-code, the bytecode is interpreted by the language runtime. In contrast, the native code option allows developers to compile a sample into the usual machine code, which generally works faster but takes up more space because of multiple overhead instructions being used.</p>
			<p>It is important to know which mode the analyzed sample is compiled in as it defines what static and dynamic analysis tools should be used. As for how to distinguish them, the easiest way would be to look at the <code>NativeCode</code> field we mentioned previously. If it is set to <code>0</code>, this means that the p-code compilation mode is being used. Another indicator here is that the difference between the <code>CodeEnd</code> and <code>CodeStart</code> values will only be a few bytes maximum as there will be no native code functions.</p>
			<p><a id="_idTextAnchor1046"/>One more (less reliable) approach is to look at the import table:</p>
			<ul>
				<li><code>MSVBVM60.DLL</code>, which provides access to all the necessary VB functions:</li>
			</ul>
			<div><div><img src="img/Figure_9.16_B18500.jpg" alt="Figure 9.16 – The import table of the Visual Basic sample compiled in p-code mode&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.16 – The import table of the Visual Basic sample compiled in p-code mode</p>
			<ul>
				<li><code>MSVBVM60.DLL</code>, there<a id="_idIndexMarker1405"/> will also be the typical system DLLs such as <code>kernel32.dll</code> and the corresponding import functions:</li>
			</ul>
			<div><div><img src="img/Figure_9.17_B18500.jpg" alt="Figure 9.17 – The import table of the Visual Basic sample compiled in native code mode&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.17 – The import table of the Visual Basic sample compiled in native code mode</p>
			<p><a id="_idTextAnchor1047"/>A quick way to distinguish between these modes is to load a sample into a free <strong class="bold">VB Decompiler Lite</strong> program and take a<a id="_idIndexMarker1406"/> look at the code compilation type (marked in bold) and the functions themselves. If the instructions there are typical x86 instructions, then the sample has been compiled as native code; otherwise, p-code mode has been used:</p>
			<div><div><img src="img/Figure_9.18_B18500.jpg" alt="Figure 9.18 – P-code versus native code samples in VB Decompiler Lite&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.18 – P-code versus native code samples in VB Decompiler Lite</p>
			<p><a id="_idTextAnchor1048"/>We will cover this tool in<a id="_idIndexMarker1407"/> greater detail in the next section.<a id="_idTextAnchor1049"/></p>
			<h2 id="_idParaDest-304"><a id="_idTextAnchor1050"/>Common p-code instructions</h2>
			<p>Multiple basic opcodes <a id="_idIndexMarker1408"/>take up 1 byte (<code>0x00-0xFA</code>); the bigger 2-byte opcodes that start with a prefix byte from the <code>0xFB</code>-<code>0xFF</code> range are used less frequently. Here are some examples of the most common p-code instructions that are generally seen when exploring VB disassembly:</p>
			<ul>
				<li>Data storage and movement:<ul><li><code>LitStr/LitVarStr</code>: Initializes a string</li><li><code>LitI2/LitI4/...</code>: Pushes an integer value to the stack (often used to pass arguments)</li><li><code>FMemLdI2/FMemLdRf/...</code>: Loads values of a particular type (memory)</li><li><code>Ary1StI2/Ary1StI4/...</code>: Puts values of a particular type into an array</li><li><code>Ary1LdI2/Ary1LdI4/...</code>: Loads values of a particular type from an array</li><li><code>FStI2/FStI4/...</code>: Puts a variable value into the stack</li><li><code>FLdI2/FLdI4/...</code>: Loads a value into a variable from the stack</li><li><code>FFreeStr</code>: Frees a string</li><li><code>ConcatStr</code>: Concatenates a string</li><li><code>NewIfNullPr</code>: Allocates space if null</li></ul></li>
				<li>Arithmetic operations:<ul><li><code>AddI2/AddI4/...</code>: Adding operation</li><li><code>SubI2/SubI4/...</code>: Subtraction operation</li><li><code>MulI2/MulI4/...</code>: Multiplication operation</li><li><code>DivR8</code>: Division operation</li><li><code>OrI4/XorI4/AndI4/NotI4/...</code>: Logical operations</li></ul></li>
				<li>Comparison:<ul><li><code>EqI2/EqI4/EqStr/...</code>: Check if equal </li><li><code>NeI2/NeI4/NeStr/...</code>: Check if not equal </li><li><code>GtI2/GtI4/...</code>: Check if greater than </li><li><code>LeI2/LeI4/...</code>: Check if less than or equal to</li></ul></li>
				<li>Control flow:<ul><li><code>VCallHresult/VCallAd(VCallI4)/...</code>: Calls a function</li><li><code>ImpAdCallI2/ImpAdCallI4/...</code>: Calls an import function (API) </li><li><code>Branch/BranchF</code>: Branches<a id="_idIndexMarker1409"/> when the condition is met</li></ul></li>
			</ul>
			<p>There are many more of these. If some new opcode is not clear to you and you need to understand its functionality, it can be found in the unofficial documentation (not very detailed) or explored in the debugge<a id="_idTextAnchor1051"/>r.</p>
			<p>Here are the most common abbreviations used in opcode names:</p>
			<ul>
				<li><code>Ad</code>: Address </li>
				<li><code>Rf</code>: Reference </li>
				<li><code>Lit</code>: Literal </li>
				<li><code>Pr</code>: Pointer </li>
				<li><code>Imp</code>: Import </li>
				<li><code>Ld</code>: Load</li>
				<li><code>St</code>: Store</li>
				<li><code>C</code>: Cast</li>
				<li><code>DOC</code>: Duplicate opcode</li>
			</ul>
			<p>All the common data type <a id="_idIndexMarker1410"/>abbreviations that are used are pretty much self-explanatory:</p>
			<ul>
				<li><code>I</code>: Integer (<code>UI1</code> – byte, <code>I2</code> – integer, <code>I4</code> – long)</li>
				<li><code>R</code>: Real (<code>R4</code> – single, <code>R8</code> – double)</li>
				<li><code>Bool</code>: Boolean </li>
				<li><code>Var</code>: Variant </li>
				<li><code>Str</code>: String </li>
				<li><code>Cy</code>: Currency</li>
			</ul>
			<p>While it may take some time to get used to their notations, there aren’t that many variations, so after a while, it becomes pretty straightforward to understand the core logic. Another option would be to invest in a proper decompiler and avoid dealing with p-code instructio<a id="_idTextAnchor1052"/>ns. We will cover this lat<a id="_idTextAnchor1053"/>er.</p>
			<h1 id="_idParaDest-305"><a id="_idTextAnchor1054"/>Dissecting Visual Basic samples</h1>
			<p>Now that we have gained some knowledge of the essentials of Visual Basic, it’s time to shift our focus and<a id="_idIndexMarker1411"/> learn how to dissect Visual Basic samples. In this section, we are going to perform a detailed static and dynamic anal<a id="_idTextAnchor1055"/><a id="_idTextAnchor1056"/>ysis.</p>
			<h2 id="_idParaDest-306"><a id="_idTextAnchor1057"/>Static analysis</h2>
			<p>The common part of VB<a id="_idIndexMarker1412"/> malware is that the code generally gets executed as part of the <code>SubMain</code> routine and event handlers, where timer and form load events are particularly typical.</p>
			<p>As we have already mentioned, the choice of tools will be defined by the compilation mode that’s used when creating a malware sa<a id="_idTextAnchor1058"/>mple.</p>
			<h3>P-code</h3>
			<p>For p-code samples, <strong class="bold">VB Decompiler</strong> can be used to get <a id="_idIndexMarker1413"/>access to its internals. The Lite version is free and <a id="_idIndexMarker1414"/>provides access to the p-code disassembly, which may be enough for most cases. If the engineer doesn’t have enough expertise or time to deal with the p-code syntax, then the paid full version provides a powerful decompiler that produces more readable Visual Basic source code as output:</p>
			<div><div><img src="img/Figure_9.19_B18500.jpg" alt="Figure 9.19 – The same p-code function in VB Decompiler disassembled and decompiled&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.19 – The same p-code function in VB Decompiler disassembled and deco<a id="_idTextAnchor1059"/>mpiled</p>
			<p>Another popular <a id="_idIndexMarker1415"/>option is the <strong class="bold">P32Dasm</strong> tool, which allows you to obtain p-code listings in a few clicks:</p>
			<div><div><img src="img/Figure_9.20_B18500.jpg" alt="Figure 9.20 – P32Dasm in action&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.20 – P32Dasm in action</p>
			<p>One of its useful<a id="_idIndexMarker1416"/> features is its ability to produce MAP files that can later be loaded into OllyDbg or IDA using dedicated plugins. Its documentation also mentions the Visual Basic debugger plugin for IDA, but it doesn’t seem to be available to the general public.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">A hint for first-time users – if necessary, put all requested <code>.ocx</code> files (can be downloaded separately if not available) into the P32Dasm’s root directory to make i<a id="_idTextAnchor1060"/>t work.</p>
			<h3>Native code</h3>
			<p>For samples compiled as native code, any Windows static analysis tool we’ve already discussed will do the<a id="_idIndexMarker1417"/> trick. In this case, the solutions that can effectively apply structures (such as IDA, Binary Ninja, or radare2) can save <a id="_idTextAnchor1061"/>time:</p>
			<div><div><img src="img/Figure_9.21_B18500.jpg" alt="Figure 9.21 – The beginning of the native code after applying the ProjectInfo structure&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.21 – The beginning of the native code after applying the ProjectInfo structure</p>
			<p>VB Decompiler can be used to quickly access the names of procedures without digging into VB structures. For IDA, a free <code>SubMain</code> function by taking the address of the VB header (as we know, it is passed to the <code>ThunRTMain</code> function in the first instruction at the sample’s entry point) and get the address of <code>SubMain</code> by its offset (<code>0x2C</code>). For example, in radare2, you would do the following:</p>
			<div><div><img src="img/Figure_9.22_B18500.jpg" alt="Figure 9.22 – Finding the SubMain address for the VB sample in radare2&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.22 – Finding the SubMain address for the VB sample in radare2</p>
			<p>Now, let’s talk about the<a id="_idIndexMarker1419"/> dynamic analysis of Visual Basic <a id="_idTextAnchor1063"/>samples.</p>
			<h2 id="_idParaDest-307"><a id="_idTextAnchor1064"/>Dynamic analysis</h2>
			<p>Just like static analysis, a<a id="_idIndexMarker1420"/> dynamic analysis will be different for p-code and na<a id="_idTextAnchor1065"/>tive code<a id="_idTextAnchor1066"/> samples.</p>
			<h3>P-code</h3>
			<p>When there is a need to<a id="_idIndexMarker1421"/> debug p-code compiled code, generally, there are two options available: debug the p-code instructions themselves or debug the restored source code.</p>
			<p>The second option requires a high-quality decompiler that can produce something close to the original source code. Usually, VB Decompiler does this job pretty well. In this case, its output can be loaded into an IDE of your choice and after some minor modifications, it can be used to debug any usual source code. Often, it isn’t necessary to restore the whole project as only certain parts of the code need to <a id="_idTextAnchor1067"/>be traced.</p>
			<p>While this approach is more user-friendly in general, sometimes, debugging actual p-code may be the only option available, for example, when a decompiler doesn’t work properly or just isn’t available. In this case, the <strong class="bold">WKTVBDE</strong> project becomes<a id="_idIndexMarker1422"/> extremely handy as it allows you to debug p-code compiled applications. It requires <a id="_idTextAnchor1068"/>a malicious sample to be placed in its root directory to be loade<a id="_idTextAnchor1069"/>d properly.</p>
			<h3>Native code</h3>
			<p>For native code samples, just like for static analysis, dynamic analysis tools for Windows can be used. The <a id="_idIndexMarker1423"/>choice mainly depends on the analyst’s pre<a id="_idTextAnchor1070"/>ferences and available budget.</p>
			<p>At this stage, we have learned enough about VB to start analyzing the first few samples. Now, let’s talk about Java-ba<a id="_idTextAnchor1071"/>sed threats.</p>
			<h1 id="_idParaDest-308"><a id="_idTextAnchor1072"/>The internals of Java samples</h1>
			<p>Java is a cross-platform programming language that is commonly used to create both local and web applications. Its <a id="_idIndexMarker1424"/>syntax was influenced by another object-oriented<a id="_idIndexMarker1425"/> language called Smalltalk. Originally developed by Sun Microsystems and first released in 1995, it later became a part of the Oracle Corporation portfolio. At the time of writing, it is considered to be one of the most popular programming languages in use.</p>
			<p>Java applications are compiled into the <a id="_idIndexMarker1426"/>bytecode that’s executed by <strong class="bold">Java Virtual Machines</strong> (<strong class="bold">JVMs</strong>). The idea here is to let applications that have been compiled once be used across all supported platforms without any changes required. There are multiple JVM implementations available on the market and at the time of writing (starting from Java 1.3), HotSpot JVM is the default official option. Its distinctive feature is its combination of the interpreter and the JIT compiler, which can compile bytecode into native machine instructions based on the profiler output to speed up the execution of slower parts of the code. Most PC users get it by installing the <strong class="bold">Java Runtime Environment</strong> (<strong class="bold">JRE</strong>), which is<a id="_idIndexMarker1427"/> a software distribution that includes the standalone JVM (HotSpot), the standard libraries, and a configuration<a id="_idIndexMarker1428"/> toolset. The <strong class="bold">Java Development Kit</strong> (<strong class="bold">JDK</strong>), which also contains JRE, is another popular option since it is a development environment for building applications, applets, and components using the Java language. For mobile devices, the process is quite different. We will cover it in <a href="B18500_13.xhtml#_idTextAnchor1503"><em class="italic">Chapter 13</em></a>, <em class="italic">Analyzing Android Malware Samples</em>.</p>
			<p>In terms of malware, Java is quite<a id="_idIndexMarker1429"/> popular among <strong class="bold">Remote Access Tool</strong> (<strong class="bold">RAT</strong>) developers. Examples include jRAT or the Frutas/Adwind families distributed as JAR files. Exploits used to be another big problem for users until recent changes were introduced by the industry. In this section, we will explore the internals of the compiled Java files and learn how to analyze malware w<a id="_idTextAnchor1073"/><a id="_idTextAnchor1074"/>hile leveraging it.</p>
			<h2 id="_idParaDest-309"><a id="_idTextAnchor1075"/>File structure</h2>
			<p>Once compiled, text <code>.java</code> files become <code>.class</code> files and can be<a id="_idIndexMarker1430"/> executed by the JVM straight away.</p>
			<p>Here is their structure according to the official documentation:</p>
			<pre class="source-code">
ClassFile {
  u4 magic;
  u2 minor_version;
  u2 major_version;
  u2 constant_pool_count;
  cp_info constant_pool[constant_pool_count-1]; 
  u2 access_flags;
  u2 this_class; 
  u2 super_class;
  u2 interfaces_count;
  u2 interfaces[interfaces_count]; 
  u2 fields_count;
  field_info fields[fields_count]; 
  u2 methods_count;
  method_info methods[methods_count]; 
  u2 attributes_count;
  attribute_info attributes[attributes_count];
}</pre>
			<p>The magic value that’s used in this case is a hexadecimal DWORD, <code>0xCAFEBABE</code>. The other fields are self-explanatory.</p>
			<p>The most common way to release a more complex project is to build a JAR file that contains multiple compiled modules, as well as auxiliary metadata files such as <code>MANIFEST.MF</code>. JAR files follow the usual ZIP archive format and can be extracted using any unpacking software that supports it.</p>
			<p>Finally, the <code>&lt;jar&gt;</code> field, which is <a id="_idIndexMarker1432"/>a reference to the actual JAR file, and the <code>&lt;applet-desc&gt;</code> field, which, among other things, specifies the name of the main Java class to be loaded.</p>
			<p>There are numerous ways that Java-based samples can be analyzed. In this section, we are going to explore multiple options available for both static <a id="_idTextAnchor1076"/><a id="_idTextAnchor1077"/><a id="_idTextAnchor1078"/>and dynamic analysis.</p>
			<h2 id="_idParaDest-310"><a id="_idTextAnchor1079"/>JVM instructions</h2>
			<p>The list of supported <a id="_idIndexMarker1433"/>instructions is very well-documented, so generally, it isn’t a problem to find information about any bytecode of interest. Let’s look at some examples of what they look like.</p>
			<p>Data transfer:</p>
			<div><div><img src="img/B18500_09_Table7.jpg" alt=""/>
				</div>
			</div>
			<p>Arithmetic and logical operations:</p>
			<div><div><img src="img/B18500_09_Table8.jpg" alt=""/>
				</div>
			</div>
			<p>Control flow:</p>
			<div><div><img src="img/B18500_09_Table9.jpg" alt=""/>
				</div>
			</div>
			<p>Interestingly enough, other projects can produce Java bytecode, such as JPython, which aims to compile Python files into Java-style bytecode. However, in reality, in the absolute majority of<a id="_idIndexMarker1434"/> cases, working with them is not necessary as modern decompilers are doing their job extremely well.<a id="_idTextAnchor1080"/></p>
			<h2 id="_idParaDest-311"><a id="_idTextAnchor1081"/>Static analysis</h2>
			<p>Since the Java bytecode remains the <a id="_idIndexMarker1435"/>same across all platforms, it speeds up the process of creating high-quality decompilers as developers don’t have to spend much time supporting different architectures and operating systems. Here are some of the most popular tools available to the general public:</p>
			<ul>
				<li><code>rt.jar</code> file from your Java folder via the <code>-path</code> argument when using it.</li>
				<li><strong class="bold">Procyon</strong>: Another powerful <a id="_idIndexMarker1437"/>decompiler, this can process both Java files and raw bytecode.</li>
				<li><strong class="bold">FernFlower</strong>: A Java<a id="_idIndexMarker1438"/> decompiler that’s maintained as a plugin for IntelliJ IDEA. It has a command-line version as well.</li>
				<li><strong class="bold">CFR</strong>: A JVM bytecode <a id="_idIndexMarker1439"/>decompiler written in Java that can process individual classes and entire JAR files as well.</li>
				<li><strong class="bold">d4j</strong>: A Java decompiler<a id="_idIndexMarker1440"/> built on top of the Procyon pr<a id="_idTextAnchor1082"/>oject.</li>
				<li><strong class="bold">Ghidra</strong>: This reverse-engineering<a id="_idIndexMarker1441"/> toolkit supports multiple file formats and instruction sets, including<a id="_idIndexMarker1442"/> Java bytecode:</li>
			</ul>
			<div><div><img src="img/Figure_9.23_B18500.jpg" alt="Figure 9.23 – Disassembled and decompiled Java bytecode in Ghidra&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.23 – Disassembled and decompiled Java bytecode in Ghidra</p>
			<ul>
				<li><strong class="bold">JD Project</strong>: A venerable Java <a id="_idIndexMarker1443"/>decompiler project, this provides a set of tools for analyzing Java bytecode. It includes <a id="_idIndexMarker1444"/>a library called <strong class="bold">JD-Core</strong>, a standalone tool called <strong class="bold">JD-GUI</strong>, and several plugins for major IDEs.</li>
				<li><strong class="bold">JAD</strong>: A classic decompiler that has assisted generations of reverse engineers with Java malware <a id="_idIndexMarker1445"/>analysis. It’s now discontinued:</li>
			</ul>
			<div><div><img src="img/Figure_9.24_B18500.jpg" alt="Figure 9.24 – Decompiled code of the Adwind RAT malware written in Java&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.24 – Decompiled code of the Adwind RAT malware writte<a id="_idTextAnchor1083"/>n in Java</p>
			<p>It always makes sense to try <a id="_idIndexMarker1446"/>several different projects and compare their output since all of them implement different techniques, so the quality may vary, depending on the input sample.</p>
			<p>To know where to start the analysis, look inside the <code>MANIFEST.MF</code> file as it will indicate from which class of the corresponding JAR sample the execution will start (the <code>Main-Class</code> field).</p>
			<p>Finally, if necessary, Java bytecode disassembly can be obtained using a standard <code>-c<a id="_idTextAnchor1084"/></code> argument.</p>
			<h2 id="_idParaDest-312"><a id="_idTextAnchor1085"/>Dynamic analysis</h2>
			<p>Modern decompilers generally <a id="_idIndexMarker1447"/>produce a reasonably high-quality output, which, after minor modifications, can be read and debugged as any usual Java source code. Multiple IDEs support Java that provide debugging options for this purpose: Eclipse, NetBeans, IntelliJ IDEA, and others.</p>
			<p>If the original bytecode tracing is required, it is possible to achieve this with the <code>-XX:+TraceBytecodes</code> option, which is available for debug builds of the HotSpot JVM. If step-by-step bytecode debugging is required, then Dr. Garbage’s <strong class="bold">Bytecode Visualizer</strong> plugin for Eclipse IDE appears to be<a id="_idIndexMarker1448"/> extremely handy. It allows you to not <a id="_idTextAnchor1086"/>only see the disassembly of the compiled modules inside the JAR but also<a id="_idTextAnchor1087"/> debug them.</p>
			<h2 id="_idParaDest-313"><a id="_idTextAnchor1088"/>Dealing with anti-reverse engineering solutions</h2>
			<p>At the time of writing, there is<a id="_idIndexMarker1449"/> an impressive number of commercial obfuscators for Java available on the market. As for malware developers, many of them use either cracked versions or demos and leaked licenses. An example is Allatori Obfuscator, which is misused by Adwind RAT.</p>
			<p>When the obfuscator’s name is confirmed (for example, by unique strings), it generally makes sense to check whether any of the existing deobfuscation tools support it. Here are some of them:</p>
			<ul>
				<li><strong class="bold">Java Deobfuscator</strong>: A versatile <a id="_idIndexMarker1450"/>project that supports a decent amount of commercial protectors</li>
				<li><strong class="bold">JMD</strong>: A Java bytecode<a id="_idIndexMarker1451"/> analysis and deobfuscation tool that can remove obfuscation implemented by multiple well-known protectors</li>
				<li><strong class="bold">Java DeObfuscator</strong> (<strong class="bold">JDO</strong>): A<a id="_idIndexMarker1452"/> general-purpose deobfuscator that implements several universal techniques, such as renaming obfuscated values to be unique and indicative of their data type</li>
				<li><strong class="bold">jrename</strong>: Another universal <a id="_idIndexMarker1453"/>deobfuscator that specializes in renaming values to make the c<a id="_idTextAnchor1089"/>ode more readable</li>
			</ul>
			<p>If nothing ready-to-use has been found, it makes sense to search for articles covering this particular obfuscator as they may give you valuable insight into how it works and what approach is worth trying.</p>
			<p>If no information has been found, then it is time to explore the logic behind the obfuscator from scratch, trying to get the most valuable information first, such as strings and then the bytecode. The more information that can be collected about the obfuscator, t<a id="_idTextAnchor1090"/>he less time will be spent on the analysis itself later.</p>
			<p>That’s it for Java-based threats. Now, let’s talk about malware written in Python.</p>
			<h1 id="_idParaDest-314"><a id="_idTextAnchor1091"/>Analyzing compiled Python threats</h1>
			<p>Python is <a id="_idIndexMarker1454"/>a high-level general-purpose language that debuted in 1990 and since that time has gone through several development iterations. At the time of writing, there are two branches actively used by the public, Python 2 and Python 3, which are not fully compatible. The language itself is extremely robust and easy to learn, which eventually lets engineers prototype and develop ideas rapidly.</p>
			<p>As for why compiled Python is used by malware authors when there are so many other languages, this language is cross-platform, which allows an existing application to be easily ported to multiple platforms. It is also<a id="_idIndexMarker1455"/> possible to create executables from Python scripts using tools such as <strong class="bold">py2exe</strong> and <strong class="bold">PyInstaller</strong>.</p>
			<p>You may be wondering, why is Python being covered in this chapter when it is a scripting language? The truth is, whether the programming language uses bytecode or not depends on the actual implementation and not on the language itself. Active Python users may notice files with the <code>.pyc</code> extension appearing, for example, when the Python modules get imported. These files contain the code that’s been compiled into Python’s bytecode language and can be used for various purposes, including malicious ones. In addition, the executables that are generated from Python projects can generally be reverted to these bytecode modules first.</p>
			<p>In this section, we will explain how such sampl<a id="_idTextAnchor1092"/><a id="_idTextAnchor1093"/><a id="_idTextAnchor1094"/>es can be analyzed.</p>
			<h2 id="_idParaDest-315"><a id="_idTextAnchor1095"/>File structure</h2>
			<p>There are three types of compiled files associated with Python: <code>.pyc</code>, <code>.pyo</code>, and <code>.pyd</code>. Let’s go through the <a id="_idIndexMarker1456"/>differences between them:</p>
			<ul>
				<li><code>.pyc</code>: These are standard compiled bytecode files that can be used to make future module importing easier and faster</li>
				<li><code>.pyo</code>: These are compiled bytecode files that are built with the <code>-O</code> (or <code>-OO</code>) option, which is responsible for introducing optimizations that affect the speed they will be loaded (not executed)</li>
				<li><code>.pyd</code>: These are traditional Windows DLL files that implement the MZ-PE structure (for Linux, it will be <code>.so</code>)</li>
			</ul>
			<p>Since MZ-PE files have been covered multiple times throughout this book, we won’t talk about them too much, nor spend much time on <code>.pyd</code> files. Their main feature is having a specific name for the initialization routine that should match the name of the module.</p>
			<p>Particularly, if you have <a id="_idIndexMarker1457"/>a module named <code>foo.pyd</code>, it should export a function called <code>initfoo</code> so that later, when imported using the <code>import foo</code> statement, Python can search for the module with such a name and know the name of the initialization function to be loaded.</p>
			<p>Now, let’s focus on the compiled bytecode files. Here is the structure of the <code>.pyc</code> file:</p>
			<div><div><img src="img/B18500_09_Table10.jpg" alt=""/>
				</div>
			</div>
			<p>Interestingly enough, the <code>.pyc</code> modules are platform independent, but at the same time Python version-dependent. Thus, <code>.pyc</code> files can easily be transferred between systems with the same Python version installed, but files that are compiled using one version of Python<a id="_idIndexMarker1458"/><a id="_idTextAnchor1096"/> generally can’t be used by another version of Python, even on the same system.<a id="_idTextAnchor1097"/></p>
			<h2 id="_idParaDest-316"><a id="_idTextAnchor1098"/>Bytecode instructions</h2>
			<p>The official Python documentation <a id="_idIndexMarker1459"/>describes the bytecode that’s used in both versions 2 and 3. In addition, since it is open source software, all bytecode instructions for a particular Python version can be also found in the corresponding source code files, mainly <code>ceval.c</code>.</p>
			<p>The differences between the bytecode that’s used in Python 2 and 3 aren’t that drastic, but still noticeable. For example, some instructions that were implemented for version 2 are gone in version 3 (such as <code>STOP_CODE</code>, <code>ROT_FOUR</code>, <code>PRINT_ITEM</code>, <code>PRINT_NEWLINE/PRINT_NEWLINE_TO</code>, and so on):</p>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><img src="img/Figure_9.25_B18500.png" alt="Figure 9.25 – Diﬀerent bytecode for the same HelloWorld script produced by Python 2 and 3&#13;&#10;"/></p>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.25 – Diﬀerent bytecode for the same HelloWorld script produced by Python 2 and 3</p>
			<p>Here are the groups of instructions that are used in the official documentation for Python 3, along with some examples:</p>
			<ul>
				<li><code>NOP</code>: Do nothing (generally used as a placeholder)</li><li><code>POP_TOP</code>: Removes the top value from the stack</li><li><code>ROT_TWO</code>: Swaps the top items on the stack</li></ul></li>
				<li><code>UNARY_POSITIVE</code>: Increment</li><li><code>UNARY_NOT</code>: Logical <code>NOT</code> operation</li><li><code>UNARY_INVERT</code>: Inversion</li></ul></li>
				<li><code>BINARY_MULTIPLY</code>: Multiplication</li><li><code>BINARY_ADD</code>: Addition</li><li><code>BINARY_XOR</code>: XOR operation</li></ul></li>
				<li><code>INPLACE_MULTIPLY</code>: Multiplication</li><li><code>INPLACE_SUBTRACT</code>: Subtraction</li><li><code>INPLACE_RSHIFT</code>: Right shift operation</li></ul></li>
				<li><code>GET_AITER</code>: Call the <code>get_awaitable</code> function for the output of the <code>__aiter__()</code> method of the top item on the stack</li><li><code>SETUP_ASYNC_WITH</code>: Create a new frame object</li></ul></li>
				<li><code>BREAK_LOOP</code>: Terminate a loop</li><li><code>SET_ADD</code>: Add the top item on the stack to the set specified by the second item</li><li><code>MAKE_FUNCTION</code>: Push a new function object to the stack</li></ul></li>
			</ul>
			<p>The bytecode instruction names are quite self-explanatory. For the exact syntax, please consult the official documentation.</p>
			<p>After discussing<a id="_idIndexMarker1467"/> the various aspects of Python as a scripting language, we will now pay attention to how to analyze compiled Python code. In this section, we will go through the practical analysis techniques from a Python pers<a id="_idTextAnchor1099"/>pective.</p>
			<h2 id="_idParaDest-317"><a id="_idTextAnchor1100"/>Static analysis</h2>
			<p>In many cases, the analysts<a id="_idIndexMarker1468"/> don’t get the compiled Python modules straight away. Instead, they get a sample, which is a set of Python scripts that’s been converted into an executable using either py2exe or PyInstaller solutions. So, before digging into bytecode modules themselves, we need to obtain bytecode modules. Luckily, several projects can perform this task:</p>
			<ul>
				<li><strong class="bold">unpy2exe.py</strong>: This script can handle samples built using py2exe</li>
				<li><strong class="bold">pyinstxtractor.py</strong>: As the name suggests, this tool can be used to extract Python modules from the executables built using the PyInstaller solution</li>
			</ul>
			<p>An open source project called <strong class="bold">python-exe-unpacker</strong> combines both of these tools and can be run against the executable sample without any extra checks.</p>
			<p>After extracting the files that were<a id="_idIndexMarker1469"/> packed using <strong class="bold">PyInstaller</strong>, there is one moment that can be quite frustrating for anybody who just started analyzing compiled Python files. In particular, the main extracted module may be missing the first few bytes preceding the marshaled code (see the preceding table for the exact number that depends on the Python version), so it can’t be processed by other tools straight away. The easiest way to handle this is to take them from any compiled file on the current machine and then add them there using any hex editor. Such a file can be created by importing (not executing) a simple Hello World script.</p>
			<p>Since analyzing Python source code is pretty straightforward, it makes sense to stick to this option where possible. In this case, the decompilers, which can restore the original code, appear to be extremely useful. At the time of writing, multiple options are available:</p>
			<ul>
				<li><strong class="bold">uncompyle6</strong>: An open source native <a id="_idIndexMarker1470"/>Python decompiler that supports multiple versions of it. It does exactly what it promises – translates <a id="_idIndexMarker1471"/>bytecode back into equivalent source code. There were several older projects preceding it (decompyle, uncompyle, and uncompyle2).</li>
				<li><strong class="bold">decompyle3</strong>: A reworking of the<a id="_idIndexMarker1472"/> uncompyle6 project that supports Python <a id="_idTextAnchor1101"/>versions 3.7+</li>
				<li><strong class="bold">Decompyle++ (also known as pycdc)</strong>: A disassembler and decompiler written in C++, it seeks to support<a id="_idIndexMarker1473"/> bytecode from any version of Python.</li>
				<li><strong class="bold">Meta</strong>: A Python framework that allows <a id="_idIndexMarker1474"/>you to analyze Python bytecode and syntax trees.</li>
				<li><strong class="bold">UnPYC</strong>: A versatile GUI tool for <a id="_idIndexMarker1475"/>Python decompiling that relies on other projects to do the actual code restoration.</li>
			</ul>
			<p>After obtaining the source code, it can be reviewed in any text editor with convenient syntax highlighting or an IDE of your choice.</p>
			<p>However, in certain cases, the decompiling process is not possible straight away. For example, when the module was built using the newest version of Python, it became corrupted during a transfer, partial decoding/decryption, or maybe due to some anti-reverse engineering technique. Such tasks can also be found in some CTF competitions. In this case, the engineer has to stick to analyzing the bytecode. Apart from the tools we mentioned previously, the <code>marshal.load</code> and <code>dis.disassemble</code> methods can be used to translate the bytecode into a <a id="_idTextAnchor1102"/>readable format.</p>
			<h2 id="_idParaDest-318"><a id="_idTextAnchor1103"/>Dynamic analysis</h2>
			<p>In terms of dynamic analysis, usually, the<a id="_idIndexMarker1476"/> output of decompilers can be executed straight away. Step-by-step execution is supported by any major IDE that supports the Python language. In addition, step-by-step debugging is possible <a id="_idIndexMarker1477"/>with the <strong class="bold">trepan2/trepan3k</strong> debugger (for recent versions of Python 2 and 3, respectively), which automatically uses uncompyle6 if there is no source code available. For Python before 2.6, the older packages, <strong class="bold">pydbgr</strong> and <strong class="bold">pydb</strong>, can be used.</p>
			<p>If there is a necessity to trace the bytecode, there are several ways it can be handled, as follows:</p>
			<ul>
				<li><code>ceval.c</code> file is amended to process (for example, print) executed instructions.</li>
				<li><strong class="bold">Amending the .pyc file itself</strong>: Here, the source code line numbers are replaced with the index of each byte, which eventually allows you to trace executed bytecode. Ned Batchelder covered this technique in his <em class="italic">Wicked hack: Python bytecode tracing</em> article.<a href="https://nedbatchelder.com/blog/200804/wicked_hack_python_bytecode_tracing.html.&#13;"/></li>
			</ul>
			<p>There are also existing<a id="_idIndexMarker1478"/> projects such as <code>.pyc</code> files with a header format that’s generated by the current version of Python 2, so update it if necessary).</p>
			<p>Some examples of common anti-reverse engineering techniques include doing the following:</p>
			<ul>
				<li>Manipulating non-existing values on the stack</li>
				<li>Setting up a custom exception handler (for this purpose, the <code>SETUP_EXCEPT</code> instruction can be used)</li>
			</ul>
			<p>When editing the bytecode (for example, to get rid of anti-debugging or anti-decompiling techniques or to restore a corrupted code block), the <code>dis.opmap</code> mapping appears to be extremely useful to find the binary values of opcodes and later replace them, and the <code>bytecode_graph</code> module can be used to seamlessly rem<a id="_idTextAnchor1104"/>ove unwanted values.</p>
			<h1 id="_idParaDest-319"><a id="_idTextAnchor1105"/>Summary</h1>
			<p>In this chapter, we covered the fundamental theory of bytecode languages. We learned what their use cases are and how they work from the inside. Then, we dived deep into the most popular bytecode languages used by modern malware families, explained how they operate, and looked at their unique specifics that need to be paid attention to. Finally, we provided detailed guidelines on how such malware can be analyzed and the tools that can facilitate this process.</p>
			<p>Equipped with this knowledge, you can analyze malware of this kind and get an invaluable insight into how it may affect victims’ systems.</p>
			<p>In <a href="B18500_10.xhtml#_idTextAnchor1106"><em class="italic">Chapter 10</em></a>, <em class="italic">Scripts and Macros – Reversing, Deobfuscation, and Debugging</em>, we are going to cover various script and macros languages, explore the malware that misuses them, and find interesting links between them, as well as already covered technologies.</p>
		</div>
	</body></html>