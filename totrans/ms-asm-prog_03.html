<html><head></head><body>
        

                            
                    <h1 class="header-title">Intel Instruction Set Architecture (ISA)</h1>
                
            
            
                
<p>It may virtually be right to say that any digital device has a specific set of instructions. Even a transistor, the foundation stone of modern digital electronics, has two instructions, on and off, where each one is represented by 1 or 0 (which one of these represents on and off depends on whether the transistor is <em>n-p-n</em> or <em>p-n-p</em>). A processor is constructed from millions of transistors and is, as well, controlled by sequences of 1s and 0s (grouped into 8-bit bytes grouped into instructions). Fortunately, we do not have to take care of instruction encoding (it's the 21st century out there) as assemblers do that for us.</p>
<p>Each CPU instruction (and this is right for any CPU, not only Intel based) has a mnemonic designation (further simply mnemonic), which you need to learn about along with a few simple rules regarding operand sizes (and memory addressing, but we will take a deeper look at that in <a href="7a0e22a2-ba7f-4750-ac01-91e2460ce0cd.xhtml">Chapter 4</a>, <em>Memory Addressing Modes</em>), and this is exactly what we will do in this chapter.</p>
<p>We will begin by creating a simple Assembly template, which we will use throughout the book as a starting point for our code. Then, we will proceed to the actual CPU instruction set and get acquainted with the following types of instructions:</p>
<ul>
<li>Data transfer instructions</li>
<li>Arithmetic instructions</li>
<li>Floating point instructions</li>
<li>Execution flow control instructions</li>
<li>Extensions</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Assembly source template</h1>
                
            
            
                
<p>We will start with two 32-bit templates, one for Windows and one for Linux. 64-bit templates will be added very soon and we will see that they are not much different from 32-bit ones. The templates contain some macro instructions and directives that will be explained later in the book. As for now, these templates are provided with the sole purpose to give you the ability to write simple (and not so simple) snippets of code, compile them, and test them in a debugger.</p>
<p> </p>


            

            
        
    

        

                            
                    <h1 class="header-title">The Windows Assembly template (32-bit)</h1>
                
            
            
                
<p>A Windows executable consists of several sections (the structure of a PE executable/object file will be covered in more detail in <a href="17490bf0-6e1c-4061-8cd1-339e5a5ec48a.xhtml">Chapter 9</a>, <em>Operating System Interface</em>); usually, one section for code, one for data, and one for import data (this contains information on external procedures, which are imported from dynamic link libraries). <strong>Dynamic-link libraries</strong> (<strong>DLL</strong>) also have an export section, which contains information on procedures/objects publicly available in the DLL itself. In our template, we simply define the sections and let the assembler do the rest of the work (write headers and so on).</p>
<p>Now, let's take a look at the template itself. See further explanation of PE specifics in the comments:</p>
<pre><em>; File: srctemplate_win.asm</em><br/><br/><em>; First of all, we tell the compiler which type of executable we want it</em><br/><em>; to be. In our case it is a 32-bit PE executable.</em> <br/>format PE GUI<br/><br/><em>; Tell the compiler where we want our program to start - define the entry</em><br/><em>; point. We want it to be at the place labeled with '_start'.</em><br/>entry _start<br/><br/><em>; The following line includes a set of macros, shipped with FASM, which </em><br/><em>; are essential for the Windows program. We can, of course, implement all </em><br/><em>; we need ourselves, and we will do that in chapter 9.</em><br/>include 'win32a.inc'<br/><br/><em>; PE file consists of at least one section. </em><br/><em>; In this template we only need 3:</em><br/><em>;    1. '.text' - section that contains executable code</em><br/><em>;    2. '.data' - section that contains data</em><br/><em>;    3. '.idata' - section that contains import information</em><br/><em>;</em><br/><em>; '.text' section: contains code, is readable, is executable</em><br/>section '.text' code readable executable<br/>_start:<br/>   <em>;</em><br/><em>   ; Put your code here</em><br/><em>   ;</em><br/><br/><br/><em>   ; We have to terminate the process properly</em><br/><em>   ; Put return code on stack</em><br/>   push  0<br/>   <em>; Call ExitProcess Windows API procedure</em><br/>   call [exitProcess]<br/><br/><em>; '.data' section: contains data, is readable, may be writeable</em><br/>section '.data' data readable writeable<br/>   <em>;</em><br/><em>   ; Put your data here</em><br/><em>   ;</em><br/><br/><em>; '.idata' section: contains import information, is readable, is</em> <em>writeable</em><br/>section '.idata' import data readable writeable<br/><br/><em>; 'library' macro from 'win32a.inc' creates proper entry for importing </em><br/><em>; procedures from a dynamic link library. For now it is only 'kernel32.dll',</em><br/><em>; library kernel, 'kernel32.dll'</em><br/><br/><em>; 'import' macro creates the actual entries for procedures we want to import </em><br/><em>; from a dynamic link library</em><br/>import kernel, <br/>   exitProcess, 'ExitProcess'</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">The Linux Assembly template (32-bit)</h1>
                
            
            
                
<p>On Linux, although files on disc are divided into sections, executables in memory are divided into code and data segments. The following is our template for the ELF 32-bit executable for Linux:</p>
<pre><em>; File: src/template_lin.asm</em><br/><br/><em>; Just as in the Windows template - we tell the assembler which type </em><br/><em>; of output we expect. </em><br/><em>; In this case it is 32-bit executable ELF</em><br/>format ELF executable<br/><br/><em>; Tell the assembler where the entry point is</em><br/>entry _start<br/><br/><em>; On *nix based systems, when in memory, the space is arranged into </em><br/><em>; segments, rather than in sections, therefore, we define </em><br/><em>; two segments:</em><br/><em>; Code segment (executable segment)</em><br/>segment readable executable<br/><br/><em>; Here is our entry point</em><br/>_start:<br/><br/><br/>   <em>; Set return value to 0</em><br/>   xor ebx, ebx<br/>   mov eax, ebx<br/> <br/>   <em>; Set eax to 1 - 32-bit Linux SYS_exit system call number</em><br/>   inc eax<br/> <br/>   <em>; Call kernel</em><br/>   int 0x80<br/><br/><br/><em>; Data segment</em><br/>segment readable writeable<br/>   db 0<br/><br/><br/><em>; As you see, there is no import/export segment here. The structure </em><br/><em>; of an ELF executable/object file will be covered in more detail </em><br/><em>; in chapters 8 and 9</em></pre>
<p>As was mentioned in the preceding code, these two templates will be used as a starting point for any code we will write in this book.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Data types and their definitions</h1>
                
            
            
                
<p>Before we start working with Assembly instructions, we have to know how to define data, or, to be more precise, how to tell the assembler which type of data we are using.</p>
<p>The Flat Assembler supports six built-in types of data and allows us to either define or declare variables. The difference between a definition and a declaration in this case is that when we define a variable we also assign a certain value to it, but when we declare, we simply reserve space for a certain type of data:</p>
<p><strong>Variable definition format</strong>: <kbd>[label] definition_directive value(s)</kbd></p>
<ul>
<li><kbd>label</kbd>: This is optional, but addressing an unnamed variable is harder</li>
</ul>
<p>Variable declaration format: <kbd>[label] declaration_directive count</kbd></p>
<ul>
<li><kbd>label</kbd>: This is optional, but addressing an unnamed variable is harder</li>
<li><kbd>count</kbd>: This tells the assembler how many entries of the type specified in <kbd>declaration_directive</kbd> it should reserve memory for</li>
</ul>
<p>The following table shows definition and declaration directives for built-in data types, sorted by size thereof:</p>
<table>
<tbody>
<tr>
<td>
<p><strong>Size of data type in bytes</strong></p>
</td>
<td>
<p><strong>Definition directive</strong></p>
</td>
<td>
<p><strong>Declaration (reservation) directive</strong></p>
</td>
</tr>
<tr>
<td>
<p>1</p>
</td>
<td>
<p><kbd>db</kbd> file (includes binary file)</p>
</td>
<td>
<p><kbd>rb</kbd></p>
</td>
</tr>
<tr>
<td>
<p>2</p>
</td>
<td>
<p><kbd>dw</kbd> <kbd>du</kbd> (defines unicode character)</p>
</td>
<td>
<p><kbd>rw</kbd></p>
</td>
</tr>
<tr>
<td>
<p>4</p>
</td>
<td>
<p><kbd>dd</kbd></p>
</td>
<td>
<p><kbd>rd</kbd></p>
</td>
</tr>
<tr>
<td>
<p>6</p>
</td>
<td>
<p><kbd>dp</kbd> <kbd>df</kbd></p>
</td>
<td>
<p><kbd>rp</kbd> <kbd>rf</kbd></p>
</td>
</tr>
<tr>
<td>
<p>8</p>
</td>
<td>
<p><kbd>dq</kbd></p>
</td>
<td>
<p><kbd>rq</kbd></p>
</td>
</tr>
<tr>
<td>
<p>10</p>
</td>
<td>
<p><kbd>dt</kbd></p>
</td>
<td>
<p><kbd>rt</kbd></p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>The preceding table lists acceptable data types ordered by their size in bytes, which is in the leftmost column. The column in the middle contains the directives we use in the Assembly code for definition of data of a certain type. For example, if we want to define a byte variable named <kbd>my_var</kbd>, then we write the following:</p>
<pre>my_var   db  0x5a</pre>
<p>Here, <kbd>0x5a</kbd> is the value we assign to this variable. In cases where we do not need to initialize the variable with any specific value, we write this:</p>
<pre>my_var db ?</pre>
<p>Here, the question mark (<kbd>?</kbd>) means that the assembler may initialize the memory area occupied by this variable to any value (which would typically be <kbd>0</kbd>).</p>
<p>There are two directives that require a bit more attention:</p>
<ul>
<li><kbd>file</kbd>: This directive instructs the assembler to include a binary file during the compilation.</li>
<li><kbd>du</kbd>: This directive is used just like <kbd>db</kbd> is used to define characters or strings thereof, yet it produces unicode-like characters/strings instead of ASCII. The effect is the 0 extension of 8-bit values to 16-bit values. This is rather a convenience directive and has to be overridden when a proper transformation to unicode is required.</li>
</ul>
<p>Directives shown in the rightmost column are used when we want to reserve space for a range of data entries of a certain type without specifying the values thereof. For example, if we want to reserve space for, let's say, 12 32-bit integers labeled <kbd>my_array</kbd>, then we would write the following:</p>
<pre>my_array rd 12</pre>
<p>The assembler would then reserve 48 bytes for this array, beginning at a place labeled <kbd>my_array</kbd> in the code.</p>
<p>Although you will use these directives in the data section most of the time, there is no limitation as to where they may be placed. For example, you may (for whatever purpose) reserve some space within a procedure, or between two procedures, or include a binary file containing precompiled code.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">A debugger</h1>
                
            
            
                
<p>We are almost ready to begin the process of instruction set exploration; however, there is one more thing that we have not touched yet, as there was no need for it--a debugger. There is a relatively wide choice of debuggers out there and you, being a developer, have most likely worked with at least one of them. However, since we are interested in debugging programs written in the Assembly language, I would suggest one of the following:</p>
<ul>
<li><strong>IDA Pro</strong> (<a href="https://www.hex-rays.com/products/ida/index.shtml">https://www.hex-rays.com/products/ida/index.shtml</a>): Very convenient, but also very expensive. If you have it, good! If not, never mind, we have other options. Windows only.</li>
<li><strong>OllyDbg</strong> (<a href="http://www.ollydbg.de/version2.html">http://www.ollydbg.de/version2.html</a>): Free debugger/disassembler. More than enough for what we need. Windows only. Unfortunately, the 64-bit version of this tool was never finished, meaning that you would not be able to use it with 64-bit examples.</li>
<li><strong>HopperApp</strong> (<a href="https://www.hopperapp.com">https://www.hopperapp.com</a>): Commercial, but very affordable disassembler with GDB frontend. macOS X and Linux.</li>
<li><strong>GDB</strong> (<strong>GNU DeBugger</strong>): Freely available, works on Windows, Linux, mac OS X, and others. Although GDB is a command-line tool, it is quite easy to use. The only limitation is that the disassembler's output is in AT&amp;T syntax.</li>
</ul>
<p>You are free to choose either one of these or a debugger that is not mentioned on the list (and there are relatively many). There is only one important factor to consider while selecting a debugger--you should feel comfortable with it, as running your code in a debugger, seeing everything that happens in registers of a processor or in memory, would greatly enhance your experience while writing code in Assembly.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The instruction set summary</h1>
                
            
            
                
<p>We have finally got to the interesting part--the instruction set itself. Unfortunately, describing each and every instruction of a modern Intel-based processor would require a separate book, but since there is already such a book (<a href="http://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-instruction-set-reference-manual-325383.pdf">http://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-instruction-set-reference-manual-325383.pdf</a>), we will not multiply things without need and will concentrate on instruction groups rather than on individual instructions. At the end of the chapter, we will implement AES128 encryption for the sake of demonstration.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">General purpose instructions</h1>
                
            
            
                
<p>The general purpose instructions perform basic operations such as data movement, arithmetic, flow control, and so on. They are grouped by their purpose:</p>
<ul>
<li>Data transfer instructions</li>
<li>Binary arithmetic instructions</li>
<li>Decimal arithmetic instructions</li>
<li>Logical instructions</li>
<li>Shift and rotate instructions</li>
<li>Bit/byte manipulation instructions</li>
<li>Flow control instructions</li>
<li>String manipulation instructions</li>
<li>ENTER/LEAVE instructions</li>
<li>Flag control instructions</li>
<li>Miscellaneous instructions</li>
</ul>
<p>The division of instructions into groups is the same as in the Intel Software Developer's Manual.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Data transfer instructions</h1>
                
            
            
                
<p>Data transfer instructions, as the name of the group suggests, are used to transfer data between registers or between registers and memory. Some of them may have an immediate value as their source operand. The following example illustrates their usage.</p>
<pre><strong> push </strong> ebx                 <em>; save EBX register on stack</em><br/><strong> mov </strong>  ax, 0xc001          <em>; move immediate value to AX register</em><br/><strong> movzx</strong> ebx, ax             <em>; move zero-extended content of AX to EBX </em><br/><em>                            ; register</em><br/><em>                            ; EBX = 0x0000c001</em><br/><strong> bswap</strong> ebx                 <em>; reverse byte order of EBX register </em><br/><em>                            ; EBX = 0x01c00000</em><br/><strong> mov </strong>  [some_address], ebx <em>; move content of EBX register to </em><br/><em>                            ; memory at 'some_address'</em><br/><em>                            ; content of 'some_address' = </em><br/><em>                            ; 0x01c00000</em><br/>                            <em>; The above two lines of code could have </em><br/><em>                            ; been replaced with:</em><br/><em>                            ; movbe [some_address], ebx</em><br/><strong> pop </strong>  ebx                  <em>; restore EBX register from stack</em></pre>
<p>Let's take a closer look at the instructions used with the example:</p>
<ul>
<li><strong>PUSH</strong>: This instructs the processor to store the value of the operand onto a stack and decrements stack pointer (ESP register on 32-bit systems and RSP register on 64-bit ones).</li>
<li><strong>MOV</strong>: This is the most commonly used instruction for transferring data:
<ul>
<li>It moves data between registers of the same size</li>
<li>It loads a register with either an immediate value or a value read from memory</li>
<li>It stores the content of a register to memory</li>
<li>It stores the immediate value to memory</li>
</ul>
</li>
<li><strong>MOVZX</strong>: This is less powerful than MOV by means of addressing modes, as it may only transfer data from register to register or from memory to register, but it has its special feature--the value being transferred is converted to a wider (one that uses more bits) one and is zero extended. As to the addressing modes supported by this instruction, it may only do the following:
<ul>
<li>It moves the byte value from register or memory to a word-sized register and extends the resulting value with zeroes (one byte would be added)</li>
<li>It moves byte value from register or memory to a double word-sized register, in which case three bytes would be added to the original value and the value itself would be extended with zeroes</li>
<li>It moves word-sized value from register or memory to a double word-sized register, adding two bytes and filling them with the extension value of 0</li>
</ul>
</li>
<li><strong>MOVSX</strong> is similar to MOVZX; however, the extended bits are filled with the sign bit of the source operand.</li>
<li><strong>BSWAP/MOVBE</strong> The BSWAP instruction is the easiest way to switch the endianness of a value; however, it is not really a transfer instruction as it only rearranges data within a register. The BSWAP instruction only works on 32/64-bit operands. MOVBE is a more convenient instruction for swapping byte order as it also moves data between the operands. This instruction works on 16, 32, and 64-bit operands. It cannot move data from register to register.</li>
<li><strong>POP</strong>: This retrieves values previously stored on stack. The only operand of this instruction is the destination where the value should be stored, and it may be a register or a location in memory. This instruction increments the stack pointer register as well.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Binary Arithmetic Instructions</h1>
                
            
            
                
<p>These instructions perform basic arithmetic operations. Operands may be byte, word, double-word or quad-word registers, memory locations, or immediate values. They all modify CPU flags according to the result of operation thereof, which, in turn, lets us change the execution flow depending on the values of certain flags.</p>
<p>Let us take a look at a few basic arithmetic instructions:</p>
<ul>
<li><strong>INC</strong>: This is short for increment. This instruction adds 1 to the value of its operand. Obviously, the inc instruction, or its counterpart, the <kbd>dec</kbd> instruction, may not be used with immediate values. The <kbd>inc</kbd> instruction affects certain CPU flags. For example, consider that we take a register (let it be the EAX register for the sake of simplicity), set it to 0, and execute it, as follows:</li>
</ul>
<pre>      inc eax</pre>
<p style="padding-left: 60px">In this case, EAX would equal to 1 and ZF (zero flag, remember?) would be set to 0, meaning that the operation resulted in a non-zero value. On the other hand, if we load the EAX register with the <kbd>0xffffffff</kbd> value and increment it with the <kbd>inc</kbd> instruction, the register will become zero and, since zero is the result of the latest operation, ZF would be set then (will have value of <kbd>1</kbd>).</p>
<ul>
<li><strong>ADD</strong>: This performs simple addition, adding the source operand to the destination operand and storing the resulting value in the destination operand. This instruction affects several CPU flags as well. In the following example, we will add <kbd>0xffffffff</kbd> to the EBX register, which has been set to <kbd>1</kbd>. The result of such an operation would be a 33-bit value, but as we only have 32 bits to store the result, the extra bit would go into the carry flag. Such a mechanism, in addition to being useful for control of the execution flow, may also be used when adding two big numbers (may be even hundreds of bits wide) as we can then process the numbers by smaller portions (of, for example, 32 bits).</li>
<li><strong>ADC</strong>: Talking about addition of big numbers, the <kbd>adc</kbd> instruction is the one that allows us to add the value of the carry flag, as set by a previous operation, to the summation of additional two values. For example, if we want to add <kbd>0x802597631</kbd> and <kbd>0x4fe013872</kbd>, we would then add <kbd>0x02597631</kbd> and <kbd>0xfe013872</kbd> first, resulting in <kbd>0x005aaea3</kbd> and a set carry flag. Then, we would add 8, 4 and, the value of the carry flag:</li>
</ul>
<pre><em>      ;Assuming EAX equals to 8 and EBX equals to 4</em><br/>      adc eax, ebx</pre>
<p style="padding-left: 60px">This would result in <kbd>8 + 4 + 1</kbd> (where 1 is the implicit operand--the value of the CF) <kbd>= 0xd</kbd>, thus, the overall result would be <kbd>0xd005aaea3</kbd>.</p>
<p>The following example illustrates these instructions in more detail:</p>
<pre>mov   eax, 0          <em>; Set EAX to 0</em><br/>mov   ebx, eax        <em>; Set EBX to 0</em><br/>inc   ebx             <em>; Increment EBX</em><br/><em>                      ; EBX = 1</em><br/>add   ebx, 0xffffffff <em>; add 4294967295 to EBX</em><br/><em>                      ; EBX = 0 and Carry Flag is set</em><br/>adc   eax, 0          <em>; Add 0 and Carry Flag to EAX </em><br/><em>                      ; EAX = 1</em></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Decimal arithmetic instructions</h1>
                
            
            
                
<p>In about 15 years of Assembly development and reverse engineering software, I encountered these instructions exactly once, and that was in the college. However, it would be right to mention them, for a few reasons:</p>
<ul>
<li>Instructions like AAM and AAD may sometimes be used as a smaller variant of multiplication and division, since they allow immediate operand. They're smaller as they allow generation of smaller code due to their encoding.</li>
<li>Sequences like AAD 0 (which is division by zero) may be used as an exception trigger in certain protection schemes.</li>
<li>Not mentioning them would be historically wrong.</li>
</ul>
<p>Decimal arithmetic instructions are illegal on 64-bit platforms.</p>
<p>First of all, what is BCD? It is <strong>Binary coded decimal</strong> (<strong>BCD</strong>) and is, in fact, an attempt to ease the conversion of binary representations of numbers to their ASCII equivalent and vice versa, as well as adding the ability to perform basic arithmetic operations on decimal numbers represented in a hexadecimal form (not their hexadecimal equivalents!).</p>
<p>There are two types of BCD: packed and unpacked. Packed BCD represents a decimal number using nibbles of a single byte. For example, the number 12 would be represented as 0x12. Unpacked BCD, on the other hand, uses bytes for representation of individual digits (for example, 12 converts to 0x0102).</p>
<p>However, given the fact that these instructions have not been changed since their first appearance, they only operate on values stored in a single byte, for packed BCD, or values stored in a single word, for unpacked BCD. More than this, these values should be stored only in the AL register for packed BCD and the AX register (or, to say it in a more precise way, in the AH:AL pair) for unpacked BCD.</p>
<p>There are only six BCD instructions:</p>
<ul>
<li><strong>Decimal Adjust after Addition</strong> (<strong>DAA</strong>): This instruction is specific to packed BCD. Since the addition of two packed BCD numbers would not necessarily result in a valid packed BCD number, the invocation of DAA fixes the problem by making the adjustments needed for converting a result into a proper packed BCD value. For example, let's add 12 and 18. Normally, the result would be 30, but if we add <kbd>0x12</kbd> and <kbd>0x18</kbd>, the result would be <kbd>0x2a</kbd>. The following example illustrates the procedure for such a calculation:</li>
</ul>
<pre style="padding-left: 60px">mov al, 0x12   <em>; AL = 0x12, which is packed BCD </em><br/><em>               ; representation of 12</em><br/>add al, 0x18   <em>; Add BCD representation of 18, <br/>               ; which would result in 0x2a</em><br/>daa            <em>; Adjust. AL would contain 0x30 after this instruction, </em><br/><em>               ; which is the BCD representation of 30</em></pre>
<ul>
<li><strong>Decimal Adjust after Subtraction</strong> (<strong>DAS</strong>): This instruction performs similar adjustments after subtracting two packed BCD numbers. Let's add some more lines to the preceding code (AL still contains <kbd>0x30</kbd>):</li>
</ul>
<p style="padding-left: 90px"/>
<pre class="mce-root" style="padding-left: 60px">sub al, 0x03  <em>; We are subtracting 3 from 30, however, </em><br/><em>              ; the result of 0x30 - 0x03 </em><br/><em>              ; would be 0x2d</em><br/>das           <em>; This instruction sets AL to 0x27, <br/>              ; which is the packed BCD</em> <br/>              <em>; representation of 27.</em></pre>
<ul>
<li><strong>ASCII Adjust after Addition</strong> (<strong>AAA</strong>): This instruction is similar to DAA, yet it works on unpacked BCD numbers (meaning, the AX register). Let's look at the following example, where we still add 18 to 12, but we do that with the unpacked BCD:</li>
</ul>
<pre style="padding-left: 60px">mov ax, 0x0102  <em>; 0x0102 is the unpacked BCD representation of 12</em><br/>add ax, 0x0108  <em>; same for 18</em><br/><em>                ; The result of the addition would be <br/>                ; 0x020a - far from being 0x0300</em><br/>aaa             <em>; Converts the value of AX register to 0x0300</em></pre>
<p style="padding-left: 60px">The resulting value may easily be converted to the ASCII representation by adding <kbd>0x3030</kbd>.</p>
<ul>
<li><strong>ASCII Adjust after Subtraction</strong> (<strong>AAS</strong>): This instruction is similar to DAS, but operates on unpacked BCD numbers. We may continue to add code to the preceding example (The AX register still has the value of <kbd>0x0300</kbd>). Let's subtract 3, which should, at the end, give us the value of <kbd>0x0207</kbd>:</li>
</ul>
<pre style="padding-left: 60px">sub ax, 0x0003  <em>; AX now contains 0x02fd</em><br/>aas             <em>; So we convert it to unpacked BCD</em> <br/>                <em>; representation, but...</em><br/><em>                ; AX becomes 0x0107, but as we know, <br/>                ; 30 - 3 != 17...</em></pre>
<p style="padding-left: 60px">What went wrong then? In fact, nothing went wrong; it is just that the internal implementation of the AAS instruction caused carry (and, as we may see in a debugger, the CF is in deed set) or, to be more precise, a borrow occurred. That is why it is better for our convenience to finalize this with the following:</p>
<pre style="padding-left: 60px">adc ah, 0  <em>; Adds the value of CF to AH</em></pre>
<p style="padding-left: 60px">We end up with <kbd>0x0207</kbd>, which is the unpacked BCD representation of 27--exactly the result we were expecting.</p>
<ul>
<li><strong>ASCII Adjust AX after Multiply</strong> (<strong>AAM</strong>): Result of the multiplication of two unpacked BCD numbers, as well, requires certain adjustments to be made in order to be in an unpacked BCD form. However, what we have to remember first of all is the size limitation implied by these operations. As we are limited to the AX register, the maximum value of a multiplicand is 9 (or <kbd>0x09</kbd>), meaning that, being limited to AX with the resulting value, we are limited to one byte with multiplicands. Let's say we want to multiply 8 by 4 (which would be <kbd>0x08 * 0x04</kbd>); naturally, the result would be <kbd>0x20</kbd> (the hexadecimal equivalent of 32), which is not even close to being an unpacked BCD represented number. The <kbd>aam</kbd> instruction solves this problem by converting the value of the AL register to the unpacked BCD format and stores it in AX:</li>
</ul>
<pre style="padding-left: 60px">mov al, 4 <br/>mov bl, 8<br/>mul bl     <em>; AX becomes 0x0020</em><br/>aam        <em>; Converts the value of AX to the </em><br/><em>           ; corresponding unpacked BCD form. Now the AX</em><br/><em>           ; register equals to 0x0302</em></pre>
<p style="padding-left: 60px">As we see, the multiplication of two unpacked BCD bytes results in an unpacked BCD word.</p>
<ul>
<li><strong>ASCII Adjust AX before Division</strong> (<strong>AAD</strong>): This is exactly as the name of the instruction suggests--it should adjust the value of the AX register before division. The size limitations are just the same as in AAM. The AX register still contains <kbd>0x0302</kbd> after the previous example, so let's divide it by 4:</li>
</ul>
<pre style="padding-left: 60px">mov bl, 4<br/>aad        <em>; Adjust AX. The value changes from 0x0302 to 0x0020</em><br/>div bl     <em>; Perform the division itself</em><br/><em>           ; AL register contains the result - 0x08</em></pre>
<p>As we see, although these instructions may seem to be somewhat convenient, there are better ways to convert numbers between their ASCII notation and their binary equivalents, not to mention the fact that regular arithmetic instructions are much more convenient to use.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Logical instructions</h1>
                
            
            
                
<p>This group contains instructions for bitwise logical operations which you, being a developer, already know. These are NOT, OR, XOR, and AND operations. However, while high-level languages do make a difference between bitwise and logical operators (for example, bitwise AND (&amp;) and logical AND (&amp;&amp;) in C), they are all the same on the Assembly level and are quite commonly used in conjunction with the EFlags register (or RFlags on 64-bit systems).</p>
<p>For example, consider the following simple snippet in C that checks for a specific bit being set and conditionally executes certain code:</p>
<pre>if(my_var &amp; 0x20)<br/>{<br/>   <em>// do something if true</em><br/>}<br/>else<br/>{<br/>  <em>// do something else otherwise</em><br/>}</pre>
<p>It may be implemented in Assembly like this:</p>
<pre>and dword [my_var], 0x20  <em>; Check for sixth bit of 'my_var'. </em><br/><em>                          ; This operation sets ZF if the result </em><br/><em>                          ; is zero (if the bit is not set).</em><br/>jnz do_this_if_true       <em>; Go to this label if the bit is set</em><br/>jmp do_this_if_false      <em>; Go to this label otherwise</em></pre>
<p>One of the many other applications of these instructions is the finite field arithmetic, where XOR stands for addition and AND stands for multiplication.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Shift and rotate instructions</h1>
                
            
            
                
<p>Instructions of this group let us move bits within the destination operand, which is something we only partially have in high-level languages. We can shift, but we cannot rotate, neither can we implicitly specify arithmetic shifts (the selection of arithmetic or a logical shift is usually performed by high-level language implementation based on the type of data the operations are carried on).</p>
<p>Using shift instructions, in addition to their primary role of moving bits left or right a certain number of positions, is a simpler way to perform integer multiplication and division of the destination operand by powers of two. Additionally, two special shift instructions exist that let us move certain amount of bits from one location to another--to be more precise, from a register to another register or to a memory location.</p>
<p>Rotation instructions allow us, as the name suggests, to rotate bits from one end of the destination operand to another. It is important to mention that bits may be rotated through the CF (carry flag), meaning that the bit that is shifted out is stored in the CF while the value of the CF is shifted into the operand on the other side. Let's consider the following example, one of the simplest integrity control algorithms, CRC8:</p>
<pre>   poly = 0x31       <em>; The polynomial used for CRC8 calculation</em><br/>   xor  dl, dl       <em>; Initialise CRC state register with 0</em><br/>   mov  al, 0x16     ;<em> Prepare the sequence of 8 bits (may definitely </em><br/><em>                     ; be more than 8 bits)</em><br/>   mov  ecx, 8       <em>; Set amount of iterations</em><br/>crc_loop:<br/>   shl  al, 1<br/>   rcl  bl, 1<br/>   shl  dl, 1<br/>   rcl  bh, 1<br/>   xor  bl, bh<br/>   test bl, 1<br/>   jz  .noxor<br/>   xor  dl, poly<br/>.noxor:<br/>   loop crc_loop</pre>
<p>The body of the loop in the preceding snippet was intentionally left without comments as we would like to take a closer look at what is happening there.</p>
<p>The first instruction of the loop <kbd>shl al, 1</kbd> shifts out the most significant bit of the value we are calculating CRC8 for and stores it into the CF. The next instruction <kbd>rcl bl, 1</kbd> stores the value of the CF (the bit we shifted out of our bit stream) into the BL register. The following two instructions do the same for the DL register, storing the most significant bit into BH. The side effect of the <kbd>rcl</kbd> instruction is that the most significant bits of the first BL and then the BH register are moved to the CF. Although it is of no importance in this specific case, we should not forget about this when rotating through the CF. At the end, this means after 8 iterations, the preceding code provides us with the CRC8 value for <kbd>0x16</kbd> (which is <kbd>0xE5</kbd>) in the DL register.</p>
<p>The two shift and rotate instructions mentioned in the example have their right-sided counterparts:</p>
<ul>
<li><strong>SHR</strong>: This shifts bits to the right, while saving the last bit shifted out in the CF</li>
<li><strong>RCR</strong>: This rotates bits to the right through the carry flag</li>
</ul>
<p>There are a few additional instructions in this group that we cannot skip:</p>
<ul>
<li><strong>SAR</strong>: This shifts bits to the right while "dragging" the sign bit instead of simply filling the "vacant" bits with zeroes.</li>
<li><strong>SAL</strong>: This is an arithmetic shift to the left. It is not truly an instruction, rather a mnemonic used for a programmer's convenience. The assembler generates the same encoding as for SHL.</li>
<li><strong>ROR</strong>: This rotates bits to the right. Each bit being shifted out to the right and shifted in to the left is also stored in the CF.</li>
</ul>
<p>Finally, as it was mentioned earlier, the two special shift instructions are as follows:</p>
<ul>
<li><strong>SHLD</strong>: This shifts a certain number of left-side (most significant) bits from a register into another register or into a memory location</li>
<li><strong>SHRD</strong>: This shifts a certain number of right-side (least significant) bits from a register into another register or into a memory location</li>
</ul>
<p>Another new instruction in the previous example is TEST, but it will be explained in the next section.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Bit and byte instructions</h1>
                
            
            
                
<p>Instructions of this group are those that let us manipulate individual bits within an operand and/or set bytes in accordance with the sate of flags in the EFlags/RFlags register.</p>
<p>With high-level languages that implement bit fields, it is quite easy to access individual bits even if we want to perform more complex operations than just scan, test, set or reset, as provided by Intel Assembly. However, with high-level languages having no bit fields we have to implement certain constructs in order to have access to individual bits and that is where Assembly is more convenient.</p>
<p>While bit and byte instructions may have a variety of applications, let's consider them (just a few of them) in the context of the CRC8 example. It would not be completely right to say that using these instructions in that example would have significantly optimized it; after all, it would let us get rid of a single instruction, making the implementation of the algorithm look a bit clearer. Let's see how <kbd>crc_loop</kbd> would have changed:</p>
<pre>crc_loop:<br/>   shl  al, 1     <em>; Shift left-most bit out to CF</em><br/>   setc bl        <em>; Set bl to 1 if CF==1, or to zero otherwise</em><br/>   shl  dl, 1     <em>; shift left-most bit out to CF</em><br/>   setc bh        <em>; Set bh to 1 if CF==1, or to zero otherwise</em><br/>   xor  bl, bh    <em>; Here we, in fact, are XOR'ing the previously left-most bits of al and dl</em><br/>   jz  .noxor     <em>; Do not add POLY if XOR result is zero</em><br/>   xor  dl, poly<br/>.noxor:<br/>   loop crc_loop</pre>
<p>The preceding code is quite self-explanatory, but let's take a closer look at the set of bit instructions:</p>
<ul>
<li><strong>BT</strong>: This stores a bit from the destination operand (bit base) to the CF. The bit is identified by the index specified in the source operand.</li>
<li><strong>BTS</strong>: This is the same as BT, but it also sets the bit in the destination operand.</li>
<li><strong>BTR</strong>: This is the same as BT, but it also resets the bit in the destination operand.</li>
<li><strong>BTC</strong>: This is the same as BT, but it also inverts (complements) the bit in the destination operand.</li>
<li><strong>BSF</strong>: This stands for <strong>bit scan forward</strong>. It searches the source operand for the least significant bit that is set. The index of the bit, if found, is returned in the destination operand. If the source operand is all zeros, then the value for the destination operand is not defined and ZF is set.</li>
<li><strong>BSR</strong>: This stands for <strong>bit scan reverse</strong>. It searches the source operand for the most significant bit that is set. The index of the bit, if found, is returned in the destination operand. If the source operand is all zeros, then the value of the destination operand is not defined and ZF is set.</li>
<li><strong>TEST</strong>: This instruction makes it possible to check for several bits being set at the same time. To put it simply, the TEST instruction performs the logical AND operation, sets flags accordingly, and discards the result.</li>
</ul>
<p>Byte instructions are all of a form SETcc, where <strong>cc</strong> stands for <strong>condition code</strong>. The following are the condition codes on the Intel platform, as specified in section B.1 Condition Codes of <em>Appendix B EFlags Condition Codes</em> of Intel 64 and IA-32 Architectures Software Developer's Manual Volume 1:</p>
<table style="width: 929px;height: 1657px">
<tbody>
<tr>
<td><strong>Mnemonic (cc)</strong></td>
<td><strong>Condition tested for</strong></td>
<td><strong>Status flags setting</strong></td>
</tr>
<tr>
<td>O</td>
<td>Overflow</td>
<td>
<p>OF = 1</p>
</td>
</tr>
<tr>
<td>NO</td>
<td>No overflow</td>
<td>
<p>OF = 0</p>
</td>
</tr>
<tr>
<td>
<p>B<br/>
NAE</p>
</td>
<td>Below<br/>
Neither above nor equal</td>
<td>
<p>CF = 1</p>
</td>
</tr>
<tr>
<td>
<p>NB<br/>
AE</p>
</td>
<td>Not below<br/>
Above or equal</td>
<td>
<p>CF = 1</p>
</td>
</tr>
<tr>
<td>
<p>E<br/>
Z</p>
</td>
<td>Equal<br/>
Zero</td>
<td>
<p>ZF = 1</p>
</td>
</tr>
<tr>
<td>
<p>NE<br/>
NZ</p>
</td>
<td>Not equal<br/>
Not zero</td>
<td>
<p>ZF = 0</p>
</td>
</tr>
<tr>
<td>
<p>BE<br/>
NA</p>
</td>
<td>Below or equal<br/>
Not above</td>
<td>
<p>(CF or ZF) = 1</p>
</td>
</tr>
<tr>
<td>
<p>NBE<br/>
A</p>
</td>
<td>Neither below nor equal<br/>
Above</td>
<td>
<p>(CF or ZF) = 0</p>
</td>
</tr>
<tr>
<td>
<p>S</p>
</td>
<td>Sign</td>
<td>
<p>SF = 1</p>
</td>
</tr>
<tr>
<td>
<p>NS</p>
</td>
<td>No sign</td>
<td>
<p>SF = 0</p>
</td>
</tr>
<tr>
<td>
<p>P<br/>
PE</p>
</td>
<td>Parity<br/>
Parity even</td>
<td>
<p>PF = 1</p>
</td>
</tr>
<tr>
<td>
<p>NP<br/>
PO</p>
</td>
<td>No parity<br/>
Parity odd</td>
<td>
<p>PF = 0</p>
</td>
</tr>
<tr>
<td>
<p>L<br/>
NGE</p>
</td>
<td>Less<br/>
Neither greater nor equal</td>
<td>
<p>(SF xor OF) = 1</p>
</td>
</tr>
<tr>
<td>
<p>NL<br/>
GE</p>
</td>
<td>
<p>Not less<br/>
Greater or equal</p>
</td>
<td>
<p>(SF xor OF) = 0</p>
</td>
</tr>
<tr>
<td>
<p>LE<br/>
NG</p>
</td>
<td>
<p>Less or equal<br/>
Not greater</p>
</td>
<td>
<p>((SF xor OF) or ZF) = 1</p>
</td>
</tr>
<tr>
<td>
<p>NLE<br/>
G</p>
</td>
<td>
<p>Not less or equal<br/>
Greater</p>
</td>
<td>
<p>((SF xor OF) or ZF) = 0</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>So, as we may conclude using the preceding table and the <kbd>setc</kbd> instruction from the CRC8 example, it instructs the processor to set <kbd>bl</kbd> (and <kbd>bh</kbd>) to 1 if the C condition is true, which means CF == 1.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Execution flow transfer instructions</h1>
                
            
            
                
<p>Instructions of this group make it possible to easily branch the execution, whether in accordance to a specific condition designated by the EFlags/RFlags register or completely unconditionally, and may, therefore, be divided into two groups:</p>
<ul>
<li>Unconditional execution flow transfer instructions:
<ul>
<li><strong>JMP</strong>: Perform unconditional jump to an explicitly specified location. This loads the instruction pointer register with the address of the specified location.</li>
<li><strong>CALL</strong>: This instruction is used to call a procedure. This pushes the address of the next instruction onto the stack and loads the instruction pointer with the address of the first instruction in the called procedure.</li>
<li><strong>RET</strong>: This instruction performs a return from procedure. It pops the value stored on the stack into the instruction pointer register. When used at the end of a procedure, it returns the execution to instruction following the CALL instruction.<br/>
The RET instruction may have a two-bytes value as its operand, in which case the value defines the amount of bytes occupied by the operands that were passed to the procedure on stack. The stack pointer is then automatically adjusted by adding the amount of bytes.</li>
<li><strong>INT</strong>: This instruction causes a software interrupt.<br/>
The use of this instruction on Windows while programming in ring 3 is quite rare. It may even be safe to assume that the only usage is INT3--software breakpoint. On 32-bit Linux, however, it is used for invocation of system calls.</li>
</ul>
</li>
<li>Conditional execution flow transfer instructions:
<ul>
<li><strong>Jcc</strong>: This is the conditional variant of the JMP instruction, where <strong>cc</strong> stands for <strong>condition code</strong>, which may be one of the condition codes listed in the preceding table. For example, look at the <kbd>jz .noxor</kbd> line from the CRC8 example.</li>
<li><strong>JCXZ</strong>: This is a special version of the conditional jump instruction, which uses the CX register as a condition. The jump is only executed if the CX register contains 0.</li>
<li><strong>JECXZ</strong>: This is the same as above, but it operates on the ECX register.</li>
<li><strong>JRCXZ</strong>: This is the same as above, but it operates on the RCX register (long mode only).</li>
<li><strong>LOOP</strong>: A loop with ECX as a counter, this decrements ECX and, if the result is not 0, loads the instruction pointer register with the address of the loop label. We have already used this instruction in the CRC8 example.</li>
<li><strong>LOOPZ</strong>/<strong>LOOPE</strong>: This is the loop with ECX as a counter while ZF = 1.</li>
<li><strong>LOOPNZ</strong>/<strong>LOOPNE</strong>: This is the loop with ECX as a counter while ZF = 0.</li>
</ul>
</li>
</ul>
<p>Let's, for the sake of example, implement the CRC8 algorithm as a procedure (insert the following into the code section of the relevant 32-bit template):</p>
<pre><em>;</em><br/><em>; Put your code here</em><br/><em>; </em> <br/>   mov al, 0x16         <em>; In this specific case we pass the <br/>                        ; only argument via AL register</em><br/>   call crc_proc        <em>; Call the 'crc_proc' procedure</em><br/><br/><em>   ; For Windows</em><br/>   push 0               <em>; Terminate the process if you are on Windows</em><br/>   call [exitProcess]<br/><br/>   <em>; For Linux          ; Terminate the process if you are on Linux</em><br/>   xor  ebx, ebx<br/>   mov  eax, ebx<br/>   inc  eax<br/>   int  0x80<br/><br/>crc_proc:               <em>; Our CRC8 procedure</em><br/>   push ebx ecx edx     <em>; Save the register we are going to use on stack</em><br/>   xor dl, dl           <em>; Initialise the CRC state register</em><br/>   mov ecx, 8           <em>; Setup counter</em><br/>.crc_loop:<br/>   shl al, 1<br/>   setc bl<br/>   shl dl, 1<br/>   setc bh<br/>   xor bl, bh<br/>   jz .noxor<br/>   xor dl, 0x31<br/>.noxor:<br/>   loop .crc_loop<br/>   mov al, dl          <em>; Setup return value</em><br/>   pop edx ecx ebx     <em>; Restore registers</em><br/>   ret                 <em>; Return from this procedure</em></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">String instructions</h1>
                
            
            
                
<p>This is an interesting group of instructions that operate on strings of bytes, words, double words, or quad words (long mode only). These instructions have implicit operands only:</p>
<ul>
<li>The source address should be loaded into the ESI (RSI for long mode) register</li>
<li>The destination address should be loaded into the EDI (RDI for long mode) register</li>
<li>One of the EAX (for example, AL and AX) register variations is used with all of them except the MOVS* and CMPS* instructions</li>
<li>The number of iterations (if any) should be in ECX (only used with the REP* prefix)</li>
</ul>
<p>ESI and/or EDI registers are automatically incremented by one for byte, two for word, and four for double word data. The direction of these operations (whether they increment or decrement ESI/EDI) is controlled by the direction flag (DF) in the EFlags register: DF = 1 : decrement ESI/EDI DF = 0 : increment ESI/EDI.</p>
<p>These instructions may be divided into five groups. In fact, to put it in a more precise manner, there are five instructions supporting four data sizes each:</p>
<ul>
<li><strong>MOVSB</strong>/<strong>MOVSW</strong>/<strong>MOVSD</strong>/<strong>MOVSQ</strong>: These move byte, word, double word, or quad word in memory from the location pointed by ESI/RSI to the location pointed by EDI/RDI. The instruction's suffix specifies the size of data to be moved. Setting ECX/RCX to the amount of data items to be moved and prefixing it with the REP* prefix instructs the processor to execute this instruction ECX times or while the condition used with the REP* prefix (if any) is true.</li>
<li><strong>CMPSB</strong>/<strong>CMPSW</strong>/<strong>CMPSD</strong>/<strong>CMPSQ</strong>: These compare the data pointed by the ESI/RSI register to the data pointed by the EDI/RDI register. The iteration rules are the same as for MOVS* instruction.</li>
<li><strong>SCASB</strong>/<strong>SCASW</strong>/<strong>SCASD</strong>/<strong>SCASQ</strong>: These scan sequences of data items (size thereof is specified by the instruction's suffix) pointed by the EDI/RDI register for a value specified in AL, AX, EAX, or RAX, depending on the mode (protected or long) and the instruction's suffix. Iterations rules are the same as those for the MOVS* instruction.</li>
<li><strong>LODSB</strong>/<strong>LODSW</strong>/<strong>LODSD</strong>/<strong>LODSQ</strong>: These load AL, AX, EAX, or RAX (depending on operation mode and instruction's suffix) with a value from memory, pointed by the ESI/RSI register. The iteration rules are the same as those for the MOVS* instruction.</li>
<li><strong>STOSB</strong>/<strong>STOSW</strong>/<strong>STOSD</strong>/<strong>STOSQ</strong>: These store the value of the AL, AX, EAX, or RAX registers to the memory location pointed by the EDI/RDI register. These iteration rules are the same as those for the MOVS* instruction.</li>
</ul>
<p>All of the preceding instructions have the explicit-operands form without a suffix, but in such a case, we need to specify the size of the operands. While the operands themselves may not be changed and therefore would always be ESI/RSI and EDI/RDI, all we may change is the size of the operand. The following is an example of such case:</p>
<pre>scas byte[edi]</pre>
<p>The following example shows typical usage of the SCAS* instruction--scanning a sequence of, in this particular case, bytes for specific value, which is stored in the AL register. The other instructions are similar in their usage.</p>
<pre><em>; Calculate the length of a string</em><br/>   mov   edi, hello<br/>   mov   ecx, 0x100    <em>; Maximum allowed string length</em><br/>   xor   al, al        <em>; We will look for 0</em><br/>   <strong>rep</strong> <strong>scasb          </strong> <em>; Scan for terminating 0</em><br/>   or    ecx, 0        <em>; Check whether the string is too long</em><br/>   jz    too_long<br/>   neg   ecx           <em>; Negate ECX</em><br/>   add   ecx, 0x100    <em>; Get the length of the string</em><br/>                       <em>; ECX = 14 (includes terminating 0)</em><br/>too_long:<br/>   <em>; Handle this</em><br/><br/>hello db "Hello, World!", 0</pre>
<p>The <kbd>rep</kbd> prefix, used in the preceding example, indicates to the processor that it should execute the prefixed command using the ECX register as a counter (in the same manner as it is used by the LOOP* instructions). However, there is one more optional condition designated by ZF (zero flag). Such a condition is specified by the condition suffix attached to REP. For example, using it with the E or Z suffix would instruct the processor to check ZF for being set before each iteration. Suffixes NE or NZ would instruct the processor to check ZF for being reset before each iteration. Consider the following example:</p>
<pre>repz cmpsb</pre>
<p>This would instruct the processor to keep comparing two sequences of bytes (pointed by the EDI/RDI and ESI/RSI registers) while they are equal and ECX is not zero.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">ENTER/LEAVE</h1>
                
            
            
                
<p>According to the Intel manual for developers, <em>these instructions provide machine-language support for procedure calls in block-structured languages;</em> however, they are very useful for Assembly developers as well.</p>
<p>When we implement a procedure, we have to take care of the creation of the stack frame where we store the procedure's variables, storing the value of ESP and then restoring all that before we leave a procedure. These two instructions can do all that work for us:</p>
<pre><em>; Do something here</em><br/>call   my_proc<br/><em>; Do something else here</em><br/><br/>my_proc:<br/>   <strong>enter</strong> 0x10, 0   <em>; Save EBP register on stack,</em><br/>                   <em>; save ESP to EBP and</em><br/><em>                   ; allocate 16 bytes on stack for procedure variables</em><br/><em>   ;</em><br/><em>   ; procedure body</em><br/><em>   ;</em><br/>   <strong>leave          </strong> <em>; Restore ESP and EBP registers (this automatically</em><br/>                   <em>; releases the space allocated on stack with ENTER)</em><br/>   ret             <em>; Return from procedure</em></pre>
<p>The preceding code is equivalent to the following code:</p>
<pre><em>; Do something here</em><br/>call   my_proc<br/><em>; Do something else here</em><br/><br/>my_proc:<br/>   push   ebp       <em>; Save EBP register on stack,</em><br/>   mov    ebp, esp  <em>; save ESP to EBP and</em><br/>   sub    esp, 0x10 <em>; allocate 16 bytes on stack for procedure variables</em><br/><em>   ;</em><br/><em>   ; procedure body</em><br/><em>   ;</em><br/>   mov    esp, ebp<strong> </strong> <em>; Restore ESP and EBP registers (this automatically</em><br/>   pop    ebp       <em>; releases the space allocated on stack with ENTER)</em><br/>   ret              <em>; Return from procedure</em></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Flag control instructions</h1>
                
            
            
                
<p>The EFlags register contains information on certain aspects of the last ALU operation as well as certain settings of the CPU (for example, the direction of string instructions); however, we have the mechanism for controlling the content of this register, up to the level of a single flag, with the following instructions:</p>
<ul>
<li><strong>Set</strong>/<strong>clear carry flag</strong> (<strong>STC</strong>/<strong>CLC</strong>): We may want to have the CF set or reset prior to certain operations.</li>
<li><strong>Complement the carry flag</strong> (<strong>CMC</strong>): This instruction inverts the value of the CF.</li>
<li><strong>Set</strong>/<strong>clear direction flag</strong> (<strong>STD</strong>/<strong>CLD</strong>): We may use these instructions to set or reset the DF in order to define whether ESI/EDI (RSI/RDI) should increment or decrement with string instructions.</li>
<li><strong>Load flags into the AH register</strong> (<strong>LAHF</strong>): There are certain flags, for example, ZF, that do not have associated instructions for direct modification, therefore, we may load the Flags register into AH, modify the corresponding bit, and reload the Flags register with the modified value.</li>
<li><strong>Store the AH register into flags</strong> (<strong>SAHF</strong>): This instruction stores the value of AH register into the Flags register.</li>
<li><strong>Set</strong>/<strong>clear the interrupt flag</strong> (<strong>STI</strong>/<strong>CLI</strong>) (not in user land): These instructions are used on the operating system-level to enable/disable interrupts.</li>
<li><strong>Push Flags</strong>/<strong>EFlags</strong>/<strong>RFlags register onto the stack</strong> (<strong>PUSHF</strong>/<strong>PUSHFD</strong>/<strong>PUSHFQ</strong>): LAHF/SAHF instructions may not be sufficient for inspection/modification of certain flags in the Flags/EFlags/RFlags register. With the PUSHF* instruction, we gain access to other bits (flags).</li>
<li><strong>Retrieve Flags</strong>/<strong>EFlags</strong>/<strong>RFlags register from the stack</strong> (<strong>POPF</strong>/<strong>POPFD</strong>/<strong>POPFQ</strong>): These reload Flags/EFlags/RFlags register with the new value from the stack.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Miscellaneous instructions</h1>
                
            
            
                
<p>There are a few instructions without any particular category assigned to them, which are as follows:</p>
<ul>
<li><strong>Load effective address</strong> (<strong>LEA</strong>): This instruction calculates the effective address specified with one of the processor's addressing modes in the source operand and stores it in the destination operand. It is also frequently used instead of the ADD instruction when terms are specified as parts of the addressing mode. The following example code shows both cases:</li>
</ul>
<pre style="padding-left: 60px"><strong>lea</strong> eax, [some_label] <em>; EAX will contain the address of some_label</em><br/> <strong>lea</strong> eax, [ebx + edi] <em>; EAX will contain the sum of EBX and EDI</em></pre>
<ul>
<li><strong>No operation</strong> (<strong>NOP</strong>): As the name states, this instruction performs no operation and is often used for filling the gaps between aligned procedures.</li>
<li><strong>Processor identification</strong> (<strong>CPUID</strong>): Depending on the value of the operand (in EAX), this instruction returns CPU identification information. This instruction is available only if the ID flag in the EFlags register (bit 21) is set.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">FPU instructions</h1>
                
            
            
                
<p>FPU instructions are executed by the x87 <strong>floating-point unit</strong> (<strong>FPU</strong>) and operate on floating point, integer, or binary coded decimal values. These instructions are grouped by their purpose:</p>
<ul>
<li>FPU data transfer instructions</li>
<li>FPU basic arithmetic instructions</li>
<li>FPU comparison instructions</li>
<li>FPU load constant instructions</li>
<li>FPU control instructions</li>
</ul>
<p>Another important aspect of the FPU operation is the fact that, unlike the registers of the processor, floating point registers are organized in the form of a stack. Instructions like <kbd>fld</kbd> are used to push the operand onto the top of the stack, instructions like <kbd>fst</kbd> are used for reading a value from the top of the stack, and instructions like <kbd>fstp</kbd> are used for popping the value from the top of the stack and moving other values toward the top.</p>
<p>The following example shows the calculation of the circumference for a circle with radius of <kbd>0.2345</kbd>:</p>
<pre><em>; This goes in '.text' section</em><br/>fld     [radius]    <em>; Load radius to ST0</em><br/><em>                    ; ST0 &lt;== 0.2345</em><br/>fldpi               <em>; Load PI to ST0</em><br/><em>                    ; ST1 &lt;== ST0</em><br/><em>                    ; ST0 &lt;== 3.1415926</em><br/>fmulp               <em>; Multiply (ST0 * ST1) and pop</em><br/><em>                    ; ST0 = 0.7367034</em><br/>fadd    st0, st0    <em>; * 2</em><br/><em>                    ; ST0 = 1.4734069</em><br/>fstp    [result]    <em>; Store result</em><br/><em>                    ; result &lt;== ST0</em><br/><br/><em>; This goes in '.data' section</em><br/>radius  dt  0.2345<br/>result  dt  0.0</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Extensions</h1>
                
            
            
                
<p>Since the first Intel microprocessor, technology has significantly evolved and so has the complexity of the processor architecture. The initial set of instructions, although it was and still is quite powerful, is not enough for some tasks (and here we have to admit that the number of such tasks is growing as time goes by). The solution adopted by Intel is nice and quite user friendly: <strong>Instruction Set Architecture Extensions</strong> (<strong>ISA Extensions</strong>). Intel has gone a long way from <strong>MMX</strong> (unofficially, <strong>MultiMedia eXtension</strong>) to SSE4.2, AVX, and AVX2 extensions, which introduced support for 256-bit data processing and AVX-512, which allows the processing of 512-bit data and extends the number of usable SIMD registers to 32. All of these are SIMD extensions, where SIMD stands for single instruction multiple data. In this section, we will particularly pay attention to the AES-NI extension and partially to SSE (which will be covered in more detail in <a href="81d8a530-f9fe-484d-83f7-652ce31bfa1c.xhtml" target="_blank">Chapter 5</a>, <em>Parallel Data Processing</em>).</p>


            

            
        
    

        

                            
                    <h1 class="header-title">AES-NI</h1>
                
            
            
                
<p><strong>AES-NI</strong> stands for <strong>Advanced Encryption Standard New Instructions</strong>, an extension initially proposed by Intel in 2008 for speeding up AES algorithm implementations.</p>
<p>The following code checks whether AES-NI is supported by the CPU:</p>
<pre>mov   eax, 1        <em>; CPUID request code #1</em><br/>cpuid<br/>test ecx, 1 shl 25  <em>; Check bit 25</em><br/>jz not_supported    <em>; If bit 25 is not set - CPU does not support AES-NI</em></pre>
<p>Instructions in this extension are rather simple and few:</p>
<ul>
<li><strong>AESENC</strong>: This performs one round of AES encryption on 128-bit data using a 128-bit round key for all encryption rounds except the last round</li>
<li><strong>AESENCLAST</strong>: This performs the last round of AES encryption on 128-bit data</li>
<li><strong>AESDEC</strong>: This performs one round of AES decryption on 128-bit data using a 128-bit round key for all decryption rounds except the last round</li>
<li><strong>AESDECLAST</strong>: This performs the last round of AES decryption on 128-bit data</li>
<li><strong>AESKEYGENASSIST</strong>: This assists in the generation of an AES round key using an 8-bit round constant (RCON)</li>
<li><strong>AESIMC</strong>: This performs the inverse mix column transformation on a 128-bit round key</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">SSE</h1>
                
            
            
                
<p>SSE stands for Streaming SIMD Extension, which allows, as the name suggest, processing of multiple data with a single instruction, which is best seen in the following example code:</p>
<pre>lea   esi, [fnum1]<br/>movq  xmm0, [esi]    <em>; Load fnum1 and fnum2 into xmm0 register</em><br/>add   esi, 8<br/>movq  xmm1, [esi]    <em>; Load fnum3 and fnum4 into xmm1 register</em><br/>addps xmm0, xmm1     <em>; Add two floats in xmm1 to another two floats in xmm0</em><br/><em>                     ; xmm0 will then contain:</em><br/><em>                     ; 0.0  0.0  1.663  12.44</em><br/><br/>fnum1  dd 0.12<br/>fnum2  dd 1.24<br/>fnum3  dd 12.32<br/>fnum4  dd 0.423</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Example program</h1>
                
            
            
                
<p>As you have noticed, the previous two sections (AES-NI and SSE) were left without proper examples. The reason is that the best way to demonstrate the abilities of both extensions would be to mix them in a single program. In this section, we will implement a simple AES-128 encryption algorithm with the help of the two. AES encryption is one the classic examples of an algorithm that would definitely benefit from parallel processing of data offered by SSE.</p>
<p>We will use the templates we prepared in the beginning of this chapter, thus, all we have to do is write the following code in place of this comment:</p>
<pre><em>;</em><br/><em>; Put your code here</em><br/><em>;</em></pre>
<p>The code runs equally well on both Windows and Linux, so no other preparations required:</p>
<pre><em> ; First of all we have to expand the key</em><br/><em> ; into AES key schedule.</em><br/> lea esi, [k]<br/> movups xmm1, [esi]<br/> lea edi, [s]<br/><br/> <em>; Copy initial key to schedule</em><br/> mov ecx, 4<br/> rep movsd<br/> <em>; Expand the key</em><br/> call aes_set_encrypt_key<br/><br/> <em>; Actually encrypt data</em><br/> lea esi, [s] <em>; ESI points to key schedule</em><br/> lea edi, [r] <em>; EDI points to result buffer</em><br/> lea eax, [d] <em>; EAX points to data we want</em><br/><em>              ; to encrypt</em><br/> movups xmm0, [eax] <em>; Load this data to XMM0</em><br/><br/> <em>; Call the AES128 encryption procedure</em><br/> call aes_encrypt<br/><br/> <em>; Nicely terminate the process</em><br/> push 0<br/> call [exitProcess]<br/><br/><br/><em>; AES128 encryption procedure</em><br/>aes_encrypt: <em>; esi points to key schedule</em><br/><em>             ; edi points to output buffer</em><br/><em>             ; xmm0 contains data to be encrypted</em><br/>   mov ecx, 9<br/>   movups xmm1, [esi]<br/>   add esi, 0x10<br/>   pxor xmm0, xmm1          <em>; Add the first round key</em><br/><br/>.encryption_loop:<br/>   movups xmm1, [esi]       <em>; Load next round key</em><br/>   add esi, 0x10<br/>   aesenc xmm0, xmm1        <em>; Perform encryption round</em><br/>   loop .encryption_loop<br/><br/>   movups xmm1, [esi]       <em>; Load last round key</em> <br/>   aesenclast xmm0, xmm1    <em>; Perform the last encryption round</em><br/><br/>   lea edi, [r]<br/>   movups [edi], xmm0       <em>; Store encrypted data</em><br/>   ret<br/><br/><em>; AES128 key setup procedures</em><br/><em>; This procedure creates full</em><br/><em>; AES128 encryption key schedule</em><br/>aes_set_encrypt_key: <em>; xmm1 contains the key</em><br/><em>                     ; edi points to key schedule</em><br/>   aeskeygenassist xmm2, xmm1, 1<br/>   call key_expand<br/>   aeskeygenassist xmm2, xmm1, 2<br/>   call key_expand<br/>   aeskeygenassist xmm2, xmm1, 4<br/>   call key_expand<br/>   aeskeygenassist xmm2, xmm1, 8<br/>   call key_expand<br/>   aeskeygenassist xmm2, xmm1, 0x10<br/>   call key_expand<br/>   aeskeygenassist xmm2, xmm1, 0x20<br/>   call key_expand<br/>   aeskeygenassist xmm2, xmm1, 0x40<br/>   call key_expand<br/>   aeskeygenassist xmm2, xmm1, 0x80<br/>   call key_expand<br/>   aeskeygenassist xmm2, xmm1, 0x1b<br/>   call key_expand<br/>   aeskeygenassist xmm2, xmm1, 0x36<br/>   call key_expand<br/>   ret<br/><br/>key_expand: <em>; xmm2 contains key portion</em><br/><em>            ; edi points to place in schedule</em><br/><em>            ; where this portion should</em><br/><em>            ; be stored at</em><br/> pshufd xmm2, xmm2, 0xff    <em>; Set all elements to 4th element</em><br/> vpslldq xmm3, xmm1, 0x04   <em>; Shift XMM1 4 bytes left</em><br/><em>                            ; store result to XMM3</em><br/> pxor xmm1, xmm3            <br/> vpslldq xmm3, xmm1, 0x04<br/> pxor xmm1, xmm3<br/> vpslldq xmm3, xmm1, 0x04<br/> pxor xmm1, xmm3<br/> pxor xmm1, xmm2<br/> movups [edi], xmm1<br/> add edi, 0x10<br/> ret</pre>
<p>The following should be placed in the data section/segment:</p>
<pre><em> ; Data to be encrypted</em><br/> d db 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0xa,0xb, 0xc, 0xd, 0xe, 0xf<br/> <br/> <em>; Encryption key</em><br/> k db 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1<br/> <br/> <em>; AES key schedule (11 round keys, 16 bytes each)</em><br/> s rb 16 * 11<br/> <br/> <em>; Result will be placed here</em><br/> r rb 16</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>We began this chapter with creation of two templates--one for a 32-bit Windows executable and the other for a 32-bit Linux executable. While there are certain parts of both templates that may still be unclear, let that bother you not, as we will cover each and every aspect thereof when the time comes. You may use these templates as a skeleton for your own code.</p>
<p class="mce-root">The most significant part of the chapter, however, was dedicated to the Intel Instruction Set Architecture itself. It was, of course, a very brief overview as there was no need to describe each and every instruction--Intel did the job releasing their Programmer's Manual, which contains over three thousand pages. Instead, a decision was made to provide only the basic information and help us achieve certain level of acquaintance with Intel instruction set.</p>
<p class="mce-root">We ended the chapter by implementing the AES128 encryption algorithm with the aid of AES-NI extension, which makes the process of AES128 encryption/decryption significantly simpler and easier.</p>
<p class="mce-root">Now, when we understand the instructions, we are ready to proceed further to the memory organization and data and code addressing modes.</p>


            

            
        
    </body></html>