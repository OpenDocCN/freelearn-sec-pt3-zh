["```\n  while (true) {\n for (char i = 1; i <= 255; i++) {\n if (GetAsyncKeyState(i) & 1) {\n sprintf_s(lpBuffer, \"\\\\x%02x\", i);\n LogFile(lpBuffer, (char*)\"log.txt\");\n }\n }\n```", "```\nvoid LogFile(char* lpBuffer, LPCSTR fname) {\n\n  BOOL bErrorFlag;\n  DWORD dwBytesWritten;\n\n  HANDLE hFile = CreateFileA(fname, FILE_APPEND_DATA, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);\n  bErrorFlag = WriteFile(hFile, lpBuffer, strlen(lpBuffer), &dwBytesWritten, NULL);\n  CloseHandle(hFile);\n\n  return;_\n}\n```", "```\nint main()\n{\n LPCSTR lpSubKey = \"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run\";\n HKEY hkResult;\n DWORD dwIndex;\n char ValueName[1024];\n char ValueData[1024];\n DWORD cchValueName;\n DWORD result;\n DWORD dType;\n DWORD dataSize;\n HKEY hKey = HKEY_LOCAL_MACHINE;\n\n if (RegOpenKeyExA(hKey, lpSubKey, 0, KEY_READ, &hkResult) == ERROR_SUCCESS)\n {\n printf(\"HKEY_LOCAL_MACHINE\\\\%s\\n\", lpSubKey);\n dwIndex = 0;\n result = ERROR_SUCCESS;\n while (result == ERROR_SUCCESS)\n {\n cchValueName = 1024;\n result = RegEnumValueA(hkResult, dwIndex, (char *)&ValueName, &cchValueName, NULL, NULL, NULL, NULL);\n if (result == ERROR_SUCCESS)\n {\n RegQueryValueExA(hkResult, ValueName, NULL, &dType, (unsigned char *)&ValueData, &dataSize);\n if (strlen(ValueName) == 0)\n sprintf((char*)&ValueName, \"%s\", \"(Default)\");\n printf(\"%s: %s\\n\", ValueName, ValueData);\n }\n dwIndex++;\n }\n RegCloseKey(hkResult);\n }\n return 0;\n}\n```", "```\nint main()\n{\n  HANDLE hSnapshot;\n  PROCESSENTRY32 pe32;\n\n  hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);\n  pe32.dwSize = sizeof(PROCESSENTRY32);\n\n  if (Process32First(hSnapshot, &pe32))\n  {\n    printf(\"\\nexecutable [pid]\\n\");\n    do\n    {\n      printf(\"%ls [%d]\\n\", pe32.szExeFile, pe32.th32ProcessID);\n    } while (Process32Next(hSnapshot, &pe32));\n    CloseHandle(hSnapshot);\n  }\n    return 0;\n}\n```", "```\nint main()\n{\n  unsigned char buffer[1024] = \"Hello World!\";\n  unsigned char password[] = \"this0is0quite0a0long0cryptographic0key\";\n  DWORD dwDataLen;\n  BOOL Final;\n\n  HCRYPTPROV hProv;\n\n  printf(\"message: %s\\n\", buffer);\n  if (CryptAcquireContextA(&hProv, NULL, NULL, PROV_RSA_AES, CRYPT_VERIFYCONTEXT))\n  {\n    HCRYPTHASH hHash;\n    if (CryptCreateHash(hProv, CALG_SHA_256, NULL, NULL, &hHash))\n    {\n      if (CryptHashData(hHash, password, strlen((char*)password), NULL))\n      {\n        HCRYPTKEY hKey;\n        if (CryptDeriveKey(hProv, CALG_AES_128, hHash, NULL, &hKey))_\n        {\n          Final = true;\n          dwDataLen = strlen((char*)buffer);\n          if (CryptEncrypt(hKey, NULL, Final, NULL, (unsigned char*)&buffer, &dwDataLen, 1024))\n          {\n            printf(\"saving encrypted buffer to message.enc\");\n            LogFile(buffer, dwDataLen, (char*)\"message.enc\");\n          }\n          printf(\"%d\\n\", GetLastError());\n          CryptDestroyKey(hKey);\n        }\n      }\n      CryptDestroyHash(hHash);\n    }\n    CryptReleaseContext(hProv, 0);\n  }\n  return 0;\n}\n```", "```\nvoid LogFile(unsigned char* lpBuffer, DWORD buflen, LPCSTR fname) {\n\n  BOOL bErrorFlag;\n  DWORD dwBytesWritten;\n\n  DeleteFileA(fname);\n\n  HANDLE hFile = CreateFileA(fname, FILE_ALL_ACCESS, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);\n  bErrorFlag = WriteFile(hFile, lpBuffer, buflen, &dwBytesWritten, NULL);\n  CloseHandle(hFile);\n\n  Sleep(10);\n\n  return;\n}\n```", "```\nint main()\n{\n  unsigned char buffer[1024];\n  unsigned char password[] = \"this0is0quite0a0long0cryptographic0key\";\n  DWORD dwDataLen;\n  BOOL Final;\n\n  DWORD buflen;\n  char fname[] = \"message.enc\";\n  HANDLE hFile = CreateFileA(fname, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);\n  ReadFile(hFile, buffer, 1024, &buflen, NULL);\n  CloseHandle(hFile);\n\n  HCRYPTPROV hProv;\n\n  if (CryptAcquireContextA(&hProv, NULL, NULL, PROV_RSA_AES, CRYPT_VERIFYCONTEXT))\n  {\n    HCRYPTHASH hHash;\n    if (CryptCreateHash(hProv, CALG_SHA_256, NULL, NULL, &hHash))\n    {\n      if (CryptHashData(hHash, password, strlen((char*)password), NULL))\n      {\n        HCRYPTKEY hKey;\n        if (CryptDeriveKey(hProv, CALG_AES_128, hHash, NULL, &hKey))\n        {\n          Final = true;\n          dwDataLen = buflen;\n          if ( CryptDecrypt(hKey, NULL, Final, NULL, (unsigned char*)&buffer, &dwDataLen) )\n          {\n            printf(\"decrypted message: %s\\n\", buffer);\n            printf(\"saving decrypted message to message.dec\");\n            LogFile(buffer, dwDataLen, (char*)\"message.dec\");\n          }\n          printf(\"%d\\n\", GetLastError());\n          CryptDestroyKey(hKey);\n        }\n      }\n      CryptDestroyHash(hHash);\n    }\n    CryptReleaseContext(hProv, 0);\n  }\n  return 0;\n}\n\n```", "```\n\nint main()\n{\n int listenfd = 0, connfd = 0;\n struct sockaddr_in serv_addr;\n struct sockaddr_in ctl_addr;\n int addrlen;\n char sendBuff[1025];\n\n WSADATA WSAData;\n\n if (WSAStartup(MAKEWORD(2, 2), &WSAData) == 0)\n {\n     listenfd = socket(AF_INET, SOCK_STREAM, 0);\n     if (listenfd != INVALID_SOCKET)\n     {\n         memset(&serv_addr, '0', sizeof(serv_addr));\n         memset(sendBuff, '0', sizeof(sendBuff));\n         serv_addr.sin_family = AF_INET;\n         serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);\n         serv_addr.sin_port = htons(9999);\n         if (bind(listenfd, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) == 0)\n         {\n             if (listen(listenfd, SOMAXCONN) == 0)\n             {\n                 printf(\"Genie is waiting for connections to port 9999.\\n\");\n                 while (1)\n                 {\n                     addrlen = sizeof(ctl_addr);\n                     connfd = accept(listenfd, (struct sockaddr*)&ctl_addr, &addrlen);\n                     if (connfd != INVALID_SOCKET)\n                     {\n                         printf(\"%s has connected.\\n\", inet_ntoa(ctl_addr.sin_addr));\n\n                         snprintf(sendBuff, sizeof(sendBuff), \"You have connected to the Genie. Nothing to see here.\\n\\n\");\n                         send(connfd, sendBuff, strlen(sendBuff), 0);\n                         closesocket(connfd);\n                     }\n                 }\n             }\n         }\n     closesocket(listenfd);\n     }\n WSACleanup();\n }\n return 0;\n}\n```", "```\nFilename:  passcode.exe\nFilesize:  16,766 bytes\nMD5:  5D984DB6FA89BA90CF487BAE0C5DB300\nSHA256:  A5A981EDC9D4933AEEE888FC2B32CA9E0E59B8945C78C9CBD84085AB8D616568\nFile Type: Windows PE 32-bit\nCompiler: MingWin32 - Dev C++\n```", "```\nmain()\n{\n    printf(\"what is the password? \");\n    scanf(\"%30[0-9a-zA-Z ]\", &password);\n    password_size = strlen(password);\n    if (password_size == 17)\n    { ... }\n    else\n    { ... }\n}\n```", "```\nwrong_password()\n{\n    printf(\"wrong password. try again!\\n\");\n}\n\nmain()\n{\n    printf(\"what is the password? \");\n    scanf(\"%30[0-9a-zA-Z ]\", &password);\n    password_size = strlen(password);\n    if (password_size == 17)\n    { ... }\n    else\n    {\n        wrong_password();\n    }\n}\n```", "```\n[ebp+5*4-5ch] -> [ebp-48h] = 10h\n[ebp+4*4-5ch] -> [ebp-4Ch] = 0eh\n[ebp+3*4-5ch] -> [ebp-50h] = 7\n[ebp+2*4-5ch] -> [ebp-54h] = 5\n[ebp+1*4-5ch] -> [ebp-58h] = 3\n```", "```\neax = 5;  edx = ebp-8+10h;  edx = ebp+8\neax = 4;  edx = ebp-8+0eh;  edx = ebp+6\neax = 3;  edx = ebp-8+7;    edx = ebp-1\neax = 2;  edx = ebp-8+5;    edx = ebp-3\neax = 1;  edx = ebp-8+3;    edx = ebp-5\n```", "```\nfrom eax = 5;  eax = ebp+8-20h;  eax = ebp-18h\nfrom eax = 4;  eax = ebp+6-20h;  eax = ebp-1ah\nfrom eax = 3;  eax = ebp-1-20h;  eax = ebp-21h\nfrom eax = 5;  eax = ebp-3-20h;  eax = ebp-23h\nfrom eax = 5;  eax = ebp-5-20h;  eax = ebp-25h\n```", "```\nwrong_password()\n{\n    printf(\"wrong password. try again!\\n\");\n}\n\nmain()\n{\n    e_locations[] = [3, 5, 7, 0eh, 10h];\n    printf(\"what is the password? \");\n    scanf(\"%30[0-9a-zA-Z ]\", &password);\n    password_size = strlen(password);\n    if (password_size == 17)\n    {\n\n        for (i = 5; i >= 0; i--)\n            if (password[e_locations[i]] != 'e')\n            {\n                wrong_password();\n                goto goodbye;\n            }\n        ...\n    }\n    else\n    {\n        wrong_password();\n    }\ngoodbye:\n}\n```", "```\nwrong_password()\n{\n    printf(\"\\nwrong password. try again!\\n\");\n}\n\ncorrect_password()\n{\n    printf(\"\\ncorrect password. bye!\\n\");\n}\n\nmain()\n{\n    e_locations[] = [3, 5, 7, 0eh, 10h];\n    printf(\"what is the password? \");\n    scanf(\"%30[0-9a-zA-Z ]\", &password);\n    password_size = strlen(password);\n    if (password_size == 17)\n    {\n        for (i = 5; i >= 0; i--)\n            if (password[e_locations[i]] != 'e')\n            {\n                wrong_password();\n                goto goodbye;\n            }\n        if ( (password[6] ^ password[10]) == 0 )   // ^ means XOR\n            if ( (password[6] + password[10]) == 0x40 )\n                if ( ( *(password+0) & 0x0FFFFFF ) == 'duA' )\n                    if ( ( *(password+11) & 0x0FFFFFF ) == 'caF' )\n                        if ( ( *(password+8) & 0x0FFFF ) == 'ts' )\n                        {\n                            correct_password();\n                            goto goodbye\n                        }\n    }\n    wrong_password();\ngoodbye:\n}\n```", "```\nbp 004012b8\n```"]