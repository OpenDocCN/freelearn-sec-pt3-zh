- en: Operating System Interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While preparing to write this chapter, I remembered a real-time systems course
    in college. Not the whole course, of course, but one of the tasks we were given
    --one of the most interesting ones, if not the most interesting. We had to write
    a small program that would display a text string that should move from left to
    right and back again on the screen until a certain key was pressed on the keyboard.
    Two additional keys would make it possible to control the speed of the string's
    movement. It was 2001 or 2002, we were still using DOS for Assembly-related exercises
    and the task appeared to be quite simple.
  prefs: []
  type: TYPE_NORMAL
- en: I personally found it extremely boring to use DOS interrupts for this purpose
    (I had no idea of Occam's Razor principle at the time, besides, I wanted to look
    smart), so I decided not to use any OS at all. My laptop had a floppy drive, so
    the only thing I was missing was a program to write raw sectors to a floppy diskette,
    which I wrote myself (guess what programming language).
  prefs: []
  type: TYPE_NORMAL
- en: 'The program consisted of two parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Bootloader**: This was a tiny piece of code (it had to fit into a 512-bytes
    sector after compilation) responsible for one thing only --loading my program
    from a floppy and setting it up for running'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The program**: This is actually the program for displaying a moving string'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Having proper documentation was not a big deal to implement the whole package.
    However, I had to take care of things we usually do not deal with. One of them
    was a primitive video driver, which would have handled switching to graphic mode,
    displaying the string at the proper location, and switching back to the text mode
    before the program terminated. The other one was writing a primitive keyboard
    driver, basically an interrupt handler to listen to the keyboard and make proper
    adjustments to the speed of the string's movement, or tell the program to terminate.
    To put it simply, I had to interface hardware myself (oh, the good old times of
    the real mode... everything was so simple and so complicated).
  prefs: []
  type: TYPE_NORMAL
- en: In modern days, unless you are a driver developer, you are completely free from
    accessing hardware directly --the operating system does all the dirty work for
    us and we may concentrate purely on the implementation of our ideas.
  prefs: []
  type: TYPE_NORMAL
- en: We are able to implement any algorithm in Assembly language thus far, we may
    even, provided that we have proper documentation, write our own drivers, however,
    doing so only introduces redundant work when trying to write a user-space application.
    Not to mention the fact that there are already drivers for all your hardware provided
    by hardware vendors, and Occam's Razor principle tells us not to multiply things
    without need. Modern operating systems are good at managing these drivers and
    providing easier and seamless access to hardware, thus allowing us to concentrate
    on the process of creation.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will see how to easily and painlessly use the power given
    to us by the operating system and numerous libraries already created by others.
    We will begin by linking third-party object files to our code, proceed through
    importing API from DLL/SO and finish with dynamically loading DLL/SO, and importing
    the API at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: The rings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Almost all modern platforms, except a few embedded ones, utilize the same security
    principle --the division of execution environments by security levels and privileges;
    in this case, this means the ability to access certain resources. On Intel-based
    platforms, there are four security levels known as **protection rings**. These
    rings are numbered 0 through 3, where the greater the number, the less privileged
    the ring. Obviously, the code running at a less privileged level cannot access
    memory with a higher privilege level directly. We will shortly see how data is
    transferred between different privilege levels.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure illustrates the concept of protection rings:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3c5463ec-283d-475d-96bc-8c48ba85616b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here''s a description of the different privileges of protection rings:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ring 0** is the most privileged level where all instructions are available
    and all hardware is accessible. This is the grey area where the kernel resides,
    accompanied by kernel space drivers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ring 1** and **Ring 2** are intended to serve as the driver execution environment,
    but are hardly used at all.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ring 3** is the user space. It is the privilege level regular software is
    granted, and it is the only privilege level we are interested in. Although getting
    deeper may be very interesting, it would not be practical for the purpose of this
    book, as all our code requires privilege level 3 only.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: System call
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The user-space application is of no value if it cannot make service requests
    to the kernel, as it is not able to even terminate properly without asking the
    kernel to terminate the process it is running in. All system calls may be categorized
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Process control**: System calls that fall into this category are responsible
    for the creation of processes/threads and their management, as well as memory
    allocation/deallocation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**File management**: These system calls are responsible for file creation,
    deletion, and IO'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Device management**: This category contains system calls used for device
    administration/access'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Maintenance**: This category contains system calls for management of date,
    time, and files or device attributes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Communication**: Management of communication channels and remote devices'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: System call hardware interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'On the hardware level, the processor provides us with several ways to invoke
    a kernel procedure to handle a system call:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Through an interrupt** (**INT instruction on 32-bit systems**): The operating
    system allocates a descriptor for an interrupt with a specific number, which points
    to a procedure in the kernel space that handles the interrupt in accordance with
    its parameters (parameters are passed via registers). One of the parameters is
    the index into system call table (roughly speaking, the table of pointers to specific
    system call handlers).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Using the SYSENTER instruction** (**32-bit systems excluding WOW64 processes**):
    Beginning with Pentium II, we are able to use the `SYSENTER` instruction to perform
    fast calls to a ring 0 procedure. This instruction is accompanied by the `SYSEXIT`
    instruction, which returns from a system call.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Using the SYSCALL instruction** (**64-bit systems**): This instruction was
    introduced by the x86_64 architecture and is only available in the long mode.
    This instruction allows faster transfer to a system call handler and does not
    access the interrupt descriptor table.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Direct system calls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using one of the preceding instructions would mean making a direct system call
    and bypassing all system libraries as shown in the following figure. However,
    this is not the best practice and we will see why in a moment:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b0f706b6-aee1-4da5-a275-0dfc7bd9b6e0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Using the direct system call approach on Linux would, most likely, work, as
    Linux system calls are well documented and their numbers are well known (they
    may be found in `/usr/include/asm/unistd_32.h` for a 32-bit system and in `/usr/include/asm/unistd_64.h`
    for a 64-bit one), and those numbers do not tend to change. For example, the following
    code prints a `msg` string to the standard output on a 32-bit Linux system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is its 64-bit counterpart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'On Windows, however, despite the fact that the idea is the same, the implementation
    is different. To begin with, there is no publicly available official documentation
    of Windows system calls, which not only requires a certain portion of reverse
    engineering, but also gives no guarantee that the information found through reversing
    `ntdll.dll` would remain intact after the next update, not to mention the fact
    that system call numbers tend to change from version to version. However, for
    the sake of common education, here is the system call invocation procedure from
    the 32-bit `ntdll.dll`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, if the `SYSENTER` instruction is available, then we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Although the second variant is more promising, there is still no guarantee that
    the format of the parameter block would not change (though, this is not likely).
    In conclusion of this subsection, it is important to say that it is much advised
    not to make use of direct system calls unless absolutely necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Indirect system calls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A more common way of making use of system services is through supporting libraries,
    whether system DLLs on Windows or libc on Linux, which provide a more convenient
    API than the raw system call interface. The process is depicted in the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/60f5f7fc-944f-4945-82e6-3f5248525238.png)'
  prefs: []
  type: TYPE_IMG
- en: Although it may seem like another layer may introduce redundant complications,
    in reality, it is exactly the opposite, not to mention that in such cases our
    code would become much more portable.
  prefs: []
  type: TYPE_NORMAL
- en: Using libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As it has been stated earlier, the best way to interact with the operating system
    from a program written in Assembly is through the system API --system DLLs on
    Windows and libc on Linux, and the rest of the chapter is dedicated to this topic,
    as it will significantly make your life easier as an Assembly developer.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the chapter is dedicated to the use of external libraries and DLLs
    if on Windows, or external libraries and shared objects if on Linux. We will try
    to kill two rabbits in one shot, meaning that we will not only learn how to link
    DLLs or system lib files to our code, but we will also cover the linking of other
    object files with our code.
  prefs: []
  type: TYPE_NORMAL
- en: For the sake of an example, we will create a small program that prints a message
    to the standard output and uses the module we developed in [Chapter 8](22b2b820-0431-48f6-9ed2-8b9e0cded10a.xhtml),
    *Mixing Modules Written in Assembly and Those Written in High-Level Languages*,
    for the encryption and decryption of the message.
  prefs: []
  type: TYPE_NORMAL
- en: Windows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are two options for how to gain access to external functionality on Windows;
    one would be compiling our code to an object file and linking it against other
    object files or libraries, and the other would be creating executable and importing
    functions exported by different DLLs. We will examine them both so that you will
    be able to select the most suitable approach when the need arises.
  prefs: []
  type: TYPE_NORMAL
- en: Linking against object and/or library files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An object file is a file that contains billets of executable code and/or data.
    It cannot be executed by itself (even if it contains all the code for an executable),
    as the information stored in such files is only used by a linker when building
    the final executable; otherwise, all the code and data within the file is not
    bound to any address, and only hints are provided. Detailed information on the
    Microsoft object file format, as well as the PE executable format specifications,
    may be obtained at [http://www.microsoft.com/whdc/system/platform/firmware/PECOFF.mspx](http://www.microsoft.com/whdc/system/platform/firmware/PECOFF.mspx).
    Visit this URL, click on the Download button, and select `pecoff.docx`.
  prefs: []
  type: TYPE_NORMAL
- en: Object file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s get to business and write the code for our object file, `obj_win.asm`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we implement our code, let''s create the data section so that the code
    is easier to understand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The data section is quite self-explanatory and we are now ready to write the
    code at last:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Remember the `virtual` directive?
  prefs: []
  type: TYPE_NORMAL
- en: 'We, programmers, are sometimes lazy people and like things to be convenient,
    especially when it comes to reading our own code a week after it was written,
    therefore, we would prefer to address our cryptographic procedures by name, rather
    than by an offset from the address of the `crypto_functions` structure, and this
    is when the `virtual` directive comes in handy allowing us to label the location
    pointed by the EBX register as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The `funcs` is a virtual label that refers to the location pointed to by the
    `ebx` register, and it will be replaced with `ebx` in compile time. Any member
    of the `crypto_functions` structure referred by `funcs` will be replaced by its
    offset within the structure. Let''s now set up the crypto engine and encrypt and
    then decrypt the message stored at `buffer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Producing the executable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Compiling this source file will produce the `obj_win.obj` file, which we will
    link to `kernel32.lib` and `crypto_w32.obj`. But where do we find the `kernel32.lib`
    file? This task may not be such a simple one sometimes, although not a difficult
    one. All system libraries may be found at `c:\Program Files\Microsoft SDKs\Windows\vX.X\Lib`,
    where `vX.X` stands for the version (there will, most likely, be more than one).
    For 64-bit Windows, the directory would be `c:\Program Files (x86)\Microsoft SDKs\Windows\vX.X\Lib`.
    So, let''s copy the `crypto_w32.obj` file to our working directory and try to
    link it. Open the Developer Command Prompt for VS 2017 command window, as shown
    in the following screenshot, and navigate to your working directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2cd9e977-d93f-4e17-9c0c-f3b07218d2b1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Type the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you press enter, if all went well, the Microsoft (R) Incremental Linker
    logo message will appear in the console followed by a new prompt, and the `obj_win.exe`
    file will be generated. Try to run it and you should get this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Voila! We have just used external functionality in our Assembly code.
  prefs: []
  type: TYPE_NORMAL
- en: Importing procedures from DLL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Flat Assembler provides us with yet another option for using external functionality.
    While with other assemblers we need a linker in order to link against DLLs, Flat
    Assembler makes it possible to produce an executable with all the imports defined
    in source code, which allows us to simply compile the source code and run the
    executable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The process of runtime linking dynamic link libraries to our code is fairly
    simple and may be illustrated with the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2eae957f-1fab-4f41-8397-6ca6d6249f66.png)'
  prefs: []
  type: TYPE_IMG
- en: Once the loader has loaded an executable, it parses its import table (if present)
    and identifies the requested libraries (refer to `PECOFF.docx` for the import
    table format specifications). For each library reference found in the import section,
    the loader attempts to load the library, then parses the executable's import section
    for the names of procedures exported by the library in question, and scans the
    library's export section for a match. Once a matching entry is found, the loader
    calculates the virtual address of the entry and writes it back to the import section
    of the executable. This sequence is repeated for every imported entry of every
    requested library.
  prefs: []
  type: TYPE_NORMAL
- en: For our example, we will use the same code as with linking objects (just rename
    it to `dll_win.asm`) with just a few tiny modifications, and `crypto_w32.dll`
    instead of `crypto_w32.obj`. First of all, remove all the `extrn` and `public`
    declarations and then tell the assembler that this time we are expecting a console
    executable, rather than an object file, by changing `format MS COFF` to `format
    PE CONSOLE`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we will create our own import table, we need to include the `win32a.inc`
    file that contains all the macros we may need for our purpose. Add this line after
    the format declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We are almost there; append the following code to the source file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The last modification that we have to make is change `call GetPointers` to `call
    [GetPointers]`, as this time, the `GetPointers`; procedure will not be statically
    linked to our executable, but it will be imported from a dynamic link library,
    meaning that the `GetPointers` label will refer to an address in memory where
    the address of the `GerPointers` procedure will be stored.
  prefs: []
  type: TYPE_NORMAL
- en: Try to compile the file and run it in the console. You should get the same output
    as the one with the executable we linked from multiple objects.
  prefs: []
  type: TYPE_NORMAL
- en: If you get an error message saying that the executable failed to launch instead
    of the expected output, try adding the `section '.reloc' fixups data readable
    discardable` line to the `TARGET_W32_DLL` section of the `finalize` macro in the
    `platform.inc` file, and recompile `crypto_w32.dll`. This is correct for building
    a DLL in general, although it may work without this in certain circumstances.
  prefs: []
  type: TYPE_NORMAL
- en: It is, of course, possible to load DLLs manually with the `LoadLibrary()` Windows
    API, and resolve addresses of needed procedures with `GetProcAddress()`, but that
    does not differ from linking against a DLL or importing APIs, as we still do need
    to import these two APIs. There is, however, a method that allows us to import
    API addresses in the so-called stealthy way.
  prefs: []
  type: TYPE_NORMAL
- en: The exact same rules apply when it comes to building 64-bit executables. The
    only difference is the location of `kernel32.lib`, which will be `c:\Program Files\Microsoft
    SDKs\Windows\vX.X\Lib\x64`, and the size of pointers. Also, it is very important
    to remember that the calling convention used on x86_64 Windows is neither `cdecl`
    nor `stdcall`!
  prefs: []
  type: TYPE_NORMAL
- en: Linux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Linux, just like in Windows, we have the same support for both static and
    dynamic linking (and support for manual import too). The main difference is that
    in Linux (and this is my sole opinion), building software is much easier as all
    the development tools are integrated into the system. Well, except Flat Assembler,
    but its integration is not a problem --we simply copy the `fasm` executable to
    one of the `bin` directories that are included in the user's PATH environment
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately for us, Flat Assembler has built-in support for generation of both
    object files and executables, which imports procedures from libraries on Linux
    just as well as it supports such methods on Windows. We will shortly see that
    these approaches on Linux are almost identical to those on Windows, as long as
    we do not start diving into the depth of the ELF specifications and format.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to explore the ELF format in-depth, specifications are available
    at
  prefs: []
  type: TYPE_NORMAL
- en: '[http://refspecs.linuxbase.org/elf/elf.pdf](http://refspecs.linuxbase.org/elf/elf.pdf)
    for specifications of 32-bit ELF'
  prefs: []
  type: TYPE_NORMAL
- en: and
  prefs: []
  type: TYPE_NORMAL
- en: '[http://ftp.openwatcom.org/devel/docs/elf-64-gen.pdf](http://ftp.openwatcom.org/devel/docs/elf-64-gen.pdf)
    for specifications of 64-bit ELF.'
  prefs: []
  type: TYPE_NORMAL
- en: You may also find these specifications with Google or any other search engine,
    if these links appear broken.
  prefs: []
  type: TYPE_NORMAL
- en: Just like we did in the case of Windows, we will begin by linking several object
    files to a single executable and then proceed to create an executable ELF file
    with dynamic dependency linking.
  prefs: []
  type: TYPE_NORMAL
- en: Linking against object and/or library files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The structure of the **Microsoft Common Object File Format** (**MS COFF**) and
    that of **ELF** (**Executable and Linkable Format**, previously known as **Extensible
    Linking Format**) are very different, but for us, this difference does not matter
    at all. The ELF was developed by UNIX System Laboratories and was published in
    1997\. It was later selected as a portable object file format for the 32-bit Intel
    architecture. As of today, there is ELF for 32-bit systems and ELF64 for 64-bit
    systems.
  prefs: []
  type: TYPE_NORMAL
- en: From our perspective, however, the code for Linux is very similar to the code
    for Windows. To be more precise, FASM is what makes it quite similar.
  prefs: []
  type: TYPE_NORMAL
- en: Object file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Just as with the object file source code for Windows, as always we will begin
    by telling the assembler what kind of output we are expecting, which procedures
    are public, and which are external:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we proceed with convenience macro definition, and the suggestion is to
    put convenience macros into a separate include file so that they may be painlessly
    used with different code without the need to rewrite them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The data section is almost the same as in the case of the object file for Windows,
    except that we do not need a variable to hold the `stdout` handle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'And, at last, the code section. It is logically the same code with the only
    difference being the use of `printf()` instead of `WriteConsoleA()`, in which
    case the `printf()` implementation in `libc` will make all the arrangements and
    invoke a `SYS_write` Linux system call for us. As we are, from GCC''s point of
    view, only implementing the `main()` function, we do not have to terminate the
    process ourselves, hence there is no `exit()` procedure imported --the runtime
    code is automatically added and linked, and GCC will do all the rest, while we
    simply return from `main()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Producing the executable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Save the file as `o_lin.asm` and compile it into an object file with the `fasm
    o_lin.asm` command in the terminal. The next step will be linking `o_lin.o` with
    `crypto_32.o` with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This will result in a `5KB o_lin` executable --quite a heavy one in relation
    to the size of code we used to produce. Such a huge size is due to the GCC linking
    C runtime into it. Try to run it and you should see this in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5c3fb30f-da46-4445-887c-ef4b73369ebd.png)'
  prefs: []
  type: TYPE_IMG
- en: Dynamic linking of ELF
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is not always suitable to statically link object files into a single executable,
    and Linux provides us with a mechanism to produce an ELF executable that would
    be linked with the required libraries (shared objects) dynamically at runtime.
    The Flat Assembler used to have relatively basic support for ELF, meaning one
    could only create an executable that would use system calls directly, or create
    an object file to be linked with others (exactly in the manner we did).
  prefs: []
  type: TYPE_NORMAL
- en: 'Flat Assembler''s support for ELF was extended with the release of version
    1.69.05 --a few segment attributes were added along with several convenience macros,
    which let us manually create the import table in an ELF executable. These macros
    are in the Linux package under the `examples/elfexe/dynamic` directory (underlined
    in the following screenshot):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f7556984-e5eb-47a7-8eb2-a385a7f3fe85.png)'
  prefs: []
  type: TYPE_IMG
- en: These macros may be found under the `linux_include` folder in the accompanying
    code for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code for dynamically linked ELF is almost the same as for an ELF object
    file, with a few tiny differences. First of all, the `formatter` directive must
    tell the assembler to produce an executable, rather than an object file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The convenience structures we used in this chapter (`crypto_functions` and
    `string`) are still intact and should be placed in the file too. There is no strict
    definition as to where they should be placed exactly, but they should appear before
    they are used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'A new segment is introduced in order to improve the Flat Assembler''s ELF support;
    one is the **interpreter** that contains the name of the loader to be used with
    the executable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Another one is **dynamic** and serves as an import index. However, we are not
    going to declare this segment ourselves; instead, we will use two macros --one
    of them will create a list of the needed libraries and the other specifies procedures
    to be imported. In our case, it will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The rest of the code has only a few changes. First of all, the code section
    is declared as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This time all procedures are called indirectly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The last two instructions we replace the two lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Save the file as `so_lin.asm`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you may build and run the newly created executable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'If everything is done right, then you should see this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/65a7ca6e-06f1-4dfe-b7c9-828005ecb106.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you got acquainted with system calls --an operating system's
    service gateway. You learned that it is much more practical and convenient to
    use existing libraries in order to invoke system calls indirectly, and in a much
    more convenient and secure way.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter was intentionally left without 64-bit examples, as I would like
    you to try and write 64-bit versions of these simple executables yourself as a
    small exercise to test yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Now we are masters. We have a firm base and are able to implement any algorithm
    in pure Intel Assembly, and we are even able to invoke system calls directly (on
    Linux at least, as it is strongly discouraged on Windows). However, as real masters,
    we know that there is much more to learn and explore, as a base alone is not enough.
  prefs: []
  type: TYPE_NORMAL
