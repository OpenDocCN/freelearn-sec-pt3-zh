<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Deep Packet Inspection</h1>
                </header>
            
            <article>
                
<p><strong>Deep Packet Inspection</strong> (<strong>DPI</strong>) become popular when the Edward Snowden leaks about data collection by the government came out. It has gone from just another buzzword to making headlines. In this chapter, we will look at various traits of protocols and packets that aid DPI.</p>
<p>We will be specifically looking at the following topics:</p>
<ul>
<li>Analysis of multiple protocols</li>
<li>Packet encapsulation and packet analysis</li>
</ul>
<p>So, why are we learning DPI? Well, DPI is the process of looking beyond the generic TCP/IP headers and involves analyzing the payload itself.</p>
<p>Devices with DPI capabilities can analyze, evaluate, and perform actions from layer 2 to the application layer itself. This means that the devices with DPI capabilities are not only reliant on the header information but also check what is being sent as the data part. Hence, the overall tradition of network analysis is now changing.</p>
<p>DPI is widely used in the following fields and services:</p>
<ul>
<li><strong>Traffic shapers</strong>: Blocking malicious traffic/limiting traffic.</li>
<li><strong>Service assurance</strong>: Network admins can ensure that high-priority traffic is carefully dealt with and services do not go down for them.</li>
<li><strong>Identification </strong><strong>of </strong><strong>fake </strong><strong>applications</strong>: Applications that make use of non-standard ports to leverage standard protocol data are easily identified with DPI.</li>
<li><strong>Malware Detection</strong>: Since DPI allows viewing the payload itself, malware detection is much easier to perform.</li>
<li><strong>Intrusion detection</strong>: Not only malware, but also the DPI-enabled system can uncover hack attempts and exploit attempts, backdoors, and much more.</li>
<li><strong>Data Leakage Prevention (DLP)</strong>: With DPI, we can identify critical data traveling out of the network as well, making it an ideal choice for DLP systems.</li>
</ul>
<p>Before diving deep, let's understand the encapsulation of protocols on the different layers of communication.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>To complete exercises performed in this chapter, you will require the following software's:</p>
<ul>
<li>Wireshark v3.0.0 (<a href="https://www.wireshark.org/download.html">https://www.wireshark.org/download.html</a>) installed on Windows 10 OS / Ubuntu 14.04</li>
<li>Notepad++ 7.5.9 (<a href="https://notepad-plus-plus.org/download/v7.6.4.html">https://notepad-plus-plus.org/download/v7.6.4.html</a>)</li>
<li>Download PCAP files for this chapter from <a href="https://github.com/nipunjaswal/networkforensics/tree/master/Ch3">https://github.com/nipunjaswal/networkforensics/tree/master/Ch3</a></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Protocol encapsulation</h1>
                </header>
            
            <article>
                
<p>Before moving forward, let's look at how the packets are made and what sort of information they carry. Understanding a network packet will not only allow us to gain knowledge, but will also help to hone our network forensics skills. In layman's terms, we can say that a network packet is merely data put together to be transferred from one endpoint/host to another. However, in the depths of a network, an IP packet looks similar to the following:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/fda06dde-e116-47e4-9024-62fb1cf47f22.png"/></div>
<p>From the very first raw data on the wire, to becoming an Ethernet frame, to the IP packet, and further, to the TCP and UDP type, and finally, becoming the application data, the information is encapsulated through various layers. Let's see an example of packet encapsulation:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/217bb7cc-0063-4863-8fb6-0a341f3d4a5f.png"/></div>
<p>From the preceding example, we can see that on the wire, the packet was only a mere frame that encapsulated Ethernet information containing MAC addresses of both source and destination. The IP header is merely responsible for sending a packet from one endpoint to another, while the TCP header keeps a note of communication between the two endpoints. Finally, we have the data, which is nothing but our layer 7 data, such as HTTP and FTP. We will have a brief look at the IP header structure in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Internet Protocol header</h1>
                </header>
            
            <article>
                
<p>As we mentioned the IP header previously, let's see an example of IPv4 packet and break it down in the form of its fields:</p>
<ul>
<li><strong>Version</strong>: The version contains the format of the IP packet.</li>
<li><strong>IP Header Length (IHL)</strong>: Length of the IP packet header. There are generally count of 32-bit words in the packet.</li>
</ul>
<ul>
<li><strong>Differentiated Services Code Point (DCSP)</strong>: Previously called the TOS, this is usually used for real-time communications.</li>
<li><strong>Explicit Congestion Notification (ECN)</strong>: Congestion can be detected through this field.</li>
<li><strong>Total Length</strong>: The complete length of the packet, including the data and header.</li>
<li><strong>Identification</strong>: For unique packet identification, however if fragmentation occurs, this value will be the same for all fragments</li>
<li><strong>Flags</strong>: The flags usually indicate whether the router is allowed to fragment the packets.</li>
<li><strong>Fragmentation Offset</strong>: In cases where the fragmentation occurs, this field is used to indicate offset from the start of the datagram itself.</li>
<li><strong>Time To Live (TTL)</strong>: The number of devices the packet hops to before it expires.</li>
<li><strong>Protocol</strong>: The meat of the packet that describes what protocol is encapsulated within, for example, TCP or UDP or other transport layer protocols.</li>
<li><strong>Header Checksum</strong>: Used for error-detection purposes.</li>
<li><strong>Source Address</strong>: Packet sender.</li>
<li><strong>Destination Address</strong>: Destination of the packet.</li>
<li><strong>Options</strong>: Extra options. Variable length.</li>
<li><strong>Padding</strong>: Adds extra bits to make the packet length a multiple of 32 bits.</li>
</ul>
<p>Let's expand the IP header part of the packet to see these packet values:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/49866b08-4356-4415-82d8-7a456b5239df.png" style="width:41.33em;height:22.67em;"/></div>
<p>We can see all the mentioned fields in the IP header for the packet. Throughout our network forensics investigation, we will make use of them from time to time. Let's look at the next layer of encapsulation, which is the TCP header.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Transmission Control Protocol header</h1>
                </header>
            
            <article>
                
<p>Following our discussion on the IP header for the packet, we captured in Wireshark. Let's check out the TCP header:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/22dad0d5-fbb4-4f82-9b43-8d462b8d6350.png" style="width:41.08em;height:20.75em;"/></p>
<p>We can see that the TCP header contains the following sections:</p>
<ul>
<li><strong>Source Port</strong>: The port that generates the packet.</li>
<li><strong>Destination Port</strong>: The port at which the data is addressed for a particular host.</li>
<li><strong>Sequence number</strong>: The first data byte position.</li>
<li><strong>Acknowledge number</strong>: The next data byte the receiving host is expecting.</li>
<li><strong>Header Length</strong>: The length of the Transport layer header in 32-bit words.</li>
<li><strong>Flags</strong>: The control bit field has the following types of values:
<ul>
<li><strong>URG</strong>: Prioritize data</li>
<li><strong>ACK</strong>: Acknowledge received packet</li>
<li><strong>PSH</strong>: Immediately push data</li>
<li><strong>RST</strong>: Abort a connection</li>
<li><strong>SYN</strong>: Initiate a connection</li>
<li><strong>FIN</strong>: Close a connection</li>
</ul>
</li>
</ul>
<ul>
<li style="list-style-type: none">
<ul>
<li><strong>NS ECN-nonce - concealment protection</strong></li>
<li><strong>Congestion Window Reduced</strong> (<strong>CWR</strong>)</li>
<li><strong>ECE ECN</strong>: Echo either indicates that the peer can use ECN (if the SYN flag is set); otherwise, indicates that there is network congestion</li>
</ul>
</li>
<li><strong>Window</strong>: The size/amount of data that can be accepted.</li>
<li><strong>Checksum</strong>: Used for finding errors while checking the header, data and pseudo-header</li>
<li><strong>Urgent pointer</strong>: The pointer to the end of the urgent data.</li>
<li><strong>Options</strong>: Additional options.</li>
<li><strong>Padding</strong>: For size-matching by padding the header.</li>
</ul>
<p>Moving further down the packet encapsulation, we can see that we have the TCP payload that contains the HTTP packet:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/8c2191e6-7d9e-49c5-8849-37d416c27415.png" style="width:41.42em;height:16.25em;"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The HTTP packet</h1>
                </header>
            
            <article>
                
<p>The HTTP packet includes the following:</p>
<ul>
<li><strong>Request Line</strong>: Contains the <kbd>GET</kbd>/<kbd>POST</kbd> request type or other HTTP options followed by the requested resource, which is <kbd>cloudquery.php</kbd> in our case, supported by HTTP/1.1, which is the version of the HTTP protocol.</li>
<li><strong>Request Message Headers</strong>: This section contains all the header information, such as general headers, request headers, and entity headers.</li>
<li><strong>Message Body</strong>: The sent data to the endpoint, such as files, parameters, and images, is placed here.</li>
</ul>
<p>In our case, we can see that the data is a <kbd>POST</kbd> request type that posts data to the <kbd>cloudquery.php</kbd> page on the <kbd>54.255.213.29</kbd> IP address. We can also see that the data posted contains some file data. We can see the message body:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/f50205a0-404a-4645-94d9-155607620cfa.png"/></div>
<p>We can see that the data being sent looks gibberish. We will see more on the decryption, decoding, and decompression of data in the upcoming chapters.</p>
<p>So far, we saw how a frame on the wire encapsulated a variety of data meant for the various layers of the TCP/IP model. We also saw how a frame jolted down right to the HTTP request that contained some encrypted data. Let's move further and figure out what is sometimes referred to as <strong>unknown protocols</strong> and how to make them recognizable in Wireshark.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Analyzing packets on TCP</h1>
                </header>
            
            <article>
                
<p>The reason of the world moving majorly onto the techniques such as DPI is the recognition of protocols on a non-standard port as well. Consider a scenario where an FTP server is listening on port <kbd>10008</kbd>, which is a non-standard FTP port, or where an attacker infiltrated the network and is using port <kbd>443</kbd> to listen to FTP packets. How would you recognize that the HTTP port is used for FTP services? DPI allows that and discovers what lies inside the packet rather than just identifying the type of service based on the port numbers. Let's see an example of a capture file:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/08182eea-691f-4628-8f3d-6f619a83ba63.png"/></div>
<p>From the preceding screenshot, we cannot exactly figure out the type of application layer the TCP packets are referring to. However, if we look closely in the data of the packet, to our surprise, we have the following:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/5d5c00ea-b5af-43ee-a524-5e75be5f22a2.png" style="width:40.92em;height:9.25em;"/></div>
<p>We can see that the decoded data contains a list of FTP commands. This means that the protocol is FTP, but the reason for Wireshark not decoding the protocol is again the same reason some firewalls and traffic analyzers make use of port numbers to identify protocols rather than looking inside and finding what matters the most, and that is the sole reason DPI is required. However, let's look at ways we can decode what's being sent and try to decode it back to FTP:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1088 image-border" src="assets/25d899b8-3d93-42c1-9d64-91c39fb196fa.png" style="width:99.08em;height:29.33em;"/></div>
<p>Let's try following the TCP stream by right-clicking a packet and checking out the TCP stream:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/9314af6d-85df-4bc0-a5f5-0f0b64a8424f.png"/></div>
<p>We can see that the TCP stream displays various types of FTP details, such as commands issued. However, this is not what we need. We need a mechanism to force Wireshark into decoding this data once and for all. Let's have another look at the packet:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1089 image-border" src="assets/9060a1e3-6f07-4b98-86cd-282e3c98087b.png" style="width:102.42em;height:34.50em;"/></div>
<p>We can see that the source port is <kbd>10008</kbd> for the data that originated from the FTP server. Let's quickly note that down. Next, we need to decode this into FTP; we can use the <span class="packt_screen">Decode As...</span>, a feature of Wireshark:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/70865590-b83c-4f0d-be4c-929a9e173a13.png" style="width:46.42em;height:30.67em;"/></div>
<p>As soon as we press the <strong>Decode as...</strong> button, we get the following popup on the screen:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/1afbcaec-1986-4590-a2f6-b76ee93179c2.png" style="width:50.33em;height:16.75em;"/></div>
<p>Let's click on the <strong>+</strong> button, which will populate the following entry:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/9e037eab-4544-4a90-9de2-3632c8619b51.png" style="width:50.67em;height:16.50em;"/></div>
<p>Since the originating port was <kbd>10008</kbd>, let's modify the value to <kbd>10008</kbd> from <kbd>55695</kbd> and <strong>Current</strong> to <strong>FTP</strong>, as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/6335a297-c30a-4415-bb76-defffac60bd9.png" style="width:62.17em;height:21.92em;"/></div>
<p>Let's press the <strong>OK</strong> button to see changes to the packets:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/5d41a3d4-dd2d-4024-b6d3-531529d53384.png"/></div>
<p>Wow! We can see the FTP data now. We just saw that we can recognize a protocol that is running on non-standard ports.</p>
<p>We saw how the TCP packet works and also saw its applications, such as HTTP and FTP. Let's jump into the UDP packet and take the most common application of it, which is DNS. I know some might argue that DNS makes use of both TCP and UDP at times, like zone transfers. However, for most of its operations, such as resolving queries, DNS makes use of UDP packets only.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Analyzing packets on UDP</h1>
                </header>
            
            <article>
                
<p>The <strong>user datagram protocol</strong> (<strong>UDP</strong>) is used primarily for real-time communications and in situations where speed matters. The UDP header size is 8 bytes compared to 20 in TCP. A UDP packet does not have segment acknowledgment and is usually much faster, since it is a connectionless protocol. Also, error checking is still a part of UDP, but no reporting of errors takes place. A common example of UDP is <strong>Voice over Internet Protocol</strong> (<strong>VoIP</strong>). Comparing to the structure we discussed in the very beginning of the chapter, we have the following structure for UDP:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/eabc6ec9-495c-4102-a41d-ba0e8ee9a062.png"/></div>
<p>We can see that we have so many fields reduced and primarily have only the <strong>Source Port</strong>, <strong>Destination Port</strong>, <strong>Length</strong>, and <strong>Checksum</strong> fields. Let's validate this by analyzing a UDP packet in Wireshark:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/30ebf07c-b4e0-4f74-a78d-8dc910f0371c.png"/></div>
<p>We can see that we have certain fields as mentioned in the preceding diagram. Additionally, we can see that we have DNS data, which is nothing but the data field as mentioned in the diagram. Let's see what details we have on expanding the DNS field:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/75fbbd4b-c30a-4003-8647-a10ff679a22a.png"/></div>
<p>We can see that the raw data was decoded by Wireshark to reveal <strong>Transaction ID</strong>, <strong>Questions</strong>, <strong>Answers</strong>, and other details:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/fa065a8a-0b48-457c-9673-ac624377ccb2.png" style="width:38.75em;height:27.58em;"/></div>
<p>We can see that in the queries section, we also have the domain and subdomain values, record type, and addresses. You can see that pointing to any of the preceding fields will highlight the raw data segment:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/e036e94e-777d-498a-9fd9-ddbbab0f470e.png" style="width:39.17em;height:15.08em;"/></div>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Understanding each raw data packet can also help us to develop PCAP readers and custom network analyzers. Hence, let's build some filters based on the following data fields:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/efcfbb84-e98f-4d85-9e3d-7a735d1f8c41.png"/></div>
<p>We saw a field called the DNS transaction ID. We can make use of it by coupling DNS and ID together while equating the value to <kbd>0x2581.</kbd> The filter would be as follows:</p>
<pre><strong>dns.id ==0x2581</strong> </pre>
<p>Using the filter, we will have the unique packets for the transaction, as we can see that we have a DNS standard query and its associated response. Wireshark allows us to perform a variety of filtering operations on the DNS and other protocols by interpreting raw fields:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1090 image-border" src="assets/c488c772-2266-4b4f-b77b-da07e5f60fb6.png" style="font-size: 1em;width:130.83em;height:77.67em;"/></div>
<p>Let's see an example of how DNS queries work and then figure out their corresponding response times in the next example by actually going ahead and capturing packets on our internet connected wireless interface. Additionally, we will only capture packets on port <kbd>53</kbd> to analyze the DNS queries and responses as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/3cae3697-4e0d-4ef4-8e28-7ac2276c8f91.png" style="width:32.33em;height:17.50em;"/></div>
<p>We use a capture filter that will only capture packets from port <kbd>53</kbd>. Let's double-click the Wi-Fi interface and start capturing:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/d833da11-a740-42fc-b183-5750e64b73c5.png"/></div>
<p>We can see that the data has started flowing in. Let's open some websites and set the flags filter to <kbd>0x8180</kbd> by placing the <kbd>dns.flags == 0x8180</kbd> display filter. The value <kbd>0x8180</kbd> denotes a standard DNS response. Let's see the result as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/7f1f99ac-ece4-4797-a907-029dc1b785cd.png"/></div>
<p>Wireshark only displays standard DNS response packets. Let's analyze their response times as well. We can see that every packet has the response time associated with it:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/6f51504e-14fc-4cd8-a190-92429f097508.png"/></div>
<p class="mce-root"/>
<p>Let's right-click the time field and choose <strong>Apply as Column</strong>:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/24a21a78-50ba-40fc-b6c7-57c4e2e5247c.png"/></div>
<p>We can now see that another field got added to the packet list:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1091 image-border" src="assets/ea9619cd-2452-4c8e-a6ef-6a9fdb720528.png" style="width:87.08em;height:34.83em;"/></div>
<p>We have a new column, <strong>Time</strong>, added to it. However, the entry's name is redundant with time. Let's change it by right-clicking and selecting <span class="packt_screen">Edit Column</span>:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/debfb5dc-768f-4f07-8848-edd365ae2a1f.png"/></div>
<p>We can now rename the field <kbd>Response Time</kbd>:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1092 image-border" src="assets/00bedfc3-e8e0-43a2-90f9-211de10dab4b.png" style="width:76.17em;height:4.83em;"/></div>
<p>Let's check out the packet list:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/8a62e2da-e9a4-4c3f-8041-866679aeee0f.png"/></div>
<p>We can now see that we have response times for all the DNS response packets. However, we can also see that some of the packets do not have this value, and this is where the DNS response has been received twice. You might be wondering why we are discussing this in a network forensics book. It's because having a brief knowledge of these packets will help us understand the complex examples in the upcoming chapters. We are still in the learning phase, and in the next few chapters, everything we learn here will start to make sense. So, let's continue and see only those packets that have been retransmitted using the <kbd>dns.retransmit_response</kbd> filter:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/328b2d59-e7ce-4a59-a712-232fabf972f2.png"/></div>
<p>We can now only see retransmitted responses. We can also filter all the queries based on the query names; let's filter out all the queries related to <kbd>google.com</kbd>. We can set up a filter, such as <kbd>dns.qry.name contains "google.com"</kbd>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/44ff94c7-8ad9-4b99-8137-10705a595dc9.png"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Analyzing packets on ICMP</h1>
                </header>
            
            <article>
                
<p>Let's take a look at the <strong>Internet Control Message Protocol</strong> (<strong>ICM</strong><strong>P</strong>). It is one of the most popular protocols, and is better known for being used in ping commands, which is where an ICMP echo request is sent to an IP address with some random data, and it then denotes whether the system is alive. A typical ICMP packet would look like this:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/a91bcd44-6b90-4d25-bda9-583c08e1a85f.png"/></div>
<p>The ICMP has many messages, which are identified by the <strong>Type of Message</strong> field. The <strong>Code</strong> field indicates the type of message. The <strong>Identifier</strong> and <strong>Sequence Number</strong> can be used by the client to match the reply with the request that caused the reply.</p>
<p>The <strong>Data</strong> field may contain a random string or a timestamp to compute the round-trip time in a stateless manner. Let's ping <a href="https://www.google.com/">https://www.google.com/</a> and analyze it in Wireshark:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/98c59ec6-89ac-4bb0-b5ab-1159ed7a1d38.png"/></div>
<p>We can see that we have four Echo request and four Echo reply packets. Let's see the request first:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/d0b37d3b-c38d-4a74-bed4-caf7346224fc.png"/></div>
<p>The request is of the Echo type and is denoted by the number 8, and the code is 0.</p>
<div class="packt_infobox">Check out the ICMP type and codes at <a href="https://www.iana.org/assignments/icmp-parameters/icmp-parameters.xhtml#icmp-parameters-codes-8">https://www.iana.org/assignments/icmp-parameters/icmp-parameters.xhtml#icmp-parameters-codes-8</a><span class="URLPACKT">.</span></div>
<p>We can also see that the data starts with <kbd>09b</kbd> and goes up to 48 bytes. Since we are pinging Google, if it's up, it will reply with the same data back to us. Let's see the response:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/be29763a-a1ea-4d7a-962a-32c24ffdd8e3.png"/></div>
<p>We can see that the data was sent back as is, which denotes that the system is up. Also, we can see that the <strong>Identifier</strong> and <strong>Sequence number</strong> are similar to the one in the request. The <strong>Type</strong> for the <strong>Echo reply</strong> is denoted by <strong>0</strong> and the code also remains zero. Let's see what happens when the IP is not reachable:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/dc1f9f48-b9b2-4078-a465-6e4bff975db5.png" style="width:30.08em;height:11.25em;"/></div>
<p>The preceding <kbd>ping</kbd> command denotes that there was a 100% loss of packets; let's see Wireshark:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/25cb726f-c673-4014-86df-592b21a78dec.png"/></div>
<p>We can see that Wireshark has not seen any response. Hence, it marked it as no response found.</p>
<p>So far, we have covered the basics of the TCP, UDP, and ICMP protocols. Let's see a case study and analyze the involved PCAP evidence file in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Case study – ICMP Flood or something else</h1>
                </header>
            
            <article>
                
<p>Imagine you are a network forensics expert who has been tasked with analyzing the PCAP file. As soon as you open the file in Wireshark, you are presented with the following:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/02f4ec43-deaa-4ac4-958c-e349f8c8341f.png"/></div>
<p>What we can see from the capture file is that it contains a ton of ICMP packets traveling to and from <kbd>192.168.153.129</kbd> and <kbd>192.168.153.130</kbd>. We quickly added a new column by right-clicking the column header in Wireshark and choosing <strong>Column Preferences</strong> and adding a new column by clicking the <strong>+</strong> button and choosing its type as <strong>UTC</strong> for the UTC time, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/5dd5631a-3d36-4953-b150-6067da5a8f39.png"/></div>
<p>Next, we go to the <strong>Statistics</strong> tab and choose <span class="packt_screen">Capture File Properties</span>:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/8cd5fffe-037f-4d4c-9e97-0c591645326e.png"/></div>
<p>The preceding option will populate the following window:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/22e7c625-7e67-481b-af05-3b0f98ca7136.png"/></div>
<p>We can see a good amount of detail related to the capture file, such as the date and time of the first packet, last packet, duration, average packets per second, and the number of packets captured. When we populate the <strong>Endpoints</strong> tab, we can see the following:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/eb9ece5b-5505-4a11-a368-2e93db1ae257.png"/></p>
<p>We can quickly determine that the <kbd>192.168.153.129</kbd> and <kbd>192.168.153.130</kbd> IP addresses are communicating. We can confirm this by opening the <strong>Conversations</strong> tab:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/6524c7ab-837c-4470-b198-21170fe1e7d4.png"/></div>
<p>We can see that both IPs are communicating. However, the strange thing is that the only traffic exchanged between these two is ICMP traffic. Using the filter as <kbd>icmp.type == 8</kbd> displays that there are 510 ICMP echo requests sent from <kbd>192.168.153.129</kbd> to <kbd>192.168.153.130</kbd>:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/087a01d1-8208-47ce-8da6-10d53e5abad7.png"/></div>
<p>Let's see the number of replies by setting the <kbd>icmp.type == 0</kbd> as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/25a09d8e-7019-4172-9cc6-c9a9c655b104.png"/></div>
<p>We can see that the number of replies is almost equal to the number of requests—Strange! Someone would never send out that amount of ping requests intentionally—unless they are conducting a DOS attack. However, carrying out a <strong>ping of death</strong> or Ping DoS will require a significantly higher number of packets.</p>
<div class="packt_infobox">A ping DoS would require more packets, but a ping of death might only require one on a vulnerable system.</div>
<p><span>There is something wrong with this. </span>Let's investigate the packets:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/8effb7a0-90f2-4bc4-be71-eb6ee6f93cef.png"/></div>
<p>Everything seems fine until we reach packet number 149, to which no response was received from the target. The next packet, number 150, contains something of interest:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/6181fee4-1751-43ce-9754-759eda0daa22.png"/></div>
<p>Packet 150 contains <kbd>ipconfig</kbd> in the data segment. Hmm.. this is awkward! Let's investigate further:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/83c02494-1079-4160-b08d-3541665709d4.png"/></div>
<p>Packet number 179 has a system path in it. This is going south! The found traces denote that someone is accessing this system using an ICMP shell. The ICMP shell is a backdoor that makes use of data fields to send replies to a command sent by the attacker. Since all the requests originated from <kbd>192.168.153.129</kbd>, we have our attacker. We can also see another strange thing: The ICMP packets are missing data fields, apart from the packets' ICMP backdoor packets. This gives us an edge to only focus on the packets having data, for this, we can type data as the filter:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/5febb9d6-f425-4df4-a994-b3bee70bb428.png"/></div>
<p>We can see that we are only left with 17 packets out of 1,087, which can be easily traversed using Tshark. Tshark is the command-line wireless equivalent and is way better for people who love the command line. We will make use of PowerShell to run Tshark in Windows, as follows:</p>
<pre><strong>.\tshark.exe  -Y data -r C:\Users\Apex\Desktop\Wire\icmp_camp.pcapng -T fields -e data</strong>  </pre>
<p>The preceding command runs Tshark with the <kbd>-Y</kbd> switch as data, which denotes the filter, <kbd>-r</kbd> as the path of the capture file; the <kbd>-T</kbd> fields denotes the field types to print, and <kbd>-e</kbd> denotes which fields will be printed. Additionally, more details on these optional switches can be found using <kbd>man tshark</kbd> or <kbd>tshark –help</kbd> command in Windows. Now, let's run this command as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/006447da-e302-469d-b5c9-bff9dca2267f.png"/></div>
<p>We can see that we have all the data from the 17 packets in hex. Let's copy this data into Notepad++:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/d50addc3-b31c-4b34-a613-fd3e6731a0ec.png"/></div>
<p>Notepad++ contains pre-installed plugins to convert hex into ASCII. Let's browse to the <strong>Plugins</strong> tab and choose <strong>Converter</strong> | <strong>Hex -&gt; ASCII</strong>:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/188e9354-1c7f-4d68-b393-a10f9d6cd0bc.png"/></div>
<p>As soon as we press the <strong>Hex -&gt; ASCII</strong> option, we will have the following:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/e6df6e9a-37e3-4c4c-a497-bde602e56914.png" style="width:32.67em;height:31.25em;"/></div>
<p>God! Someone was running commands on the system; they ran <kbd>ipconfig</kbd> followed by the <kbd>whoami</kbd> command.</p>
<p>In this exercise, we saw how innocent-looking ICMP packets were used to access a compromised system. However, throughout this exercise, we learned how to do a few things: We investigated ICMP packets, found some malicious activity, gathered and clubbed data from the various packets into a single file, and decoded them from hex into ASCII to reveal the intentions of the attacker and the activities that they performed on the target. We also identified that the backdoor was making use of the ICMP protocol to conduct command and control, and we looked at using Tshark for the very first time.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>We covered some serious theory in this chapter. We started by looking at the IP and TCP protocol headers, and we analyzed the HTTP protocol. We then analyzed the FTP protocol, and the UDP-oriented DNS service. We looked at the ICMP protocol and saw a case study where ICMP was being used for command and control. Throughout this chapter, we learned new and advanced concepts to analyze various packets and protocols. In the next chapter, we will look at statistical flow analysis, and we will learn how it can help us conduct an efficient network forensic exercise.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Questions and exercises</h1>
                </header>
            
            <article>
                
<p>To enhance your network forensics skills on various protocols and packets, try answering/solving the following exercises and problems:</p>
<ul>
<li>Refer to the case study on ICMP. Try a similar exercise for DNS by analyzing <kbd>dns-shell</kbd> (<a href="https://github.com/sensepost/DNS-Shell">https://github.com/sensepost/DNS-Shell</a>).</li>
<li>Study at least five different packet structures including IPv6, TLS, NTP, and many others.</li>
<li>Write a small Bash script in Linux to convert hexadecimal characters to ASCII.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<p>To learn more about DPI, check out <a href="https://is.muni.cz/th/ql57c/dp-svoboda.pdf">https://is.muni.cz/th/ql57c/dp-svoboda.pdf</a><span class="URLPACKT">.</span></p>


            </article>

            
        </section>
    </body></html>