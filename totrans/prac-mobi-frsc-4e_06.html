<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">iOS Data Analysis and Recovery</h1>
                </header>
            
            <article>
                
<p>A key aspect of iOS-device forensics is to examine and analyze the data acquired to interpret the evidence. In the previous chapters, you learned various techniques to acquire data from iOS devices. Any type of acquired image contains hundreds of data files that are often parsed by the tools described in earlier chapters. Even when the data is parsed by the forensic tool, a manual analysis may be required to uncover additional artifacts or to simply validate your findings.</p>
<p>This chapter will help you understand how data is stored on iOS devices, and it will walk you through the key artifacts that should be examined in each investigation to recover the most data possible.</p>
<p>In this chapter, we will be covering the following topics:</p>
<ul>
<li><span>Interpreting iOS timestamps</span></li>
<li>Working with SQLite databases</li>
<li>Key artifacts – important iOS database files</li>
<li>Property lists</li>
<li>Other important files</li>
<li>Recovering deleted SQLite records</li>
</ul>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Interpreting iOS timestamps</h1>
                </header>
            
            <article>
                
<p>Before examining the data, it is important to understand different timestamp formats that are used on iOS devices. Timestamps found on iOS devices are presented either in the <em>Unix timestamp</em> or <em>Mac absolute</em> <em>time</em> format. You, as the examiner, must ensure that the tools properly convert the timestamps. Access to the raw SQLite files will allow you to verify these timestamps manually. You'll learn how to decode each timestamp format in the next few sections.<a href="http://www.zdziarski.com/blog/wp-content/uploads/2013/05/iOS-Forensic-Investigative-Methods.pdf"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Unix timestamps</h1>
                </header>
            
            <article>
                
<p>A Unix timestamp is the number of seconds that have elapsed since Unix epoch time, which started at midnight on January 1, 1970. A Unix timestamp can be converted easily, using the <kbd>date</kbd> command on a Mac workstation or using an online Unix epoch converter, such as <a href="https://www.epochconverter.com/" target="_blank">https://www.epochconverter.com/</a>.</p>
<p>The <kbd>date</kbd> command is shown in the following code snippet: </p>
<pre class="p1"><strong><span class="s1">$ date -r 1557479897<br/></span>Fri May<span class="Apple-converted-space"> 10</span><span> 12:18:17 MSK 2019</span></strong></pre>
<p>You may come across Unix timestamps in a millisecond or nanosecond format as well. This is not a big problem; there are a number of online converters, such as <a href="http://currentmillis.com/" target="_blank">http://currentmillis.com/</a>, as highlighted in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/3eefc99b-2294-439e-8675-d2e80c165d82.png" style="width:17.83em;height:17.33em;"/></div>
<div class="mce-root CDPAlignCenter CDPAlign packt_figref">A Unix timestamp in milliseconds converted with http://currentmillis.com/</div>
<p>The Unix epoch is the most common format for iOS devices, but there are others as well, including Mac absolute time and WebKit/Chrome time.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Mac absolute time</h1>
                </header>
            
            <article>
                
<p>iOS devices adopted the use of Mac absolute time with iOS 5. Mac absolute time is the number of seconds that have elapsed since Mac epoch time, which started at midnight on January 1, 2001. The difference between the Unix epoch time and the Mac time is exactly 978,307,200 seconds. It means you can easily convert the Mac time to the Unix epoch and use the same methods to finally convert it to a human-readable timestamp. Of course, there are a few online converters, such as <a href="https://www.epochconverter.com/coredata" target="_blank">https://www.epochconverter.com/coredata</a>, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/e52b9f80-162b-4bbb-a9cd-77c3312d6752.png" style="width:32.00em;height:6.08em;"/></div>
<div class="mce-root CDPAlignCenter CDPAlign packt_figref">A Mac timestamp converted with https://www.epochconverter.com/coredata</div>
<p class="mce-root">Of course, there are offline tools for timestamp conversion as well. We'll introduce you to one of them in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">WebKit/Chrome time</h1>
                </header>
            
            <article>
                
<p>When analyzing iOS application data, especially for web browsers such as Google Chrome, Safari, and Opera, you may face another timestamp format—<em>WebKit/Chrome time</em>. <span>This is the number of microseconds since midnight on January 1, 1601. There is also an online converter for this: <a href="https://www.epochconverter.com/webkit" target="_blank">https://www.epochconverter.com/webkit</a>.</span></p>
<div class="packt_tip">If you don't like or don't want to use online converters for some reason, you can also use a free tool: Digital Detective's DCode. This tool can be used to convert timestamps in a number of different formats, including Unix time (both seconds and milliseconds), Mac absolute time, and WebKit/Chrome time, as shown in the following screenshot:</div>
<div class="CDPAlignCenter CDPAlign"><img src="assets/da4ab0d6-d97d-49c2-a5a6-2df65bec31bb.png" style="width:39.83em;height:21.83em;"/></div>
<div class="mce-root CDPAlignCenter CDPAlign packt_figref"><span>A WebKit/Chrome timestamp converted with DCode</span></div>
<p>Many commercial mobile forensic suites will easily convert extracted timestamps for you automatically, but in some cases, it's extremely important to validate it, so it's a must for you to clearly understand the timestamp formats.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Working with SQLite databases</h1>
                </header>
            
            <article>
                
<p>SQLite is an open source, in-process library that implements a self-contained, zero-configuration, and transactional SQL database engine. This is a complete database with multiple tables, triggers, and views that are contained in a single cross-platform file. As SQLite is portable, reliable, and small, it is a popular database format that appears on many mobile platforms.</p>
<p class="mce-root"/>
<p>Apple iOS devices, as with other smartphones and tablets, make heavy use of SQLite databases for data storage. Many of the built-in applications—such as Phone, Messages, Mail, Calendar, and Notes—store data in SQLite databases. Apart from this, third-party applications installed on the device also leverage SQLite databases for data storage.</p>
<p>SQLite databases are created with or without a file extension. They typically have the <kbd>.sqlitedb</kbd> or <kbd>.db</kbd> file extensions, but some databases are given other extensions as well.</p>
<p>Data in SQLite files is broken up into tables that contain the actual data. To access the data stored in the files, you need a tool that is able to read it. Most commercial mobile forensic tools—such as Belkasoft Evidence Center, Magnet AXIOM, and Cellebrite <strong>Universal Forensic Extraction Device</strong> (<strong>UFED</strong>) Physical Analyzer—provide support for the examination of SQLite databases. If you don't own one of these tools, some good free tools are as follows:</p>
<ul>
<li><strong>DB Browser for SQLite (DB4S)</strong>: This can be downloaded from <a href="http://sqlitebrowser.org/" target="_blank">http://sqlitebrowser.org/</a>.</li>
<li><strong>SQLite command-line client</strong>: This can be downloaded from <a href="http://www.sqlite.org/" target="_blank">http://www.sqlite.org/</a>.</li>
<li><strong>SQLiteStudio</strong> (<a href="https://sqlitestudio.pl" target="_blank">https://sqlitestudio.pl</a>): This is a free cross-platform SQLite manager with support for <span>Windows 9x/2k/XP/2003/Vista/7/8/10, macOS, and Linux</span>.</li>
<li><strong>SQLiteSpy</strong>: This is a free <strong>graphical user interface</strong> <strong>(GUI)</strong> tool for Windows. You can download it from <a href="http://www.yunqa.de/delphi/doku.php/products/sqlitespy/index">http</a><a href="http://www.yunqa.de/delphi/doku.php/products/sqlitespy/index" target="_blank">://www.yunqa.de/delphi/doku.php/products/sqlitespy/index</a>.</li>
</ul>
<p>macOS includes the SQLite command-line utility (<kbd>sqlite3</kbd>) by default. This command-line utility can be used to access individual files and run SQL queries against a database. In the following sections, we will use both the <kbd>sqlite3</kbd> command-line utility and other SQLite tools and browsers to retrieve data from various SQLite databases. Before retrieving the data, the basic commands that you will need to learn are explained in the following sections.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Connecting to a database</h1>
                </header>
            
            <article>
                
<p>Manual examination of iOS SQLite database files is possible with the use of free tools. The following is an example of how to examine a database using native Mac commands in the Terminal:</p>
<ol>
<li>Make sure that your device image is mounted as read-only to prevent changes being made to the original evidence.</li>
<li>To connect to an SQLite database from the command line, run the <kbd>sqlite3</kbd> command in the Terminal by entering your database file. This will give you an SQL prompt where you can issue SQL queries, as shown in the following code block:</li>
</ol>
<pre style="padding-left: 60px" class="p1"><strong><span class="s1">$ sqlite3 sms.db<br/></span><span>SQLite version 3.28.0 2019-04-15 14:49:49</span><br/><span>Enter ".help" for usage hints.</span><br/></strong></pre>
<ol start="3">
<li>To disconnect, use the <kbd>.exit</kbd> command. This exits the SQLite client and returns to the Terminal.</li>
</ol>
<p><span><span>The next section will walk you through the analysis of databases, using <kbd>sqlite3</kbd> built-in commands.</span></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Exploring SQLite special commands</h1>
                </header>
            
            <article>
                
<p>Once you connect to a database, you can use a number of built-in SQLite commands that are known as <em>dot commands</em> and that can be used to obtain information from the database files.</p>
<p>You can obtain the list of special commands by issuing the <kbd>.help</kbd> command in the SQLite prompt. These are SQLite-specific commands, and they do not require a semicolon at the end. The most commonly used dot commands include the following:</p>
<ul>
<li><kbd>.tables</kbd>: This lists all of the tables within a database. The following screenshot displays the list of tables found inside the <kbd>sms.db</kbd> database:</li>
</ul>
<div class="CDPAlignCenter CDPAlign"><img src="assets/d27252c6-e75f-4035-8f34-9be14da66735.png" style="width:23.33em;height:7.58em;"/></div>
<ul>
<li><kbd>.schema table-name</kbd>: This displays the <kbd>SQL CREATE</kbd> statement that was used to construct the table. The following screenshot displays the schema for the <kbd>handle</kbd> table from the <kbd>sms.db</kbd> database:</li>
</ul>
<div class="CDPAlignCenter CDPAlign"><img src="assets/6d00603a-79a1-44df-9c3b-2475eab6f5d9.png" style="width:40.42em;height:2.92em;"/></div>
<ul>
<li><kbd>.dump table-name</kbd>: This dumps the entire content of a table into SQL statements. The example in the following screenshot displays the dump of the <kbd>handle</kbd> table, which is found inside the <kbd>sms.db</kbd> database:</li>
</ul>
<div class="CDPAlignCenter CDPAlign"><img src="assets/3457bfe6-038b-4021-902c-452e24a4c31e.png" style="width:34.00em;height:5.50em;"/></div>
<ul>
<li><kbd>.output file-name</kbd>: This redirects the output to a file on the disk instead of showing it on the screen.</li>
<li><kbd>.headers on</kbd>: This displays the column title whenever you issue a <kbd>SELECT</kbd> statement.</li>
<li><kbd>.help</kbd>: This displays the list of available SQLite dot commands.</li>
<li><kbd>.exit</kbd>: This disconnects from the database and exits the SQLite command shell.</li>
<li><kbd>.mode</kbd>: This sets the output mode; it could be <kbd>.csv</kbd>, HTML, tabs, and so on.</li>
</ul>
<div class="packt_tip">Make sure that there is no space between the SQLite prompt and the dot command; otherwise, the entire command will be ignored.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Exploring standard SQL queries</h1>
                </header>
            
            <article>
                
<p>In addition to the SQLite dot commands, standard SQL queries such as <kbd>SELECT</kbd>, <kbd>INSERT</kbd>, <kbd>ALTER</kbd>, and <kbd>DELETE</kbd> can be issued to SQLite databases on the command line. Unlike the SQLite dot commands, standard SQL queries expect a semicolon at the end of the command.</p>
<p class="mce-root"/>
<p>Most of the databases that you will examine will contain only a reasonable number of records, so you can issue a <kbd>SELECT *</kbd> statement, which prints all of the data contained in the table. This will be covered in detail throughout this chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Accessing a database using commercial tools</h1>
                </header>
            
            <article>
                
<p class="mce-root">While a manual examination of iOS SQLite database files is possible with the use of free tools, most examiners prefer commercial support prior to digging manually into the files for examination. The following is an example of how to examine a database using SQLite, which is included in Belkasoft Evidence Center.</p>
<p>To open and analyze a database, you just need to follow a few simple steps, listed here<span>:</span></p>
<ol>
<li class="mce-root">Launch Belkasoft Evidence Center and navigate to <span class="packt_screen">View | SQLite</span> <span class="packt_screen">Viewer</span>, a<span>nd choose the database file you want to examine.</span></li>
<li>Once the database is chosen, it's immediately opened with SQLite Viewer and is ready to be examined, as illustrated in the following screenshot:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/a9651922-7915-4392-87cf-313d624572e9.png" style="width:16.42em;height:22.58em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">sms.db database opened with Belkasoft Evidence Center's SQLite Viewer</div>
<p>Why does an examiner need to use such commercial viewers instead of free and open-source ones? For example, this particular viewer supports even damaged or partially overwritten SQLite databases. What's more, the tool supports the extraction of data from freelists, <strong>Write-Ahead Log</strong> (<strong>WAL</strong>), and unallocated space, as illustrated in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/edf93e65-d1c8-4d11-bb26-005c4afa01e6.png" style="width:33.08em;height:21.33em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Unallocated space of the database as seen in <span>Belkasoft Evidence Center's SQLite Viewer</span></div>
<p>Of course, there are some free and open source tools available for SQLite data recovery. You'll learn more about such tools in the following sections.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Key artifacts – important iOS database files</h1>
                </header>
            
            <article>
                
<p>Filesystems and backups that you extracted as per the instructions in <a href="6bdeccbc-e651-43f3-b5ed-4e6d071adec6.xhtml">Chapter 3</a><em>, Data Acquisition from iOS Devices,</em> and <a href="f082adcc-6892-4e66-80cc-49b9752cb56a.xhtml">Chapter 4</a><em>,</em> <em>Data Acquisition from iOS Backups,</em> should contain the following SQLite databases that may be important to your investigation. If these files are not recovered, make sure that you acquired the iOS device correctly. The files that are shown in the following sections are extracted via logical acquisition from a device running iOS. As Apple adds new features to the built-in applications with every iOS release, the format of the files may vary for different iOS versions. </p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Address book contacts</h1>
                </header>
            
            <article>
                
<p>The address book contains a wealth of information about the owner's personal contacts. With the exception of third-party applications, the address book contains contact entries for all of the contacts that are stored on the device. The address book database can be found at <kbd>/HomeDomain/Library/AddressBook.sqlitedb</kbd>. The <kbd>AddressBook.sqlitedb</kbd> file contains several tables, of which the following three are of particular interest:</p>
<ul>
<li><kbd>ABPerson</kbd>: This contains the name, organization, notes, and more for each contact.</li>
<li><kbd>ABMultiValue</kbd>: This contains phone numbers, email addresses, website <strong>Uniform Resource Locators</strong> (<strong>URLs</strong>), and more for the entries in the <kbd>ABPerson</kbd> table. The <kbd>ABMultiValue</kbd> table uses a <kbd>record_id</kbd> file to associate the contact information with a <kbd>ROWID</kbd> from the <kbd>ABPerson</kbd> table.</li>
<li><kbd>ABMultiValueLabel</kbd>: This table contains labels to identify the kind of information stored in the <kbd>ABMultiValue</kbd> table.</li>
</ul>
<p>Some of the data stored within the <kbd>AddressBook.sqlitedb</kbd> file could be from third-party applications. You should manually examine the application file folders to ensure that all the contacts are accounted for and examined.</p>
<p>While all the following commands can be run natively on a Mac, we are going to use DB4S to examine the most common databases found on iOS devices. This is a free tool that simplifies the process and provides a clear view of the data to you. Once the database is loaded, you can draft queries to examine the data most relevant to you and export the address book into a <kbd>.csv</kbd> file named <kbd>AddressBook.csv</kbd>, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/51361ad5-b90c-4a2a-9e91-8eee6bc2c0f6.png" style="width:30.50em;height:21.50em;"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">The AddressBook.sqlitedb file in DB4S</div>
<p>In the preceding screenshot, you can see the suggested query to parse data from both the <kbd>ABPerson</kbd> and <kbd>ABMultiValue</kbd> tables. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Address book images</h1>
                </header>
            
            <article>
                
<p>In addition to the address book's data, each contact may contain an image associated with it. This image is displayed on the screen whenever the user receives an incoming call from a particular contact. These images can be created by third-party applications that have access to the contacts on the device. Often, the contact is linked to a third-party application profile photo. The address book images database can be found at <kbd>/HomeDomain/Library/AddressBook/AddressBookImages.sqlitedb</kbd>.</p>
<p>The address book images can be parsed manually, but using commercial software makes this process much more practical. Most free and commercial tools will provide access to the address book images. However, some tools will not make the link between the graphic and the contact, which may require some manual rebuilding. Sometimes, the free solutions work best when parsing simple data from iOS devices. Next, we will examine the address book images in iExplorer, which was introduced in <a href="f082adcc-6892-4e66-80cc-49b9752cb56a.xhtml" target="_blank">Chapter 4</a>, <em>Data Acquisition from iOS Backups</em>.</p>
<p class="mce-root"/>
<p>In the example in the following screenshot, iExplorer matched contact data with the image automatically:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/c5991b98-0b58-44c4-8955-11c1d0a9f20e.png" style="width:12.50em;height:22.25em;"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Examining address book images in iExplorer</div>
<p>The same thumbnails can be found in the <kbd>ABThumbnailImage</kbd> table, in the <kbd>data</kbd> column. You can match the photo to the contact manually, using the <kbd>record_id</kbd> column from the <span><kbd>ABThumbnailImage</kbd> table of <kbd>AddressBookImages.sqlitedb</kbd> and the <kbd>ROWID</kbd> column from the <kbd>ABPerson</kbd> table of <kbd>AddressBook.sqlitedb</kbd>.</span></p>
<div class="CDPAlignCenter CDPAlign packt_figref"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Call history</h1>
                </header>
            
            <article>
                
<p>Phone or FaceTime calls placed, missed, and received by the user are logged in the call history along with other metadata, such as call duration, and date and time. The call history database can be found at <kbd><span>/HomeDomain/Library/CallHistoryDB/CallHistory.storedata</span></kbd>. The <kbd>CallHistory.storedata</kbd> file was introduced with iOS 8 and is currently in use at the time of writing (iOS 13.2).</p>
<p>The <kbd>ZCALLRECORD</kbd> table in the <kbd>CallHistory.storedata</kbd> database contains the call history. It's important to note that only a limited number of calls may be stored in the active database. Just because the database removes the oldest record when space is needed does not mean this data is deleted. It's simply in the free pages of the SQLite database file, and it can be recovered using forensic tools or manually. The most important columns in the <kbd><span>ZCALLRECORD</span></kbd> table are the following:</p>
<ul>
<li><kbd>ZDATE</kbd>: This column contains the timestamps of calls in Mac absolute time format.</li>
<li><kbd>ZDURATION</kbd>: This column contains the duration of calls.</li>
<li><kbd>ZLOCATION</kbd>: This column contains the locations of phone numbers.</li>
<li><kbd>ZADDRESS</kbd>: This column contains the phone numbers.</li>
<li><kbd>ZSERVICE_PROVIDER</kbd>: This column contains the service providers—for example, Phone, WhatsApp, Telegram, and so on.</li>
</ul>
<p>You can run the following queries in DB4S to parse the call history. Afterward, you can export it into a <kbd>.csv</kbd> file, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/c9e15bf1-ab8e-4000-8456-29f227a1c52b.png" style="width:35.58em;height:20.25em;"/></div>
<div class="mce-root CDPAlignCenter CDPAlign packt_figref">Examining CallHistory.storedata in DB4S</div>
<p>This time, the query is quite simple as all columns of interest are in the same table. Notice we used <kbd>datetime</kbd> to convert Mac absolute timestamps to human-readable dates.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Short Message Service (SMS) messages</h1>
                </header>
            
            <article>
                
<p>The SMS database contains text and multimedia messages that were sent from and received by the device, along with the phone number of the remote party, date and time, and other carrier information. Starting with iOS 5, iMessage data is also stored in the SMS database. iMessage allows users to send SMS and <strong>Multimedia Messaging Service</strong> (<strong>MMS</strong>) messages over a cellular or Wi-Fi network to other iOS or macOS users, thus providing an alternative to SMS. The SMS database can be found at <kbd>/HomeDomain/Library/SMS/sms.db</kbd>.</p>
<p><span>You can run the following queries in DB4S to parse the SMS messages. Afterward, you can export it into a <kbd>.csv</kbd> file, as shown in the following screenshot:</span></p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/7c2195ca-221a-478c-a224-c4811153eb62.png" style="width:43.83em;height:21.75em;"/></div>
<div class="mce-root CDPAlignCenter CDPAlign packt_figref"><span>Examining sms.db in DB4S</span></div>
<p>There's another interesting subdirectory that can be found at <span><kbd>/HomeDomain/Library/SMS/</kbd>—<kbd>Drafts</kbd>. Inside, there are more subfolders, each of which contains a <kbd>message.plist</kbd> file. Each file is a property list with draft messages the user started to type but didn't send. You'll learn more about property lists in the next sections.</span></p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Calendar events</h1>
                </header>
            
            <article>
                
<p>Calendar events that have been manually created by the user or synced using a mail application or other third-party applications are stored in the <kbd>Calendar</kbd> database. The <kbd>Calendar</kbd> database can be found at <kbd>/HomeDomain/Library/Calendar/Calendar.sqlitedb</kbd>.</p>
<p>The <kbd>CalendarItem</kbd> table in the <kbd>Calendar.sqlitedb</kbd> file contains the calendar events summary, description, start date, end date, and more. <span>You can run the following queries in DB4S to parse the calendar, as illustrated in the following screenshot:</span></p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/2f1bdd85-49ca-4b3f-8a00-c8648c6697f3.png" style="width:29.67em;height:19.83em;"/></div>
<div class="mce-root CDPAlignCenter CDPAlign packt_figref">Examining calendar.sqlitedb in DB4S</div>
<p><span><span>As you can see, the <kbd>CalendarItem</kbd> table stores dates in Mac absolute time format, so we added</span></span> <kbd>978307200</kbd> <span><span>to reveal actual timestamps, with the help of the <kbd>datetime</kbd> function.</span></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Notes</h1>
                </header>
            
            <article>
                
<p>The <kbd>Notes</kbd> database contains the notes that are created by the user using the device's built-in <kbd>Notes</kbd> application. <kbd>Notes</kbd> is the simplest application, often containing the most sensitive and confidential information. The <kbd>Notes</kbd> database can be found at <kbd>/HomeDomain/Library/Notes/notes.sqlite</kbd>.</p>
<p>The <kbd>ZNOTE</kbd> and <kbd>ZNOTEBODY</kbd> tables in the <kbd>notes.sqlite</kbd> file contain each note's title, content, creation date, modification date, and more. You can run the following queries to parse the <kbd>Notes</kbd> database:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/d2995cae-a0c5-4cba-8239-b274e77c4f25.png" style="width:45.42em;height:20.00em;"/></div>
<div class="mce-root CDPAlignCenter CDPAlign packt_figref">Examining notes in DB4S</div>
<p><span><span>This query merges data from two tables, so we use <kbd>ZOWNER</kbd> from <kbd>ZNOTEBODY</kbd>, <kbd>Z_PK</kbd> from <kbd>ZNOTE</kbd>, and a <kbd>WHERE</kbd> clause to do it.</span></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Safari bookmarks and history</h1>
                </header>
            
            <article>
                
<p>The Safari browser used on an iOS device allows users to bookmark their favorite websites. The <kbd>Bookmarks</kbd> database can be found at <kbd>/HomeDomain/Library/Safari/Bookmarks.db</kbd>. Bookmark data can be extracted with a very simple query, as illustrated in the following screenshot:</p>
<p class="mce-root"/>
<p class="CDPAlignCenter CDPAlign"><img src="assets/456f42eb-bf0b-418c-87a8-4bfee6e5c029.png" style="width:19.92em;height:18.08em;"/></p>
<div class="mce-root CDPAlignCenter CDPAlign packt_figref">Examining bookmarks in DB4S</div>
<p>Browsing history can be found in <kbd>History.db</kbd>, at <kbd><span>/HomeDomain/Library/Safari/</span></kbd>. The most important pieces of information about visited websites can be extracted from <kbd>history_items</kbd> and <kbd>history_visits</kbd> tables, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/15dedc9e-25ed-4fae-aded-167b4bdbc601.png" style="width:39.92em;height:20.00em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span><span>Examining history in DB4S</span></span></div>
<p>In addition to Safari, other browsers can be used to store data on an iOS device. For this reason, we recommend using a tool built to parse internet history, to ensure that data is not overlooked. Good forensic tools for solving this task are AXIOM by Magnet Forensics, <span>Physical Analyzer by Cellebrite</span>, and some others.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Voicemail</h1>
                </header>
            
            <article>
                
<p>The<span> </span><kbd>Voicemail</kbd><span> </span>database contains metadata about each voicemail that is<span> </span>stored<span> </span>on the device, which includes the sender's phone number, callback number, timestamp and message duration, and more. The voicemail recordings are stored as <strong>Adaptive Multi-Rate</strong> (<strong>AMR</strong>) audio files that can be played by any media<span> </span>player<span> </span>that supports the AMR codec (for example,<span> </span>QuickTime Player). The <kbd>Voicemail</kbd> database can be found under<span> </span><kbd>/HomeDomain/Library/Voicemail/voicemail.db</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Recordings</h1>
                </header>
            
            <article>
                
<p><span>The</span><span> </span><kbd><span>Recordings</span> </kbd><span>database contains metadata about each recording</span><span> </span>stored<span> </span><span>on the device, which includes the timestamp, its duration, its location on the device, and more. The database can be found at </span><kbd>/MediaDomain/Media/Recordings</kbd><span>. The metadata can be extracted with the query shown in the following screenshot:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/c34c37f3-762b-4675-ae9d-bdef7279306a.png" style="width:39.25em;height:16.08em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref"><span>Examining recordings in DB4S</span></div>
<p>As you can see in the preceding screenshot, actual files with recordings are stored in the same directory.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Device interaction</h1>
                </header>
            
            <article>
                
<p>There is an SQLite database that records how the user interacts with different applications. This database is called <kbd>interactionC.db</kbd> and is located at <span><kbd>/HomeDomain/Library/CoreDuet/People</kbd>. The <kbd>ZINTERACTIONS</kbd> table contains information about whether the user reads a message, sends a message, performs a call, and so on. You can extract this information from the table with the query shown in the following screenshot:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/d4baf2f6-666d-4e8a-8256-d348057170a6.png" style="width:44.83em;height:22.50em;"/></p>
<div class="mce-root CDPAlignCenter CDPAlign packt_figref">
<div class="packt_figref CDPAlignCenter CDPAlign"><span>Examining interactions in DB4S</span></div>
</div>
<p>Also, make sure you examined the <kbd>ZCONTACTS</kbd> table—it contains information about contacts who were involved in the user's interactions with the device, if applicable.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Phone numbers</h1>
                </header>
            
            <article>
                
<p>You can obtain information about all phone numbers utilized by the user, even if they changed phones and restored from a backup, by analyzing the <kbd>CellularUsage.db</kbd> file located at <kbd>/WirelessDomain/Library/Databases</kbd>. The query to extract this data is shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/673b6637-286f-4d21-8fb0-910bdd31bf95.png" style="width:34.92em;height:17.17em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Extracting phone numbers</div>
<p>As you can see, there is not only phone numbers available, but also the <strong>Subscriber Identity Module</strong> (<strong>SIM</strong>) card's <span><strong>Integrated Circuit Card Identifier</strong> (<strong>ICCID</strong>).</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Property lists</h1>
                </header>
            
            <article>
                
<p>A property list, commonly referred to as a <kbd>plist</kbd>, is a structured data format used to store, organize, and access various types of data on an iOS device as well as a macOS device. <kbd>plist</kbd> files are binary-formatted, and they can be viewed using a property List Editor, which is capable of reading or converting the binary format to an <strong>American Standard Code for Information Interchange</strong> (<strong>ASCII</strong>) format.</p>
<p><kbd>Plist</kbd> files may or may not have a <kbd>.plist</kbd> file extension. To access the data stored in these files, you need a tool that can read them. Some of the good free tools include the following:</p>
<ul>
<li>plist Editor Pro, which can be downloaded from <a href="http://www.icopybot.com/plist-editor.htm" target="_blank">http://www.icopybot.com/plist-editor.htm</a>.<a href="http://www.icopybot.com/plist-editor.htm" target="_blank"/></li>
<li>The <kbd>plutil</kbd> command-line utility on macOS.</li>
</ul>
<p class="mce-root"/>
<p>You can view <kbd>plist</kbd> files using Xcode. macOS includes the <kbd>plutil</kbd> command-line utility by default. This command-line utility can easily convert the binary-formatted files into human-readable files. In addition to this, most commercial forensic tools include great support for parsing <kbd>plist</kbd> files.</p>
<p>The following screenshot displays the <kbd>com.apple.mobile.ldbackup.plist</kbd> file:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/85fcf9cc-8be9-489f-850b-5cb264c83f30.png" style="width:26.17em;height:12.67em;"/></div>
<div class="mce-root CDPAlignCenter CDPAlign packt_figref">The <span>com.apple.mobile.ldbackup.plist</span> in plist Editor Pro</div>
<p>As you can see, this <kbd>plist</kbd> uncovers the last local and cloud backup dates (in Mac absolute time, of course), the time zone it was created in, as well as the fact that the backup is encrypted.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Important plist files</h1>
                </header>
            
            <article>
                
<p>Raw disk images or the backup that you extracted in <a href="6bdeccbc-e651-43f3-b5ed-4e6d071adec6.xhtml" target="_blank">Chapter 3</a>, <em>Data Acquisition from iOS Devices,</em> and <a href="f082adcc-6892-4e66-80cc-49b9752cb56a.xhtml" target="_blank">Chapter 4</a>, <em>Data Acquisition from iOS Backups,</em> should contain the following <kbd>plist</kbd> files that are important for an investigation. The files displayed are extracted from an iOS 13.2 device backup. The file locations may vary for your iOS version.</p>
<p class="mce-root"/>
<p>The following are the <kbd>plist</kbd> files that contain data that may be relevant to your investigation:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td style="width: 59.0428%" class="CDPAlignCenter CDPAlign"><strong><span>plist file</span></strong></td>
<td style="width: 40.3462%">
<p class="CDPAlignCenter CDPAlign"><strong>Description</strong></p>
</td>
</tr>
<tr>
<td style="width: 59.0428%"><kbd><span>/HomeDomain/Library/Preferences/com.apple.commcenter.shared.plist</span></kbd></td>
<td style="width: 40.3462%">
<p>Contains the phone number in use</p>
</td>
</tr>
<tr>
<td style="width: 59.0428%"><span><kbd>/HomeDomain/Library/Preferences/com.apple.identityservices.idstatuscache.plist</kbd></span></td>
<td style="width: 40.3462%"><span>Contains information about the email address used for the Apple ID and the phone numbers of the individuals the user interacted with via FaceTime or iMessage using this ID</span></td>
</tr>
<tr>
<td style="width: 59.0428%"><kbd><span>/HomeDomain/Library/Preferences/com.apple.mobile.ldbackup.plist</span></kbd></td>
<td style="width: 40.3462%"><span>Contains the timestamps of the last iTunes and iCloud backups, the last iTunes backup time zone, and if it was encrypted or not</span></td>
</tr>
<tr>
<td style="width: 59.0428%"><kbd><span>/HomeDomain/Library/Preferences/com.apple.MobileBackup.DemotedApps.plist</span></kbd></td>
<td style="width: 40.3462%"><span>Contains the list of unused applications that were automatically offloaded by the operating system</span></td>
</tr>
<tr>
<td style="width: 59.0428%"><kbd><span>/HomeDomain/Library/Preferences/com.apple.mobilephone.speeddial.plist</span></kbd></td>
<td style="width: 40.3462%"><span>Contains the list of the user's favorite contacts, including their names and phone numbers</span></td>
</tr>
<tr>
<td style="width: 59.0428%"><kbd><span>/HomeDomain/Library/Preferences/com.apple.preferences.datetime.plist</span></kbd></td>
<td style="width: 40.3462%"><span>Contains information about the time zone set by the user</span></td>
</tr>
<tr>
<td style="width: 59.0428%"><kbd><span>/RootDomain/Library/Caches/locationd/clients.plist</span></kbd></td>
<td style="width: 40.3462%"><span>Contains the list of applications that use location Services</span></td>
</tr>
<tr>
<td style="width: 59.0428%"><kbd><span>/RootDomain/Library/Preferences/com.apple.MobileBackup.plist</span></kbd></td>
<td style="width: 40.3462%"><span>Contains information about the last restoration from the backup, including the restore start date, file transfer duration, number of files transferred, source device <strong>Unique Device Identifier</strong> (<strong>UDID</strong>), and so on</span></td>
</tr>
<tr>
<td style="width: 59.0428%"><kbd><span>/SystemPreferencesDomain/SystemConfiguration/com.apple.mobilegestalt.plist</span></kbd></td>
<td style="width: 40.3462%"><span>Contains the device name assigned by the user</span></td>
</tr>
<tr>
<td style="width: 59.0428%"><kbd><span>/SystemPreferencesDomain/SystemConfiguration/com.apple.wifi.plist</span></kbd></td>
<td style="width: 40.3462%"><span>Contains information about wireless access points used by the device owner</span></td>
</tr>
<tr>
<td style="width: 59.0428%"><kbd><span>/WirelessDomain/Library/Preferences/com.apple.commcenter.plist</span></kbd></td>
<td style="width: 40.3462%"><span>Contains information about the device phone number, network carrier, ICCIDs, and <strong>international</strong> <strong>mobile</strong> <strong>subscriber</strong> <strong>identities</strong> (<strong>IMSIs</strong>)</span></td>
</tr>
</tbody>
</table>
<p> </p>
<p>Of course, <kbd>plist</kbd> files don't contain as much information as SQLite databases, but they can still be useful during your forensic examinations. Next, we'll look at some other files that may be also useful.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Other important files</h1>
                </header>
            
            <article>
                
<p>Apart from SQLite and <kbd>plist</kbd> files, several other locations may contain information that could be valuable to an investigation.</p>
<p>The other sources include the following:</p>
<ul>
<li>Local dictionary</li>
<li>Photos</li>
<li>Thumbnails</li>
<li>Wallpaper</li>
<li>Downloaded third-party applications</li>
</ul>
<p>Let's look at each of them.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Local dictionary</h1>
                </header>
            
            <article>
                
<p>The list of words added by the device user to the dictionary are stored in a <kbd>LocalDictionary</kbd> plaintext file, located at <kbd>/KeyboardDomain/Library/Keyboard/</kbd>. As the file is plaintext, you can use your favorite text editor.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Photos</h1>
                </header>
            
            <article>
                
<p>Photos are stored in a directory located at <kbd>/CameraRollDomain/Media/DCIM</kbd>, which contains the photos taken with the device's built-in camera, screenshots, selfies, photo stream, recently deleted photos, and accompanying thumbnails. Some third-party applications will also store photos taken in this directory. Every photo stored in the <kbd>DCIM</kbd> folder contains <strong>Exchangeable Image File Format</strong> (<strong>EXIF</strong>) data. <kbd>EXIF</kbd> data stored in the photo can be extracted using <kbd>ExifTool</kbd>, which can be downloaded from <a href="https://sno.phy.queensu.ca/~phil/exiftool/" target="_blank">https://sno.phy.queensu.ca/~phil/exiftool/</a>. <kbd>EXIF</kbd> data may contain geographical information when a photo is tagged with the user's geolocation if the user has enabled location permissions on the iOS device.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Thumbnails</h1>
                </header>
            
            <article>
                
<p>Another source of important artifacts related to photos is the <kbd>ithmb</kbd> files. You can find these files at <kbd>/CameraRollDomain/Media/PhotoData/Thumbnails</kbd><span>. These files contain thumbnails not only for actual photos on the device but also</span> for deleted ones. And, of course, there is a tool for parsing such files, <kbd>iThmb Converter</kbd>, which can be downloaded from <a href="http://www.ithmbconverter.com/en/download/" target="_blank">http://www.ithmbconverter.com/en/download/</a> and is shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/30e58e68-ad94-4084-8b21-dae387321a59.png"/></div>
<div class="mce-root CDPAlignCenter CDPAlign packt_figref">Examining 3304.ithmb with iThmb Converter</div>
<p>As these files may contain thumbnails of deleted photos, they mustn't be overlooked by forensic examiners. What's more, some of them contain quite big thumbnails, so it will be clear what was pictured.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Wallpaper</h1>
                </header>
            
            <article>
                
<p>The current background wallpapers set for the iOS device can be recovered from the <kbd>LockBackgroundThumbnail.jpg</kbd> and <span><kbd>LockBackgroundThumbnaildark.jpg</kbd> </span>files that are found in <kbd>/HomeDomain/Library/SpringBoard</kbd>.</p>
<p>The wallpaper picture may contain identifying information about the user that could help in a missing person's case or that could be found on an iOS device recovered from a theft investigation.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Downloaded third-party applications</h1>
                </header>
            
            <article>
                
<p>Third-party applications that are downloaded and installed from the App Store—including applications such as Facebook, WhatsApp, Viber, Threema, Tango, Skype, and Gmail—contain a wealth of information that is useful for an investigation. Some third-party applications use Base64 encoding, which needs to be converted for viewing purposes as well as encryption. Applications that encrypt the database file may prevent you from accessing the data residing in the tables. Encryption varies among these applications, based on the application and iOS versions.</p>
<p>A subdirectory with a <strong>universally unique identifier</strong> (<strong>UUID</strong>) is created for each application that is installed on the device in the <kbd>/private/var/mobile/Containers/Data/Application</kbd> directory. Most of the files stored in the application's directory are in the SQLite and <kbd>plist</kbd> format. Each file must be examined for relevance. We recommend using Belkasoft Evidence Center, Cellebrite UFED Physical Analyzer, Elcomsoft Phone Viewer, and Magnet AXIOM when possible to extract these artifacts quickly, before going back and manually running queries and parsing the data.</p>
<p><span>Also, information about installed applications can be gathered from the </span><kbd>applicationState.db</kbd><span> database, located at <kbd>/HomeDomain/Library/FrontBoard</kbd>. This is another SQLite database and can be analyzed with an appropriate viewer of the examiner's choice.</span></p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Recovering deleted SQLite records</h1>
                </header>
            
            <article>
                
<p>SQLite databases store the deleted records within the database itself, so it is possible to recover deleted data, such as contacts, SMS messages, calendars, notes, email, voicemail, and more by parsing the corresponding SQLite database. If an SQLite database is vacuumed or defragmented, the likelihood of recovering the deleted data is minimal. The amount of cleanup that these databases require relies heavily on the iOS version, the device, and the user's settings on the device.</p>
<p>A SQLite database file comprises one or more fixed-size pages, which are used just once. SQLite uses a B-tree layout of pages to store indices and table content. Detailed information on the B-tree layout can be found at <a href="https://github.com/NotionalLabs/SQLiteZer/blob/master/_resources/Sqlite_carving_extractAndroidData.pdf" target="_blank">https://github.com/NotionalLabs/SQLiteZer/blob/master/_resources/Sqlite_carving_extractAndroidData.pdf</a>.</p>
<p>Commercial forensic tools provide support to recover deleted data from SQLite database files, but they don't always recover all of the data, nor do they support extracting data from all databases on an iOS device. It is recommended that each database containing key artifacts be examined for deleted data. The key artifacts or databases already discussed in this book should be examined using free parsers, hex viewers, or even your forensic tool to determine whether the user deleted artifacts that are relevant to the investigation.</p>
<p>To carve an SQLite database, you can examine the data in raw hex or use <kbd>sqliteparse.py</kbd>, a free Python script developed by Mari DeGrazia. The Python script can be downloaded from <a href="https://github.com/mdegrazia/SQlite-Deleted-Records-Parser" target="_blank">https://github.com/mdegrazia/SQlite-Deleted-Records-Parser</a>.</p>
<p>The following example recovers the deleted records from the <kbd>notes.sqlitedb</kbd> file and dumps the output to the <kbd>output.txt</kbd> file. This script should work on all database files recovered from iOS devices. To validate your findings from running the script, simply examine the database in a hex viewer to ensure nothing is overlooked. The code can be seen here:</p>
<pre><strong>$python sqliteparse.py -f notes.sqlitedb -r -o output.txt</strong></pre>
<p>In addition to this, performing a <kbd>strings</kbd> dump of the database file can also reveal deleted records that may have been missed, as shown in the following command:</p>
<pre><strong>$strings notes.sqlitedb</strong></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<div class="packt_tip">Should you prefer a GUI, Mari DeGrazia kindly created one and placed it on her GitHub page.</div>
<p>Another open-source tool you can use to recover deleted SQLite records is Undark. You can download it here: <a href="http://pldaniels.com/undark/" target="_blank">http://pldaniels.com/undark/</a>. To use the tool, run the following command:</p>
<pre><strong>./undark -i sms.db &gt; sms_database.csv</strong></pre>
<p>It's important to note that Undark <span>does not differentiate between current and deleted data, so you will get the whole set of data, both actual and deleted.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>This chapter covered various data analysis techniques and specified the locations for common artifacts within the iOS device's filesystem. When writing this chapter, we aimed to cover the most popular artifacts that tie into most investigations. Clearly, it is impossible to cover them all. We hope that once you learn how to extract data from SQLite and <kbd>plist</kbd> files, intuition and persistence will assist you in parsing the artifacts that were not covered.</p>
<p>Keep in mind that most open-source and commercial tools are able to pull active and deleted data from common database files, such as contacts, calls, SMS messages, and more, but they often overlook the third-party application database files. Our best advice is to know how to recover the data manually, just in case you need to validate your findings or testify as to how your tool functions.</p>
<p>We covered techniques to recover deleted SQLite records that prove useful in most iOS device investigations. Again, the acquisition method, encoding, and encryption schemas can affect the amount of data that you can recover during your examination.</p>
<p>In the next chapter, <em>iOS Forensic Tools</em>, we will introduce you to the most popular mobile forensic tools—Cellebrite UFED Physical Analyzer, Magnet AXIOM, Elcomsoft Phone Viewer, and Belkasoft Evidence Center.</p>


            </article>

            
        </section>
    </body></html>