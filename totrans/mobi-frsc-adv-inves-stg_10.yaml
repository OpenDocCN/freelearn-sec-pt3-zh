- en: Chapter 10\. Dealing with Issues, Obstacles, and Special Cases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Each acquisition case is unlike others. Different manufacturers, hardware, and
    ecosystems; different versions of the mobile OS; different on-device security
    settings; and many other things make every case unique. In this chapter, we'll
    have a look at some common obstacles that may become roadblocks on the way to
    successful acquisition. We'll learn how to deal with some issues and understand
    restrictions and limitations imposed by some things specific to various platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Cloud acquisition and two-factor authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Two-factor authentication is probably the best security feature since passwords
    were invented. Two-factor authentication goes a long way towards protecting one's
    accounts against being hacked. A password alone, no matter how long or secure,
    is no longer enough to provide sufficient protection. Social engineering, linked
    security breaches ([http://blog.elcomsoft.com/2013/02/yahoo-dropbox-and-battle-net-hacked-stopping-the-chain-reaction/](http://blog.elcomsoft.com/2013/02/yahoo-dropbox-and-battle-net-hacked-stopping-the-chain-reaction/)),
    leaked passwords, and hacked mailboxes all contribute to the insecurity of password-based
    protection. Once the intruder gets a hold of someone's password, they can access
    the account without a fuss. Even worse, they can gain access to other accounts
    by, for example, using a hacked e-mail address to request password resets on other
    connected services. Two-factor authentication aims to address this problem.
  prefs: []
  type: TYPE_NORMAL
- en: LinkedIn. Yahoo! Mail. Dropbox. Battle.net. IEEE. Adobe Connect. PayPal. eBay.
    Twitter. These are just a few recent examples of big name service providers being
    hacked, with literally millions of passwords leaked.
  prefs: []
  type: TYPE_NORMAL
- en: The infamous celebrity photo leak ([http://www.mirror.co.uk/3am/celebrity-news/celebrity-4chan-shock-naked-picture-4395155](http://www.mirror.co.uk/3am/celebrity-news/celebrity-4chan-shock-naked-picture-4395155))
    was huge. It demonstrated how susceptible iCloud users are to remote hacks. Thousands
    of explicit images that celebrities captured with their iPhones were stolen straight
    from their iCloud accounts. Apparently, hackers were able to get passwords from
    celebrities' Apple ID, and gained access to the linked iCloud accounts using a
    copy of Elcomsoft Phone Breaker. Should Apple enforce two-factor authentication
    on iCloud account holders, the problem would probably occur on a much lesser scale.
    Even though two-factor authentication is not infallible and is susceptible to
    social engineering, it does require significantly greater effort to obtain a quickly
    expiring security code from the victim, and poses a much higher risk to an attacker.
  prefs: []
  type: TYPE_NORMAL
- en: As an expert in mobile forensics, you may face similar obstacles when attempting
    to acquire information from the suspect's cloud account over the air.
  prefs: []
  type: TYPE_NORMAL
- en: Two-factor authentication – Apple, Google, and Microsoft
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All three major mobile service providers (Apple, Google, and Microsoft) use
    similar approaches to two-factor authentication. The two most common approaches
    are online and offline.
  prefs: []
  type: TYPE_NORMAL
- en: Online authentication works by approving authentication requests on a trusted
    device or entering a code that is pushed to the user or delivered via a text message.
    Offline authentication apps must be initialized with a cryptographic seed once;
    they will generate time-sensitive authentication codes afterwards without the
    need for an Internet connection.
  prefs: []
  type: TYPE_NORMAL
- en: Google mostly uses offline authentication via its Google Authenticator app (or
    via Microsoft Authenticator on Windows Phone devices). However, push authentication
    was added by Google in June 2016.
  prefs: []
  type: TYPE_NORMAL
- en: Apple is mostly relying on online authentication, pushing codes to trusted iOS
    devices, or delivering server-generated single-use codes via text messages. The
    ability to use time-dependent offline codes was added in iOS 9 with two-factor
    authentication support.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, Microsoft users have access to both authentication methods at the same
    time. Windows users verifying their Microsoft Account can choose online or offline
    authentication at any given time. In addition, users can set up two-step verification
    with an e-mail address or phone number. Microsoft will send a security code to
    enter on the sign-in page when the user attempts to sign in on a new device or
    from a new location.
  prefs: []
  type: TYPE_NORMAL
- en: '|  | **Microsoft** | **Apple** | **Google** |'
  prefs: []
  type: TYPE_TB
- en: '| **Push authentication** | Yes: Windows 10 Mobile and Android apps only |
    Yes: iOS 9 and newer | Yes: unspecified versions of Android running the latest
    Google Play Services |'
  prefs: []
  type: TYPE_TB
- en: '| **Offline authentication** | Yes | Yes: iOS 9, via Settings | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| **Text/SMS authentication** | Yes, as a backup | Yes, as a backup | Yes,
    as a backup |'
  prefs: []
  type: TYPE_TB
- en: Online versus offline authentication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When using online authentication, users must approve a notification on one of
    their trusted devices. With this type of authentication, users don't have to enter
    security codes. Instead, they will be pushed a verification request to all of
    their trusted devices. By approving the request, they will successfully confirm
    their identity.
  prefs: []
  type: TYPE_NORMAL
- en: Offline authentication apps are based on a different principle. They don't require
    an active Internet connection or mobile service. A new time-sensitive single-use
    code is generated every few seconds by the authenticator app. The codes are automatically
    generated even when the trusted device is offline.
  prefs: []
  type: TYPE_NORMAL
- en: While it is generally possible to de-authorize individual trusted devices with
    online authentication apps, de-authorizing offline authentication is only possible
    for all offline authentication apps at the same time. Once a new cryptographic
    seed is generated, codes generated by offline authentication apps using the old
    seed will fail to verify.
  prefs: []
  type: TYPE_NORMAL
- en: App passwords and two-factor authentication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Two-factor authentication is still relatively new. As a result, some devices
    and some third-party applications are unable to properly authenticate accounts
    if two-factor authentication is enabled. If this is the case, the user will see
    an incorrect password error when trying to set up an account. This happens because
    these older apps do not support additional security codes.
  prefs: []
  type: TYPE_NORMAL
- en: This issue was immediately recognized by developers of two-factor authentication
    schemes. A neat workaround was implemented. If a certain app or device does not
    support two-factor authentication, the user can create a unique app password allowing
    these apps to sign in and effectively bypass the second authentication step. Users
    can generate as many app passwords as needed. Microsoft, Apple, and Google all
    support app-specific passwords. Users are recommended to create new app passwords
    for each app or device not supporting the two-factor authentication scheme.
  prefs: []
  type: TYPE_NORMAL
- en: App passwords can be revoked by the user at any time. Apps using revoked passwords
    will not be able to sign in or authenticate (for example, via a stored token).
    Interestingly, app-specific passwords will not work for web sign-ins or with each
    company's respective apps.
  prefs: []
  type: TYPE_NORMAL
- en: 'A typical app password generated by Google 2FA looks like this: `asdg skgf
    dsks ezck` (it should be entered without spaces).'
  prefs: []
  type: TYPE_NORMAL
- en: Forensically, these app passwords, once extracted, can be used for effectively
    bypassing two-factor authentication. However, their forensic use is limited. For
    example, Apple does not allow downloading iCloud backups using an app password,
    but does allow accessing certain types of data (such as notes and messages). Microsoft
    does not allow accessing its backups with app passwords either. Google, on the
    other hand, allows limited access to certain types of data even when using an
    app password. Notably, app passwords can be used as a last resort when the expert
    has no access to the second authentication factor.
  prefs: []
  type: TYPE_NORMAL
- en: Google's two-factor authentication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Google implements consistent two-factor authentication, protecting access to
    all interactions with any of its services that involve the use of the user's Google
    Account. If two-factor authentication is enabled, users have to verify their identity
    as they attempt to access any of the services provided under the Google Account
    umbrella if they initiate access from a new device, app, or web browser. Authenticating
    Gmail in Internet Explorer does not automatically grant access to the same Gmail
    account if the user tries to open it in Chrome, and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: Protected services include (but are not limited to) logging in to the Google
    Account, using Gmail, accessing files or documents in Google Drive, or setting
    up a new device (for example, an Android phone) to access Google Play services.
    All in all, Google's implementation of two-factor authentication is the most consistent
    and straightforward compared to Apple and Microsoft.
  prefs: []
  type: TYPE_NORMAL
- en: Google relies mostly on offline, non-interactive two-factor authentication.
    An authenticator app is readily available on Android and iOS. The app can be initialized
    by scanning a color code displayed while the user sets up two-factor authentication.
    Once initialized, the app will continuously generate and display six-digit codes.
    The codes are valid for a short period of time (30 seconds).
  prefs: []
  type: TYPE_NORMAL
- en: Technically speaking, the app implements TOTP or HOTP security tokens as defined
    in the RFC 6238 standard. As a result, similar two-factor authentication apps
    based on the same standard may be compatible with Google, generating exactly the
    same codes that will be valid for authenticating the account. As an example, Microsoft
    Authenticator, available in Windows Store for the Windows Phone platform, is fully
    compatible with both Microsoft's and Google's two-factor authentication schemes,
    and can be used to authenticate both types of accounts.
  prefs: []
  type: TYPE_NORMAL
- en: Offline authentication in general is convenient because it does not require
    an active Internet connection. However, since it serves for authenticating account
    access (which is inherently an online operation), this point is moot. The drawback
    of this type of authentication is that the user cannot de-authorize an individual
    device or app that was previously authorized to generate authentication codes.
    Instead, if the user needs to de-authorize an app on any one of their devices,
    a new initialization image must be generated and used to re-initialize all authenticator
    apps running on all devices.
  prefs: []
  type: TYPE_NORMAL
- en: Since an initialized authentication app may not always be available, Google
    offers two backup options for receiving authentication codes. The user can authorize
    one or several phone numbers to receive single-time codes as text messages (SMS).
    In addition, the user can print 10 pre-generated eight-digit backup codes. These
    codes do not expire. These codes are disposable; each code can be used only once.
    If all codes are used, or if the user loses them, a different bunch of backup
    codes can be generated (which automatically invalidates all unused codes from
    the previous batch) at [https://www.google.com/landing/2step/](https://www.google.com/landing/2step/)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![Google''s two-factor authentication](img/0176.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Google offers a plethora of authentication options ranging from printable verification
    codes to app-specific passwords, push authentication on trusted devices, and security
    keys (electronic tokens).
  prefs: []
  type: TYPE_NORMAL
- en: '![Google''s two-factor authentication](img/0177.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Elcomsoft Cloud Explorer ([https://www.elcomsoft.com/ecx.html](https://www.elcomsoft.com/ecx.html))
    supports Google''s two-factor authentication. If the Google authentication server
    requests a verification code, the tool automatically requests that code from the
    user:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Google''s two-factor authentication](img/0178.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The code will be requested after you click **Sign in**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Google''s two-factor authentication](img/0179.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can request the code from a trusted device (a list of trusted devices will
    appear if you choose **Secure Code** as the authentication type) or use a **Recovery
    Key**, if available. Enter the code and click **Verify** to proceed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Google''s two-factor authentication](img/0180.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: More information about Google Authenticator can be found at [https://garbagecollected.org/2014/09/14/how-google-authenticator-works/](https://garbagecollected.org/2014/09/14/how-google-authenticator-works/)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft's implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the world of Microsoft Windows, the company protects Microsoft Account login
    with several security measures. Microsoft uses the same 2FA configuration for
    restoring Windows 8, 8.1, Windows 10, Windows Phone 8.1, and Windows 10 Mobile.
    The number of systems running one of those operating systems is huge, so it's
    important to understand the implications of Microsoft two-factor authentication.
  prefs: []
  type: TYPE_NORMAL
- en: Why should forensic experts be concerned about two-factor authentication in
    Microsoft systems? At the very least, two-factor authentication protects access
    to online backups made by all compatible systems listed previously. These backups
    contain comprehensive information about the user including bits such as stored
    Internet Explorer and Edge browser passwords, application data, contacts, calls,
    and text messages. While the amount of data available in Microsoft backups is
    somewhat less than that captured by Apple iOS, it is still much more than available
    in Android backups (even in the latest Android 6.0.1).
  prefs: []
  type: TYPE_NORMAL
- en: When setting up a new Windows 8, 8.1, or Windows 10 PC and attempting to sign
    in with a Microsoft Account (as opposed to using a local login), the system may
    prompt you to complete identity verification. The user's identity can be verified
    by either approving the verification request on a trusted device or by entering
    a code generated by the Authenticator app. The verification request can be pushed
    to an authorized Microsoft Account app running on a trusted PC or mobile device
    (an Android version of the app is available). Once the request is approved with
    an app, the new device is added to the list of trusted devices.
  prefs: []
  type: TYPE_NORMAL
- en: The Windows Phone 8 and 8.1 platforms use an offline Microsoft Authenticator
    app that works similarly to Google Authenticator (generating time-sensitive single-use
    codes). The difference between the two types of authentication is that the former
    requires an active Internet connection to receive authentication requests, while
    the latter works completely offline. Both authentication methods can be active
    at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: The different authentication types may not be available on all platforms. Microsoft
    has compiled a comprehensive FAQ on how to configure authentication apps on the
    different mobile platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Identity verification apps**: FAQs at [http://windows.microsoft.com/en-US/Windows/identity-verification-apps-faq](http://windows.microsoft.com/en-US/Windows/identity-verification-apps-faq)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Did you know?** Microsoft and Google offline authentication apps are compatible.
    One can use Microsoft Authenticator running on a Windows Phone device to authenticate
    Google accounts, or Google Authenticator running on iOS or Android to authenticate
    Microsoft accounts.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are types of identity verification apps available on the different
    platforms:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Apple iOS**: It is an offline authenticator. Microsoft recommends using Google
    Authenticator, which is compatible.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Android**: It authenticates apps offline and online. Microsoft Account handles
    online authentication requests, while Google Authenticator can be used to generate
    authentication codes offline.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Windows Phone**: It is an offline authenticator. Microsoft Authenticator
    can be used to verify both Microsoft and Google accounts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Verification methods can be configured at [https://account.live.com/proofs/Manage](https://account.live.com/proofs/Manage)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![Microsoft''s implementation](img/0181.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**More about Microsoft two-step verification**: [http://windows.microsoft.com/en-us/windows/two-step-verification-faq](http://windows.microsoft.com/en-us/windows/two-step-verification-faq)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft allows using two-factor authentication to protect all interactions
    with Microsoft Account. However, the user can choose to only enable this type
    of authentication for accessing sensitive information such as establishing Microsoft
    Account on a Windows 10 device (which automatically enables full access to all
    files synced via Microsoft OneDrive, access to stored passwords, and the ability
    to restore backups including configuration settings and application data).
  prefs: []
  type: TYPE_NORMAL
- en: Apple's two-step verification
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Up until recently, Apple used its very own approach to multi-factor authentication.
    Dubbed as two-step verification ([https://support.apple.com/en-us/HT204152](https://support.apple.com/en-us/HT204152)),
    the extra security layer was only meant to cover certain activities that could
    be performed with the user''s Apple ID. Namely, two-step verification covered
    (and still covers, if you''re dealing with iOS older than 9.0) all of the following
    activities:'
  prefs: []
  type: TYPE_NORMAL
- en: Sign in to Apple ID account page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sign in to iCloud on a new device or at [https://www.icloud.com/](https://www.icloud.com/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sign in to iMessage, Game Center, or FaceTime.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make an iTunes, iBooks, or App Store purchase from a new device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get Apple ID-related support from Apple.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'According to Apple, this is how two-step verification works:'
  prefs: []
  type: TYPE_NORMAL
- en: You enter your Apple ID and password as usual.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Apple sends a verification code to one of your devices.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You enter the code to verify your identity and finish signing in.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Source**: [https://support.apple.com/kb/PH14668?locale=en_US](https://support.apple.com/kb/PH14668?locale=en_US)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Two-step verification only supports a single secondary authentication factor:
    a trusted iOS device. A verification code will be pushed by Apple to a trusted
    device, allowing users to validate requests protected with two-step verification.'
  prefs: []
  type: TYPE_NORMAL
- en: Backup verification methods include SMS verification and an offline **Recovery
    Key** that can be created, printed out, and stored in a safe place.
  prefs: []
  type: TYPE_NORMAL
- en: 'With iOS 9, Apple moved from this proprietary scheme to a different method:
    the more open two-factor authentication.'
  prefs: []
  type: TYPE_NORMAL
- en: Apple's two-factor authentication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since iOS 9, Apple switched from two-step verification to a different, improved
    security mechanism. Apple's two-factor authentication is built directly into iOS
    9, designed to protect access to all the photos, documents, and other important
    data stored with Apple.
  prefs: []
  type: TYPE_NORMAL
- en: Two-factor authentication is being gradually rolled out by Apple to eligible
    users since fall 2015 ([https://support.apple.com/en-us/HT205075](https://support.apple.com/en-us/HT205075)).
    Unlike the older two-step verification, the new two-factor authentication mechanism
    protects iOS devices from the ground up. If two-factor authentication is enabled,
    users will be required to enter a unique, single-use six-digit authentication
    code every time they access their Apple ID from a new device. The code is displayed
    automatically on the user's other devices, or sent to a trusted (and verified)
    phone number ([https://support.apple.com/en-us/HT204915](https://support.apple.com/en-us/HT204915)).
  prefs: []
  type: TYPE_NORMAL
- en: The code is only requested once per device. It remains valid until the user
    signs out completely, erases the device, or changes the password. Web sign-ins
    can be remembered by offering the user an option to trust the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Bypassing Apple's two-factor authentication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When it comes to digital forensics, the secondary authentication factor may
    or may not be available. If the secondary authentication factor is a trusted iOS
    device, being able to unlock the device (by entering the correct passcode) is
    required in order to access the pushed authentication code. Such access may or
    may not be available to the investigator.
  prefs: []
  type: TYPE_NORMAL
- en: When performing cloud acquisition of Apple accounts protected with either two-step
    verification or two-factor authentication, investigators have the ability to bypass
    authentication requirements by using a cached authentication token. The authentication
    token is a piece of cached data that helps authenticate requests to Apple servers
    without requiring the user to enter their credentials every time.
  prefs: []
  type: TYPE_NORMAL
- en: At this time, only authentication tokens produced by Apple iTunes can be used
    to bypass authentication.
  prefs: []
  type: TYPE_NORMAL
- en: 'Comprehensive information on how to acquire and use binary authentication tokens
    to access the user''s iCloud and iCloud Drive data is available in our blog:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Breaking Into iCloud**: No Password Required at [http://blog.elcomsoft.com/2014/06/breaking-into-icloud-no-password-required/](http://blog.elcomsoft.com/2014/06/breaking-into-icloud-no-password-required/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'If no binary authentication token is available, it may still be possible to
    extract the correct Apple ID and password from the computer:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Acquiring and Utilizing Apple ID Passwords, Mitigating the Risks and Protecting
    Personal Information at [http://blog.elcomsoft.com/2015/03/acquiring-and-utilizing-apple-id-passwords-mitigating-the-risks-and-protecting-personal-information/](http://blog.elcomsoft.com/2015/03/acquiring-and-utilizing-apple-id-passwords-mitigating-the-risks-and-protecting-personal-information/).
  prefs: []
  type: TYPE_NORMAL
- en: '**Further reading**: Apple Two-Factor Authentication and the iCloud at [http://blog.elcomsoft.com/2013/05/apple-two-factor-authentication-and-the-icloud/](http://blog.elcomsoft.com/2013/05/apple-two-factor-authentication-and-the-icloud/)
    (published back in 2013, so some things have changed since then).'
  prefs: []
  type: TYPE_NORMAL
- en: Two-factor authentication – a real roadblock
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Two-factor authentication goes a long way towards securing user accounts. Even
    if a weak password is used, third parties may not be able to access information
    protected with two-factor authentication if they don't have physical access to
    the secondary authentication factor.
  prefs: []
  type: TYPE_NORMAL
- en: Two-factor authentication is a roadblock to performing over-the-air acquisition.
    Since acquisition is normally performed on what's considered to be a new device,
    the authentication system will require verifying a user's identity with the second
    factor. As such, tools such as Elcomsoft Cloud Explorer will require entering
    the correct authentication code.
  prefs: []
  type: TYPE_NORMAL
- en: There are exceptions. For example, Apple's authentication tokens can be extracted
    from a previously authorized computer and used with a tool such as Elcomsoft Phone
    Breaker. This allows accessing information stored in the user's iCloud, including
    iOS backups and uploaded files, even without having a trusted device.
  prefs: []
  type: TYPE_NORMAL
- en: Unallocated space
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While we cover the issue of unallocated space separately for each individual
    mobile platform, this chapter gathers all information we have about the issue
    in a single place. In order to allow our readers to use this chapter as a reference,
    we included some information about internal (eMMC) and external (SD card) storage,
    as well as some basic information about encryption and its effect on unallocated
    space. We separately reviewed encryption options available for internal and external
    storage, as their effect on unallocated space can be quite different. If you just
    want an idea on whether or not unallocated space can be recovered from a particular
    device, carry on reading!
  prefs: []
  type: TYPE_NORMAL
- en: The issue of unallocated space
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What happens to information that was deleted from a smartphone? Is there life
    after a full factory reset? Is there anything left on the device after a remote
    wipe? What is the best method to recover information stored in unallocated space;
    what tools and equipment are required? With six major mobile platforms and countless
    variations, there is no single answer to any of those questions. Let's look at
    the issue from the very beginning.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing destroyed evidence in different mobile platforms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At this time, we have several distinctly different mobile platforms: Apple
    iOS, Android, Windows Phone 8, Windows RT, Windows 8/8.1/10, and BlackBerry 10\.
    To say that these platforms handle deleted data differently is not saying much
    at all. Android and iOS are poles apart when it comes to handling deleted data
    and recovering information. Windows Phone 8 is somewhere in between, while Windows
    RT and the full versions of Windows 8/8.1/10 have their own share of issues.'
  prefs: []
  type: TYPE_NORMAL
- en: Apple iOS – impossible
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This chapter is easy to write. Recovering data stored in unallocated space in
    iOS 5 and newer is impossible, even on jailbroken devices. Not even if you send
    it to Apple, and not if you give them the passcode. Once the data is gone, it's
    gone. A factory reset erases everything completely and irrecoverably.
  prefs: []
  type: TYPE_NORMAL
- en: A theoretical concept exists allowing you to restore the state of the filesystem
    to a certain moment in the past. A proof-of-concept tool was developed, but it
    never made it to a truly usable state.
  prefs: []
  type: TYPE_NORMAL
- en: The reason for this is how Apple implements encryption. Since iOS 5, Apple used
    full disk encryption in iOS devices. The decryption keys are only maintained for
    the file system (allocated data blocks). iOS immediately discards decryption keys
    for unallocated (released) data blocks. This means that once a file is deleted,
    decryption keys to those encrypted data blocks are destroyed.
  prefs: []
  type: TYPE_NORMAL
- en: You may be able to extract the complete disk image. You may be able to extract
    decryption keys. But you still won't be able to decrypt unallocated areas because
    there will be no decryption keys for those data blocks. While the actual (encrypted)
    data may still be there, there is absolutely no possibility to decrypt it.
  prefs: []
  type: TYPE_NORMAL
- en: Since no Apple device uses external storage (SD cards), there is no way to recover
    information from SD cards either.
  prefs: []
  type: TYPE_NORMAL
- en: What about *data recovery* tools from the Cydia repository available to users
    of jailbroken devices? Those are fakes. On recent iOS devices, deleted files cannot
    be recovered, and any tool or service offering such recovery is an imposter.
  prefs: []
  type: TYPE_NORMAL
- en: Note that you may still be able to access some recently deleted files by retrieving
    the device's iCloud backups. Since iCloud keeps the three most recent backups,
    downloading the earliest backup with Elcomsoft Phone Breaker ([https://www.elcomsoft.com/eppb.html](https://www.elcomsoft.com/eppb.html))
    may result in finding those files before they've been deleted.
  prefs: []
  type: TYPE_NORMAL
- en: BlackBerry – Iffy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Security is the hallmark of BlackBerry smartphones. While previous versions
    of BlackBerry OS used to offer user-selectable security and data encryption levels,
    this is not the case with the newest BlackBerry 10.
  prefs: []
  type: TYPE_NORMAL
- en: By design, BlackBerry 10 employs optional full-disk encryption activated by
    either the end user or provisioned by the corporate **BES** (**BlackBerry Enterprise
    Server**). There is no jailbreak for BlackBerry 10\. Physical acquisition methods
    for BlackBerry 10 devices are limited (Cellerbrite UFED via a bootloader exploits
    certain devices if no device password is set). There is no way to extract a decrypted
    raw image of an encrypted BlackBerry 10 smartphone. Chip-off acquisition will
    only produce an encrypted disk image; all data will remain securely encrypted.
    The BlackBerry security model is exemplary, and there is no way of accessing (encrypted)
    unallocated space data in BlackBerry 10 smartphones.
  prefs: []
  type: TYPE_NORMAL
- en: In reality, BlackBerry 10 phones sold to end users don't come with encryption
    activated out-of-the-box. Since many users won't bother activating encryption
    (or are concerned with the slower performance of the storage subsystem after encryption),
    we've encountered quite a few BlackBerry 10 smartphones that were not encrypted.
  prefs: []
  type: TYPE_NORMAL
- en: As there is no physical acquisition and no JTAG extraction available on newer
    BlackBerry devices, chip-off is the only extraction method available for BlackBerry
    10 devices. There is no known way to determine if a particular BlackBerry is encrypted
    or not. As a result, the encryption status of a particular BlackBerry 10 phone
    has to be decided on a case by case basis.
  prefs: []
  type: TYPE_NORMAL
- en: SD cards
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some BlackBerry 10 devices can use SD cards for additional storage. Those SD
    cards can be encrypted, or they can be left unencrypted. Unencrypted SD cards
    can be acquired in the usual way. There is nothing available to decrypt the content
    of encrypted SD cards though (unless you instruct the original BlackBerry 10 device
    to do so, which will require you to unlock it first with a passcode).
  prefs: []
  type: TYPE_NORMAL
- en: Samsung devices are known to encrypt SD cards with encryption keys stored in
    the device's internal memory. As a result, encrypted SD cards can only be used
    in the same device. Windows 10 Mobile applies similar technique to encrypt SD
    cards.
  prefs: []
  type: TYPE_NORMAL
- en: Android – possible with limitations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Android is a highly fragmented platform that implements many things in the opposite
    way to iOS. Let's have a look at what happens in Android devices when a file is
    deleted.
  prefs: []
  type: TYPE_NORMAL
- en: Android – built-in storage
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Many Android devices can have two distinctly separate types of memory: built-in
    storage (typically an eMMC chip) and optional external storage (typically a micro
    SD card).'
  prefs: []
  type: TYPE_NORMAL
- en: Before Android 2.3 Gingerbread, Android smartphones commonly used plain flash
    chips as their main storage. A flash-friendly file system called `f2fs` was used
    for wear leveling. Since Android 2.3 and in all later versions, the overwhelming
    majority of Android smartphones use eMMC storage. Typically, the data partition
    is formatted with one of the Linux file systems such as `ext3` or `ext4`, but
    `f2fs` is also frequently encountered. In the past, the YAFFS2 file system was
    also a common choice. Several Samsung models used RFS, a FAT-based file system.
  prefs: []
  type: TYPE_NORMAL
- en: Note that a large number of ultra-budget Chinese smartphones are still manufactured
    equipped with raw NAND chips instead of eMMC flash. While chip-off acquisition
    would allow capturing the complete raw dump of those chips, less advanced acquisition
    such as physical and JTAG is often available on those devices. Such devices are
    relatively rare outside China.
  prefs: []
  type: TYPE_NORMAL
- en: Unencrypted storage
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If the data partition is not encrypted, capturing a full disk image via physical
    acquisition, JTAG, **ISP** (**In-system programming**), or chip-off will enable
    the investigator to perform unallocated space analysis by using a tool supporting
    Linux file systems. Limitations common to all eMMC storage apply (as described
    in the *eMMC and Deleted Data* section). Note that full-disk physical acquisition
    may require rooting the device or using an acquisition tool that can temporarily
    root the device. None of these methods are able to extract overprovisioned areas
    from eMMC chips.
  prefs: []
  type: TYPE_NORMAL
- en: Encrypted storage
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Android is the exact opposite of iOS in many ways, including its approach to
    encryption. As opposed to Apple iOS, which employs full-disk encryption and destroys
    decryption keys for unused blocks, Android encryption is sector-based. As a result,
    if decrypting the user partition was successful, unallocated areas are automatically
    decrypted as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since Android is a highly fragmented platform, OEMs can implement various parts
    of the system in many different ways. Some manufacturers (for example, Samsung)
    are known to vary their implementations widely between devices, even changing
    encryption types on the same device with OTA updates. As a result, it is impossible
    to predict whether or not a particular encrypted partition could be extracted
    via physical acquisition (with or without knowing the right passcode). One thing
    is for certain: encryption can make low-level attacks, such as JTAG and chip-off,
    complicated.'
  prefs: []
  type: TYPE_NORMAL
- en: Encryption in different versions of Android
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Speaking of stock Android, Google implemented encryption as early as Android
    3.0 Honeycomb. However, most OEMs started implementing encryption with effect
    from Android 4.0\. Based on the Linux `dm-crypt`, first-generation encryption
    was easy to brute force. The second version was much tougher to break, but brute-forcing
    passcodes was still possible (by swapping the function to scrypt). Initial implementations
    of Android encryption were inherently insecure, as encryption metadata was stored
    alongside encrypted data.
  prefs: []
  type: TYPE_NORMAL
- en: Samsung used to use stock Android encryption in its early devices. However,
    the company was never happy about its security, so Samsung started experimenting
    with its own implementations. Early implementations of Samsung proprietary encryption
    still kept encryption metadata openly accessible. However, with time the company
    learned to encrypt metadata and moved the master key into a protected area (inaccessible
    during chip-off).
  prefs: []
  type: TYPE_NORMAL
- en: Android 5.0 implements encryption in a way that's very similar to what Samsung
    does. Encryption metadata is now protected with a master key which, in turn, is
    now stored in a protected area inaccessible to chip-off. Google had plans to enforce
    encryption on all devices released with Android 5.x; however, this never materialized,
    and device encryption remains optional on most Android 5.x devices except for
    the Nexus line.
  prefs: []
  type: TYPE_NORMAL
- en: If you manage to pull an unprotected image of the encrypted partition (for example,
    via physical acquisition) or succeed in decrypting a protected image, you may
    be able to gain access to unallocated areas. Note that most encryption implementations
    also implement Trim pass-through, allowing the eMMC controller to clear (erase)
    data blocks that are no longer used. Such data blocks will be apparently visible
    as empty (zeroed) areas. However, since the Trim operation is not instant on eMMC
    controllers (as opposed to most SSD drives), you may still have time to analyze
    and recover data from those unallocated areas.
  prefs: []
  type: TYPE_NORMAL
- en: Android – SD cards
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since many Android devices have SD card slots, and those SD cards are rarely
    encrypted (see the next chapter for details), retrieving and analyzing the external
    SD card is an easy way of recovering information. Naturally, recovering information
    from an SD card is best done by removing the card and inserting it into a micro
    SD reader, in a write-protected manner, connected directly to the investigator's
    computer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since Android is a highly fragmented platform, the many different versions
    of the system (as well as many vendor customizations) implement varying approaches
    as to what types of data can or cannot be stored on an SD card. Android has the
    following policies, which cannot be changed by the user without rooting the device
    but can be overridden by individual OEMs:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Android 2.3, 4.0-4.2**: Apps are allowed to write to the external SD card.
    Many OEM implementations leave external SD cards unprotected. Applications can
    be moved to an SD card. Applications can be installed onto an SD card. Applications
    moved to or installed on the SD card can keep their data on that SD card.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Android 4.4**: Due to changes in security policies, only system apps have
    full access to the external SD card. Regular applications cannot keep data on
    an SD card unless they used the new **SAF** (**Storage Access Framework**) API.
    SD cards can still be used for storing multimedia files (music and videos) or
    keeping information such as map data (for example, HERE Maps).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Android 5.0-5.1**: New APIs (SAF extensions) now allow full access to SD
    card directories and files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Android 6.0**: Access to external storage (SD cards and OTG sticks) integrated
    with internal storage.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The different APIs were introduced in order to secure information stored on
    SD cards. Unlike internal partitions that are usually formatted with ext3 or ext4
    (a file system with built-in permission management and access control), external
    SD cards are normally formatted with FAT32 (SDHC, up to and including 32 GB) or
    exFAT (SDXC, 64GB, and larger cards). Neither of these implement any type of permissions
    or access control, requiring the operating system to take full control of who
    can access what areas on the SD card.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Note**: 64GB (and larger) SDXC cards are formatted with exFAT out of the
    box. You will need an exFAT-compliant tool to recover deleted information and
    analyze unallocated areas on these SD cards. While you can still carve those cards
    with tools not supporting exFAT, such tools will not be able to tell unallocated
    and allocated areas apart, and provide messy results. Do check your tool''s capabilities
    as exFAT support is not a given.'
  prefs: []
  type: TYPE_NORMAL
- en: Android – SD card encryption
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Encrypted SD cards are relatively uncommon in Android phones. Stock Android
    didn't implement the encryption of external SD cards in any version before Android
    M (although SD card encryption will be part of Android M).
  prefs: []
  type: TYPE_NORMAL
- en: Many Samsung phones as well as certain OEM ROMs offer optional SD card encryption.
    The corresponding setting is typically located under **Settings** | **More** |
    **Security** | **Encrypt external SD card** or **Settings** | **Control** | **Security**,
    and can only be activated if the phone is protected with a passcode. Similar to
    internal storage, there is no `full disk` encryption on SD cards. Instead, only
    the file system is encrypted. Unallocated (empty) areas are commonly left unencrypted,
    which, for one, enables investigators to recover deleted information stored on
    SD cards prior to encryption. Samsung devices are known to encrypt SD cards with
    encryption keys stored in the device's internal memory. As a result, encrypted
    SD cards can only be used in the same device that was used to encrypt the card.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Android M implements the new concept of adoptable storage, allowing us to use
    an external SD card or USB drive in the same manner as internal storage. This,
    in particular, means that the same encryption is applicable to adopted external
    storage as it is used to protect the internal storage. More information can be
    found at [http://nelenkov.blogspot.fi/2015/06/decrypting-android-m-adopted-storage.html](http://nelenkov.blogspot.fi/2015/06/decrypting-android-m-adopted-storage.html)
    .
  prefs: []
  type: TYPE_NORMAL
- en: A factory reset renders data stored on an encrypted SD card unusable (even if
    the SD card is stored separately from the device) as the encryption master key
    is destroyed during the reset.
  prefs: []
  type: TYPE_NORMAL
- en: Windows Phone 8 and 8.1 – possible for end-user devices with limitations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Windows Phone is a unique system. All three other systems are Unix-based. Apple
    iOS is based on BSD UNIX, Google Android is based on Linux, and BlackBerry 10
    is based on QNX. Windows Phone 8/8.1, on the other hand, is based on Microsoft
    Windows, and shares its system architecture and the file system (NTFS).
  prefs: []
  type: TYPE_NORMAL
- en: Windows Phone 8/8.1 is a well-balanced operating system that learned a lot from
    Android and iOS. Somewhat similar to iOS, it offers the ability to create cloud
    backups (although these backups contain less information compared to iOS, with
    almost no application data being restored, save for login data). The OS features
    separate data space (sandbox) for each application and leaves no residual garbage
    after removing an app. However, it allows access to shared files (for example,
    music and videos can be played by any supported application and not just that
    one app the user imported the data to), which is similar to Android. Just like
    iOS, Windows Phone does not normally allow installing applications from sources
    other than Windows Store.
  prefs: []
  type: TYPE_NORMAL
- en: Windows Phone devices can be officially developer-unlocked to allow installing
    a limited number of unsigned applications from third-party sources. However, unlike
    in Android, there is no way for a user-installable app to obtain administrative
    access. Since Windows Phone devices cannot be rooted or jailbroken, there is no
    way to install an executable file with administrative-level access either.
  prefs: []
  type: TYPE_NORMAL
- en: As a result, it is impossible to develop a user-level application to launch
    on the phone in order to gain access to unallocated space. The issue is the result
    of both insufficient privileges and missing low-level disk access APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Windows Phone 8/8.1 devices sold to end users don't come with pre-activated
    encryption. Unlike in Android, users cannot manually activate encryption on their
    devices, and there is no encryption option available anywhere in the settings.
    This allows using JTAG and chip-off acquisition methods to extract the device's
    full disk image. In addition, acquisition methods exist that allow reading the
    eMMC chip directly without removing it from the circuit board. Limitations common
    to all eMMC storage will apply (as described in the *eMMC and Deleted Data* section).
    Windows 10 Mobile changed this behavior and allows full user control over encryption
    (and decryption) of the device.
  prefs: []
  type: TYPE_NORMAL
- en: Some Windows Phone 8 devices of fairly recent generations (for example, Nokia
    Lumia 520) can be acquired via physical acquisition by exploiting a bootloader
    hack. Cellerbrite offers a tool (**UFED**) that can perform physical acquisitions
    of selected Windows Phones. Images acquired via this method (if the device is
    not encrypted) will contain full, raw dumps of the phone's storage including unallocated
    areas.
  prefs: []
  type: TYPE_NORMAL
- en: Windows Phone BitLocker encryption
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In general, the Windows Phone OS (versions 8 and 8.1, as well as Windows 10
    Mobile) supports using BitLocker technology to encrypt user data. The technology
    effectively protects information (including unallocated areas) against hardware
    attacks such as JTAG and chip-off extraction.
  prefs: []
  type: TYPE_NORMAL
- en: In Windows Phone 8 and 8.1, end users have no control over device encryption.
    There is no option to activate or deactivate encryption anywhere in the phone
    settings.
  prefs: []
  type: TYPE_NORMAL
- en: In Windows 10 Mobile, Microsoft added a user-accessible Device Encryption setting.
    Interestingly, Microsoft allows both enabling and disabling encryption, allowing
    investigators to actually decrypt encrypted devices with a simple change of a
    setting. Needless to say, any data stored in unallocated space is **permanently
    lost** during the decryption process.
  prefs: []
  type: TYPE_NORMAL
- en: '![Windows Phone BitLocker encryption](img/0182.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Windows 10 Device Encryption
  prefs: []
  type: TYPE_NORMAL
- en: 'Windows Phone devices used in corporate environments will normally have BitLocker
    encryption activated out of the box, according to Microsoft ([https://dev.windowsphone.com/en-US/OEM/docs/Phone_Bring-Up/Secure_boot_and_device_encryption_overview](https://dev.windowsphone.com/en-US/OEM/docs/Phone_Bring-Up/Secure_boot_and_device_encryption_overview)).
    Device encryption is not enabled by default. Device encryption is automatically
    enabled in the following scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: The user adds an Outlook account to the phone, and the Microsoft Exchange server
    that it connects to is configured to require device encryption
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The user connects the phone to a company apps account, and the enterprise device
    management server for the account pushes down a policy to the phone that requires
    device encryption
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In either of these scenarios, the phone automatically begins encrypting the
    main OS and internal user data store partitions after the device encryption policy
    change is configured on the phone. The device encryption work is throttled to
    minimize the impact to end users.
  prefs: []
  type: TYPE_NORMAL
- en: This encryption effectively prevents capturing the full disk image via physical
    acquisition, and makes unallocated space analysis impossible. JTAG/chip-off acquisitions
    can still be done, but becomes useless.
  prefs: []
  type: TYPE_NORMAL
- en: According to Microsoft, *Unlike BitLocker for desktop Windows, there is no recovery
    key backup and no UI option for end users to enable or disable device encryption
    on Windows Phones. Microsoft Exchange servers and enterprise device management
    servers cannot disable device encryption after it has been enabled*.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[https://dev.windowsphone.com/en-US/OEM/docs/Phone_Bring-Up/Secure_boot_and_device_encryption_overview](https://dev.windowsphone.com/en-US/OEM/docs/Phone_Bring-Up/Secure_boot_and_device_encryption_overview)'
  prefs: []
  type: TYPE_NORMAL
- en: Windows Phone SD cards
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many Windows Phone smartphones (with a few exceptions) have support for external
    storage via an SD card slot. The Windows Phone OS implements advanced support
    for external storage, allowing users to not only store music and videos on an
    SD card, but use the external storage to install applications. Unlike in Android,
    this functionality is standard on all Windows Phone devices equipped with an SD
    card slot regardless of OEM. In particular, entry-level Windows Phone devices
    with a limited amount of internal storage (for example, 8 GB models) are very
    likely to have an SD card installed, which makes acquisition easier.
  prefs: []
  type: TYPE_NORMAL
- en: Windows Phone offers no separate options to encrypt the content of SD cards.
    Instead, SD card encryption is triggered by the same corporate policy provisioned
    to the phone, meaning that most end user devices will remain completely unencrypted
    while most corporate devices will have encrypted internal partitions and activated
    encryption for SD cards.
  prefs: []
  type: TYPE_NORMAL
- en: Even if the security policy provisioned to the device demands SD card encryption,
    user files such as photos and videos will remain unencrypted as per Microsoft
    policy.
  prefs: []
  type: TYPE_NORMAL
- en: More information on SD card encryption in Windows Phone 8.1 is available in
    [Chapter 8](ch08.html "Chapter 8\. Acquisition – Approaching Windows 8, 8.1, 10,
    and RT Tablets"), *Acquisition - Approaching Windows 8, 8.1, 10, and RT Tablets*.
  prefs: []
  type: TYPE_NORMAL
- en: Windows RT, Windows 8/8.1, and Windows 10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since Windows RT is a closed platform that does not allow running unsigned desktop
    applications, acquisition options other than sending the device to the manufacturer
    (accompanied with a government request) are limited.
  prefs: []
  type: TYPE_NORMAL
- en: Since most Windows RT devices (as well as many tablets running Windows 8/8.1/10)
    are properly equipped for BitLocker drive encryption, the chance of encountering
    a device with an encrypted system partition is higher. (To recoup, BitLocker full
    disk protection is activated automatically by default, without user intervention,
    if the device is equipped with a TPM module, has non-removable (soldered) RAM,
    and the user logs in with their Microsoft Account as opposed to using a local
    Windows account.) More on BitLocker protection in **BITLOCKER DEVICE ENCRYPTION**.
    Note that BitLocker Recovery Keys can be obtained from Microsoft with a government
    request.
  prefs: []
  type: TYPE_NORMAL
- en: BitLocker encryption is volume-based. On eMMC and SSD drives, BitLocker provides
    trim pass-through, and does not encrypt unallocated space. Released data blocks
    will remain encrypted until they are trimmed by the SSD or eMMC controller.
  prefs: []
  type: TYPE_NORMAL
- en: If BitLocker encryption is not activated, the usual acquisition techniques,
    and all considerations applicable to eMMC in general, will apply. However, Windows
    RT acquisition may be tricky, with chip-off extraction possibly being the best
    possible course of action.
  prefs: []
  type: TYPE_NORMAL
- en: Most Windows RT devices (and practically all Windows 8/8.1 tablets) support
    SD cards. While Windows RT can access (and decrypt) SD cards with BitLocker To
    Go, the system does not come with tools to encrypt the SD card. (Users can still
    encrypt their SD card with a password on a different PC running the full version
    of Windows 8/8.1/10, and use that card, encrypted, with Windows RT.) As a result,
    you will most likely see an unencrypted SD card. Since many Windows and Windows
    RT devices are equipped with barely enough storage to keep Windows installation
    as well as Metro apps (32 GB is barely enough for that purpose), it is very likely
    that the user will have a micro SD card installed.
  prefs: []
  type: TYPE_NORMAL
- en: Note that in *full* (non-RT) versions of Windows, BitLocker To Go is only supported
    in the Pro and Enterprise editions of Windows 8 and 8.1.
  prefs: []
  type: TYPE_NORMAL
- en: Also note that Windows RT and Windows 8/8.1/10 maintain a OneDrive backup of
    the user's documents (if the user is logged in with their Microsoft Account),
    and a full application backup (with app data) is maintained in the user's Microsoft
    Account. Providing that the user's Microsoft Account login and password are known,
    examiners can extract information from the cloud. Alternatively, a government
    request can be sent to Microsoft to obtain information they have including all
    BitLocker Recovery Keys stored in the cloud.
  prefs: []
  type: TYPE_NORMAL
- en: eMMC and deleted data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the few things that all mobile devices have in common is the choice of
    the type of internal storage. All Apple smartphones and tablets, most Android
    devices since Android 2.3 Gingerbread, all BlackBerry 10 smartphones, Windows
    Phone 8, Windows RT, and a lot of Windows 8/8.1 tablets use eMMC chips as their
    storage.
  prefs: []
  type: TYPE_NORMAL
- en: '**eMMC** stands for **embedded MMC**, or **embedded MultiMedia Card**. To put
    it simply, eMMC is a non-removable memory card that is soldered onto a circuit
    board. Unlike *plain* flash memory chips, the eMMC standard uses a combination
    of NAND modules and an integrated storage controller built into a single chip.
    It is the storage controller that makes things so different to traditional storage
    media when it comes to recovering deleted information.'
  prefs: []
  type: TYPE_NORMAL
- en: In broad general terms, the embedded storage controller takes care of all the
    reading and writing operations. In addition (and this is the important part),
    the eMMC specification defines a number of maintenance routines designed to maintain
    performance and keep flash memory in good health in a way that's very similar
    to how SSD drives perform.
  prefs: []
  type: TYPE_NORMAL
- en: eMMC and SSD – similarities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Technically speaking, eMMC memory is similar to SSD drives in that it relies
    on solid-state NAND flash chips to store data, and uses an integrated controller
    to perform read, writes, and all maintenance operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'NAND flash chips used in both eMMC and SSD drives have two inherent properties:'
  prefs: []
  type: TYPE_NORMAL
- en: Solid-state storage based on NAND flash chips can only write data to an empty
    block. If the block contains information, it must be erased before it can accept
    new data. Erasing a non-empty block is much slower compared to writing into an
    empty one. These properties are shared between eMMC and SSD drives because they
    use underlying physical media of the same type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NAND flash chips have a limited lifespan. Each cell can only sustain a finite
    number of writes. Every time new data is written to a cell, the cell starts leaking
    slightly more current than before. After a certain number of write cycles, the
    leak will become significant enough to severely affect the ability of the cell
    to retain data. Most manufacturers rate their flash cells to a certain number
    of write operations, assuming three-month data retention while powered off.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because of the underlying technology, the eMMC standard defines performance
    optimization and wear leveling measures similar to those used in SSD drives. Overprovisioning,
    instant remapping, wear leveling, trim, and background garbage collection are
    properties of both eMMC and SSD drives. This, in turn, means that we'll observe
    issues with eMMC media self-destructing evidence as a result of those background
    processes.
  prefs: []
  type: TYPE_NORMAL
- en: However, despite similarities, eMMC and SSD drives implement those technologies
    differently, still retaining remnants of information even after it's been deleted.
  prefs: []
  type: TYPE_NORMAL
- en: eMMC and SSD – differences
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The main technical difference between eMMC memory and SSD drive is not the type,
    but the number of NAND flash chips used. SSD drives are so much faster compared
    to eMMC, not because they employ special types of ultra-fast flash memory (yet,
    in general, manufacturers tend to pick higher-quality chips for SSD drives compared
    to eMMC modules). Instead, SSD drives are equipped with multiple flash chips working
    in parallel. As a result, their controllers have the ability to read and write
    data from (or to) several flash cells at the same time. This ability dramatically
    increases SSD performance compared to single-chip solutions.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we can see, SSD drives are equipped with faster, smarter, and much more
    complex controllers. These controllers are also much larger, taking more space
    and consuming more energy. eMMC chips are built for different requirements. Used
    in portable, battery-powered devices, they must be small and power-efficient.
    As a result, not only are they not equipped with parallel operations, but they
    employ simplified versions of some of the maintenance algorithms used in SSD drives.
    This includes:'
  prefs: []
  type: TYPE_NORMAL
- en: Unlike SSD drives, eMMC controllers may not start erasing trimmed data immediately.
    In many cases, deleted data may remain intact even after the trim command has
    been issued. For example, many Android phones will only trim data upon shutdown.
    For the purpose of forensic extraction, this means that eMMC chips may maintain
    deleted data for longer than SSD drives.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unlike SSD drives, the eMMC standard does not define a deterministic trim. Used
    in SSD drives, **DRAT** (**Deterministic Read After Trim**) defines that the controller
    will return the same data for all trimmed blocks. Its extended version **DZAT**
    (**Deterministic Zero After Trim**) means that the SSD controller will return
    all zeroes on any attempt to read trimmed blocks—even of the physical blocks that
    have not yet been erased. Now, eMMC controllers are NOT equipped with a deterministic
    trim. For that reason, the controller will return the actual content of the cell—even
    if it's marked as trimmed. For the purpose of mobile forensics, this means that
    deleted data can be stored in a recoverable state for a much longer time compared
    to SSD drives.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overprovisioning and remapping
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Of particular interest are overprovisioning (the fact that a memory chip has
    more physical storage than advertised to the outside world) and remapping (the
    ability of the embedded controller to instantly reassign logical addresses to
    different physical blocks).
  prefs: []
  type: TYPE_NORMAL
- en: Overprovisioning is used by manufacturers as a means to increase write performance
    and the effective lifespan of the flash storage. The controller can instantly
    push a logical data block out of service and into the overprovisioned area, where
    that block will be erased and prepared for future service. Importantly, overprovisioned
    data blocks are non-addressable and not accessible by any means except by the
    controller. There is no way to extract data blocks from the overprovisioned area
    by any logical or physical means. JTAG and chip-off acquisition methods will *only*
    return addressable space because they work through the eMMC controller (instead
    of accessing the NAND flash chips directly). The possibility of reading data directly
    off NAND chips is more of a theoretical one. It can be done, but at great expense
    and requiring extremely complex hardware.
  prefs: []
  type: TYPE_NORMAL
- en: Overprovisioned data blocks in eMMC chips are not accessible to any data recovery
    program or app. They will not become part of a raw image or dump. Overprovisioned
    areas remain invisible during JTAG and chip-off acquisition because JTAG and chip-off
    requests are served by the controller integrated into the eMMC chip (as opposed
    to directly accessing NAND flash chips). If the device is equipped with plain
    flash chips, JTAG, using the Boundary Scan technique or chip-off acquisition,
    will return the entire content of those chips complete with overprovisioned areas.
  prefs: []
  type: TYPE_NORMAL
- en: Overprovisioned blocks can be pulled to service by the controller integrated
    into the eMMC chip. The controller can instantly assign a logical address to any
    healthy physical block, including overprovisioned blocks. This, in turn, can mean
    that data block(s) belonging to a deleted file can be instantly pushed into the
    overprovisioned area by means of data remapping, while an already erased physical
    block will correspond to the logical address that used to belong to a deleted
    file.
  prefs: []
  type: TYPE_NORMAL
- en: User data in overprovisioned areas
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ve been asked this question: *Have you determined if any user data is also
    found in this space? Is this like the bad sectors on the older NAND flash that
    may have contained older-dated user data that could only be obtained through chip-off?
    Or does the eMMC Controller allow user data to be stored there and one requires
    a process to gain access to these areas using chip-off, ISP, or JTAG?*'
  prefs: []
  type: TYPE_NORMAL
- en: It is important to understand what overprovisioned space is, and what it isn't.
  prefs: []
  type: TYPE_NORMAL
- en: In the context of eMMC chips, an overprovisioned area represents a number of
    extra storage blocks that are not advertised as available storage capacity. These
    blocks don't have physical addresses that could be used by the OS to access. There
    is no standard way or process to gain access to them from the outside world. Only
    the eMMC controller embedded into the chip has access to these blocks. However,
    no standard mechanisms, commands, or processes are defined by the eMMC standard
    that could be used to make the controller dump the contents of the overprovisioned
    area.
  prefs: []
  type: TYPE_NORMAL
- en: 'Overprovisioned blocks can be one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Bad blocks**: Each and every eMMC chip, with no exceptions, contains a number
    of bad memory blocks out-of-the-factory. These are permanently mapped out. If
    any particular NAND block expires (reaches the maximum number of allowable write
    cycles) or gets bad, it can be permanently overprovisioned. Its physical address
    will be assigned to one of the healthy blocks from the overprovisioned area.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Trimmed (erased) blocks**: These are commonly used by the controller as quick
    substitutes for dirty blocks marked for trimming. If this happens, the controller
    maps the dirty block out of the addressable space, and assigns its address to
    a fresh block from the overprovisioned area.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dirty blocks**: These blocks still contain information, waiting for their
    turn to be cleaned (trimmed, erased). Eventually, these blocks will be erased;
    however, there is no defined timeframe, so there is no way to know if a certain
    block will be erased at any particular time. If (or when) these blocks will be
    actually trimmed depends on the make and model of a particular eMMC chip, the
    controller used, and the current I/O load.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As can be seen, overprovisioned blocks may still contain user data. Due to the
    nature of eMMC chips, accessing the actual NAND flash modules is extremely difficult,
    and not possible without precise equipment.
  prefs: []
  type: TYPE_NORMAL
- en: Due to the constraints of eMMC, we've never been able to access a real, raw
    dump of the NAND chip (as opposed to dumps obtained via chip-off). However, our
    experience with SSD drives (which do contain individual NAND chips that can be
    dumped) suggests that there can be remnants of user data scattered around in both
    addressable trimmed blocks as well as in the overprovisioned area.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of portable electronic devices, this will be actual user data as
    opposed to system files. In smartphones and tablets, system files are predominantly
    read-only and are not normally shuffled around or deleted, unless a recent OTA/firmware
    update was applied.
  prefs: []
  type: TYPE_NORMAL
- en: To conclude this chapter, it must be said that acquiring the content of overprovisioned
    areas (by capturing raw physical dumps of the NAND chips) is so complicated, yet
    the amount of potential user data is so negligible that the process is hardly
    worth it, except under extreme circumstances.
  prefs: []
  type: TYPE_NORMAL
- en: Delete operations on non-encrypted eMMC drives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once a file is deleted from an unencrypted eMMC volume, the operating system
    will make changes to the file system to indicate that certain sectors (defined
    on a file system level) are no longer in use. The operating system will also send
    the Trim command to the eMMC controller, telling the device that certain physical
    data blocks are no longer used. The eMMC controller then assigns the special *do
    not care* status to those data blocks. So far, it's been pretty straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: 'What happens next depends on the particular eMMC controller and its internal
    programs. As we mentioned earlier, NAND flash cells can be written much faster
    if previously erased (they must be erased before they can be written to). As a
    result, the eMMC controller will do two things:'
  prefs: []
  type: TYPE_NORMAL
- en: The controller will schedule trimmed blocks to be emptied (erased) to prepare
    them for accepting new data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The controller may remap those data blocks, assigning their logical addresses
    to already-emptied physical blocks. Those already-emptied data blocks can be taken
    from available (addressable) blocks, or pulled from the overprovisioned area.
    Such remapping has two goals: it allows the system to write new data to that logical
    address immediately without waiting for it to be erased (increasing effective
    write speeds), and allows the controller to write data to flash cells with the
    least number of write cycles on them (regardless of those cells'' physical addresses).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a result, the operating system (or any application attempting to read that
    particular sector) may discover that sectors belonging to a recently deleted file
    have become empty in an instant—much faster in fact that it takes for the flash
    chip to actually erase data.
  prefs: []
  type: TYPE_NORMAL
- en: As a forensic expert, you may wonder what happens to those data blocks that
    still contain information from that deleted file. Those data blocks can be remapped
    to another logical address (meaning that you should be able to carve the file
    after taking a full dump of the eMMC chip). Alternatively, those data blocks could
    be pushed out of the addressable space and placed into an overprovisioned area,
    where the integrated controller will erase their content in the background. If
    those data blocks end up in the overprovisioned area, there is no feasible way
    of extracting their content—even if you use JTAG or chip-off extraction.
  prefs: []
  type: TYPE_NORMAL
- en: eMMC conclusion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we start discussing the particular implementations of the different mobile
    platforms, we can already conclude that recovering unallocated space is going
    to be difficult and not always possible due to the underlying technology. The
    chances to retrieve information from an eMMC chip are substantially higher compared
    to the situation with SSD drives, but significantly lower compared to traditional
    hard drives or flash-based storage media without integrated controllers.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, there still is a chance to recover deleted data from unallocated
    space... if the mobile operating system does not prevent it in one way or another.
  prefs: []
  type: TYPE_NORMAL
- en: SD cards
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many Android phones, most Windows Phone 8, Windows RT, Windows 8/8.1 devices,
    and BlackBerry 10 phones are equipped with micro SD card slots to allow users
    to increase available storage capacity. Depending on the platform, certain limitations
    apply as to what types of data the users are allowed to keep on an SD card. For
    example, the Windows Phone 8 platform enables full, unrestricted use of an SD
    card including an option to install applications, while the different versions
    of Android implement strikingly different policies to external storage.
  prefs: []
  type: TYPE_NORMAL
- en: SD cards are frequently used to store multimedia files (music and videos), Camera
    Roll, offline maps (for example, HERE Maps or other navigation applications),
    and additional data (for example, extra files belonging to larger games). In Android,
    not all applications are able to use external storage to keep their data.
  prefs: []
  type: TYPE_NORMAL
- en: Just like eMMC chips, SD cards are a combination of NAND flash chips and an
    integrated microcontroller. However, the built-in storage controller is much simpler
    than that of an eMMC drive. SD card controllers do have address remapping (as
    per manufacturing limitations, each NAND chip in every SD card contains a large
    number of unusable, faulty blocks that are simply mapped out); however, trimming
    erased data in the background is not part of the Secure Digital standard. As a
    result, data that belongs to files deleted from an unencrypted SD card will normally
    remain accessible until overwritten with new information.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Note:** SDHC/SDXC specifications include support for **flash erase**, the
    command that permanently erases the content of data blocks. While some standard-sized
    SD cards support **flash erase**, mobile devices use the "micro" variety of SD
    cards. microSD cards are built to different specifications compared to standard-size
    SD cards. In particular, microSD cards do not support **flash erase**, meaning
    that background garbage collection is not possible. microSD cards do not support
    automatic wiping of released data blocks.'
  prefs: []
  type: TYPE_NORMAL
- en: Another thing to note is the use of the file system. micro SD cards that conform
    to the SDHC standard (up to and including 32 GB cards) come formatted with FAT32,
    while the SDXC standard requires the use of exFAT, a new file system from Microsoft
    that lifts the 4 GB limitation for maximum file size. Microsoft collects licensing
    fees for supporting exFAT. This is the reason for many Android devices only supporting
    SD cards up to 32 GB (more often than not, these same devices will support a 64
    GB memory card if reformatted to FAT32). At the same time, even the cheapest Windows
    Phones support SDXC memory cards with exFAT.
  prefs: []
  type: TYPE_NORMAL
- en: SD card encryption
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Many mobile platforms have the ability to encrypt the content of external storage
    including micro-SD cards. While encryption policies and implementations vary widely
    among the different ecosystems, two things are in common between all of them:'
  prefs: []
  type: TYPE_NORMAL
- en: SD cards are almost never encrypted out of the box. The user (or system administrator,
    if the device is managed by a corporate policy) must explicitly encrypt the content
    of an SD card.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SD card encryption is practically never full-disk encryption. This means that,
    when the user encrypts the SD card, only the file system is encrypted. Any free
    space (which may or may not contain remnants of deleted data) is left over.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other than that, the following policies are observed.
  prefs: []
  type: TYPE_NORMAL
- en: Apple iOS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: SD card support is not available in any Apple iOS device.
  prefs: []
  type: TYPE_NORMAL
- en: Android
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Users can manually encrypt SD cards. Factory reset typically wipes the content
    of internal memory; the content of an external SD card is rarely wiped, although
    data becomes inaccessible after the wipe due to encryption metadata being destroyed.
    This behavior may be different due to platform fragmentation and various OEM implementations.
  prefs: []
  type: TYPE_NORMAL
- en: Most implementations make encryption of multimedia files (pictures, videos,
    and music) on SD cards optional. This opens the possibility for carving deleted
    pictures and videos from the SD card.
  prefs: []
  type: TYPE_NORMAL
- en: If an Android device has an SD card mounted, the system and some applications
    may automatically use the SD card to store information. For example, Foursquare
    keeps parts of its data on an SD card by default, while WhatsApp uses the SD card
    to create backups. HERE Maps and some other navigation tools can be configured
    to store maps, voices, and parts of their data on an SD card. There are many more
    applications that use SD cards to keep data, which enables experts to carve the
    content of an SD card for evidence.
  prefs: []
  type: TYPE_NORMAL
- en: Since Android does not come with the ability to format SD cards with a Linux
    file system such as ext3 or ext4, the majority of SD cards used in Android devices
    are formatted with either FAT32 (SDHC, cards up to and including 32 GB) or exFAT
    (SDXC, 64 GB and larger SD cards). Neither file system comes with access control
    or permission management. This, as well as the fact that the SD card can be easily
    removed, made some developers employ proprietary encryption to protect files stored
    on an SD card by their applications. This can become an extra obstacle when analyzing
    unallocated space from an SD card.
  prefs: []
  type: TYPE_NORMAL
- en: Windows Phone 8/8.1
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Windows Phone 8.1 supports the ability to install apps on an SD card. According
    to Microsoft documentation ([http://download.microsoft.com/download/B/9/A/B9A00269-28D5-4ACA-9E8E-E2E722B35A7D/Windows-Phone-8-1-Security-Overview.pdf](http://download.microsoft.com/download/B/9/A/B9A00269-28D5-4ACA-9E8E-E2E722B35A7D/Windows-Phone-8-1-Security-Overview.pdf)),
    apps and their data are stored on a hidden partition on the SD card. If encryption
    is enabled on the device by the corresponding policy, this partition will be encrypted
    just like the internal storage. Notably, personal content such as photos and videos
    is stored on the SD card in an unencrypted partition so that the user can access
    the SD card on other devices. As a result, unallocated space can be carved at
    least for the unencrypted partition even if encryption is activated.
  prefs: []
  type: TYPE_NORMAL
- en: In reality, we were unable to prove the existence of a special hidden partition
    on Windows Phone 8.1 devices. Installing applications onto an SD card inserted
    into a Windows phone provisioned to support encryption has always resulted in
    clearly visible files and folders being created on the main partition on that
    card. The entire content of these folders, complete with application binaries,
    their data, and temporary files, was accessible in plain view. After a system
    update pushed by Microsoft in late 2014, the system fixed that behavior by enabling
    per-file encryption. The entire file system can still be browsed through, and
    filenames and sizes are visible, yet the content of those files is now encrypted.
    This behavior is significantly different from the mechanism described in the Microsoft
    whitepaper. Other researchers (for example, [http://www.insinuator.net/2015/01/in-secure-sd-cards-on-wp8-1/](http://www.insinuator.net/2015/01/in-secure-sd-cards-on-wp8-1/))
    received similar results, so it's unlikely that our experience was an isolated
    incident.
  prefs: []
  type: TYPE_NORMAL
- en: It is essential that Windows Phone 8.x does not allow users to encrypt their
    devices (or SD cards) with a setting within the phone's menu. There is no such
    option available. Encryption can only be activated as provisioned by the corporate
    security policy (if the phone is used in a corporate environment and connected
    to an MDM system).
  prefs: []
  type: TYPE_NORMAL
- en: A factory reset may not render the SD card inaccessible since encryption escrow
    keys may be available in the MDM system.
  prefs: []
  type: TYPE_NORMAL
- en: Windows 10 Mobile
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Windows 10 Mobile introduced the ability for end users to control device and
    SD card encryption. Users now have an option to encrypt and decrypt (!) the internal
    memory. A separate encryption option is available for SD cards.
  prefs: []
  type: TYPE_NORMAL
- en: Windows RT
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Windows RT supports a somewhat restricted version of BitLocker that does not
    allow encrypting the SD card in a Windows RT device, but does allow using an already
    encrypted card (for example, if one was encrypted in a computer running the full
    version of Windows). Considering the number of Windows RT devices sold, the chances
    of encountering an encrypted SD card in one of those are slim to none.
  prefs: []
  type: TYPE_NORMAL
- en: Notably, a full factory reset of a Windows RT system will neither wipe the content
    of an SD card nor render the data inaccessible since information is encrypted
    with a password and can be accessed again if the correct password has been entered.
  prefs: []
  type: TYPE_NORMAL
- en: Windows 8 through 10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While most tablets running Windows 8, 8.1, and Windows 10 support BitLocker
    full disk protection (for encrypting partitions in the main eMMC storage), BitLocker
    To Go (for encrypting external storage such as USB flash drives and SD cards with
    a password) is only available in the Pro and Enterprise editions of Windows 8
    and 8.1 and Windows 10 Pro. Since many budget Windows tablets use the most basic
    edition of Windows with Bing, SD card encryption is not available to their users
    (yet, similar to Windows RT, they can still access BitLocker-protected SD cards
    that were encrypted on a higher Windows edition that supports BitLocker). Even
    if the SD card is encrypted, BitLocker To Go only encrypts the file system, leaving
    unallocated space unencrypted. (This has changed in Windows 10, with the option
    to encrypt the entire content of the SD card now available.)
  prefs: []
  type: TYPE_NORMAL
- en: Notably, a full factory reset of a Windows system will neither wipe the content
    of an SD card nor render the data inaccessible since information is encrypted
    with a password and can be accessed again if the correct password has been entered.
  prefs: []
  type: TYPE_NORMAL
- en: BlackBerry OS 1 through 7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Early versions of BlackBerry OS offered three distinct options to encrypt SD
    cards:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the device key
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the password
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the device key and the password
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the exception of the first encryption method, passwords can be attacked
    and recovered, and backups can be decrypted.
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to SD encryption, the decryption key can be extracted from a physical
    image or chip-off dump of the device. Early versions of BlackBerry OS (prior to
    BlackBerry 10) used to have a security flaw related to encrypted SD cards. Encryption
    metadata could be derived by analyzing the content of the encrypted SD card and
    brute-forcing the security key. This weakness (used, for example, in Elcomsoft
    Phone Breaker) allowed investigators to decrypt encrypted partitions dumped from
    the device itself in addition to the content of the SD card itself. Effectively,
    the option to encrypt the content of an SD card became the system's Achilles heel.
    This, however, is no longer the case in BlackBerry 10.
  prefs: []
  type: TYPE_NORMAL
- en: BlackBerry 10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: SD card encryption is optional in BlackBerry 10, even if the device is configured
    to encrypt its main memory. A factory reset destroys encryption metadata, rendering
    the content of such an SD card completely inaccessible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Below is a comparison table of SD card encryption in various systems:'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | **Enabled by default** | **User configurable** | **Algorithm** | **Known
    vulnerabilities** |'
  prefs: []
  type: TYPE_TB
- en: '| **Android** | No | Yes | Version specific, AES | None |'
  prefs: []
  type: TYPE_TB
- en: '| **BlackBerry OS 1-7** | No | Yes | Depends on user selectable settings |
    In some scenarios, attacking encrypted SD can recover device passcode |'
  prefs: []
  type: TYPE_TB
- en: '| **BlackBerry 10** | No | Yes | AES | None |'
  prefs: []
  type: TYPE_TB
- en: '| **Windows Phone 8.x** | No | No | BitLocker | Some versions don''t enable
    encryption, but claim encryption is enabled |'
  prefs: []
  type: TYPE_TB
- en: '| **Windows 10 Mobile** | No | Yes | BitLocker | None |'
  prefs: []
  type: TYPE_TB
- en: '| **Windows RT** | No | No; must use different PC to encrypt (depends on Windows
    edition); can use already encrypted SD cards | BitLocker | None |'
  prefs: []
  type: TYPE_TB
- en: '| **Windows 8 through 10** | No | Yes, depends on Windows edition | BitLocker
    | None |'
  prefs: []
  type: TYPE_TB
- en: SD cards conclusion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While SD cards are equipped with an integrated storage controller, the built-in
    controllers are of a simple variety. While supporting data remapping, SD card
    controllers do not implement trim, which means that deleted data will remain available
    in unallocated areas, just like on most USB drives. The same acquisition methods
    that work for USB flash drives will work for SD cards. SDHC cards (up to and including
    32 GB) are typically formatted with FAT32\. Do note that larger SDXC cards (64
    GB and up) come pre-formatted with exFAT, and will require a carving tool supporting
    that file system.
  prefs: []
  type: TYPE_NORMAL
- en: It is essential to note that mobile devices (smartphones and tablets) accept
    microSD cards as opposed to standard-size SD cards. microSD are built to different
    specifications compared to standard-size SD cards. In particular, microSD cards
    do not support the **flash erase** command, meaning no background collection and
    no automatic wiping of released data blocks.
  prefs: []
  type: TYPE_NORMAL
- en: SQLite databases (access to call logs, browsing history, and many more)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A special case (accessing deleted data on mobile platforms) applies to information
    stored inside SQLite databases. SQLite is a universally accepted database format
    employed by countless system and third-party apps running on all popular mobile
    platforms. Android and iOS keep call logs, message history, Web browsing logs,
    and many system settings in SQLite databases. Applications such as Chrome, Firefox,
    Skype, WhatsApp, and countless others also use SQLite.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike files deleted from encrypted partitions, records deleted from SQLite
    databases may not immediately disappear. In a naive attempt to counter forensic
    efforts, users may clear call history, delete message logs, and clear the browsing
    history. These measures may not be as effective as users think.
  prefs: []
  type: TYPE_NORMAL
- en: The reason for these measures being unreliable is the way in which SQLite deletes
    records. Due to performance considerations, SQLite does not wipe deleted records
    (which can be quite big) unless flushed. Instead, the actual data is not moved
    anywhere. SQLite modifies pointers to deleted records to manifest that those records
    are now stored in a so-called **freelist**. By using a forensic SQLite analysis
    tool (for example, Belkasoft Evidence Center or Elcomsoft Phone Viewer), one can
    access and parse the database container, successfully extracting deleted records
    from the freelist and viewing them along with existing data.
  prefs: []
  type: TYPE_NORMAL
- en: Regularly cleaning call logs and removing text messages helps users maintain
    the illusion of privacy, while in fact deleted records may not immediately disappear.
    Instead, these records might be placed into a freelist. Records can be kept in
    the freelist for a long time—much longer in fact than most users realize because
    new calls and text messages that could potentially trigger a cleanup are relatively
    infrequent.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we had a look at the obstacles, special cases, and considerations
    when acquiring mobile devices. We reviewed SD card encryption and learned about
    the issues of unallocated space in flash-based storage media. We also reviewed
    the differences between two-factor authentication methods implemented in all major
    mobile ecosystems. The next chapter will present case studies and list forensic
    tools that can be used to acquire and analyze mobile devices.
  prefs: []
  type: TYPE_NORMAL
