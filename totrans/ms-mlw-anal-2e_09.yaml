- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Reversing Bytecode Languages – .NET, Java, and More
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反向字节码语言 – .NET、Java及更多
- en: The beauty of cross-platform compiled programs is in their flexibility as you
    don’t need to spend lots of effort porting each program to different systems.
    In this chapter, we will learn how malware authors are trying to leverage these
    advantages for malicious purposes. In addition, you will be provided with an arsenal
    of techniques and tools whose aim is to make analysis quick and efficient.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 跨平台编译程序的美妙之处在于它们的灵活性，因为你无需花费大量精力将每个程序移植到不同的系统上。在本章中，我们将学习恶意软件作者如何利用这些优势进行恶意用途。此外，你将获得一系列旨在使分析快速高效的技术和工具。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: The basic theory of bytecode languages
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字节码语言的基本理论
- en: .NET explained
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET解释
- en: .NET malware analysis
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET恶意软件分析
- en: The essentials of Visual Basic
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Basic的基本要点
- en: Dissecting Visual Basic samples
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解析Visual Basic示例
- en: The internals of Java samples
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java示例的内部
- en: Analyzing compiled Python threats
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析编译的Python威胁
- en: The basic theory of bytecode languages
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字节码语言的基本理论
- en: .NET, Java, Python, and many other languages are designed to be cross-platform.
    The corresponding source code doesn’t get compiled into an assembly language (such
    as Intel, ARM, and so on), but gets compiled into an intermediate language that
    is called bytecode language. Bytecode language is a type of language that’s close
    to assembly languages, but it can easily be executed by an interpreter or compiled
    on the fly into a native language (this depends on the CPU and operating system
    it is getting executed in) in what’s called **Just-in-Time** (**JIT**) compiling.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: .NET、Java、Python等许多语言设计为跨平台。相应的源代码不会被编译成汇编语言（如Intel、ARM等），而是被编译成一种称为字节码语言的中间语言。字节码语言类似于汇编语言，但可以轻松地由解释器执行或即时编译成本地语言（这取决于CPU和操作系统）。这种编译方式称为**即时编译**（**JIT**）。
- en: Object-oriented programming
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 面向对象编程
- en: Most of these bytecode languages follow state-of-the-art technologies in the
    programming and development fields. They implement what’s called **object-oriented
    programming** (**OOP**). If you’ve never heard of it, OOP is based on the concept
    of **objects**. These objects contain properties (sometimes called fields or attributes)
    and contain procedures (sometimes called functions or methods). These objects
    can interact with each other.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数这些字节码语言遵循编程和开发领域的最新技术。它们实现了所谓的**面向对象编程**（**OOP**）。如果你以前没听说过，OOP基于**对象**的概念。这些对象包含属性（有时称为字段或属性）和包含过程（有时称为函数或方法）。这些对象可以相互交互。
- en: 'Objects can be different instances of the same design or blueprint, which is
    known as a **class**. The following diagram shows a class for a car and different
    instances or objects of that class:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 对象可以是相同设计或蓝图的不同实例，这称为**类**。下图显示了汽车类及其不同的实例或对象：
- en: '![Figure 9.1 – A car class and three diﬀerent objects'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.1 – 一个汽车类和三个不同的对象'
- en: '](img/Figure_9.1_B18500.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.1_B18500.jpg)'
- en: Figure 9.1 – A car class and three diﬀerent objects
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1 – 一个汽车类和三个不同的对象
- en: In this class, there are attributes such as fuel and speed, as well as methods
    such as `accelerate()` and `stop()`. Some objects could interact with each other
    and call these methods or directly modify the attributes.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个类中，有诸如燃料和速度之类的属性，以及诸如`accelerate()`和`stop()`之类的方法。一些对象可以相互交互并调用这些方法或直接修改这些属性。
- en: Inheritance
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继承
- en: Another important concept to understand is inheritance. Inheritance allows a
    subclass to inherit (or include) all the attributes and methods that are included
    in the parent class (with the code inside). This subclass can have more attributes
    or methods, and it can even reimplement a method included in the parent class
    (sometimes called a super or superclass).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的概念是继承。继承允许子类继承（或包含）父类中包含的所有属性和方法（包括内部的代码）。这个子类可以拥有更多的属性或方法，甚至可以重新实现父类中包含的方法（有时称为超类或父类）。
- en: Polymorphism
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多态性
- en: Inheritance allows one class to represent many different types of objects in
    what’s called polymorphism. A `Shape` class can represent different subclasses,
    such as `Line`, `Circle`, `Square`, and others. A drawing application can loop
    through all `Shape` objects (regardless of their subclasses) and execute a `paint()`
    method to paint them on the screen or the program canvas without having to deal
    with each class separately.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 继承使得一个类能够在所谓的多态中表示多种不同类型的对象。一个`Shape`类可以表示不同的子类，例如`Line`、`Circle`、`Square`等。一个绘图应用程序可以遍历所有`Shape`对象（无论它们的子类是什么），并执行`paint()`方法，将它们绘制到屏幕或程序画布上，而无需单独处理每个类。
- en: Since the `Shape` class has the `paint()` method and each of its subclasses
    has an implementation of it, it becomes much easier for the application to just
    execute the `paint()` method, regardless of its implementation.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`Shape`类具有`paint()`方法，并且它的每个子类都有该方法的实现，因此应用程序只需执行`paint()`方法，而无需关心其具体实现，这样就变得更加简单。
- en: .NET explained
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .NET 解释
- en: .NET languages (mainly C# and VB.NET) are languages that were designed by Microsoft
    to be cross-platform. The corresponding source code is compiled into a bytecode
    language, originally named **Microsoft Intermediate Language** (**MSIL**), which
    is now known as **Common Intermediate Language** (**CIL**). This language gets
    executed by the **Common Language Runtime** (**CLR**), which is an application
    virtual machine that provides memory management and exception handling.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: .NET语言（主要是C#和VB.NET）是微软设计的跨平台语言。相应的源代码被编译成字节码语言，最初命名为**Microsoft Intermediate
    Language**（**MSIL**），现在被称为**Common Intermediate Language**（**CIL**）。此语言由**Common
    Language Runtime**（**CLR**）执行，CLR是一个应用程序虚拟机，提供内存管理和异常处理。
- en: .NET file structure
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: .NET文件结构
- en: The .NET file structure is based on the PE structure that we described in [*Chapter
    3*](B18500_03.xhtml#_idTextAnchor084), *Basic Static and Dynamic Analysis for
    x86/x64*. The .NET structure starts with a PE header that contains the last but
    one entry in the data directory pointing to .NET’s special **CLR header** (**COR20
    header**).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: .NET文件结构基于我们在[*第3章*](B18500_03.xhtml#_idTextAnchor084)中描述的PE结构，*x86/x64的基本静态和动态分析*。
    .NET结构以PE头开始，包含数据目录中的倒数第二个条目，指向.NET的特殊**CLR头**（**COR20头**）。
- en: .NET COR20 header
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: .NET COR20头
- en: 'The `.text` section and contains basic information about the .NET file, as
    shown in the following screenshot:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`.text`部分，包含有关.NET文件的基本信息，如以下截图所示：'
- en: '![Figure 9.2 – CLR header (COR20 header) and CLR streams'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.2 – CLR头（COR20头）和CLR流'
- en: '](img/Figure_9.2_B18500.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.2_B18500.jpg)'
- en: Figure 9.2 – CLR header (COR20 header) and CLR streams
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2 – CLR头（COR20头）和CLR流
- en: 'Some of the values of this structure are as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 该结构的一些值如下：
- en: '**cb**: Represents the size of the header (always 0x48)'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**cb**：表示头的大小（始终为0x48）'
- en: '**MajorRuntimeVersion** and **MinorRuntimeVersion**: Always with values of
    2 and 5 (even with runtime 4)'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MajorRuntimeVersion**和**MinorRuntimeVersion**：始终为2和5（即使是运行时4）'
- en: '**Metadata address and size**: This contains all the CLR streams, which will
    be described later'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**元数据地址和大小**：包含所有CLR流，稍后将详细描述'
- en: '`0x6000012` value, we have the following:'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0x6000012`值，我们得到了以下内容：'
- en: '`#~` stream (we will talk about streams in detail later). In the following
    screenshot, we can see that it corresponds to the `Methods` table.'
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`#~`流（我们稍后会详细讨论流）。在以下截图中，我们可以看到它对应于`Methods`表。'
- en: '`Main`:'
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Main`：'
- en: '![Figure 9.3 – The entry point method in the methods table in the ﬁrst stream,
    #~'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.3 – 第一流中的方法表中的入口点方法，#~'
- en: '](img/Figure_9.3_B18500.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.3_B18500.jpg)'
- en: 'Figure 9.3 – The entry point method in the methods table in the ﬁrst stream,
    #~'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3 – 第一流中的方法表中的入口点方法，#~
- en: Now, let’s talk about streams.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来谈谈流。
- en: Metadata streams
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 元数据流
- en: 'Metadata contains five sections that are similar to the PE file sections, but
    they are called streams. The streams’ names start with `#` and are as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 元数据包含五个部分，它们类似于PE文件的部分，但称为流。流的名称以`#`开头，具体如下：
- en: '`Methods` table has an ID of 0x6).'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Methods`表的ID是0x6）。'
- en: '`#~` stream. This includes the methods’ names, classes’ names, and so on. Here,
    each item starts with its length, followed by the string, and then the next item’s
    length followed by the string, and so on.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`#~`流。此流包括方法名称、类名称等。每个条目以其长度开始，接着是字符串，然后是下一个条目的长度，再接着是字符串，依此类推。'
- en: '`#Strings` stream, but it contains the strings that are used by the application
    itself, as shown in the following screenshot (with the same structure of item
    length followed by the string):'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 9.4 – The #US Unicode string started with the length and was followed
    by the actual string'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.4_B18500.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.4 – The #US Unicode string started with the length and was followed
    by the actual string'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '**#GUID**: Stores the unique identifiers (GUIDs).'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`#US` and `#Strings`, but it contains all Binary data related to the application.
    It has the same format as the item length, followed by the data blob.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, this is the structure of the .NET application. Now, let’s look at how to
    distinguish the .NET application from other executable files.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: How to identify a .NET application from PE characteristics
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first way that a .NET PE file can be identified is by using a **PEiD**
    or **CFF Explorer** that includes signatures that cover .NET applications, as
    shown in the following screenshot:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.5 – PEiD detecting that malware is a .NET application'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.5_B18500.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.5 – PEiD detecting that malware is a .NET application
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: 'The second way is to check the import table inside the data directory. .NET
    applications always import only one API, which is `_CorExeMain` from `mscoree.dll`,
    as shown here:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.6 – .NET application import table'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.6_B18500.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.6 – .NET application import table
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you can check the last but one (15th) entry in the data directory,
    which represents the CLR header. If it’s populated (that is, contains values other
    than `NULL`), then it’s a .NET application, and this should be a CLR header (you
    can use CFF Explorer to check that).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: The CIL language instruction set
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The CIL (also known as MSIL) language is quite similar to **Reduced Instruction
    Set Computer** (**RISC**) assembly languages. However, it doesn’t include any
    registers, and all the variables, classes, fields, methods, and so on are accessed
    through their ID in the streams and their tables. Local variables are also accessed
    through their ID in methods. Most of the code is based on loading variables and
    constants into the stack, performing an operation (whose result is stored on the
    stack), and popping this result back into a local variable or field in an object.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: This language consists of a set of opcodes and arguments for these opcodes (if
    necessary). Most of the opcodes take up 1 byte. Let’s take a look at the instructions
    in this language.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: Pushing into stack instructions
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are many instructions for storing values or IDs in the stack. These can
    be accessed later by an operation or stored in another variable. Here are some
    examples of them:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18500_09_Table1.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
- en: Important Note
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: For all the instructions that take an ID, they take an ID in a 2-byte form.
    There is a shorter version of them that has the `.s` suffix added to them, which
    takes an ID in a 1-byte form.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: 'The instructions that deal with the constants or elements of an array (`ldc`
    and `ldelem`) take a suffix that describes the type of that value. Here are the
    used types:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18500_09_Table2.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
- en: Now, let’s learn how to pull a value from the stack out into another variable
    or field.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: Pulling out a value from the stack
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here are the instructions that let you pull out (pop) a value or a reference
    from the stack into another variable or field:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18500_09_Table3.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
- en: Important Note
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: The instructions that take IDs also have a shorter version with the `.s` suffix.
    Some instructions, such as `stind` and `stelem`, may have a value type suffix
    as well (such as `.i4` or `.r8`).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: Mathematical and logical operations
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The CIL language implements the same operations that you will see in any assembly
    language, such as `add`, `sub`, `shl`, `shr`, `xor`, `or`, `and`, `mul`, `div`,
    `not`, `neg`, `rem` (the remainder from a division), and `nop` (for no operation).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: These instructions take their arguments from the stack and save the result back
    into the stack. These can be stored in a variable using any store instruction
    (such as `stloc`).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: Branching instructions
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is the last important set of instructions to learn. These instructions
    are related to branching and conditional jumps. These instructions are not so
    different from the assembly languages either, but they depend on the stack values
    for comparing and branching:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18500_09_Table4.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
- en: Now, let’s put this knowledge into practice and learn how the source code would
    translate into these instructions.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: CIL language into higher-level languages
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we’ve discussed the various IL language instructions and the key differentiating
    factors of a .NET application, as well as its file structure. In this section,
    we will take a look at how these higher-level languages (VB.NET, C#, and others),
    as well as their statements, branches, and loops, get converted into CIL language.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: Local variable assignments
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here is an example of setting a local variable value with a constant value
    of `10`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This will be converted into the following:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Easy peasy.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: Local variable assignment with a method return value
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here is another more complicated example that shows you how to call a method,
    push its arguments to the stack, and store the return value in a local variable
    (here, it’s calling a static method from a class directly and not a virtual method
    from an object):'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The intermediate code looks like this:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Basic branching statements
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For `if` statements, the C# code looks like this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The corresponding IL code will look like this (here, we are adding the line
    numbers for branching instructions):'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: These instructions will also help us understand the next topic – loops.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Loops statements
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The last example we will cover in this section is the `for` loop. This statement
    is more complicated than `if` statements and even more complicated than the `while`
    statement for loops. However, it’s more widely used in C#, and understanding it
    will help you understand other complicated statements in the IL language. The
    C# code looks like this:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本节中讲解的最后一个示例是`for`循环。这个语句比`if`语句复杂，甚至比`while`语句的循环还要复杂。然而，它在C#中使用广泛，理解它将有助于你理解IL语言中的其他复杂语句。C#代码如下：
- en: '[PRE6]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The equivalent IL code will look like this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 等效的IL代码如下：
- en: '[PRE7]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: That’s it for the .NET file structure and IL language. Now, let’s learn how
    to analyze .NET malware.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是.NET文件结构和IL语言的介绍。现在，让我们学习如何分析.NET恶意软件。
- en: .NET malware analysis
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .NET恶意软件分析
- en: As you may know, .NET applications are easy to disassemble and decompile so
    that they become as close to the original source code as possible. This leaves
    malware more exposed to reverse engineering. We will describe multiple obfuscation
    techniques in this section, together with the deobfuscation process. First, let’s
    explore the available tools for .NET reverse engineering.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，.NET应用程序很容易被反汇编和反编译，以尽可能接近原始源代码。这使得恶意软件更容易受到逆向工程的攻击。我们将在本节中描述多种混淆技术，并介绍去混淆过程。首先，让我们探索用于.NET逆向工程的工具。
- en: .NET analysis tools
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: .NET分析工具
- en: 'Here are the most well-known tools for decompiling and analysis:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一些最知名的反编译和分析工具：
- en: '**ILSpy**: This is a good decompiler for static analysis, but it can’t debug
    malware.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ILSpy**：这是一个很好的静态分析反编译工具，但它不能调试恶意软件。'
- en: '**dnSpy**: Based on ILSpy and dnlib, it’s a disassembler and decompiler that
    also allows you to debug and patch code.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**dnSpy**：基于ILSpy和dnlib，它是一个反汇编器和反编译器，还可以让你调试和修补代码。'
- en: '**.NET reflector**: A commercial decompiler tool for static analysis and debugging
    in Visual Studio.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**.NET reflector**：一款用于静态分析和Visual Studio调试的商业反编译工具。'
- en: '**.NET IL Editor (DILE)**: Another powerful tool that allows you to disassemble
    and debug .NET applications.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**.NET IL Editor (DILE)**：另一个强大的工具，允许你反汇编和调试.NET应用程序。'
- en: '**dotPeek**: A tool that’s used to decompile malware into C# code. It’s good
    for static analysis and for recompiling and debugging with the help of Visual
    Studio.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**dotPeek**：一款用于将恶意软件反编译为C#代码的工具。它适用于静态分析，并且在Visual Studio的帮助下可以重新编译和调试。'
- en: '**Visual Studio**: Visual Studio is the main IDE for .NET languages. It allows
    you to compile the source code and debug .NET applications.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Visual Studio**：Visual Studio是.NET语言的主要IDE。它允许你编译源代码并调试.NET应用程序。'
- en: '**SOSEX**: A plugin for WinDbg that simplifies .NET debugging.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SOSEX**：一个用于WinDbg的插件，可以简化.NET调试。'
- en: 'Here are the most well-known deobfuscation tools:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是最著名的去混淆工具：
- en: '**de4dot**: Based on dnlib as well, it is very useful for deobfuscating samples
    that have been obfuscated by known obfuscation tools'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**de4dot**：同样基于dnlib，它非常适用于去除已知混淆工具混淆的样本。'
- en: '**NoFuserEx**: A deobfuscator for the ConfuserEx obfuscator'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**NoFuserEx**：一个用于ConfuserEx混淆器的去混淆工具'
- en: '**Detect It Easy (DiE)**: A good tool for detecting.NET obfuscators'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Detect It Easy (DiE)**：一款用于检测.NET混淆器的优秀工具。'
- en: In the following examples, we are going to mainly use the dnSpy tool.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们将主要使用dnSpy工具。
- en: Static and dynamic analysis
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态和动态分析
- en: Now, we will learn how to perform static analysis and dynamic analysis, and
    then patch the sample to delete or modify the obfuscator code.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将学习如何进行静态分析和动态分析，然后对样本进行修补，以删除或修改混淆代码。
- en: .NET static analysis
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: .NET静态分析
- en: 'Multiple tools can help you disassemble and decompile a sample, and even convert
    it completely into C# or VB.NET source code. For example, you can use **dnSpy**
    to decompile a sample by just dragging and dropping it into the application interface.
    This is what this application looks like:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 多种工具可以帮助你反汇编和反编译样本，甚至将其完全转换为C#或VB.NET源代码。例如，你可以通过将样本拖放到应用程序界面中，使用**dnSpy**进行反编译。以下是该应用程序的界面：
- en: '![Figure 9.7 – Static analysis of a malicious sample with dnSpy'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.7 – 使用dnSpy对恶意样本进行静态分析'
- en: '](img/Figure_9.7_B18500.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.7_B18500.jpg)'
- en: Figure 9.7 – Static analysis of a malicious sample with dnSpy
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.7 – 使用dnSpy对恶意样本进行静态分析
- en: You can click on **File** | **Export To Project** to export the decompiled source
    code into a Visual Studio project. Now, you can read the source code, modify it,
    write comments on it, or modify the names of the functions for better analysis.
    dnSpy can show the actual IL language of the sample if you right-click and choose
    **Edit IL Language** from the menu.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以点击**文件** | **导出为项目**将反编译的源代码导出为Visual Studio项目。现在，你可以阅读源代码、修改代码、写注释，或者修改函数名称以便更好的分析。如果你右键点击并从菜单中选择**编辑IL语言**，dnSpy还可以显示样本的实际IL语言。
- en: To go to the main function, you can right-click on the program (from the sidebar)
    and choose `OnRun`, `OnStartup`, or `OnCreateMainForm`, as well as in forms. When
    analyzing code associated with forms, start from their constructor (`.ctor`) and
    pay attention to what function is being added to `base.Load`, as well as what
    functions are called after this. Some methods, such as the form’s `OnLoad` method,
    may be overridden as well.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 要跳转到主函数，你可以右键点击程序（从侧边栏），选择`OnRun`、`OnStartup`或`OnCreateMainForm`，以及在表单中进行选择。当分析与表单相关的代码时，从它们的构造函数（`.ctor`）开始，并注意哪些函数被添加到`base.Load`中，以及在此之后调用了哪些函数。一些方法，例如表单的`OnLoad`方法，可能也会被重写。
- en: Another tool that you could use is **dotPeek**. It’s a free tool that can also
    decompile a sample and export it to C# source code. It has a very similar interface
    to Visual Studio. You can also analyze the CIL language using IDA.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用另一个工具——**dotPeek**。它是一个免费的工具，也可以将样本反编译并导出为C#源代码。它的界面与Visual Studio非常相似。你还可以使用IDA分析CIL语言。
- en: 'Finally, a standard `ildasm.exe` tool can disassemble and export the IL code
    of a sample:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，标准的`ildasm.exe`工具可以反汇编并导出样本的IL代码：
- en: '[PRE8]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: .NET dynamic analysis
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: .NET动态分析
- en: For debugging, there are fewer tools to use. dnSpy is a complete solution when
    it comes to static and dynamic analysis. It allows you to set breakpoints and
    step into and step over for debugging. It also shows the variables’ values.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在调试过程中，可用的工具较少。dnSpy是一个完整的解决方案，适用于静态和动态分析。它允许你设置断点，并进行单步调试。它还会显示变量的值。
- en: To start debugging, you need to set a breakpoint on the entry point of the sample.
    Another option is to export the source code to C#, and then recompile and debug
    the program in Visual Studio, which will give you full control over the execution.
    Visual Studio also shows the variables’ values and has lots of features to facilitate
    debugging.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始调试，你需要在样本的入口点设置一个断点。另一种选择是将源代码导出为C#，然后在Visual Studio中重新编译并调试程序，这样你将完全控制程序的执行。Visual
    Studio还会显示变量的值，并具有许多有助于调试的功能。
- en: 'If the sample is too obfuscated to debug or export to C# code by dotPeek or
    Dnspy, you can rely on `ildasm.exe` to export the sample code in IL language and
    use `ilasm.exe` to compile it again with debug information. Here is how to recompile
    it with `ilasm.exe`:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果样本经过了过度混淆，无法通过dotPeek或Dnspy进行调试或导出为C#代码，可以依赖`ildasm.exe`将样本代码导出为IL语言，并使用`ilasm.exe`重新编译并包含调试信息。下面是使用`ilasm.exe`重新编译的步骤：
- en: '[PRE9]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: With the `/debug` argument, a `.pdb` file for the sample has been created, which
    includes its debug information.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`/debug`参数，已经为该样本创建了一个`.pdb`文件，其中包含了调试信息。
- en: Patching a .NET sample
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: .NET样本的修补
- en: There are multiple ways to modify the sample code for deobfuscating, simplifying
    the code, or forcing the execution to go through a specific path. The first option
    is to use the dnSpy patching capability. In dnSpy, you can edit any method or
    class by right-clicking, selecting **Edit Method (C#)**, modifying the code, and
    recompiling. You can also export the whole project, modify the source code, go
    to **Edit Method (C#)**, and click on the C# icon to import a source code file
    to be compiled by replacing the original code of that class. You can also modify
    the malware source code (after exporting) in Visual Studio and recompile it for
    debugging.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方法可以修改样本代码，用于去混淆、简化代码或强制执行特定路径。第一种选择是使用dnSpy的修补功能。在dnSpy中，你可以通过右键点击任何方法或类，选择**编辑方法（C#）**，修改代码后重新编译。你也可以导出整个项目，修改源代码，进入**编辑方法（C#）**，点击C#图标导入源代码文件，并替换该类的原始代码进行编译。你还可以在Visual
    Studio中修改恶意代码源（导出后），并重新编译以便调试。
- en: 'In dnSpy, you can modify the local variables’ names by selecting **Edit IL
    Instruction** from the menu and selecting **Locals** to modify them by their local
    variable names, as shown in the following screenshot. Concerning the classes and
    methods, you can modify their names just by updating them using the **Edit Method
    (C#)** or **Edit Class (C#)** options:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.8 – Editing local variables in dnSpy'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.8_B18500.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.8 – Editing local variables in dnSpy
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: You can also edit the IL code directly by selecting **Edit IL Instruction**
    and modifying the instructions. This allows you to choose the instruction and
    the field or variable you want to access.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with obfuscation
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will look at different common obfuscation techniques for
    .NET samples and learn how to deobfuscate them.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Obfuscated names for classes, methods, and others
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the most common obfuscation techniques is to obfuscate the names of the
    classes, methods, variables, fields, and so on – basically everything that has
    a name.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: Obfuscation can get even harder if you obfuscate the names into other alphabets
    or other symbols (since the names are in Unicode), such as Chinese or Japanese.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: 'You can try to deobfuscate such samples automatically by running the **de4dot**
    deobfuscator from the command line, like so:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This will rename all the obfuscated names, as shown in the following screenshot
    (the HammerDuke sample is shown here):'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.9 – The Hammerduke malware before and after running de4dot to deobfuscate
    the names'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.9_B18500.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.9 – The Hammerduke malware before and after running de4dot to deobfuscate
    the names
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: You can also rename the methods manually to add more meaningful names by right-clicking
    on the method and then selecting **Edit Method** or clicking *Alt* + *Enter* and
    changing the name of the method. After that, you need to save the module and reload
    it for the changes to be put into effect.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: You can also edit local variable names by right-clicking on the method and choosing
    **Edit Method Body** or **Edit IL Instructions** and choosing **Locals**.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: Encrypted strings inside the Binary
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Another common technique used by .NET malware is encrypting its strings. This
    approach hides these strings from signature-based tools, as well as from less
    experienced malware analysts. Working with encrypted strings requires finding
    the decryption function and setting a breakpoint on each of its calls, as shown
    in the following screenshot:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.10 – The Samsam ransomware encrypted strings getting decrypted in
    memory'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.10_B18500.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.10 – The Samsam ransomware encrypted strings getting decrypted in memory
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, there are hard-to-reach encrypted strings, so you may not see them
    decrypted in the default execution of the malware – for example, because the C&C
    is down, or maybe there are additional C&C addresses that won’t get decrypted
    if the first C&C is working. In these cases, you can do any of the following:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，会有难以访问的加密字符串，因此你可能不会在恶意软件的默认执行过程中看到它们被解密——例如，因为 C&C 服务器无法连接，或者可能存在额外的 C&C
    地址，在第一个 C&C 正常工作的情况下这些地址不会被解密。在这些情况下，你可以执行以下操作：
- en: 'You can try to use de4dot to decrypt the encrypted strings by giving it the
    method ID. You can find the method ID by checking the `Methods` table in the `#~`
    stream, as shown in the following screenshot:'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以尝试使用 de4dot 通过提供方法 ID 来解密加密字符串。你可以通过检查 `#~` 流中的 `Methods` 表来找到方法 ID，如下图所示：
- en: '![Figure 9.11 – The Samsam ransomware myﬀ11() decryption function, ID 0x0600000C'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.11 – Samsam 勒索病毒 myﬀ11() 解密函数，ID 0x0600000C'
- en: '](img/Figure_9.11_B18500.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.11_B18500.jpg)'
- en: Figure 9.11 – The Samsam ransomware myﬀ11() decryption function, ID 0x0600000C
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.11 – Samsam 勒索病毒 myﬀ11() 解密函数，ID 0x0600000C
- en: 'Then, you can decrypt the strings dynamically using the following command:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以使用以下命令动态解密字符串：
- en: '[PRE11]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You can modify the entry point code and add a call to the decryption function
    to decrypt the strings. The preceding screenshot is created by repointing calls
    to the decryption functions, including the encrypted strings. For dnSpy to process
    this code, you must use these strings by changing an object field or calling `System.Console.Writeline()`
    to print that string to the console. You will need to save the module after modifying
    it and reopen it for the changes to be put into effect.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以修改入口点代码并添加调用解密函数的代码来解密字符串。前面的截图是通过重新指向对解密函数的调用，包括加密字符串，生成的。为了让 dnSpy 处理此代码，你必须通过更改对象字段或调用
    `System.Console.Writeline()` 将字符串打印到控制台来使用这些字符串。你需要在修改后保存模块，并重新打开它以使更改生效。
- en: Another option is to export the whole malware source code from dnSpy by clicking
    on **File** | **Export To Project** (other tools may have similar functionality),
    modifying it, and then recompiling it with Visual Studio before debugging it.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选择是通过点击 **文件** | **导出到项目**（其他工具也可能有类似功能）将整个恶意软件源代码从 dnSpy 导出，进行修改，然后在 Visual
    Studio 中重新编译并调试它。
- en: The sample is obfuscated using an obfuscator
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 样本使用混淆器进行混淆
- en: 'There are many .NET obfuscators publicly available. They are generally supposed
    to be used for protecting intellectual property, but they are also commonly used
    by malware authors to protect their samples from reverse engineering. There are
    multiple tools for detecting known packers, such as **Detect It Easy** (**DiE**),
    as shown in the following screenshot:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多公开可用的 .NET 混淆器。它们通常用于保护知识产权，但也常被恶意软件作者用来保护他们的样本免受逆向工程。有多种工具可以检测已知的打包器，如 **Detect
    It Easy**（**DiE**），如下图所示：
- en: '![Figure 9.12 – Detect it Easy detecting the obfuscator (ConfuserEx) used to
    protect against malware'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.12 – 使用 **Detect It Easy** 检测保护恶意软件的混淆器（ConfuserEx）'
- en: '](img/Figure_9.12_B18500.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.12_B18500.jpg)'
- en: Figure 9.12 – Detect it Easy detecting the obfuscator (ConfuserEx) used to protect
    against malware
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.12 – 使用 **Detect It Easy** 检测保护恶意软件的混淆器（ConfuserEx）
- en: You can also use the de4dot tool to detect the obfuscator by only running the
    `de4dot.exe -d <sample>` command or deobfuscate the sample using the `de4dot.exe
    <sample>` command.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用 de4dot 工具通过运行 `de4dot.exe -d <sample>` 命令来检测混淆器，或者使用 `de4dot.exe <sample>`
    命令解混淆样本。
- en: For custom and unknown obfuscators, you will need to go through debugging and
    patching processes to deal with them. Before doing so, check different sources,
    if there are solutions or deobfuscators for it. If the obfuscator is shareware,
    you may be able to communicate with the authors and get their aid to deobfuscate
    the sample (as these obfuscators are not designed to help malware authors protect
    their samples).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 对于自定义和未知的混淆器，你需要通过调试和修补过程来处理它们。在此之前，请检查不同的资源，看是否有相关的解决方案或解混淆工具。如果该混淆器是共享软件，你可能可以与作者联系并获得他们的帮助来解混淆样本（因为这些混淆器并非为了帮助恶意软件作者保护他们的样本而设计的）。
- en: Compile after delivery and proxy code execution
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编译后交付并代理代码执行
- en: Instead of distributing malicious .NET binaries directly, attackers may also
    attempt to dynamically compile the malicious payload on the victim’s machine using
    the standard `csc.exe` utility. This approach is commonly used with the help of
    scripts, which we will cover in the next chapter.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: In addition, attackers may use the standard `InstallUtil.exe` tool to load malicious
    .NET samples instead of executing them directly. The main advantage of this approach
    for attackers is the fact that in this case, all the associated activity will
    be done on behalf of the signed legitimate application. It is important to know
    that in this case, the execution of the loaded module will start from the class
    inherited from the standard `System.Configuration.Install.Installer` class.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: Dynamically loaded code blocks
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Sometimes, malware may decrypt or decode the next block of code and load it
    dynamically using, for instance, the standard `AppDomain.CurrentDomain.Load` method.
    In this case, it is possible to reach the first instruction of this payload in
    dnSpy by stepping into this method and tracing the code until the `UnsafeInvokeInternal`
    -> `RuntimeMethodHandle.InvokeMethod` control transfer point is reached. Here
    is an example from the AgentTesla malware:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.13 – Transferring control to the payload inside AppDomain.CurrentDomain.Load'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.13_B18500.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.13 – Transferring control to the payload inside AppDomain.CurrentDomain.Load
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: Once the first line of the embedded payload is reached, dnSpy will handle the
    rest, decompiling this newly introduced block of code and adding it to the **Assembly
    Explorer** panel to be used for static analysis.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: That’s it for .NET-based malware; we have learned everything we need to know
    to start analyzing the corresponding samples efficiently. Now, let’s talk about
    threats written in Visual Basic.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: The essentials of Visual Basic
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Visual Basic is a high-level programming language developed by Microsoft and
    based on the BASIC family of languages. Initially, its main feature was its ability
    to quickly create graphical interfaces and good integration with the COM model,
    which fostered easy access to **ActiveX Data Objects** (**ADOs**).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: The last version of it was released in 1998 and the extended support for it
    ended in 2008\. However, all modern Windows operating systems keep supporting
    it and, while it is rarely used by APT actors, many mass malware families are
    still written on it. In addition, many malicious packers use this programming
    language, often detected as Vbcrypt/VBKrypt or something similar. Finally, **Visual
    Basic for Applications** (**VBA**), which is still widely used in Microsoft Office
    applications and was even upgraded to version 7 in 2010, is largely the same language
    as VB6 and uses the same runtime library.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will dive into two different compilation modes supported
    by the latest version of Visual Basic (which is 6.0 at the time of writing) and
    provide recommendations on how to analyze samples using them.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: File structure
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The compiled Visual Basic samples look like standard MZ-PE executables. They
    can easily be recognized by a unique imported DLL, `MSVBVM60.DLL` (`MSVBVM50.DLL`
    was used for the older version). PEiD tool is generally very good at identifying
    this programming language (when the sample is not packed, obviously):'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.14 – PEiD identifying Visual Basic'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.14_B18500.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.14 – PEiD identifying Visual Basic
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: 'At the entry point of the sample, we can expect to see a call to the `ThunRTMain`
    (`MSVBVM60.100`) runtime function:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.15 – Entry point of the Visual Basic sample'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.15_B18500.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.15 – Entry point of the Visual Basic sample
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Thun` prefix here is a reference to the original project’s name, **BASIC
    Thunder**. This function receives a pointer to the following structure:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18500_09_Table5.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
- en: 'Now, let’s take a look at the `ProjectInfo` structure:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18500_09_Table6.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
- en: Here, one of the most interesting fields is `NativeCode`. This field can be
    used to figure out whether the sample has been compiled as p-code or native code.
    Now, let’s see why this information is important.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: P-code versus native code
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Starting from Visual Basic 5, the language supports two compilation modes:
    p-code and native code (before p-code was the only option). To understand the
    differences between them, we need to understand what p-code is.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '`P-code`, which stands for packed code or pseudocode, is an intermediate language
    with an instruction format similar to machine code. In other words, it is a form
    of bytecode. The main reason behind introducing it is to reduce the program’s
    size at the expense of execution speed. When the sample is compiled as p-code,
    the bytecode is interpreted by the language runtime. In contrast, the native code
    option allows developers to compile a sample into the usual machine code, which
    generally works faster but takes up more space because of multiple overhead instructions
    being used.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: It is important to know which mode the analyzed sample is compiled in as it
    defines what static and dynamic analysis tools should be used. As for how to distinguish
    them, the easiest way would be to look at the `NativeCode` field we mentioned
    previously. If it is set to `0`, this means that the p-code compilation mode is
    being used. Another indicator here is that the difference between the `CodeEnd`
    and `CodeStart` values will only be a few bytes maximum as there will be no native
    code functions.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: 'One more (less reliable) approach is to look at the import table:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '`MSVBVM60.DLL`, which provides access to all the necessary VB functions:'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 9.16 – The import table of the Visual Basic sample compiled in p-code
    mode'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.16_B18500.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.16 – The import table of the Visual Basic sample compiled in p-code
    mode
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '`MSVBVM60.DLL`, there will also be the typical system DLLs such as `kernel32.dll`
    and the corresponding import functions:'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 9.17 – The import table of the Visual Basic sample compiled in native
    code mode'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.17_B18500.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.17 – The import table of the Visual Basic sample compiled in native
    code mode
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: 'A quick way to distinguish between these modes is to load a sample into a free
    **VB Decompiler Lite** program and take a look at the code compilation type (marked
    in bold) and the functions themselves. If the instructions there are typical x86
    instructions, then the sample has been compiled as native code; otherwise, p-code
    mode has been used:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.18 – P-code versus native code samples in VB Decompiler Lite'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.18_B18500.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.18 – P-code versus native code samples in VB Decompiler Lite
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: We will cover this tool in greater detail in the next section.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: Common p-code instructions
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Multiple basic opcodes take up 1 byte (`0x00-0xFA`); the bigger 2-byte opcodes
    that start with a prefix byte from the `0xFB`-`0xFF` range are used less frequently.
    Here are some examples of the most common p-code instructions that are generally
    seen when exploring VB disassembly:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: 'Data storage and movement:'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LitStr/LitVarStr`: Initializes a string'
  id: totrans-238
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LitI2/LitI4/...`: Pushes an integer value to the stack (often used to pass
    arguments)'
  id: totrans-239
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FMemLdI2/FMemLdRf/...`: Loads values of a particular type (memory)'
  id: totrans-240
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Ary1StI2/Ary1StI4/...`: Puts values of a particular type into an array'
  id: totrans-241
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Ary1LdI2/Ary1LdI4/...`: Loads values of a particular type from an array'
  id: totrans-242
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FStI2/FStI4/...`: Puts a variable value into the stack'
  id: totrans-243
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FLdI2/FLdI4/...`: Loads a value into a variable from the stack'
  id: totrans-244
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FFreeStr`: Frees a string'
  id: totrans-245
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ConcatStr`: Concatenates a string'
  id: totrans-246
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NewIfNullPr`: Allocates space if null'
  id: totrans-247
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Arithmetic operations:'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AddI2/AddI4/...`: Adding operation'
  id: totrans-249
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SubI2/SubI4/...`: Subtraction operation'
  id: totrans-250
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MulI2/MulI4/...`: Multiplication operation'
  id: totrans-251
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DivR8`: Division operation'
  id: totrans-252
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OrI4/XorI4/AndI4/NotI4/...`: Logical operations'
  id: totrans-253
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Comparison:'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EqI2/EqI4/EqStr/...`: Check if equal'
  id: totrans-255
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NeI2/NeI4/NeStr/...`: Check if not equal'
  id: totrans-256
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GtI2/GtI4/...`: Check if greater than'
  id: totrans-257
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LeI2/LeI4/...`: Check if less than or equal to'
  id: totrans-258
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Control flow:'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VCallHresult/VCallAd(VCallI4)/...`: Calls a function'
  id: totrans-260
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ImpAdCallI2/ImpAdCallI4/...`: Calls an import function (API)'
  id: totrans-261
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Branch/BranchF`: Branches when the condition is met'
  id: totrans-262
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: There are many more of these. If some new opcode is not clear to you and you
    need to understand its functionality, it can be found in the unofficial documentation
    (not very detailed) or explored in the debugger.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the most common abbreviations used in opcode names:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '`Ad`: Address'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Rf`: Reference'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Lit`: Literal'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Pr`: Pointer'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Imp`: Import'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Ld`: Load'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`St`: Store'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`C`: Cast'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DOC`: Duplicate opcode'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All the common data type abbreviations that are used are pretty much self-explanatory:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '`I`: Integer (`UI1` – byte, `I2` – integer, `I4` – long)'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`R`: Real (`R4` – single, `R8` – double)'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Bool`: Boolean'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Var`: Variant'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Str`: String'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Cy`: Currency'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While it may take some time to get used to their notations, there aren’t that
    many variations, so after a while, it becomes pretty straightforward to understand
    the core logic. Another option would be to invest in a proper decompiler and avoid
    dealing with p-code instructions. We will cover this later.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: Dissecting Visual Basic samples
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have gained some knowledge of the essentials of Visual Basic, it’s
    time to shift our focus and learn how to dissect Visual Basic samples. In this
    section, we are going to perform a detailed static and dynamic analysis.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: Static analysis
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The common part of VB malware is that the code generally gets executed as part
    of the `SubMain` routine and event handlers, where timer and form load events
    are particularly typical.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: As we have already mentioned, the choice of tools will be defined by the compilation
    mode that’s used when creating a malware sample.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: P-code
  id: totrans-287
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For p-code samples, **VB Decompiler** can be used to get access to its internals.
    The Lite version is free and provides access to the p-code disassembly, which
    may be enough for most cases. If the engineer doesn’t have enough expertise or
    time to deal with the p-code syntax, then the paid full version provides a powerful
    decompiler that produces more readable Visual Basic source code as output:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.19 – The same p-code function in VB Decompiler disassembled and
    decompiled'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.19_B18500.jpg)'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.19 – The same p-code function in VB Decompiler disassembled and decompiled
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: 'Another popular option is the **P32Dasm** tool, which allows you to obtain
    p-code listings in a few clicks:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.20 – P32Dasm in action'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.20_B18500.jpg)'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.20 – P32Dasm in action
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: One of its useful features is its ability to produce MAP files that can later
    be loaded into OllyDbg or IDA using dedicated plugins. Its documentation also
    mentions the Visual Basic debugger plugin for IDA, but it doesn’t seem to be available
    to the general public.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: A hint for first-time users – if necessary, put all requested `.ocx` files (can
    be downloaded separately if not available) into the P32Dasm’s root directory to
    make it work.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: Native code
  id: totrans-299
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For samples compiled as native code, any Windows static analysis tool we’ve
    already discussed will do the trick. In this case, the solutions that can effectively
    apply structures (such as IDA, Binary Ninja, or radare2) can save time:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.21 – The beginning of the native code after applying the ProjectInfo
    structure'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.21_B18500.jpg)'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.21 – The beginning of the native code after applying the ProjectInfo
    structure
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: 'VB Decompiler can be used to quickly access the names of procedures without
    digging into VB structures. For IDA, a free `SubMain` function by taking the address
    of the VB header (as we know, it is passed to the `ThunRTMain` function in the
    first instruction at the sample’s entry point) and get the address of `SubMain`
    by its offset (`0x2C`). For example, in radare2, you would do the following:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.22 – Finding the SubMain address for the VB sample in radare2'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.22_B18500.jpg)'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.22 – Finding the SubMain address for the VB sample in radare2
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s talk about the dynamic analysis of Visual Basic samples.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic analysis
  id: totrans-309
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just like static analysis, a dynamic analysis will be different for p-code and
    native code samples.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: P-code
  id: totrans-311
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When there is a need to debug p-code compiled code, generally, there are two
    options available: debug the p-code instructions themselves or debug the restored
    source code.'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: The second option requires a high-quality decompiler that can produce something
    close to the original source code. Usually, VB Decompiler does this job pretty
    well. In this case, its output can be loaded into an IDE of your choice and after
    some minor modifications, it can be used to debug any usual source code. Often,
    it isn’t necessary to restore the whole project as only certain parts of the code
    need to be traced.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: While this approach is more user-friendly in general, sometimes, debugging actual
    p-code may be the only option available, for example, when a decompiler doesn’t
    work properly or just isn’t available. In this case, the **WKTVBDE** project becomes
    extremely handy as it allows you to debug p-code compiled applications. It requires
    a malicious sample to be placed in its root directory to be loaded properly.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: Native code
  id: totrans-315
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For native code samples, just like for static analysis, dynamic analysis tools
    for Windows can be used. The choice mainly depends on the analyst’s preferences
    and available budget.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: At this stage, we have learned enough about VB to start analyzing the first
    few samples. Now, let’s talk about Java-based threats.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: The internals of Java samples
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Java is a cross-platform programming language that is commonly used to create
    both local and web applications. Its syntax was influenced by another object-oriented
    language called Smalltalk. Originally developed by Sun Microsystems and first
    released in 1995, it later became a part of the Oracle Corporation portfolio.
    At the time of writing, it is considered to be one of the most popular programming
    languages in use.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: Java applications are compiled into the bytecode that’s executed by **Java Virtual
    Machines** (**JVMs**). The idea here is to let applications that have been compiled
    once be used across all supported platforms without any changes required. There
    are multiple JVM implementations available on the market and at the time of writing
    (starting from Java 1.3), HotSpot JVM is the default official option. Its distinctive
    feature is its combination of the interpreter and the JIT compiler, which can
    compile bytecode into native machine instructions based on the profiler output
    to speed up the execution of slower parts of the code. Most PC users get it by
    installing the **Java Runtime Environment** (**JRE**), which is a software distribution
    that includes the standalone JVM (HotSpot), the standard libraries, and a configuration
    toolset. The **Java Development Kit** (**JDK**), which also contains JRE, is another
    popular option since it is a development environment for building applications,
    applets, and components using the Java language. For mobile devices, the process
    is quite different. We will cover it in [*Chapter 13*](B18500_13.xhtml#_idTextAnchor1503),
    *Analyzing Android Malware Samples*.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: In terms of malware, Java is quite popular among **Remote Access Tool** (**RAT**)
    developers. Examples include jRAT or the Frutas/Adwind families distributed as
    JAR files. Exploits used to be another big problem for users until recent changes
    were introduced by the industry. In this section, we will explore the internals
    of the compiled Java files and learn how to analyze malware while leveraging it.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: File structure
  id: totrans-322
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once compiled, text `.java` files become `.class` files and can be executed
    by the JVM straight away.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is their structure according to the official documentation:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The magic value that’s used in this case is a hexadecimal DWORD, `0xCAFEBABE`.
    The other fields are self-explanatory.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: The most common way to release a more complex project is to build a JAR file
    that contains multiple compiled modules, as well as auxiliary metadata files such
    as `MANIFEST.MF`. JAR files follow the usual ZIP archive format and can be extracted
    using any unpacking software that supports it.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the `<jar>` field, which is a reference to the actual JAR file, and
    the `<applet-desc>` field, which, among other things, specifies the name of the
    main Java class to be loaded.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: There are numerous ways that Java-based samples can be analyzed. In this section,
    we are going to explore multiple options available for both static and dynamic
    analysis.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: JVM instructions
  id: totrans-330
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The list of supported instructions is very well-documented, so generally, it
    isn’t a problem to find information about any bytecode of interest. Let’s look
    at some examples of what they look like.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: 'Data transfer:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18500_09_Table7.jpg)'
  id: totrans-333
  prefs: []
  type: TYPE_IMG
- en: 'Arithmetic and logical operations:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18500_09_Table8.jpg)'
  id: totrans-335
  prefs: []
  type: TYPE_IMG
- en: 'Control flow:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18500_09_Table9.jpg)'
  id: totrans-337
  prefs: []
  type: TYPE_IMG
- en: Interestingly enough, other projects can produce Java bytecode, such as JPython,
    which aims to compile Python files into Java-style bytecode. However, in reality,
    in the absolute majority of cases, working with them is not necessary as modern
    decompilers are doing their job extremely well.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: Static analysis
  id: totrans-339
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since the Java bytecode remains the same across all platforms, it speeds up
    the process of creating high-quality decompilers as developers don’t have to spend
    much time supporting different architectures and operating systems. Here are some
    of the most popular tools available to the general public:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: '`rt.jar` file from your Java folder via the `-path` argument when using it.'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Procyon**: Another powerful decompiler, this can process both Java files
    and raw bytecode.'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**FernFlower**: A Java decompiler that’s maintained as a plugin for IntelliJ
    IDEA. It has a command-line version as well.'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CFR**: A JVM bytecode decompiler written in Java that can process individual
    classes and entire JAR files as well.'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**d4j**: A Java decompiler built on top of the Procyon project.'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ghidra**: This reverse-engineering toolkit supports multiple file formats
    and instruction sets, including Java bytecode:'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 9.23 – Disassembled and decompiled Java bytecode in Ghidra'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.23_B18500.jpg)'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.23 – Disassembled and decompiled Java bytecode in Ghidra
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: '**JD Project**: A venerable Java decompiler project, this provides a set of
    tools for analyzing Java bytecode. It includes a library called **JD-Core**, a
    standalone tool called **JD-GUI**, and several plugins for major IDEs.'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**JAD**: A classic decompiler that has assisted generations of reverse engineers
    with Java malware analysis. It’s now discontinued:'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 9.24 – Decompiled code of the Adwind RAT malware written in Java'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.24_B18500.jpg)'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.24 – Decompiled code of the Adwind RAT malware written in Java
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: It always makes sense to try several different projects and compare their output
    since all of them implement different techniques, so the quality may vary, depending
    on the input sample.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: To know where to start the analysis, look inside the `MANIFEST.MF` file as it
    will indicate from which class of the corresponding JAR sample the execution will
    start (the `Main-Class` field).
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: Finally, if necessary, Java bytecode disassembly can be obtained using a standard
    `-c` argument.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic analysis
  id: totrans-358
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Modern decompilers generally produce a reasonably high-quality output, which,
    after minor modifications, can be read and debugged as any usual Java source code.
    Multiple IDEs support Java that provide debugging options for this purpose: Eclipse,
    NetBeans, IntelliJ IDEA, and others.'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: If the original bytecode tracing is required, it is possible to achieve this
    with the `-XX:+TraceBytecodes` option, which is available for debug builds of
    the HotSpot JVM. If step-by-step bytecode debugging is required, then Dr. Garbage’s
    **Bytecode Visualizer** plugin for Eclipse IDE appears to be extremely handy.
    It allows you to not only see the disassembly of the compiled modules inside the
    JAR but also debug them.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with anti-reverse engineering solutions
  id: totrans-361
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At the time of writing, there is an impressive number of commercial obfuscators
    for Java available on the market. As for malware developers, many of them use
    either cracked versions or demos and leaked licenses. An example is Allatori Obfuscator,
    which is misused by Adwind RAT.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: 'When the obfuscator’s name is confirmed (for example, by unique strings), it
    generally makes sense to check whether any of the existing deobfuscation tools
    support it. Here are some of them:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: '**Java Deobfuscator**: A versatile project that supports a decent amount of
    commercial protectors'
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**JMD**: A Java bytecode analysis and deobfuscation tool that can remove obfuscation
    implemented by multiple well-known protectors'
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Java DeObfuscator** (**JDO**): A general-purpose deobfuscator that implements
    several universal techniques, such as renaming obfuscated values to be unique
    and indicative of their data type'
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**jrename**: Another universal deobfuscator that specializes in renaming values
    to make the code more readable'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If nothing ready-to-use has been found, it makes sense to search for articles
    covering this particular obfuscator as they may give you valuable insight into
    how it works and what approach is worth trying.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: If no information has been found, then it is time to explore the logic behind
    the obfuscator from scratch, trying to get the most valuable information first,
    such as strings and then the bytecode. The more information that can be collected
    about the obfuscator, the less time will be spent on the analysis itself later.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: That’s it for Java-based threats. Now, let’s talk about malware written in Python.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing compiled Python threats
  id: totrans-371
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python is a high-level general-purpose language that debuted in 1990 and since
    that time has gone through several development iterations. At the time of writing,
    there are two branches actively used by the public, Python 2 and Python 3, which
    are not fully compatible. The language itself is extremely robust and easy to
    learn, which eventually lets engineers prototype and develop ideas rapidly.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: As for why compiled Python is used by malware authors when there are so many
    other languages, this language is cross-platform, which allows an existing application
    to be easily ported to multiple platforms. It is also possible to create executables
    from Python scripts using tools such as **py2exe** and **PyInstaller**.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: You may be wondering, why is Python being covered in this chapter when it is
    a scripting language? The truth is, whether the programming language uses bytecode
    or not depends on the actual implementation and not on the language itself. Active
    Python users may notice files with the `.pyc` extension appearing, for example,
    when the Python modules get imported. These files contain the code that’s been
    compiled into Python’s bytecode language and can be used for various purposes,
    including malicious ones. In addition, the executables that are generated from
    Python projects can generally be reverted to these bytecode modules first.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will explain how such samples can be analyzed.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: File structure
  id: totrans-376
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are three types of compiled files associated with Python: `.pyc`, `.pyo`,
    and `.pyd`. Let’s go through the differences between them:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: '`.pyc`: These are standard compiled bytecode files that can be used to make
    future module importing easier and faster'
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.pyo`: These are compiled bytecode files that are built with the `-O` (or
    `-OO`) option, which is responsible for introducing optimizations that affect
    the speed they will be loaded (not executed)'
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.pyd`: These are traditional Windows DLL files that implement the MZ-PE structure
    (for Linux, it will be `.so`)'
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since MZ-PE files have been covered multiple times throughout this book, we
    won’t talk about them too much, nor spend much time on `.pyd` files. Their main
    feature is having a specific name for the initialization routine that should match
    the name of the module.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: Particularly, if you have a module named `foo.pyd`, it should export a function
    called `initfoo` so that later, when imported using the `import foo` statement,
    Python can search for the module with such a name and know the name of the initialization
    function to be loaded.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s focus on the compiled bytecode files. Here is the structure of the
    `.pyc` file:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18500_09_Table10.jpg)'
  id: totrans-384
  prefs: []
  type: TYPE_IMG
- en: Interestingly enough, the `.pyc` modules are platform independent, but at the
    same time Python version-dependent. Thus, `.pyc` files can easily be transferred
    between systems with the same Python version installed, but files that are compiled
    using one version of Python generally can’t be used by another version of Python,
    even on the same system.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: Bytecode instructions
  id: totrans-386
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The official Python documentation describes the bytecode that’s used in both
    versions 2 and 3\. In addition, since it is open source software, all bytecode
    instructions for a particular Python version can be also found in the corresponding
    source code files, mainly `ceval.c`.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: 'The differences between the bytecode that’s used in Python 2 and 3 aren’t that
    drastic, but still noticeable. For example, some instructions that were implemented
    for version 2 are gone in version 3 (such as `STOP_CODE`, `ROT_FOUR`, `PRINT_ITEM`,
    `PRINT_NEWLINE/PRINT_NEWLINE_TO`, and so on):'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.25 – Diﬀerent bytecode for the same HelloWorld script produced by
    Python 2 and 3'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.25_B18500.png)'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.25 – Diﬀerent bytecode for the same HelloWorld script produced by Python
    2 and 3
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the groups of instructions that are used in the official documentation
    for Python 3, along with some examples:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: '`NOP`: Do nothing (generally used as a placeholder)'
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`POP_TOP`: Removes the top value from the stack'
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ROT_TWO`: Swaps the top items on the stack'
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UNARY_POSITIVE`: Increment*   `UNARY_NOT`: Logical `NOT` operation*   `UNARY_INVERT`:
    Inversion*   `BINARY_MULTIPLY`: Multiplication*   `BINARY_ADD`: Addition*   `BINARY_XOR`:
    XOR operation*   `INPLACE_MULTIPLY`: Multiplication*   `INPLACE_SUBTRACT`: Subtraction*   `INPLACE_RSHIFT`:
    Right shift operation*   `GET_AITER`: Call the `get_awaitable` function for the
    output of the `__aiter__()` method of the top item on the stack*   `SETUP_ASYNC_WITH`:
    Create a new frame object*   `BREAK_LOOP`: Terminate a loop*   `SET_ADD`: Add
    the top item on the stack to the set specified by the second item*   `MAKE_FUNCTION`:
    Push a new function object to the stack'
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The bytecode instruction names are quite self-explanatory. For the exact syntax,
    please consult the official documentation.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: After discussing the various aspects of Python as a scripting language, we will
    now pay attention to how to analyze compiled Python code. In this section, we
    will go through the practical analysis techniques from a Python perspective.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: Static analysis
  id: totrans-399
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In many cases, the analysts don’t get the compiled Python modules straight
    away. Instead, they get a sample, which is a set of Python scripts that’s been
    converted into an executable using either py2exe or PyInstaller solutions. So,
    before digging into bytecode modules themselves, we need to obtain bytecode modules.
    Luckily, several projects can perform this task:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: '**unpy2exe.py**: This script can handle samples built using py2exe'
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**pyinstxtractor.py**: As the name suggests, this tool can be used to extract
    Python modules from the executables built using the PyInstaller solution'
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An open source project called **python-exe-unpacker** combines both of these
    tools and can be run against the executable sample without any extra checks.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: After extracting the files that were packed using **PyInstaller**, there is
    one moment that can be quite frustrating for anybody who just started analyzing
    compiled Python files. In particular, the main extracted module may be missing
    the first few bytes preceding the marshaled code (see the preceding table for
    the exact number that depends on the Python version), so it can’t be processed
    by other tools straight away. The easiest way to handle this is to take them from
    any compiled file on the current machine and then add them there using any hex
    editor. Such a file can be created by importing (not executing) a simple Hello
    World script.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: 'Since analyzing Python source code is pretty straightforward, it makes sense
    to stick to this option where possible. In this case, the decompilers, which can
    restore the original code, appear to be extremely useful. At the time of writing,
    multiple options are available:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: '**uncompyle6**: An open source native Python decompiler that supports multiple
    versions of it. It does exactly what it promises – translates bytecode back into
    equivalent source code. There were several older projects preceding it (decompyle,
    uncompyle, and uncompyle2).'
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**decompyle3**: A reworking of the uncompyle6 project that supports Python
    versions 3.7+'
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Decompyle++ (also known as pycdc)**: A disassembler and decompiler written
    in C++, it seeks to support bytecode from any version of Python.'
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Meta**: A Python framework that allows you to analyze Python bytecode and
    syntax trees.'
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**UnPYC**: A versatile GUI tool for Python decompiling that relies on other
    projects to do the actual code restoration.'
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After obtaining the source code, it can be reviewed in any text editor with
    convenient syntax highlighting or an IDE of your choice.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: However, in certain cases, the decompiling process is not possible straight
    away. For example, when the module was built using the newest version of Python,
    it became corrupted during a transfer, partial decoding/decryption, or maybe due
    to some anti-reverse engineering technique. Such tasks can also be found in some
    CTF competitions. In this case, the engineer has to stick to analyzing the bytecode.
    Apart from the tools we mentioned previously, the `marshal.load` and `dis.disassemble`
    methods can be used to translate the bytecode into a readable format.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic analysis
  id: totrans-413
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In terms of dynamic analysis, usually, the output of decompilers can be executed
    straight away. Step-by-step execution is supported by any major IDE that supports
    the Python language. In addition, step-by-step debugging is possible with the
    **trepan2/trepan3k** debugger (for recent versions of Python 2 and 3, respectively),
    which automatically uses uncompyle6 if there is no source code available. For
    Python before 2.6, the older packages, **pydbgr** and **pydb**, can be used.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: 'If there is a necessity to trace the bytecode, there are several ways it can
    be handled, as follows:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: '`ceval.c` file is amended to process (for example, print) executed instructions.'
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Amending the .pyc file itself**: Here, the source code line numbers are replaced
    with the index of each byte, which eventually allows you to trace executed bytecode.
    Ned Batchelder covered this technique in his *Wicked hack: Python bytecode tracing*
    article.'
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are also existing projects such as `.pyc` files with a header format that’s
    generated by the current version of Python 2, so update it if necessary).
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: 'Some examples of common anti-reverse engineering techniques include doing the
    following:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: Manipulating non-existing values on the stack
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up a custom exception handler (for this purpose, the `SETUP_EXCEPT`
    instruction can be used)
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When editing the bytecode (for example, to get rid of anti-debugging or anti-decompiling
    techniques or to restore a corrupted code block), the `dis.opmap` mapping appears
    to be extremely useful to find the binary values of opcodes and later replace
    them, and the `bytecode_graph` module can be used to seamlessly remove unwanted
    values.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-423
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered the fundamental theory of bytecode languages. We
    learned what their use cases are and how they work from the inside. Then, we dived
    deep into the most popular bytecode languages used by modern malware families,
    explained how they operate, and looked at their unique specifics that need to
    be paid attention to. Finally, we provided detailed guidelines on how such malware
    can be analyzed and the tools that can facilitate this process.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: Equipped with this knowledge, you can analyze malware of this kind and get an
    invaluable insight into how it may affect victims’ systems.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 10*](B18500_10.xhtml#_idTextAnchor1106), *Scripts and Macros –
    Reversing, Deobfuscation, and Debugging*, we are going to cover various script
    and macros languages, explore the malware that misuses them, and find interesting
    links between them, as well as already covered technologies.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
