<html><head></head><body>
		<div><h1 id="_idParaDest-80" class="chapter-number"><a id="_idTextAnchor084"/>3</h1>
			<h1 id="_idParaDest-81"><a id="_idTextAnchor085"/>Basic Static and Dynamic Analysis for x86/x64</h1>
			<p>In this chapter, we are going to cover the core fundamentals that you need to know to analyze 32-bit or 64-bit malware in the Windows platform. We will cover the <strong class="bold">Windows Portable Executable file header</strong> (<strong class="bold">PE header</strong>) and look at how it can help us to answer different <a id="_idIndexMarker321"/>incident handling and threat intelligence questions.</p>
			<p>We will also walk through the concepts and basics of static and dynamic analysis, including processes and threads, the process creation flow, and WOW64 processes. Finally, we will cover process debugging, including setting breakpoints and altering the program’s execution.</p>
			<p>This chapter will help you to perform basic static and dynamic analyses of malware samples by explaining the theory and equipping you with practical knowledge. By doing this, you will learn about the tools needed for malware analysis.</p>
			<p>In this chapter, we will cover the following topics: </p>
			<ul>
				<li>Working with the PE header structure</li>
				<li>Static and dynamic linking</li>
				<li>Using PE header information for static analysis </li>
				<li>PE loading and process creation</li>
				<li>Basics of dynamic analysis using OllyDbg and x64dbg</li>
				<li>Debugging malicious services</li>
				<li>Essentials of behavioral analysis<a id="_idTextAnchor086"/><a id="_idTextAnchor087"/><a id="_idTextAnchor088"/></li>
			</ul>
			<h1 id="_idParaDest-82"><a id="_idTextAnchor089"/>Working with the PE header structure</h1>
			<p>When you start<a id="_idIndexMarker322"/> to perform basic static analysis on a file, your first valuable source of information will be the PE header. The PE header is a structure that any executable Windows file follows.</p>
			<p>It contains various information, such as supported systems, the memory layouts of sections that contain code and data (such as strings, images, and so on), and various metadata, helping the system load and execute a file properly.</p>
			<p>In this section, we will explore the PE header structure and learn how to analyze a P<a id="_idTextAnchor090"/>E file and read its information<a id="_idTextAnchor091"/>.</p>
			<h2 id="_idParaDest-83"><a id="_idTextAnchor092"/>Why PE?</h2>
			<p>The portable <a id="_idIndexMarker323"/>executable structure was able to solve multiple issues that appeared in previous structures, such as MZ for MS-DOS executables. It represents a complete design for any executable file. Some of the features of the PE structure are as follows:</p>
			<ul>
				<li>It separates the code and the data into sections, making it easy to manage the data separately from the program and link any string back in the assembly code.</li>
				<li>Each section has separate memory permissions, which act as layers of security over the virtual memory of each program. These aim to allow or deny reading from a specific page of memory, writing to a specific page of memory, or executing code on a specific page of memory. A page of memory commonly takes <em class="italic">0x1000</em> bytes, which is <em class="italic">4,096</em> bytes in decimal.</li>
				<li>The file expands in memory (it takes less size on a hard disk), which allows you to create space for uninitialized variables (variables that don’t have a specific value assigned before the application uses them) and, at the same time, save space on the hard disk.</li>
				<li>It supports dynamic linking (via export and import directories), which is a very important technology that we will talk about later in this chapter.</li>
				<li>It supports relocation, which allows the program to be loaded in a different place in memory from what it was designed to be loaded in.</li>
				<li>It supports resource sections, where it can store any additional files, such as icons.</li>
				<li>It supports multiple processors, subsystems, and types of files, which allows the PE structure to be used across many platforms, such as Windows CE and Windows <a id="_idIndexMarker324"/>Mobile.</li>
			</ul>
			<p>Now, let’s talk about what PE’s structure looks li<a id="_idTextAnchor093"/><a id="_idTextAnchor094"/><a id="_idTextAnchor095"/>ke.</p>
			<h2 id="_idParaDest-84"><a id="_idTextAnchor096"/>Exploring PE’s structure</h2>
			<p>In this section, we <a id="_idIndexMarker325"/>will dive deeper into the structure of a typical executable file on a Windows operating system. This structure is used by Microsoft to represent multiple files, such as applications or libraries in the Windows operating system, across multiple types of devices, such as PCs, tabl<a id="_idTextAnchor097"/>ets, and mobile devices.</p>
			<h3>MZ header</h3>
			<p>Early in the <a id="_idIndexMarker326"/>MS-DOS era, Windows and DOS co-existed, and <a id="_idIndexMarker327"/>both had executable files with the same extension, <code>.exe</code>. So, each Windows application had to start with a small DOS application that printed a message stating <code>This program cannot be run in DOS mode</code> (or any similar message). This way, when a Windows application gets executed in the DOS environment, the small DOS application at the start of it will get executed and print this message to the user to run it in the Windows environment. The following diagram shows the high-level structure of the PE file header, with<a id="_idIndexMarker328"/> the <strong class="bold">DOS program’s MZ Header</strong> at the start:</p>
			<div><div><img src="img/Figure_3.1_B18500.jpg" alt=""/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.1 – Example PE structure</p>
			<p>This DOS header starts with the <code>MZ</code> magic value and ends with a field called <code>e_lfanew</code>,<a id="_idTextAnchor098"/> which points to <a id="_idIndexMarker329"/>the start of the <strong class="bold">portable executable </strong><strong class="bold"><a id="_idIndexMarker330"/></strong><strong class="bold">header</strong>, or <strong class="bold">PE<a id="_idTextAnchor099"/> header</strong>.</p>
			<h3>PE header</h3>
			<p>The PE header <a id="_idIndexMarker331"/>starts with two letters, <code>PE</code>, followed by two important headers, which are the file header and the optional header. Later, all the additional structures are pointed to by the data directo<a id="_idTextAnchor100"/><a id="_idTextAnchor101"/><a id="_idTextAnchor102"/>ry array.</p>
			<h3>File header</h3>
			<p>Some <a id="_idIndexMarker332"/>of<a id="_idIndexMarker333"/> the most important values from this header are as follows:</p>
			<div><div><img src="img/Figure_3.2_B18500.jpg" alt=""/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.2 – File header explained</p>
			<p>The highlighted values are as follows:</p>
			<ol>
				<li><code>Machine</code>: This field represents the processor type – for example, 0x14c represents Intel 386 or later processors.</li>
				<li><code>NumberOfSections</code>: This value represents the number of sections that follow the headers, such as the code section, data section, or resources section (for files or images).</li>
				<li><code>TimeDateStamp</code>: This is the exact date and time that this program was compiled. It’s very useful for threat intelligence and creating a timeline of the attack.</li>
				<li><code>Characteristics</code>: This value represents the type of executable file and specifies whether it is a program or a dynamic link library (we will cover this later in<a id="_idIndexMarker334"/> this <a id="_idIndexMarker335"/>chapter).</li>
			</ol>
			<p>Now, let’s talk about the opti<a id="_idTextAnchor103"/>onal header.</p>
			<h3>Optional header</h3>
			<p>Following the <a id="_idIndexMarker336"/>file header, the optional header <a id="_idIndexMarker337"/>comes with much more information, as shown here:</p>
			<div><div><img src="img/Figure_3.3_B18500.jpg" alt=""/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.3 – Optional hea<a id="_idTextAnchor104"/>der explained</p>
			<p>Here are some of the most important values in this header:</p>
			<ol>
				<li value="1"><code>Magic</code>: This identifies the platform the PE file supports (whether it’s x86 or x64). </li>
				<li><code>AddressOfEntryPoint</code>: This is a very important field for our analysis and it points to the starting point of program execution (to the first assembly instruction to be executed in the program) relative to its starting address (its base). These types<a id="_idIndexMarker338"/> of addresses are called <strong class="bold">Relative Virtual Addresses</strong> (<strong class="bold">RVAs</strong>).</li>
				<li><code>ImageBase</code>: This is the address where the program was designed to be loaded into virtual memory. All instructions that use absolute addresses will expect this as a program base. If the program has a relocation table, it can be loaded to a different base address. In this case, all such instructions will be updated by the Windows loader according to this table.</li>
				<li><code>SectionAlignment</code>: The size of each section and all header sizes should be aligned to this value when loaded into memory (generally, this value is 0x1000).</li>
				<li><code>FileAlignment</code>: The size of each section in the PE file (as well as the size of all headers) must be aligned to this number (for example, for a section that’s 0x1164 in size <a id="_idIndexMarker339"/>and has a file alignment value of 0x200, the section size will be changed to 0x1200 on the hard disk).</li>
				<li><code>MajorSubsystemVersion</code>: This represents the minimum Windows version to run the application on, such as Windows XP or Windows 7.</li>
				<li><code>SizeOfImage</code>: This is the size of the whole application in memory (usually, it’s larger than the size of the file on the hard disk due to uninitialized data, different alignments, and other reasons).</li>
				<li><code>SizeOfHeaders</code>: This is the size of all headers.</li>
				<li><code>Subsystem</code>: This indicates that this could be a Windows UI application, a console application, or a driver, or that it could even run on other Windows subs<a id="_idTextAnchor105"/>ystems, such as Microsoft POSIX.</li>
			</ol>
			<p>The optional header ends with a list of da<a id="_idTextAnchor106"/>ta directories.</p>
			<h3>Data directories</h3>
			<p>The data <a id="_idIndexMarker340"/>directory <a id="_idIndexMarker341"/>array points to a list of other structures that might be included in the executable and are not necessarily present in every application.</p>
			<p>It includes 16 entries that follow the following format:</p>
			<ul>
				<li><code>Address</code>: This points to the beginning of the structure in memory (from the start of the file).</li>
				<li><code>Size</code>: This is the size of the corresp<a id="_idTextAnchor107"/>onding structure.</li>
			</ul>
			<p>The data directory includes many different values; not all of them are that important for malware analysis. Some of the most important entries to mention are as follows:</p>
			<ul>
				<li><strong class="bold">Import directory</strong>: This <a id="_idIndexMarker342"/>represents the functions (or APIs) that this program doesn’t include but wants to import from other executable files or libraries (DLLs).</li>
				<li><strong class="bold">Export directory</strong>: This represents the functions (or APIs) that this program includes in its code and is willing to export and allow other applications to use.</li>
				<li><strong class="bold">Resource directory</strong>: This is always located at the start of the resource section and its purpose is to represent the packages’ files within the program, such as icons, images, and others.</li>
				<li><strong class="bold">Relocation directory</strong>: This is always located at the start of the relocation section and it’s used to fix addresses in the code when the PE file is loaded to another place in memory.</li>
				<li><strong class="bold">TLS directory</strong>: <strong class="bold">Thread Local Storage</strong> (<strong class="bold">TLS</strong>) points to functions that will be executed <a id="_idIndexMarker343"/>before the entry point. It can be used to bypass debuggers, as we will see later in greater detail.</li>
			</ul>
			<p>Following the data directories, there <a id="_idTextAnchor108"/>is a section table.</p>
			<h3>Section table</h3>
			<p>After the 16 entries of the data directory array, there’s the section table. Each entry in the section <a id="_idIndexMarker344"/>table represents a section of the PE file. The number <a id="_idIndexMarker345"/>of sections in total is the number stored in the <code>NumberOfSections</code> field in <code>FileHeader</code>.</p>
			<p>Here is an example of it:</p>
			<div><div><img src="img/Figure_3.4_B18500.jpg" alt=""/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.4 – Exampl<a id="_idTextAnchor109"/>e of a section table</p>
			<p>These fields are used for the following purposes:</p>
			<ul>
				<li><code>Name</code>: The name of the section (8 bytes max).</li>
				<li><code>VirtualSize</code>: The size of a section (in memory).</li>
				<li><code>VirtualAddress</code>: The pointer to the beginning of the section in memory (as RVA).</li>
				<li><code>SizeOfRawData</code>: The size of a section (on the hard disk). </li>
				<li><code>PointerToRawData</code>: The pointer to the beginning of the section in the file on the hard disk (relative to the start of the file). These types of addresses are called offsets.</li>
				<li><code>Characteristics</code>: Memory protection flags (mainly <code>EXECUTE</code>, <code>READ</code>, or <code>WRITE</code>).</li>
			</ul>
			<p>Now, let’s talk about the Rich header.</p>
			<h3>Rich header</h3>
			<p>This is a<a id="_idIndexMarker346"/> much <a id="_idIndexMarker347"/>lesser-known part of the MZ-PE header. It is located straight after the small DOS program, which prints the <code>This program cannot be run in DOS mode</code> string, and the PE header, as shown in the following screenshot:</p>
			<div><div><img src="img/Figure_3.5_B18500.jpg" alt=""/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.5 – Raw Rich header</p>
			<p>Unlike other <a id="_idIndexMarker348"/>header <a id="_idIndexMarker349"/>structures, it is supposed to be read from the end of where the <code>Rich</code> magic value is located. The value following it is the custom checksum that’s calculated over the DOS and Rich headers, which also serves as an XOR key, with which the actual content of this header is encrypted. Once decrypted, it will contain various information about the software that was used to compile the program. The very first field, once decrypted, will be the <code>DanS</code> marker:</p>
			<div><div><img src="img/Figure_3.6_B18500.jpg" alt=""/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.6 – Parsed Rich header in the PE-Bear tool</p>
			<p>This information can help researchers identify software that was used to create malware to choose the right tools for analysis and actor attribution.</p>
			<p>As you can <a id="_idIndexMarker350"/>see, the PE structure is a treasure trove for malware<a id="_idIndexMarker351"/> analysts since it provides lots of invaluable information about both the malicious functionality and the a<a id="_idTextAnchor110"/><a id="_idTextAnchor111"/>ttackers who created it.</p>
			<h2 id="_idParaDest-85"><a id="_idTextAnchor112"/>PE+ (x64 PE)</h2>
			<p>At this point, you<a id="_idIndexMarker352"/> may be thinking that all x64 PE files’ fields take 8 bytes compared to 4 bytes in x86 PE files. But the truth is that the PE+ header is very similar to the good old PE header with very few changes, as follows:</p>
			<ul>
				<li><code>ImageBase</code>: It is 8 bytes instead of 4 bytes.</li>
				<li><code>BaseOfData</code>: This was removed from the optional header.</li>
				<li><code>Magic</code>: This value changed from 0x10B (representing x86) to 0x20B (representing x64). PE+ files stayed at the maximum 2 GB size, while all other RVA addresses, including <code>AddressOfEntrypoint</code>, remained at 4 bytes.</li>
				<li>Some other fields, such as <code>SizeOfHeapCommit</code>, <code>SizeOfHeapReserve</code>, <code>SizeOfStackReserve</code>, and <code>SizeOfStackCommit</code>, now take 8 bytes instead of 4.</li>
			</ul>
			<p>Now that we <a id="_idIndexMarker353"/>know what the PE header is, let’s talk about various tools that may help us extract and v<a id="_idTextAnchor113"/><a id="_idTextAnchor114"/><a id="_idTextAnchor115"/>isualize this information.</p>
			<h2 id="_idParaDest-86"><a id="_idTextAnchor116"/>PE header analysis tools</h2>
			<p>Once we become <a id="_idIndexMarker354"/>familiar with the PE format, we need to become able to parse different PE files (for example, <code>.exe</code> files) and read their header values. Luckily, we don’t have to do this ourselves in a hex editor; there are lots of different tools that can help us read PE header information easily. The most well-known free tools to do it are as follows:</p>
			<ul>
				<li><strong class="bold">CFF Explorer</strong>: This tool<a id="_idIndexMarker355"/> is great for parsing the PE header as it properly analyzes and presents all the important information stored there:</li>
			</ul>
			<div><div><img src="img/Figure_3.7_B18500.jpg" alt=""/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.7 – CFF Explorer UI</p>
			<ul>
				<li><strong class="bold">PE-bear</strong>: The great<a id="_idIndexMarker356"/> advantage of this tool compared to CFF Explorer is that it can also parse the Rich header, which, as we know, contains lots of useful information<a id="_idIndexMarker357"/> about the developer tools used to create the sample.</li>
				<li><strong class="bold">Hiew</strong>: While the demo<a id="_idIndexMarker358"/> version shows only a small subset of the PE header’s information, the full version gives researchers full visibility as well as the ability to edit any field there.</li>
				<li><strong class="bold">PEiD</strong>: While it is <a id="_idIndexMarker359"/>mainly used to detect the compilers (Visual Studio, for example) or the packer that is used to pack this malware using static signatures stored within the application (this will be covered in greater detail in <a href="B18500_04.xhtml#_idTextAnchor238"><em class="italic">Chapter 4</em></a>, <em class="italic">Unpacking, Decryption, and Deobfuscation</em>), researchers can use the <strong class="bold">&gt;</strong> buttons to get lots of information from the PE header:</li>
			</ul>
			<div><div><img src="img/Figure_3.8_B18500.jpg" alt=""/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.8 – PEiD UI</p>
			<p>In <a id="_idIndexMarker360"/>the next section, we will further our knowledge and explore the nitty-gritty of static and dynamic linking.</p>
			<h1 id="_idParaDest-87"><a id="_idTextAnchor117"/>Static and dynamic linking</h1>
			<p>In this section, we will cover the code libraries that were introduced to speed up the software development process, avoid code duplication, and improve the cooperation between different teams within companies producing software.</p>
			<p>These libraries are a known target for malware families as they can easily be injected into the memory of different applications and impersonate t<a id="_idTextAnchor118"/>hem to disguise their malicious activities.</p>
			<p>First of all, let’s talk about the differ<a id="_idTextAnchor119"/>ent ways libraries can be used.</p>
			<h2 id="_idParaDest-88"><a id="_idTextAnchor120"/>Static linking</h2>
			<p>With the increasing <a id="_idIndexMarker361"/>number of applications on different operating systems, developers found that there was a lot of code reuse and the same logic being rewritten over and over again to support certain functionalities in their programs. Because of that, the invention of code libraries came in handy. Let’s take a look at the following diagram:</p>
			<div><div><img src="img/Figure_3.9_B18500.jpg" alt=""/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.9 – Static link<a id="_idTextAnchor121"/>ing from compilation to loading</p>
			<p>Code libraries <code>(.lib</code> files) include lots of functions to be copied to your program when required, so there is no need to reinvent the wheel and rewrite these functions again (for example, the code for mathematical operations such as sin or cos for any application that deals with mathematical equations). This is done by a program called a linker, whose job is to put all the required functions (groups of instructions) together and produce a single self-contained executable file as a result. This app<a id="_idTextAnchor122"/>roach is called static linking.</p>
			<h2 id="_idParaDest-89"><a id="_idTextAnchor123"/>Dynamic linking</h2>
			<p>Statically<a id="_idIndexMarker362"/> linked libraries lead to having the same code copied over and over again inside each program that may need it, which, in turn, leads to the loss of hard disk space and increases the size of the executable files.</p>
			<p>In modern operating systems such as Windows and Linux, there are hundreds of libraries, and each contains thousands of functions for UIs, graphics, 3D, internet communications, and more. Because of that, static linking appeared to be limited. To mitigate this issue, dynamic linking emerged. The whole process is displayed in the following diagram:</p>
			<div><div><img src="img/Figure_3.10_B18500.jpg" alt=""/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.10 – Dynamic link<a id="_idTextAnchor124"/>ing from compilation to loading</p>
			<p>Instead of storing the code inside each executable, any needed library is loaded next to each application in the same virtual memory so that this application can directly call the required<a id="_idTextAnchor125"/> functions. These libraries are<a id="_idIndexMarker363"/> named <strong class="bold">dynamic link libraries</strong> (<strong class="bold">DLLs</strong>), as shown in the preceding diagram. Let<a id="_idTextAnchor126"/>’s cover them in greater detail.</p>
			<h2 id="_idParaDest-90"><a id="_idTextAnchor127"/>Dynamic link libraries</h2>
			<p>A DLL is a <a id="_idIndexMarker364"/>complete PE file that includes all the necessary headers, sections, and, most importantly, the export table.</p>
			<p>The export table includes all the functions that this library exports. Not all library functions are exported as some of them are for internal use. However, the functions that are exported can be accessed through their names or <em class="italic">ordinal</em> numbers (index numbers). These are <a id="_idIndexMarker365"/>called <strong class="bold">application programming interfaces</strong> (<strong class="bold">APIs</strong>).</p>
			<p>Windows provides lots of libraries for developers who are creating programs for Windows to access its functionality. Some of these libraries are as follows:</p>
			<ul>
				<li><code>kernel32.dll</code>: This library includes the basic and core functionality for all programs, including reading a file and writing a file. In recent versions of Windows, the actual code of the functions moved to <code>KernelBase.dll</code></li>
				<li><code>ntdll.dll</code>: This library exports Windows native APIs; <code>kernel32.dll</code> uses this library as a backend for its functionality. Some malware writers try to access undocumented APIs inside this library to make it harder for reverse engineers to understand the malware functionality, such as <code>LdrLoadDll</code>.</li>
				<li><code>advapi32.dll</code>: This library is used mainly for working with the registry and cryptography.</li>
				<li><code>shell32.dll</code>: This library is responsible for shell-related operations such as executing and opening files.</li>
				<li><code>ws2_32.dll</code>: This library is responsible for all the functionality related to internet sockets and network communications, which is very important for understanding custom network communication protocols.</li>
				<li><code>wininet.dll</code>: This library contains HTTP and FTP functions and more.</li>
				<li><code>urlmon.dll</code>: This library provides similar functionality to <code>wininet.dll</code> and is used for working with URLs, web compre<a id="_idTextAnchor128"/><a id="_idTextAnchor129"/><a id="_idTextAnchor130"/>ssion, downloading files, and more.</li>
			</ul>
			<p>Now, it’s time to talk about <a id="_idIndexMarker366"/>what exactly APIs are.</p>
			<h2 id="_idParaDest-91"><a id="_idTextAnchor131"/>Application programming interface (API)</h2>
			<p>In short, APIs <a id="_idIndexMarker367"/>export functions in libraries that any application can call or interact with. In addition, APIs can be exported by executable files in the same way as DLLs. This way, an executable file can be run as a program or loaded as a library by other executables or libraries.</p>
			<p>Each program’s import table contains the names of all the required libraries and all the APIs that this program uses. And in each library, the export table contains the API’s name, the API’s ordinal number, and the RVA address of this API.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">Each API has an ordinal n<a id="_idTextAnchor132"/><a id="_idTextAnchor133"/>umber, but not all APIs have a name.</p>
			<h3>Dynamic API loading</h3>
			<p>In malware, it’s <a id="_idIndexMarker368"/>very common to obscure the name of the libraries and the APIs that they are using to hide their functionality from static analysis using what’s called dynamic API loading.</p>
			<p>Dynamic API loading is supported by Windows using two very well-known APIs:</p>
			<ul>
				<li><code>LoadLibraryA</code>: This API loads a dynamic link library into the virtual memory of the calling program and returns its address (variations include <code>LoadLibraryW</code>, <code>LoadLibraryExA</code>, and <code>LoadLibraryExW</code>).</li>
				<li><code>GetProcAddress</code>: This API returns an address of the API specified by its name or the ordinal value and the address of the library that contains this API.</li>
			</ul>
			<p>By calling these two APIs, malware can access APIs that are not written in the import table, which means they might be hidden from the eyes of the reverse engineer.</p>
			<p>In some advanced malware, the malware author also hides the names of the libraries and the APIs using encryption or other obfuscation techniques, which will be covered in <a href="B18500_04.xhtml#_idTextAnchor238"><em class="italic">Chapter 4</em></a>, <em class="italic">Unpa<a id="_idTextAnchor134"/>cking, Decryption, and Deobfuscation</em>.</p>
			<p>These APIs are not the only APIs that can allow dynamic API loading; other techniques will be <a id="_idIndexMarker369"/>explored in <a href="B18500_08.xhtml#_idTextAnchor811"><em class="italic">Chapter 8</em></a>, <em class="italic">Handling Exploits and Shellcode</em>.</p>
			<p>Armed with this knowledge, let’s learn m<a id="_idTextAnchor135"/>ore about how to put it into practice.</p>
			<h1 id="_idParaDest-92"><a id="_idTextAnchor136"/>Using PE header information for static analysis</h1>
			<p>Now<a id="_idIndexMarker370"/> that we’ve covered the PE header, dynamic <a id="_idIndexMarker371"/>link libraries, and APIs, the question that arises is, <em class="italic">How can we use this information in <a id="_idTextAnchor137"/>our static analysis?</em> This depends on the questions that you want to ans<a id="_idTextAnchor138"/>wer, so that is what we will cover here.</p>
			<h2 id="_idParaDest-93"><a id="_idTextAnchor139"/>How to use the PE header for incident handling</h2>
			<p>If an incident <a id="_idIndexMarker372"/>occurs, static analysis of the PE header can help you answer multiple questions in your report. Here are the questions and how the PE header can help you answer them:</p>
			<ul>
				<li><em class="italic">Is this malware packed</em>?</li>
			</ul>
			<p>The PE header can help you figure out if this malware is packed. Packers tend to change section names from their familiar names (<code>.text</code>, <code>.data</code>, and <code>.rsrc</code>) to something else, such as <code>UPX0</code> or <code>.aspack</code>.</p>
			<p>In addition, packers commonly hide most of the APIs otherwise expected to be present in the import table. So, if you see that the import table contains very few APIs, that could be another sign of packing being involved. We will cover unpacking in detail in <a href="B18500_04.xhtml#_idTextAnchor238"><em class="italic">Chapter 4</em></a>, <em class="italic">Unpacking, Decryption, and Deobfuscation</em>.</p>
			<ul>
				<li><em class="italic">Is this malware a dropper or a downloader</em>?</li>
			</ul>
			<p>It’s very common to see droppers that have additional PE files stored in their resources. Multiple tools, such <a id="_idIndexMarker373"/>as <strong class="bold">Resource Hacker</strong>, can detect these embedded files (or, for example, a ZIP file that contains them), and you will be able to find the dropped modules.</p>
			<p>For downloaders, it’s common to see an API named <code>URLDownloadToFile</code> from a DLL named <code>urlmon.dll</code> where you can download the file, and the <code>ShellExecuteA</code> API to execute the file. Other APIs can be used to achieve the same goal, but these two APIs are the most well-known and amo<a id="_idTextAnchor140"/>ng the easiest to use for malware authors.</p>
			<ul>
				<li><em class="italic">Does it connect to the Command &amp; Control server(s) (C&amp;C, or the attacker’s website)? And how?</em></li>
			</ul>
			<p>There are many APIs that can tell you that the malware uses the internet, such as <code>socket</code>, <code>send</code>, and <code>recv</code>, and they can tell you if they connect to a server acting as a client or if they listen to a port such as <code>connect</code> or <code>listen</code>, respectively.</p>
			<p>Some APIs can even tell you what protocol they are using, such as <code>HTTPSendRequestA</code> or <code>FTPPutFile</code>, which are both from <code>wininet.dll</code>.</p>
			<ul>
				<li><em class="italic">What other functionalities does this malware have?</em></li>
			</ul>
			<p>Some APIs<a id="_idIndexMarker374"/> are related to file searching, such as <code>FindFirstFileA</code>, which could be a hint that this malware may be ransomware or an info stealer.</p>
			<p>It could use APIs such as <code>Process32First</code>, <code>Process32Next</code>, and <code>CreateRemoteThread</code>, which could mean a process injection functionality, or use <code>TerminateProcess</code>, which could mean that this malware may try to terminate other applications, such as antivirus programs or malware analysis tools.</p>
			<p>We will cover all of these in greater detail later in this book. This section gave you hints and ideas to think about during your next static malware analysis and helped you find what you would be searching for in a PE header.</p>
			<p>Usually, it is a good idea to focus on the main questions that you should answer in your report. Perhaps performing basic static analysis base<a id="_idTextAnchor141"/>d on the strings and the P<a id="_idTextAnchor142"/>E header would be enough to help your case.</p>
			<h2 id="_idParaDest-94"><a id="_idTextAnchor143"/>How to use a PE header for threat hunting</h2>
			<p>So far, we <a id="_idIndexMarker375"/>have covered how a PE header could help you answer questions related to incident handling or a normal tactical report. Now, let’s cover the following questions related to threat intelligence and how a PE header can help you answer them:</p>
			<ul>
				<li><em class="italic">When was this sample created?</em></li>
			</ul>
			<p>Sometimes, threat researchers need to know how old the sample is. Is it an old sample or a new variant, and when did the attackers start to plan their attacks in the first place?</p>
			<p>The PE header includes a value called <code>TimeDateStamp</code> in the file header. This value includes the exact date and time this sample was compiled, which can help answer this question and help threat researchers build their attack timeline. However, it’s worth mentioning that it can also be forged. Another less-known field that serves a similar purpose is the <code>TimeDateStamp</code> value of the Export Directory (when available).</p>
			<ul>
				<li><em class="italic">What’s the country of origin of these attackers?</em></li>
			</ul>
			<p>What country do the attackers belong to? That can answer a lot about their motivations.</p>
			<p>One of the ways to answer this question is, again, <code>TimeDateStamp</code>, which looks at many samples and their compile times. In some cases, they fall into 9-5 jobs for a particular time zone, which may help deduce the attackers’ country of origin, as shown in the following graph:</p>
			<div><div><img src="img/Figure_3.11_B18500.jpg" alt=""/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.11 – Patterns in compilation timestamps</p>
			<p>The Rich header may also be used for attribution purposes since combining different versions of software that were used to compile the sample generally doesn’<a id="_idTextAnchor144"/>t change very often for <a id="_idIndexMarker376"/>a particular setup.</p>
			<ul>
				<li><em class="italic">Is malware signed with a stolen certificate? Are all these samples related?</em></li>
			</ul>
			<p>One of the data directory entries is related to the certificate. Some applications are signed by their manufacturer to provide additional trust for the users and the operating system that this application is safe. But these certificates sometimes get stolen and used by different malware actors.</p>
			<p>For all the malicious samples that use a specific stolen certificate, it’s quite likely that all of them are produced by the same actor. Even if they have a different purpose or target different victims, they’re likely to be different activities performed by the same attackers.</p>
			<p>As we <a id="_idIndexMarker377"/>mentioned earlier, a PE header is an information treasure trove if you look into the details hiding inside its fields. Here, we covered some of the mo<a id="_idTextAnchor145"/>st common use cases. There is so much more to get out of <a id="_idTextAnchor146"/>it, and it’s up to you to explore it further.</p>
			<h1 id="_idParaDest-95"><a id="_idTextAnchor147"/>PE loading and process creation</h1>
			<p>Everything that we have covered so far was related to the PE file present on the hard disk. What we haven’t covered yet is how this PE file changes in memory when it’s loaded, as well as the whole execution process of these files. In this section, we<a id="_idTextAnchor148"/> will talk about how Windows loads a PE file, e<a id="_idTextAnchor149"/>xecutes it, and turns it into a live program.</p>
			<h2 id="_idParaDest-96"><a id="_idTextAnchor150"/>Basic terminology</h2>
			<p>To understand PE loading and process creation, we must cover some basic terminology, such as <a id="_idIndexMarker378"/>process, thread, <strong class="bold">Thread Environment Block</strong> (<strong class="bold">TEB</strong>), <strong class="bold">Process Environment Block</strong> (<strong class="bold">PEB</strong>), and <a id="_idIndexMarker379"/>others before we dive into the<a id="_idTextAnchor151"/> flow <a id="_idTextAnchor152"/>of loading and executing an executable PE file.</p>
			<h3>What’s a process?</h3>
			<p>A process is<a id="_idIndexMarker380"/> not just a representation of a running program in memory – it is also a container for all the information about the running application. This container stores information about the virtual memory associated with that process, all the loaded DLLs, opened files and sockets, the list of threads running as part of this process (we will c<a id="_idTextAnchor153"/>over this later), the process ID, and much more.</p>
			<p>A process is a structure in the kernel that holds all this information, working as an entity to represent this running executable file, as shown in the following diagram:</p>
			<div><div><img src="img/Figure_3.12_B18500.jpg" alt=""/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.12 – Example of a 32-bit process memory layout</p>
			<p>We’ll compare the various <a id="_idIndexMarker381"/>aspects o<a id="_idTextAnchor154"/>f virtual<a id="_idTextAnchor155"/> memory and physical memory in the next section.</p>
			<h3>Mapping virtual memory to physical memory</h3>
			<p>Virtual<a id="_idIndexMarker382"/> memory <a id="_idIndexMarker383"/>is like a holder for each process. Each process has its own virtual memory space to store its images, related libraries, and all the auxiliary memory ranges dedicated to the stack, heap, and so on. This virtual memory has a mapper to the equivalent physical memory. Not all virtual memory addresses are mapped to physical memory, and each one that’s been mapped has a permission (<em class="italic">READ|WRITE</em>, <em class="italic">READ|EXECUTE</em>, or maybe <em class="italic">READ|WRITE|EXECUTE</em>), as shown in the following diagram:</p>
			<div><div><img src="img/Figure_3.13_B18500.jpg" alt=""/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.13 – Mappings between physical and virtual memory</p>
			<p>Virtual memory allows you to create a security layer between one process and another and allows <a id="_idIndexMarker384"/>the<a id="_idIndexMarker385"/> operating system to manage different processes an<a id="_idTextAnchor156"/><a id="_idTextAnchor157"/><a id="_idTextAnchor158"/>d suspend one process to give resources to another.</p>
			<h3>Threads</h3>
			<p>A thread is not just the<a id="_idIndexMarker386"/> entity that represents an execution path inside a process (and each process can have one or more threads running simultaneously). It is also a structure in the kernel that saves the whole state of that execution, including the registers, stack information, and the last error.</p>
			<p>Each thread in Windows has a little time frame to run in before it gets stopped to have another thread resumed (as the number of processor cores is much smaller than the number of threads running in the entire system). When Windows changes the execution from one thread to another, it takes a snapshot of the whole execution state (registers, stack, instruction pointer, and so on) and saves it in the thread structure to be able to resume it again from where it stopped.</p>
			<p>All threads running in one process share the same resources of that process, including the virtual memory, open files, open sockets, DLLs, mutexes, and others, and they synchronize with each other upon accessing these resources.</p>
			<p>Each thread has a stack, instruction pointer, code functions for error handling (SEH, which will be covered in <a href="B18500_06.xhtml#_idTextAnchor554"><em class="italic">Chapter 6</em></a>, <em class="italic">Bypassing Anti-Reverse Engineering Techniques</em>), a thread ID, and a thread information structure called TEB, as shown in the following diagram:</p>
			<div><div><img src="img/Figure_3.14_B18500.jpg" alt=""/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.1<a id="_idTextAnchor159"/>4 – Example processes with one and multiple threads</p>
			<p>Next, we will <a id="_idIndexMarker387"/>talk about the crucial d<a id="_idTextAnchor160"/>ata structures that are needed to <a id="_idTextAnchor161"/>understand threads and processes. Let’s get started.</p>
			<h3>Important data structures – TIB, TEB, and PEB</h3>
			<p>The last<a id="_idIndexMarker388"/> thing <a id="_idIndexMarker389"/>that <a id="_idIndexMarker390"/>you<a id="_idIndexMarker391"/> need to understand related to processes and threads are TIB, TEB, and PEB data structures. These structures are stored inside the process memory, and their main function is to include all the information about the process and each thread, as well as make them accessible to the code so that it can easily know the process filename, the loaded DLLs, and other related information.</p>
			<p>They can all be accessed through a special segment register, either FS (32-bit) or GS (64-bit), like this:</p>
			<pre class="source-code">
mov eax, DWORD PTR FS:[XX]</pre>
			<p>These data structures<a id="_idIndexMarker392"/> have the following functions:</p>
			<ul>
				<li><strong class="bold">Thread Information Block (TIB)</strong>: This <a id="_idIndexMarker393"/>contains information about the thread, including the list of functions that are used for error handling and much more.</li>
				<li><strong class="bold">Thread Environment Block (TEB)</strong>: This <a id="_idIndexMarker394"/>structure starts with the TIB, which is then followed by additional thread-related fields. In many cases, the terms TIB and TEB are used interchangeably.</li>
				<li><strong class="bold">Process Environment Block (PEB)</strong>: This <a id="_idIndexMarker395"/>includes various information about the process, such as its name, ID (PID), and a list of modules (which includes all the PE files that have been loaded in memory – mainly the program itself and the DLLs).</li>
			</ul>
			<p>In the next section, and throughout this entire book, we will cover the different information that is s<a id="_idTextAnchor162"/>tored in these structures that is used to help the maliciou<a id="_idTextAnchor163"/>s code achieve its goals – for example, to detect debuggers.</p>
			<h2 id="_idParaDest-97"><a id="_idTextAnchor164"/>Process creation step by step</h2>
			<p>Now that we know <a id="_idIndexMarker396"/>the basic terminology, we can dive into PE loading and process creation. We will investigate it sequentially, as shown in the following steps:</p>
			<ol>
				<li value="1"><code>calc.exe</code>, another process called <code>explorer.exe</code> (the process of Windows Explorer) calls an API, <code>CreateProcessA</code>, which gives the operating syste<a id="_idTextAnchor165"/>m the request to create this process and start its execution.</li>
				<li><code>EPROCESS</code>), sets a unique ID for this process (<code>ProcessID</code>), and sets the <code>explorer.exe</code> file’s process ID as a parent PID for the newly created <code>calc.exe</code> process.</li>
				<li><code>EPROCESS</code> structure. Then, it creates the PEB structure with all the necessary information and loads the main two DLLs that Windows applications will always need: <code>ntdll.dll</code> and <code>kernel32.dll</code> (some applications run on other Windows subsystems, such as POSIX, and don’t use <code>kernel32.dll</code>).</li>
				<li><strong class="bold">Loading the PE file</strong>: After that, Windows starts loading the PE file (which we will explain next), which loads all the required third-party libraries (DLLs), including all the DLLs these libraries require, and makes sure to find the required APIs from these libraries and save their addresses in the import table of the loaded PE file so that the code can easily access them and call them.</li>
				<li><strong class="bold">Starting the execution</strong>: Last but not least, Windows creates the first thread in the process, which<a id="_idIndexMarker397"/> does so<a id="_idTextAnchor166"/>me initialization and calls the PE file’s entry point to start the execution of the program. The TLS callbacks mentioned previously, if present, will be executed before the entry point.</li>
			</ol>
			<p>N<a id="_idTextAnchor167"/>ow, let’s dig deeper into the PE loading part of this process.</p>
			<h2 id="_idParaDest-98"><a id="_idTextAnchor168"/>PE file loading step by step</h2>
			<p>The Windows <a id="_idIndexMarker398"/>PE loader follows these steps while loading an executable PE file into memory (including dynamic link libraries):</p>
			<ol>
				<li value="1"><code>ImageBase</code>: To load the PE file (if possible) at this address in its virtual memory.</li><li><code>NumberOfSections</code>: To be used to load the sections. </li><li><code>SizeOfImage</code>: As this will be the final size of the whole PE file after being loaded in m<a id="_idTextAnchor169"/>emory, this value will be used to allocate the space initially.</li></ul></li>
				<li><code>NumberOfSections</code> field parses all the sections in the PE <a id="_idIndexMarker399"/>file and makes sure to get all the necessary information, including their addresses and sizes in memory (<code>VirtualAddress</code> and <code>VirtualSize</code> respectively), as well as the offset and the size of the section on the hard disk for reading its data.</li>
				<li><code>SectionAlignment</code>, the loader copies all the headers and then moves each section to a new place using its <code>VirtualAddress</code> and <code>VirtualSize</code> values (if <code>VirtualAddress</code> or <code>VirtualSize</code> are not aligned with <code>SectionAlignment</code>, the loader will align them first and then use them), as shown in the followin<a id="_idTextAnchor170"/>g diagram:</li>
			</ol>
			<div><div><img src="img/Figure_3.15_B18500.jpg" alt=""/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.15 – Mapping sections from disk to memory</p>
			<ol>
				<li value="4"><strong class="bold">Dealing with third-party libraries</strong>: In this step, the loader loads all the required DLLs, going through this process again and again recursively until all DLLs are<a id="_idIndexMarker400"/> loaded. After that, it gets the addresses of all the imported APIs and saves them in the import table of the loaded PE file.</li>
				<li><code>ImageBase</code>, the loader fixes all the absolute addresses in the code with the new address of the program/library (with the new <code>ImageBase</code>).</li>
				<li><strong class="bold">Starting the execution</strong>: Finally, as in process creation, Windows creates the first thread, which executes the program from its entry point. Some anti-reverse engineering techniques can force it to start somewhere else before, which we will<a id="_idIndexMarker401"/> cover in <a href="B18500_06.xhtml#_idTextAnchor554"><em class="italic">Chapter 6</em></a>, <em class="italic">Bypassing Anti-Reverse Engine<a id="_idTextAnchor171"/><a id="_idTextAnchor172"/>ering Techniques</em>.</li>
			</ol>
			<p>One more thing we need to learn about is WOW64.</p>
			<h2 id="_idParaDest-99"><a id="_idTextAnchor173"/>WOW64 processes</h2>
			<p>At this point, you <a id="_idIndexMarker402"/>should understand how a 32-bit process gets loaded into an x86 environment and how a 64-bit process gets loaded into an x64 environment. So, how about running 32-bit programs in 64-bit operating systems?</p>
			<p>For this special case, Windows has created what’s called the WOW64 subsystem. It is implemented mainly in the following DLLs:</p>
			<ul>
				<li><code>wow64.dll</code></li>
				<li><code>wow64cpu.dll</code></li>
				<li><code>wow64win.dll</code></li>
			</ul>
			<p>These DLLs create a simulated environment for the 32-bit process, which includes 32-bit versions of libraries that it may need.</p>
			<p>These DLLs, rather than connecting directly to the Windows kernel, call an API, <code>X86SwitchTo64BitMode</code>, which then switches to x64 and calls the 64-bit <code>ntdll.dll</code>, which communicates directly with the kernel, as shown in the following diagram:</p>
			<div><div><img src="img/Figure_3.16_B18500.jpg" alt=""/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.16 – WOW64 architecture</p>
			<p>Also, for WOW64-based processes (x86 processes running in an x64 environment), new APIs were introduced, such <a id="_idIndexMarker403"/>as IsWow64Process, which is commonly used by malware to identify if it’s running as a 32-bit process in an x64 environment or an x86 environment.</p>
			<h1 id="_idParaDest-100"><a id="_idTextAnchor174"/>Basics of dynamic analysis using OllyDbg and x64dbg</h1>
			<p>Now that<a id="_idIndexMarker404"/> we’ve <a id="_idIndexMarker405"/>explained processes, threads, and the execution of the PE files, it’s time to start debugging a running process and <a id="_idTextAnchor175"/><a id="_idTextAnchor176"/><a id="_idTextAnchor177"/>understanding its functionality by tracing over its code at runtime.</p>
			<h2 id="_idParaDest-101"><a id="_idTextAnchor178"/>Debugging tools</h2>
			<p>There are multiple <a id="_idIndexMarker406"/>debugging tools we can use. Here, we will just give three examples that are quite similar to each other in terms of their UIs and functionality:</p>
			<ul>
				<li><strong class="bold">OllyDbg</strong>: This is <a id="_idIndexMarker407"/>probably the most well-known debugger for the Windows platform. The following screenshot shows its UI, which has bec<a id="_idTextAnchor179"/>ome a standard for most Windows debuggers:</li>
			</ul>
			<div><div><img src="img/Figure_3.17_B18500.jpg" alt=""/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.17 – OllyDbg UI</p>
			<ul>
				<li><strong class="bold">Immunity Debugger</strong>: This is<a id="_idIndexMarker408"/> a scriptable clone of OllyDbg that focuses <a id="_idTextAnchor180"/>on exploitation and bug hunting:</li>
			</ul>
			<div><div><img src="img/Figure_3.18_B18500.jpg" alt=""/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.18 – Immunity Debugger UI</p>
			<ul>
				<li><strong class="bold">X64dbg</strong>: This is a<a id="_idIndexMarker409"/> debugger for x86 and x64 executables with an interface that’s very similar to OllyDbg. It’s <a id="_idIndexMarker410"/>also an open source debugger:</li>
			</ul>
			<div><div><img src="img/Figure_3.19_B18500.jpg" alt=""/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.19 – x64dbg UI</p>
			<p>We will cover <a id="_idIndexMarker411"/>OllyDbg 1.10 (the most common version of OllyDbg) in great detail. The same<a id="_idTextAnchor181"/><a id="_idTextAnchor182"/><a id="_idTextAnchor183"/> concepts and hotkeys can be applied to other debuggers mentioned here.</p>
			<h2 id="_idParaDest-102"><a id="_idTextAnchor184"/>How to analyze a sample with OllyDbg</h2>
			<p>The OllyDbg UI interface<a id="_idIndexMarker412"/> is pretty simple and easy to learn. In this section, we will cover the steps and the different windows that can help you with your analysis:</p>
			<ol>
				<li value="1"><strong class="bold">Select a sample to debug</strong>: You can directly open the sample file by going to <strong class="bold">File</strong> | <strong class="bold">Open</strong> and choosing a PE file to open (it could be a DLL file as well, but make sure it’s a 32-bit sample). Alternatively, you can attach it to a running process, as shown here:</li>
			</ol>
			<div><div><img src="img/Figure_3.20_B18500.jpg" alt=""/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.20 – OllyDbg attaching dialog window</p>
			<ol>
				<li value="2"><strong class="bold">CPU window</strong>: This is your main window. This is the window that you spend most of your<a id="_idIndexMarker413"/> debugging time in. This window includes the assembly code in the top left-hand corner and provides the option to set breakpoints by double-clicking on the address or modifying the program’s assembly code.</li>
			</ol>
			<p>You’ve also got the registers in the top right-hand corner. It is possible to modify them at any given time (once the execution has been paused). At the bottom, y<a id="_idTextAnchor185"/>ou have the stack and the data in hex format, which you can also modify.</p>
			<p>You can simply modify any data in memory in the following two views:</p>
			<div><div><img src="img/Figure_3.21_B18500.jpg" alt=""/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.21 – OllyDbg default window layout explained</p>
			<ol>
				<li value="3"><strong class="bold">Executable modules Window</strong>: There are multiple windows in OllyDbg that can help<a id="_idIndexMarker414"/> you with your analysis, such as the <strong class="bold">Executable modules</strong> window (you can access it by going<a id="_idTextAnchor186"/> to <strong class="bold">View</strong> | <strong class="bold">Executable modules</strong>), as shown in the following screenshot:</li>
			</ol>
			<div><div><img src="img/Figure_3.22_B18500.jpg" alt=""/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.22 – OllyDbg dialog window for executable modules</p>
			<p>This window will help you see all the loaded PE files in this process’ virtual memory, including the malware sample and all the libraries or DLLs loaded with it.</p>
			<ol>
				<li value="4"><strong class="bold">Memory map window</strong>: Here, you can see all the allocated memory inside the process’ virtual memory. Allocated memory is the memory that is represented in the physical (RAM) memory or a <strong class="bold">page file</strong> on the hard disk to store the content of the RAM when it’s not big enough. You can see what they represent and their memory <a id="_idIndexMarker415"/>protection (READ, WRITE, and/or EXECUTE), as shown in the following screenshot:</li>
			</ol>
			<div><div><img src="img/Figure_3.23_B18500.jpg" alt=""/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.23 – OllyDbg memory map dialog window</p>
			<ol>
				<li value="5"><strong class="bold">Debugging the sample</strong>: In the <strong class="bold">Debug</strong> menu, you have multiple options for running the program’s assembly code, such as fully executing the sample until you hit a breakpoint using <strong class="bold">Run</strong> or just using <em class="italic">F9</em>.</li>
			</ol>
			<p>The other option will be to just step over. <strong class="bold">Step over</strong> executes one line of code. However, if this line of code is a call to another function, it executes this function completely and stops just after the function returns. This makes it different from <strong class="bold">Step into</strong>, which goes inside the function and stops at the beginning of it, as shown in the following screenshot:</p>
			<div><div><img src="img/Figure_3.24_B18500.jpg" alt=""/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.24 – OllyDbg debug menu</p>
			<p>It includes the option to set hardware breakpoints and view them, which we will cover later in this chapter.</p>
			<ol>
				<li value="6"><strong class="bold">There’s much more</strong>: OllyDbg allows you to modify the code of the program; change its registers, state, and memory; dump any part of the memory; and save the changes of the PE file in memory back to the hard disk for<a id="_idTextAnchor187"/><a id="_idTextAnchor188"/><a id="_idTextAnchor189"/> further static analysis <a id="_idIndexMarker416"/>if needed.</li>
			</ol>
			<p>Now, let’s talk about breakpoints.</p>
			<h2 id="_idParaDest-103"><a id="_idTextAnchor190"/>Types of breakpoints</h2>
			<p>To be able to<a id="_idIndexMarker417"/> dynamically analyze a sample and understand its behavior, you need to be able to control its execution flow. You need to be able to stop the execution when a condition is me<a id="_idTextAnchor191"/>t, examine its memory, and alter its registers’ values and instr<a id="_idTextAnchor192"/>uctions. There are several types of breakpoints that make this possible.</p>
			<h3>Step into/step over breakpoints</h3>
			<p>This <a id="_idIndexMarker418"/>breakpoint <a id="_idIndexMarker419"/>is very simple <a id="_idIndexMarker420"/>and allows the processor to<a id="_idIndexMarker421"/> execute only one instruction of the program, before returning to the debugger.</p>
			<p>This breakpoint modifies a flag in a register <a id="_idIndexMarker422"/>called <strong class="bold">EFlags</strong>. While not common, this breakpoint could be detected by malware to identify the presence of a debugger, which we will cover when we look at ant<a id="_idTextAnchor193"/>i-reverse en<a id="_idTextAnchor194"/>gineering tricks in <a href="B18500_06.xhtml#_idTextAnchor554"><em class="italic">Chapter 6</em></a>, <em class="italic">Bypassing Anti-Reverse Engineering Techniques</em>.</p>
			<h3>Software (INT3) breakpoints</h3>
			<p>This is the<a id="_idIndexMarker423"/> most <a id="_idIndexMarker424"/>common breakpoint, and you can easily set this breakpoint by double-clicking on the hex representation of an assembly line in the CPU window in OllyDbg or pressing <em class="italic">F2</em>. After this, you will see a red highlight over the address of this instruction, as shown in the following screenshot:</p>
			<div><div><img src="img/Figure_3.25_B18500.jpg" alt=""/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.25 – Disassembly in OllyDbg</p>
			<p>Well, this is what you see through the debugger’s UI, but what you don’t see is that the first byte of this instruction (0xB8, in this case) has been modified to 0xCC (the INT3 instruction), which stops the execution once the processor reaches it and returns control to the debugger. This 0xCC byte is not visible in the debugger UI as it keeps showing us the original bytes and the instruction they represent, but it can be seen if we decide to dump this memory on the disk and look at it using the hex editor.</p>
			<p>Once the debugger gets control of this INT<a id="_idTextAnchor195"/>3 breakpoint, it replaces 0xCC with 0xB8 to execute this instruction normally.</p>
			<p>The main problem with this breakpoint is that it modifies memory. If malware tries to read or modify the bytes of this instruction, it will read the first byte as 0xCC instead of 0xB8, which can break some code or detect the presence of the debugger (which we will cover in <a href="B18500_06.xhtml#_idTextAnchor554"><em class="italic">Chapter 6</em></a><em class="italic">,</em> <em class="italic">Bypassing Anti-Reverse Engineering Techniques</em>). In addition, it may affect memory dumping because this way, the resulting dump will be damaged by these modifications. The solutio<a id="_idTextAnchor196"/>n to this problem is to remove all software breakpoints <a id="_idIndexMarker425"/>before <a id="_idIndexMarker426"/>dumping memory.</p>
			<h3>Memory breakpoints</h3>
			<p>Memory <a id="_idIndexMarker427"/>breakpoints are used not to stop the execution of <a id="_idIndexMarker428"/>specific instructions, but to stop when any instruction tries to read or modify a specific part of memory. The way many debuggers set memory breakpoints is by adding the <em class="italic">PAGE_GUARD</em> (0x100) protection flag to the page’s original protection and removing <em class="italic">PAGE_GUARD</em> once the breakpoint is hit.</p>
			<p>These can be accessed by right-clicking on <strong class="bold">Breakpoint</strong> | <strong class="bold">Memory, on access</strong> or <strong class="bold">Memory, on write</strong>, as shown in the following screenshot:</p>
			<div><div><img src="img/Figure_3.26_B18500.jpg" alt=""/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.26 – OllyDbg breakpoint menu</p>
			<p>Another important thing to note here is that memory breakpoints are less precise as it is only po<a id="_idTextAnchor197"/><a id="_idTextAnchor198"/><a id="_idTextAnchor199"/>ssible to change memory protection flags for a memory page, not for a single byte.</p>
			<h3>Hardware breakpoints</h3>
			<p>Hardware<a id="_idIndexMarker429"/> breakpoints<a id="_idIndexMarker430"/> are based on<a id="_idIndexMarker431"/> six<a id="_idIndexMarker432"/> special-purpose<a id="_idIndexMarker433"/> registers: <strong class="bold">DR0-DR3</strong>, <strong class="bold">DR6</strong>, and <strong class="bold">DR7</strong>.</p>
			<p>These registers allow you to set a maximum of four breakpoints that have been given specific addresses to read, write, or execute 1, 2, or 4 bytes, starting from the given address. They are very useful as they don’t modify the instruction bytes as INT3 breakpoints do, and they are generally harder to detect. However, they could still be detected and removed by the malware, which we will discuss in <a href="B18500_06.xhtml#_idTextAnchor554"><em class="italic">Chapter 6</em></a>, <em class="italic">Bypassing Anti-Reverse Engineering Techniques</em>.</p>
			<p>You can view them from the <strong class="bold">Debug</strong> menu by going to <strong class="bold">Hardware breakpoints</strong>, as shown in the following screenshot:</p>
			<div><div><img src="img/Figure_3.27_B18500.jpg" alt=""/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.27 – OllyDbg dialog window for hardware breakpoints</p>
			<p>As you can see, each type of breakpoint serves a particular purpose and has advantages and<a id="_idIndexMarker434"/> disadvantag<a id="_idTextAnchor200"/><a id="_idTextAnchor201"/>es, so it is important to know all of them and<a id="_idIndexMarker435"/> use them according to the task at hand.</p>
			<h2 id="_idParaDest-104"><a id="_idTextAnchor202"/>Modifying the program’s execution</h2>
			<p>To be able to<a id="_idIndexMarker436"/> bypass anti-debugging tricks, forcing the malware to communicate with the C&amp;C or even testing different branches of the malware execution, you need to be able to alter the execution flow of the malware. Let’s look at the dif<a id="_idTextAnchor203"/><a id="_idTextAnchor204"/><a id="_idTextAnchor205"/>ferent techniques we can use to alter the execution flow and the behavior of any thread.</p>
			<h3>Modifying the program’s assembly instructions</h3>
			<p>You can <a id="_idIndexMarker437"/>modify the code execution path by changing the assembly instruction. For example, you can change a conditional jump instruction to the opposite condition, as shown in the following screenshot, and force the execution of a specific branch that wasn’t supposed to be executed:</p>
			<div><div><img src="img/Figure_3.28_B18500.jpg" alt=""/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.28 – Working with assembly<a id="_idTextAnchor206"/><a id="_idTextAnchor207"/> in OllyDbg</p>
			<p>Apart from the code, it is also possible to change the content of registers.</p>
			<h3>Changing EFlags</h3>
			<p>Rather than<a id="_idIndexMarker438"/> modifying the code of the conditional jump instruction, you can modify the results of the comparison before it by changing the EFlags registers.</p>
			<p>At the top right, after the registers, you have multiple flags that you can change. Each flag represents a specific result from any comparison (other instructions change these flags as well). For example, ZF represents if the two values are equal or if a register became z<a id="_idTextAnchor208"/>ero. By changing the ZF flag, you force conditional jumps, s<a id="_idTextAnchor209"/>uch as <code>jnz</code> and <code>jz</code>, to jump to the opposite branch and force the execution path to change.</p>
			<h3>Modifying the instruction pointer value</h3>
			<p>You can <a id="_idIndexMarker439"/>force the execution of a specific branch or instruction by simply modifying the instruction pointer (<strong class="bold">EIP</strong>/<strong class="bold">RIP</strong>). You <a id="_idTextAnchor210"/><a id="_idTextAnchor211"/><a id="_idTextAnchor212"/>can do this by right-clicking on the instruction of interest and choosing <strong class="bold">New origin here</strong>.</p>
			<h3>Changing the program data</h3>
			<p>Just like you can <a id="_idIndexMarker440"/>change an instruction code, you can change the data values. With the bottom-left view (the hexadecimal view), you can change bytes of the data by right-clicking on <strong class="bold">Binary</strong> | <strong class="bold">Edit</strong>. You can also copy/paste hexadecimal values, as shown in the following screenshot:</p>
			<div><div><img src="img/Figure_3.29_B18500.jpg" alt=""/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.29 – Data editing in OllyDbg</p>
			<p>Now, let’s talk <a id="_idIndexMarker441"/>about how to efficiently search for important pieces of information to facilitate the analysis.</p>
			<h2 id="_idParaDest-105"><a id="_idTextAnchor213"/>List strings, APIs, and cross-references</h2>
			<p>When<a id="_idIndexMarker442"/> performing <a id="_idIndexMarker443"/>reverse <a id="_idIndexMarker444"/>engineering, strings <a id="_idIndexMarker445"/>and<a id="_idIndexMarker446"/> APIs serve as very important <a id="_idIndexMarker447"/>sources of information, so it is important to know how to navigate them efficiently.</p>
			<p>To get a list of strings in OllyDbg, right-click anywhere in the disassembly section of the CPU window and choose <strong class="bold">Search for</strong> | <strong class="bold">All referenced text strings</strong>. The resulting dialog box will show all candidate C-style strings, both ANSI and Unicode (UTF16-LE), and the instructions that use them.</p>
			<p>To get a list of APIs, do the same, but this time, choose <strong class="bold">Search for</strong> | <strong class="bold">All intermodular calls</strong>.</p>
			<p>Cross-references are markers that show the researcher where this code or data is being accessed. This is an extremely important piece of information that allows us to efficiently connect the dots. To find them for a particular instruction, right-click on it and choose the <strong class="bold">Find references to</strong> | <strong class="bold">Selected command</strong> option. For data in the hex dump window, it will be just <strong class="bold">Find references</strong>.</p>
			<h2 id="_idParaDest-106"><a id="_idTextAnchor214"/>Setting labels and comments</h2>
			<p>When analyzing <a id="_idIndexMarker448"/>any kind of sample, it is important to keep the markup accurate so that you will always have a clear picture of what the meaning of already reviewed code or data is. Giving functions and references proper names is a great way to make sure you won’t have to re-analyze the same code again after some time. </p>
			<p>To give the function or some data a name, right-click on its first instruction and choose the <strong class="bold">Label</strong> option (or just press the <em class="italic">:</em> hotkey). Now, all the references to them will use this label rather than an address, as shown in the following screenshot:</p>
			<div><div><img src="img/Figure_3.30_B18500.jpg" alt=""/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.30 – Using labels and comments in OllyDbg</p>
			<p>To follow the address, press <em class="italic">Enter</em> while selecting the instruction using it. To return, press the <em class="italic">-</em> hotkey. To leave comments, use the <em class="italic">;</em> hotkey.</p>
			<p>Now, let’s talk about x64dbg.</p>
			<h2 id="_idParaDest-107"><a id="_idTextAnchor215"/>Differences between OllyDbg and x64dbg</h2>
			<p>As we<a id="_idIndexMarker449"/> mentioned<a id="_idIndexMarker450"/> previously, these debuggers share multiple similarities. They use the same layout and have pretty much the same interface options and hotkeys – even the default color schema is quite similar. However, there is a list of differences between them, some of which are worth mentioning:</p>
			<ul>
				<li>Unlike OllyDbg, x64dbg supports both 32- and 64-bit executables.</li>
				<li>By default, x64dbg stops at the system breakpoint (a system function that initializes an application to be debugged) while OllyDbg stops at the entry point.</li>
				<li>x64dbg supports tabs for dialog windows, which is very convenient in many cases, such as when several <strong class="bold">Hex dump</strong> windows must be used simultaneously.</li>
				<li>x64dbg displays more registers, including the DR0-3, DR6, and DR7 debug registers.</li>
				<li>OllyDbg may display incorrect protection flags in the <strong class="bold">Memory map</strong> window; x64dbg is generally more accurate.</li>
				<li>x64dbg displays breakpoints of all types in a single <strong class="bold">Breakpoints</strong> window while OllyDbg separates them into <strong class="bold">View</strong> | <strong class="bold">Breakpoints</strong> and <strong class="bold">Debug</strong> | <strong class="bold">Hardware breakpoints</strong>.</li>
				<li>x64dbg doesn’t have a menu option to call the DLL’s export function; it must be done manually.</li>
			</ul>
			<p>There are <a id="_idIndexMarker451"/>other minor differences here and there, so feel free to<a id="_idTextAnchor216"/><a id="_idTextAnchor217"/> try <a id="_idIndexMarker452"/>both tools and choose the one that suits you best.</p>
			<p>Now, let’s talk about how to debug services.</p>
			<h1 id="_idParaDest-108"><a id="_idTextAnchor218"/>Debugging malicious services</h1>
			<p>While loading <a id="_idIndexMarker453"/>individual executables and DLLs for debugging is generall<a id="_idTextAnchor219"/>y a pretty straigh<a id="_idTextAnchor220"/>tforward task, things get a little bit more complicated when we talk about debugging Windows services.</p>
			<h2 id="_idParaDest-109"><a id="_idTextAnchor221"/>What is a service?</h2>
			<p>Services are tasks <a id="_idIndexMarker454"/>that are generally supposed to execute certain logic in the background, similar to daemons on Lin<a id="_idTextAnchor222"/>ux. So, it comes as no surprise that malware authors commonly use them to achieve reliable persistence.</p>
			<p>Services are <a id="_idIndexMarker455"/>controlled by the <code>%SystemRoot%\System32\services.exe</code>. All services have the corresponding <code>HKLM\SYSTEM\CurrentControlSet\services\&lt;service_name&gt;</code> registry key. It contains multiple values that describe the service, including the following:</p>
			<ul>
				<li><code>ImagePath</code>: A file path to the corresponding executable with optional arguments. </li>
				<li><code>Type</code>: The <code>REG_DWORD</code> value specifies the type of the service. Let’s look at some examples of such supported values:<ul><li><code>0x00000001</code> (kernel): In this case, the logic is implemented in a driver (which will be covered in more detail in <a href="B18500_07.xhtml#_idTextAnchor669"><em class="italic">Chapter 7</em></a>, <em class="italic">Understanding Kernel-Mode Rootkits</em>, which is dedicated to kernel-mode threats).</li><li><code>0x00000010</code> (own): The service runs in its own process.</li><li><code>0x00000020</code> (share): The service runs in a shared process.</li></ul></li>
				<li><code>Start</code>: This <a id="_idIndexMarker456"/>is another <code>REG_DWORD</code> value that describes the way the service is supposed to start. The following options are commonly used:<ul><li><code>0x00000000</code> (boot) and <code>0x00000001</code> (system): These values are used for drivers. In this case, they will be loaded by the boot loader or during the kernel’s initialization, respectively.</li><li><code>0x00000002</code> (auto): The service will automatically start each time the machine restarts. This is the obvious choice for malware.</li><li><code>0x00000003</code> (demand): This specifies a service that should be started manually. This option is particularly useful for debugging.</li></ul></li>
				<li><code>0x00000004</code> (disabled): The service won’t be started.</li>
			</ul>
			<p>Let’s look at several ways the services can be designed:</p>
			<ul>
				<li><code>ImagePath</code> will contain its full file path.</li>
				<li><code>rundll32.exe</code>). The full command line is stored in the <code>ImagePath</code> key, the same as in the previous case.</li>
				<li><code>svchost.exe</code> processes. To be loaded, malware generally creates a new group in <code>HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Svchost registry key</code> and passes this value to <code>svchost.exe</code> using the -<code>k</code> argument. The path to the DLL will be specified not in the <code>ImagePath</code> value of the service registry key, as in the previous case (here, it will contain<a id="_idIndexMarker458"/> the path of <code>svchost.exe</code> with the service group argument), but in the <code>ServiceDll</code> value of <code>HKLM\SYSTEM\CurrentControlSet\services\&lt;service_name&gt;\Parameter s registry key</code>. The service DLL should contain the <code>ServiceMain</code> export function (if the custom name is used, it should be specified in the <code>ServiceMain</code> registry value). If the <code>SvchostPushServiceGlobals</code> export is present, it will be executed before <code>ServiceMain</code>.</li>
			</ul>
			<p>A user-mode <a id="_idIndexMarker459"/>service with a dedicated executable (or a DLL with its own loader) can be registered using the standard <code>sc</code> command-line tool, like this:</p>
			<pre>sc create &lt;service_name&gt; type= own binpath= &lt;path_to_executable&gt;</pre>
			<p>The process is slightly more complicated for svchost DLL-based services:</p>
			<pre class="source-code">
reg add "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Svchost" /v "&lt;service_group&gt;" /t REG_MULTI_SZ /d "&lt;service_name&gt;\0" /f
reg add "HKLM\SYSTEM\CurrentControlSet\Services\&lt;service_name&gt;\Parameters"
/v ServiceDll /t REG_EXPAND_SZ /d &lt;path_to_dll&gt; /f sc create &lt;service_name&gt; type= share binpath=<code> </code>"C:\Windows\System32\svchost.exe -k &lt;service_group&gt;"</pre>
			<p>Using this approach, the created service can be started on demand, when necessary, such as by using the following command:</p>
			<pre>sc start &lt;service_name&gt;</pre>
			<p>Alternatively, you<a id="_idIndexMarker460"/> can use the fol<a id="_idTextAnchor224"/><a id="_idTextAnchor225"/><a id="_idTextAnchor226"/>lowing command:</p>
			<pre>net start &lt;service_name_or_display_name&gt;</pre>
			<p>Now, let’s talk about how we can attach to services.</p>
			<h2 id="_idParaDest-110"><a id="_idTextAnchor227"/>Attaching to services</h2>
			<p>There are multiple<a id="_idIndexMarker461"/> ways to attach to services immediately once they start:</p>
			<ul>
				<li><code>HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\&lt;filename&gt;</code> with the corresponding <code>Debugger</code> string data value, which contains the full path to the debugger to be attached to the service once the program with the specified <code>&lt;filename&gt;</code> starts. Here, there is the issue that the window of the attached debugger may not appear if the service is not interactive. It can be fixed in one of the following ways:<ul><li>Open <code>services.msc</code>, open <code>HKLM\SYSTEM\CurrentControlSet\services\&lt;service_name&gt;</code> registry key and replacing its data with the result of a bitwise OR operation with the current value and the <code>0x00000100</code> DWORD (the <code>SERVICE_INTERACTIVE_PROCESS</code> flag). For example, <code>0x00000010</code> will become <code>0x00000110</code>.</li><li>In addition, it can be created interactively when using the sc tool with the <code>type= interact type= own</code> or <code>type= interact type= share</code> arguments. Another option here is to use remote debugging.</li></ul></li>
				<li><strong class="bold">Using GFlags</strong>: The <strong class="bold">Global Flags Editor</strong> (<strong class="bold">GFlags</strong>) tool, which is part of the <strong class="bold">Debugging Tools for Windows</strong> (the same <a id="_idIndexMarker462"/>as <strong class="bold">WinDbg</strong>), provides multiple options for<a id="_idIndexMarker463"/> tweaking the process of debugging the candidate application. To attach the debugger, it modifies the registry key mentioned previously, so both approaches can be used pretty much interchangeably in this case. To do so using its UI, you must set the filename of the program of interest (not the full path) to the <strong class="bold">Image File</strong> tab and the <strong class="bold">Image</strong> field, and then refresh the window using the <em class="italic">Tab</em> key and set a tick against the <strong class="bold">Debugger</strong> field, where the full path to the debugger of preference should be specified. As in the previous case, you must make<a id="_idIndexMarker464"/> sure the service is interactive.</li>
				<li><code>services.exe</code> with a debugger that supports breaks on the child process c<a id="_idTextAnchor228"/>reation, enable it (for example, with the <code>.childdbg 1</code> command in WinDbg), and then start the service of interest.</li>
				<li><code>\xEB\xFE</code> bytes on the entry point of the analyzed sample that represents the <code>JMP</code> instruction to redirect the execution to the start of itself, which creates an infinite loop. Then, it’s possible to find the corresponding process (it will consume a large number of CPU resources), attach to it with a debugger, restore the original bytes, and continue execution as usual while making sure that the restored instructions are successfully executed.</li>
			</ul>
			<p>Once the debugger is attached, it is possible to place the breakpoint at the entry point of the sample to stop the execution there.</p>
			<p>The common problem with debugging services is the timeout. By default, the service gets killed after about 30 seconds if it didn’t signal that it was executed successfully, which may complicate the debugging process. For example, WinDbg accidentally starts showing a <em class="italic">No runnable debuggees</em> error when trying to execute any command. To extend this time interval, you must create or update the DWORD <code>ServicesPipeTimeout</code> value in the <code>HKLM\SYSTEM\CurrentControlSet\Control</code> registry key with the new timeout in milliseconds and restart the machine.</p>
			<p>The service DLL’s exports, such as <code>ServiceMain</code>, can be debugged using any of the previously mentioned approaches. In this case, it is possible to either attach to the corresponding <code>svchost.exe</code> process immediately once it is created and enable breaking on the DLL load (for example, using the <code>sxe ld[:&lt;dll_name&gt;]</code> command in WinDbg) or patch the DLL’s entry point or any other export of interest with the infinite loop <a id="_idIndexMarker465"/>instruction and attach it to <code>svchost.exe</code> at any time once it’s started.</p>
			<p>Finally, let’s explain what behavioral analysis is and how it can help us understand malware’s functionality.</p>
			<h1 id="_idParaDest-111"><a id="_idTextAnchor229"/>Essentials of behavioral analysis</h1>
			<p>First of all, it is worth <a id="_idIndexMarker466"/>mentioning that some resources use the terms dynamic analysis and behavioral analysis interchangeably. Dynamic analysis is the process of executing instructions in the debugger, while behavioral analysis involves a black-box approach when malware is executed under various monitoring tools to record the changes it introduces. This approach allows researchers to get a quick insight into malware functionality. However, there are multiple limitations associated with it, as follows:</p>
			<ul>
				<li>Malware may execute only a part of its functionality</li>
				<li>Malware may behave differently if it notices it’s being analyzed</li>
			</ul>
			<p>In most cases, behavioral analysis tools can easily be detected by various characteristics: file, process or <a id="_idIndexMarker467"/>directory names, registry keys and values, mutexes, window names, and so on.</p>
			<p>Now, let’s look at the most commonly used tools, grouping them by type.</p>
			<h2 id="_idParaDest-112"><a id="_idTextAnchor230"/>File operations</h2>
			<p>Here, the <a id="_idIndexMarker468"/>goal is to monitor <a id="_idIndexMarker469"/>all the changes that are introduced by malware at the filesystem level:</p>
			<ul>
				<li><strong class="bold">Process Monitor (Filemon)</strong>: Part of Sysinternals Suite, Process Monitor combines multiple previously standalone tools. One of them, formerly known as Filemon, allows you to record all filesystem operations that are performed by all processes:</li>
			</ul>
			<div><div><img src="img/Figure_3.31_B18500.jpg" alt=""/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.31 – Various operations recorded by Process Monitor</p>
			<ul>
				<li><strong class="bold">Sandboxie</strong>: The main purpose of this tool is to not just record file operations but to give the researchers access to created/modified files. This is extremely useful if malware drops or downloads additional modules and deletes them afterward.</li>
			</ul>
			<p>Apart from file operations, monitoring registry operations is another proven by time technique <a id="_idIndexMarker470"/>that allows us<a id="_idIndexMarker471"/> to understand the purpose of malware.</p>
			<h2 id="_idParaDest-113"><a id="_idTextAnchor231"/>Registry operations</h2>
			<p>In this case, we<a id="_idIndexMarker472"/> are interested<a id="_idIndexMarker473"/> in recording all the changes that have been made to the Windows Registry, a hierarchical database that stores various settings for both the operating systems and the applications that have been installed:</p>
			<ul>
				<li><strong class="bold">Process Monitor (Regmon)</strong>: This part of Process Monitor allows the researchers to record all types of actions that have been performed with the registry.</li>
				<li><strong class="bold">Regshot</strong>: The idea of this tool is extremely simple – the researchers can create a snapshot of the registry before and after malware execution and compare them to see any differences that have been introduced:</li>
			</ul>
			<div><div><img src="img/Figure_3.32_B18500.jpg" alt=""/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.32 – Regshot UI</p>
			<ul>
				<li><strong class="bold">Autoruns</strong>: Another great tool from the Sysinternals Suite, it is invaluable for figuring out persistence mechanisms introduced by malware. It shows the researchers <a id="_idIndexMarker474"/>all <a id="_idIndexMarker475"/>the modules that will be loaded or executed once the system starts.</li>
			</ul>
			<p>Now, let’s talk about process operations.</p>
			<h2 id="_idParaDest-114"><a id="_idTextAnchor232"/>Process operations</h2>
			<p>Apart from<a id="_idIndexMarker476"/> monitoring<a id="_idIndexMarker477"/> registry and filesystem changes, any created or terminated processes are important artifacts from the malware analysis perspective. The following tools can help us keep track of them:</p>
			<ul>
				<li><strong class="bold">Process Monitor (Procmon)</strong>: Here, the<a id="_idIndexMarker478"/> researchers can keep an eye on all process-related operations – mainly their creation and termination.</li>
				<li><strong class="bold">Process Explorer</strong>: This tool is<a id="_idIndexMarker479"/> also distributed as part of the Sysinternals Suite. In short, this is an advanced version of Task Manager that shows the process hierarchy (parent-child relationships) and more.</li>
			</ul>
			<p>Another way to understand the purpose of malware is to track the APIs it uses.</p>
			<h2 id="_idParaDest-115"><a id="_idTextAnchor233"/>WinAPIs</h2>
			<p>Here, instead<a id="_idIndexMarker480"/> of focusing on a particular <a id="_idIndexMarker481"/>type of activity, the researchers get the option to monitor specific Windows APIs by selecting any of them while grouped by functionality. To do that, the following tool can be used:</p>
			<ul>
				<li><strong class="bold">API Monitor</strong>: This is a great tool that allows the researchers to select either individual APIs or their groups and see which of them were called by malware and in which order. Here is what its UI looks like:</li>
			</ul>
			<div><div><img src="img/Figure_3.33_B18500.jpg" alt=""/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.33 – API Monitor groups WinAPIs by category</p>
			<p>Finally, let’s talk<a id="_idIndexMarker482"/> about network <a id="_idIndexMarker483"/>operations.</p>
			<h2 id="_idParaDest-116"><a id="_idTextAnchor234"/>Network activity</h2>
			<p>The following<a id="_idIndexMarker484"/> is a list of the <a id="_idIndexMarker485"/>most popular tools that allow us to get an insight into the network-related functionality of malware:</p>
			<ul>
				<li><strong class="bold">Tcpview</strong>: This is quite a basic tool that shows the researchers all open ports, as well as established connections and their associated processes.</li>
				<li><strong class="bold">Wireshark</strong>: The king of network traffic analysis, this tool gives invaluable insight into all sent and received packets and allows you to dissect them according to the OSI model and group them into streams. Its rich filtering syntax makes it an indispensable weapon for analyzing malicious network activity. The following screenshot shows what it looks like:</li>
			</ul>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">a</p>
			<div><div><img src="img/Figure_3.34_B18500.jpg" alt=""/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.34 – Wireshark dissecting network packets</p>
			<p>Instead of <a id="_idIndexMarker486"/>monitoring <a id="_idIndexMarker487"/>individual operations with separate tools manually, it is also possible to use sandboxes. </p>
			<h2 id="_idParaDest-117"><a id="_idTextAnchor235"/>Sandboxes</h2>
			<p>Sandboxes are <a id="_idIndexMarker488"/>machines (usually virtual) that <a id="_idIndexMarker489"/>record all actions that have been performed by malware once it is executed, giving researchers a quick and detailed insight into its functionality. They may support various platforms, operating systems, and file types. Others may also record the generated traffic and collect memory dumps.</p>
			<p>Like any behavioral analysis tool, there are multiple limitations associated with them, as follows:</p>
			<ul>
				<li>Sandboxes don’t know much about the environment that’s expected by malware and can’t automatically simulate, for example, the required command-line arguments.</li>
				<li>They can easily be detected. In this case, the malware may either immediately terminate or show some fake activity.</li>
				<li>Their visibility is<a id="_idIndexMarker490"/> limited as they commonly show only part of the malware functionality.</li>
			</ul>
			<p>There are two <a id="_idIndexMarker491"/>options for using sandboxes:</p>
			<ul>
				<li><strong class="bold">Online sandbox services</strong></li>
			</ul>
			<p>There are <a id="_idIndexMarker492"/>several big players in this market, some of which are commercial-only or public with subscription options. Here are some of the most well-known free public sandbox-based<a id="_idIndexMarker493"/> services:</p>
			<ul>
				<li><a href="https://any.run">https://any.run</a></li>
				<li><a href="https://www.hybrid-analysis.com">https://www.hybrid-analysis.com</a></li>
				<li><a href="https://virustotal.com">https://virustotal.com</a> (the <strong class="bold">Behavior</strong> tab)</li>
			</ul>
			<p class="callout-heading">Important Note</p>
			<p class="callout">At the time of writing, VirusTotal supports multiple different sandboxes, so try a few different ones to find a good report.</p>
			<ul>
				<li><strong class="bold">Self-managed sandboxes</strong></li>
			</ul>
			<p>Here, the <a id="_idIndexMarker494"/>researchers will need to host, set up, and administrate the software on their own, with all the corresponding pluses and minuses. Some of the most well-known options are as follows:</p>
			<ul>
				<li><strong class="bold">Cuckoo</strong> (Free): Probably the <a id="_idIndexMarker495"/>most famous sandbox software, it has multiple forks, such <a id="_idIndexMarker496"/>as <strong class="bold">CAPE</strong>.</li>
				<li><strong class="bold">DRAKVUF Sandbox</strong> (Free): The <a id="_idIndexMarker497"/>newer player in the sandbox market based on the DRAKVUF virtualization.</li>
				<li><strong class="bold">VMRay</strong> (Commercial): Unlike<a id="_idIndexMarker498"/> the previous two, this one is commercial-only but provides outstanding results.</li>
			</ul>
			<p>Depending on the use cases and the resources available, each option has its pros and cons and should be used accordingly.</p>
			<p>This brings us to the end of th<a id="_idTextAnchor236"/>is chapter. Now, let’s take a quick look at what we have learned <a id="_idIndexMarker499"/>and<a id="_idIndexMarker500"/> what we will cover in <a href="B18500_04.xhtml#_idTextAnchor238"><em class="italic">Chapter 4</em></a>, <em class="italic">Unpacking, Decryption, and Deobfuscation</em>.</p>
			<h1 id="_idParaDest-118"><a id="_idTextAnchor237"/>Summary</h1>
			<p>In this chapter, we covered the PE structure of Windows executable files. We covered the PE header field by field and examined its importance for static analysis, finishing with the main questions for incident handling and threat intelligence that the PE header of this sample can help us answer.</p>
			<p>We also covered DLLs and how the PE files that reside together in the same virtual memory can communicate and share code and functions through what are called APIs. We also covered how import and export tables work.</p>
			<p>Then, we covered dynamic analysis from its foundation, such as what a process is and what a thread is. We provided step-by-step guidance on how Windows creates a process and loads a PE file, from double-clicking on an application in Windows Explorer up until the program is running in front of you.</p>
			<p>Last but not least, we covered how to dynamically analyze malware with OllyDbg by going through the most important functionalities of this tool to monitor, debug, and even modify the program’s execution. We talked about the different types of breakpoints, how to set them, how they work internally so that you can understand how they can be detected by malware, and how to bypass their anti-reverse engineering techniques. Finally, we covered Windows services and learned how they can be debugged.</p>
			<p>At this point, you should have the foundation to perform basic malware analysis, including static and dynamic analysis. You should also have an understanding of what questions you need to answer in each step and the process you need to follow to have a full understanding of this malware’s functionality.</p>
			<p>In <a href="B18500_04.xhtml#_idTextAnchor238"><em class="italic">Chapter 4</em></a>, <em class="italic">Unpacking, Decryption, and Deobfuscation</em>, we will take our discussion and venture into unpacking, decryption, and deobfuscation into the context of malware. We will explore different techniques that have been introduced by malware authors to bypass detection and trick inexperienced reverse engineers. We will also learn how to bypass these techniques and deal with them.</p>
		</div>
		<div><div></div>
		</div>
	</body></html>