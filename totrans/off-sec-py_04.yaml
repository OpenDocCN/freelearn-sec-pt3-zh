- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python for Security Professionals – Beyond the Basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter looks into complex Python applications designed exclusively for
    security professionals, pushing you beyond the fundamentals and into the field
    of cutting-edge cybersecurity practices.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will not only have a thorough understanding
    of Python’s role in cybersecurity, but you will also have firsthand experience
    designing a comprehensive security tool. You will obtain the expertise required
    to effectively address real-world security concerns through practical examples
    and in-depth explanations.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Utilizing essential security libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Harnessing advanced Python techniques for security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compiling a Python library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advanced Python features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utilizing essential security libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the heart of network analysis is the practice of network scanning. **Network
    scanning** is a technique used to discover devices on a network, determine open
    ports, identify available services, and uncover vulnerabilities. This information
    is invaluable for security assessments and maintaining the overall security of
    a network.
  prefs: []
  type: TYPE_NORMAL
- en: Without further ado, let us write a network scanner. **Scapy** will be our library
    of choice.
  prefs: []
  type: TYPE_NORMAL
- en: Scapy is a powerful packet manipulation tool that allows users to capture, analyze,
    and forge network packets. It can be used for network discovery, security testing,
    and forensic analysis.
  prefs: []
  type: TYPE_NORMAL
- en: How can I determine that Scapy is the preferred library for our tool?
  prefs: []
  type: TYPE_NORMAL
- en: You’ll need to do some Google searches, and you can also use [https://pypi.org/](https://pypi.org/)
    to find modules that suit your needs.
  prefs: []
  type: TYPE_NORMAL
- en: So, now that we have our library, how can I find the modules from Scapy that
    are needed for our tool? For that, you can make use of the documentation that
    is available either at [https://pypi.org/](https://pypi.org/) or the GitHub repository
    for the library ([https://github.com/secdev/scapy](https://github.com/secdev/scapy)).
  prefs: []
  type: TYPE_NORMAL
- en: One effective method for network discovery is utilizing an **Address Resolution
    Protocol** (**ARP**) scan to query devices on the local network, gathering their
    IP and MAC addresses. With Scapy, a powerful packet manipulation library, we can
    create a simple yet efficient script to perform this task. Scapy’s flexibility
    allows for detailed customization of packets, enabling precise control over the
    ARP requests we send out. This not only increases the efficacy of the scanning
    process but also minimizes any potential network disturbance. The following is
    an optimized script that demonstrates this process.
  prefs: []
  type: TYPE_NORMAL
- en: The first step in any Python script involves loading the necessary modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the necessary modules from Scapy, including `ARP`, `Ether` (`srp` (**send
    and** **receive packets**):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We can start by creating the function to perform an ARP scan. The `arp_scan`
    function takes a target IP range as input and creates an ARP request packet for
    each IP address in the specified range. It sends the packets, receives responses,
    and extracts IP and MAC addresses, storing them in a list called `devices_list`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Another task is displaying the scan result in the input-output stream. The
    `print_scan_results` function takes the `devices_list` as input and prints the
    discovered IP and MAC addresses in a formatted manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The `main` function, the primary function to initiate the script, takes the
    target IP range as input, initiates the ARP scan, and prints the scan results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The `if __name__ == "__main__":` block makes the script executable in a command
    line and capable of accepting parameters. The script prompts the user to enter
    the target IP range, such as `192.168.1.1/24`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: To run the script, ensure you are in the virtual environment, have the Scapy
    library installed (`pip install scapy`), and execute it with elevated privilege.
    It will perform an ARP scan on the specified IP range and print the discovered
    devices’ IP and MAC addresses.
  prefs: []
  type: TYPE_NORMAL
- en: 'The result should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1 – Output of the executed ARP scanner script](img/B21287_01_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.1 – Output of the executed ARP scanner script
  prefs: []
  type: TYPE_NORMAL
- en: The preceding is a simple example of how powerful Python libraries are. In addition
    to Scapy, I have listed some of the most common libraries that we can utilize
    in our security operations in the previous chapter. The given libraries are just
    a few; there are many more that you can utilize for different needs.
  prefs: []
  type: TYPE_NORMAL
- en: Let us now deep dive into harnessing advanced Python techniques, utilizing our
    newfound knowledge to navigate complex security terrains with utmost precision,
    innovation, and resilience.
  prefs: []
  type: TYPE_NORMAL
- en: Harnessing advanced Python techniques for security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using the IP addresses obtained from our network scan, we will create a Python
    module, import it into our program, and perform a port scan on these IPs. Along
    the way, we will also cover some advanced Python concepts.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will delve into the intricacies of complex Python concepts,
    starting with basic elements such as **object-oriented programming** and **list
    comprehensions**. We will break down these advanced aspects of Python, making
    them easy to understand, and discuss how they can be utilized in the realm of
    technical security testing.
  prefs: []
  type: TYPE_NORMAL
- en: Before starting the port scanner, we need to import the necessary modules in
    Python, in this case, the `socket` module. The `socket` module is a key tool used
    to create networking interfaces in Python. It is important to do so because the
    `socket` module provides us with the ability to connect with other computers over
    a network. This connection with other computers is a crucial starting point for
    any port scanning procedure. Hence, importing the `socket` module is the first
    step in setting up the port scanner.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this initial stage, we will be importing the necessary modules as usual:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We will initiate the creation of a `PortScanner` class. In the realm of Python,
    a class serves as a blueprint for creating objects that encapsulate a set of variables
    and functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The first method that one encounters within a class is the `__init__` method.
    This method is crucial as it is used to initialize the instances of a class or
    to set the default values. The `__init__` method is a special method in Python
    classes. It acts as a constructor and is automatically called when a new instance
    of the class is created. In this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '**self**: This refers to the instance of the class being created. It allows
    you to access the instance’s attributes and methods.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**target_host**: A parameter representing the target host (e.g., a website
    or IP address) that the port scanner will scan.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**start_port** and **end_port** are parameters representing the range of ports
    to be scanned, from **start_port** to **end_port**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**open_ports**: An empty list that will store the list of open ports found
    during the scanning process. This list is specific to each instance of the **PortScanner**
    class:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The method named `is_port_open` is thoroughly discussed next. This procedure
    is designed to check if certain network ports are open, which is crucial for identifying
    potential vulnerabilities in a network’s security system.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the parameters for the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '**self**: This represents the instance of the class on which the method is
    called.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**port**: This is a parameter representing the port number to be checked for
    openness.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are the principles outlined in the preceding code block elaborated
    on in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '**with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:**: This line
    creates a new socket object:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**socket.AF_INET**: This indicates that the socket will use IPv4 addressing.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**socket.SOCK_STREAM**: This indicates that the socket is a TCP socket, used
    for streaming data.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**s.settimeout(1)**: This sets a timeout of **1** second for the socket. connection
    attempt. If the connection does not succeed within **1** second, a **socket.timeout**
    exception will be raised.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**s.connect((self.target_host, port))**: This attempts to establish a connection
    to the target host (**self.target_host**) on the specified port (**port**).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Handling a connection result**: If the connection attempt is successful (i.e.,
    the port is open and accepts connections), the code inside the **try** block is
    executed without errors. In this case, the method immediately returns **True**,
    indicating that the port is open.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Handling exceptions**: If the connection attempt results in a timeout (**socket.timeout**)
    or **ConnectionRefusedError**, it means the port is closed or unreachable. These
    exceptions are caught in the **except** block, and the method returns **False**,
    indicating that the port is closed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `is_port_open` method is used internally within the `PortScanner` class.
    It provides a simple and reusable way to check whether a specific port on the
    target host is open or closed. By encapsulating this logic into a separate method,
    the code becomes more modular and easier to maintain. The method allows the `PortScanner`
    class to efficiently determine the status of ports during the scanning process.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we discuss the `scan_ports` method. This method is an intricate process
    that systematically scans and analyzes network ports.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the parameter for the method (`self`); it represents the instance
    of the class on which the method is called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are the principles outlined in the preceding code block elaborated
    on in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '`iterable` and optionally filtering the items based on a condition.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The syntax for the list comprehension will be as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The constituents of the structure can be elucidated as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`[port for port in range(self.start_port, self.end_port + 1) if self.is_port_open(port)]`
    line in the `scan_ports` method, it is a list comprehension. Its components can
    be dissected and expounded upon as follows:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`iterable`. They are a fundamental part of Python’s expressive syntax, enabling
    developers to write efficient and readable code.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`start_port` and `end_port`.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`is_port_open` method to check whether the port is open (using the `is_port_open`
    helper method explained earlier).'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`is_port_open(port)` returns `True`. This list comprehensively identifies and
    captures all open ports within the specified range.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`scan_ports` method provides a concise way to scan a range of ports and collect
    the list of open ports. It utilizes list comprehension, a powerful feature in
    Python, to create the `open_ports` list in a single line. By using this method,
    the `PortScanner` class can easily and efficiently identify open ports within
    a specified range on the target host. This method is integral to the functionality
    of the `PortScanner` class, as it encapsulates the logic of scanning and identifying
    open ports.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, we will focus on the `main()` function. The following are its features:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '**target_host = input("Enter target host: ")**: This prompts the user to input
    the target host (e.g., a website domain or IP address) and stores the input in
    the **target_host** variable.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**start_port = int(input("Enter starting port: "))**: This prompts the user
    to input the starting port number and stores the input after converting it to
    an integer in the **start_port** variable.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**end_port = int(input("Enter ending port: "))**: This prompts the user to
    input the ending port number and stores the input after converting it to an integer
    in the **end_port** variable.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is the `main()` function code section:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'The following are the code execution steps explained in depth:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '`PortScanner` class, passing the `target_host`, `start_port`, and `end_port`
    as parameters. This instance will be used to scan ports.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`scan_ports` method of the `PortScanner` instance to scan ports. This method
    returns a list of open ports using list comprehension, as explained in previous
    discussions.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`scan_ports` method using list comprehension.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally, add the following code block to call the `main` method when the file
    is executed as a script, but not when it is utilized as an import module:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: The `if __name__ == "__main__":` line checks whether the script is being run
    directly (not imported as a module). When you execute the script directly, this
    condition evaluates to `True`. If the script is being run directly, it calls the
    `main()` function, initiating the process of input gathering, port scanning, and
    displaying the results.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: In summary, this script prompts the user for a target host, starting port, and
    ending port. It then creates an instance of the `PortScanner` class and uses list
    comprehension to scan ports within the specified range. The open ports are displayed
    to the user. The script is structured to be run directly as a standalone program,
    allowing users to interactively scan ports based on their input.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, let us convert our code into a Python library, so we can install and use
    this library in any of our Python scripts.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Compiling a Python library
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Creating a Python library involves packaging your code in a way that allows
    others to easily install, import, and use it in their projects. To convert your
    code into a Python library, follow these steps:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Organize your code**: Ensure our code is well-organized and follows the package
    structure:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'The components of a Python library are as follows:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '**portscanner/**: The main folder containing your package'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**portscanner/__init__.py**: An empty file indicating that **portscanner**
    is a Python package'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**portscanner/scanner.py**: Your **PortScanner** class and related functions'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**setup.py**: The script for packaging and distributing your library'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**README.md**: Documentation explaining how to use your library'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Update setup.py**:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: In this file, you specify the package name (`portscanner`), version number,
    and the packages to include (use `find_packages()` to automatically discover packages).
    Add any dependencies your library requires to the `install_requires` list.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Package your code**: In your terminal, navigate to the directory containing
    your **setup.py** file and run the following command to create a source distribution
    package:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '**Publish your library (optional)**: If you want to make your library publicly
    available, you can publish it on the **Python Package Index** (**PyPI**). You
    will need to create an account on PyPI and install **twine** if you have not already:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: twine upload dist/*
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '**Install and use your library**: To test your library, you can install it
    locally using **pip**. In the same directory as your **setup.py**, run the following
    command:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 1\. from portscanner.portscanner import PortScanner
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '2.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 3\. scanner = PortScanner(target_host, start_port, end_port)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 4\. open_ports = scanner.scan_ports()
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '5\. print("Open ports: ", open_ports)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: As we bring our discussion on compiling a Python library to a close, we turn
    toward the exploration of advanced Python features to further enhance our knowledge
    and skills in cybersecurity. The following section will delve deeper into these
    sophisticated components of Python.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Advanced Python features
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: We can combine our library created in the earlier section into our network mapping
    tool and transform our code, which does a network scan and a port scan of the
    discovered IP addresses. Let us keep it there and talk about some more advanced
    Python features, starting with **decorators**.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Decorators
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
- en: Decorators are a powerful aspect of Python’s syntax, allowing you to modify
    or enhance the behavior of functions or methods without changing their source
    code.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'For an improved understanding of Python decorators, we will delve into the
    examination of the following code:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'The following are the code execution steps explained in depth:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '**timing_decorator(func)**: This decorator function, known as **timing_decorator(func)**,
    operates by accepting a function (**func**) as a parameter, and then producing
    a new function (**wrapper**). **wrapper** fundamentally functions as a housing
    for the original function, offering an extra layer of operation.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**wrapper(*args, **kwargs)**: This is the **wrapper** function returned by
    the decorator. It captures the arguments and keyword arguments passed to the original
    function, records the start time, calls the original function, records the end
    time, calculates the time taken, prints the duration, and finally returns the
    result of the original function.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let us examine how to utilize this decorator in the code:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Here, `@timing_decorator` decorates the `scan_ports` method using `timing_decorator`.
    It is equivalent to writing `scan_ports =` `timing_decorator(scan_ports)`.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '`timing_decorator` measures the time taken for the `scan_ports` method to execute
    and prints the duration. This is a common use case for decorators, showcasing
    how they can enhance the functionality of methods in a clean and reusable way.
    Decorators provide a flexible and elegant approach to modifying or extending the
    behavior of functions and methods in Python.'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Next, we will explore various scenarios where decorators can be effectively
    employed for enhancing code functionality in an uncomplicated manner. We will
    highlight the benefits of using decorators in improving code maintainability,
    readability, and reusability, ultimately contributing to a more secure and optimized
    code base.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The following are the use cases and benefits of decorators:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Code reusability**: Decorators allow you to encapsulate reusable functionality
    and apply it to multiple functions or methods without duplicating code.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Logging and timing**: Decorators are often used for logging, timing, and
    profiling functions to monitor their behavior and performance.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Authentication and authorization**: Decorators can enforce authentication
    and authorization checks, ensuring that only authorized users can access certain
    functions or methods.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Error handling**: Decorators can handle exceptions raised by functions, providing
    consistent error handling across different parts of the code.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Aspect-oriented programming (AOP)**: Decorators enable AOP, allowing you
    to separate cross-cutting concerns (e.g., logging, security) from the core logic
    of functions or methods.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Method chaining and modification**: Decorators can modify the output or behavior
    of functions, enabling method chaining or transforming return values.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: This previous code usage appears to be almost complete, however, it appears
    that our port scanner tool we started at the beginning of this chapter utilizes
    a list to store the open ports and then return them, which makes the code not
    so memory efficient, so let’s introduce **generators**, another Python concept.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Generators
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
- en: Generators in Python are special types of functions that return a sequence of
    results. They allow you to declare a function that behaves like an iterator, iterating
    over it in a for-loop or explicitly with the next function, while also maintaining
    the program’s internal state and pausing execution between values, thus optimizing
    memory use.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The characteristics of the generator are detailed and explained more thoroughly
    as follows:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Lazy evaluation**: Generators use lazy evaluation, meaning they produce values
    on the fly and only when requested. This makes them memory efficient, especially
    when dealing with large datasets or potentially infinite sequences.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Memory efficiency**: Generators do not store all values in memory at once.
    They generate each value one at a time, consuming minimal memory. This is particularly
    beneficial for working with large data streams.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Efficient iteration**: Generators are **iterable** objects, allowing them
    to be used in loops and comprehensions just like lists. However, they generate
    values efficiently, processing each item as it is needed.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Infinite sequences**: Generators can represent infinite sequences. Since
    they produce values on demand, you can create a generator that theoretically generates
    values forever.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will enhance our understanding of Python generators by thoroughly analyzing
    the following code:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Following are the code execution steps explained in depth to understand the
    generator function behavior:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '**for port in range(self.start_port, self.end_port + 1)**: This loop iterates
    over each port number in the specified range (**self.start_port** to **self.end_port**),
    inclusive of both **start_port** and **end_port**.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**if self.is_port_open(port)**: For each port in the range, it calls the **is_port_open**
    method to check whether the port is open (using the **is_port_open** helper method
    explained earlier).'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**yield port**: If the port is open, the **yield** keyword is used to produce
    a value (**port**) from the generator. The **generator** function maintains its
    state, allowing it to resume execution from where it left off when the next value
    is requested.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The use cases of the generator are detailed and explained further as follows:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Processing large files**: Reading large files line-by-line without loading
    the entire file into memory'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stream processing**: Analyzing real-time data streams where data is continuously
    generated'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Efficient filtering**: Generating filtered sequences without creating intermediate
    lists'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mathematical calculations**: Generating sequences such as Fibonacci numbers
    or prime numbers on the fly'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Generators are a powerful concept in Python, enabling the creation of memory-efficient
    and scalable code, especially when working with large datasets or sequences. They
    are a fundamental feature of Python’s expressive syntax and are widely used in
    various programming scenarios.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Upon utilizing advanced features such as decorators and generators, our code
    will take on a certain form. This is how the code should appear in its final iteration:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Having explored the intricacies of a port scanner script, its modularization,
    and the use of advanced features such as decorators and generators, our next task
    is to delve into the subsequent steps. This translates into a hands-on activity,
    allowing readers an opportunity to further analyze and comprehend coding practices.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to use Python to create a network mapper and
    a port scanner. We covered several complex Python topics along the road, such
    as object-oriented programming, comprehensions, decorators, generators, and how
    to package a Python program into a library.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: You will be able to build more elegant Python code that stands out from the
    crowd with these. The presented concepts are difficult to execute at first, but
    once you get the feel of it, you will never consider coding in any other way.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: The next chapter will dive into the exciting and paramount field of web security
    through the usage of Python. It will explore various strategies, tools, and techniques
    that Python offers to identify and neutralize security threats, alongside understanding
    the fundamentals of web security itself. This knowledge is imperative in today’s
    digital age, where security breaches can come at a high cost.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Activity
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, I will leave it up to you to package both the network scanner and the port
    scanner into a library and use the libraries to write a more compact script that
    does a network scan and scan for open ports for each IP that is found.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Readers are recommended to follow the outlined steps to reinforce the concepts
    presented in this chapter. Every task designed within this activity aims to test
    and solidify the reader’s comprehension effectively:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Package both code snippets into the library.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Name your new Python file **network-and-port-scanner.py**.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Import both libraries into the new program.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Use argument parsing to obtain the IP and port ranges for scanning.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Pass the IP address range to the network mapper for ARP scanning and write the
    IPs to a file.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Read the IPs from the file and provide the discovered IP addresses with the
    port range to the port scanner.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Print the IPs and ports into a table in a more visually appealing manner.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
