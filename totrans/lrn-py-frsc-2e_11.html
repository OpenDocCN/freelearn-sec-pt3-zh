<html><head></head><body>
        

                            
                    <h1 class="header-title">Parsing Outlook PST Containers</h1>
                
            
            
                
<p><strong>Electronic mail</strong> (<strong>email</strong>) continues to be one of the most common methods of communication in the workplace, surviving the number of new communication services present in today's world. Emails can be sent from computers, websites, and the phones that're in so many pockets across the globe. This medium allows for the transmission of information in the form of text, HTML, attachments, and more in a reliable fashion. It's no wonder, then, that emails can play a large part in investigations, especially for cases involving the workplace. In this chapter, we're going to work with a common email format, <strong>Personal Storage Table</strong> (<strong>PST</strong>), used by Microsoft Outlook to store email content in a single file.</p>
<p>The script we'll develop in this chapter introduces us to a series of operations available through the <kbd>libpff</kbd> library developed by Joachim Metz. This library allows us to open PST file and explore its contents in a Pythonic manner. Additionally, the code we build demonstrates how to create dynamic, HTML-based, graphics to provide additional context to spreadsheet-based reports. For these reports, we'll leverage the Jinja2 module, introduced in <a href="a4ae250a-8aa8-49b9-8fd6-0cac51975f11.xhtml" target="_blank">Chapter 5</a>, <em>Databases in Python</em>, and the D3.js framework to generate our dynamic HTML-based charts.</p>
<p>The D3.js project is a JavaScript framework that allows us to design informative and dynamic charts without much effort. The charts used in this chapter are open source examples of the framework shared with the community at <a href="https://github.com/d3/d3" target="_blank">https://github.com/d3/d3</a>. Since this book doesn't focus on JavaScript, nor does it introduce the language, we won't cover the implementation details to create these charts. Instead, we'll demonstrate how to add our Python results to a pre-existing template.</p>
<p>Finally, we'll use a sample PST file, which has a large variety of data across time, to test our script. As always, we recommend running any code against test files before using it in casework to validate the logic and feature coverage. The library used in this chapter is in active development and is labeled experimental by the developer.</p>
<p>The following are the topics covered in this chapter:</p>
<ul>
<li>Understanding the background of PST files</li>
<li>Leveraging <kbd>libpff</kbd> and its Python bindings, <kbd>pypff</kbd>, to parse PST files</li>
<li>Creating informative and professional charts using Jinja2 and D3.js</li>
</ul>
<p>The code for this chapter is developed and tested using Python 2.7.15.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The PST file format</h1>
                
            
            
                
<p>The PST format is a type of <strong>Personal File Format</strong> (<strong>PFF</strong>). Two other types of PFF file include the <strong>Personal Address Book</strong> (<strong>PAB</strong>) for storing contacts and the <strong>Offline Storage Table</strong> (<strong>OST</strong>), which stores offline email, calendars, and tasks. By default, Outlook stores cached email information in OST files, which can be found at the locations specified in the following table. Items in Outlook will be stored in a PST file if archived:</p>
<table border="1" style="border-collapse: collapse;width: 100.413%">
<tbody>
<tr>
<td style="width: 10.1928%">
<p class="TableColumnHeadingPACKT"><strong>Windows version</strong></p>
</td>
<td style="width: 18.3196%">
<p class="TableColumnHeadingPACKT"><strong>Outlook version</strong></p>
</td>
<td style="width: 70.7989%">
<p class="TableColumnHeadingPACKT"><strong>OST location</strong></p>
</td>
</tr>
<tr>
<td style="width: 10.1928%">
<p class="TableColumnContentPACKT">Windows XP</p>
</td>
<td style="width: 18.3196%">
<p class="TableColumnContentPACKT">Outlook 2000/2003/2007</p>
</td>
<td style="width: 70.7989%">
<p><kbd>C:\Documents and Settings\USERPROFILE%\Local Settings\Application Data\Microsoft\Outlook</kbd></p>
</td>
</tr>
<tr>
<td style="width: 10.1928%">
<p class="TableColumnContentPACKT">Windows Vista/7/8</p>
</td>
<td style="width: 18.3196%">
<p class="TableColumnContentPACKT">Outlook 2007</p>
</td>
<td style="width: 70.7989%">
<p><kbd>C:\Users\%USERPROFILE%\AppData\Local\Microsoft\Outlook</kbd></p>
</td>
</tr>
<tr>
<td style="width: 10.1928%">
<p class="TableColumnContentPACKT">Windows XP</p>
</td>
<td style="width: 18.3196%">
<p class="TableColumnContentPACKT">Outlook 2010</p>
</td>
<td style="width: 70.7989%">
<p class="TableColumnContentPACKT"><kbd>C:Documents and Settings\%USERPROFILE%\My Documents\Outlook Files</kbd></p>
</td>
</tr>
<tr>
<td style="width: 10.1928%">
<p class="TableColumnContentPACKT">Windows Vista/7/8</p>
</td>
<td style="width: 18.3196%">
<p class="TableColumnContentPACKT">Outlook 2010/2013</p>
</td>
<td style="width: 70.7989%">
<p class="TableColumnContentPACKT"><kbd>C:\Users\%USERPROFILE%\Documents\Outlook Files</kbd> </p>
</td>
</tr>
</tbody>
</table>
<p>From: <a href="https://forensicswiki.org/wiki/Personal_Folder_File_(PAB,_PST,_OST)" target="_blank">https://forensicswiki.org/wiki/Personal_Folder_File_(PAB,_PST,_OST)</a>. Location of OST files by default.</p>
<p class="packt_figure">The <kbd>%USERPROFILE%</kbd> field is dynamic and replaced with the user account name on the machine. PFF files can be identified through the hex file signature of <kbd>0x2142444E</kbd> or <kbd>!BDN</kbd> in ASCII. After the file signature, the type of PFF file is denoted by 2 bytes at offset 8:</p>
<table border="1" style="border-collapse: collapse;width: 50.3439%">
<tbody>
<tr>
<td style="width: 14%">
<p class="TableColumnHeadingPACKT"><strong>Type</strong></p>
</td>
<td style="width: 16%">
<p class="TableColumnHeadingPACKT"><strong>Hex signature</strong></p>
</td>
<td style="width: 17.4132%">
<p class="TableColumnHeadingPACKT"><strong>ASCII signature</strong></p>
</td>
</tr>
<tr>
<td style="width: 14%">
<p class="TableColumnContentPACKT">PST</p>
</td>
<td style="width: 16%">
<p class="TableColumnContentPACKT">534D</p>
</td>
<td style="width: 17.4132%">
<p class="TableColumnContentPACKT">SM</p>
</td>
</tr>
<tr>
<td style="width: 14%">
<p class="TableColumnContentPACKT">OST</p>
</td>
<td style="width: 16%">
<p class="TableColumnContentPACKT">534F</p>
</td>
<td style="width: 17.4132%">
<p class="TableColumnContentPACKT">SO</p>
</td>
</tr>
<tr>
<td style="width: 14%">
<p class="TableColumnContentPACKT">PAB</p>
</td>
<td style="width: 16%">
<p class="TableColumnContentPACKT">4142</p>
</td>
<td style="width: 17.4132%">
<p class="TableColumnContentPACKT">AB</p>
</td>
</tr>
</tbody>
</table>
<p>From http://www.garykessler.net/library/file_sigs.html</p>
<p>The content type (such as 32-bit or 64-bit) is defined at byte offset 10. The structure of the PFF file format has been described in detail by Joachim Metz in several papers that document the technical structure and how to manually parse these files on GitHub at the project's code repository: <a href="https://github.com/libyal/libpff" target="_blank">https://github.com/libyal/libpff</a>.</p>
<p>In this chapter, we'll work only with PST files and we can ignore the differences in OST and PAB files. By default, PST archives have a root area containing a series of folders and messages depending on how the archives were created. For example, a user may archive all folders in their view or only a select few. All of the items within the selected content will be exported into the PST file.</p>
<p>In addition to users archiving content, Outlook has an automatic archiving feature that will store items in the PST files after a set time as defined in the following table. Once this expiration period has been reached, the items will be included in the next archive created. The automatic archive stores PSTs by default in <kbd>%USERPROFILE%\Documents\Outlook</kbd> in Windows 7, <kbd>%APPDATA%\Local\Microsoft\Outlook</kbd> in Vista, and <kbd>%APPDATA%\Local Settings\Microsoft\Outlook</kbd> in XP. These defaults could be set by the user or by group policy in a domain environment. This automatic archive functionality provides examiners with a great history of communication information that we can access and interpret in our investigations:</p>
<table border="1" style="border-collapse: collapse;width: 58.3219%">
<tbody>
<tr>
<td style="width: 34%">
<p class="TableColumnHeadingPACKT"><strong>Folder</strong></p>
</td>
<td style="width: 22.4022%">
<p class="TableColumnHeadingPACKT"><strong>Default aging period</strong></p>
</td>
</tr>
<tr>
<td style="width: 34%">
<p class="TableColumnContentPACKT">Inbox and Drafts</p>
</td>
<td style="width: 22.4022%">
<p class="TableColumnContentPACKT">6 months</p>
</td>
</tr>
<tr>
<td style="width: 34%">
<p class="TableColumnContentPACKT">Sent Items and Deleted Items</p>
</td>
<td style="width: 22.4022%">
<p class="TableColumnContentPACKT">2 months</p>
</td>
</tr>
<tr>
<td style="width: 34%">
<p class="TableColumnContentPACKT">Outbox</p>
</td>
<td style="width: 22.4022%">
<p class="TableColumnContentPACKT">3 months</p>
</td>
</tr>
<tr>
<td style="width: 34%">
<p class="TableColumnContentPACKT">Calendar</p>
</td>
<td style="width: 22.4022%">
<p class="TableColumnContentPACKT">6 months</p>
</td>
</tr>
<tr>
<td style="width: 34%">
<p class="TableColumnContentPACKT">Tasks</p>
</td>
<td style="width: 22.4022%">
<p class="TableColumnContentPACKT">6 months</p>
</td>
</tr>
<tr>
<td style="width: 34%">
<p class="TableColumnContentPACKT">Notes</p>
</td>
<td style="width: 22.4022%">
<p class="TableColumnContentPACKT">6 months</p>
</td>
</tr>
<tr>
<td style="width: 34%">
<p class="TableColumnContentPACKT">Journal</p>
</td>
<td style="width: 22.4022%">
<p class="TableColumnContentPACKT">6 months</p>
</td>
</tr>
</tbody>
</table>
<p>Table 11.1: Default aging of Outlook items (https://support.office.com/en-us/article/Automatically-move-or-delete-older-items-with-AutoArchive-e5ce650b-d129-49c3-898f-9cd517d79f8e)</p>


            

            
        
    

        

                            
                    <h1 class="header-title">An introduction to libpff</h1>
                
            
            
                
<p>The <kbd>libpff</kbd> library allows us to reference and navigate through PST objects in a programmatic manner. The <kbd>root_folder()</kbd> function allows us to reference <kbd>RootFolder</kbd>, which is the base of the PST file and the starting point for our recursive analysis of email content. Within <kbd>RootFolder</kbd> are folders and messages. The folders can contain other sub-folders or messages. Folders have properties that include the name of the folder, the number of subfolders, and the number of submessages. Messages are objects representing messages and have attributes, including the subject line, the name of all participants, and several timestamps.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to install libpff and pypff</h1>
                
            
            
                
<p>Installing some third-party libraries is more difficult than running <kbd>pip install &lt;library_name&gt;</kbd>. In the case of <kbd>libpff</kbd> and the <kbd>pypff</kbd> bindings, we need to take a few steps and follow the instructions outlined in the GitHub project repository. The <kbd>libpff</kbd> wiki (located at <a href="https://github.com/libyal/libpff/wiki/Building" target="_blank">https://github.com/libyal/libpff/wiki/Building</a>) describes the steps we need to take in order to build <kbd>libpff</kbd>.</p>
<p>We'll briefly walk through how you would build this library on an Ubuntu 18.04 system. After downloading and installing Ubuntu 18.04 (preferably in a virtual machine), you'll want to install the dependencies by running the following:</p>
<pre><strong>sudo apt-get update</strong><br/><strong>sudo apt-get install git python-dev python-pip autoconf automake \</strong><br/><strong>    autopoint libtool pkg-config</strong></pre>
<p>This will install the required packages for both our script and the <kbd>pypff</kbd> bindings. We'll then want to download our <kbd>libpff</kbd> code by running the following command:</p>
<pre><strong>git clone https://github.com/libyal/libpff</strong></pre>
<p>Once the <kbd>git clone</kbd> command completes, we'll navigate into the new <kbd>libpff</kbd> directory and run the following commands to download additional dependencies, configure, and install the components we need for the library:</p>
<pre><strong>cd libpff</strong><br/><strong>./synclibs.ps1</strong><br/><strong>./autogen.ps1</strong><br/><strong>./configure --enable-python</strong><br/><strong>make</strong><br/><strong>make install</strong></pre>
<p>Additional build options are described further on the <kbd>libpff</kbd> wiki page.</p>
<p>At this point, you should be able to run the following statements and get the same output, though your version may vary:</p>
<pre><strong>python</strong><br/><strong>&gt;&gt;&gt; import pypff</strong><br/><strong>&gt;&gt;&gt; pypff.get_version()</strong><br/><strong>u'20180812'</strong></pre>
<p>To make this process easier for you, we've prebuilt the <kbd>pypff</kbd> bindings and created a Dockerfile to run this entire setup for you. If you're unfamiliar with Docker, it's a virtualization environment that allows us to run virtual machines with minimal effort. While Docker is generally used to host applications, we'll use it more as a traditional virtual machine. What makes this advantageous for us is that we can distribute a configuration file that you can run on your system and generate the same environment that we've tested.</p>
<p>To begin, please follow the instructions to install Docker on your system from <a href="https://docs.docker.com/install/">https://docs.docker.com/install/</a>. Once installed and running, navigate to the <kbd>Chapter 11</kbd> code folder on your system and run the <kbd>docker build</kbd> command. This command will generate a system following a series of preconfigured steps:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-444 image-border" src="img/e560c17a-8832-4e57-bb38-a5163ddd3b28.png" style="width:28.08em;height:3.50em;"/></p>
<p>This will create a new image named <kbd>lpff-ch11</kbd> with the version number 20181130. An image in Docker is what it sounds like: a base installation that you can use to create running machines. This way you can have multiple machines all based on the same image. Each machine is called a container, and to create a container from this image, we'll use the <kbd>docker run</kbd> statement:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-445 image-border" src="img/1e6dc4dd-69ab-4de0-a5ba-00efa49927a3.png" style="width:42.00em;height:6.50em;"/></p>
<p class="mce-root"/>
<p>The <kbd>-it</kbd> flag in the <kbd>docker run</kbd> command asks Docker to connect to the bash shell once the container is created. The <kbd>-P</kbd> parameter asks Docker to provide us with networking to, in our case, the web server running on the container. Lastly, the <kbd>--name</kbd> argument allows us to assign a familiar name to our container. We then pass in the image name and version and run the command. As you can see, we're provided with a root shell as soon as the Docker instance finishes.</p>
<p>Regarding the previously mentioned web server, we've included <kbd>lighttpd</kbd> to allow us to serve our HTML-generated report as a web page. This isn't necessary, though we wanted to highlight how these reports could be made accessible on an internal system.</p>
<p>Please don't run this Docker container on a public network as it'll allow anyone with access to your machine's IP address to see your HTML reports. </p>
<p>In the preceding screenshot, we start this web server by running <kbd>server lighttpd start</kbd> and then list the contents of our current directory. As you can see, we have two files, our <kbd>pst_indexer.py</kbd> script that we're about to build and the <kbd>stats_template.html</kbd> that we'll use to generate our sharp report. Let's build our Python script.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Exploring PSTs – pst_indexer.py</h1>
                
            
            
                
<p>In this script, we'll harvest information about the PST file, taking note of the messages in each folder and generating statistics for word usage, frequent senders, and a heat map for all email activity. Using these metrics, we can go beyond the initial collection and reporting of messages and explore trends in the language used or communication patterns with certain individuals. The statistics section highlights examples of how we can utilize the raw data and build informative graphics to assist the examiner. We recommend tailoring the logic to your specific investigation to provide the most informative report possible. For example, for the word count, we'll only be looking at the top ten words that're alphanumeric and longer than four characters, to help reduce common words and symbols. This might not provide the correct information for your investigation and might require tailoring to your specific situation.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">An overview</h1>
                
            
            
                
<p>This chapter's script was built to work with Python 2.7.15 and requires the third-party libraries described in the previous section. Please consider using the Docker image alongside this script.</p>
<p>As with our other chapters, this script starts by importing libraries we use at the top. In this chapter, we use two new libraries, one of which is third-party. We've already introduced <kbd>pypff</kbd>, the Python bindings to the <kbd>libpff</kbd> library. The <kbd>pypff</kbd> module specifies the Python bindings that allow us access to the compiled code. On line 8, we introduce <kbd>unicodecsv</kbd>, a third-party library we've used previously in <a href="a4ae250a-8aa8-49b9-8fd6-0cac51975f11.xhtml" target="_blank">Chapter 5</a>, <em>Databases in Python</em>. This library allows us to write Unicode characters to CSV files as the native CSV library doesn't support Unicode characters as nicely.</p>
<p>On line 6, we import a standard library called <kbd>collections</kbd> that provides a series of useful interfaces including <kbd>Counter</kbd>. The <kbd>Counter</kbd> module allows us to provide values to it and it handles the logic of counting and storing objects. In addition to this, the collections library provides <kbd>OrderedDict</kbd>, which is extremely useful when you need to create a dictionary with keys in a specified order. The <kbd>OrderedDict</kbd> module isn't leveraged in this book though it does have its place in Python when you wish to use key-value pairs in an ordered list-like fashion:</p>
<pre>001 """Index and summarize PST files"""<br/>002 import os<br/>003 import sys<br/>004 import argparse<br/>005 import logging<br/>006 from collections import Counter<br/>007 <br/>008 import jinja2<br/>009 import pypff<br/>010 import unicodecsv as csv</pre>
<p>Following our license and script metadata, we'll set up a few global variables. These variables will help us decrease the number of variables we must pass into functions. The first global variable is <kbd>output_directory</kbd>, defined on line 46, which will store a string path set by the user. The <kbd>date_dictionary</kbd>, defined on line 47, uses dictionary comprehension to create keys 1 through 24 and map them to the integer 0. We then use list comprehension on line 48 to append seven instances of this dictionary to <kbd>date_list</kbd>. This list is leveraged to build a heat map to show information about activity within the PST file split within seven days' worth of 24-hour columns:</p>
<pre>040 __authors__ = ["Chapin Bryce", "Preston Miller"]<br/>041 __date__ = 20181027<br/>042 __description__ = '''This scripts handles processing and<br/>043     output of PST Email Containers'''<br/>044 logger = logging.getLogger(__name__)<br/>045 <br/>046 output_directory = ""<br/>047 date_dict = {x:0 for x in range(1, 25)}<br/>048 date_list = [date_dict.copy() for x in range(7)]</pre>
<p>This heat map will establish baseline trends and help identify anomalous activity. An example includes the ability to see a spike in activity at midnight on week nights or excessive activity on Wednesdays before the business day starts. The <kbd>date_list</kbd> has seven dictionaries, one for each day, each of which is identical and contains a key-value pair for the hour of the day with the default value of <kbd>0</kbd>.</p>
<p>The <kbd>date_dict.copy()</kbd> call on line 48 is required to ensure that we can update the hours within a single date. If we omit the <kbd>copy()</kbd> method, every day will be updated. This is because dictionaries are tied together by references to the original object, and we're generating a list of objects without the <kbd>copy()</kbd> method. When we do use this function, it allows us to create a copy of the values with a new object, so we can create a list of different objects.</p>
<p>With these variables built, we can reference and update their values throughout other functions without needing to pass them again. Global variables are read-only by default and require a special global command in order to be modified by a function.</p>
<p>The following functions outline our script's operation. As usual, we have our <kbd>main()</kbd> function to control behavior. The following is the <kbd>make_path()</kbd> function, which is a utility to assist us in gathering full paths for our output files. The <kbd>folder_traverse()</kbd> and <kbd>check_for_msgs()</kbd> functions are used to iterate through the available items and start processing:</p>
<pre>051 def main():<br/>...<br/>078 def make_path():<br/>...<br/>089 def folder_traverse():<br/>...<br/>103 def check_for_msgs(): </pre>
<p>Our remaining functions focus on processing and reporting data within PSTs. The <kbd>process_message()</kbd> function reads the message and returns the required attributes for our reports. The first reporting function is the <kbd>folder_report()</kbd> function. This code creates a CSV output for each folder found within the PST and describes the content found within each.</p>
<p class="mce-root"/>
<p>This function also processes data for the remaining reports by writing message bodies to a single text file, stores each set of dates, and preserves a list of the senders. By caching this information to a text file, the next function is easily able to read the file without a major impact on memory.</p>
<p>Our <kbd>word_stats()</kbd> function reads and ingests the information into a collection. The <kbd>Counter()</kbd> object is used in our <kbd>word_report()</kbd> function. When generating our word count report, we read the collection's. <kbd>Counter()</kbd> object into a CSV file, which  will be read by our JavaScript code. The <kbd>sender_report()</kbd> and <kbd>date_report()</kbd> functions also flush data to delimited files for interpretation by JavaScript in the report. Finally, our <kbd>html_report()</kbd> function opens our report template and writes the custom report information into an HTML file in our output folder:</p>
<pre>118 def process_msg():<br/>...<br/>138 def folder_report():<br/>...<br/>193 def word_stats():<br/>...<br/>208 def word_report():<br/>...<br/>235 def sender_report():<br/>...<br/>260 def date_report():<br/>...<br/>277 def html_report():</pre>
<p>As with all of our scripts, we handle our arguments, logs, and the <kbd>main()</kbd> function call under the <kbd>if __name__ == "__main__":</kbd> conditional statement on line 302. We define the required arguments, <kbd>PST_FILE</kbd> and <kbd>OUTPUT_DIR</kbd>, and the user can specify optional arguments, <kbd>--title</kbd> and <kbd>-l</kbd>, for a custom report title and log path:</p>
<pre>302 if __name__ == "__main__":<br/>303     parser = argparse.ArgumentParser(<br/>304         description=__description__,<br/>305         epilog='Built by {}. Version {}'.format(<br/>306             ", ".join(__authors__), __date__),<br/>307        formatter_class=argparse.ArgumentDefaultsHelpFormatter<br/>308     )<br/>309     parser.add_argument('PST_FILE',<br/>310         help="PST File Format from Microsoft Outlook")<br/>311     parser.add_argument('OUTPUT_DIR',<br/>312         help="Directory of output for temporary and report files.")<br/>313     parser.add_argument('--title', default="PST Report",<br/>314         help='Title of the HTML Report.')<br/>315     parser.add_argument('-l',<br/>316         help='File path of log file.')<br/>317     args = parser.parse_args()</pre>
<p>After defining our arguments, we begin processing them so that we can pass them to the <kbd>main()</kbd> function in a standardized and safe manner. On line 319, we convert the output location into an absolute path so that we can be sure about accessing the correct location throughout the script. Notice how we're calling the <kbd>output_directory</kbd> global variable and assigning a new value to it. This is only possible because we're not within a function. If we were modifying the global variable within a function, we would need to write <kbd>global output_directory</kbd> on line 318:</p>
<pre>319     output_directory = os.path.abspath(args.OUTPUT_DIR)<br/>320 <br/>321     if not os.path.exists(output_directory):<br/>322         os.makedirs(output_directory)</pre>
<p>After we modify the <kbd>output_directory</kbd> variable, we make sure the path exists (and create it if it doesn't) to avoid errors later in the code. Once complete, we then use our standard logging code snippet to configure logging for this script on lines 331 through 339. On lines 341 through 345, we log debug information on the system executing the script prior to calling the <kbd>main()</kbd> function. On line 346, we call the <kbd>main()</kbd> function and pass the <kbd>args.PST_FILE</kbd> and <kbd>args.title</kbd> arguments. We don't need to pass the <kbd>output_directory</kbd> value because we can reference it globally. Once we pass the arguments and the <kbd>main()</kbd> function completes execution, we log that the script has finished executing on line 347:</p>
<pre>331     logger.setLevel(logging.DEBUG)<br/>332     msg_fmt = logging.Formatter("%(asctime)-15s %(funcName)-20s"<br/>333         "%(levelname)-8s %(message)s")<br/>334     strhndl = logging.StreamHandler(sys.stderr) # Set to stderr<br/>335     strhndl.setFormatter(fmt=msg_fmt)<br/>336     fhndl = logging.FileHandler(log_path, mode='a')<br/>337     fhndl.setFormatter(fmt=msg_fmt)<br/>338     logger.addHandler(strhndl)<br/>339     logger.addHandler(fhndl)<br/>340     <br/>341     logger.info('Starting PST Indexer v. {}'.format(__date__))<br/>342     logger.debug('System ' + sys.platform)<br/>343     logger.debug('Version ' + sys.version.replace("\n", " "))<br/>344 <br/>345     logger.info('Starting Script')<br/>346     main(args.PST_FILE, args.title)<br/>347     logger.info('Script Complete')</pre>
<p class="mce-root"/>
<p>The following flowchart highlights how the functions interact with each other. This flowchart might seem a little complicated but encapsulates the basic structure of our script.</p>
<p>The <kbd>main()</kbd> function calls the recursive <kbd>folder_traverse()</kbd> function, which in turn finds, processes, and summarizes messages and folders from the root folder. After this, the <kbd>main()</kbd> function generates reports with the word, sender, and date reports, which get displayed in one HTML report generated by the <kbd>html_report()</kbd> function. As a note, the dashed lines represent functions that return a value, while the solid lines represent a function that returns no value:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-446 image-border" src="img/41b0ceae-68da-4acd-9cec-2fb60a9fd531.png" style="width:42.25em;height:35.92em;"/></p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Developing the main() function</h1>
                
            
            
                
<p>The <kbd>main()</kbd> function controls the primary operations of the script, from opening and initial processing of the file, traversing the PST, to generating our reports. On line 62, we split the name of the PST file from its path using the <kbd>os.path</kbd> module.</p>
<p>We'll use the <kbd>pst_name</kbd> variable if a custom title isn't supplied by the user. On the next line, we use the <kbd>pypff.open()</kbd> function to create a PST object. We use the <kbd>get_root_folder()</kbd> method to get the PST root folder so we can begin the iteration process and discover items within the folders:</p>
<pre>051 def main(pst_file, report_name):<br/>052     """<br/>053     The main function opens a PST and calls functions to parse<br/>054     and report data from the PST<br/>055     :param pst_file: A string representing the path to the PST<br/>056     file to analyze<br/>057     :param report_name: Name of the report title<br/>058         (if supplied by the user)<br/>059     :return: None<br/>060     """<br/>061     logger.debug("Opening PST for processing...")<br/>062     pst_name = os.path.split(pst_file)[1]<br/>063     opst = pypff.open(pst_file)<br/>064     root = opst.get_root_folder()</pre>
<p>With the root folder extracted, we call the <kbd>folder_traverse()</kbd> function on line 67 to begin traversing the directories within the PST container. We'll cover the nature of this function in the next section. After traversing the folders, we start generating our reports with the <kbd>word_stats()</kbd>, <kbd>sender_report()</kbd>, and <kbd>date_report()</kbd> functions. On line 74, we pass the name of the report, the PST name, and lists containing the most frequent words and senders to provide statistical data for our HTML dashboard, as follows:</p>
<pre>066     logger.debug("Starting traverse of PST structure...")<br/>067     folder_traverse(root)<br/>068 <br/>069     logger.debug("Generating Reports...")<br/>070     top_word_list = word_stats()<br/>071     top_sender_list = sender_report()<br/>072     date_report()<br/>073 <br/>074     html_report(report_name, pst_name, top_word_list,<br/>075         top_sender_list)</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Evaluating the make_path() helper function</h1>
                
            
            
                
<p>To make life simpler, we've developed a helper function, <kbd>make_path()</kbd>, defined on line 78. Helper functions allow us to reuse code that we might normally write out many times throughout our script in one function call. With this code, we take an input string representing a file name and return the absolute path of where the file should exist within the operating system based on the <kbd>output_directory</kbd> value supplied by the user. On line 85, two operations take place; first, we join the <kbd>file_name</kbd> to the <kbd>output_directory</kbd> value with the correct path delimiters using the <kbd>os.path.join()</kbd> method.</p>
<p>Next, this value is processed by the <kbd>os.path.abspath()</kbd> method, which provides the full file path within the operating system environment. We then return this value to the function that originally called it. As we saw in the flow diagram, many functions will make calls to the <kbd>make_path()</kbd> function:</p>
<pre>078     def make_path(file_name):<br/>079     """<br/>080     The make_path function provides an absolute path between the<br/>081     output_directory and a file<br/>082     :param file_name: A string representing a file name<br/>083     :return: A string representing the path to a specified file<br/>084     """<br/>085     return os.path.abspath(os.path.join(output_directory,<br/>086         file_name))</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Iteration with the folder_traverse() function</h1>
                
            
            
                
<p>This function recursively walks through folders to parse message items and indirectly generates summary reports on the folder. This function, initially provided the root directory, is generically developed to be capable of handling any folder item passed to it. This allows us to reuse the function for each discovered subfolder. On line 97, we use a <kbd>for</kbd> loop to recurse through the <kbd>sub_folders</kbd> iterator generated from our <kbd>pypff.folder</kbd> object. On line 98, we check whether the folder object has any additional subfolders and, if it does, call the <kbd>folder_traverse()</kbd> function again before checking the current folder for any new messages. We only check for messages in the event that there are no new subfolders:</p>
<pre>089 def folder_traverse(base):<br/>090     """<br/>091     The folder_traverse function walks through the base of the<br/>092     folder and scans for sub-folders and messages<br/>093     :param base: Base folder to scan for new items within<br/>094         the folder.<br/>095     :return: None<br/>096     """<br/>097     for folder in base.sub_folders:<br/>098         if folder.number_of_sub_folders:<br/>099             folder_traverse(folder) # Call new folder to traverse<br/>100         check_for_msgs(folder)</pre>
<p>This is a recursive function because we call the same function within itself (a loop of sorts). This loop could potentially run indefinitely, so we must make sure the data input will have an end to it. A PST should have a limited number of folders and will therefore eventually exit the recursive loop. This is essentially our PST specific <kbd>os.walk()</kbd> function, which iteratively walks through filesystem directories. Since we're working with folders and messages within a file container, we have to create our own recursion. Recursion can be a tricky concept to understand; to guide you through it, please reference the following diagram when reading our explanation in the upcoming paragraphs:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-447 image-border" src="img/fdd3782c-1bd5-4025-a20d-94d7cefca744.png" style="width:80.50em;height:31.33em;"/></p>
<p>In the preceding diagram, there're five levels in this PST hierarchy, each containing a mixture of blue folders and green messages. On level <strong>1</strong>, we have <kbd>Root Folder</kbd>, which is the first iteration of the <kbd>folder_traverse()</kbd> loop. Since this folder has a single subfolder, <kbd>Top of Personal Folders</kbd>, as you can see on level <strong>2</strong>, we rerun the function before exploring the message contents. When we rerun the function, we now evaluate the <kbd>Top of Personal Folders</kbd> folder and find that it also has subfolders.</p>
<p>Calling the <kbd>folder_traverse()</kbd> function again on each of the subfolders, we first process the Deleted Items folder on level <strong>3</strong>. Inside the <kbd>Deleted Items</kbd> folder on level 4, we find that we only have messages in this folder and call the <kbd>check_for_msgs()</kbd> function for the first time.</p>
<p class="mce-root"/>
<p>After the <kbd>check_for_msgs()</kbd> function returns, we go back to the previous call of the <kbd>folder_traverse()</kbd> function on level 3 and evaluate the <kbd>Sent Items</kbd> folder. Since the <kbd>Sent Items</kbd> folder also doesn't have any subfolders, we process its messages before returning to level 3.</p>
<p>We then reach the <kbd>Inbox</kbd> folder on level 3 and call the <kbd>folder_traverse()</kbd> function on the <kbd>Completed Cases</kbd> subfolder on level 4. Now that we're in level 5, we process the two messages inside the <kbd>Completed Cases</kbd> folder. With these two messages processed, we step back to level 4 and process the two messages within the <kbd>Inbox</kbd> folder. Once these messages are processed, we've completed all items in levels 3, 4, and 5 and can finally move back to level 2. Within <kbd>Root Folder</kbd>, we can process the three message items there before the function execution concludes. Our recursion, in this case, works from the bottom up.</p>
<p>These four lines of code allow us to navigate through the entire PST and call additional processing on every message in every folder. Though this is usually provided to us through methods such as <kbd>os.walk()</kbd>, some libraries don't natively support recursion and require the developer to do so using the existing functionality within the library.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Identifying messages with the check_for_msgs() function</h1>
                
            
            
                
<p>This function is called for every discovered folder in the <kbd>folder_traverse()</kbd> function and handles the processing of messages. On line 110, we log the name of the folder to provide a record of what has been processed. Following this, we create a list to append messages on line 111 and begin iterating through the messages in the folder on line 112.</p>
<p>Within this loop, we call the <kbd>process_msg()</kbd> function to extract the relevant fields into a dictionary. After each message dictionary has been appended to the list, we call the <kbd>folder_report()</kbd> function, which will create a summary report of all of the messages within the folder:</p>
<pre>103 def check_for_msgs(folder):<br/>104     """<br/>105     The check_for_msgs function reads folder messages if<br/>106     present and passes them to the report function<br/>107     :param folder: pypff.Folder object<br/>108     :return: None<br/>109     """<br/>110     logger.debug("Processing Folder: " + folder.name)<br/>111     message_list = []<br/>112     for message in folder.sub_messages:<br/>113         message_dict = process_msg(message)<br/>114         message_list.append(message_dict)<br/>115     folder_report(message_list, folder.name)</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Processing messages in the process_msg() function</h1>
                
            
            
                
<p>This function is called the most as it runs for every discovered message. When you're considering how to improve the efficiency of your code base, these are the types of functions to look at. Even a minor efficiency improvement in function that're called frequently can have a large effect on your script.</p>
<p>In this case, the function is simple and exists mainly to remove clutter from another function. Additionally, it compartmentalizes message processing within a single function and will make it easier to troubleshoot bugs associated with message processing.</p>
<p>The return statement on line 126 passes a dictionary to the calling function. This dictionary contains a key-value pair for each of the <kbd>pypff.message</kbd> object attributes. Note that the <kbd>subject</kbd>, <kbd>sender</kbd>, <kbd>transport_headers</kbd>, and <kbd>plain_text_body</kbd> attributes are strings. The <kbd>creation_time</kbd>, <kbd>client_submit_time</kbd>, and <kbd>delivery_time</kbd> attributes are Python <kbd>datetime.datetime</kbd> objects and the <kbd>number_of_attachments</kbd> attribute is an integer.</p>
<p>The subject attribute contains the subject line found within the message and <kbd>sender_name</kbd> contains a single string of the name of the sender who sent the message. The sender name might reflect an email address or the contact name depending on whether the recipient resolved the name.</p>
<p>The <kbd>transport_headers</kbd> contains the email header data transmitted with any message. This data should be read from the bottom up, as new data is added to the top of the header as a message moves between mail servers. We can use this information to possibly track the movement of a message using hostnames and IP addresses. The <kbd>plain_text_body</kbd> attribute returns the body as plain text, though we could display the message in RTF or HTML format using the <kbd>rtf_body</kbd> and <kbd>html_body</kbd> attributes, respectively.</p>
<p>The <kbd>creation_times</kbd> and <kbd>delivery_times</kbd> are reflective of the creation of the message and delivery of a received message to the PST being examined. The <kbd>client_submit_time</kbd> value is the timestamp for when the message was sent. The last attribute shown here is the <kbd>number_of_attachments</kbd> attribute, which finds additional artifacts for extraction:</p>
<pre>118 def process_msg(message):<br/>119     """<br/>120     The process_msg function processes multi-field messages<br/>121     to simplify collection of information<br/>122     :param message: pypff.Message object<br/>123     :return: A dictionary with message fields (values) and<br/>124         their data (keys)<br/>125     """<br/>126     return {<br/>127         "subject": message.subject,<br/>128         "sender": message.sender_name,<br/>129         "header": message.transport_headers,<br/>130         "body": message.plain_text_body,<br/>131         "creation_time": message.creation_time,<br/>132         "submit_time": message.client_submit_time,<br/>133         "delivery_time": message.delivery_time,<br/>134         "attachment_count": message.number_of_attachments,<br/>135     }</pre>
<p>At this time, the <kbd>pypff</kbd> module doesn't support interaction with attachments, although the <kbd>libpff</kbd> library will extract artifacts using its <kbd>pffexport</kbd> and <kbd>pffinfo</kbd> tools. To build these tools, we must include the <kbd>--enable-static-executables</kbd> argument on the command line when running the <kbd>./configure</kbd> command while building.</p>
<p>Once built with these options, we can run the tools mentioned earlier to export the PST attachments in a structured directory. The developer has stated that he'll include <kbd>pypff</kbd> support for attachments in a future release. If made available, we'll be able to interface with message attachments and run additional processing on discovered files. If this functionality is needed for analysis, we could add support to call the <kbd>pffexport</kbd> tool via Python through the <kbd>os</kbd> or <kbd>subprocess</kbd> libraries.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summarizing data in the folder_report() function</h1>
                
            
            
                
<p>At this point, we've collected a fair amount of information about messages and folders. We use this code block to export that data into a simple report for review. To create this report, we require the <kbd>message_list</kbd> and <kbd>folder_name</kbd> variables. On line 146, we check whether there're any entries in the <kbd>message_list</kbd>; if not, we log a warning and return the function to prevent any of the remaining code from running.</p>
<p>If the <kbd>message_list</kbd> has content, we start to create a CSV report. We first generate the filename in the output directory by passing our desired filename into the <kbd>make_path()</kbd> function to get the absolute path of the file that we wish to write to. Using this file path, we open the file in <kbd>wb</kbd> mode to write our CSV file and to prevent a bug that would add an extra line between the rows of our reports on line 152. In the following line, we define the list of headers for the output document.</p>
<p class="mce-root"/>
<p>This list should reflect an ordered list of columns we wish to report. Feel free to modify lines 153 and 154 to reflect a preferred order or additional rows. All of the additional rows must be valid keys from all dictionaries within the <kbd>message_list</kbd> variable.</p>
<p>Following our headers, we initiate the <kbd>csv.DictWriter</kbd> class on line 155. If you recall from the start of our script, we imported the <kbd>unicodecsv</kbd> library to handle Unicode characters when writing to a CSV. During this import, we used the <kbd>as</kbd> keyword to rename the module from <kbd>unicodecsv</kbd> to <kbd>csv</kbd> within our script. This module provides the same methods as the standard library, so we can continue using the familiar function calls we have seen with the <kbd>csv</kbd> library. In this initialization of <kbd>DictWriter()</kbd>, we pass along the open file object, the field names, and an argument to tell the class what to do with unused information within the <kbd>message_list</kbd> dictionaries. Since we're not using all of the keys within the dictionaries in the <kbd>message_list</kbd> list, we need to tell the <kbd>DictWriter()</kbd> class that we would like to ignore these values, as follows:</p>
<pre>138 def folder_report(message_list, folder_name):<br/>139     """<br/>140     The folder_report function generates a report per PST folder<br/>141     :param message_list: A list of messages discovered<br/>142         during scans<br/>143     :folder_name: The name of an Outlook folder within a PST<br/>144     :return: None<br/>145     """<br/>146     if not len(message_list):<br/>147         logger.warning("Empty message not processed")<br/>148         return<br/>149 <br/>150     # CSV Report<br/>151     fout_path = make_path("folder_report_" + folder_name + ".csv")<br/>152     fout = open(fout_path, 'wb')<br/>153     header = ['creation_time', 'submit_time', 'delivery_time',<br/>154         'sender', 'subject', 'attachment_count']<br/>155     csv_fout = csv.DictWriter(fout, fieldnames=header,<br/>156         extrasaction='ignore')<br/>157     csv_fout.writeheader()<br/>158     csv_fout.writerows(message_list)<br/>159     fout.close()</pre>
<p>With the <kbd>csv_fout</kbd> variable initialized and configured, we can begin writing our header data using the <kbd>writeheaders()</kbd> method call on line 157. Next, we write the dictionary fields of interest to the file using the <kbd>writerows()</kbd> method. Upon writing all the rows, we close the <kbd>fout</kbd> file to write it to disk and release the handle on the object as seen on line 159.</p>
<p class="mce-root"/>
<p>On lines 119 through 141, we prepare the dictionaries from the <kbd>message_list</kbd> for use in generating HTML report statistics. We need to invoke the <kbd>global</kbd> statement as seen on line 162 to allow us to edit the <kbd>date_list</kbd> global variable. We then open two text files to record a raw list of all of the body content and sender names. These files will be used in a later section to generate our statistics and allow the collection of this data in a manner that doesn't consume large amounts of memory. These two text files, seen on lines 163 and 164, are opened in the <kbd>a</kbd> mode, which will create the file if it doesn't exist or append the data to the end of the file if it exists.</p>
<p>On line 165, we start a <kbd>for</kbd> loop to iterate through each message, <kbd>m</kbd>, in <kbd>message_list</kbd>. If the message body key has a value, then we write the value to the output file with two line breaks to separate this content. Following this, on lines 168 and 169, we perform a similar process on the sender key and its value. In this instance, we'll only use one line break so that we can iterate through it easier in a later function:</p>
<pre>162     global date_list # Allow access to edit global variable<br/>163     body_out = open(make_path("message_body.txt"), 'a')<br/>164     senders_out = open(make_path("senders_names.txt"), 'a')<br/>165     for m in message_list:<br/>166         if m['body']:<br/>167             body_out.write(m['body'] + "\n\n")<br/>168         if m['sender']:<br/>169             senders_out.write(m['sender'] + '\n')</pre>
<p>After collecting the message content and senders, we accumulate the date information. To generate our heat map, we'll combine all three dates of activity into a single count to form a single chart. After checking that a valid date value is available, we gather the day of the week to determine which of the dictionaries within the <kbd>date_list</kbd> list we wish to update.</p>
<p>The Python <kbd>datetime.datetime</kbd> library has a <kbd>weekday()</kbd> method and an <kbd>.hour</kbd> attribute, which allows us to access the values as integers and handles the messy conversions for us. The <kbd>weekday()</kbd> method returns an integer from 0 to 6, where 0 represents Monday and 6 represents Sunday. The <kbd>.hour</kbd> attribute returns an integer between 0 and 23, representing time in a 24-hour fashion, though the JavaScript we're using for the heat map requires an integer between 1 and 24 to process correctly. Because of this, we add 1 to each of the hour values as seen on lines 175, 181, and 187.</p>
<p>We now have the correct weekday and time of day keys we need to update the value in the <kbd>date_list</kbd>. Upon completing the loop, we can close the two file objects on lines 189 and 190:</p>
<pre>171         # Creation Time<br/>172         c_time = m['creation_time']<br/>173         if c_time isn't None:<br/>174             day_of_week = c_time.weekday()<br/>175             hour_of_day = c_time.hour + 1<br/>176             date_list[day_of_week][hour_of_day] += 1<br/>177         # Submit Time<br/>178         s_time = m['submit_time']<br/>179         if s_time isn't None:<br/>180             day_of_week = s_time.weekday()<br/>181             hour_of_day = s_time.hour + 1<br/>182             date_list[day_of_week][hour_of_day] += 1<br/>183         # Delivery Time<br/>184         d_time = m['delivery_time']<br/>185         if d_time isn't None:<br/>186             day_of_week = d_time.weekday()<br/>187             hour_of_day = d_time.hour + 1<br/>188             date_list[day_of_week][hour_of_day] += 1<br/>189     body_out.close()<br/>190     senders_out.close()</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Understanding the word_stats() function</h1>
                
            
            
                
<p>With the message content written to a file, we can now use it to calculate a frequency of word usage. We use the <kbd>Counter</kbd> module we imported from the collections library to generate a word count in an efficient manner.</p>
<p>We initialize the <kbd>word_list</kbd> as a <kbd>Counter()</kbd> object, which allows us to call it and assign new words while keeping track of the overall count per word. After initialization, we start a <kbd>for</kbd> loop on line 200, open the file, and iterate through each line with the <kbd>readlines()</kbd> method:</p>
<pre>193 def word_stats(raw_file="message_body.txt"):<br/>194     """<br/>195     The word_stats function reads and counts words from a file<br/>196     :param raw_file: The path to a file to read<br/>197     :return: A list of word frequency counts<br/>198     """<br/>199     word_list = Counter()<br/>200     for line in open(make_path(raw_file), 'r').readlines():</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>At this point, we need to <kbd>split()</kbd> the line into a list of individual words in order to generate a proper count. By not passing an argument to <kbd>split()</kbd>, we'll split on all whitespace characters, which, in this case, works to our advantage. Following the split on line 201, we use a conditional statement to ensure only a single word greater than four characters is included in our list, to eliminate common filler words or symbols. This logic may be tailored based on your environment, as you may, for example, wish to include words shorter than four letters or some other filtering criteria.</p>
<p>If the conditional evaluates to true, we add the word to our counter. On line 204, we increment the value of the word in the list by one. After iterating through every line and word of the <kbd>message_body.txt</kbd> file, we pass this word list to the <kbd>word_report()</kbd> function:</p>
<pre>201         for word in line.split():<br/>202             # Prevent too many false positives/common words<br/>203             if word.isalnum() and len(word) &gt; 4:<br/>204                 word_list[word] += 1<br/>205     return word_report(word_list)</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating the word_report() function</h1>
                
            
            
                
<p>Once <kbd>word_list</kbd> is passed from the <kbd>word_stats()</kbd> function, we can generate our reports using the supplied data. In order to have more control over how our data is presented, we're going to write a CSV report without the help of the <kbd>csv</kbd> module. First, on line 216, we need to ensure that <kbd>word_list</kbd> contains values. If it doesn't, the function logs a warning and returns. On line 220, we open a new file object in <kbd>wb</kbd> mode to create our CSV report. On line 221, we write our <kbd>Count</kbd> and <kbd>Word</kbd> headers onto the first row with a newline character to ensure all other data is written in the rows below:</p>
<pre>208 def word_report(word_list):<br/>209     """<br/>210     The word_report function counts a list of words and returns<br/>211     results in a CSV format<br/>212     :param word_list: A list of words to iterate through<br/>213     :return: None or html_report_list, a list of word<br/>214         frequency counts<br/>215     """<br/>216     if not word_list:<br/>217         logger.debug('Message body statistics not available')<br/>218         return []<br/>219 <br/>220     fout = open(make_path("frequent_words.csv"), 'wb')<br/>221     fout.write("Count,Word\n")</pre>
<p>We then use a <kbd>for</kbd> loop and the <kbd>most_common()</kbd> method to call out a tuple containing each word and the assigned count value. If the length of the tuple is greater than 1, we write the values into the CSV document in reverse order to properly align the columns with the values, followed by a newline character. After this loop completes, we close the file and flush the results to the disk as seen on line 225:</p>
<pre>222     for e in word_list.most_common():<br/>223         if len(e) &gt; 1:<br/>224             fout.write(str(e[1]) + "," + str(e[0]) + "\n")<br/>225     fout.close()</pre>
<p>Following this loop, we then generate a list of the top 10 words. By passing the integer 10 into the <kbd>most_common()</kbd> method, we select only the top 10 most common entries in <kbd>Counter</kbd>. We append a dictionary of the results to a temporary list, which is returned to the <kbd>word_stats()</kbd> function and later used in our HTML report:</p>
<pre>227     html_report_list = []<br/>228     for e in word_list.most_common(10):<br/>229         html_report_list.append(<br/>230             {"word": str(e[0]), "count": str(e[1])})<br/>231 <br/>232     return html_report_list</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Building the sender_report() function</h1>
                
            
            
                
<p>The <kbd>sender_report()</kbd> functions similarly to <kbd>word_report()</kbd> and generates a CSV and HTML report for individuals who sent emails. This function showcases another method for reading values into the <kbd>Counter()</kbd> method. On line 242, we open and read the lines of a file into the <kbd>Counter()</kbd> method.</p>
<p>We can implement it this way because each line of the input file represents a single sender. Counting the data in this manner simplifies the code and, by extension, saves us a few lines of writing.</p>
<p>This wasn't a feasible option for the <kbd>word_stats()</kbd> function because we had to break each line into a separate word and then perform additional logic operations prior to counting the words. If we wanted to apply logic to the sender statistics, we would need to create a similar loop to that in <kbd>word_stats()</kbd>. For example, we might want to exclude all items from Gmail or that contain the word <kbd>noreply</kbd> in the sender's name or address:</p>
<pre>235 def sender_report(raw_file="senders_names.txt"):<br/>236     """<br/>237     The sender_report function reports the most frequent_senders<br/>238     :param raw_file: The file to read raw information<br/>239     :return: html_report_list, a list of the most<br/>240         frequent senders<br/>241     """<br/>242     sender_list = Counter(<br/>243         open(make_path(raw_file), 'r').readlines())</pre>
<p>After generating the sender count, we can open the CSV report and write our headers to it. At this point, we'll iterate through each of the most common in a <kbd>for</kbd> loop as seen on line 247, and if the tuple contains more than one element, we'll write it to the file.</p>
<p>This is another location where we could filter the values based on the sender's name. After writing, the file is closed and flushed to the disk. On line 252, we generate statistics for the top five senders for the final report by generating a list of dictionaries containing the tuple values. To access it in our HTML report function, we return this list. See the following code:</p>
<pre>245     fout = open(make_path("frequent_senders.csv"), 'wb')<br/>246     fout.write("Count,Sender\n")<br/>247     for e in sender_list.most_common():<br/>248         if len(e) &gt; 1:<br/>249             fout.write(str(e[1]) + "," + str(e[0]))<br/>250     fout.close()<br/>251 <br/>252     html_report_list = []<br/>253     for e in sender_list.most_common(5):<br/>254         html_report_list.append(<br/>255             {"label": str(e[0]), "count": str(e[1])})<br/>256 <br/>257     return html_report_list</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Refining the heat map with the date_report() function</h1>
                
            
            
                
<p>This report provides data to generate the activity heat map. For it to operate properly, it must have the same filename and path specified in the HTML template. The default template for the file is named <kbd>heatmap.tsv</kbd> and is located in the same directory as the output HTML report.</p>
<p>After opening this file with those defaults on line 267, we write the headers with a tab character delimiting the day, hour, and value columns and ending with a newline character. At this point, we can begin iterating through our list of dictionaries by using two <kbd>for</kbd> loops to access each list containing dictionaries.</p>
<p class="mce-root"/>
<p>In the first <kbd>for</kbd> loop, we use the <kbd>enumerate()</kbd> method to capture the loop iteration number. This number conveniently corresponds to the date we're processing, allowing us to use this value to write the day value:</p>
<pre>260 def date_report():<br/>261     """<br/>262     The date_report function writes date information in a<br/>263     TSV report. No input args as the filename<br/>264     is static within the HTML dashboard<br/>265     :return: None<br/>266     """<br/>267     csv_out = open(make_path("heatmap.tsv"), 'w')<br/>268     csv_out.write("day\thour\tvalue\n")<br/>269     for date, hours_list in enumerate(date_list):</pre>
<p>In the second <kbd>for</kbd> loop, we iterate through each dictionary, gathering both the hour and count values separately by using the <kbd>items()</kbd> method to extract the key and value as a tuple. With these values, we can now assign the date, hour, and count to a tab-separated string and write it to the file.</p>
<p>On line 271, we add 1 to the date value as the heat map chart uses a 1 through 7 range, whereas our list uses an index of 0 through 6 to count days of the week.</p>
<p>After iterating through the hours, we flush the data to the disk before moving forward to the next dictionary of hours. Once we've iterated through all of the seven days, we can close this document as it's ready to be used with our heat map chart in the <kbd>html_report()</kbd> function:</p>
<pre>270         for hour, count in hours_list.items():<br/>271             to_write = "{}\t{}\t{}\n".format(date+1, hour, count)<br/>272             csv_out.write(to_write)<br/>273         csv_out.flush()<br/>274     csv_out.close()</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Writing the html_report() function</h1>
                
            
            
                
<p>The <kbd>html_report()</kbd> function is where we tie together all of the pieces of information gathered from the PST into a final report, with much anticipation. To generate this report, we require arguments specifying the report title, PST name, and counts of the top words and senders:</p>
<pre>277 def html_report(report_title, pst_name, top_words, top_senders):<br/>278     """<br/>279     The html_report function generates the HTML report from a<br/>280         Jinja2 Template<br/>281     :param report_title: A string representing the title of<br/>282         the report<br/>283     :param pst_name: A string representing the file name of<br/>284         the PST<br/>285     :param top_words: A list of the top 10 words<br/>286     :param top_senders: A list of the top 10 senders<br/>287     :return: None<br/>288     """</pre>
<p>To begin with, we open the template file and read in the contents into a single variable as a string. This value is then passed into our <kbd>jinja2.Template</kbd> engine to be processed into a template object called <kbd>html_template</kbd> on line 290.</p>
<p>Next, we create a dictionary of values to pass into the template's placeholders and use the <kbd>context</kbd> dictionary on line 292 to hold these values. With the dictionary in place, we then render the template on line 295 and provide the <kbd>context</kbd> dictionary. This rendered data is a string of HTML data, as you expect to see on a web page, with all of our placeholder logic evaluated and turned into a static HTML page.</p>
<p>We write the rendered HTML data to an output file in the user-specified directory as seen on lines 297 through 299. With the HTML report written to the output directory, the report is complete and ready to view in the output folder:</p>
<pre>289     open_template = open("stats_template.html", 'r').read()<br/>290     html_template = jinja2.Template(open_template)<br/>291 <br/>292     context = {"report_title": report_title, "pst_name": pst_name,<br/>293         "word_frequency": top_words,<br/>294         "percentage_by_sender": top_senders}<br/>295     new_html = html_template.render(context)<br/>296 <br/>297     html_report_file = open(make_path("pst_report.html"), 'w')<br/>298     html_report_file.write(new_html)<br/>299     html_report_file.close()</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">The HTML template</h1>
                
            
            
                
<p>This book focuses on the use of Python in forensics. Though Python provides many great methods for manipulating and applying logic to data, we still need to lean on other resources to support our scripts. In this chapter, we've built an HTML dashboard to present statistical information about these PST files.</p>
<p>In this section, we'll review sections of HTML, focusing on where our data is inserted into the template versus the intricacies of HTML, JavaScript, and other web languages. For more information in the use and implementation of HTML, JavaScript, D3.js, and other web resources, visit <a href="http://packtpub.com">http://packtpub.com</a> for pertinent titles or <a href="http://w3schools.com">http://w3schools.com</a> for introductory tutorials. Since we'll not be delving deeply into HTML, CSS, or other web design aspects, our focus will be primarily on the spaces where our Python script will interact.</p>
<p>This template leverages a couple of common frameworks that allow the rapid design of professional-looking web pages. The first is Bootstrap 3, a CSS styling framework that organizes and styles HTML to look uniform and clean no matter the device used to view the page. The second is the D3.js framework, which is a JavaScript framework for graphic visualizations.</p>
<p>As we've seen before, the template items into which we'll insert our data are contained within double braces, <kbd>{{ }}</kbd>. We'll insert the report title for our HTML dashboard on line 39 and 44. Additionally, we'll insert the name of the PST file on lines 48, 55, and 62. The <kbd>div id</kbd> tags on lines 51, 58, and 65 acts as a variable name for the charts that can be inserted by JavaScript in the later section of the template once the code processes the input:</p>
<pre>...<br/>038   &lt;/style&gt;<br/>039   &lt;title&gt;{{ report_title }}&lt;/title&gt;<br/>040 &lt;/head&gt;<br/>041 &lt;body&gt;<br/>042   &lt;div class="container"&gt;<br/>043     &lt;div class="row"&gt;<br/>044       &lt;h1&gt;{{ report_title }}&lt;/h1&gt;<br/>045     &lt;/div&gt;<br/>046     &lt;div class="row"&gt;<br/>047         &lt;div class="row"&gt;<br/>048           &lt;h3&gt;Top 10 words in {{ pst_name }}&lt;/h3&gt;<br/>049         &lt;/div&gt;<br/>050         &lt;div class="row"&gt;<br/>051           &lt;div id="wordchart"&gt;<br/>052           &lt;/div&gt;<br/>053         &lt;/div&gt;<br/>054         &lt;div class="row"&gt;<br/>055           &lt;h3&gt;Top 5 Senders in {{ pst_name }}&lt;/h3&gt;<br/>056         &lt;/div&gt;<br/>057         &lt;div class="row"&gt;<br/>058           &lt;div id="piechart"&gt;<br/>059           &lt;/div&gt;<br/>060         &lt;/div&gt;<br/>061         &lt;div class="row"&gt;<br/>062           &lt;h3&gt;Heatmap of all date activity in {{ pst_name }}&lt;/h3&gt;<br/>063         &lt;/div&gt;<br/>064         &lt;div class="row"&gt;<br/>065           &lt;div id="heatmap"&gt;&lt;/div&gt;<br/>066         &lt;/div&gt;<br/>067       &lt;/div&gt;<br/>068     &lt;/div&gt;<br/>... </pre>
<p>After the <kbd>div</kbd> placeholder elements are in place, the JavaScript on lines 69 through 305 processes the provided data into charts. The first location data is placed on line 92, where the <kbd>{{ word_frequency }}</kbd> phrase is replaced with the list of dictionaries. For example, this could be replaced with <kbd>[{'count': '175', 'word': 'message'}, {'count': '17', 'word': 'iPhone'}]</kbd>. This list of dictionaries is translated into chart values to form the vertical bar chart of the HTML report:</p>
<pre>...<br/>088         .attr("transform", "translate(" + margin.left + "," + margin.top + ")");<br/>089<br/>090         data = {{ word_frequency }}<br/>091<br/>092       function processData(data) {x.domain(data.map(function(d) {<br/>093         return d;<br/>094       }<br/>...</pre>
<p>On line 132, we insert the <kbd>percentage_by_sender</kbd> value from the context dictionary into the JavaScript. This replacement will occur in a similar example to the <kbd>word_frequency</kbd> insert. With this information, the donut chart generates on the HTML report:</p>
<pre>...  
129     (function(d3) { 
130       'use strict'; 
131  
132       var dataset = {{ percentage_by_sender }}; 
133  
134       var width = 960; 
...</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>We'll use a new way to insert data for the heat map. By providing the filename discussed in the previous section, we can prompt the code to look for a <kbd>heatmap.tsv</kbd> file in the same directory as this HTML report. The upside to this is how we're able to generate a report once and use the TSV in a program such as Excel and within our dashboard, though the downside is that this file must travel with the HTML report for it to display properly, as the chart will regenerate on reload.</p>
<p>This chart also has difficulty rendering on some browsers as JavaScript is interpreted differently by each browser. Testing found that Chrome, Firefox, and Safari were OK at viewing the graphic. Ensure that browser add-ons are not interfering with the JavaScript and that your browser doesn't block JavaScript from interacting with local files. If your browser disallows this, consider running the script in the Docker instance, starting the <kbd>lighttpd</kbd> service, and placing your output in <kbd>/var/www/html</kbd>. When you visit the IP address of your Docker instance, you'll be able to navigate to the report as the server will provide access to the resources for you:</p>
<pre>174         times = ["1a", "2a", "3a", "4a", "5a", "6a", "7a", "8a", "9a", "10a", "11a", "12a", "1p", "2p", "3p", "4p", "5p", "6p", "7p", "8p", "9p", "10p", "11p", "12p"];<br/>175<br/>176       datasets = ["heatmap.tsv"];<br/>177<br/>178       var svg = d3.select("#heatmap").append("svg") </pre>
<p>The remainder of the template is available in the code repository and can easily be referenced and manipulated if web languages are your strong suit or worth further exploration. The D3.js library allows us to create additional informative graphics and adds another tool to our reporting toolbox that's relatively simple and portable. The following graphics represent examples of data for each of the three charts we've created.</p>
<p class="mce-root"/>
<p>The first chart represents the most used words in the PST file. The frequency is plotted on the <em>y</em> axis and the word on the <em>x</em> axis:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-448 image-border" src="img/ea070c05-142b-467e-bee8-10ebe5b799bd.png" style="width:79.92em;height:51.00em;"/></p>
<p>The following chart identifies the top five accounts that have sent an email to the user. Notice how the circle graph helps to identify which participants are most frequent in the dataset. In addition, the text labels provide the name of the address and the number of emails received by that address:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-449 image-border" src="img/84b19b6e-c27f-47f5-a634-d963ffb450d0.png" style="width:63.08em;height:46.50em;"/></p>
<p>Lastly, the following heat map aggregates all emails into hour-long cells for each day. This is very useful in identifying trends in the dataset.</p>
<p class="mce-root"/>
<p>For example, in this case, we can quickly identify that most emails are sent or received early in the morning and particularly at 6 AM on Tuesdays. The bar at the bottom of the graphic indicates the number of emails. For example, the color of the cell for 6 AM Tuesdays indicates that more than 1,896 emails were sent or received during that time:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-450 image-border" src="img/17140a11-ba74-4359-8322-064e7b07c3f4.png" style="width:80.75em;height:35.17em;"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Running the script</h1>
                
            
            
                
<p>With our code complete, both the script and the HTML template, we're ready to execute the code! In our Ubuntu environment, we'll need to run the following command and provide our PST for analysis. If your Ubuntu machine has a configured web server, then the output could be placed in the web directory and served as a website for other users to view when visiting the server.</p>
<p class="mce-root">If you plan on using the Docker container method to run this code, you'll need to copy the PST file into your container using a command such as the one shown in the following. Please note that the following syntax  is <kbd>docker cp src_file container_name:/path/on/container</kbd> and additional functionality is described with <kbd>docker cp --help</kbd>:</p>
<pre><strong>$ docker cp sample.pst pst_parser:/opt/book</strong></pre>
<p class="mce-root"/>
<p class="packt_figure CDPAlignLeft CDPAlign">Now that our PST is located within our container; we can run our script as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-451 image-border" src="img/24182530-5859-41b7-a0f5-4ecf4ea41e9b.png" style="width:50.00em;height:41.75em;"/></p>
<p>The preceding screenshot shows us using <kbd>/var/www/html</kbd> as our output directory. This means that if we're running the <kbd>lighttpd</kbd> service on our Docker container, we'll be able to browse to the container's IP address and view the content in a browser on our system. You'll need to run <kbd>docker container ls pst_parser</kbd> to get the correct port that the web server can be found at. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Additional challenges</h1>
                
            
            
                
<p>For this project, we invite you to implement some improvements that will make our script more versatile. As mentioned earlier in the chapter, <kbd>pypff</kbd> currently doesn't natively support the extraction or direct interaction with attachments. We can, however, call the <kbd>pffexport</kbd> and <kbd>pffinfo</kbd> tools within our Python script to do so. We recommend looking at the subprocess module to accomplish this. To extend this further, how can we connect this with the code covered in previous chapter ? What type of data might become available once we have access to attachments?</p>
<p>Consider methods that would allow a user to provide filtering options to collect specific messages of interest rather than the entire PST. A library that may assist in providing additional configuration options to the user is <kbd>ConfigParser</kbd> and can be installed with <kbd>pip</kbd>.</p>
<p>Finally, another challenge would be seeing improvements in the HTML report by adding additional charts and graphs. One example might be to parse <kbd>transit_headers</kbd> and extract the IP addresses. Using these IP addresses, you could geolocate them and plot them on a map with the D3.js library. This kind of information can increase the usefulness of our reports by squeezing out as much information as possible from all potential data points.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>Email files contain a large amount of valuable information, allowing forensic examiners to gain greater insight into communications and the activity of users over time. Using open source libraries, we're able to explore PST files and extract information about the messages and folders within. We also examined the content and metadata of messages to gather additional information about frequent contacts, common words, and abnormal hot spots of activity. Through this automated process, we can gather a better understanding of the data we review and begin to identify hidden trends. The code for this project can be downloaded from GitHub or Packt, as described in the <em>Preface</em>.</p>
<p>Identifying hidden information is very important in all investigations and is one of the many reasons that data recovery is an important cornerstone in the forensic investigation process.</p>
<p>In the next chapter, we'll cover how to recover data from a difficult source, databases. Using several Python libraries, we'll be able to recover data that might otherwise be lost and gain valuable insights into records that're no longer tracked by the database.</p>


            

            
        
    </body></html>