["```\n*; First of all we tell the assembler*\n*; that this is a 32-bit code*\nuse32\n\n*; Tell the assembler that we are expecting*\n*; this code to appear at 0x41e000*\norg 0x41e000\n\n*; Define labels for \"external\" procedures*\n*; we are about to use*\nlabel fgets at 0x414bd8\nlabel __acrt_iob_func at 0x41b180\n\n*; Implement the procedure*\nfgets_patch:\n\n *; We begin the procedure with the standard*\n *; prolog for cdecl calling convention*\n   push  ebp\n   mov   ebp, esp\n\n *; As we need the pointer to the stdin stream*\n *; we call the __acrt_iob_func procedure*\n   push  0                      *; This is the number of the stream*\n   call  dword[__acrt_iob_func]\n   add   esp, 4                 *; Restore the stack pointer\n\n   ; Forward the parameter (char*) and \n   ; invoke fgets()* push  eax                    *; Contains pointer to the stdin stream*\n   push  128                    *; Maximum input length*\n   push  dword[ebp + 8]         *; Pointer to the receiving buffer*\n   call  fgets\n   add   esp, 4 * 3             *; Restore the stack pointer\n\n   ; Standard epilog for procedures using cdecl \n   ; calling convention* mov   esp, ebp\n   pop   ebp\n   ret\n```", "```\n *; Preceding code*\n   push  .return_address   *; Push the return address on stack*\n   push  .callee           *; Redirect the execution flow to*\n   ret                     *; callee*\n.return_address:\n *; the rest of the code*\n```", "```\npush  callee\nret\n```", "```\nlea  eax, [callee]\njmp eax\n```", "```\n*; The %t below stands for the current*\n*; timestamp (at the compile time)*\nrandom_seed = %t\n\n*; This macro sets 'r' to current random_seed*\nmacro random r\n{\n   random_seed = ((random_seed *\\\n                   214013 +\\\n                   2531011) shr 16) and 0xffffffff\n   r = random_seed \n}\n```", "```\n*; This macro has a parameter - the label (address)*\n*; of the procedure to call*\nmacro  f_call callee \n{\n *; First we declare a few local labels*\n *; We need them to be local as this macro may be*\n *; used more than once in a procedure*\n   local .reference_addr,\\\n         .out,\\\n         .ret_addr,\\\n         .z,\\\n         .call\n\n *; Now we need to calculate the reference address*\n *; for all further address calculations*\n   call  .call\n.call:\n   add   dword[esp], .reference_addr - .call\n *; Now the address or the .reference_addr label*\n *; is at [esp]*\n *; Jump to the .reference_addr*\n   ret\n\n *; Add some randomness*\n   random .z\n   dd     .z\n\n *; The ret instruction above returns to this address*\n.reference_addr:\n\n *; Calculate the address of the callee:*\n *; We load the previously generated random bytes into*\n *; the .z compile time variable*\n   load .z dword from .reference_addr - 4\n\n   mov  eax, [esp - 4]     *; EAX now contains the address*\n *; of the .reference_addr label*\n   mov  eax, [eax - 4]     *; And now it contains the four*\n *; random bytes*\n   xor  eax, callee xor .z *; EAX is set to the address of*\n *; the callee*\n\n   *; We need to set up return address for the callee* \n *; before we jump to it*\n   sub  esp, 4             *; This may be written as* \n *; 'add esp, -4' for a bit of* \n *; additional obfuscation*\n   add  dword[esp], .ret_addr - .reference_addr\n   *; Now the value stored on stack is the address of*\n *; the .ret_addr label*\n *; At last - jump to the callee*\n   jmp  eax\n\n   *; Add even more randomness*\n   random .z\n   dd     .z\n   random .z\n   dd     .z\n\n   *; When the callee returns, it falls to this address*\n.ret_addr:\n   *; However, we want to obfuscate further execution*\n *; flow, so we add the following code, which sets* \n *; the value still present on stack (address of the*\n *; .ret_addr) to the address of the .out label*\n   sub  dword[esp - 4], -(.out - .ret_addr)\n   sub  esp, 4\n   ret\n   *; The above two lines are, in fact, an equivalent* \n *; of 'jmp dword[esp - 4]'*\n\n *; Some more randomness*\n   random .z\n   dd     .z\n\n.out:\n}\n```", "```\n    readelf- sr name_of_the_mofule.ko\n    ```", "```\nformat ELF64       *; 64-bit ELF object file*\nextrn printk       *; We are going to use this symbol,*\n *; exported by the kernel, in order to*\n *; have an indication of the module being*\n *; loaded without problems*\n```", "```\nsection '.init.text' executable \n\nmodule_init:\n   push  rdi       *; We are going to use this register*\n\n   mov   rdi, str1 *; Load RDI with the address of the string*\n *; we want to print to system log (we will*\n *; add it to the data section in a few moments)*\n   xor   eax, eax\n   call  printk    *; Write the string to the system log*\n\n   xor   eax, eax  *; Prepare return value*\n   pop   rdi       *; Restore the RDI register*\n   ret\n```", "```\nsection '.exit.text' executable\nmodule_cleanup:\n   xor   eax, eax\n   ret\n```", "```\nsection '.rodata.str1.1'\n   str1  db  '<0> Here I am, gentlemen!', 0x0a, 0\n```", "```\nsection '.modinfo'\n *; It is possible to specify another license here,*\n *; however, some kernel symbols would not be* \n *; available for license other than GPL*\n   db  'license=GPL', 0\n\n   *; Our LKM has no dependencies, therefore, we leave*\n *; this blank*\n   db  'depends=', 0\n\n   *; Version of the kernel and supported options*\n   db  'vermagic=3.16.0-4-amd64 SMP mod_unload modversions ', 0\n```", "```\n/sbin/modinfo /lib/modules/`uname -r`/kernel/arch/x86/crypto/aesni-intel.ko\n```", "```\nsection '.gnu.linkonce.this_module' writeable\n\nthis_module:\n *; Reserve 0x18 bytes*\n   rb  0x18\n *; String representation of the name of the module*\n   db  'simple_module',0\n\n   *; Reserve bytes till the offset 0x150*\n   rb  0x150 - ($ - this_module)\n   *; The address of the module_init procedure*\n   dq  module_init\n\n   *; Reserve bytes till the offset 0x248*\n   rb  0x248 - ($ - this_module)\n   *; The address of the module_cleanup procedure*\n   dq  module_cleanup\n   dq  0\n```", "```\nmacro __version ver, name\n{\n   local .version, .name\n   .version  dq  ver\n   .name     db  name, 0\n   .name_len = $ - .name\n             rb  56 - .name_len\n}\n```", "```\nsection '__versions'\n   __version  0x2AB9DBA5, 'module_layout'\n   __version  0x27E1A049, 'printk'\n```", "```\n*# It is just the name of the output file that differs*\n*# The extension would be 'ko' - **k**ernel **o**bject, instead*\n*# of 'o' for regular **o**bject*\nfasm lkm.asm lkm.ko \n```", "```\nsudo /sbin/insmode ./lkm.ko\n```", "```\ndmesg | tail -n 10\n```", "```\nsudo /sbin/rmmod simple_module\n```"]