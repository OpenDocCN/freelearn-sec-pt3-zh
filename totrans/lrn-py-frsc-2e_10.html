<html><head></head><body>
        

                            
                    <h1 class="header-title">Rapidly Triaging Systems</h1>
                
            
            
                
<p class="mce-root">In today's brave new world, where incidents have a way of rapidly ballooning out of control without a rapid and effective response, it is integral that DFIR professionals are able to query hosts for relevant information, such as the processes and services running on the system, to make informed investigative decisions to quickly contain the incident. While we can often collect this information on a forensic image of a machine, some of this information is volatile or it may be necessary to collect quickly rather than waiting for a forensic image to be created.</p>
<p class="mce-root">In this chapter, we develop a single script that is compatible with modern operating systems and, using various first- and third-party libraries, extract useful information about the system that the script is running on. With some modification, this script could be leveraged in an environment by deploying it to many hosts and collecting basic system information that may be valuable for the investigation. For example, in the case of an incident involving malware, if that malware, as part of its successful infection of a host, creates a new process, one could use this information to quickly determine the universe of hosts infected and, upon further investigation, which machine was likely infected first.</p>
<p>To achieve a script that is compatible across different operating systems, we will rely on a third-party module called <kbd>psutil</kbd> to obtain information about running processes, while more OS-specific intel, in the case of the Windows operating systems, will be extracted using the <strong>Windows Management Interface</strong> (<strong>WMI</strong>). </p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Extracting OS-agnostic process information using <kbd>psutil</kbd></li>
<li>Interacting with Windows systems by querying the WMI with Python and the <kbd>wmi</kbd> and <kbd>pywin32</kbd> modules</li>
<li>Creating a multi-platform triage artifact collection script</li>
</ul>
<p>The code for this chapter was developed and tested using Python 2.7.15 and Python 3.7.1.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Understanding the value of system information</h1>
                
            
            
                
<p>Why bother with collecting system information, anyway? Not all investigations revolve around the user and what actions they took on the system, but, rather, what the system is like and how it is behaving. For example, in the previous section, we discussed how running processes and created services can be informative based on indicators of compromise for a given scenario. However, as DFIR professionals well know, sources for system information can also provide insight into user activity, such as what disks are currently attached to the machine or querying the event log for user logins.</p>
<p>In the first edition of this book, this chapter originally showcased a <kbd>keylogger</kbd> script that we developed, whose purpose was mainly to illustrate how to use operating system APIs. For the second edition, we elected to keep that focus intact, but apply it in a more forensically relevant way. Let's dive in and discuss the third-party libraries. We will need to develop this script starting with <kbd>psutil</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Querying OS-agnostic process information with psutil</h1>
                
            
            
                
<p>The <kbd>psutil</kbd> module (version 5.4.5) is a cross-platform library capable of gathering various system information from different operating systems, for both 32-bit and 64-bit architectures. While we use this library to extract process information from the host system running the script, be aware that this library is capable of extracting more system information than just running processes.</p>
<p>Let's walk through a few examples, some of which we will not leverage in the script; however, first install the library with <kbd>pip</kbd>:</p>
<pre><strong>pip install psutil==5.4.5</strong></pre>
<p>We can get a list of active process IDs using the <kbd>pids()</kbd> function and then use a PID to collect additional information about the process. For instance, in the following code block, we select the first PID in the list of PIDs, with PID 62, create a process object for PID 62, and use various functions to display its name, parent PID, and open files.</p>
<p>Note that, for some of these functions, such as the <kbd>open_files()</kbd> method, you need to run the commands in an elevated Command Prompt:</p>
<pre><strong>&gt;&gt;&gt; import psutil</strong><br/><strong>&gt;&gt;&gt; pids = psutil.pids()</strong><br/><strong>&gt;&gt;&gt; pids[0]</strong><br/><strong>62</strong><br/><strong>&gt;&gt;&gt; proc = psutil.Process(pids[0])</strong><br/><strong>&gt;&gt;&gt; proc.is_running()</strong><br/><strong>True</strong><br/><strong>&gt;&gt;&gt; proc.name()</strong><br/><strong>syslogd</strong><br/><strong>&gt;&gt;&gt; proc.ppid()</strong><br/><strong>1</strong><br/><strong>&gt;&gt;&gt; proc.parent().name()</strong><br/><strong>launchd</strong><br/><strong>&gt;&gt;&gt; proc.open_files()[0]</strong><br/><strong>popenfile(path='/private/var/run/utmpx', fd=3)</strong></pre>
<p>While we use this library to print details about processes, we can use it to perform other tasks as well.</p>
<p>For example, we can collect information about connected disks, using the <kbd>disk_partitions()</kbd> function:</p>
<pre class="mce-root"><strong>&gt;&gt;&gt; for part in psutil.disk_partitions():</strong><br/><strong>...     print("Device: {}, Filesystem: {}, Mount: {},"<br/>...           " Size: {}, Disk Used: {}%".format(<br/>...                 part[0], part[2], part[1], <br/>...                 psutil.disk_usage(part[1])[0], <br/>...                 psutil.disk_usage(part[1])[3]))<br/>...<br/>Device: /dev/disk1s1, Filesystem: apfs, Mount: /, Size: 500068036608, Disk Used: 82.9%</strong></pre>
<p>Additionally, we could use the <kbd>users()</kbd> function to identify user profiles on the system and when the user session started:</p>
<pre><strong>&gt;&gt;&gt; psutil.users()[0].name</strong><br/><strong>PyForensics</strong><br/><strong>&gt;&gt;&gt; psutil.users()[0].started</strong><br/><strong>1548086912.0<br/>&gt;&gt;&gt; from datetime import datetime<br/>&gt;&gt;&gt; print(datetime.utcfromtimestamp(psutil.users()[0].started))<br/>2019-01-21 16:08:32</strong></pre>
<p>You can learn more about this library by reading the documentation page at <a href="https://pypi.org/project/psutil/">https://pypi.org/project/psutil/</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Using WMI</h1>
                
            
            
                
<p>The <kbd>wmi</kbd> library, maintained by Tim Golden, is a wrapper for the <kbd>pywin32</kbd> module, covered in the next section, that allows programmers to interact with the WMI API and provides programmers with a great deal of relevant information about Windows systems. You can even use this library to query other Windows systems on your network.</p>
<p>First, install WMI using <kbd>pip</kbd> by executing the following at Command Prompt:</p>
<pre><strong>pip install WMI==1.4.9</strong></pre>
<p>It should go without saying that the examples that we will discuss here will only work on Windows systems and therefore should be executed on a Windows system. Let's first take a look at querying running services.</p>
<p>We will need to create a WMI object and then use the <kbd>query()</kbd> method to identify running services:</p>
<pre><strong>&gt;&gt;&gt; import wmi</strong><br/><strong>&gt;&gt;&gt; conn = wmi.WMI()</strong><br/><strong>&gt;&gt;&gt; for service in conn.query(<br/>...        "SELECT * FROM Win32_Service WHERE State='Running'"):</strong><br/><strong>...    print("Service: {}, Desc: {}, Mode: {}".format(<br/>...         service.Name, service.Description, service.StartMode))</strong><br/><strong>...</strong><br/><strong>Service: PlugPlay, Desc: Enables a computer to recognize and adapt to hardware changes with little or no user input. Stopping or disabling this service will result in system instability., Mode: Manual</strong></pre>
<p>We can, for example, use this module to identify installed printers associated with the system.</p>
<p>A portion of the output, denoted by the string <kbd>[...]</kbd>, has been sanitized in the following example:</p>
<pre><strong>&gt;&gt;&gt; for printer in conn.Win32_Printer():</strong><br/><strong>...    print(printer.Name)</strong><br/><strong>...</strong><br/><strong>Microsoft XPS Document Writer</strong><br/><strong>Microsoft Print to PDF</strong><br/><strong>HP[...] (HP ENVY Photo 6200 series)</strong><br/><strong>Fax</strong></pre>
<p>Lastly, a very useful feature of this library, which we use in this script, allows us to query Windows Event Logs.</p>
<p>In the following example, we query to the <kbd>OAlerts.evtx</kbd> file, an event log that stores Microsoft Office alerts, and print out each event's message and the time the event was generated. Only one such message is shown here, in order to be succinct:</p>
<pre><strong>&gt;&gt;&gt; for event in conn.query(<br/>            "SELECT * FROM Win32_NTLogEvent WHERE Logfile='OAlerts'"):</strong><br/><strong>...     print(event.Message, event.TimeGenerated)</strong><br/><strong>...</strong><br/><strong>Microsoft Excel</strong><br/><strong>Want to save your changes to 'logonevent.csv'?</strong><br/><strong>P1: 153042</strong><br/><strong>P2: 15.0.5101.1000</strong><br/><strong>P3:</strong><br/><strong>P4:</strong><br/><strong>20190121031627.589966-000</strong></pre>
<p>We could discuss many other features of this library; however, we invite you to explore and experiment with its capabilities. We will introduce a few more examples of this library in this chapter's script.</p>
<p>This module requires the <kbd>pywin32</kbd> library, which is an incredibly powerful library that gives developers access to a number of different Windows APIs and is covered briefly in the next section. Understand that we are only scratching the surface with these libraries and focus on the specific goals of our script. Spend some time reading the documentation for these libraries and experimenting with their capabilities, as you will likely find these libraries useful in any script that interacts with the Windows operating system.</p>
<p>Read more about the <kbd>wmi</kbd> library and its capabilities on the documentation page at <a href="https://pypi.org/project/WMI/">https://pypi.org/project/WMI/</a>. Sample cookbook recipes using the <kbd>wmi</kbd> library can be found here:<a href="http://timgolden.me.uk/python/wmi/cookbook.html"> http://timgolden.me.uk/python/wmi/cookbook.html</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">What does the pywin32 module do?</h1>
                
            
            
                
<p>One of the most versatile Windows API libraries for Python is <kbd>pywin32</kbd> (version 224). This project is hosted on GitHub (historically on SourceForge) by Mark Hammond and is an open source project that the community contributes to. There are many different APIs available for Windows through this library. These features allow developers to build GUIs for their applications, leverage built-in authentication methods, and interact with hard drives and other external devices.</p>
<p>The <kbd>pywin32</kbd> module can be installed with <kbd>pip</kbd> by executing the following at Command Prompt:</p>
<pre><strong>pip install pywin32==224</strong></pre>
<p>Windows defines a <strong>Component Object Model</strong> (<strong>COM</strong>) that allows information to be shared between applications. A COM can be in the form of a <strong>Dynamic Link Library</strong> (<strong>DLL</strong>) or other binary file formats. These modules are designed in such a manner that any programming language can interpret the information. This single set of instructions, for example, allows a C++-based and Java-based program to share a single resource, rather than requiring a separate version for each language. COMs are generally only found on Windows, although they could be ported to a UNIX platform if desired. The <kbd>win32com</kbd> library, a part of the <kbd>pywin32</kbd> library, allows us to interact with COMs in Windows and is used by the <kbd>wmi</kbd> library to obtain the information we request from it.</p>
<p>The <kbd>pywin32</kbd> library can be found on GitHub at <a href="https://github.com/mhammond/pywin32">https://github.com/mhammond/pywin32</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Rapidly triaging systems – pysysinfo.py</h1>
                
            
            
                
<p>We are now ready to dive into the focus of this chapter, the <kbd>pysysinfo.py</kbd> script after having already covered the importance of collecting volatile information and the libraries we will use. This script is composed of a number of functions, most of which have to do with the <kbd>psutil</kbd> library, but at its heart identifies early on what type of system it is running on and, if that system is using the Windows operating system, runs an additional function using the WMI API, discussed previously. You can see in the following diagram how the various functions interact with each other and make up the code discussed throughout the remainder of this chapter:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/4e8d31ee-900c-4a28-a337-089734af5dfc.png"/></p>
<p>This script was developed and tested on Python 2.7.15 and 3.7.1. As with any script we develop, we must start with the imports necessary to successfully execute the code we've developed. You'll notice a number of the usual imports; however, a few stand out—notably the <kbd>platform</kbd> module and <kbd>psutil</kbd> on lines 5 and 8. You may also notice that <kbd>wmi</kbd> is missing from this set of imports. You will understand why this is imported later in the script in a few paragraphs. This script contains seven different functions, most of which are used to process the data from the <kbd>psutil</kbd> library.</p>
<p>Note that the <kbd>return_none()</kbd> function is covered in the following code block instead of in a new section, as it is a one-line function that simply returns <kbd>None</kbd> to the calling code:</p>
<pre>002 from __future__ import print_function<br/>003 import argparse<br/>004 import os<br/>005 import platform<br/>006 import sys<br/>007 <br/>008 import psutil<br/>009     if sys.version_info[0] == 2:<br/>010 import unicodecsv as csv<br/>011     elif sys.version_info[0] == 3:<br/>012 import csv<br/>...<br/>050 def return_none():<br/>051    """<br/>052    Returns a None value, but is callable.<br/>053    :return: None.<br/>054    """<br/>055    return None<br/>...<br/>058 def read_proc_connections(proc):<br/>...<br/>081 def read_proc_files(proc):<br/>...<br/>101 def get_pid_details(pid):<br/>...<br/>158 def get_process_info():<br/>...<br/>172 def wmi_info(outdir):<br/>...<br/>279 def csv_writer(data, outdir, name, headers, **kwargs):</pre>
<p>The <kbd>platform</kbd> module, which we have not touched on previously, is part of the standard library and also provides some information about the system it is running on. In this case, we only use this library to determine the operating system of the host system executing the script.</p>
<p>Learn more about the platform module by reading the documentation page at <a href="https://docs.python.org/3/library/platform.html">https://docs.python.org/3/library/platform.html</a>.</p>
<p>Moving on to the script setup, we have the argument parser, which is decidedly bland compared to some other chapters, featuring only one positional argument, <kbd>OUTPUT_DIR</kbd>, the output directory to write the processed data to.</p>
<p>If the desired output directory does not exist, we create it using the <kbd>os.makedirs()</kbd> function on line 323:</p>
<pre>313 if __name__ == '__main__':<br/>314     parser = argparse.ArgumentParser(description=__description__,<br/>315                     epilog='Developed by ' +<br/>316                     __author__ + ' on ' +<br/>317                     __date__)<br/>318     parser.add_argument('OUTPUT_DIR',<br/>319     help="Path to output directory. Will create if not found.")<br/>320     args = parser.parse_args()<br/>321<br/>322     if not os.path.exists(args.OUTPUT_DIR):<br/>323         os.makedirs(args.OUTPUT_DIR)</pre>
<p>Here's where things differ a little from normal. On line 325, using the <kbd>platform.system()</kbd> function, we check to see if the script is being executed on a Windows system. If so, we try to import the <kbd>wmi</kbd> module and, if successful, call the <kbd>wmi_info()</kbd> method. As alluded to earlier, we import the <kbd>wmi</kbd> library here for a reason. When the <kbd>wmi</kbd> library is imported, it also loads the <kbd>pywin32</kbd> module, specifically the <kbd>win32com.client</kbd> module. On a non-Windows system, where the <kbd>pywin32</kbd> library won't be installed, this can then cause an <kbd>ImportError</kbd> exception. For that reason, we do not try importing <kbd>wmi</kbd> until we know the script is executing on a Windows machine. It's also not a bad idea to only import libraries once they are needed:</p>
<pre>325     if 'windows' in platform.system().lower():<br/>326         try:<br/>327             import wmi<br/>328         except ImportError:<br/>329             print("Install the wmi and pywin32 modules. "<br/>330             "Exiting...")<br/>331             sys.exit(1)<br/>332         wmi_info(args.OUTPUT_DIR)</pre>
<p>Regardless of whether the system is Windows or not, we run the code captured in the next code block. On line 336, we call the <kbd>get_process_info()</kbd> method, which ultimately returns process data in the form of a dictionary. On line 337, we create a list containing the desired column names and keys of our <kbd>pid_data</kbd> dictionary. Lastly, on line 341, we call the <kbd>csv_writer()</kbd> method and pass in the data, desired output directory, output name, the <kbd>fields</kbd> list, and a keyword argument.</p>
<p>We will see what that keyword-argument does in a little bit:</p>
<pre>334     # Run data gathering function<br/>335     print("[+] Gathering current active processes information")<br/>336     pid_data = get_process_info()<br/>337     fields = ['pid', 'name', 'exe', 'ppid', 'cmdline',<br/>338         'username', 'cwd', 'create_time', '_errors']<br/>339 <br/>340     # Generate reports from gathered details<br/>341     csv_writer(pid_data, args.OUTPUT_DIR, 'pid_summary.csv',<br/>342         fields, type='DictWriter')</pre>
<p>As you may have noticed, we do not have a <kbd>main()</kbd> function for this script and will, instead, jump right into a review of the <kbd>get_process_info()</kbd> method. We will cover the Windows-specific function, <kbd>wmi_info()</kbd>, toward the end of this chapter.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Understanding the get_process_info() function</h1>
                
            
            
                
<p>As far as functions go, the <kbd>get_process_info()</kbd> function, is relatively straightforward and mainly serves to set up the rest of the code execution. On line 166, we create the <kbd>pid_info</kbd> dictionary, which is ultimately returned to the calling function on line 336 and contains the extracted process data. Next, using the <kbd>psutil.pids()</kbd> method as an iterator, which we showed in the demonstration of this library earlier, we pass each process ID to the <kbd>get_pid_details()</kbd> method and store the returned data in the <kbd>pid_info</kbd> dictionary, with the PID serving as the dictionary key.</p>
<p>Let's look at the <kbd>get_pid_details()</kbd> function next:</p>
<pre>158 def get_process_info():<br/>159     """<br/>160     Gather details on running processes within the system.<br/>161     :return pid_info: A dictionary containing details of<br/>162     running processes.<br/>163     """<br/>164 <br/>165     # List of PIDs<br/>166     pid_info = {}<br/>167     for pid in psutil.pids():<br/>168         pid_info[pid] = get_pid_details(pid)<br/>169     return pid_info</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Learning about the get_pid_details() function</h1>
                
            
            
                
<p>The <kbd>get_pid_details()</kbd> method starts to gather information about each PID that is passed to it. For each PID, we create a dictionary, <kbd>details</kbd>, which is pre-populated with relevant keys we can expect to extract values for using the <kbd>psutil</kbd> library. The dictionary keys are initialized with placeholder values, mostly consisting of empty strings and lists:</p>
<pre>101 def get_pid_details(pid):<br/>102     """<br/>103     Gather details on a specific pid.<br/>104     :param pid: an integer value of a pid to query for<br/>105     additional details.<br/>106     :return details: a dictionary of gathered information<br/>107     about the pid.<br/>108     """<br/>109     details = {'name': '', 'exe': '', 'cmdline': '', 'pid': pid,<br/>110                'ppid': 0, 'status': '', 'username': '',<br/>111                'terminal': '', 'cwd': '', 'create_time': '',<br/>112                'children': [], # list of pid ints<br/>113                'threads': [], # list of thread ints<br/>114                'files': [], # list of open files<br/>115                'connections': [], # list of network connections<br/>116                '_errors': []<br/>117     }</pre>
<p>Next, on line 118, we enter a <kbd>try</kbd> and <kbd>except</kbd> block that tries to create a <kbd>Process</kbd> object for each provided PID. In this case, on lines 120 and 124, we have two different exception clauses to handle situations where there is no process matching the provided PID (perhaps if the process closed immediately after script execution) or if there is an operating system error. In either event, should such exceptions occur, the errors are appended to the <kbd>details</kbd> dictionary and the dictionary is returned to the calling function.</p>
<p>Rather than crashing or halting the script due to an issue with a given process, the script continues and will provide any such errors as a column in the CSV report that is generated by the script:</p>
<pre>118     try:<br/>119         proc = psutil.Process(pid)<br/>120     except psutil.NoSuchProcess:<br/>121         details['_errors'].append(<br/>122             (pid, 'Process no longer found'))<br/>123         return details<br/>124     except OSError:<br/>125         details['_errors'].append((pid, 'OSError'))<br/>126         return details</pre>
<p>If a <kbd>Process</kbd> object is created for the provided PID, we then iterate through each key in the <kbd>details</kbd> dictionary on line 128, and if the key is anything other than <kbd>pid</kbd> or <kbd>_errors</kbd>, we attempt to get the value associated with the key with the <kbd>getattr()</kbd> function on line 144. There are a few exceptions to that, however; for instance, we have specific <kbd>elif</kbd> statements for the <kbd>children</kbd>, <kbd>threads</kbd>, <kbd>connections</kbd>, or <kbd>files</kbd> keys. In the case of the <kbd>children</kbd> and <kbd>threads</kbd> keys, we use list comprehension on lines 134 and 138 to associate the children's PIDs and thread's IDs to the <kbd>children</kbd> and <kbd>threads</kbd> keys, respectively.</p>
<p>For both the <kbd>connections</kbd> and <kbd>files</kbd> keys, we have developed separate functions to extract the desired information and store the returned data to the appropriate key in the <kbd>details</kbd> dictionary. Lastly, on lines 145, 148, and 151, we create exceptions that may occur throughout the conditional statements, including handling issues where we lack sufficient privilege, for instance, if the script is running from a non-elevated prompt, or if the process no longer exists, or an operating system error has occurred:</p>
<pre style="padding-left: 30px">128     for key in details:<br/>129         try:<br/>130             if key in ('pid', '_errors'):<br/>131                 continue<br/>132             elif key == 'children':<br/>133                 children = proc.children()<br/>134                 details[key] = [c.pid for c in children]<br/>135 <br/>136             elif key == 'threads':<br/>137                 threads = proc.threads()<br/>138                 details[key] = [t.id for t in threads]<br/>139             elif key == 'connections':<br/>140                 details[key] = read_proc_connections(proc)<br/>141             elif key == 'files':<br/>142                 details[key] = read_proc_files(proc)<br/>143             else:<br/>144                 details[key] = getattr(proc, key, return_none)()<br/>145         except psutil.AccessDenied:<br/>146             details[key] = []<br/>147             details['_errors'].append((key, 'AccessDenied'))<br/>148         except OSError:<br/>149             details[key] = []<br/>150             details['_errors'].append((key, 'OSError'))<br/>151         except psutil.NoSuchProcess:<br/>152             details['_errors'].append(<br/>153             (pid, 'Process no longer found'))<br/>154             break</pre>
<p>As discussed, for two keys, the <kbd>connections</kbd> and <kbd>files</kbd> keys, we called separate functions to handle each of them. Let's now take a look at the first of those.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Extracting process connection properties with the read_proc_connections() function</h1>
                
            
            
                
<p>The <kbd>read_proc_connections()</kbd> function, defined on line 58, starts by creating an empty list, <kbd>conn_details</kbd>, which will store the details of each PID connection:</p>
<pre>058 def read_proc_connections(proc):<br/>059     """<br/>060     Read connection properties from a process.<br/>061     :param proc: An object representing a running process.<br/>062     :return conn_details: A list of process connection<br/>063     properties.<br/>064     """<br/>065     conn_details = []</pre>
<p>For each connection in the provided process, we create a <kbd>conn_items</kbd> dictionary, and store within it, the details of each connection, including the status of the connection and the local and remote IP addresses and ports. As seen before, we use the <kbd>getattr()</kbd> method, querying for named attributes of the specified object and storing the returned value in our dictionary. If the named object does not exist, we use <kbd>None</kbd> or empty strings as default values defined as the third input of the <kbd>getattr()</kbd> function.</p>
<p>We then append the dictionary of details for each connection to the <kbd>conn_details</kbd> list which, after this process has completed for each connection, is itself returned to the calling function:</p>
<pre>066     for conn in proc.connections():<br/>067         conn_items = {}<br/>068         conn_items['fd'] = getattr(conn, 'fd', None)<br/>069         conn_items['status'] = getattr(conn, 'status', None)<br/>070         conn_items['local_addr'] = "{}:{}".format(<br/>071             getattr(conn.laddr, 'ip', ""), getattr(<br/>072                 conn.laddr, 'port', ""))<br/>073         conn_items['remote_addr'] = "{}:{}".format(<br/>074             getattr(conn.raddr, 'ip', ""), getattr(<br/>075                 conn.raddr, 'port', ""))<br/>076 <br/>077         conn_details.append(conn_items)<br/>078     return conn_details</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Obtaining more process information with the read_proc_files() function</h1>
                
            
            
                
<p>The <kbd>read_proc_files()</kbd> method, defined on line 81, follows a similar pattern to what was discussed in the preceding section. Essentially, on line 88, we iterate through all of the open files associated with the process and, using the <kbd>getattr()</kbd> method, attempt to extract information about each open file, such as its path and mode.</p>
<p>We return the <kbd>file_details</kbd> list after extracting all values for each open file and inserting the data into the <kbd>file_details</kbd> list:</p>
<pre>081 def read_proc_files(proc):<br/>082     """<br/>083     Read file properties from a process.<br/>084     :param proc: An object representing a running process.<br/>085     :return file_details: a list containing process details.<br/>086     """<br/>087     file_details = []<br/>088     for handle in proc.open_files():<br/>089         handle_items = {}<br/>090         handle_items['fd'] = getattr(handle, 'fd', None)<br/>091         handle_items['path'] = getattr(handle, 'path', None)<br/>092         handle_items['position'] = getattr(<br/>093             handle, 'position', None)<br/>094         handle_items['mode'] = getattr(handle, 'mode', None)<br/>095 <br/>096         file_details.append(handle_items)<br/>097 <br/>098     return file_details</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Extracting Windows system information with the wmi_info() function</h1>
                
            
            
                
<p>The <kbd>wmi_info()</kbd> function, defined on line 172, starts by defining a dictionary that will store the various types of information we query using the WMI API.</p>
<p>Similarly, on line 185, we create the WMI object and assign it to the variable, <kbd>conn</kbd>, which is what we will be specifically querying:</p>
<pre>172 def wmi_info(outdir):<br/>173     """<br/>174     Gather information available through Windows Management<br/>175     Interface. We recommend extending this script by adding<br/>176     support for other WMI modules -- Win32_PrintJob,<br/>177     Win32_NetworkAdapterConfiguration, Win32_Printer,<br/>178     Win32_PnpEntity (USB).<br/>179     :param outdir: The directory to write CSV reports to.<br/>180     :return: Nothing.<br/>181     """<br/>182 <br/>183     wmi_dict = {"Users": [], "Shares": [], "Services": [],<br/>184         "Disks": [], "Event Log": []}<br/>185     conn = wmi.WMI()</pre>
<p>In some of these code blocks, you will notice that we call a specific function of the <kbd>conn</kbd> object, but in others, we use the <kbd>query()</kbd> method. Note that either option is viable in some cases. For instance, instead of calling <kbd>conn.Win32_UserAccount()</kbd>, we could call <kbd>conn.query("SELECT * from Win32_UserAccount")</kbd>. The <kbd>query()</kbd> method gives us some additional flexibility, as we can provide additional logic to our query, which will be seen when we query for specific event log entries.</p>
<p>Starting with the <kbd>print</kbd> statement on line 190, we begin to collect information using the <kbd>wmi</kbd> library. Iterating through each user profile on line 191, we append various attributes of the user account to the <kbd>wmi_dict</kbd> users list: </p>
<pre>187     # See attributes for a given module like so: for user in<br/>188     # conn.Win32_UserAccount(); user._getAttributeNames()<br/>189 <br/>190     print("[+] Gathering information on Windows user profiles")<br/>191     for user in conn.Win32_UserAccount():<br/>192         wmi_dict["Users"].append({<br/>193             "Name": user.Name, "SID": user.SID,<br/>194             "Description": user.Description,<br/>195             "InstallDate": user.InstallDate,<br/>196             "Domain": user.Domain,<br/>197             "Local Account": user.LocalAccount,<br/>198             "Password Changeable": user.PasswordChangeable,<br/>199             "Password Required": user.PasswordRequired,<br/>200             "Password Expires": user.PasswordExpires,<br/>201             "Lockout": user.Lockout<br/>202         })</pre>
<p> </p>
<p>We start to use the <kbd>query()</kbd> method in the following code block to list all (<kbd>*</kbd>) shares on line 205. For each share, we append various details about it to the appropriate list in the <kbd>wmi_dict</kbd> dictionary. On line 213, we again use the <kbd>query()</kbd> method, this time for services, but only capture services that are currently running.</p>
<p>Hopefully, you can appreciate the value of the <kbd>query()</kbd> method, as it provides the developer with a lot of flexibility on isolating and providing data only matching specified criteria, thereby cutting out a lot of junk:</p>
<pre>204     print("[+] Gathering information on Windows shares")<br/>205     for share in conn.query("SELECT * from Win32_Share"):<br/>206         wmi_dict["Shares"].append({<br/>207             "Name": share.Name, "Path": share.Path,<br/>208             "Description": share.Description,<br/>209             "Status": share.Status,<br/>210             "Install Date": share.InstallDate})<br/>211<br/>212     print("[+] Gathering information on Windows services")<br/>213     for service in conn.query(<br/>214             "SELECT * FROM Win32_Service WHERE State='Running'"):<br/>215         wmi_dict["Services"].append({<br/>216             "Name": service.Name,<br/>217             "Description": service.Description,<br/>218             "Start Mode": service.StartMode,<br/>219             "State": service.State,<br/>220             "Path": service.PathName,<br/>221             "System Name": service.SystemName})</pre>
<p>On line 224, we begin to collect details on the connected drives by iterating through each drive using the <kbd>conn.Win32_DiskDrive()</kbd> function. To collect all of the information we want to extract, we need to also iterate through each partition and the logical volume of each disk; hence, the additional <kbd>for</kbd> loops on lines 225 and 227.</p>
<p>Once we have the <kbd>disk</kbd>, <kbd>partition</kbd>, and <kbd>logical_disk</kbd> objects, we use each and append a dictionary to the appropriate list of the <kbd>wmi_dict</kbd> dictionary containing the various properties of each disk, partition, and volume:</p>
<pre>223     print("[+] Gathering information on connected drives")<br/>224     for disk in conn.Win32_DiskDrive():<br/>225         for partition in disk.associators(<br/>226                 "Win32_DiskDriveToDiskPartition"):<br/>227             for logical_disk in partition.associators(<br/>228                     "Win32_LogicalDiskToPartition"):<br/>229                 wmi_dict["Disks"].append({<br/>230                     "Physical Disk Name": disk.Name,<br/>231                     "Bytes Per Sector": disk.BytesPerSector,<br/>232                     "Sectors": disk.TotalSectors,<br/>233                     "Physical S/N": disk.SerialNumber,<br/>234                     "Disk Size": disk.Size,<br/>235                     "Model": disk.Model,<br/>236                     "Manufacturer": disk.Manufacturer,<br/>237                     "Media Type": disk.MediaType,<br/>238                     "Partition Name": partition.Name,<br/>239                     "Partition Desc.": partition.Description,<br/>240                     "Primary Partition": partition.PrimaryPartition,<br/>241                     "Bootable": partition.Bootable,<br/>242                     "Partition Size": partition.Size,<br/>243                     "Logical Name": logical_disk.Name,<br/>244                     "Volume Name": logical_disk.VolumeName,<br/>245                     "Volume S/N": logical_disk.VolumeSerialNumber,<br/>246                     "FileSystem": logical_disk.FileSystem,<br/>247                     "Volume Size": logical_disk.Size,<br/>248                     "Volume Free Space": logical_disk.FreeSpace})</pre>
<p>Next, on line 253, we create a variable, <kbd>wmi_query</kbd>, to hold a string that we will use to extract all events with event ID 4624 from the <kbd>Security</kbd> event log.</p>
<p>Note that it was observed in testing that the script needs to be run from an elevated Command Prompt to be able to extract information from the <kbd>Security</kbd> event log.</p>
<p>Similar to the other queries, we iterate through the returned results and append various attributes to the appropriate list in the <kbd>wmi_dict</kbd> dictionary:</p>
<pre>250     # Query for logon events type 4624<br/>251     print("[+] Querying the Windows Security Event Log "<br/>252     "for Event ID 4624")<br/>253     wmi_query = ("SELECT * from Win32_NTLogEvent WHERE Logfile="<br/>254         "'Security' AND EventCode='4624'")<br/>255     for logon in conn.query(wmi_query):<br/>256         wmi_dict["Event Log"].append({<br/>257             "Event Category": logon.CategoryString,<br/>258             "Event ID": logon.EventIdentifier,<br/>259             "Time Generated": logon.TimeGenerated,<br/>260             "Message": logon.Message})</pre>
<p>Lastly, after extracting all of the information and storing it in the <kbd>wmi_dict</kbd> dictionary, we begin to make calls to the <kbd>csv_writer()</kbd> function to write a spreadsheet for each type of data to the output directory. Most of the values being passed into the <kbd>csv_writer()</kbd> are self-explanatory and include the artifact-specific data (that is, User Profiles under the <kbd>Users</kbd> key), the output directory, and the output filename. The last argument is an alphabetically sorted list of keys from the artifact-specific data to serve as column headers for our CSV.</p>
<p>You will also notice that we have a <kbd>try</kbd> and <kbd>except</kbd> block to handle writing the event log data. The reason for this, as previously discussed, is that, if the script is not run from an elevated Command Prompt, it is possible that the <kbd>Event Log</kbd> key will consist of an empty list:</p>
<pre>262     csv_writer(wmi_dict["Users"], outdir, "users.csv",<br/>263         sorted(wmi_dict["Users"][0].keys()))<br/>264     csv_writer(wmi_dict["Shares"], outdir, "shares.csv",<br/>265         sorted(wmi_dict["Shares"][0].keys()))<br/>266     csv_writer(wmi_dict["Services"], outdir, "services.csv",<br/>267         sorted(wmi_dict["Services"][0].keys()))<br/>268     csv_writer(wmi_dict["Disks"], outdir, "disks.csv",<br/>269         sorted(wmi_dict["Disks"][0].keys()))<br/>270     try:<br/>271         csv_writer(wmi_dict["Event Log"],outdir, "logonevent.csv", <br/>272                    sorted(wmi_dict["Event Log"][0].keys()))<br/>273     except IndexError:<br/>274         print("No Security Event Log Logon events (Event ID "<br/>275             "4624). Make sure to run the script in an escalated "<br/>276             "command prompt")</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Writing our results with the csv_writer() function</h1>
                
            
            
                
<p>Our <kbd>csv_writer()</kbd>, defined on line 279, begins normally enough, by creating a <kbd>csvfile</kbd> file object based on the version of Python being used to execute the script. One thing that is different is the <kbd>**kwargs</kbd> argument listed in the definition of the function. The <kbd>**</kbd> component of that argument indicates that this function accepts keyword arguments. In Python, by convention, keyword arguments are referred to as <kbd>kwargs</kbd>.</p>
<p>We use keyword arguments in this function to differentiate between using the regular <kbd>csv.writer()</kbd> method and the <kbd>csv.DictWriter()</kbd> method. This is necessary because the CSV calls from the <kbd>wmi_info()</kbd> and the <kbd>get_process_info()</kbd> functions pass in a list and dictionary, respectively. </p>
<p>While using additional logic in the <kbd>csv_writer()</kbd> method solves our problem, we could also have solved this issue by making both the <kbd>wmi_info()</kbd> and <kbd>get_process_info()</kbd> functions return similarly structured objects:</p>
<pre>279 def csv_writer(data, outdir, name, headers, **kwargs):<br/>280     """<br/>281     The csv_writer function writes WMI or process information<br/>282     to a CSV output file.<br/>283     :param data: The dictionary or list containing the data to<br/>284         write to the CSV file.<br/>285     :param outdir: The directory to write the CSV report to.<br/>286     :param name: the name of the output CSV file.<br/>287     :param headers: the CSV column headers.<br/>288     :return: Nothing.<br/>289     """<br/>290     out_file = os.path.join(outdir, name)<br/>291 <br/>292     if sys.version_info[0] == 2:<br/>293         csvfile = open(out_file, "wb")<br/>294     elif sys.version_info[0] == 3:<br/>295         csvfile = open(out_file, "w", newline='',<br/>296             encoding='utf-8')</pre>
<p>As you can see on line 298, we check to see if a keyword argument called <kbd>type</kbd> was passed into the function call. Given that we only do this on the call to this function on line 341,we know what this signifies. We should use the <kbd>csv.DictWriter</kbd> method. On line 341, you'll note that we assigned the <kbd>type</kbd> keyword argument to the <kbd>DictWriter</kbd> string  However, in this case, we could have passed any arbitrary string, as we do not use its value at all here. Rather, we need only know that the <kbd>type</kbd> keyword argument was assigned a value.</p>
<p>For the dictionary from the <kbd>get_process_info()</kbd> function, we can use list comprehension to write the values of each entry of the dictionary. For the <kbd>wmi_info()</kbd> function, we need to first iterate through each entry in the provided list and then write the value associated with each of the provided headers to the CSV file:</p>
<pre>298     if 'type' in kwargs:<br/>299         with csvfile:<br/>300             csvwriter = csv.DictWriter(csvfile, fields,<br/>301                 extrasaction='ignore')<br/>302             csvwriter.writeheader()<br/>303             csvwriter.writerows([v for v in data.values()])<br/>304 <br/>305     else:<br/>306         with csvfile:<br/>307             csvwriter = csv.writer(csvfile)<br/>308             csvwriter.writerow(headers)<br/>309             for row in data:<br/>310                 csvwriter.writerow([row[x] for x in headers])</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Executing pysysinfo.py</h1>
                
            
            
                
<p>In the following screenshot, you can see the output printed to the when running this script on a Windows system:</p>
<p class="CDPAlignCenter CDPAlign"><strong><img src="img/51f36ee7-799b-434e-b612-59df0f15a3f7.png" style="width:42.67em;height:8.92em;"/></strong></p>
<p>Additionally, after executing the script on a Windows system, CSV files for connected drives, shares, services, processes, users, and logon events are created in the specified output directory. A screenshot of the contents of one such spreadsheet, the user profile spreadsheet, is captured here:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-785 image-border" src="img/18e3b3b1-571f-4b09-b7c0-6a920c9afb68.png" style="width:93.83em;height:18.33em;"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Challenges</h1>
                
            
            
                
<p>As alluded to in the <em>Using the WMI</em> section, consider expanding the script's capabilities by being able to query remote Windows hosts. Similarly, both <kbd>wmi</kbd> and <kbd>psutil</kbd> offer access to additional information that is worth collecting. Experiment with these two libraries and collect more information, especially focusing on collecting system information for non-Windows systems, which, in the current iteration of this script, is more fully supported thanks to the <kbd>wmi</kbd> library.</p>
<p>Lastly, for a more advanced challenge, consider developing a more useful storage repository to collect and query the data. It's all well and good to collect and present data in the way we have for a few systems, but how well would this scale when run across many hundreds of systems? Imagine a scenario where you deploy and run a modified version of this script against many hosts on a network and have that processed information stored in a singular centralized database for storage and, more importantly, as a more efficient means of querying the collected data.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we confirmed the value of system information and how to extract that information on live systems. Using the <kbd>psutil</kbd> library, we learned how to extract process information in an OS-agnostic manner. We also briefly touched on how to use the WMI API to obtain even more information from the Windows operating system. The code for this project can be downloaded from GitHub or Packt, as described in the <em>Preface</em>.</p>
<p>In the next chapter, we will learn how to process an Outlook archive <kbd>.pst</kbd> file with Python and create a listing of its contents.</p>


            

            
        
    </body></html>