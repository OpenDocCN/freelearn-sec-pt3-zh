- en: Deep Packet Inspection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Deep Packet Inspection** (**DPI**) become popular when the Edward Snowden
    leaks about data collection by the government came out. It has gone from just
    another buzzword to making headlines. In this chapter, we will look at various
    traits of protocols and packets that aid DPI.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be specifically looking at the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Analysis of multiple protocols
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Packet encapsulation and packet analysis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, why are we learning DPI? Well, DPI is the process of looking beyond the
    generic TCP/IP headers and involves analyzing the payload itself.
  prefs: []
  type: TYPE_NORMAL
- en: Devices with DPI capabilities can analyze, evaluate, and perform actions from
    layer 2 to the application layer itself. This means that the devices with DPI
    capabilities are not only reliant on the header information but also check what
    is being sent as the data part. Hence, the overall tradition of network analysis
    is now changing.
  prefs: []
  type: TYPE_NORMAL
- en: 'DPI is widely used in the following fields and services:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Traffic shapers**: Blocking malicious traffic/limiting traffic.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Service assurance**: Network admins can ensure that high-priority traffic
    is carefully dealt with and services do not go down for them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Identification ****of ****fake ****applications**: Applications that make
    use of non-standard ports to leverage standard protocol data are easily identified
    with DPI.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Malware Detection**: Since DPI allows viewing the payload itself, malware
    detection is much easier to perform.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Intrusion detection**: Not only malware, but also the DPI-enabled system
    can uncover hack attempts and exploit attempts, backdoors, and much more.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data Leakage Prevention (DLP)**: With DPI, we can identify critical data
    traveling out of the network as well, making it an ideal choice for DLP systems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before diving deep, let's understand the encapsulation of protocols on the different
    layers of communication.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To complete exercises performed in this chapter, you will require the following
    software''s:'
  prefs: []
  type: TYPE_NORMAL
- en: Wireshark v3.0.0 ([https://www.wireshark.org/download.html](https://www.wireshark.org/download.html))
    installed on Windows 10 OS / Ubuntu 14.04
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Notepad++ 7.5.9 ([https://notepad-plus-plus.org/download/v7.6.4.html](https://notepad-plus-plus.org/download/v7.6.4.html))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Download PCAP files for this chapter from [https://github.com/nipunjaswal/networkforensics/tree/master/Ch3](https://github.com/nipunjaswal/networkforensics/tree/master/Ch3)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Protocol encapsulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before moving forward, let''s look at how the packets are made and what sort
    of information they carry. Understanding a network packet will not only allow
    us to gain knowledge, but will also help to hone our network forensics skills.
    In layman''s terms, we can say that a network packet is merely data put together
    to be transferred from one endpoint/host to another. However, in the depths of
    a network, an IP packet looks similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fda06dde-e116-47e4-9024-62fb1cf47f22.png)'
  prefs: []
  type: TYPE_IMG
- en: 'From the very first raw data on the wire, to becoming an Ethernet frame, to
    the IP packet, and further, to the TCP and UDP type, and finally, becoming the
    application data, the information is encapsulated through various layers. Let''s
    see an example of packet encapsulation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/217bb7cc-0063-4863-8fb6-0a341f3d4a5f.png)'
  prefs: []
  type: TYPE_IMG
- en: From the preceding example, we can see that on the wire, the packet was only
    a mere frame that encapsulated Ethernet information containing MAC addresses of
    both source and destination. The IP header is merely responsible for sending a
    packet from one endpoint to another, while the TCP header keeps a note of communication
    between the two endpoints. Finally, we have the data, which is nothing but our
    layer 7 data, such as HTTP and FTP. We will have a brief look at the IP header
    structure in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: The Internet Protocol header
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we mentioned the IP header previously, let''s see an example of IPv4 packet
    and break it down in the form of its fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Version**: The version contains the format of the IP packet.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**IP Header Length (IHL)**: Length of the IP packet header. There are generally count
    of 32-bit words in the packet.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Differentiated Services Code Point (DCSP)**: Previously called the TOS, this
    is usually used for real-time communications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Explicit Congestion Notification (ECN)**: Congestion can be detected through
    this field.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Total Length**: The complete length of the packet, including the data and
    header.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Identification**: For unique packet identification, however if fragmentation
    occurs, this value will be the same for all fragments'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Flags**: The flags usually indicate whether the router is allowed to fragment
    the packets.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fragmentation Offset**: In cases where the fragmentation occurs, this field
    is used to indicate offset from the start of the datagram itself.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Time To Live (TTL)**: The number of devices the packet hops to before it
    expires.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Protocol**: The meat of the packet that describes what protocol is encapsulated
    within, for example, TCP or UDP or other transport layer protocols.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Header Checksum**: Used for error-detection purposes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Source Address**: Packet sender.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Destination Address**: Destination of the packet.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Options**: Extra options. Variable length.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Padding**: Adds extra bits to make the packet length a multiple of 32 bits.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s expand the IP header part of the packet to see these packet values:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/49866b08-4356-4415-82d8-7a456b5239df.png)'
  prefs: []
  type: TYPE_IMG
- en: We can see all the mentioned fields in the IP header for the packet. Throughout
    our network forensics investigation, we will make use of them from time to time.
    Let's look at the next layer of encapsulation, which is the TCP header.
  prefs: []
  type: TYPE_NORMAL
- en: The Transmission Control Protocol header
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Following our discussion on the IP header for the packet, we captured in Wireshark.
    Let''s check out the TCP header:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/22dad0d5-fbb4-4f82-9b43-8d462b8d6350.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can see that the TCP header contains the following sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Source Port**: The port that generates the packet.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Destination Port**: The port at which the data is addressed for a particular
    host.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sequence number**: The first data byte position.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Acknowledge number**: The next data byte the receiving host is expecting.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Header Length**: The length of the Transport layer header in 32-bit words.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Flags**: The control bit field has the following types of values:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**URG**: Prioritize data'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ACK**: Acknowledge received packet'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PSH**: Immediately push data'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**RST**: Abort a connection'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SYN**: Initiate a connection'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**FIN**: Close a connection'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**NS ECN-nonce - concealment protection**'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Congestion Window Reduced** (**CWR**)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ECE ECN**: Echo either indicates that the peer can use ECN (if the SYN flag
    is set); otherwise, indicates that there is network congestion'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Window**: The size/amount of data that can be accepted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Checksum**: Used for finding errors while checking the header, data and pseudo-header'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Urgent pointer**: The pointer to the end of the urgent data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Options**: Additional options.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Padding**: For size-matching by padding the header.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Moving further down the packet encapsulation, we can see that we have the TCP
    payload that contains the HTTP packet:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8c2191e6-7d9e-49c5-8849-37d416c27415.png)'
  prefs: []
  type: TYPE_IMG
- en: The HTTP packet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The HTTP packet includes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Request Line**: Contains the `GET`/`POST` request type or other HTTP options
    followed by the requested resource, which is `cloudquery.php` in our case, supported
    by HTTP/1.1, which is the version of the HTTP protocol.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Request Message Headers**: This section contains all the header information,
    such as general headers, request headers, and entity headers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Message Body**: The sent data to the endpoint, such as files, parameters,
    and images, is placed here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In our case, we can see that the data is a `POST` request type that posts data
    to the `cloudquery.php` page on the `54.255.213.29` IP address. We can also see
    that the data posted contains some file data. We can see the message body:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f50205a0-404a-4645-94d9-155607620cfa.png)'
  prefs: []
  type: TYPE_IMG
- en: We can see that the data being sent looks gibberish. We will see more on the
    decryption, decoding, and decompression of data in the upcoming chapters.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we saw how a frame on the wire encapsulated a variety of data meant
    for the various layers of the TCP/IP model. We also saw how a frame jolted down
    right to the HTTP request that contained some encrypted data. Let's move further
    and figure out what is sometimes referred to as **unknown protocols** and how
    to make them recognizable in Wireshark.
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing packets on TCP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The reason of the world moving majorly onto the techniques such as DPI is the
    recognition of protocols on a non-standard port as well. Consider a scenario where
    an FTP server is listening on port `10008`, which is a non-standard FTP port,
    or where an attacker infiltrated the network and is using port `443` to listen
    to FTP packets. How would you recognize that the HTTP port is used for FTP services?
    DPI allows that and discovers what lies inside the packet rather than just identifying
    the type of service based on the port numbers. Let''s see an example of a capture
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/08182eea-691f-4628-8f3d-6f619a83ba63.png)'
  prefs: []
  type: TYPE_IMG
- en: 'From the preceding screenshot, we cannot exactly figure out the type of application
    layer the TCP packets are referring to. However, if we look closely in the data
    of the packet, to our surprise, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5d5c00ea-b5af-43ee-a524-5e75be5f22a2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can see that the decoded data contains a list of FTP commands. This means
    that the protocol is FTP, but the reason for Wireshark not decoding the protocol
    is again the same reason some firewalls and traffic analyzers make use of port
    numbers to identify protocols rather than looking inside and finding what matters
    the most, and that is the sole reason DPI is required. However, let''s look at
    ways we can decode what''s being sent and try to decode it back to FTP:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/25d899b8-3d93-42c1-9d64-91c39fb196fa.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s try following the TCP stream by right-clicking a packet and checking
    out the TCP stream:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9314af6d-85df-4bc0-a5f5-0f0b64a8424f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can see that the TCP stream displays various types of FTP details, such
    as commands issued. However, this is not what we need. We need a mechanism to
    force Wireshark into decoding this data once and for all. Let''s have another
    look at the packet:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9060a1e3-6f07-4b98-86cd-282e3c98087b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can see that the source port is `10008` for the data that originated from
    the FTP server. Let''s quickly note that down. Next, we need to decode this into
    FTP; we can use the Decode As..., a feature of Wireshark:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/70865590-b83c-4f0d-be4c-929a9e173a13.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As soon as we press the **Decode as...** button, we get the following popup
    on the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1afbcaec-1986-4590-a2f6-b76ee93179c2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s click on the **+** button, which will populate the following entry:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9e037eab-4544-4a90-9de2-3632c8619b51.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Since the originating port was `10008`, let''s modify the value to `10008`
    from `55695` and **Current** to **FTP**, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6335a297-c30a-4415-bb76-defffac60bd9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s press the **OK** button to see changes to the packets:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5d41a3d4-dd2d-4024-b6d3-531529d53384.png)'
  prefs: []
  type: TYPE_IMG
- en: Wow! We can see the FTP data now. We just saw that we can recognize a protocol
    that is running on non-standard ports.
  prefs: []
  type: TYPE_NORMAL
- en: We saw how the TCP packet works and also saw its applications, such as HTTP
    and FTP. Let's jump into the UDP packet and take the most common application of
    it, which is DNS. I know some might argue that DNS makes use of both TCP and UDP
    at times, like zone transfers. However, for most of its operations, such as resolving
    queries, DNS makes use of UDP packets only.
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing packets on UDP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The **user datagram protocol** (**UDP**) is used primarily for real-time communications
    and in situations where speed matters. The UDP header size is 8 bytes compared
    to 20 in TCP. A UDP packet does not have segment acknowledgment and is usually
    much faster, since it is a connectionless protocol. Also, error checking is still
    a part of UDP, but no reporting of errors takes place. A common example of UDP
    is **Voice over Internet Protocol** (**VoIP**). Comparing to the structure we
    discussed in the very beginning of the chapter, we have the following structure
    for UDP:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eabc6ec9-495c-4102-a41d-ba0e8ee9a062.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can see that we have so many fields reduced and primarily have only the **Source
    Port**, **Destination Port**, **Length**, and **Checksum** fields. Let''s validate
    this by analyzing a UDP packet in Wireshark:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/30ebf07c-b4e0-4f74-a78d-8dc910f0371c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can see that we have certain fields as mentioned in the preceding diagram.
    Additionally, we can see that we have DNS data, which is nothing but the data
    field as mentioned in the diagram. Let''s see what details we have on expanding
    the DNS field:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/75fbbd4b-c30a-4003-8647-a10ff679a22a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can see that the raw data was decoded by Wireshark to reveal **Transaction
    ID**, **Questions**, **Answers**, and other details:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fa065a8a-0b48-457c-9673-ac624377ccb2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can see that in the queries section, we also have the domain and subdomain
    values, record type, and addresses. You can see that pointing to any of the preceding
    fields will highlight the raw data segment:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e036e94e-777d-498a-9fd9-ddbbab0f470e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Understanding each raw data packet can also help us to develop PCAP readers
    and custom network analyzers. Hence, let''s build some filters based on the following
    data fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/efcfbb84-e98f-4d85-9e3d-7a735d1f8c41.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We saw a field called the DNS transaction ID. We can make use of it by coupling
    DNS and ID together while equating the value to `0x2581.` The filter would be
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the filter, we will have the unique packets for the transaction, as we
    can see that we have a DNS standard query and its associated response. Wireshark
    allows us to perform a variety of filtering operations on the DNS and other protocols
    by interpreting raw fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c488c772-2266-4b4f-b77b-da07e5f60fb6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s see an example of how DNS queries work and then figure out their corresponding
    response times in the next example by actually going ahead and capturing packets
    on our internet connected wireless interface. Additionally, we will only capture
    packets on port `53` to analyze the DNS queries and responses as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3cae3697-4e0d-4ef4-8e28-7ac2276c8f91.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We use a capture filter that will only capture packets from port `53`. Let''s
    double-click the Wi-Fi interface and start capturing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d833da11-a740-42fc-b183-5750e64b73c5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can see that the data has started flowing in. Let''s open some websites
    and set the flags filter to `0x8180` by placing the `dns.flags == 0x8180` display
    filter. The value `0x8180` denotes a standard DNS response. Let''s see the result
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7f1f99ac-ece4-4797-a907-029dc1b785cd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Wireshark only displays standard DNS response packets. Let''s analyze their
    response times as well. We can see that every packet has the response time associated
    with it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6f51504e-14fc-4cd8-a190-92429f097508.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s right-click the time field and choose **Apply as Column**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/24a21a78-50ba-40fc-b6c7-57c4e2e5247c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can now see that another field got added to the packet list:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ea9619cd-2452-4c8e-a6ef-6a9fdb720528.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We have a new column, **Time**, added to it. However, the entry''s name is
    redundant with time. Let''s change it by right-clicking and selecting Edit Column:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/debfb5dc-768f-4f07-8848-edd365ae2a1f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can now rename the field `Response Time`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00bedfc3-e8e0-43a2-90f9-211de10dab4b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s check out the packet list:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8a62e2da-e9a4-4c3f-8041-866679aeee0f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can now see that we have response times for all the DNS response packets.
    However, we can also see that some of the packets do not have this value, and
    this is where the DNS response has been received twice. You might be wondering
    why we are discussing this in a network forensics book. It''s because having a
    brief knowledge of these packets will help us understand the complex examples
    in the upcoming chapters. We are still in the learning phase, and in the next
    few chapters, everything we learn here will start to make sense. So, let''s continue
    and see only those packets that have been retransmitted using the `dns.retransmit_response`
    filter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/328b2d59-e7ce-4a59-a712-232fabf972f2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can now only see retransmitted responses. We can also filter all the queries
    based on the query names; let''s filter out all the queries related to `google.com`.
    We can set up a filter, such as `dns.qry.name contains "google.com"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/44ff94c7-8ad9-4b99-8137-10705a595dc9.png)'
  prefs: []
  type: TYPE_IMG
- en: Analyzing packets on ICMP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s take a look at the **Internet Control Message Protocol** (**ICM****P**).
    It is one of the most popular protocols, and is better known for being used in
    ping commands, which is where an ICMP echo request is sent to an IP address with
    some random data, and it then denotes whether the system is alive. A typical ICMP
    packet would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a91bcd44-6b90-4d25-bda9-583c08e1a85f.png)'
  prefs: []
  type: TYPE_IMG
- en: The ICMP has many messages, which are identified by the **Type of Message**
    field. The **Code** field indicates the type of message. The **Identifier** and
    **Sequence Number** can be used by the client to match the reply with the request
    that caused the reply.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Data** field may contain a random string or a timestamp to compute the
    round-trip time in a stateless manner. Let''s ping [https://www.google.com/](https://www.google.com/) and
    analyze it in Wireshark:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/98c59ec6-89ac-4bb0-b5ab-1159ed7a1d38.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can see that we have four Echo request and four Echo reply packets. Let''s
    see the request first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d0b37d3b-c38d-4a74-bed4-caf7346224fc.png)'
  prefs: []
  type: TYPE_IMG
- en: The request is of the Echo type and is denoted by the number 8, and the code
    is 0.
  prefs: []
  type: TYPE_NORMAL
- en: Check out the ICMP type and codes at [https://www.iana.org/assignments/icmp-parameters/icmp-parameters.xhtml#icmp-parameters-codes-8](https://www.iana.org/assignments/icmp-parameters/icmp-parameters.xhtml#icmp-parameters-codes-8).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also see that the data starts with `09b` and goes up to 48 bytes. Since
    we are pinging Google, if it''s up, it will reply with the same data back to us.
    Let''s see the response:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/be29763a-a1ea-4d7a-962a-32c24ffdd8e3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can see that the data was sent back as is, which denotes that the system
    is up. Also, we can see that the **Identifier** and **Sequence number** are similar
    to the one in the request. The **Type** for the **Echo reply** is denoted by **0**
    and the code also remains zero. Let''s see what happens when the IP is not reachable:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dc1f9f48-b9b2-4078-a465-6e4bff975db5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The preceding `ping` command denotes that there was a 100% loss of packets;
    let''s see Wireshark:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/25cb726f-c673-4014-86df-592b21a78dec.png)'
  prefs: []
  type: TYPE_IMG
- en: We can see that Wireshark has not seen any response. Hence, it marked it as
    no response found.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have covered the basics of the TCP, UDP, and ICMP protocols. Let's
    see a case study and analyze the involved PCAP evidence file in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Case study – ICMP Flood or something else
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Imagine you are a network forensics expert who has been tasked with analyzing
    the PCAP file. As soon as you open the file in Wireshark, you are presented with
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/02f4ec43-deaa-4ac4-958c-e349f8c8341f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'What we can see from the capture file is that it contains a ton of ICMP packets
    traveling to and from `192.168.153.129` and `192.168.153.130`. We quickly added
    a new column by right-clicking the column header in Wireshark and choosing **Column
    Preferences** and adding a new column by clicking the **+** button and choosing
    its type as **UTC** for the UTC time, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5dd5631a-3d36-4953-b150-6067da5a8f39.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we go to the **Statistics** tab and choose Capture File Properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8cd5fffe-037f-4d4c-9e97-0c591645326e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The preceding option will populate the following window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/22e7c625-7e67-481b-af05-3b0f98ca7136.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can see a good amount of detail related to the capture file, such as the
    date and time of the first packet, last packet, duration, average packets per
    second, and the number of packets captured. When we populate the **Endpoints**
    tab, we can see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eb9ece5b-5505-4a11-a368-2e93db1ae257.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can quickly determine that the `192.168.153.129` and `192.168.153.130` IP
    addresses are communicating. We can confirm this by opening the **Conversations**
    tab:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6524c7ab-837c-4470-b198-21170fe1e7d4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can see that both IPs are communicating. However, the strange thing is that
    the only traffic exchanged between these two is ICMP traffic. Using the filter
    as `icmp.type == 8` displays that there are 510 ICMP echo requests sent from `192.168.153.129`
    to `192.168.153.130`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/087a01d1-8208-47ce-8da6-10d53e5abad7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s see the number of replies by setting the `icmp.type == 0` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/25a09d8e-7019-4172-9cc6-c9a9c655b104.png)'
  prefs: []
  type: TYPE_IMG
- en: We can see that the number of replies is almost equal to the number of requests—Strange!
    Someone would never send out that amount of ping requests intentionally—unless
    they are conducting a DOS attack. However, carrying out a **ping of death** or
    Ping DoS will require a significantly higher number of packets.
  prefs: []
  type: TYPE_NORMAL
- en: A ping DoS would require more packets, but a ping of death might only require
    one on a vulnerable system.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is something wrong with this. Let''s investigate the packets:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8effb7a0-90f2-4bc4-be71-eb6ee6f93cef.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Everything seems fine until we reach packet number 149, to which no response
    was received from the target. The next packet, number 150, contains something
    of interest:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6181fee4-1751-43ce-9754-759eda0daa22.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Packet 150 contains `ipconfig` in the data segment. Hmm.. this is awkward!
    Let''s investigate further:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/83c02494-1079-4160-b08d-3541665709d4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Packet number 179 has a system path in it. This is going south! The found traces
    denote that someone is accessing this system using an ICMP shell. The ICMP shell
    is a backdoor that makes use of data fields to send replies to a command sent
    by the attacker. Since all the requests originated from `192.168.153.129`, we
    have our attacker. We can also see another strange thing: The ICMP packets are
    missing data fields, apart from the packets'' ICMP backdoor packets. This gives
    us an edge to only focus on the packets having data, for this, we can type data
    as the filter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5febb9d6-f425-4df4-a994-b3bee70bb428.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can see that we are only left with 17 packets out of 1,087, which can be
    easily traversed using Tshark. Tshark is the command-line wireless equivalent
    and is way better for people who love the command line. We will make use of PowerShell
    to run Tshark in Windows, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command runs Tshark with the `-Y` switch as data, which denotes
    the filter, `-r` as the path of the capture file; the `-T` fields denotes the
    field types to print, and `-e` denotes which fields will be printed. Additionally,
    more details on these optional switches can be found using `man tshark` or `tshark
    –help` command in Windows. Now, let''s run this command as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/006447da-e302-469d-b5c9-bff9dca2267f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can see that we have all the data from the 17 packets in hex. Let''s copy
    this data into Notepad++:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d50addc3-b31c-4b34-a613-fd3e6731a0ec.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Notepad++ contains pre-installed plugins to convert hex into ASCII. Let''s
    browse to the **Plugins** tab and choose **Converter** | **Hex -> ASCII**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/188e9354-1c7f-4d68-b393-a10f9d6cd0bc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As soon as we press the **Hex -> ASCII** option, we will have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e6df6e9a-37e3-4c4c-a497-bde602e56914.png)'
  prefs: []
  type: TYPE_IMG
- en: God! Someone was running commands on the system; they ran `ipconfig` followed
    by the `whoami` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this exercise, we saw how innocent-looking ICMP packets were used to access
    a compromised system. However, throughout this exercise, we learned how to do
    a few things: We investigated ICMP packets, found some malicious activity, gathered
    and clubbed data from the various packets into a single file, and decoded them
    from hex into ASCII to reveal the intentions of the attacker and the activities
    that they performed on the target. We also identified that the backdoor was making
    use of the ICMP protocol to conduct command and control, and we looked at using
    Tshark for the very first time.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We covered some serious theory in this chapter. We started by looking at the
    IP and TCP protocol headers, and we analyzed the HTTP protocol. We then analyzed
    the FTP protocol, and the UDP-oriented DNS service. We looked at the ICMP protocol
    and saw a case study where ICMP was being used for command and control. Throughout
    this chapter, we learned new and advanced concepts to analyze various packets
    and protocols. In the next chapter, we will look at statistical flow analysis,
    and we will learn how it can help us conduct an efficient network forensic exercise.
  prefs: []
  type: TYPE_NORMAL
- en: Questions and exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To enhance your network forensics skills on various protocols and packets,
    try answering/solving the following exercises and problems:'
  prefs: []
  type: TYPE_NORMAL
- en: Refer to the case study on ICMP. Try a similar exercise for DNS by analyzing
    `dns-shell` ([https://github.com/sensepost/DNS-Shell](https://github.com/sensepost/DNS-Shell)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Study at least five different packet structures including IPv6, TLS, NTP, and
    many others.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write a small Bash script in Linux to convert hexadecimal characters to ASCII.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To learn more about DPI, check out [https://is.muni.cz/th/ql57c/dp-svoboda.pdf](https://is.muni.cz/th/ql57c/dp-svoboda.pdf).
  prefs: []
  type: TYPE_NORMAL
