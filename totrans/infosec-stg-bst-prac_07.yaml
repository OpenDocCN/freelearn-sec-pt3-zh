- en: 'Chapter 5: Controlling Access and Managing Identity'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Well, well, well… look who we have here. It's you! Not to mention the thirst
    for knowledge about controlling access and managing identity that you brought
    along. That's so great, and quite a coincidence, as this chapter actually covers
    those topics.
  prefs: []
  type: TYPE_NORMAL
- en: '**Identity and Access Management**, or **IAM**, helps with understanding both
    the people and the automated services that are doing all of the **CRUD** (short
    for **Creating, Reading, Updating, and Deleting**) in your estate. That sounds
    important because it is important. How else can you ensure an entity is actually
    the approved user they claim to be?'
  prefs: []
  type: TYPE_NORMAL
- en: Also, based on previous chapters, we have described certain levels of permission
    based on various aspects of privacy and confidentiality, but how is it that we
    can enforce those rules in an automated way in our digital environment? How do
    you walk the tightrope of the right amount of access? Too much access for your
    users and you've got a breach on your hands, but not enough access and your users
    aren't able to be productive in their day-to-day work. The aim of this chapter
    is to help you answer these questions for you and your organization.
  prefs: []
  type: TYPE_NORMAL
- en: 'Essentially, what I want from this chapter is to discuss the following bullet
    points:'
  prefs: []
  type: TYPE_NORMAL
- en: Access control models and concepts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selecting and implementing authentication and authorization mechanisms for people,
    devices, and services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identity and access management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling physical access to assets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I know how exciting this all sounds for you because just writing this is making
    the hair on the back of my neck stand up straight. So, with that said, enough
    stalling; let's just get started!
  prefs: []
  type: TYPE_NORMAL
- en: Access control models and concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When it comes to information security, the same idea applies from the physical
    security realm; *restricting access* to a location or asset is referred to as
    **access control**. When we say access, we could mean physically entering a space
    or digitally accessing a folder. We could mean reading a printed document in an
    office, but we can also consider the CRUD possibilities in a digital estate as
    well.
  prefs: []
  type: TYPE_NORMAL
- en: The classic (or retro?) access control is a **lock and key**. If somebody has
    the key, they're able to access what the lock is preventing access to. And if
    they have the key, they're allowed to access it, right? Is it that simple? Of
    course not. What we want is the ability to ensure that the people with the key
    are the people with permission, and try our best to ensure that even *with* the
    key, the wrong people aren't allowed to (or **authorized** to) access what they
    shouldn't.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before diving into the models, I''d like to cover four key definitions first:'
  prefs: []
  type: TYPE_NORMAL
- en: A **subject** is a user or program that manipulates *objects*. Subjects can
    act.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An **object** is passive data that is manipulated by *subjects*. Objects cannot
    act.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Clearance** is assigned to a *subject*, which dictates their access level,
    for instance, *Confidential*, *Secret*, or *Top Secret*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **classification** or **confidentiality/integrity** level is assigned to
    an *object*, depending on its nature or sensitivity.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that those are covered, let's begin with the **state machine model**.
  prefs: []
  type: TYPE_NORMAL
- en: State machine model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **state machine model** is a concept of preventing a system from becoming
    insecure by the continual monitoring of its status. All of the potential *states*
    of the system and the ways to transition from one state to another are defined
    and regulated, along with any other actions. This way, the current state of the
    system is able to be predicted and compared against.
  prefs: []
  type: TYPE_NORMAL
- en: 'A lot of these concepts are going to be a bit "wacky" to write out, and I think
    it might make more sense to use diagrams to help with conceptualizing their usefulness.
    Essentially, what a **state machine diagram** aims to do is to map out the various
    actions that can occur on a system, in order to prevent misuse:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – State machine model diagram'
  prefs: []
  type: TYPE_NORMAL
- en: '(source: https://commons.wikimedia.org/wiki/File:Finite_state_machine_example_with_comments.svg)](img/Figure_5.01_B16611.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.1 – State machine model diagram
  prefs: []
  type: TYPE_NORMAL
- en: '(source: [https://commons.wikimedia.org/wiki/File:Finite_state_machine_example_with_comments.svg](https://commons.wikimedia.org/wiki/File:Finite_state_machine_example_with_comments.svg))'
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we have a very simple system consisting of a single object,
    a door, that has two states, open and closed. The *transitions* that can occur
    are that a closed door can be opened and an opened door can be closed. These are
    triggered by the actions of *subjects*. Please, wake up, I can't have you fall
    asleep now; there are still three chapters after this one. Let's move on.
  prefs: []
  type: TYPE_NORMAL
- en: Information flow model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Similar to (and extending on from) the state machine model is the **information
    flow model**, consisting of **objects**, **state transitions**, and **flow policy
    states** (or **lattice states**). It aims to prevent any insecure or unauthorized
    communication, no matter the direction of the flow. This model lends to the **Biba**
    and **Bell-LaPadula** models, which will be covered later on in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Confidentiality models
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: From the information flow and state machine models, we can transition into models
    that are focused primarily on confidentiality. Governments categorize information
    to be able to streamline the process of managing access to it, such as *Top Secret*,
    *Secret*, *Confidential*, and *Sensitive but Unclassified*. Let's look at how
    the Bell-LaPadula model, the Take-Grant model, and the Brewer and Nash model can
    help an organization manage access to information.
  prefs: []
  type: TYPE_NORMAL
- en: Bell-LaPadula model
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By using **Mandatory Access Control** (**MAC**) to enforce a security policy
    across multiple levels, you enable the ability to manage access to information
    based on a subject's *need to know* and providing they meet or succeed the required
    clearance.
  prefs: []
  type: TYPE_NORMAL
- en: 'When considering the Bell-LaPadula model, you should keep in mind the following
    properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '**No read up**: Subjects aren''t able to read information at a higher confidentially
    level than they have clearance to. This is pretty self-explanatory. In order to
    keep things confidential, you prevent people who are below a certain "level" from
    being able to know what''s going on. It''s standard and is appropriately called
    the **simple security property**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**No write down**: Subjects aren''t able to produce or contribute information
    that is classified at a lower confidentially level than they have clearance for.
    This is to prevent information that is classified at a higher "level" from being
    "written down" to a lower confidentiality-level document, either explicitly or
    through inference.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**No read up/down and no write up/down**: Also known as the *strong star *
    property*, this essentially enforces that in order to read or write to an object,
    the subject''s clearance and the object''s confidentiality must be equal. This
    is a strengthened version of the Bell-LaPadula model, which prevents the write-up
    operation from occurring.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Take-Grant model
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **Take-Grant model**, dating back to 1976, is a way to represent a system
    in a directed graph of nodes and connections, rather than a matrix, with the aim
    to easily be able to determine the safety of the system, even if it's complex.
  prefs: []
  type: TYPE_NORMAL
- en: 'The basics are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Subjects* can have the standard *read and write access rights*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Subjects* can also have state transition rules associated with them, such
    as **take**, **grant**, **create**, and **remove**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A *subject* with the **take** right can take the rights of another *object*
    or *subject*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **grant** rule allows a *subject* to grant their own rights to another *object*
    or *subject*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **create** rule allows a subject to create new *objects*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **revoke** rule allows a subject to remove rights it has over another *object*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Take-Grant diagram representation example is shown as follows. Keep in mind
    that **D** is a **directory** and **F** is a **file**, both being **objects**.
  prefs: []
  type: TYPE_NORMAL
- en: '**P1** and **P2** are **subjects**.'
  prefs: []
  type: TYPE_NORMAL
- en: You might be able to decipher from the diagram that when a subject or an object
    has the **take** right for an object (or **t**), it can gain any rights the object
    has. If it has the **grant** right for an object (or **g**), it can pass any of
    its rights to that object.
  prefs: []
  type: TYPE_NORMAL
- en: 'See the following diagram for further investigation, which is exactly the point:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2 – A Take-Grant directed graph from https://commons.wikimedia.org/wiki/File:Take-grant_representation.svg'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.02_B16611.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.2 – A Take-Grant directed graph from https://commons.wikimedia.org/wiki/File:Take-grant_representation.svg
  prefs: []
  type: TYPE_NORMAL
- en: Now let's look at the Brewer and Nash model.
  prefs: []
  type: TYPE_NORMAL
- en: Brewer and Nash model
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **Brewer and Nash**, or **Chinese wall**, model is focused on segmentation.
    Essentially, we want to prevent *conflict of interest* by allowing access to the
    group of information that the user needs, but nothing more. The goal of this model
    is to ensure that no information is able to flow in a way that would allow a conflict
    of interest to arise.
  prefs: []
  type: TYPE_NORMAL
- en: It was initially created for the UK's finance sector and can be conceptualized
    by imagining a consultancy firm that provides services to several different companies.
    The employees at the consultancy firm who help with one client shouldn't have
    access to another client's information, as that could lead to issues around confidentiality.
  prefs: []
  type: TYPE_NORMAL
- en: Integrity models
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have covered integrity previously, so I'll spare us both from going into
    it again. Keep in mind that certain organizations might be more focused on integrity
    loss than confidentiality loss.
  prefs: []
  type: TYPE_NORMAL
- en: I'd like to go into the Biba and Clark-Wilson models, which address integrity.
  prefs: []
  type: TYPE_NORMAL
- en: Biba
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Biba, or rather **the Biba model**, is conversely an access control model that
    focuses on addressing the concerns of *integrity*.
  prefs: []
  type: TYPE_NORMAL
- en: '**The Biba model** was first published in 1977 and is another *lattice*-based
    model, like *Bell-LaPadula*. The defining properties of the Biba model for access
    control are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**No read down**: Subjects are not able to read objects at a lower classification
    than their clearance. The opposite of the Bell-LaPadula''s *no read up* principle,
    Biba''s *simple integrity property* ensures that subjects that are at a higher
    rank aren''t reading documents that may be "tainted" with misinformation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**No write up**: Subjects are not able to write to objects at a higher classification
    than their clearance. Also known as the *star * integrity property*, it prevents
    breaches to integrity in objects that shouldn''t be "tainted" by contributions
    from below a certain clearance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Invocation property**: This property aims to prevent a subject from invoking
    another subject who has higher clearance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you might have been able to tell, the Biba model doesn't address availability
    or confidentiality but focuses on integrity entirely.
  prefs: []
  type: TYPE_NORMAL
- en: Clark-Wilson
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Next, we can speak about the **Clark-Wilson model**, dating back to 1987\. Like
    most things from the 80s, it had commercial activities as the foundation of its
    creation. This model, like Biba, focuses on integrity.
  prefs: []
  type: TYPE_NORMAL
- en: The key takeaways from the Clark-Wilson access control model are the separation
    of duties principle and that data must be accessed through an application that
    allows logging, and the auditing of those logs is imperative.
  prefs: []
  type: TYPE_NORMAL
- en: '**Authorized users** aren''t able to change (or perform a **transformational
    procedure**, in this case) **constrained data items** in a way that is deemed
    inappropriate. The logged statuses for constrained data items are *tampered*,
    *logged*, and *consistent*.'
  prefs: []
  type: TYPE_NORMAL
- en: In Clark-Wilson, users only have access to the data at their clearance level,
    not higher or lower, meaning each clearance level has its own set of data entirely.
  prefs: []
  type: TYPE_NORMAL
- en: With that, to prevent this section from becoming overly long, I'd like to move
    on to briefly discuss how this applies to the real world.
  prefs: []
  type: TYPE_NORMAL
- en: Real-world access control models
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So, going back to our definitions from earlier, from a real-world perspective,
    what we''re saying is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Subjects* are entities that perform actions on the system. Some systems give
    *subjects* a **user ID**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Objects* are the resources on the system. The *subjects* are potentially accessing
    them, and therefore access to *objects* should be controlled.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Generally, we''re looking at two ways to handle access control: **capability-based
    models**, and **access control list (ACL)-based models**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In **capability-based models**, subjects that possess a **capability** to an
    object (similar to ownership) are the subjects that have access to an object.
    They can transfer that capability to another user.
  prefs: []
  type: TYPE_NORMAL
- en: In **ACL-based models**, subjects have access to an object if their ID is on
    a list of those with access to the object. If they don't, then "they're not on
    the list," and they get thrown into the street and a taxi splashes water all over
    their face and their cool red velvet suit is completely ruined.
  prefs: []
  type: TYPE_NORMAL
- en: Both model types have the ability to treat a **group of subjects** as a *subject*.
  prefs: []
  type: TYPE_NORMAL
- en: 'From there, let''s dig further and investigate the real-world access control
    models that we see regularly:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Identity-Based Access Control** (**IBAC**) is based on individuals and allows
    a more granular but more difficult-to-manage approach to access control.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lattice-Based Access Control** (**LBAC**) is a way of describing the rules
    for accessing an object or the rules for which objects a subject may access. For
    example, in a lattice approach, let''s suppose you create rules that state the
    following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '- If the *classification* of the *object* is less than or equal to the *clearance*
    of the *subject*, then they are allowed to read it.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- If the *classification* of the *object* is less than the *clearance* of the
    *subject*, then they aren''t able to write to it.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: That's *Bell-LaPadula* in practice. I knew it wouldn't be a complete and utter
    waste of time to describe those models earlier! No read up, no write down, BOOM!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Role-Based Access Control** (**RBAC**) is where we create clearance groups
    based on roles and put users into the various role groups. As a result, for access
    to *objects*, we eliminate the requirement for ad hoc decisions. If you have the
    role, you can access this *classification* of an *object*; if you don''t, you
    can''t.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rule-Based Access Control** (**RAC**) is associating rules with access, such
    as dictating that an *object* is only available from 09:00 to 17:00 on working
    days.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**MAC** is what we''ve been describing thus far, in the fact that we''re using
    the *classification* of the *objects* to determine access, rather than allowing
    users to determine who gets access to what.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Discretionary Access Control** (**DAC**) is where a data owner determines
    which subjects can access specific objects. SysAdmins create a directory structure
    that has various permissions, and the appropriate data is stored in the appropriate
    location.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Attribute-Based Access Control** (**ABAC**) is where access is given to *subjects*
    through policies that check *subject* and *object* attributes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Graph-Based Access Control** (**GBAC**) uses graphs and a query language
    to define access based on organizational diagrams, which sets it apart from RBAC,
    for example. Doesn''t this diagram remind you of Take-Grant directed graphs?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 5.3 – A GBAC organizational graph (source: https://commons.wikimedia.org/wiki/File:GBACOrgGraph.pdf)](img/Figure_5.03_B16611.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.3 – A GBAC organizational graph (source: https://commons.wikimedia.org/wiki/File:GBACOrgGraph.pdf)'
  prefs: []
  type: TYPE_NORMAL
- en: '**History-Based Access Control** (**HBAC**) is where access is determined after
    assessing the activities of the *subject*. This could include their behavior in
    the system, the amount of time between their requests for access, and the content
    of that request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**History of Presence-Based Access Control** (**HPBAC**) is an analytical approach
    to access control, taking into consideration the occasions for access. You might
    set a policy to state that users have access to an object if last week they have
    accessed the same object four or more times. It''s not a popular choice, I''ll
    be honest.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have those covered, let's delve further into the real world and
    talk about selecting and implementing authentication and authorization mechanisms.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting and implementing authentication and authorization mechanisms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Thankfully, we have actually covered some of the aspects of this topic previously.
    Just as a refresher, I think we should touch on authentication versus authorization
    before moving on to how we might select and implement the various IAM solutions
    to ensure we keep unauthorized users from gaining access to resources they shouldn't,
    and ensuring that the authorized users are able to access what they need to get
    on with their miserable lives.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication versus authorization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Authentication** is focused on the identity of the user, and ensuring they
    are *authentic*. Not in the way that they compliment you and actually mean it,
    but rather that they are who they say they are.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Authorization** is focused on what that user is allowed to do (or authorized
    to do) when they are *authenticated*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A user can be *authenticated*, and due to their role as a data analyst have
    *authorization* to access the records they are currently working on. They might
    not have *authorization* for the new quantum levitation device that the company
    is currently prototyping in order to build the skateboard from Back to the Future:
    Part II, because the company is focused on confidentiality.'
  prefs: []
  type: TYPE_NORMAL
- en: We are able to associate authorization clearances with the sensitivity labels
    or classification of the organization's data, which we have previously mentioned.
  prefs: []
  type: TYPE_NORMAL
- en: 'Authorization could be conceptualized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"If a document has this classification, then users with these clearances are
    authorized to read, but not write or delete".*'
  prefs: []
  type: TYPE_NORMAL
- en: Of course, these decisions are based on your organization's policies and vary
    heavily based on risk and requirements.
  prefs: []
  type: TYPE_NORMAL
- en: How is it possible to confirm the identity of the user? Where do we store these
    properties and how are we able to automate the process using computer systems?
    Those two questions lead into the next section beautifully.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication and security
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A crucial aspect of information security is **authentication**. It's at the
    center of many things we've covered thus far in this book. We want to allow known
    people to work on what they need to work on (but nothing more) without a hitch,
    but at the same time, we want to prevent unknown people from accessing anything
    they shouldn't.
  prefs: []
  type: TYPE_NORMAL
- en: There are many ways to tackle this issue, and for many solutions, the goal can
    be the same but apply to different components inside the network architecture
    or system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at a few examples. We can, for example, authenticate a user
    through the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Password authentication**, an example of "*something you know*."'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Smart card authentication**, an example of "*something you have*."'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Biometric authentication**, also known as "*something you are*," an example
    being **fingerprint scanning**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A combination of any of the preceding (or other) methods, known as **multi-factor
    authentication** (**MFA**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When it comes to MFA, we need to remember that entering a password and then
    "the name of your first dog" is not an example of *MFA*. Those are two things
    that you know. It might strengthen the authentication process, but it's not truly
    MFA.
  prefs: []
  type: TYPE_NORMAL
- en: Password authentication
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The advantages of **password authentication** are pretty obvious: We have trained
    people around the world to know how to authenticate themselves using passwords.
    It''s easy for users (unless they''re my mother-in-law). If they forget their
    password (like my mother-in-law does), then they can reset it simply by having
    access to their email account (which my mother-in-law has forgotten the password
    of).'
  prefs: []
  type: TYPE_NORMAL
- en: Generally, this password is stored as a **salted hash**, and a service such
    as **Microsoft Active Directory** handles the secure storage of these credentials.
  prefs: []
  type: TYPE_NORMAL
- en: Passwords on their own need to be difficult to guess, and the number of attempts
    at guessing a password should be *rate-limited* or blocked, to prevent **dictionary
    attacks** or **brute-force attacks**.
  prefs: []
  type: TYPE_NORMAL
- en: Another mitigation against these attacks are **password complexity requirements**,
    where a password should not contain dictionary words, must have a certain number
    of characters, and must be a mix of letters, numbers, and symbols. Additionally,
    reusing the same password in multiple places allows for a breach in one service
    leading to account compromise elsewhere… but now we're canceling out the upside
    of passwords because they're supposed to be easy. **Password managers** give us
    a technological solution to this issue by automating the creation and utilization
    of complex passwords, provided a "master password" is entered, generally with
    MFA enabled.
  prefs: []
  type: TYPE_NORMAL
- en: Smart card authentication
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By using a smart card, you're utilizing the "something you have" factor of authentication.
    The card has a chip that stores keys to identify a person and verify this information
    to the authentication process.
  prefs: []
  type: TYPE_NORMAL
- en: Generally, these cards also require the use of a PIN for access to be granted,
    which provides the second factor of "something you know." It's a bit like the
    way we used to use ATMs to take cash out, back when cash was a thing. Generally,
    the PIN is a very weak password, but the number of attempts is limited to prevent
    attacks surrounding complexity. The PIN requirement also prevents somebody from
    just *finding* a smart card and being granted access to your system.
  prefs: []
  type: TYPE_NORMAL
- en: Biometric authentication
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another form of *authentication* is through **biometrics**. Scanning your retina,
    listening to the sound of your voice, reading your fingerprint or palm veins,
    or dripping your blood into a witch's copper bowl, these sorts of things.
  prefs: []
  type: TYPE_NORMAL
- en: The advantages of biometrics are that there aren't any passwords to remember;
    you can't forget your fingerprint at home, and the likelihood of somebody having
    the same biometrics as another person is very slim – unless you are using something
    like Face ID on your iPhone, which occasionally doesn't work when it is actually
    you attempting to unlock your phone (**false negative**), or it works to unlock
    the screen of a similar-looking person (**false positive**).
  prefs: []
  type: TYPE_NORMAL
- en: 'The negatives of biometrics are also obvious:'
  prefs: []
  type: TYPE_NORMAL
- en: You can't change your fingerprint.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If somebody needs your fingerprint, they might just chop off your finger (in
    this situation, you can only hope it's for a fingerprint biometric).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They cost way more to implement than passwords do. Before phones came out, nobody
    had a fingerprint scanner in their home.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Single sign-on
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Furthermore, entering in passwords is a bit of an annoying experience, especially
    if you're following best practices and using different passwords for each service,
    but not using a password manager.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of prompting the user to enter in a password each time they try to use
    a different service, there are solutions that allow for a more unified approach
    to authentication, such as **single sign-on**, or **SSO**, where a user is prompted
    to prove their identity once, and then give access to all of the resources they
    need. This usually requires a bit of configuration but can lead to reduced risk
    from password reuse and easier revocation of privileges, among other things.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication protocols
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Thankfully, authentication in the digital estate has become somewhat standardized
    through a few different protocols. Over time, these protocols have been improved
    from a security perspective, and their compatibility has expanded to include more
    use cases.
  prefs: []
  type: TYPE_NORMAL
- en: As a result, it's worth going into the most common authentication methods and
    protocols that are utilized by organizations around the world currently, such
    as **NTLM**, **Kerberos**, and **PKI**.
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft NTLM (NT LAN Manager)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**NTLM**, or **NT LAN Manager**, is a revisioning of how authenticating in
    Windows works and an upgrade from LM, or LAN Manager, which merely passed the
    (weakly hashed) password over the network to the domain controller, which stores
    the authentication information for each user. With NTLM, now the hashed password
    is never actually sent over the network, but rather a message that has been encrypted
    with a hash of the password as the key.'
  prefs: []
  type: TYPE_NORMAL
- en: It is considered an outdated authentication protocol, but it is still widespread
    in IT systems because of its deep connection with **Windows**, **Exchange**, **Active
    Directory**, and **Windows Server** systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a diagram of how NTLM works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.4 – NTLM authentication diagram'
  prefs: []
  type: TYPE_NORMAL
- en: '(source: https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-apds/5bfd942e-7da5-494d-a640-f269a0e3cc5d)](img/Figure_5.04_B16611.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.4 – NTLM authentication diagram
  prefs: []
  type: TYPE_NORMAL
- en: '(source: [https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-apds/5bfd942e-7da5-494d-a640-f269a0e3cc5d](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-apds/5bfd942e-7da5-494d-a640-f269a0e3cc5d))'
  prefs: []
  type: TYPE_NORMAL
- en: 'To summarize, here are the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: A user signs in to the **client** PC, which sends a message to the **server**
    requesting authentication.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **server** responds to the **client** with a challenge message as a response.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **client** encrypts their password with a 56-bit segment of an MD4 hash
    of their password, encrypts the server's challenge with it, and sends it back
    to the **server** as a response. This is part of the weakness of the protocol.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **server** passes the response through to the **domain controller**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **domain controller** checks its records for a match and notifies the server
    whether the user can be authenticated or not.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Because of flaws in the logic of NTLM, various issues have cropped up. For example,
    by relaying the NTLM `AUTHENTICATE_MESSAGE` to a rogue server with a dictionary,
    a **rainbow table** (pre-computed hashes of the most popular passwords), or the
    *hashcat* tool, they are able to quickly solve for username/password combinations.
    Currently, a modern GPU like the GTX 1060 is able to solve the NTLM for seven-character
    passwords in 1 second.
  prefs: []
  type: TYPE_NORMAL
- en: Even worse, malicious actors are able to simply sniff the network for the NTLM
    hash from another client, and then **pass-the-hash** and authenticate as that
    user, because the *hash* is **password-equivalent** thanks to a lack of *salting*.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, **Remote Code Execution** (**RCE**) is possible on machines that
    have NTLM enabled and access to administrative accounts on Exchange and Active
    Directory servers.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, NTLM authentication is still used for local log-on authentication,
    and for any system that is part of a **workgroup**. Many applications use NTLM
    for authentication instead of the more recent **Kerberos** protocol (it's been
    20 years, people! COME ON ALREADY!).
  prefs: []
  type: TYPE_NORMAL
- en: If you find yourself with the requirement to keep NTLM enabled on machines and
    servers at your organization, there are a few mitigating steps you can take, but
    keep in mind that your team will be busy each time a new flaw is found, which
    is quite often.
  prefs: []
  type: TYPE_NORMAL
- en: You can enforce **SMB signing** to prevent **NTLM relay attacks**.
  prefs: []
  type: TYPE_NORMAL
- en: You can block the older version of **NTLMv1**, which is beyond saving.
  prefs: []
  type: TYPE_NORMAL
- en: You can enforce **LDAP/S signing** and **channel binding** to prevent **LDAP
    relay attacks**.
  prefs: []
  type: TYPE_NORMAL
- en: You can only accept requests with **Enhanced Protection for Authentication**
    (**EPA**) to prevent **NTLM relay attacks** on web servers.
  prefs: []
  type: TYPE_NORMAL
- en: Kerberos
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To remedy many of these flaws from **NTLM**, **Kerberos** was introduced into
    **Windows 2000** onward for authentication. The three parts we'll include in this
    overview of Kerberos are the **client** (the user's PC, generally), the **server**,
    and the **Key Distribution Center** (**KDC**).
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we get into the process, let''s have a look at the diagram here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.5 – A diagram of Kerberos authentication'
  prefs: []
  type: TYPE_NORMAL
- en: '(source: https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-kile/b4af186e-b2ff-43f9-b18e-eedb366abf13
    )](img/Figure_5.06_B16611.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.5 – A diagram of Kerberos authentication
  prefs: []
  type: TYPE_NORMAL
- en: '(source: [https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-kile/b4af186e-b2ff-43f9-b18e-eedb366abf13](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-kile/b4af186e-b2ff-43f9-b18e-eedb366abf13)
    )'
  prefs: []
  type: TYPE_NORMAL
- en: So, one of the first things we can see from this diagram is that the KDC is
    completely separate from the server, and there's no pass-through authentication
    happening as there was with NTLM.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s discuss what is occurring and how it''s a secure method of authentication:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Kerberos Authentication Service exchange**: The **client** sends a request
    to the **KDC** for a **ticket-granting ticket** (yes, that''s an incredibly awful
    name, let''s instead call it the **TGT**). The client presents its principal name
    and can present pre-authentication information. This is represented on the diagram
    by **(1) KRB_AS_REQ**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **KDC** returns a **TGT** and a **session key** that the client can use
    to encrypt and authenticate communication with the **KDC** for **Ticket-Granting
    Service** (**TGS**) requests, without reusing the persistent key. This is represented
    on the diagram by **(2) KRB_AS_REP**.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Kerberos TGS exchange**: The **client** then sends a request to the **KDC**
    for a **ticket** for the server. The client presents the **TGT**, a **Kerberos
    authenticator**, and the **Service Principal Name** (**SPN**), which is the name
    the client uses to identify a service for authentication purposes. A **Kerberos
    authenticator** is the client ID and a timestamp, encrypted with the **session
    key**, and helps the server detect **replay attacks** by proving that the **authenticator**
    is recently constructed. This is represented on the diagram by **(3) KRB_TGS_REQ**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **KDC** validates the **TGT** and the **authenticator**. If these are valid,
    the **KDC** returns a **service ticket** encrypted with the **server**'s **long-term
    key** (which is already stored in the **KDC**) and a session key, which the client
    can use to encrypt communication with the **server**. This is represented on the
    diagram by **(4) KRB_TGS_REP**.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Kerberos client/server authentication protocol exchange**: From there, the
    **client** is able to request access to the **server** by providing the **service
    ticket** and a newly generated **authenticator**. The **server** then takes the
    **service ticket** and decrypts it with its long-term key, checks the **authenticator**
    is valid, and then uses the authorization data to dictate access control for the
    **client**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To ensure the **server** is genuine, the client is optionally able to request
    verification by having the **server** send the **client's timestamp** extracted
    from the **authenticator** (which was previously encrypted with the session key).
    By returning the timestamp, the **client** has proof that the **server** can decrypt
    the **authenticator**. Otherwise, the server could be just gathering information
    without sending anything back, leaving the client in the dark.
  prefs: []
  type: TYPE_NORMAL
- en: PKI and digital certificates
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A crucial part of **Public Key Infrastructure** (**PKI**) is **digital certificates**
    (or **public key certificates**), which prove the ownership of a *key*, which
    is tied to identity –of either a user or a device.
  prefs: []
  type: TYPE_NORMAL
- en: Certificate services are used in the **TLS protocol** (which protects data-in-transport
    on the web), as well as in email encryption schemes such as **S/MIME** and digital
    signature solutions. The advantage of **public key cryptography** (or **asymmetric
    cryptography**) is that, depending on which of your two keys you use to encrypt
    a message, you're able to ensure integrity, non-repudiation, and confidentiality.
  prefs: []
  type: TYPE_NORMAL
- en: One of the most popular standard formats for *public key certificates* is called
    **X.509**, which is split into several different parts because of the wide range
    of use cases for this service. Essentially, this certificate sits on a device
    and silently provides authentication to servers behind the scenes.
  prefs: []
  type: TYPE_NORMAL
- en: One major advantage of using an **X.509 certificate** is that we lose the requirement
    for a username and password combination, which we've talked about the weaknesses
    of previously. Using a *digital certificate* would ideally be done in combination
    with another factor of authentication, such as a PIN or an **MFA app** on the
    user's mobile phone that requires a fingerprint.
  prefs: []
  type: TYPE_NORMAL
- en: By acting as a **Certificate Authority** (**CA**) in your organization's PKI,
    your *systems administrator* is able to distribute and revoke digital certificates
    at scale and utilize those certificates to meet the organization's **access control
    policies**. This is compatible with existing systems such as Active Directory
    or LDAP and provides a much more streamlined way of managing authentication in
    an organization.
  prefs: []
  type: TYPE_NORMAL
- en: From here, let's move on to **authorization**.
  prefs: []
  type: TYPE_NORMAL
- en: Authorization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Often paired together with **authentication**, **authorization** is the level
    of access that is given to a **client** or **subject** after authentication. Authorization
    isn't always required to access a resource, for example, searching on Google.
    You don't need to authenticate in order to perform a search on Google (although
    you can), and anybody that can visit [google.com](http://google.com) in their
    browser has the authorization to use that resource.
  prefs: []
  type: TYPE_NORMAL
- en: However, in order to access your Facebook messages, or to be able to change
    your profile picture, you need to *authenticate*, and then you have *authorization*
    to create, read, update, and delete content that you have ownership of.
  prefs: []
  type: TYPE_NORMAL
- en: Essentially, computer systems allow a *programmatic decision-making process*
    to be implemented, which *provides authorization* based on information derived
    from a combination of the *authentication* process along with the *defined requirements
    for security and privacy*.
  prefs: []
  type: TYPE_NORMAL
- en: Focusing on *authorization* at your organization is a crucial step in ensuring
    the appropriate access is given to the appropriate people, and nothing more. Yes,
    we're talking about *least-privilege* again, and there's a reason for it. Least-privilege
    is a huge part of ensuring your organization is secure, and although sometimes
    implementing the principle of least-privilege seems like a lot of work, the benefits
    are generally able to recoup that cost very quickly.
  prefs: []
  type: TYPE_NORMAL
- en: We spoke about real-world access control models earlier. Leveraging them is
    a best practice in order to ensure you don't run into (or completely miss) the
    issues often seen in security breaches. Utilizing either **MAC**, **DAC**, **RBAC**,
    or **ABAC**, or a combination of those examples, is standard and seen often in
    information systems.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, you might combine an ACL with RBAC to create a set of rules for
    each role in your organization, allowing access to view the resources associated
    with their role, and potentially allowing editing, updating, or deleting those
    resources, as required.
  prefs: []
  type: TYPE_NORMAL
- en: The best practice for managing these principles and ensuring your organization's
    users have the access they need, no more and no less, is to utilize an IAM tool
    suite. We are going to dive deeper into how to leverage those systems now.
  prefs: []
  type: TYPE_NORMAL
- en: Identity and access management (IAM)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we're looking into how we can possibly manage all of the authentication
    and authorization principles that we've gone into so far in this chapter, we can
    simplify the process by leveraging what are known as IAM tools. These tools help
    organizations give the right access to the right resources at the right time and
    generally help with maintenance by giving each user a single identity that is
    then maintained and monitored throughout their time at the organization. This
    could include employees, customers, or third parties. If a user changes roles
    or leaves, that is reflected in their access through the *IAM*.
  prefs: []
  type: TYPE_NORMAL
- en: A *centrally managed identity repository system* for managing identity and regulating
    access leads to greater agility, better security, and higher levels of productivity,
    but requires technically experienced people to manage their administration. Furthermore,
    policies and procedures surrounding the regular administration and auditing of
    such systems are crucial to avoiding downtime and ensuring that security violations
    don't go unnoticed.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that when we're looking at compliance requirements of the likes
    of **HIPAA**, **SOX**, or **GDPR**, or almost any other regulation or standard
    for information security or privacy, we'll see a requirement for *controlling
    access* to employee and customer information. IAM tools provide a powerful solution
    to ensure your organization is complying with those requirements.
  prefs: []
  type: TYPE_NORMAL
- en: These systems are generally compatible with the previously mentioned protocols
    and processes, such as PKI, Kerberos, SSO, and password authentication, and allow
    for various implementation models, enabling users to work from home, authenticate
    to *SaaS* solutions from their mobile devices, and other non-traditional methods
    of working.
  prefs: []
  type: TYPE_NORMAL
- en: It would be pointless to discuss managing identity at an enterprise level and
    not mention **directories**, such as **Microsoft Active Directory**. Directories
    are different from IAM tools but are a crucial part of their functioning. IAM
    tools manage information coming from multiple sources, such as HR tools or Active
    Directory, for example.
  prefs: []
  type: TYPE_NORMAL
- en: Essentially, what we want from an IAM system is to automate the business processes
    surrounding the managing of these tools in your organization. Somebody new joins
    the company and a software solution for HR triggers the creation of a new user
    in the directory, which then triggers other actions based on what they might need
    on their first day.
  prefs: []
  type: TYPE_NORMAL
- en: '**Third-party identity services**, including **Identity-as-a-Service** (**IDaaS**)
    cloud subscriptions, are increasingly popular and aim to reduce overhead and improve
    connectivity in this regard.'
  prefs: []
  type: TYPE_NORMAL
- en: With the automation available to reduce manual IT management tasks, a few things
    are required in order to properly utilize these services. Let's take a look at
    a few.
  prefs: []
  type: TYPE_NORMAL
- en: Leveraging identity services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To begin with, *your organizational* *policies and procedures must be in place*.
    That's what I always say, and I always say it because it's always true. How could
    you possibly manage something as complex as the access control for your organization
    without writing down the rules?
  prefs: []
  type: TYPE_NORMAL
- en: 'These policies and procedures will aim to answer the following questions:'
  prefs: []
  type: TYPE_NORMAL
- en: How is your organization going to handle access control? Is the focus on a *role-based
    approach*? Are we looking at *MAC* instead?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How are *new employees provisioned*? With each new employee, how do we define
    their access? What occurs to ensure they are able to access everything from their
    first day at work?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which roles or employees have which level of authorization? This is likely to
    be connected to your approach and whether it's *RBAC*, *MAC*, *DAC*, and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When an employee *leaves the organization*, what is required to ensure they
    don't have access anymore?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a user requires an *exception* to the rules, how is that escalated, approved,
    and administrated?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When is access reviewed? How do we ensure the access to resources isn't growing
    with each role change for a user at your company?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How far can automation go? Can we automate *password resets*? What about the
    revocation of privileges based on changes perceived in HR systems? For example,
    say a user hands in their resignation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If an external consultant joins the company or a third-party needs temporary
    access, how is that handled? Is *federated identity management* employed?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which services are covered by *SSO*?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do you teach new users how to use these systems? Is there a printed handout?
    A web portal? Is there a person at the company who sits with them? Create a normal
    starting procedure and try to walk through the steps of what life is like for
    a new starter, in order to test your plan.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have covered the concepts of IAM, I would like to move on to controlling
    physical access as part of our access control chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling physical access to assets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we're looking at access control in information security, sometimes we neglect
    the physical aspect in favor of the digital one. *Physical access to hard drives,
    machines, folders, or printed documents* has the potential to be highly valuable
    to a malicious actor and should be controlled. In this section, I will briefly
    discuss various concepts of **physical security** to consider.
  prefs: []
  type: TYPE_NORMAL
- en: Physical access control
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If we''re looking at restricting access or entrance to a building or room and
    only allowing authorized individuals to enter the restricted area, we might look
    at a few solutions:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Human access control**, such as *guards*, *receptionists*, or *ticket-checkers*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mechanical access control**, such as *locks* and *keys*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Technological access control**, such as *mantraps*, *turnstiles*, *fingerprint
    or retina scanners*, *fob-based access control*, or *exit barriers*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fences or perimeter barriers** may prevent individuals from being able to
    avoid the *access controls*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Access control systems can help manage and monitor the access to areas and log
    who, when, and where the access was attempted, and whether it was accepted or
    not.
  prefs: []
  type: TYPE_NORMAL
- en: Physical locks and keys don't provide the ability to restrict access based on
    time or provide any records of entry. Additionally, there's little in the way
    of proving the keyholder is the individual who is supposed to have the key.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, it's difficult to revoke access in the event of a lost or stolen
    key, and it's impossible to know whether a key has been duplicated in secret.
  prefs: []
  type: TYPE_NORMAL
- en: In walks **electronic access control**, and just in time.
  prefs: []
  type: TYPE_NORMAL
- en: Electronic access control
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The advantage of **electronic access control**, or **EAC**, is that we can solve
    some of the previously listed shortcomings of the lock and key combination… or
    the combination lock, for that matter.
  prefs: []
  type: TYPE_NORMAL
- en: 'With computers, we can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Better restrict access by time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Log entry attempts and successes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easily revoke access on a granular level, rather than having to replace the
    entire lock
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gain other information to prove the individual has authorization rather than
    just the key
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'On the topic of gaining other information, that''s when we can get into MFA,
    asking the user for two or more of the following factors of information for authentication:'
  prefs: []
  type: TYPE_NORMAL
- en: Something they know, which could be a password or PIN
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Something they have, which could be a key fob or smart card
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Something they are, which could be a retina or fingerprint scan
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a user is digitally accessing something, rather than physically, we might
    add one other "factor" type or "*somewhere they are*," which is a GPS location
    that proves the user is in a place deemed to prove their identity. For obvious
    reasons, that doesn't work for physical security access controls.
  prefs: []
  type: TYPE_NORMAL
- en: Preventing exploitation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When it comes to physical security, we could be looking at various risks, such
    as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Tailgating, when an unauthorized person follows an authorized one into a restricted
    area, sometimes being let in through politeness of holding a door open. This can
    be mitigated with mantraps and turnstiles.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Destruction, such as crashing a car through a wall in order to gain access,
    or prying a door open with a prybar. Detection of this activity and defense-in-depth
    mitigations such as bollards or steel bars may be required for the risk of this
    to be reduced to an acceptable level.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technological attacks, such as cloning smart cards or brute-forcing pins, which
    can be mitigated through MFA, rate-limiting, and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Among other things, it's worth considering the risks surrounding your physical
    access control and adding them to your risk register.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Holy cannoli! We managed to cover so much in this chapter; it's really worth
    patting yourself on the back.
  prefs: []
  type: TYPE_NORMAL
- en: We reviewed many of the various access control models and concepts, including
    classics such as *Bell-LaPadula* and *Biba*. Then, after those concepts were established,
    we looked at real-world examples, including *RBAC* and *DAC* models, and what
    those actually mean.
  prefs: []
  type: TYPE_NORMAL
- en: We then proceeded on to the topic of how we might select and implement authentication
    and authorization mechanisms for people, devices, and services. We covered the
    difference between *authentication* and *authorization*, and how they work together
    to provide *access control* for security and privacy purposes. We covered *passwords*,
    *smart cards*, and *biometrics*, as well as some of the most-used protocols for
    *authentication*.
  prefs: []
  type: TYPE_NORMAL
- en: Then we dove into what *IAM* is, and how you might utilize *identity services*
    at your organization to scale up and ensure your IT team isn't overwhelmed with
    menial access management tasks.
  prefs: []
  type: TYPE_NORMAL
- en: We dipped our toe into how to control *physical access to assets* as well, which
    is often overlooked in this topic.
  prefs: []
  type: TYPE_NORMAL
- en: 'With all of these topics covered, it looks to me as though you are better acquainted
    with the ideas that can help you to answer the questions we asked at the start
    of the chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: How can you ensure an entity is actually the approved user they claim to be?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How is it that we can enforce those rules in an automated way in our digital
    environment?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do you ensure the right number of permissions to enable productivity?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since we've covered those points, I'd say we've reached a major milestone in
    this book! We have covered enough information security topics to finally get into
    the topic of [*Chapter 6*](B16611_06_Final_JM_ePub.xhtml#_idTextAnchor112), *Designing
    and Managing Security Testing Processes*. Without further ado, let's get started!
  prefs: []
  type: TYPE_NORMAL
