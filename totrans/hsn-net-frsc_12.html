<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">WLAN Forensics</h1>
                </header>
            
            <article>
                
<p>The use of wireless LAN has become an integral part of our lives. Our reliance on it means that it's all too common for criminals to use it to break into your Wi-Fi and steal all your data, see your day-to-day activities through your web camera, or reach a critical data server, in the case of a corporate environment. The possibilities of what a cyber criminal can do once they are in your network (or have forced you into their network) are endless.</p>
<p>Over the course of this chapter, we will learn how to identify rogue access points, which can allow an attacker to view all of your communication. We will also look at strategies to identify and physically find these rogue devices. We will also look at some of the attack patterns that an attacker can follow when conducting advanced attacks. We will also look at what to do when a criminal falsifies their MAC address, one of the most important criminal techniques that is used while committing a crime on Wi-Fi. Before we move ahead with the exercises in the chapter, let's learn a bit about the wireless 802.11 standard, and the type of packets that will help us during the wireless forensic exercise.</p>
<p>We will cover the following topics in the chapter:</p>
<ul>
<li>The 802.11 standard</li>
<li>Packet types and subtypes</li>
<li>Locating wireless devices</li>
<li>Identifying rogue access points</li>
<li>Identifying attacks</li>
<li>Case study—identifying the attacker</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>To follow the exercises covered in this chapter, we will require the following:</p>
<ul>
<li>Wireshark v3.0.0 (<a href="https://www.wireshark.org/download.html">https://www.wireshark.org/download.html</a>) installed on Windows 10 OS/ Ubuntu 14.04.</li>
<li>You can download the codes and PCAP files used in this chapter from <a href="https://github.com/nipunjaswal/networkforensics/tree/master/Ch9">https://github.com/nipunjaswal/networkforensics/tree/master/Ch9</a>.</li>
<li>VMWare Player/VirtualBox installation with Kali Operating system installed. You can download it from <a href="https://www.offensive-security.com/kali-linux-vm-vmware-virtualbox-image-download/">https://www.offensive-security.com/kali-linux-vm-vmware-virtualbox-image-download/</a>.</li>
<li>Aircrack-ng suite (already a part of Kali Linux).</li>
<li>An external wireless card (TP-Link WN722N/Alfa card).</li>
<li>Python (already installed on Kali Linux).</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The 802.11 standard</h1>
                </header>
            
            <article>
                
<p>The 802.11 standards denote the family of specifications defined by the IEEE for wireless local area networks. The 802.11 standard describes an over-the-air interface between a client and a base station or between any two wireless clients. There are several standards in the 802.11 family, as shown in the following list:</p>
<ul>
<li><strong>802.11</strong>: 802.11 uses a 1-2 Mbps transmission rate using either <strong>frequency-hopping spread spectrum </strong>(<strong>FHSS</strong>) or <strong>direct-sequence spread spectrum </strong>(<strong>DSSS</strong>).</li>
<li><strong>802.11a</strong>: The speed is increased from 1-2 Mbps to 54 Mbps in the 5 GHz band. Instead of using FHSS or DSSS, it uses an orthogonal frequency division multiplexing (OFDM) encoding.</li>
<li><strong>802.11b</strong>: This has an 11 Mbps transmission in the 2.4 GHz band and uses only DSSS.</li>
<li><strong>802.11g</strong>: This has an increased speed of up to 54 Mbps in the 2.4 GHz band.</li>
<li><strong>802.11n</strong>: The <em>n</em> standard adds <strong>multiple-input multiple-output</strong> (<strong>MIMO</strong>). The speeds are over 100 Mbit/s.</li>
<li><strong>802.11ac</strong>: This has a speed of 433 Mbps to 1.3 Gbps and operates only in the 5 GHz band. Hence, its important to have the right Wi-Fi adapter to capture traffic on both 2.4 GHz and 5 GHz bands</li>
</ul>
<p> Having a working knowledge of the wireless standards, let's look at the type of evidence we can have in the wireless forensics scenario in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Wireless evidence types</h1>
                </header>
            
            <article>
                
<p>The evidence from a wireless investigation would come in a PCAP file or logs from the wireless access points. However, in the case of a live environment, you can set up captures using the <strong>aircrack-ng</strong> suite. The aircrack-ng suite we used in the previous chapters allows us to put our wireless network card in a promiscuous mode where we can capture the activity that occurs in the wireless network.</p>
<p>Let's see how we can do this by going through the following steps. We will be using a Windows 10 host laptop with Kali Linux installed in VMware Workstation:</p>
<ol>
<li>First, we will connect our external Wi-Fi card, which is a TP-Link TL-WN722M 150 Mbps high gain external USB adapter. On connecting it to the laptop, we will get the following message:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/54a0f95f-e62a-4bee-a888-0e47d4adb8cd.png" style="width:25.33em;height:20.33em;"/></div>
<ol start="2">
<li><span class="packt_screen"><span><span>Click </span></span>OK</span> and open a terminal on the Kali Linux machine as follows:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/ffb6fab8-dc34-4537-b07a-d1469dc58db1.png" style="width:33.33em;height:12.08em;"/></div>
<ol start="3">
<li>Upon running the <kbd>iwconfig</kbd> command, we can see that the wireless interface is available.</li>
<li>Next, we need to put this into monitor mode. We can use the <kbd>airmon-ng</kbd> tool to put the wireless interface in monitor mode by issuing <kbd>airmon-ng start wlan0</kbd> command, as shown in the following screenshot:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/b08e77ae-de3f-45a7-a741-fe3f5355de6c.png" style="width:37.00em;height:15.33em;"/></div>
<ol start="5">
<li>By providing the command <kbd>airmon-ng</kbd> followed by <kbd>start</kbd> and the identifier for our wireless interface, airmon-ng creates an additional virtual interface for us called <kbd>wlan0mon</kbd>. Let's verify this by again typing the <kbd>iwconfig</kbd> command as follows:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/5120b3f3-b643-422f-b75e-a97ce3f67244.png" style="width:31.08em;height:10.08em;"/></div>
<p>We can see that the interface has been created and is in <kbd>Monitor</kbd> mode.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using airodump-ng to tap the air</h1>
                </header>
            
            <article>
                
<p>Let's investigate by using another utility from the aircrack suite, <kbd>airodump-ng</kbd>, as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/a8e2f69f-9913-45eb-8f65-29e32b97cd1a.png" style="width:47.92em;height:35.33em;"/></div>
<p>By providing the <kbd>airodump-ng wlan0mon</kbd> command, starts sniffing the wireless networks around us while continually hopping to different channels. This will give us a list containing the numerous wireless networks that are available in the vicinity. The list in the upper half of the screen displays wireless access points that have a BSSID (MAC address of the access point) and an ESSID (name of the network) and many other details. The bottom half of the screenshot contains the stations which are nothing but the endpoint devices.</p>
<p>We can also see that the preceding list contains <kbd>CH</kbd>, which is the channel number on which the access point is operating. The channels are nothing but frequencies, with channel 1 being 2,412 MHz and channel 14 being 2,484 MHz. The channels are separated by a 5 MHz gap, which means that if channel 1 is 2,412 MHz, then channel 2 is 2,417 MHz, channel 3 is 2,422 MHz, and so on.</p>
<p>Additionally, we have a <kbd>PWR</kbd> field that denotes the power. A lower power value means that the access point is far from our wireless interface. We can see that the wireless network <kbd>VIP3R</kbd> has <kbd>-51</kbd> <kbd>PWR</kbd>, which means that it's quite near to us, while the access point <kbd>dlink-DAD9_EXT</kbd> is very far from us, with the least power. The power value is very important when physically locating the device in a building or a floor.</p>
<p>Moreover, we can see the type of encryption used, the cipher, the authentication type, and much more in the preceding list. In the lower pane, we can see the devices that are connected to the listed Wi-Fi access points.</p>
<p>Let's capture all the details from a single wireless network VIP3R by using the following command:</p>
<pre><strong>airodump-ng wlan0mon --bssid 78:44:76:E7:B0:58 -c 11 -w viper</strong>
  </pre>
<p>In the preceding command, we used the <kbd>-bssid</kbd> switch to filter the packets originating only from the <kbd>78:44:76:E7:B0:58</kbd> (VIP3R) access point while only capturing from channel 11 by using the <kbd>-c 11</kbd> switch. We have also chosen to write all the output to a file named <kbd>viper</kbd> by using the <kbd>-w</kbd> switch. The preceding command would yield the following details:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/63df6c4a-a7bf-4351-8cba-955ca44ef274.png" style="width:38.42em;height:12.00em;"/></div>
<p>We can see that by running the command, we obtain the details listed in the preceding screenshot. We can see three stations connected to the access point, and, along with that, we have a <strong>WPA handshake</strong> as well. A WPA handshake means that someone tried to authenticate with the wireless network. If there is an increase in the number of stations after a WPA handshake, then this would typically mean that the authentication was successful; if there is no increase, then it was not successful. Again, finding stations can be done through the PWR signal as well. Generally, attackers capture this WPA handshake through two different means:</p>
<ul>
<li>Listening when someone tries to authenticate</li>
<li>Intentionally forcing away stations connected to the access point and allowing them to reconnect</li>
</ul>
<p>Attackers will brute-force the handshake to find the network password and gain access to the network. We saw that we captured the handshake using <kbd>airodump-ng</kbd> as soon as we stop the capturing, <kbd>airodump-ng</kbd> will create capture file along with some others as shown through the <kbd>ls -la</kbd> command in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/e740d402-b3f0-49f3-96e2-e57f58a24fe1.png" style="width:31.92em;height:7.08em;"/></div>
<p>Let's open the capture (<kbd>.cap</kbd>) file in Wireshark by issuing <kbd>wireshark viper-01.cap &amp;</kbd> command and selecting WLAN traffic from the <strong>Wireless</strong> tab:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/41e9eda8-2c8b-4510-9a6f-ec360e52a7bc.png"/></div>
<p>We will be shown the statistics of the wireless traffic, as shown in the preceding screenshot. Additionally, airodump captures other networks as well. Let's put a filter on the MAC address of our wireless access point, as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/63a03ebb-3061-46e2-941a-de8e4448b7a9.png"/></div>
<p>Well, we can see that using <kbd>wlan.addr</kbd> followed by the MAC/ BSSID of the access point filters all the packets for the <span><strong>access point</strong></span> (<strong><span>AP</span></strong>) of interest. We can see that one of the client starting with the MAC address <kbd>2c:33:61:xx:xx:xx</kbd> is from an Apple device. Additionally, all the base stations and MAC addresses can be resolved for the type using the <span class="packt_screen">Resolved Addresses</span> option from Wireshark, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/3e312c46-a54a-40c1-90cd-394dde3388bd.png" style="width:26.08em;height:30.75em;"/></p>
<p>We can see that we are not able to get precise statistics on how many stations our AP is talking to from Wireshark. Let's use <kbd>tshark -r viper-01.cap -2 -R wlan.da==78:44:76:e7:b0:54 -T fields -e wlan.sa | sort | uniq</kbd> to help us out, as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/f6ed0bb4-10cb-4983-b41c-8b04156c16c9.png"/></div>
<p>The <kbd>tshark</kbd> tool runs by reading the file from the <kbd>-r</kbd> switch and using the filter <kbd>wlan.da==78:44:76:e7:b0:54</kbd> as the destination address while printing only the <kbd>wlan</kbd> sources using the <kbd>-T</kbd> fields and <kbd>-e wlan.sa</kbd> switch. With the output, we sort and print unique items by using the <kbd>sort</kbd> and <kbd>uniq</kbd> Linux commands.</p>
<div class="packt_infobox">In case of LUA errors for the preceding command, disable LUA by editing line 29 of the <kbd>/usr/share/Wireshark/init.lua</kbd> file and setting <kbd>disable_lua=true</kbd>.</div>
<p>We can check the found MAC addresses at <a href="https://macvendors.com/"><span class="URLPACKT">https://macvendors.com/</span></a>, as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/15999f20-e2f7-478a-8180-44f315eb830a.png" style="width:17.25em;height:8.42em;"/></div>
<div class="packt_infobox">Additionally, since MAC vendors provide an API, we can always develop a nice Python script to do the MAC checking for us. You can look at one of the scripts at <span class="URLPACKT"><a href="https://macvendors.co/api/python">https://macvendors.co/api/python</a>.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Packet types and subtypes</h1>
                </header>
            
            <article>
                
<p>Before we jump into packet types and subtypes, let's see what happens when we connect to a Wi-Fi access point. For this demonstration, we will be using a <strong>TP-Link router</strong> and an Apple iPhone 7. I will try to connect to the VIP3R network from the phone, but I will not use the correct password. Look at the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/e6b040e2-7d70-424d-86c0-25a80b7083ea.png"/></div>
<p>Generally, when we open the settings on the iPhone or any other phone, we start to see the networks in the vicinity of the phone. This is because each access point constantly sends out beacon frames to denote its presence. For the phone to know more about the network, a probe request is sent to the access point. We can see that our Wi-Fi access point (<kbd>78:44:76:E7:B0:58</kbd>) sends a probe response (8155) to the iPhone with the station parameters and supported rates.</p>
<p>Next, the authentication process is initiated by the iPhone, and the router responds well to it. Generally, the authentication request/response consists of a few packets exchanged between both of the communicating devices.</p>
<p>Next, an association request (8162) is sent by the iPhone to associate itself with the network, to which an association response (8164) is sent back with the association ID. Then, the key exchange process happens, and since the key was wrong, a disassociation packet is sent by the router to the iPhone denoting the failed attempt and immediately breaking the association. Since we now know how this stuff works, let's move on and discuss the types of wireless 802.11 frames in detail.</p>
<p>We primarily have data, management, and control frames in the 802.11 standards. From a pure play forensic point of view, the most we will be dealing with are the management frames. The following table highlights the types of frames and their subtypes:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td colspan="4">
<p><strong>Packet Types</strong></p>
</td>
<td rowspan="2">
<p><strong>Usage</strong></p>
</td>
</tr>
<tr>
<td colspan="2">
<p><strong>Type</strong></p>
</td>
<td colspan="2">
<p><strong>Subtype</strong></p>
</td>
</tr>
<tr>
<td>
<p>0</p>
</td>
<td>
<p>mgmt</p>
</td>
<td>
<p>0</p>
</td>
<td>
<p>Association request</p>
</td>
<td>
<p>The transmitter must already be authenticated to gain a successful association with the access point.</p>
</td>
</tr>
<tr>
<td>
<p>0</p>
</td>
<td>
<p>mgmt</p>
</td>
<td>
<p>1</p>
</td>
<td>
<p>Association response</p>
</td>
<td>
<p>The response to the association request is an association response. If the request is successful, the response packet will contain an identifier known as the association ID.</p>
</td>
</tr>
<tr>
<td>
<p>0</p>
</td>
<td>
<p>mgmt</p>
</td>
<td>
<p>10</p>
</td>
<td>
<p>Reassociation request</p>
</td>
<td>
<p>This is similar to an association request, but this packet type is sent when there are lapses in time, or when the station is moving toward another access point.</p>
</td>
</tr>
<tr>
<td>
<p>0</p>
</td>
<td>
<p>mgmt</p>
</td>
<td>
<p>11</p>
</td>
<td>
<p>Reassociation response</p>
</td>
<td>
<p>This is similar to the association response.</p>
</td>
</tr>
<tr>
<td>
<p>0</p>
</td>
<td>
<p>mgmt</p>
</td>
<td>
<p>100</p>
</td>
<td>
<p>Probe request</p>
</td>
<td>
<p>Used to actively check any, or a particular, access point.</p>
</td>
</tr>
<tr>
<td>
<p>0</p>
</td>
<td>
<p>mgmt</p>
</td>
<td>
<p>101</p>
</td>
<td>
<p>Probe response</p>
</td>
<td>
<p>The response contains station parameters and supported data rates.</p>
</td>
</tr>
<tr>
<td>
<p>0</p>
</td>
<td>
<p>mgmt</p>
</td>
<td>
<p>1000</p>
</td>
<td>
<p>Beacon</p>
</td>
<td>
<p>Beacon packets are indicator packets sent continuously by the AP denoting its presence in the network. Beacon frames also help to find rogue access points.</p>
</td>
</tr>
<tr>
<td>
<p>0</p>
</td>
<td>
<p>mgmt</p>
</td>
<td>
<p>1010</p>
</td>
<td>
<p>Disassociation</p>
</td>
<td>
<p>This packet is a notification that an existing association has been broken.</p>
</td>
</tr>
<tr>
<td>
<p>0</p>
</td>
<td>
<p>mgmt</p>
</td>
<td>
<p>1011</p>
</td>
<td>
<p>Authentication</p>
</td>
<td>
<p>Authentication packets are sent time and again between two endpoints in order to establish authenticity.</p>
</td>
</tr>
<tr>
<td>
<p>0</p>
</td>
<td>
<p>mgmt</p>
</td>
<td>
<p>1100</p>
</td>
<td>
<p>Deauthentication</p>
</td>
<td>
<p>This is an announcement message, stating that the receiver is no longer authenticated.</p>
</td>
</tr>
</tbody>
</table>
<div class="packt_infobox">For more information on wireless packet types and subtypes, refer to <span class="URLPACKT"><a href="https://www.savvius.com/networking-glossary/wireless_lan_overview/wlan_packet_types/">https://www.savvius.com/networking-glossary/wireless_lan_overview/wlan_packet_types/</a>.</span></div>
<p>We can see that the value of subtypes is given in binary. We can use its hex equivalent in Wireshark as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/f100c989-5906-4935-a208-abf7d43f6156.png"/></div>
<p>The information that we have gained regarding the packet types and subtypes will help us identify attack patterns in the latter half of the chapter. Let's now dive deep into the exercises.</p>
<div class="packt_infobox">For more information on the types of management frames, refer to <span class="URLPACKT"><a href="https://mrncciew.com/2014/09/29/cwap-802-11-mgmt-frame-types/">https://mrncciew.com/2014/09/29/cwap-802-11-mgmt-frame-types/</a>.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Locating wireless devices</h1>
                </header>
            
            <article>
                
<p>As network forensic investigators, sometimes we encounter rogue devices in a building or on a floor. It is important to find these devices, as they may contain vital information about the attacker and the attack itself. Wi-Fi is no exception. Say that we have a rogue access point running in the network. As forensic investigators, let's try to find the location of the device. We will make use of some scripts to accomplish this. Remember the <kbd>PWR</kbd> field in the airodump-ng tool? We need to develop something like that to poll the networks continuously. For this purpose, let's write the following Python 2.7 script:</p>
<pre>#!/usr/bin/env python <br/># Author: Nipun Jaswal<br/>from prettytable import PrettyTable<br/>import operator<br/>import subprocess <br/>import os<br/>import math<br/>import re<br/>import schedule<br/>import time<br/>def sniffer():<br/>  <br/>  # iwlist command to scan all the Access Points<br/>  proc = subprocess.Popen('iwlist wlan0 scan | grep -oE "(ESSID:|Address:|Channel:|Quality=).*" 2&gt;/dev/null', shell=True, stdout=subprocess.PIPE, ) <br/>  stdout_str = proc.communicate()[0]<br/>  stdout_list=stdout_str.split('\n')<br/>  <br/>  #Declaring Lists<br/>  network_name=[]<br/>  mac_address=[]<br/>  channel=[]<br/>  signal=[]<br/>  decibel=[]<br/>  distance=[]<br/>  frequency=[]<br/>  <br/>  #Reading all the Lines<br/>  for line in stdout_list:<br/>      line=line.strip()<br/>      #Regex to Match ESSID Value<br/>      match=re.search('ESSID:"(\S+)"',line) <br/>      if match: <br/>          network_name.append(match.group(1)) <br/>      #Regex to Match Channel Value<br/>      match=re.search('Channel:(\S*)',line) <br/>      if match: <br/>            channel.append(match.group(1))<br/>           #Calculating Frequency<br/>           frequency.append(int(match.group(1))*5 + 2407)<br/>      #Regex to Match Address Value<br/>      match=re.search('Address:\s(\S+)',line)<br/>      if match:<br/>           mac_address.append(match.group(1))<br/>      #Regex to Match Signal Value<br/>      match=re.search('Signal level=(\S+)',line)<br/>      if match:<br/>           signal.append(match.group(1))<br/>           # Sign Correctness<br/>           decibel.append(abs(int(match.group(1))))<br/>  i=0<br/>  x = PrettyTable()<br/>  x.field_names = ["ESSID", "MAC Address", "Channel", "Signal", "Distance","Frequency","Decibel"]<br/>  os.system("clear")<br/>  while i &lt; len(network_name):<br/>      # Free Space Path Loss (FSPL)<br/>      distance= 10 ** ((27.55 - (20 * math.log10(int(frequency[i]))) + int(decibel[i]))/20)<br/>      # Adding a Row to Pretty Table<br/>      x.add_row([network_name[i],mac_address[i],channel[i],int(signal[i]),str(float(distance))+ " mtr",int(frequency[i]),int(decibel[i])])<br/>      i=i+1<br/>  print x.get_string(sort_key=operator.itemgetter(4, 0), sortby="Signal", reversesort=True)<br/>  i=0<br/><br/># Main Thread Starts<br/>schedule.every(5).seconds.do(sniffer)<br/>while 1:<br/>    schedule.run_pending()<br/>    time.sleep(1)</pre>
<p class="mce-root"/>
<p>The code is quite self-explanatory. We used a schedule to run a wireless scan every five seconds using the <kbd>iwlist</kbd> command. We used regex expressions to filter the data out and displayed it using the <kbd>PrettyTable</kbd> Python module. To calculate the distance between the AP and our interface, we used a <strong>free-space path loss</strong> (<strong>FSPL</strong>) algorithm and the <kbd>PWR</kbd> field (power/ signal strength) and <kbd>Frequency</kbd> (channel ID) to calculate the distance using the following:</p>
<pre>Distance From the Access Point in Meters = 10 ^ ((27.55 - (20 * log10 (frequency)) +decibel)/20) </pre>
<p>Let's use the preceding formula and calculate the reading for a VIP3R access point that is running on channel 11 with a power value of -56. We can see that we need two values for the preceding formula to work. For <kbd>decibel</kbd>, we will use its absolute value, which is 56. To calculate the frequency of channel 11, we use the following:</p>
<pre>Frequency = channel number * gap + frequency of first channel - gap </pre>
<p>Using these expressions, we get the following:</p>
<pre>= 11 * 5 + 2412 - 5 
= 55+ 2407 = 2462 MHz </pre>
<p>Therefore, putting these values into the formula, we have the following:</p>
<pre>distance= 10 ^ ((27.55 - (20 * log10(2462)) + 56)/20) 
distance= 6.11240259465 </pre>
<p>Well, the distance equals 6.112 meters, which is almost accurate, given the distance from my current position where I am writing this text to my wireless router. However, an important thing to consider here is that this formula is for free-space path loss, and it may not be too accurate with a ton of walls and objects in between.</p>
<div class="packt_infobox">You can refer to an excellent white paper on the various types of signal loss due to various types of object, along with their values, at <span class="URLPACKT"><a href="https://arxiv.org/pdf/1707.05554.pdf">https://arxiv.org/pdf/1707.05554.pdf</a>.</span></div>
<p>Let's run the preceding Python script we built and see what values we get as we move closer to the AP, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/ad0facf0-eddf-4858-b971-b5ce06874f1d.png"/></div>
<p>Moving a little closer toward the access point, we get the following:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/e6b67841-59c7-432c-adea-ea1127a69240.png"/></div>
<p>We have the distance measured quite correctly. We now know how to use a few of the values from the <kbd>iwlist</kbd> scan command in Linux to create something that will aid us in wireless network forensics.</p>
<div class="packt_infobox">For a more precise reading, you can look at the upper and lower frequencies as well; find out how at <span class="URLPACKT"><a href="https://www.electronics-notes.com/articles/connectivity/wifi-ieee-802-11/channels-frequencies-bands-bandwidth.php">https://www.electronics-notes.com/articles/connectivity/wifi-ieee-802-11/channels-frequencies-bands-bandwidth.php</a>.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Identifying rogue access points</h1>
                </header>
            
            <article>
                
<p><strong>Rogue access points</strong> are an increasing area of concern. The attackers perform a<strong> <span>denial of service</span></strong> (<strong><span>DOS</span></strong>) attack on the legitimate router and set up a fake access point with the same SSID, forcing the stations to connect to the rogue access point. The attackers can set up a fake access point through a number of ways. Identifying these rogue APs is what we will look at next.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Obvious changes in the MAC address</h1>
                </header>
            
            <article>
                
<p>Say that we have a rogue access point in the vicinity. Using <kbd>airodump-ng</kbd> to capture packets, we get the following:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/04fef946-3529-4306-9162-f947d0875b21.png" style="width:35.92em;height:19.33em;"/></div>
<p>We can see that we have two networks with similar configurations, and the only changes we can see for now is the BSSID (MAC address) and the MB (link speed). While the MB is the most obvious change, let's investigate both MAC addresses at the MAC vendor's website, as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/eb195e4d-3ee4-489b-a61b-1392f966a10a.png"/></div>
<p class="mce-root"/>
<p class="mce-root"/>
<p>We can see that the address on the left is from Zioncom, which is a popular company that develops routers, while the address on the right is from a company called Analog &amp; Digital Systems, which is not a router-manufacturing company. However, if the attacker has randomly spoofed this address, they could have done it for a legitimate-looking vendor. Additionally, we found an MB rate (maximum speed) that is missing an <kbd>e</kbd> from the airodump-ng result  list. The missing <kbd>e</kbd> denotes whether the AP supports quality of service. The last thing we can denote from the airodump-ng interface is the speed at which beacons are transmitted. So, to sum up our first analysis, we have the following IoCs:</p>
<ul>
<li>Change in BSSID</li>
<li>BSSID not resolving to a legitimate vendor (MAC vendors)</li>
<li>Change in the data rate's quality of service parameter (a missing <kbd>e</kbd> means that QOS is not supported)</li>
<li>An excessive number of beacon frames from the fake AP</li>
</ul>
<p>While these are <span>all</span><span> </span><span>key checks when it comes to a fake AP detection, we will </span><span>certainly</span><span> </span><span>look for more.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The tagged perimeters</h1>
                </header>
            
            <article>
                
<p>Let's now investigate the original and fake access point in Wireshark and figure out the missing/modified details from the original access point, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/0ef7e66c-d518-4eba-809a-18129a98467e.png"/></div>
<p class="mce-root"/>
<p>Looking at the differences between both the beacon frames, we can see that there is plenty of information missing from the fake AP (on the left), and the key indicators are as follows:</p>
<ul>
<li>Fake AP support rates are considerably lower than the original AP</li>
<li>No ERP information in the fake AP</li>
<li>No details concerning the <strong>High Throughput</strong> (<strong>HT</strong> capabilities/HT information</li>
<li>Completely missing vendor-specific tags</li>
</ul>
<p>Additionally, we can see that the fake AP doesn't have any tag related to WPS, an original access point; most APs these days have WPS capabilities, which are missing from the fake access point. On investigating the original access point's WPS tag, we find the following details:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/5f389b52-cfd7-4f24-95ab-fe2877c97e44.png" style="width:27.58em;height:14.42em;"/></div>
<div>We can see that the WPS tags and data is present in case of the original access point.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The time delta analysis</h1>
                </header>
            
            <article>
                
<p>Since an advanced attacker can emulate fixes for most of the red flags identified in the preceding section, we need a serious mechanism to identify a rogue access point among the legitimate ones. We will make use of time delta for the beacon frames to identify the fake access point. While the fake access point tries to fool the analysis systems by spoofing the fixed beacon interval, time delta analysis allows us to figure out the exact beacon intervals.</p>
<p>A real AP would produce a time delta graph denoting an almost straight line; this is not the case for a fake AP. Let's confirm what we just said using <kbd>tshark -r beacon-01.cap -2 -R "wlan.sa==7c:8b:ca:ea:27:52 &amp;&amp; wlan.fc.type_subtype==0x08" -T fields -e frame.time.delta | head -n 20</kbd>, as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/30c0b8b8-6842-420f-ac2d-99a49749f891.png" style="width:42.83em;height:24.33em;"/></div>
<p>The preceding command runs <kbd>tshark</kbd> on the <kbd>beacon-01.cap</kbd> file while filtering out all the beacon frames originating from <kbd>78:44:76:e7:b0:54</kbd> and displaying <kbd>time_delta</kbd>, which is the difference between the arrival time of the packet and the previous packet. Keeping it short to only 20 entries, we can see that most of the values are close to 0.102 ms.</p>
<p>Let's do the same for the suspicious access point <kbd>00:20:30:40:43:21</kbd>:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/6ca6841b-a5ff-4566-95c8-325078a02277.png" style="width:44.33em;height:25.50em;"/></div>
<p>Well! We can see a clear difference in the values: the suspicious access point has very shaky values compared to the original access point. Plotting a graph with the first 100 time delta values for both, we will look at the differences as shown in the following graph:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/b80d23fc-f7b2-43b6-b733-1c4399cc891c.png" style="width:23.25em;height:16.00em;"/></div>
<p>We can see the difference: the original access point has kept it quite linear compared to the shaky fake access point. We now have a clear picture of how we can differentiate between an original and a fake access point. Summarizing the key indicators, we have the following indicators that can very well identify the fake access point from the original one:</p>
<ul>
<li>Change in BSSID</li>
<li>BSSID not resolving to a legitimate vendor (MAC Vendors)</li>
<li>Change in the Data Rates Quality of Service parameter (A missing e means QoS is not supported)</li>
<li>An excessive number of beacon frames from the fake AP</li>
<li>Fake AP support rates are fairly less than the original AP</li>
<li>No ERP information in the fake AP</li>
<li>No information on HT Capabilities/HT Information </li>
<li>Completely missing the Vendor Specific Tags</li>
<li>Time-Delta value analysis show a stable graph for the real access point</li>
</ul>
<div class="packt_tip">Sometimes, you will find that because of the delay and packet loss, the delta value we get is around 0.2, 0.3, or 0.4. In such cases, we should divide the value by its associated gap. So, for a value of, say, 0.204, we divide the value by 2 and obtain 0.102, or, for a value 0.412, we divide the value by 4 to obtain 0.103.</div>
<div class="packt_infobox">The preceding analysis is based on an access point created with a TP TL-WN722N wireless card and would have similar details for Alfa and other cards. However, if an access point has been created using the original router itself, this will pose additional challenges, and making use of all the techniques discussed will lead to a correct analysis. Using the original access point for malicious purposes will have a different MAC address, as it's not easy to spoof a MAC address in the original access point. In the case of an advanced attacker mimicking/spoofing the original MAC, all of the preceding techniques will detect at least some of the changes.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Identifying attacks</h1>
                </header>
            
            <article>
                
<p>Attack identification on wireless LANs is not as easy as it is with Ethernet networks. Identifying the attacker is also not straightforward. In the previous exercises, we saw how supplying a wrong password generates a disassociation response from the AP to the station that is trying to connect.</p>
<p>Let's look at more attack patterns that are commonly used against WLANs, as shown in the following list:</p>
<ul>
<li>Rogue AP attacks</li>
<li>Peer-to-peer attacks</li>
<li>Eavesdropping</li>
<li>Cracking encryption</li>
<li>Authentication attacks</li>
<li>Denial of service</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Rogue AP attacks</h1>
                </header>
            
            <article>
                
<p>In the previous section, we saw how rogue APs could be identified. Now let's look at what this attack actually does. In this type of attack, the attacker mimics an original access point and, in a parallel manner, disconnects the legitimate users from the original access point. I<span>n this case, w</span><span>hat happens is that </span><span>when </span><span>the station tries to connect back to the network, it is not able to connect to the original access point and instead gets connected to the fake one. Because of this, all the network data passes through the rogue access point, and the attacker can harvest sensitive details about the targets.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Peer-to-peer attacks</h1>
                </header>
            
            <article>
                
<p>In a <strong>peer-to-peer</strong> attack, the attacker and the target are on the same network, such as a public hotspot, and the attacker tries to carry out network-based attacks, such as exploiting a vulnerability in the network application. SMB-enabled attacks are the most common example of such attacks.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Eavesdropping</h1>
                </header>
            
            <article>
                
<p>Putting our interface in monitor mode and silently capturing all the data around us, as we did for the first example, is called <strong>eavesdropping</strong>. Once the data is captured, we can see how many stations are connected to an AP and calculate the distances, or even go further and crack the network key and then decrypt the captured data to unveil the activities of the various users. The key challenge in this attack type is that we are not able to detect an attacker, since their device is running passively and collecting data.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Cracking encryption</h1>
                </header>
            
            <article>
                
<p><span><strong>Wired equivalent privacy</strong> </span>(<strong>WEP</strong>)<span> </span> encryption in 802.11 is very weak and is susceptible to cracking. The cracking involves the process of finding how the RC4 key is generated by WEP which is by concatenating the 5 or the 13 byte key with the 3 byte IV value. Additionally, it involves finding that how RC4 processes that key in the initial permutation and finally how the permutation is used to generate the initial key stream. The attacker can see the IV value moreover the first byte in the keystream might directly be related to one of the key bytes. Hence, observing enough of these key bytes, the attacker can find the key</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Authentication attacks</h1>
                </header>
            
            <article>
                
<p>WPA and WPA2 (Wi-Fi protected access) are vulnerable to password-cracking attacks, especially when a weak password is used by the network. In order to break into a WPA-enabled AP, the attacker will use the following techniques:</p>
<ul>
<li><strong>Sniffing wireless packets in the air</strong>: This involves putting the wireless network card in monitor mode and listening and recording everything that is happening around on the local wireless networks.</li>
<li><strong>Wait for a client to authenticate</strong>: APs use a four-way handshake to exchange information with WPA wireless clients for authentication. Mostly, the client needs to prove that they are a legitimate user and has the passcode to the network. This four-way handshake, or the <strong>Extensible Authentication Protocol over LAN</strong> (<strong>EAPOL</strong>), encrypts the password in a way that the APs can decrypt it and check whether it matches the one that has been set on the network.</li>
<li><strong>Use a brute-force attack</strong>: Having recorded everything and obtaining the EAPOL packets, the attacker can brute-force the password using an offline dictionary attack against the captured file.</li>
</ul>
<p>An important point here is that if there aren't any users on the network or if there aren't any users connected to the network, then the attack will fail. However, if a user is active and already authenticated, the attacker can use a variety of attacks, such as a deauthentication attack, against the network AP or the connected or clients to disconnect them and force the client's device to authenticate again.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Denial of service</h1>
                </header>
            
            <article>
                
<p>Using deauthentication packets, an attacker can force users to disconnect from the AP. Sending a single <span>deauthentication </span> packet will force the stations to reauthenticate to the access point, and in the process, the attacker captures the WPA handshakes. However, if the attacker sends multiple <span>deauthentication </span> packets continuously over time, they create a denial-of-service situation, where the clients are not able to connect to the AP for a long time.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Investigating deauthentication packets</h1>
                </header>
            
            <article>
                
<p>In this section, we will analyze a sample capture file covering the details of an attack on a WPA2 network. Loading the file in Wireshark, we can see that we have 3,818 packets, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/29ae4e22-8c18-48b1-8d09-a2244949ca93.png"/></div>
<p class="mce-root"/>
<p>Let's clear the noise by filtering out only management frames using the <kbd>wlan.fc.type</kbd> filter and the value <kbd>0x0</kbd>, as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/074b2c44-ab7e-47cf-9f9c-baedde34aec1.png"/></div>
<p>We can see that we are left with only 420 packets, and we can also see plenty of deauthentication packets in the screenshot. Let's find out which device got affected by this <span>deauthentication</span> attack and reinitiated the key handshake:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/c5b13f57-e958-43b0-ace1-315ff8f80214.png"/></div>
<p>It looks as though <kbd>b0:10:41:c8:46:df</kbd> was deauthenticated and reinitiated the key exchange. We can see that the authentication packets started at frame number <kbd>377</kbd>. Let's look at what happened before this:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/2c7fa8dc-7164-44d9-9ec5-38c52465296a.png"/></div>
<p class="mce-root"/>
<p>We can see that plenty of <span>deauthentication </span>packets started arriving, which caused the device with the MAC address <kbd>b0:10:41:c8:46:df</kbd> to reinitiate the connection. However, we can't see the key packets anywhere. Let's find out where they are:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/a06b1684-657f-46be-8ed2-dd1aa579298e.png"/></div>
<p>Simply putting a filter on <kbd>eapol</kbd> allows us to see that the key is exchanged between the devices. An attacker with access to this file needs to brute-force it to find the network key. We saw how we could gather details on the deauthentication attack; however, we also saw that we were not able to find the original attacker's MAC address, as they pretended to be one of the victims or the AP itself.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Case study – identifying the attacker</h1>
                </header>
            
            <article>
                
<p>In this example, we have received two capture files for analysis. We start investigating the first file as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/3234ffed-844d-45a0-bdc1-e6ebb03c083a.png"/></div>
<p>We can see that the <span class="packt_screen">Link type</span> is 802.11, which means that we are investigating a WLAN. Let's see the endpoints on this network:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/02df08c9-8e5c-45fc-a240-97898a686775.png"/></div>
<p>From the preceding statistics, we can see that we have plenty of deauthenticated packets that have been directed to the broadcast address. We can also see that two stations, <kbd>54:99:63:82:64:f5</kbd> and <kbd>2c:33:61:77:23:ef</kbd>, <span>were</span><span> </span><span>both involved in deauthentication, which means that they might have received the</span> <span>deauthentication</span> <span>packets as well. Let's check this in Wireshark, as shown in the following screenshot:</span></p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/f208d965-d700-4373-81a1-a61147f1d8c4.png"/></div>
<p>We can see that the first <span>deauthentication</span> packet was broadcast at frame 4,175. Most of the time, the <span>deauthentication</span> packet will contain the reason code: the Class 3 frame received from a non-associated STA (0x0007), which happens mostly in cases of a forced deauth. After the <span>deauthentication packet was received by the station,</span> the station responds with the following:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/cb1442b5-4199-456d-aaba-8e4b71e6c038.png"/></div>
<p>The reason mentioned by the stations is <kbd>Deauthenticated</kbd> because the sending STA is leaving (or has left) IBSS or ESS (0x0003). Finally, all the clients were disassociated, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/92763128-897d-4bf2-b9e3-c7a6aeded7a5.png"/></div>
<p>Let's look at the stations' attempts to exchange keys, which the attacker might have captured to obtain information:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/e7a8d5ca-2540-45d6-9fac-09d6da0e9c13.png"/></div>
<p>We simply used the filter <kbd>-2 -R "eapol"</kbd> to view the key exchange and then printed the WLAN destination addresses, sorted them, and found the unique entries. The next thing would be to identify whether there has been any new authentication other than these four addresses. Let's investigate the second PCAP, as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/330268fa-5824-4e8b-ad9f-940b1fdd18a2.png"/></div>
<p>Running the same <kbd>tshark</kbd> command on the second PCAP file, we can see that there is a new MAC address that authenticated on the network. Let's check whether it was successful:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/5fbcb467-c57f-48bf-bacb-d8138a38bc25.png"/></div>
<p>Looking for authentication type packets, we can see that the authentication was successful. Interestingly, there are no signs of <span>deauthentication</span> or dissociations in the PCAP file. Let's look at the following overview of the timeline by taking input from <strong>Statistics</strong> | <strong>Capture File Properties</strong>, as shown as follows:</p>
<ul>
<li><strong>Mar 10, 2019 08:18:04.380420000 EDT</strong>: The file capture was started and the first packet was captured</li>
<li><strong>Mar 10, 2019 08:20:20.587840000 EDT</strong>: <kbd>78:44:76:e7:b0:58</kbd> broadcast the first <span>deauthentication</span> packet</li>
</ul>
<ul>
<li><strong>Mar 10, 2019 08:20:20.688171000 EDT</strong>: Stations started authenticating (<kbd>2c:33:61:77:23:ef</kbd>, <kbd>54:99:63:82:64:f5</kbd>, and <kbd>b0:10:41:c8:46:df</kbd>)</li>
<li><strong>Mar 10, 2019 08:20:20.691243000 EDT</strong>: <kbd>b0:10:41:c8:46:df</kbd> sent the first reassociation request</li>
<li><strong>Mar 10, 2019 08:20:20.696323000 EDT</strong>: Key exchange started for all stations</li>
<li><strong>Mar 10, 2019 08:20:22.850949000 EDT</strong>: Stations stopped authenticating (<kbd>2c:33:61:77:23:ef</kbd>, <kbd>54:99:63:82:64:f5</kbd>, and <kbd>b0:10:41:c8:46:df</kbd>)</li>
<li><strong>Mar 10, 2019 08:20:25.684608000 EDT</strong>: Deauthentications stopped</li>
<li><strong>Mar 10, 2019 08:20:27.285187000 EDT</strong>: Dissociation started on all stations</li>
<li><strong>Mar 10, 2019 08:20:27.847874000 EDT</strong>: Key exchange ended for all stations</li>
<li><strong>Mar 10, 2019 08:20:28.847362000 EDT</strong>: Dissociation ended</li>
<li><strong>Mar 10, 2019 08:23:44.857619000 EDT</strong>: A new MAC address (<kbd>f0:79:60:25:be:ac</kbd>) that was not seen before was authenticated</li>
<li><strong>Mar 10, 2019, 08:23:48.642582000 EDT</strong>: Key exchange completed for the new MAC address</li>
</ul>
<div class="CDPAlignCenter CDPAlign"><img src="assets/5cdffbee-47db-448e-8dea-38f66c1bf021.png"/></div>
<p>It's quite evident that no attacks happened after <kbd>08:20:25.684</kbd>, and a new MAC address joined the network. This might be our attacker, but we are not sure. Let's decrypt the conversation exactly in a way we did in <a href="3d24aeb7-0dd7-4fe4-a29b-8f340fb2d00b.xhtml" target="_blank">Chapter 5</a>, <em>Combatting Tunneling and Encryption</em>, which is to use Aircrack-ng as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/490e3ea2-1392-43c4-aa82-ee3dcbdc5a12.png" style="width:43.17em;height:23.08em;"/></div>
<p>We found the key using Aircrack-ng and applied it in Wireshark, as we did in the previous chapters. Look at the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/7f1093f7-c4c9-4022-a816-41de29459f00.png"/></div>
<p class="mce-root"/>
<p class="mce-root"/>
<p>It looks as though the attacker is running a port scan since the destination ports are increasing by one. On filtering the HTTP requests and following the HTTP stream, we can see that the attacker tried to reach the Hue portal which is a popular wireless lighting system by Philips as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/53b7a621-c90f-4299-a7f1-aa8448e8a6cd.png" style="width:43.08em;height:11.42em;"/></div>
<p>Moreover, they may have tried conducting further attacks, but the PCAPs were cut short.</p>
<p>Over the course of this case study, we saw how we could work with 802.11 packets to reveal a ton of information about the attacker. We developed a timeline and decrypted the 802.11 encapsulation by decrypting the key and finding the real intentions of the attacker.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>Over the course of this chapter, we learned a lot about 802.11 packets. We covered tools such as airodump-ng, learned about the packet types and subtypes and locating rogue access points using time delta analysis, and tagged parameters and changes in MAC addresses. We looked at a variety of attack types and worked with deauthentication packets.</p>
<p>In the next chapter, we will look at summarizing and automating tools and scripts to perform network forensics quickly.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<p>Answer the following questions:</p>
<ol>
<li>Which of the packet is subtype 0 in the management packets?
<ol>
<li>Association request</li>
<li>Authentication request</li>
<li>Beacon frame</li>
<li>Probe request</li>
</ol>
</li>
<li>Which of the packet is subtype 8 in the management packets?
<ol>
<li>Association request</li>
<li>Authentication request</li>
<li>Beacon frame</li>
<li>Probe request</li>
</ol>
</li>
<li>Which of the packet is subtype 12 or C in the management packets?
<ol>
<li>Deauthentication</li>
<li>Disassociation</li>
<li>Reassociation</li>
<li>Probe response</li>
</ol>
</li>
<li>Which of the following methods can detect fake AP?
<ol>
<li>Investigating HTTP packets</li>
<li>Investigating time delta</li>
<li>Investigating data frames</li>
<li>Cracking the router's password</li>
</ol>
</li>
<li>Which of the following tools can crack a wireless router's login password?
<ol>
<li>Kismet</li>
<li>Aircrack-ng</li>
<li>Wireshark</li>
<li>All of the above</li>
<li>None of the above</li>
</ol>
</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<p>To gain the most out of this chapter, please go through the following links:</p>
<ul>
<li>Read more on wireless forensics at <a href="https://www.sans.org/reading-room/whitepapers/wireless/80211-network-forensic-analysis-33023">https://www.sans.org/reading-room/whitepapers/wireless/80211-network-forensic-analysis-33023</a></li>
<li>More on fake AP Detection at <a href="https://www.sans.org/reading-room/whitepapers/detection/detecting-preventing-rogue-devices-network-1866">https://www.sans.org/reading-room/whitepapers/detection/detecting-preventing-rogue-devices-network-1866</a></li>
</ul>


            </article>

            
        </section>
    </body></html>