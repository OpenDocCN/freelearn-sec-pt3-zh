<html><head></head><body><div class="chapter" title="Chapter&#xA0;6.&#xA0;Filesystem Analysis and Data Recovery"><div class="titlepage"><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Filesystem Analysis and Data Recovery</h1></div></div></div><p>Although there are many automated and commercial tools available nowadays, understanding how these tools perform can distinguish one from another, and this can provide great support during expert testimony in the courtroom. Filesystem analysis and data recovery are considered as the main categories in the digital forensics process. Extracting files from a storage device or recovering deleted ones with evidential related data can solve a case.</p><p>In this chapter, we will go through two different filesystems: the FAT and the NTFS. We will basically explain how the files are structured in each one and how the recovery process of deleted files actually works. We will start with the famous TSK or The Sleuth Kit and how its command line tools are categorized, as they are based on each layer in the hard drive or the forensic image. After this, we will discuss Autopsy, the TSK graphical user interface. At the end of this chapter, we will show you Foremost of these, which is the Linux-based file carving tool that is used to recover files based on their signature.</p><div class="section" title="Hard drive structure"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec35"/>Hard drive structure</h1></div></div></div><p>Before we start explaining the different filesystem structures, we need to illustrate the different parts in a partitioned hard drive in Windows OS. The following figure illustrates simply the structure of a whole partitioned hard drive:</p><div class="mediaobject"><img src="graphics/image_06_001.jpg" alt="Hard drive structure"/><div class="caption"><p>Simple hard drive logical parts</p></div></div><div class="section" title="Master boot record"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec54"/>Master boot record</h2></div></div></div><p>The master boot record is the first sector (512 bytes) of the hard drive. It contains, besides the boot code, all the information about the hard drive. One of the important pieces of information that can be found in the MBR is the partition table, which contains information about the partition structure in the hard drive, and for each partition, it can tell where it starts, its size, and type.</p><p>The investigator can check the existing partition with the information in the MBR and the printed size of the hard drive for a match. If there is some missing space, the handler may assume the presence of an intended action to hide some space contains usually some related important information.</p></div><div class="section" title="Partition boot sector"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec55"/>Partition boot sector</h2></div></div></div><p>The first sector (512 bytes) of each partition contains information, such as the type of the filesystem, the booting code location, the sector size, and the cluster size in reference to sector.</p></div><div class="section" title="The filesystem area in partition"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec56"/>The filesystem area in partition</h2></div></div></div><p>If the user formatted the partition, for example, in the NTFS filesystem, some sectors at the beginning of the partition will be reserved for the <span class="strong"><strong>Master File Table</strong></span> or <span class="strong"><strong>MFT</strong></span>. MFT is the location that contains the metadata about the files in the system. Each entry is 1KB in size, and when a user deletes a file, the file's entry in the MFT is marked as unallocated. However, the file's information still exists until another file uses this MFT entry and overwrites the previous file's information.</p><p>Normal backups usually store the allocated entries only and ignore the unallocated areas in the MFT. This won't be helpful in recovering deleted files during the analysis step.</p></div><div class="section" title="Data area"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec57"/>Data area</h2></div></div></div><p>After reserving the filesystem's area, the rest of the partition space will be available for the file's data, which contains the actual data of the file. Each unit of the data area is called <span class="strong"><strong>cluster</strong></span> or <span class="strong"><strong>block</strong></span>. In the same way, if a user deletes a file from the hard drive, the clusters that contain data that is related to this file will be marked as unallocated, and the data will exist until new data that is related to a new file overwrites it.</p><p>These clusters are considered either allocated or unallocated:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Allocated cluster</strong></span>: This is a cluster that contains data that is related to a file that exists and has an entry in the filesystem MFT area</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Unallocated cluster</strong></span>: This is a cluster that isn't connected to an existing file and it may be any of the following:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Empty</strong></span>: This means that it has no data of a deleted file or its content has been wiped</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Not </strong></span><span class="strong"><strong>empty</strong></span>: This contains data that is related to a deleted file and still hasn't been overwritten with a new file's data.</li></ul></div><p>
</p></li></ul></div><p>While running a backup tool to the system, it backs up only the files that exist in the current filesystem MFT area and identifies its related cluster in the data area as allocated. This is NOT a forensically sound image which needs to acquire all the hard drive areas even if it was deleted by the user. That is why, when you backup your system using no compression, the size of the backup will be the size of the used space in the partition.</p><p>However, when using forensic imaging techniques, the size of the resulting image will be equal to exactly the size of the source; it will either comprise the whole hard drive or a single partition.</p><p>In the following section, we will quickly overview how FAT and NTFS work.</p></div></div></div>
<div class="section" title="The FAT filesystem"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec36"/>The FAT filesystem</h1></div></div></div><p>FAT or File Allocation Table became famous with the announcement of the DOS operating system from Microsoft in 1980. After this, FAT went through many improvements trying to make it adapt with the rapidly improving technology. So, we can see FAT12, FAT16, FAT32, and exFAT. Each version overcame some of the limitations of the filesystem until the announcement of NTFS filesystem.</p><div class="section" title="FAT components"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec58"/>FAT components</h2></div></div></div><p>FAT partition contains five main areas. They comprise the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Boot sector</strong></span>: This is the first sector of the partition that is loaded in memory. If this partition is the active partition, it contains information such as, but not limited to, the following:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Jump code</strong></span>: This is the location of the bootstrap and OS initialization code</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Sector size</strong></span>: This is almost fixed (512 bytes)</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Cluster size</strong></span>: This is in sectors (sectors/clusters)</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Number of sectors</strong></span>: The total number of sectors in the partition</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Number of root entries</strong></span>: This value is used with FAT12 and FAT16 only</li></ul></div><p>
</p></li></ul></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>FAT table</strong></span>: This is the filesystem, which is named after this area. Starting from the first cluster of the file, which can be found in the root directory entry of a file, the FAT area tracks the rest of the file in the data area. Each data cluster, for example, cluster X is the first cluster that contains the data of file Y, has an entry in the FAT area. This entry can have four values:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">0: This indicates that cluster X is an unallocated cluster</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Number</strong></span>: This indicates the number of the next cluster following cluster X, and it contains the next part of file Y</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>EOF</strong></span>: This is end of the file, and it indicates that cluster X is the last cluster that contains the data of file Y, End of File Y</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>BAD</strong></span>: This indicates that cluster X is a bad cluster, and it cannot be used or accessed by the operating system. This data tracking schema is called the FAT chain, and it must exist for each file.</li></ul></div><p>
</p></li></ul></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Another copy of the FAT table</strong></span>: This is used if the first FAT got corrupted.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Root directory entries</strong></span>: This is when each entry describes either directory or file in the filesystem, and its location from the root directory. Each entry contains information, such as the following:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Short File name with an 8.3 naming schema; eight characters for the name and three characters for the extension</li><li class="listitem" style="list-style-type: disc">Long file name if the file name exceeds the 8.3 schema, it will reserve another complete entry to store the file name</li><li class="listitem" style="list-style-type: disc">Entry's status such as directory, file, or deleted</li><li class="listitem" style="list-style-type: disc">Some file properties, such as read only, hidden and archive</li><li class="listitem" style="list-style-type: disc">File size, which is not important in the case of a directory</li><li class="listitem" style="list-style-type: disc">Timestamps of the file</li><li class="listitem" style="list-style-type: disc">The address of the first cluster, which contains the file's data</li></ul></div><p>
</p><p>As we can see no modern properties can be added to the file, such as compression, permissions, and encryption, which was one of the FAT filesystem limitations.</p></li></ul></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Data area</strong></span>: This is the rest of the partition. It contains the actual contents of the files in the partition, and it is divided in clusters with a size mentioned in the boot sector. Cluster numbering starts with cluster 2, so cluster 0 and cluster 1 don't exist.</li></ul></div><p>For an example of how this works, we have created table 1. Each major column represents one of the FAT areas, excluding the boot sector. Now, let's suppose that the first file, <code class="literal">F1.txt</code>, has a size of 1KB and starts at cluster 2:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Cluster 2 contains the first part of the <code class="literal">F1.txt</code> file</li><li class="listitem" style="list-style-type: disc">In the FAT entry that describes cluster 2, we will find the next cluster in the chain which, in our case, is cluster 3</li><li class="listitem" style="list-style-type: disc">At cluster 3, we can find the next part of the <code class="literal">F1.txt</code> file</li><li class="listitem" style="list-style-type: disc">In the FAT entry that describes cluster 3, we can find EoF because no more data in the <code class="literal">F1.txt</code> file needs to be stored</li></ul></div><p>The same can be applied to the other files:</p><div class="mediaobject"><img src="graphics/image123.jpg" alt="FAT components"/><div class="caption"><p>The FAT filesystem</p></div></div></div><div class="section" title="FAT limitations"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec59"/>FAT limitations</h2></div></div></div><p>FAT had some serious limitations, which raised the need for a more advanced filesystem:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The number after each FAT, such as <code class="literal">FAT12</code>, <code class="literal">FAT16</code>, or <code class="literal">FAT32</code>, represents the number of bits that are assigned to address clusters in the FAT table:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>FAT12</strong></span>: This is 2^12 = 4,096 clusters at the maximum.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>FAT16</strong></span>: This is 2^16 = 65,536 clusters at the maximum.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>FAT32</strong></span>: This is 2^32 = 4,294,967,296 clusters, but it has 4 reserved bits, so it is actually 28 bits. So, 2^28 = 268,435,456 at the maximum.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>exFAT</strong></span>: This uses the whole 32 bits for addressing.</li></ul></div><p>
</p></li></ul></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The maximum partition size in FAT32 = the maximum number of clusters, which is 268,435,456, multiplied by the maximum cluster size, which is 23 KB = 8,589,934,592 KB = 8 TB.</li></ul></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">For the maximum file size in FAT32, as an example, the bit file used to store the file size in bytes is 32 bit long. The maximum number this can store is 2^32= 4,294,967,296 bytes = 4 GB. So, the maximum file size that FAT32 can handle is 4 GB. That is why we can't store files whose size exceeds 4 GB in the FAT32 filesystem.</li><li class="listitem" style="list-style-type: disc">Properties such as access control and encryption weren't available in the FAT filesystem.</li></ul></div></div></div>
<div class="section" title="The NTFS filesystem"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec37"/>The NTFS filesystem</h1></div></div></div><p><span class="strong"><strong>NTFS</strong></span> or <span class="strong"><strong>New Technology Filesystem</strong></span> is the default filesystem in Windows NT as a result of the storage capacity increasing and the need for a more secure, scalable, and advanced filesystem. NTFS overcame the FAT limitations and was more suitable for high storage capacity. In NTFS, everything is a file including the filesystem area itself, as we will see in the following section.</p><div class="section" title="NTFS components"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec60"/>NTFS components</h2></div></div></div><p>Like FAT and any other filesystem, NTFS has its components as follows:</p><p>The boot sector is the first sector in the partition, and it contains some information about the filesystem itself, such as start code, sector size, cluster size in sectors, and the number of reserved sectors. The filesystem area contains many files, including the MFT or Master File Table, which contains the metadata of the files and directories in the partition. It will be discussed later.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The data area holds the actual contents of the files, and it is divided in clusters with a size determined during formatting and mentioned in the boot sector.</li></ul></div></div><div class="section" title="Master File Table (MFT)"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec61"/>Master File Table (MFT)</h2></div></div></div><p>As everything in NTFS is a file, the filesystem area is also a single file called $MFT. In this file, there is an entry for each file in the partition. This entry is 1,024 bytes in size. Actually, $MFT file has an entry for itself. Each entry has a header of 42 bytes at the beginning and has a signature of 0xEB52904E, which is equivalent to FILE as ASCII.</p><p>The signature also can be BAD, in this case, it indicates an error that occurred in this entry. After the header, there will be another 982 bytes left to store the file metadata. If there is space left to store the file contents, typically in small size files, the file's data is stored in the entry itself and no space in the data area is used by this file.</p><p>Each MFT entry has another substructure called <span class="strong"><strong>attributes</strong></span>. MFT uses attributes to store the metadata of the file. Different attribute types can be used in single MFT entry. Each attribute is assigned to store different information. For example, the Standard Information Attribute contains the timestamp and the size of the file, whereas the Data Attribute holds the actual contents of the file.</p><p>The attribute can be either of the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Resident</strong></span>: This contains all its data within the MFT entry.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Non-resident</strong></span>: Because of the limitation of the MFT size, some attributes may need to store their data in the data area. A clear example of this kind of attribute is the data attribute.</li></ul></div><p>Storing the file metadata in attributes creates flexibility for NTFS to add more types of attributes that are recognized by the operating system in the future. If one file has many attributes and needs more than one MFT entry to store its metadata, it can use another entry and link both entries with a sequence number.</p></div></div>
<div class="section" title="The Sleuth Kit (TSK)"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec38"/>The Sleuth Kit (TSK)</h1></div></div></div><p>The Sleuth Kit or TSK is a collection of open source digital forensic tools developed by <span class="emphasis"><em>Brian Carrier</em></span> and <span class="emphasis"><em>Wieste Venema</em></span>. TSK can read and parse different types of filesystems, such as FAT, NTFS, and EXT. Each area of the hard drive in the figure in the <span class="emphasis"><em>Hard drive structure</em></span> section has a set of tools in The Sleuth Kit that parses that area and extracts forensically important information for the investigator. Usually, each step leads to the next while using TSK in analysis.</p><p>In the upcoming sections, we will go through the different tool sets of The Sleuth Kit. We will use an image of the hard drive with Windows 7 installed, which shows the results from each part in the hard drive. The image was acquired using the FTK Imager lite from a Windows 7 virtual machine with a size of only 15 GB and a single NTFS partition.</p><p>As we will see, TSK tool names are easy to understand as they consist of two parts. The first part represents the area or the layer under investigation, such as <code class="literal">mm</code> for media management, <code class="literal">fs</code> for filesystem, <code class="literal">i</code> for metadata, and <code class="literal">f</code> for filename layer. The second part is the normal Linux command that reflects the effect of this tool, such as ls to list and cat to display the contents, for example, the <code class="literal">mmls</code> tool.</p><div class="section" title="Volume layer (media management)"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec62"/>Volume layer (media management)</h2></div></div></div><p>In this area of the hard drive, TSK parses information about the structure of the whole hard drive from the <span class="strong"><strong>MBR</strong></span> or <span class="strong"><strong>Master Boot Record</strong></span>, which is the first sector of the hard drive. We can parse this area with TSK using different tools.</p><p>The information about each partition is in the hard drive, and it can be determined from the partition table at the end of the MBR sector. The offset of each partition will be used as an input to the upcoming TSK tools to specify the partition of interest. The <code class="literal">mmls</code> tool is used to list information, such as in the following screenshot:</p><div class="mediaobject"><img src="graphics/image_06_002.jpg" alt="Volume layer (media management)"/><div class="caption"><p>The mmls tool</p></div></div><p>From the result of running <code class="literal">mmls</code> against the image, we can see that there is only one NTFS partition that starts at sector (2,048). This is the partition of interest, so we will use the start sector as the offset with the rest of the tools when needed. This also provides the partition table type, which is normal DOS in our case here. To display only the allocated volumes, we can use the <code class="literal">-a</code> option:</p><div class="mediaobject"><img src="graphics/image_06_003.jpg" alt="Volume layer (media management)"/><div class="caption"><p>A list allocated volumes only</p></div></div><p>The next command is <code class="literal">mmcat</code>, which displays the partition contents as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/image_06_004.jpg" alt="Volume layer (media management)"/><div class="caption"><p>The mmcat tool</p></div></div><p>In the previous figure, we used <code class="literal">mmcat</code> with the image name <code class="literal">sampleimage.dd</code> and the number of the target partition as in the <code class="literal">mmls</code> output <code class="literal">02</code>. Then, we pipelined the output to the <code class="literal">hexdump</code> tool. You can see in the beginning of the partition, the volume boot record starts with the NTFS partition signature at offset 0x03 with a value of (NTFS) or 0x(4E54465320202020).</p></div><div class="section" title="Filesystem layer"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec63"/>Filesystem layer</h2></div></div></div><p>The TSK tool for this layer parses the filesystem used in the provided partition and displays some information about it to the investigator. With this tool, we must provide the offset of the target partition from the output of the mmls tool, which in our case is (2,048):</p><div class="mediaobject"><img src="graphics/image_06_005.jpg" alt="Filesystem layer"/><div class="caption"><p>The fsstat tool</p></div></div><p>We can find the MFT location within the partition, cluster size, and information about the NTFS attributes, which may be used later in further analysis.</p></div><div class="section" title="The metadata layer"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec64"/>The metadata layer</h2></div></div></div><p>The metadata layer (or inode) parses and describes the information or the metadata record of the file as described in the filesystem. Also, the output of this tool can be used with other tools to narrow the results for a specific file in the image.</p><p>The <code class="literal">i</code> character in the commands in this layer stands for inode—the metadata unique number of a file in the EXT filesystem.</p><p>The <code class="literal">ils</code> command is used to list the inode numbers of the deleted files in the image until told to list all the inode information for all the files in the image. All the results of the <code class="literal">ils</code> are information about the file, including the inode of the file, the timestamps (MACB) in Unix time, and size of the file. We can use <code class="literal">ils</code> with the <code class="literal">-m</code> option to create a compatible output for the <code class="literal">mactime</code> tool in case we need to create a timeline for the file activity in the image.</p><p>Also, using <code class="literal">--m </code>will allow us to read the filename as well, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/image_06_006.jpg" alt="The metadata layer"/><div class="caption"><p>ils to list the deleted files</p></div></div><p>The result only shows the deleted files as we can notice the 'dead' status of all the files in the results.</p><div class="section" title="istat"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec4"/>istat</h3></div></div></div><p>This is used to parse the MFT or the inode record by its unique metadata number and view all the information in the provided record. The resulting information is only metadata, so we can find the timestamps, file attributes, and so on, not the data itself even if the data is short enough to fit in the 1,024 KB length of one MFT record, which is called resident.</p><p>Displaying the data contents of the file can be determined by another tool in TSK, which will be discussed next. Each file in the NTFS filesystem has an entry of this kind, even the MFT file itself. In the following figure, we will list information about the first record number 0, which is the $MFT itself:</p><div class="mediaobject"><img src="graphics/image_06_007.jpg" alt="istat"/><div class="caption"><p>The istat tool to view the metadata of a file</p></div></div></div><div class="section" title="icat"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec5"/>icat</h3></div></div></div><p>This is used to view the contents of a specific data unit. It uses the inode number as a reference to view the data blocks that are related to this file. In the forensic image under investigation, we will view the contents of the $MFT file with inode 0:</p><div class="mediaobject"><img src="graphics/image_06_008.jpg" alt="icat"/><div class="caption"><p>Contents of the $MFT file</p></div></div><p>In some cases, recovery of deleted files will be useful to the case under investigation. We can use the icat tool to copy the contents of any deleted file to another file in the investigator machine for further analysis. For the $MFT file, there are some other tools, which can parse the MFT file individually and list the contents of the filesystem in tree view:</p><div class="mediaobject"><img src="graphics/image_06_009.jpg" alt="icat"/><div class="caption"><p>Using icat to copy contents of a deleted file</p></div></div></div><div class="section" title="ifind"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec6"/>ifind</h3></div></div></div><p>During the analysis, if the investigator, for instance, conducted a word search and got a hit in one of the data units in the partition, they would now need to link this data unit to an entry in the filesystem, and <code class="literal">ifind</code> is what they need. Unlike the previous tools, <code class="literal">ifind</code> can take a data unit number or filename as an input and map this input to the equivalent entry in the filesystem to collect other information about this file. In our case, we will try to find the <code class="literal">hiberfile.sys</code>.</p><p>To search with the name, we need to use the <code class="literal">--n</code> option:</p><div class="mediaobject"><img src="graphics/image_06_010.jpg" alt="ifind"/><div class="caption"><p>ifind to search by filename</p></div></div><p>The result shows that the inode number related to the file named <code class="literal">hiberfil.sys</code> is <code class="literal">563</code>. Using <code class="literal">istat</code> again to view the information related to this file will reveal information about this file:</p><div class="mediaobject"><img src="graphics/image_06_011.jpg" alt="ifind"/><div class="caption"><p>Full information about the file with inode 563</p></div></div><p>The <code class="literal">hiberfil.sys</code> file is the copy of memory stored to the hard drive when the user elects to use the hibernate option of the machine in case of a dead system analysis. This file can provide a great benefit to the investigator as it provides them with a snapshot of the memory during the last usage of hibernation that can be provided from the timestamp of this file. As we can see, this file is an allocated file, and it can be extracted from the image like we did earlier with the $MFT file, and then used in memory analysis.</p><p>In case we need to use the ifind tool with the data unit number, we need to use the -d option. We will get another unique ID, describing the location of the file in the image. This unique ID will be discussed in the next part, the filename layer. In this example, we used the data unit ID of 3269280, which is one of the data units of the <code class="literal">hiberfil.sys</code> file:</p><div class="mediaobject"><img src="graphics/image_06_012.jpg" alt="ifind"/><div class="caption"><p>A data block address with ifind</p></div></div></div></div><div class="section" title="The filename layer"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec65"/>The filename layer</h2></div></div></div><p>Tools work in this layer to list the file structure in the hard drive image. Each file will be assigned a unique ID, which can be used with other tools to especially target this file.</p><p>To list the files under the partition, we only need to provide the partition offset to the tool:</p><div class="mediaobject"><img src="graphics/image_06_013.jpg" alt="The filename layer"/><div class="caption"><p>The fls tools to browse the partition contents</p></div></div><p>In the preceding figure, we can see the deleted <code class="literal">hiberfil.sys</code> with a metadata address of 57745 and the allocated one with a metadata address of 563.</p><p>In case we need to browse another directory (for example, the Users directory), we can provide the tool with the Users directory's unique ID (457-144-5):</p><div class="mediaobject"><img src="graphics/image_06_014.jpg" alt="The filename layer"/><div class="caption"><p>Using the directory ID for content listing with the fls tool</p></div></div><p>As we can see here, we are browsing through the contents of the image without mounting any partition or filesystem to the running OS.</p><p>The ffind tool is only used to map the metadata address to the filename, either its related file was deleted or allocated:</p><div class="mediaobject"><img src="graphics/image_06_015.jpg" alt="The filename layer"/><div class="caption"><p>Mapping metadata address to its filename</p></div></div></div><div class="section" title="Data unit layer (Block)"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec66"/>Data unit layer (Block)</h2></div></div></div><p>In this layer, the actual contents of the file are stored. The metadata of the file must point to the location of the file contents in this area, as we discussed before with the <code class="literal">ifind</code> tool.</p><div class="section" title="blkcat"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec7"/>blkcat</h3></div></div></div><p>This is used to display the contents of the specific data unit in the image. Let's say we need to display the first data unit of the <code class="literal">ntdll.dll</code> file in a Windows directory. First, we can find the metadata address for this file using the <code class="literal">ils</code> tool and grep with the <code class="literal">ntdll.dll</code> filename:</p><div class="mediaobject"><img src="graphics/image_06_016.jpg" alt="blkcat"/><div class="caption"><p>The metadata address for the ntdll.dll file</p></div></div><p>From the results, one of the <code class="literal">ntdll.dll</code> files has the metadata address of <code class="literal">25833</code>. The second step is to use the <code class="literal">istat</code> tool to find the allocated data units to this file using its metadata address:</p><div class="mediaobject"><img src="graphics/image_06_017.jpg" alt="blkcat"/><div class="caption"><p>Full information about the ntdll.dll file from the istat tool</p></div></div><p>The result shows that the first data unit of the file has the number of <code class="literal">1118226</code>. What we need to do now is use the <code class="literal">blkcat</code> tool to view the contents of this data unit. We will use the <code class="literal">--h</code> option to view the contents in hex view:</p><div class="mediaobject"><img src="graphics/image_06_018.jpg" alt="blkcat"/><div class="caption"><p>Using blkcat to display the contents of one data unit</p></div></div></div><div class="section" title="blkls"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec8"/>blkls</h3></div></div></div><p>The default of this tool is to display the unallocated clusters in an image file for further analysis, such as file carving and recovery. If we used this tool with the -e option, it will collect all the blocks of one filesystem, which is useful if we need to extract one partition from a multi-partitions larger image. Here, we need to only collect all the unallocated space in the image and direct the output to a file called <code class="literal">unallocated.blkls</code> on to the screen.</p><p>The resulting file will be in the same size of free space in the partition. Then, further analysis can be done on this file:</p><div class="mediaobject"><img src="graphics/image_06_019.jpg" alt="blkls"/><div class="caption"><p>blkls to collect all unallocated space in a single file</p></div></div></div><div class="section" title="Blkcalc"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec9"/>Blkcalc</h3></div></div></div><p>To understand the purpose of this tool, let's suppose some analysis on the unallocated space has been conducted, such as a keyword search, and a match that is related to the case under investigation is found. To map the founded location to the full image, we need to use the <code class="literal">blkcalc</code> tool.</p></div></div></div>
<div class="section" title="Autopsy"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec39"/>Autopsy</h1></div></div></div><p>Autopsy is a web-based interface for TSK, which uses the same tools in TSK and presents the results in a graphical interface. To conduct analysis with TSK, the investigator needs to start the server first from the command line. After starting the autopsy, it will give the investigator the URL to access it from the Internet, which in this case is <code class="literal">http://localhost:9999/autopsy</code>. Don't shut down the process of the autopsy during the analysis; otherwise, the analysis won't be active:</p><div class="mediaobject"><img src="graphics/image_06_020.jpg" alt="Autopsy"/><div class="caption"><p>Starting Autopsy</p></div></div><p>Then, from the browser, open that URL to start creating the case:</p><div class="mediaobject"><img src="graphics/image_06_021.jpg" alt="Autopsy"/><div class="caption"><p>Autopsy interface</p></div></div><p>We need to create a new case, and then enter some information about the case to make it easy for the investigator to follow up about the cases and who is working on each case:</p><div class="mediaobject"><img src="graphics/image_06_022.jpg" alt="Autopsy"/><div class="caption"><p>Creating a new case</p></div></div><p>After creating the case, a directory for this case will be created by default at <code class="literal">/var/lib/autopsy</code> (which is named after the case name), including all the files of the case. What we did is just create the case; now, we need to add all the hosts related to the case and add the image that we previously acquired from each host. We need to do this to follow up with the results of the analysis and to be able to differentiate between the sources of the results.</p><p>If the case under investigation took place in different time zones, that is, it includes hard drives which were running under different time zones, it is a very good idea to adjust the time zone of each host to get normalized results:</p><div class="mediaobject"><img src="graphics/image_06_023.jpg" alt="Autopsy"/><div class="caption"><p>Adding a host to the case</p></div></div><p>After adding a host, we need to map the host to an image:</p><div class="mediaobject"><img src="graphics/image_06_024.jpg" alt="Autopsy"/><div class="caption"><p>Mapping the host to a forensic image</p></div></div><p>After this, you need to map each host to its corresponding image. You need to enter the path to the image and specify whether it is a disk image or partition image. In our case, it is a complete disk image. We have the option to work with the same image and use only a symbolic link to it, or just copy or move this image:</p><div class="mediaobject"><img src="graphics/image_06_025.jpg" alt="Autopsy"/><div class="caption"><p>Adding an image to the host</p></div></div><p>Then, automatically, this will list all the allocated partitions in this image with the start and end of each one in a sector. This is the same result we got from using the <code class="literal">mmls</code> tool in the command line where it asked us to select the mount point of each partition. In our case, we have only one NTFS partition, and we will mount this one as <code class="literal">C:</code> partition:</p><div class="mediaobject"><img src="graphics/image_06_026.jpg" alt="Autopsy"/><div class="caption"><p>Mounting the allocated partition to the case</p></div></div><p>A confirmation message will summarize the configuration that you established:</p><div class="mediaobject"><img src="graphics/image_06_027.jpg" alt="Autopsy"/><div class="caption"><p>Confirmation message</p></div></div><p>Then, a home page for the case will be shown from where the investigator can select what he needs to do with the partition or the whole disk image:</p><div class="mediaobject"><img src="graphics/image_06_028.jpg" alt="Autopsy"/><div class="caption"><p>Start analysis on the case</p></div></div><p>Now, we will go with the <code class="literal">C:</code> partition, it is the equivalent of specifying the offset with <code class="literal">-o</code> option in each command that we used in the command line tools, where we provided the offset of the working partition. Here, the upcoming analysis will target the contents of the <code class="literal">C:</code> partition.</p><p>After stating the analysis, the investigator will find some tabs targeting all the layers of investigation that we mentioned before, such as the file analysis, metadata analysis, and data clusters analysis. However, the command line tools are still better for results customization. For example, if we need to redo what we did with the <code class="literal">ntdll.dll</code> file using autopsy, we need to first search for the filename from the file analysis tab:</p><div class="mediaobject"><img src="graphics/image_06_029.jpg" alt="Autopsy"/><div class="caption"><p>Search for the file by name</p></div></div><p>We now have the metadata number <code class="literal">25833</code>. You can either click on this number or under the <span class="strong"><strong>Meta Data</strong></span> tab to search for this number. This will list all the information of this file, including all the clusters that hold the contents of this file. We are interested in the first cluster number 1118226 as shown in the following image:</p><div class="mediaobject"><img src="graphics/image_06_030.jpg" alt="Autopsy"/><div class="caption"><p>Listing the metadata information with the metadata ID</p></div></div><p>Then, in the same way, either click on the cluster number or type its number under the DATA UNIT tab, it will display the contents the file in ASCII, Hex, or ASCII Strings views:</p><div class="mediaobject"><img src="graphics/image_06_031.jpg" alt="Autopsy"/><div class="caption"><p>Listing the contents of cluster by cluster number</p></div></div><p>We can see the status of the cluster is allocated and the signature of the file as before in its hex view is <code class="literal">0x4D5A</code> (MZ).</p></div>
<div class="section" title="Foremost"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec40"/>Foremost</h1></div></div></div><p>With TSK, we could find and recover the deleted files. These deleted files still have their information in the metadata area, which is why we could identify their information and know their location in the data area. This leaves us with a simple step to recover these files by redirecting the contents of each file to a new file. What if there are no entries for the deleted file, and we only have the contents of the file in the data area and no metadata about this file (which under this assumption will be in the unallocated area of the hard drive)? In this case, the file carving technique will be useful to recover such files.</p><p>Each file has a different type, such as Microsoft Office, Adobe, exe, and AVI. The extension at the end of the filename is not what is needed to differentiate between one file type and another. There is a header in the beginning of each file which differs from one type to another. Some file types have a footer in the end of the file, but this is not mandatory. File carving techniques use these headers and footers to carve and identify the locations of the files in the unallocated area of the image or hard drive to recover these files.</p><p><span class="strong"><strong>Foremost</strong></span> is a Linux tool that is used to recover data based on file carving techniques. We can apply foremost to all the images, but we already know that the carving will work on the unallocated area. So, why don't we apply foremost against the unallocated area as a single file? This single file was produced from the image using the <code class="literal">blkls</code> tool from <code class="literal">tsk</code> named as <code class="literal">unallocated.blkls</code>. We can carve this produced file from the hard drive to find the deleted files, if there are any.</p><p>The output of foremost is different directories under the working directory, which are named after each file type when using the <code class="literal">--o</code> option. As we know that each file will start at the beginning of a cluster, we don't need to search the rest of the cluster contents. We can use the <code class="literal">--q</code> option to search the beginning of the clusters only for quick results:</p><div class="mediaobject"><img src="graphics/image_06_032.jpg" alt="Foremost"/><div class="caption"><p>Foremost to carve the unallocated area in the image</p></div></div><p>Then, in the results of running this tool, we will find that one <code class="literal">audit.txt</code> file and one PDF directory were created under the foremost-results directory. Opening the <code class="literal">audit.txt</code> file will show us some information about the process of file carving, such as the time, size, and the extracted files. In our case, one single PDF file was extracted from the unallocated area in this image:</p><div class="mediaobject"><img src="graphics/image_06_033.jpg" alt="Foremost"/><div class="caption"><p>Extracted files by foremost</p></div></div><p>Due to the absence of the metadata of this file as we discussed before, we won't be able to know any information about this file except for the size and the contents of this file. This PDF file was created for testing purposes and we assumed that it contains evidential data related to the case under investigation:</p><div class="mediaobject"><img src="graphics/image_06_034.jpg" alt="Foremost"/><div class="caption"><p>Extracted PDF file</p></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec41"/>Summary</h1></div></div></div><p>In this chapter, we saw how the files are organized in the filesystem, and how it differs from FAT to NTFS. Then, we learned about reading files from a forensic image using TSK and its GUI Autopsy. We also discussed file carving and how to recover a file, based on its signature using Foremost.</p><p>In the next chapter, we will learn about Windows registry—a complex yet very important artifact in the Windows operating system. We will learn about registry structure, and its important value to the investigation and different tools to parse and analyze the registry.</p></div></body></html>