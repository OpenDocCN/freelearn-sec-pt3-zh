<html><head></head><body><div><h1 class="header-title">RE for Windows Platforms</h1>
                
            
            
                
<p>With Windows being one of the most popular operating systems in the world, most software in the cyber world has been written for it. This includes malware.</p>
<p>This chapter focuses on the analysis of the Windows native executable, the PE file, and evolves directly by doing file analysis, that is, gathering static information and performing dynamic analysis. We will dig deeper into understanding how the PE file behaves with the Windows operating system. The following topics will be covered in this chapter:</p>
<ul>
<li>Analyzing Windows PE</li>
<li>Tools</li>
<li>Static analysis</li>
<li>Dynamic analysis</li>
</ul>


            

            
        
    </div>



  
<div><h1 class="header-title">Technical requirements</h1>
                
            
            
                
<p>This chapter requires knowledge of the Windows environment and its administration. The reader should also know how to use commands in Command Prompt. The first portion of this chapter requires the user to have basic knowledge of building and compiling C programs using Visual Studio or similar software.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Hello World</h1>
                
            
            
                
<p>Programs in the Windows environment communicate with the system by using Windows APIs. These APIs are built around the file system, memory management (including processes, the stack, and allocations), the registry hive, network communication, and so forth. Regarding reverse engineering, a wide coverage of these APIs and their library modules is a good advantage when it comes to easily understanding how a program works when seen in its low-level language equivalent. So, the best way to begin exploring APIs and their libraries would be to develop some programs ourselves.</p>
<p class="mce-root"/>
<p>There are many high-level languages used by developers like C, C++, C#, and Visual Basic.  C, C++, and Visual Basic (native) compile to an executable that directly executes instructions in the x86 language. C# and Visual Basic (<kbd>p-code</kbd>) are usually compiled to use interpreters as a layer that turns the p-code into actual x86 instructions. For this chapter, we will focus on executable binaries compiled from C/C++ and assembly language. The goal is to have a better understanding of the behavior of programs that use Windows APIs.</p>
<p>For this chapter, our choice for building C/C++ programs will be the Visual Studio Community edition. Visual Studio is widely used for building Microsoft Windows programs. Given that it is also a product of Microsoft, it already contains the compatible libraries required to compile programs. You can download and install Visual Studio Community edition from <a href="https://visualstudio.microsoft.com/downloads/">https://visualstudio.microsoft.com/downloads/</a>.</p>
<p>These programs are neither harmful nor malicious. The following C programming activities can be done with Visual Studio in a bare metal machine. In case you are planning on installing Visual Studio in a Windows VM, at the time of writing this book, Visual Studio 2017 Community edition has the following recommended system requirements:</p>
<ul>
<li>1.8 GHz dual core</li>
<li>4 GB of RAM</li>
<li>130 GB of disk space</li>
</ul>
<p>These system requirements can be found at <a href="https://docs.microsoft.com/en-us/visualstudio/productinfo/vs2017-system-requirements-vs">https://docs.microsoft.com/en-us/visualstudio/productinfo/vs2017-system-requirements-vs</a>. You may need to perform some Windows updates and install the .NET framework. This can also be installed from the Windows 7 setup that we previously downloaded from <a href="https://developer.microsoft.com/en-us/microsoft-edge/tools/vms/">https://developer.microsoft.com/en-us/microsoft-edge/tools/vms/</a> . Please visit the Microsoft Visual Studio website for the requirements of newer versions.</p>
<p>There are many Visual Studio alternatives that have minimal requirements like Bloodshed Dev C++, Zeus IDE, and Eclipse. However, some of these IDE may not be up-to-date and/or may need to the compiler and its dependencies to have been properly set up.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Learning about the APIs</h1>
                
            
            
                
<p>We'll be skipping <kbd>Hello World</kbd> here since we have already made one in the previous chapters. Instead, we'll be looking into the following example programs:</p>
<ul>
<li>A keylogger saved to a <kbd>filez</kbd></li>
<li>Enumerating a registry key and printing it out</li>
<li>List processes and printing out</li>
<li>Encrypting data and storing it in a file</li>
<li>Decrypting an encrypted file</li>
<li>Listening to port <kbd>9999</kbd> and sending back a message when connected</li>
</ul>
<p>The source code for these programs can be found at <a href="https://github.com/PacktPublishing/Mastering-Reverse-Engineering/tree/master/ch7">https://github.com/PacktPublishing/Mastering-Reverse-Engineering/tree/master/ch7</a>. Feel free to play with these programs, add your own code, or even create your own version. The aim here is to get you to learn how these APIs work, hand in hand.</p>
<p>One of the keys to determining how a program behaves is to learn how APIs are used. The use of each API is documented in the Microsoft Developer Network (MSDN) library. The programs we are about to look into are just examples of program behaviors. We use these APIs to build upon these behaviors. Our goal here is to learn how these APIs are used and interact with each other. </p>
<p>As a reverse engineer, it is expected and required for the reader to use the MSDN or other resources to further understand the details on how the API works. The API name can be searched in the MSDN library at <a href="https://msdn.microsoft.com">https://msdn.microsoft.com</a>.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Keylogger</h1>
                
            
            
                
<p>A keylogger is a program that logs what keys have been pressed by a user. The log is usually stored in a file. The core API used here is <kbd>GetAsyncKeyState</kbd>. Every button that can be pressed from the keyboard or the mouse has an assigned ID called a virtual key code. Specifying a virtual key code, the <kbd>GetAsyncKeyState</kbd> gives information about whether the key has been pressed or not. </p>
<p>The source code for this program can be found at <a href="https://github.com/PacktPublishing/Mastering-Reverse-Engineering/blob/master/ch7/keylogger.cpp">https://github.com/PacktPublishing/Mastering-Reverse-Engineering/blob/master/ch7/keylogger.cpp</a>.</p>
<p>For keylogging to work, we will need to check the state of each virtual key code and run them in a loop. Once a key has been identified as pressed, the virtual key code gets stored into a file. The following code does just that:</p>
<pre>  while (true) {<br/> for (char i = 1; i &lt;= 255; i++) {<br/> if (GetAsyncKeyState(i) &amp; 1) {<br/> sprintf_s(lpBuffer, "\\x%02x", i);<br/> LogFile(lpBuffer, (char*)"log.txt");<br/> }<br/> }</pre>
<p class="mce-root"/>
<p><kbd>LogFile</kbd> here is a function that accepts two parameters: the data that it writes and the file path of the log file. <kbd>lpBuffer</kbd> contains the data and is formatted by the <kbd>sprintf_s</kbd> API as <kbd>\\x%02x</kbd>. As a result, the format converts any numbers into a two-digit hexadecimal string. The number 9 becomes <kbd>\x09</kbd>, and the number 106 becomes <kbd>\x6a</kbd>. </p>
<p>All we need are three Windows API functions to implement the storage of data to a log file – <kbd>CreateFile</kbd>, <kbd>WriteFile</kbd>, and <kbd>CloseHandle</kbd> – as shown in the following code:</p>
<pre>void LogFile(char* lpBuffer, LPCSTR fname) {<br/><br/>  BOOL bErrorFlag;<br/>  DWORD dwBytesWritten;<br/><br/>  HANDLE hFile = CreateFileA(fname, FILE_APPEND_DATA, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);<br/>  bErrorFlag = WriteFile(hFile, lpBuffer, strlen(lpBuffer), &amp;dwBytesWritten, NULL);<br/>  CloseHandle(hFile);<br/><br/>  return;_<br/>}</pre>
<p><kbd>CreateFileA</kbd> is used to create or open a new file given the filename and how the file will be used. Since the purpose of this exercise is to continuously log the virtual key codes of pressed keys, we need to open the file in append mode (<kbd>FILE_APPEND_DATA</kbd>). A file handle is returned to <kbd>hFile</kbd> and is used by <kbd>WriteFile</kbd>. <kbd>lpBuffer</kbd> contains the formatted virtual key code. One of the parameters <kbd>WriteFile</kbd> requires is the size of the data to be written. The <kbd>strlen</kbd> API was used here to determine the length of the data. Finally, the file handle is closed using the <kbd>CloseHandle</kbd>. It is important to close file handles to make the file available for use.</p>
<p>There are different keyboard variants that cater to the language of the user. Thus, different keyboards may have different virtual key codes. At the start of the program, we used <kbd>GetKeyboardLayoutNameA(lpBuffer)</kbd> to identify the type of keyboard being used.  When reading the log, the type of keyboard will be used as a reference to properly identify which keys were pressed.</p>
<p class="mce-root"/>


            

            
        
    </div>



  
<div><h1 class="header-title">regenum</h1>
                
            
            
                
<p>The <kbd>regenum</kbd> program, as mentioned below, aims to enumerate all values and data in a given registry key. The parameters required for the APIs depend on the result of the previous APIs. Just like how we were able to write data to a file in the keylogger program, registry enumerating APIs also require a handle. In this case, a handle to the registry key is used by the <kbd>RegEnumValueA</kbd> and <kbd>RegQueryValueExA</kbd> APIs.</p>
<p>The source code for this program can be found at <a href="https://github.com/PacktPublishing/Mastering-Reverse-Engineering/blob/master/ch7/regenum.cpp">https://github.com/PacktPublishing/Mastering-Reverse-Engineering/blob/master/ch7/regenum.cpp</a>.</p>
<pre>int main()<br/>{<br/> LPCSTR lpSubKey = "Software\\Microsoft\\Windows\\CurrentVersion\\Run";<br/> HKEY hkResult;<br/> DWORD dwIndex;<br/> char ValueName[1024];<br/> char ValueData[1024];<br/> DWORD cchValueName;<br/> DWORD result;<br/> DWORD dType;<br/> DWORD dataSize;<br/> HKEY hKey = HKEY_LOCAL_MACHINE;<br/><br/> if (RegOpenKeyExA(hKey, lpSubKey, 0, KEY_READ, &amp;hkResult) == ERROR_SUCCESS)<br/> {<br/> printf("HKEY_LOCAL_MACHINE\\%s\n", lpSubKey);<br/> dwIndex = 0;<br/> result = ERROR_SUCCESS;<br/> while (result == ERROR_SUCCESS)<br/> {<br/> cchValueName = 1024;<br/> result = RegEnumValueA(hkResult, dwIndex, (char *)&amp;ValueName, &amp;cchValueName, NULL, NULL, NULL, NULL);<br/> if (result == ERROR_SUCCESS)<br/> {<br/> RegQueryValueExA(hkResult, ValueName, NULL, &amp;dType, (unsigned char *)&amp;ValueData, &amp;dataSize);<br/> if (strlen(ValueName) == 0)<br/> sprintf((char*)&amp;ValueName, "%s", "(Default)");<br/> printf("%s: %s\n", ValueName, ValueData);<br/> }<br/> dwIndex++;<br/> }<br/> RegCloseKey(hkResult);<br/> }<br/> return 0;<br/>}</pre>
<p>The enumeration begins by retrieving a handle for the registry key via <kbd>RegOpenKeyExA</kbd>. A successful return value should be non-zero, while its output should show a handle stored in <kbd>hkResult</kbd>. The registry key that is being targeted here is <kbd>HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Run</kbd>.</p>
<p>The handle in <kbd>hkResult</kbd> is used by <kbd>RegEnumValueA</kbd> to begin enumerating each registry value under the registry key. Subsequent calls to <kbd>RegEnumValueA</kbd> gives the next registry value entry. This block of code is therefore placed in a loop until it fails to return an <kbd>ERROR_SUCCESS</kbd> result. An <kbd>ERROR_SUCCESS</kbd> result means that a registry value was successfully retrieved.</p>
<p>For every registry value, <kbd>RegQueryValueExA</kbd> is called. Remember that we only go the registry value, but not its respective data. Using <kbd>RegQueryValueExA</kbd>, we should be able to acquire the registry data.</p>
<p>Finally, we have to close the handle by using <kbd>RegCloseKey</kbd>.</p>
<p>Other APIs that are used here are <kbd>printf</kbd>, <kbd>strlen</kbd>, and <kbd>sprintf</kbd>. <kbd>printf</kbd> was used in the program to print the target registry key, value, and data to the command-line console. <kbd>strlen</kbd> was used to get the text string length. Every registry key has a default value. Since <kbd>RegEnumValueA</kbd> will return <kbd>ERROR_SUCCEPantf</kbd>, we are able to replace the <kbd>ValueName</kbd> variable with a string called <kbd>(Default)</kbd>:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1021 image-border" src="img/3fd38a99-d50a-449c-8af2-5b5cd45d5fa6.png" style="width:83.08em;height:9.75em;" width="997" height="117"/></p>


            

            
        
    </div>



  
<div><h1 class="header-title">processlist</h1>
                
            
            
                
<p>Similar to how enumerating registry values works, listing processes also works on the same concept. Since the processes in real-time change fast, a snapshot of the process list needs to be taken. The snapshot contains a list of process information at the time the snapshot was taken. The snapshot can be taken using <kbd>CreateToolhelp32Snapshot</kbd>. The result is stored in <kbd>hSnapshot</kbd>, which is the snapshot handle. </p>
<p>To begin enumerating the list, <kbd>Process32First</kbd> is used to acquire the first process information from the list. This information is stored in the <kbd>pe32</kbd> variable, which is a <kbd>PROCESSENTRY32</kbd> type. Subsequent process information is retrieved by calling <kbd>Process32Next</kbd>. <kbd>CloseHandle</kbd> is finally used when done with the list.</p>
<p>Again, <kbd>printf</kbd> is used to print out the executable file name and the process ID:</p>
<pre>int main()<br/>{<br/>  HANDLE hSnapshot;<br/>  PROCESSENTRY32 pe32;<br/><br/>  hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);<br/>  pe32.dwSize = sizeof(PROCESSENTRY32);<br/><br/>  if (Process32First(hSnapshot, &amp;pe32))<br/>  {<br/>    printf("\nexecutable [pid]\n");<br/>    do<br/>    {<br/>      printf("%ls [%d]\n", pe32.szExeFile, pe32.th32ProcessID);<br/>    } while (Process32Next(hSnapshot, &amp;pe32));<br/>    CloseHandle(hSnapshot);<br/>  }<br/>    return 0;<br/>}</pre>
<p>The source code for this program can be found at <a href="https://github.com/PacktPublishing/Mastering-Reverse-Engineering/blob/master/ch7/processlist.cpp">https://github.com/PacktPublishing/Mastering-Reverse-Engineering/blob/master/ch7/processlist.cpp</a>.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    </div>



  
<div><h1 class="header-title">Encrypting and decrypting a file</h1>
                
            
            
                
<p>Ransomware has been one of the most popular malware to spread out globally. Its core element is being able to encrypt files.</p>
<p>In these encrypt and decrypt programs, we are going to learn about some of the basic APIs used in encryption and decryption.  </p>
<p>The API used to encrypt is <kbd>CryptEncrypt</kbd>, while <kbd>CryptDecrypt</kbd> is used for decryption. However, these APIs require at least a handle to the encryption key. To obtain the handle to the encryption key, a handle to the <strong>Cryptographic Service Provider</strong> (<strong>CSP</strong>) is required. In essence, before calling <kbd>CryptEncrypt</kbd> or <kbd>CryptDecrypt</kbd>, calling a couple of APIs is required to set up the algorithm that will be used.</p>
<p>In our program, <kbd>CryptAcquireContextA</kbd> is used to get a <kbd>CryptoAPI</kbd> handle of a key container from a CSP. It is in this API where the algorithm, AES, is indicated. The key that the encryption will be using will be controlled by a user-defined password which is set in the <kbd>password[]</kbd> string. To get a handle to the derived key, the APIs <kbd>CryptCreateHash</kbd>, <kbd>CryptHashData</kbd>, and <kbd>CryptDeriveKey</kbd> are used while passing the user-defined <kbd>password</kbd> to <kbd>CryptHashData</kbd>. The data to be encrypted and assigned in the <kbd>buffer</kbd> variable,is passed to <kbd>CryptEncrypt</kbd>. The resulting encrypted data is written in the same data buffer, overwriting it in the process:</p>
<pre>int main()<br/>{<br/>  unsigned char buffer[1024] = "Hello World!";<br/>  unsigned char password[] = "this0is0quite0a0long0cryptographic0key";<br/>  DWORD dwDataLen;<br/>  BOOL Final;<br/><br/>  HCRYPTPROV hProv;<br/><br/>  printf("message: %s\n", buffer);<br/>  if (CryptAcquireContextA(&amp;hProv, NULL, NULL, PROV_RSA_AES, CRYPT_VERIFYCONTEXT))<br/>  {<br/>    HCRYPTHASH hHash;<br/>    if (CryptCreateHash(hProv, CALG_SHA_256, NULL, NULL, &amp;hHash))<br/>    {<br/>      if (CryptHashData(hHash, password, strlen((char*)password), NULL))<br/>      {<br/>        HCRYPTKEY hKey;<br/>        if (CryptDeriveKey(hProv, CALG_AES_128, hHash, NULL, &amp;hKey))_<br/>        {<br/>          Final = true;<br/>          dwDataLen = strlen((char*)buffer);<br/>          if (CryptEncrypt(hKey, NULL, Final, NULL, (unsigned char*)&amp;buffer, &amp;dwDataLen, 1024))<br/>          {<br/>            printf("saving encrypted buffer to message.enc");<br/>            LogFile(buffer, dwDataLen, (char*)"message.enc");<br/>          }<br/>          printf("%d\n", GetLastError());<br/>          CryptDestroyKey(hKey);<br/>        }<br/>      }<br/>      CryptDestroyHash(hHash);<br/>    }<br/>    CryptReleaseContext(hProv, 0);<br/>  }<br/>  return 0;<br/>}</pre>
<p>Using the modified version of the <kbd>LogFile</kbd> function, which now includes the size of the data to write, the encrypted data is stored in the <kbd>message.enc</kbd> file:</p>
<pre>void LogFile(unsigned char* lpBuffer, DWORD buflen, LPCSTR fname) {<br/><br/>  BOOL bErrorFlag;<br/>  DWORD dwBytesWritten;<br/><br/>  DeleteFileA(fname);<br/><br/>  HANDLE hFile = CreateFileA(fname, FILE_ALL_ACCESS, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);<br/>  bErrorFlag = WriteFile(hFile, lpBuffer, buflen, &amp;dwBytesWritten, NULL);<br/>  CloseHandle(hFile);<br/><br/>  Sleep(10);<br/><br/>  return;<br/>}</pre>
<p class="mce-root"/>
<p>To gracefully close the <kbd>CryptoAPI</kbd> handles, <kbd>CryptDestroyKey</kbd>, <kbd>CryptDestroyHash</kbd>, and <kbd>CryptReleaseContext</kbd> are used.</p>
<p>The encrypted message <kbd>Hello World!</kbd> will now look like this:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1022 image-border" src="img/a1321858-fd88-4cbb-9dcc-a106625f8811.png" style="width:70.42em;height:8.00em;" width="845" height="96"/></p>
<p>The way to decrypt the message is to use the same <kbd>CryptoAPIs</kbd>, but now use <kbd>CryptDecrypt</kbd>. This time, the contents of <kbd>message.enc</kbd> is read to the data buffer, decrypted, and then stored in <kbd>message.dec</kbd>. The CryptoAPIs are used in the same way as they were for acquiring the key handle. The buffer length stored in <kbd>dwDataLen</kbd> should initially contain the maximum length of the buffer:</p>
<pre>int main()<br/>{<br/>  unsigned char buffer[1024];<br/>  unsigned char password[] = "this0is0quite0a0long0cryptographic0key";<br/>  DWORD dwDataLen;<br/>  BOOL Final;<br/><br/>  DWORD buflen;<br/>  char fname[] = "message.enc";<br/>  HANDLE hFile = CreateFileA(fname, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);<br/>  ReadFile(hFile, buffer, 1024, &amp;buflen, NULL);<br/>  CloseHandle(hFile);<br/><br/>  HCRYPTPROV hProv;<br/><br/>  if (CryptAcquireContextA(&amp;hProv, NULL, NULL, PROV_RSA_AES, CRYPT_VERIFYCONTEXT))<br/>  {<br/>    HCRYPTHASH hHash;<br/>    if (CryptCreateHash(hProv, CALG_SHA_256, NULL, NULL, &amp;hHash))<br/>    {<br/>      if (CryptHashData(hHash, password, strlen((char*)password), NULL))<br/>      {<br/>        HCRYPTKEY hKey;<br/>        if (CryptDeriveKey(hProv, CALG_AES_128, hHash, NULL, &amp;hKey))<br/>        {<br/>          Final = true;<br/>          dwDataLen = buflen;<br/>          if ( CryptDecrypt(hKey, NULL, Final, NULL, (unsigned char*)&amp;buffer, &amp;dwDataLen) )<br/>          {<br/>            printf("decrypted message: %s\n", buffer);<br/>            printf("saving decrypted message to message.dec");<br/>            LogFile(buffer, dwDataLen, (char*)"message.dec");<br/>          }<br/>          printf("%d\n", GetLastError());<br/>          CryptDestroyKey(hKey);<br/>        }<br/>      }<br/>      CryptDestroyHash(hHash);<br/>    }<br/>    CryptReleaseContext(hProv, 0);<br/>  }<br/>  return 0;<br/>}<br/><br/></pre>
<div><img class="alignnone size-full wp-image-1023 image-border" src="img/66ef97e5-3570-4b6d-95c1-b2ca7bdcccb1.png" style="width:71.33em;height:8.17em;" width="856" height="98"/></div>
<p>The source code for the encryption and decryption programs can be found at the following links:<br/>
<br/> Encryption: <a href="https://github.com/PacktPublishing/Mastering-Reverse-Engineering/blob/master/ch7/encfile.cpp">https://github.com/PacktPublishing/Mastering-Reverse-Engineering/blob/master/ch7/encfile.cpp</a>.<br/>
<br/>
Decryption: <a href="https://github.com/PacktPublishing/Mastering-Reverse-Engineering/blob/master/ch7/decfile.cpp">https://github.com/PacktPublishing/Mastering-Reverse-Engineering/blob/master/ch7/decfile.cpp</a>.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">The server</h1>
                
            
            
                
<p>In <em><a href="079c24b7-4a53-4894-8890-74f9e16d53b9.xhtml">Chapter 6</a>, RE in Linux Platforms</em>, we learned about using socket APIs to control network communication between a client and a server. The same code can be implemented for the Windows operating system. For Windows, the socket library needs to be initiated by using the <kbd>WSAStartup</kbd> API before using socket APIs. In comparison to Linux functions, instead of using <kbd>write</kbd>, <kbd>send</kbd> is used to send data back to the client. Also, regarding <kbd>close</kbd>, the equivalent of this is <kbd>closesocket</kbd>, which is used to free up the socket handle.</p>
<p>Here's a graphical representation of how a server and a client generally communicate with the use of socket APIs.  Take note that the functions shown in the following diagram are Windows API functions:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1365 image-border" src="img/666541d2-4b6c-4946-ac7d-a0dfe3caf938.png" style="width:35.42em;height:24.08em;" width="654" height="444"/></p>
<p>The <kbd>socket</kbd> function is used to initiate a socket connection. When we're done with the connection, the communication is closed via the <kbd>closesocket</kbd> function.  The server requires that we <kbd>bind</kbd> the program with a network port. The <kbd>listen</kbd> and <kbd>accept</kbd> function is used to  wait for client connections. The send and <kbd>recv</kbd> functions are used for the data transfer between the server and the client. <kbd>send</kbd> is used to send data while <kbd>recv</kbd> is used to receive data. Finally,  <kbd>closesocket</kbd> is used to terminate the transmission. The code below shows an actual C source code of a server-side program that accepts connections and replies with <kbd>You have connected to the Genie. Nothing to see here</kbd><q>.</q></p>
<pre><br/>int main()<br/>{<br/> int listenfd = 0, connfd = 0;<br/> struct sockaddr_in serv_addr;<br/> struct sockaddr_in ctl_addr;<br/> int addrlen;<br/> char sendBuff[1025];<br/><br/> <br/> WSADATA WSAData;<br/><br/> if (WSAStartup(MAKEWORD(2, 2), &amp;WSAData) == 0)<br/> {<br/>     listenfd = socket(AF_INET, SOCK_STREAM, 0);<br/>     if (listenfd != INVALID_SOCKET)<br/>     {<br/>         memset(&amp;serv_addr, '0', sizeof(serv_addr));<br/>         memset(sendBuff, '0', sizeof(sendBuff));<br/>         serv_addr.sin_family = AF_INET;<br/>         serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);<br/>         serv_addr.sin_port = htons(9999);<br/>         if (bind(listenfd, (struct sockaddr*)&amp;serv_addr, sizeof(serv_addr)) == 0)<br/>         {<br/>             if (listen(listenfd, SOMAXCONN) == 0)<br/>             {<br/>                 printf("Genie is waiting for connections to port 9999.\n");<br/>                 while (1)<br/>                 {<br/>                     addrlen = sizeof(ctl_addr);<br/>                     connfd = accept(listenfd, (struct sockaddr*)&amp;ctl_addr, &amp;addrlen);<br/>                     if (connfd != INVALID_SOCKET)<br/>                     {<br/>                         printf("%s has connected.\n", inet_ntoa(ctl_addr.sin_addr));<br/><br/>                         snprintf(sendBuff, sizeof(sendBuff), "You have connected to the Genie. Nothing to see here.\n\n");<br/>                         send(connfd, sendBuff, strlen(sendBuff), 0);<br/>                         closesocket(connfd);<br/>                     }<br/>                 }<br/>             }<br/>         }<br/>     closesocket(listenfd);<br/>     }<br/> WSACleanup();<br/> }<br/> return 0;<br/>}</pre>
<p>The source code for this program can be found at <a href="https://github.com/PacktPublishing/Mastering-Reverse-Engineering/blob/master/ch7/server.cpp">https://github.com/PacktPublishing/Mastering-Reverse-Engineering/blob/master/ch7/server.cpp</a>.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">What is the password?</h1>
                
            
            
                
<p>In this section, we are going to reverse the <kbd>passcode.exe</kbd> program. As a practice run, we'll gather the information we need by using static and dynamic analysis tools. We'll use some of the Windows tools that were introduced in the previous chapters. Do not be limited by the tools that we are going to use here. There are a lot of alternatives that can do the same task.  The OS environment used to analyze this program is a Windows 10, 32-bit, 2 GB RAM, 2 core processor in a VirtualBox.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Static analysis</h1>
                
            
            
                
<p>The second piece of information that you'll need to know, next to knowing the filename, is the hash of the file. Let's pick Quickhash (<a href="https://quickhash-gui.org/">https://quickhash-gui.org/</a>) to help us with this task.  After opening the <kbd>passcode.exe</kbd> file using Quickhash, we can get the hash calculations for various algorithms.  The following screenshot shows the calculated <kbd>SHA256</kbd> hash for the <kbd>passcode.exe</kbd> file:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1024 image-border" src="img/e277180a-3544-4b33-8330-ebd5ccacd89a.png" style="width:55.42em;height:45.17em;" width="752" height="613"/></p>
<p>The file has a name extension of <kbd>.exe</kbd>. This initially sets us to use tools for analyzing Windows executable files. However, to make sure that this is indeed a Windows executable, let's use <kbd>TriD</kbd> to get the file type. <kbd>TrID</kbd> (<a href="http://mark0.net/soft-trid-e.html">http://mark0.net/soft-trid-e.html</a>) is console-based and should be run on the Command Prompt. We will also need to download and extract <kbd>TriD</kbd>'s definitions from<a href="http://mark0.net/download/triddefs.zip"> http://mark0.net/download/triddefs.zip</a>.  In the following screenshot, we used <kbd>dir</kbd> and <kbd>trid</kbd>. By using directory listing with <kbd>dir</kbd>, we were able to get the file's time stamp and file size.  With the <kbd>trid</kbd> tool, we were able to identify what type of file <kbd>passcode.exe</kbd> is:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1025 image-border" src="img/606a1727-d929-435c-9ef7-eed012c1cecf.png" style="width:43.33em;height:33.17em;" width="656" height="503"/></p>
<p class="mce-root"/>
<p>Now that we have verified that it is a Windows executable, using CFF Explorer should give us more file structure details. Download and install CFF Explorer from <a href="https://ntcore.com/">https://ntcore.com/</a>. Here is what you will see upon opening it: </p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1026 image-border" src="img/1b396fed-b7e9-405a-b57b-3a9deb72eeae.png" style="width:63.33em;height:37.42em;" width="760" height="449"/></p>
<p>Both <kbd>TrID</kbd> and CFF Explorer identified the file as a Windows executable, but are not agreeing on their decisions. This might be confusing since TrID identified the file as a <kbd>Win64 Executable</kbd> while CFF Explorer identified it as a <kbd>Portable Executable 32</kbd>.  This requires identifying the machine type from the PE header itself. The header reference for PE files can be viewed at <a href="http://www.microsoft.com/whdc/system/platform/firmware/PECOFF.mspx">http://www.microsoft.com/whdc/system/platform/firmware/PECOFF.mspx</a>.  </p>
<p class="mce-root"/>
<p>We can use CFF Explorer's <kbd>Hex Editor</kbd> to view the binary. The first column shows the file offset, the middle column shows the hexadecimal equivalent of the binary, and the right-most column shows the printable characters:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1028 image-border" src="img/ada629dc-e4d0-4abe-b076-717c6ed39dd9.png" style="width:73.25em;height:37.42em;" width="879" height="449"/></p>
<p>The file begins with the <kbd>MZ</kbd> magic header, or <kbd>0x4d5a</kbd>, denoting a Microsoft executable file. At file offset <kbd>0x3c</kbd>, the <kbd>DWORD</kbd> value, read in little endian, is <kbd>0x00000080</kbd>. This is the file offset where the PE header is expected to be located. The PE header begins with a <kbd>DWORD</kbd> value equivalent of <kbd>0x00004550</kbd> or <kbd>PE</kbd> followed by two null bytes. This is followed by a <kbd>WORD</kbd> value that tells you on which machine type the program can run on. In this program, we get <kbd>0x014c</kbd>, which is equivalent to <kbd>IMAGE_FILE_MACHINE_I386</kbd> and means that it runs in Intel 386 (a 32-bit microprocessor) processors or later, but also other compatible processors.</p>
<p>At this point, what we already know is as follows:</p>
<pre>Filename:  passcode.exe<br/>Filesize:  16,766 bytes<br/>MD5:  5D984DB6FA89BA90CF487BAE0C5DB300<br/>SHA256:  A5A981EDC9D4933AEEE888FC2B32CA9E0E59B8945C78C9CBD84085AB8D616568<br/>File Type: Windows PE 32-bit<br/>Compiler: MingWin32 - Dev C++</pre>
<p>To get to know the file better, let's run it in the sandbox.</p>
<p class="mce-root"/>


            

            
        
    </div>



  
<div><h1 class="header-title">A quick run</h1>
                
            
            
                
<p>From the VM, open Windows sandbox, and then drop and run a copy of <kbd>passcode.exe</kbd> in it: </p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1029 image-border" src="img/9c34cf4c-dfa0-4bc4-9ade-fe3a9a144677.png" style="width:53.58em;height:25.33em;" width="643" height="304"/></p>
<p>The program asks for a password. After guessing a password, the program suddenly closes. The information that we get from this event is as follows:</p>
<ul>
<li>The first piece of information is about the program asking for a password</li>
<li>The second piece of information is that it opens Command prompt</li>
</ul>
<p>This just means that the program should be run in the  Command prompt.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Deadlisting</h1>
                
            
            
                
<p>For the password, we may be able to find it in the text strings lying around the file itself. To get a list of strings from the file, we'll need to use SysInternal Suite's Strings (<a href="https://docs.microsoft.com/en-us/sysinternals/downloads/strings">https://docs.microsoft.com/en-us/sysinternals/downloads/strings</a>). Strings is a console-based tool. The list of strings at the output are printed out on the console.</p>
<p>The source code for this program can be found at <a href="https://github.com/PacktPublishing/Mastering-Reverse-Engineering/blob/master/ch7/passcode.c">https://github.com/PacktPublishing/Mastering-Reverse-Engineering/blob/master/ch7/passcode.c</a>.</p>
<p class="mce-root"/>
<p>We should redirect the output to a text file by running it as <kbd>strings.exe passcode.exe &gt; strings.txt</kbd>:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1030 image-border" src="img/5890e0a1-68bd-4337-98e9-363148a50ab4.png" style="width:62.08em;height:40.75em;" width="745" height="489"/></p>
<p>Regardless, we still get a wrong password when we try out the strings. That being said, the strings do show us that a correct message would most likely display <kbd>correct password. bye!</kbd>. The list also shows a lot of APIs that the program uses. However, knowing that this was compiled using MingWin-Dev C++, it is possible that most of the APIs used are part of the program's initialization.</p>
<p>Disassembling the file using the IDA Pro 32-bit decompiler, we get to see the main function code. You can download and install IDA Pro from <a href="https://github.com/PacktPublishing/Mastering-Reverse-Engineering/tree/master/tools/Disassembler%20Tools">https://github.com/PacktPublishing/Mastering-Reverse-Engineering/tree/master/tools/Disassembler%20Tools</a>. Since we are working in a Windows 32-bit environment, install the 32-bit <kbd>idafree50.exe</kbd> file. These installers were pulled from the official IDA Pro website and are hosted in our GitHub repository for the purpose of availability.</p>
<p>This file is a PE file, or Portable Executable. It should be opened as a Portable Executable to read the executable codes of the PE file. If opened using the MS-DOS executable, the resulting code will be the 16-bit MS-DOS stub:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1031 image-border" src="img/c0a289fb-3640-4e17-bede-0b423f56019d.png" style="width:31.67em;height:38.00em;" width="380" height="456"/></p>
<p class="mce-root"/>
<p>IDA Pro was able to identify the main function. It is located at the address <kbd>0x004012B8</kbd>. Scrolling down to the Graph overview shows the branching of the blocks and may give you an idea of how the program's code will flow when executed. To view the code in plain disassembly, that is, without the graphical representation, just change to Text view mode:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1366 image-border" src="img/7b166065-08e0-43eb-a462-08ba6de3aaf4.png" style="width:100.25em;height:41.75em;" width="1203" height="501"/></p>
<p>Knowing that this is a C compiled code, we only need to focus our analysis on the <kbd>_main</kbd> function. We will try to make pseudocode out of the analysis. The information that will be gathered are the APIs, since they are used in the flow of code, the conditions that make the jump branches, and the variables used. There might be some specific compiler code injected into the program that we may have identify and skip:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1033 image-border" src="img/2aa631b8-027e-41ab-9a94-38912d12e9d5.png" style="width:53.75em;height:23.92em;" width="645" height="287"/></p>
<p>Quickly inspecting the functions <kbd>sub_401850</kbd> and <kbd>sub_4014F0</kbd>, we can see that the <kbd>_atexit</kbd> API was used here. The <kbd>atexit</kbd> API is used to set the code that will be executed once the program terminates normally. <kbd>atexit</kbd> and similar APIs are commonly used by high-level compilers to run cleanup code. This cleanup code is usually designed to prevent possible memory leaks, close opened and unused handles, de-allocate allocated memory, and/or realign the heap and stack for a graceful exit:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1034 image-border" src="img/5f60e302-b265-4961-966f-0de079779645.png" style="width:44.08em;height:15.67em;" width="719" height="255"/></p>
<p>The parameter used in <kbd>_atexit</kbd> points to <kbd>sub_401450</kbd>,  and contains the cleanup codes.</p>
<p>Continuing, we get to a call the <kbd>printf</kbd> function. In assembly language, calling APIs requires that its parameters are placed in sequence from the top of the stack. The <kbd>push</kbd> instruction is what we commonly use to store the data in the stack. This code does just the same thing. If you right-click on <kbd>[esp+88h+var_88]</kbd>, a drop-down menu will pop out, showing a list of possible variable structures. The instruction line can be better understood as <kbd>mov dword ptr [esp], offset aWhatIsThePassw</kbd>:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1035 image-border" src="img/0cbc9fee-7f3e-44ed-a8da-68a58646ab55.png" style="width:37.50em;height:16.33em;" width="535" height="233"/></p>
<p class="mce-root"/>
<p>This does the same as <kbd>push offset aWhatIsThePassw</kbd>.  The square brackets were used to define a data container. In this case, <kbd>esp</kbd> is the address of the container where the address of <kbd>what is the password? </kbd> gets stored. There is a difference between using <kbd>push</kbd> and <kbd>mov</kbd>.  In the <kbd>push</kbd> instruction, the stack pointer, <kbd>esp</kbd>, is decremented. Overall, <kbd>printf</kbd> got the parameter it needed to display the message to the console.</p>
<p>The next API is <kbd>scanf</kbd>.  <kbd>scanf</kbd> requires two parameters: the format of the input and the address where the input gets stored. The first parameter is located at the top of stack, and should be in the format of the input followed by the address where the input will be placed. Revising the variable structure should look like this:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1036 image-border" src="img/69f98b29-7b53-4ba1-845a-4d0fd6a94b41.png" style="width:43.25em;height:12.00em;" width="594" height="165"/></p>
<p>The format given is <kbd>"%30[0-9a-zA-Z ]"</kbd> , which means that <kbd>scanf</kbd> will only read 30 characters from the start of the input and that it will only accept the first set of characters that are within the square bracket. The accepted characters would only be "<kbd>0</kbd>" to "<kbd>9</kbd>", "<kbd>a</kbd>" to "<kbd>z</kbd>", "<kbd>A</kbd>" to "<kbd>Z</kbd>", and the space character. This type of input format is used to prevent exceeding a 30 character input. It is also used to prevent the rest of the code from processing non-alphanumeric characters, with the exception of the space character.</p>
<p>The second parameter, placed at <kbd>[esp+4]</kbd>, should be an address to where the input will be stored. Tracing back, the value of the <kbd>eax</kbd> register is set as [<kbd>ebp+var_28</kbd>]. Let's just take note that the address stored at <kbd>var_28</kbd> is the inputted password.</p>
<p>The <kbd>strlen</kbd> API comes right after and requires only one parameter. Tracing back the value of <kbd>eax</kbd>, <kbd>var_28</kbd>, the inputted password, is the string that <kbd>strlen</kbd> will be using. The resulting length of the string is stored in the <kbd>eax</kbd> register. The string size is compared to a value of <kbd>11h</kbd> or <kbd>17</kbd>.  After a <kbd>cmp</kbd>, a conditional jump is usually expected. The <kbd>jnz</kbd> instruction is used. The red line is followed if the comparison deems <em>false</em>. A green line is followed for a <em>true </em>condition. A blue line simply follows the next code block, as shown here:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1037 image-border" src="img/53406422-23b4-4c15-a2f6-452868f5b91e.png" style="width:42.08em;height:20.08em;" width="594" height="283"/></p>
<p>Following the red line means that the string length is equal to 17. At this point, our pseudocode is as follows:</p>
<pre>main()<br/>{<br/>    printf("what is the password? ");<br/>    scanf("%30[0-9a-zA-Z ]", &amp;password);<br/>    password_size = strlen(password);<br/>    if (password_size == 17)<br/>    { ... }<br/>    else<br/>    { ... }<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root">It is more than likely that if the size of the password is not 17, it will say wrong password. Let's follow the green path first:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1038 image-border" src="img/0b076472-1c2d-451d-8e79-e511d0686774.png" style="width:38.75em;height:20.42em;" width="527" height="278"/></p>
<p>The green line goes down to the <kbd>loc_4013F4</kbd> block, followed by the <kbd>loc_401400</kbd> block that ends the <kbd>_main</kbd> function. The instruction at <kbd>loc_4013F4</kbd> is a call to <kbd>sub_401290</kbd>.  This function contains code that indeed displays the wrong password message. Take note that a lot of lines point to <kbd>loc_4013F4</kbd>:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1039 image-border" src="img/2e29152e-209b-4530-b48e-8a8a787a2265.png" style="width:53.92em;height:22.25em;" width="643" height="265"/></p>
<p>Here's the continuation of building our pseudocode with this wrong password function:</p>
<pre>wrong_password()<br/>{<br/>    printf("wrong password. try again!\n");<br/>}<br/><br/>main()<br/>{<br/>    printf("what is the password? ");<br/>    scanf("%30[0-9a-zA-Z ]", &amp;password);<br/>    password_size = strlen(password);<br/>    if (password_size == 17)<br/>    { ... }<br/>    else<br/>    {<br/>        wrong_password();<br/>    }<br/>}</pre>
<p>One good technique in reverse engineering is to find the shortest exit path possible. However, this takes practice and experience. This makes it easier to picture the whole structure of the code.</p>
<p>Now, let's analyze the rest of the code under a 17 character string size. Let's trace the branching instructions and work backwards with the conditions:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1040 image-border" src="img/50701e46-f8ec-426d-9484-fb1888571f81.png" style="width:34.25em;height:21.83em;" width="439" height="279"/></p>
<p class="mce-root"/>
<p>The condition for <kbd>jle</kbd> is a comparison between the values at <kbd>var_60</kbd> and 0.  <kbd>var_60</kbd> is set with a value of 5, which came from <kbd>var_5c</kbd>. This prompts the code direction to follow the red line, like so:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1041 image-border" src="img/934fc0ad-e6d3-42ec-a70d-0a8bb6fc8ea5.png" style="width:33.75em;height:36.00em;" width="471" height="502"/></p>
<p>Zooming out, the code we are looking at is actually a loop that has two exit points. The first exit point is a condition that the value at <kbd>var_60</kbd> is less than or equal to <kbd>0</kbd>. The second exit point is a condition where the byte pointed to by register <kbd>eax</kbd> should not be equal to <kbd>65h</kbd>. If we inspect the variables in the loop further, the initial value, at <kbd>var_60</kbd>, is <kbd>5</kbd>. The value at <kbd>var_60</kbd> is being decremented in the <kbd>loc_401373</kbd> block. This means that the loop will iterate 5 times.</p>
<p>We can also see <kbd>var_8</kbd> and <kbd>var_5c</kbd> in the loop. However, since the start of the main code, <kbd>var_8</kbd> was never set. <kbd>var_5c</kbd> was also used not as a variable, but as part of a calculated address. IDA Pro helped to identify possible variable usage as part of the <kbd>main</kbd> function's stack frame and set its base in the <kbd>ebp</kbd> register. This time, we may need to undo this variable identification by removing the variable structure only on <kbd>var_8</kbd> and <kbd>var_5c</kbd> in the loop code. This can be done by choosing the structure from the list given by right-clicking the variable names:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1042 image-border" src="img/866bdc1a-a774-427f-8081-06af3e03b364.png" style="width:34.42em;height:10.17em;" width="520" height="153"/></p>
<p>Thereby, for calculating the value in <kbd>eax</kbd>, we begin from the <kbd>lea</kbd> instruction line. The value stored to <kbd>edx</kbd> is the difference taken from <kbd>ebp</kbd> minus 8.  <kbd>lea</kbd> here does not take the value stored at <kbd>ebp-8</kbd>, unlike when using the <kbd>mov</kbd> instruction. The value stored in <kbd>ebp</kbd> is the value in the <kbd>esp</kbd> register after entering the <kbd>main</kbd> function. This makes <kbd>ebp</kbd> the stack frame's base address. Referencing variables in the stack frame makes use of <kbd>ebp</kbd>. Remember that the stack is used by descending from a high memory address. This is the reason why referencing from the <kbd>ebp</kbd> register requires subtracting relatively:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1043 image-border" src="img/a1e6eda0-6ae9-489f-8339-3546d1345d2f.png" style="width:28.42em;height:21.83em;" width="427" height="328"/></p>
<p class="mce-root">Now, in the <kbd>add</kbd> instruction line, the value to be stored in <kbd>edx</kbd> will be the sum of <kbd>edx</kbd>, and the value stored from a calculated address. This calculated address is <kbd>eax*4-5Ch</kbd>.  <kbd>eax</kbd> is the value from <kbd>var_60</kbd> which contains a value that decrements from <kbd>5</kbd> down to <kbd>0</kbd>.  But since the loop terminates when <kbd>var_60</kbd> reaches <kbd>0</kbd>, <kbd>eax</kbd> in this line will only have values from <kbd>5</kbd> down to <kbd>1</kbd>.   Calculating all five addresses, we should get the following output:</p>
<pre>[ebp+5*4-5ch] -&gt; [ebp-48h] = 10h<br/>[ebp+4*4-5ch] -&gt; [ebp-4Ch] = 0eh<br/>[ebp+3*4-5ch] -&gt; [ebp-50h] = 7<br/>[ebp+2*4-5ch] -&gt; [ebp-54h] = 5<br/>[ebp+1*4-5ch] -&gt; [ebp-58h] = 3</pre>
<p>It also happens that the values stored at these stack frame addresses were set before calling the first <kbd>printf</kbd> function. At this point, given the value of <kbd>eax</kbd> from <kbd>5</kbd> down to <kbd>1</kbd>, <kbd>edx</kbd> should have the resulting values:</p>
<pre>eax = 5;  edx = ebp-8+10h;  edx = ebp+8<br/>eax = 4;  edx = ebp-8+0eh;  edx = ebp+6<br/>eax = 3;  edx = ebp-8+7;    edx = ebp-1<br/>eax = 2;  edx = ebp-8+5;    edx = ebp-3<br/>eax = 1;  edx = ebp-8+3;    edx = ebp-5</pre>
<p>The resulting value of <kbd>edx</kbd> is then stored in <kbd>eax</kbd> by the <kbd>mov</kbd> instruction. However, right after this, <kbd>20h</kbd> is subtracted from <kbd>eax</kbd>: </p>
<pre>from eax = 5;  eax = ebp+8-20h;  eax = ebp-18h<br/>from eax = 4;  eax = ebp+6-20h;  eax = ebp-1ah<br/>from eax = 3;  eax = ebp-1-20h;  eax = ebp-21h<br/>from eax = 5;  eax = ebp-3-20h;  eax = ebp-23h<br/>from eax = 5;  eax = ebp-5-20h;  eax = ebp-25h</pre>
<p>The next two lines of code is the second exit condition for the loop. The <kbd>cmp</kbd> instruction compares <kbd>65h</kbd> with the value stored at the address pointed to by <kbd>eax</kbd>. The equivalent ASCII character of <kbd>65h</kbd> is "e". If the values at the addresses pointed to by eax don't match a value of <kbd>65h</kbd>, the code exits the loop. If a mismatch happens, following the red line ends up with a call to <kbd>sub_401290</kbd>, which happens to be the wrong password function. The addresses being compared to with the character "<kbd>e</kbd>" must be part of the input string.</p>
<p>If we made a map out of the stack frame in a table, it would look something like this:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td/>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
<td>8</td>
<td>9</td>
<td>A</td>
<td>B</td>
<td>C</td>
<td>D</td>
<td>E</td>
<td>F</td>
</tr>
<tr>
<td>-60h</td>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
<td>03</td>
<td>00</td>
<td>00</td>
<td>00</td>
<td>05</td>
<td>00</td>
<td>00</td>
<td>00</td>
</tr>
<tr>
<td>-50h</td>
<td>07</td>
<td>00</td>
<td>00</td>
<td>00</td>
<td>0e</td>
<td>00</td>
<td>00</td>
<td>00</td>
<td>10</td>
<td>00</td>
<td>00</td>
<td>00</td>
<td/>
<td/>
<td/>
<td/>
</tr>
<tr>
<td>-40h</td>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
</tr>
<tr>
<td>-30h</td>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
<td>X</td>
<td>X</td>
<td>X</td>
<td>e</td>
<td>X</td>
<td>e</td>
<td>X</td>
<td>e</td>
</tr>
<tr>
<td>-20h</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>e</td>
<td>X</td>
<td>e</td>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
</tr>
<tr>
<td>-10h</td>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
</tr>
<tr>
<td>ebp</td>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
</tr>
</tbody>
</table>
<p> </p>
<p>We have to consider that <kbd>scanf</kbd> stored the input password at <kbd>ebp-var_28</kbd> or <kbd>ebp-28</kbd>. Knowing that there are exactly 17 characters for a correct password, we marked these input locations with X. Let's also set the addresses that should match with "<kbd>e</kbd>" to proceed. Remember that the string begins at offset <kbd>0</kbd>, not <kbd>1</kbd>.</p>
<p>Now that we're good with the loop, here's what our pseudocode should look like by now:</p>
<pre>wrong_password()<br/>{<br/>    printf("wrong password. try again!\n");<br/>}<br/><br/>main()<br/>{<br/>    e_locations[] = [3, 5, 7, 0eh, 10h];<br/>    printf("what is the password? ");<br/>    scanf("%30[0-9a-zA-Z ]", &amp;password);<br/>    password_size = strlen(password);<br/>    if (password_size == 17)<br/>    {<br/><br/>        for (i = 5; i &gt;= 0; i--)<br/>            if (password[e_locations[i]] != 'e')<br/>            {<br/>                wrong_password();<br/>                goto goodbye;<br/>            }<br/>        ...<br/>    }<br/>    else<br/>    {<br/>        wrong_password();<br/>    }<br/>goodbye:<br/>}</pre>
<p>Moving on, after the loop, we will see another block that uses <kbd>strcmp</kbd>. This time, we corrected some of the variable structures to get a better grasp of what our stack frame would look like:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1044 image-border" src="img/7bd3c5ec-2c74-4cac-93c4-317d01dba058.png" style="width:28.83em;height:22.00em;" width="485" height="370"/></p>
<p>The first two instructions read <kbd>DWORD</kbd> values from <kbd>ebp-1Ah</kbd> and <kbd>ebp-25h</kbd>, and are used to calculate a binary, AND. Looking at our stack frame, both locations are within the inputted password string area. Eventually, a binary AND is again used on the resulting value and <kbd>0FFFFFFh</kbd>. The final value is stored at <kbd>ebp-2Ch</kbd>. <kbd>strcmp</kbd> is then used to compare the value stored at <kbd>ebp-2Ch</kbd> with the string "<kbd>ere</kbd>". If the string comparison does not match, the green line goes to the wrong password code block.</p>
<p>Using the <kbd>AND</kbd> instruction with <kbd>0FFFFFFh</kbd> means that it was only limited to <kbd>3</kbd> characters.  Using <kbd>AND</kbd> on the two <kbd>DWORD</kbd>s from the password string would only mean that both should be equal, at least on the 3 characters. Thus, <kbd>ebp-1Ah</kbd> and <kbd>ebp-25h</kbd> should contain "<kbd>ere</kbd>":</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td/>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
<td>8</td>
<td>9</td>
<td>A</td>
<td>B</td>
<td>C</td>
<td>D</td>
<td>E</td>
<td>F</td>
</tr>
<tr>
<td>-60h</td>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
<td>03</td>
<td>00</td>
<td>00</td>
<td>00</td>
<td>05</td>
<td>00</td>
<td>00</td>
<td>00</td>
</tr>
<tr>
<td>-50h</td>
<td>07</td>
<td>00</td>
<td>00</td>
<td>00</td>
<td>0e</td>
<td>00</td>
<td>00</td>
<td>00</td>
<td>10</td>
<td>00</td>
<td>00</td>
<td>00</td>
<td/>
<td/>
<td/>
<td/>
</tr>
<tr>
<td>-40h</td>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
</tr>
<tr>
<td>-30h</td>
<td/>
<td/>
<td/>
<td/>
<td>e</td>
<td>r</td>
<td>e</td>
<td/>
<td>X</td>
<td>X</td>
<td>X</td>
<td>e</td>
<td>r</td>
<td>e</td>
<td>X</td>
<td>e</td>
</tr>
<tr>
<td>-20h</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>e</td>
<td>r</td>
<td>e</td>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
</tr>
<tr>
<td>-10h</td>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
</tr>
<tr>
<td>ebp</td>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
</tr>
</tbody>
</table>
<p>Let's mode on to the next set of code, following the red line:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1046 image-border" src="img/73b53cca-7aef-41c5-b9a3-0afc4e6ebca1.png" style="width:28.58em;height:45.00em;" width="390" height="614"/></p>
<p>All green lines point to the wrong password code block. So, to keep moving forward, we'll have to follow the conditions that go with the red line. The first code block in the preceding screenshot uses the <kbd>XOR</kbd> instruction to validate that the characters at <kbd>ebp-1Eh</kbd> and <kbd>ebp-22h</kbd> are equal.  The second block adds both character values from the same offsets, <kbd>ebp-1Eh</kbd> and <kbd>ebp-22h</kbd>.  The sum should be <kbd>40h</kbd>. In that case, the character should have an ASCII value of <kbd>20h</kbd>, a space character.</p>
<p>The third block reads a <kbd>DWORD</kbd> value from <kbd>ebp-28h</kbd> and then uses the AND instruction to only take the first 3 characters. The result is compared with <kbd>647541h</kbd>. If translated to ASCII characters, it is read as "<kbd>duA</kbd>".</p>
<p>The fourth block does the same method as the third but takes the <kbd>DWORD</kbd> from <kbd>ebp-1Dh</kbd> and compares it with <kbd>636146h</kbd>, or "<kbd>caF</kbd>".</p>
<p>The last block takes a WORD value from <kbd>ebp-20h</kbd> and compares it with <kbd>7473h</kbd>, or "<kbd>ts</kbd>".</p>
<p>Writing all these down to our stack frame table should be done in little endian:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td/>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
<td>8</td>
<td>9</td>
<td>A</td>
<td>B</td>
<td>C</td>
<td>D</td>
<td>E</td>
<td>F</td>
</tr>
<tr>
<td>-60h</td>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
<td>03</td>
<td>00</td>
<td>00</td>
<td>00</td>
<td>05</td>
<td>00</td>
<td>00</td>
<td>00</td>
</tr>
<tr>
<td>-50h</td>
<td>07</td>
<td>00</td>
<td>00</td>
<td>00</td>
<td>0e</td>
<td>00</td>
<td>00</td>
<td>00</td>
<td>10</td>
<td>00</td>
<td>00</td>
<td>00</td>
<td/>
<td/>
<td/>
<td/>
</tr>
<tr>
<td>-40h</td>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
</tr>
<tr>
<td>-30h</td>
<td/>
<td/>
<td/>
<td/>
<td>e</td>
<td>r</td>
<td>e</td>
<td/>
<td>A</td>
<td>u</td>
<td>d</td>
<td>e</td>
<td>r</td>
<td>e</td>
<td/>
<td>e</td>
</tr>
<tr>
<td>-20h</td>
<td>s</td>
<td>t</td>
<td/>
<td>F</td>
<td>a</td>
<td>c</td>
<td>e</td>
<td>r</td>
<td>e</td>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
</tr>
<tr>
<td>-10h</td>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
</tr>
<tr>
<td>ebp</td>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
</tr>
</tbody>
</table>
<p> </p>
<p>The password should be "<kbd>Audere est Facere</kbd>". If successful, it should run the correct password function:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1047 image-border" src="img/c34a978b-bbf5-492c-8000-ce107e4ce454.png" style="width:43.25em;height:18.83em;" width="610" height="265"/></p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>To complete our pseudocode, we have to compute the string's relative offsets from <kbd>ebp-28h</kbd>.  <kbd>ebp-28h</kbd> is the password string's offset, 0, while the last offset, offset 16, in the string should be at <kbd>ebp-18h</kbd>:</p>
<pre>wrong_password()<br/>{<br/>    printf("\nwrong password. try again!\n");<br/>}<br/><br/>correct_password()<br/>{<br/>    printf("\ncorrect password. bye!\n");<br/>}<br/><br/>main()<br/>{<br/>    e_locations[] = [3, 5, 7, 0eh, 10h];<br/>    printf("what is the password? ");<br/>    scanf("%30[0-9a-zA-Z ]", &amp;password);<br/>    password_size = strlen(password);<br/>    if (password_size == 17)<br/>    {<br/>        for (i = 5; i &gt;= 0; i--)<br/>            if (password[e_locations[i]] != 'e')<br/>            {<br/>                wrong_password();<br/>                goto goodbye;<br/>            }<br/>        if ( (password[6] ^ password[10]) == 0 )   // ^ means XOR<br/>            if ( (password[6] + password[10]) == 0x40 )<br/>                if ( ( *(password+0) &amp; 0x0FFFFFF ) == 'duA' )<br/>                    if ( ( *(password+11) &amp; 0x0FFFFFF ) == 'caF' )<br/>                        if ( ( *(password+8) &amp; 0x0FFFF ) == 'ts' )<br/>                        {<br/>                            correct_password();<br/>                            goto goodbye<br/>                        }<br/>    }<br/>    wrong_password();<br/>goodbye:<br/>}</pre>


            

            
        
    </div>



  
<div><h1 class="header-title">Dynamic analysis with debugging</h1>
                
            
            
                
<p>There is nothing better than verifying what we assumed during our static analysis. Simply running the program and entering the password should finish the job:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1048 image-border" src="img/914f5cdf-219e-431e-8e7f-f8d26418db19.png" style="width:55.08em;height:17.33em;" width="661" height="208"/></p>
<p>Deadlisting is as important as debugging a program. Both can be done at the same time. Debugging can help speed up the deadlisting process as it is also validated at the same time. For this exercise, we're going to redo the analysis of <kbd>passcode.exe</kbd> by using <kbd>x32dbg</kbd> from <a href="https://x64dbg.com">https://x64dbg.com</a>. </p>
<p>After opening <kbd>passcode.exe</kbd> in <kbd>x32dbg</kbd>, registering EIP will be at a high memory region. This is definitely not in any part of the <kbd>passcode.exe</kbd> image:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1049 image-border" src="img/0b25b1d6-f32f-482d-a242-7cc8d83686e7.png" style="width:72.50em;height:52.67em;" width="870" height="632"/></p>
<p>To go around this, click on Options-&gt;Preferences, and then under the Events tab, uncheck <em>System Breakpoint*</em>: </p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1050 image-border" src="img/0755eb35-8860-4dd3-a857-289f1510204b.png" style="width:30.25em;height:26.58em;" width="378" height="332"/></p>
<p>Click on the Save button and then use Debug-&gt;Restart or press <kbd>Ctrl + F2</kbd>. This restarts the program, but now, EIP should stop at the PE file's entry point address:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1051 image-border" src="img/12921e1d-8132-4ff3-98fd-80225be0baa4.png" style="width:72.50em;height:52.67em;" width="870" height="632"/></p>
<p class="mce-root">And since we also know the address of the <kbd>main</kbd> function, we need to set a breakpoint there and let the program run (<kbd><em>F9</em></kbd>). To do that, in the Command box, enter the following:</p>
<pre>bp 004012b8</pre>
<p class="mce-root"/>
<p>After running, EIP should stop at the <kbd>main</kbd> function's address. We get to see a familiar piece of code as we did during deadlisting:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1052 image-border" src="img/bb43f02d-e2cc-4819-bf62-82d4264411ac.png" style="width:72.17em;height:52.25em;" width="866" height="627"/></p>
<p><em>F7</em> and <em>F8</em> are the shortcut keys for Step in and Step over. Click on the Debug menu and you should see the shortcut keys assigned to the debug command. Just keep on playing with the commands; if you ever mess things up, you can always restart.</p>
<p>The advantage of using the Debugger is that you should easily be able to see the stack frame. There are five memory dump windows consisting of the stack frame. Let's use Dump 2 to show us the stack frame. Make two instruction steps to get <kbd>ebp</kbd> set with the stack frame's base. On the left pane, in the list of registers, right-click on Register EBP and then select Follow in Dump-&gt;Dump 2. This should bring Dump 2 forward. Since the stack moves down from a higher address, you'll have to roll the scroll bar up to show the initial data we have in the stack frame:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1053 image-border" src="img/a37a6d40-e0fd-43a6-946e-d7303976767d.png" style="width:43.50em;height:11.75em;" width="522" height="141"/></p>
<p>Here's the same stack frame after inputting for <kbd>scanf</kbd>. Also, during <kbd>scanf</kbd>, you'll have to switch to the command prompt window to enter the password and then switch back after.  Also included in the following screenshot is the stack window, located in the right-hand pane:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1054 image-border" src="img/8da5bf65-1ea5-48cf-b569-0a5e1cb06ef4.png" style="width:71.92em;height:20.25em;" width="863" height="243"/></p>
<p>Even while in the debugger, we can change the contents of the inputted string any time, thereby forcing it to continue in the condition toward the correct password. All we need to do is right-click on the byte in the Dump window and select Modify Value<em>.</em> For example, in the loop that compares <kbd>65h</kbd> ("<kbd>e</kbd>") with the value stored in the address pointed by register <kbd>eax</kbd>, before stepping on the <kbd>cmp</kbd> instruction, we can change the value at that address.</p>
<p>In the following screenshot the value stored at the address <kbd>0060FF20h</kbd> (EAX), which is being modifed from <kbd>35h</kbd> to <kbd>65h</kbd>:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1055 image-border" src="img/1c5731fe-5dfc-421e-bed5-271800735c0f.png" style="width:72.17em;height:52.42em;" width="866" height="629"/></p>
<p>The same modification can be done by doing a binary edit through right-clicking on byte, and then selecting <em>Binary</em>-&gt;<em>Edit</em>.</p>
<p>And here's where we should end up if we have a correct password:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1056 image-border" src="img/9afbc6dc-4f99-4647-b448-cdc9dce17759.png" style="width:72.50em;height:52.67em;" width="870" height="632"/></p>


            

            
        
    </div>



  
<div><h1 class="header-title">Decompilers</h1>
                
            
            
                
<p>It may be easier if the pseudocode were automatically given to us. Certain tools exist that may be able to help us with that. Let's try and decompile <kbd>passcode.exe</kbd> (<a href="https://github.com/PacktPublishing/Mastering-Reverse-Engineering/blob/master/ch7/passcode.exe">https://github.com/PacktPublishing/Mastering-Reverse-Engineering/blob/master/ch7/passcode.exe</a>) using the standalone version of Snowman (<a href="https://derevenets.com/">https://derevenets.com/</a>). Once the file has been opened, click on View-&gt;Inspector.  This should show a box containing resolved functions from the program. Look for the function definition <kbd>_main</kbd> and select it to show the equivalent pseudocode of the assembly language. This highlights the assembly language line in the left-hand pane and the psuedocode in the middle pane:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1057 image-border" src="img/3db47a1f-e2dc-4d72-b225-ca744f400a4e.png" style="width:92.17em;height:53.17em;" width="1106" height="638"/></p>
<p>As of the time of writing this book, the output C source may help, but not all are correctly decompiled. For instance, the loop where "<kbd>e</kbd>" was being compared was not decompiled correctly. The output shows a <kbd>while</kbd> loop, but we expect that the <kbd>v10</kbd> variable should have its value read from the offset calculated in the password string. However, most of the code should somehow aid us in understanding how the program should work. The decompiler engine for this is open source (<a href="https://www.capstone-engine.org/">https://www.capstone-engine.org/</a>), so not much should be expected as support won't always be there.</p>
<p>The good news is that there are more powerful decompilers that exist, such as HexRays. Most institutions and some individual analysts and researchers who perform reverse engineering are willing to pay for these decompilers. HexRays is one bang for its buck for most reverse engineers.</p>
<p>Here's a HexRays decompiled version of <kbd>passcode.exe</kbd>:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1058 image-border" src="img/af8762c3-a506-4c10-8cf1-4b77d37555e3.png" style="width:48.25em;height:48.83em;" width="625" height="632"/></p>
<p>Decompilers are continuously developed since these tools speed up analysis. They do not decompile perfectly, but should be near the source.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we introduced reverse engineering, beginning with APIs, by learning how these are used in a functional program. We then used static and dynamic analysis tools to reverse a program.</p>
<p>Overall, there are a lot of reversing tools for Windows available for use. This also includes the vast information and research on how to use them for specific reversing situations. Reverse engineering is mostly about acquiring the resources from the World Wide Web, and from what you already know, we have already done that.  </p>


            

            
        
    </div>



  
<div><h1 class="header-title">Further reading</h1>
                
            
            
                
<ul>
<li><a href="https://visualstudio.microsoft.com">https://visualstudio.microsoft.com</a>: this is the download site for Visual Studio</li>
<li><a href="https://docs.microsoft.com/en-us/visualstudio/productinfo/vs2017-system-requirements-vs">https://docs.microsoft.com/en-us/visualstudio/productinfo/vs2017-system-requirements-vs:</a> site shows recommended system requirements for installing Visual Studio</li>
<li><a href="https://sourceforge.net/projects/orwelldevcpp/">https://sourceforge.net/projects/orwelldevcpp/</a>: this site contains the binary downloads of Dev C++.</li>
<li><a href="https://developer.microsoft.com/en-us/microsoft-edge/tools/vms/">https://developer.microsoft.com/en-us/microsoft-edge/tools/vms/</a>: appliance versions of pre-installed Microsoft Windows can be downloaded here </li>
<li><a href="http://mark0.net/soft-trid-e.html">http://mark0.net/soft-trid-e.html:</a> Download site of the TrID tool and its signature database file</li>
<li><a href="http://www.microsoft.com/whdc/system/platform/firmware/PECOFF.mspx">http://www.microsoft.com/whdc/system/platform/firmware/PECOFF.mspx:</a> documentation of the Microsoft Portable E</li>
</ul>


            

            
        
    </div>



  </body></html>