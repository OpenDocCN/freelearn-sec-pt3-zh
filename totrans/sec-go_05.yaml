- en: Packet Capturing and Injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Packet capturing is the process of monitoring the raw traffic going through
    a network. This applies to wired Ethernet and wireless network devices. The `tcpdump`
    and `libpcap` packages are the standard when it comes to packet capturing. They
    were written in the 1980s and are still being used today. The `gopacket` package
    not only wraps the C libraries but also adds layers of Go abstraction to make
    it more idiomatic to Go and practical to use.
  prefs: []
  type: TYPE_NORMAL
- en: The `pcap` library allows you to gather information about network devices, read
    packets *off the wire*, store traffic in a `.pcap` file, filter traffic based
    on a number of criteria, or forge custom packets and send them through the network
    device. For the `pcap` library, filtering is done with **Berkeley Packet Filters**
    (**BPF**).
  prefs: []
  type: TYPE_NORMAL
- en: There are countless uses of packet capturing. It can be used to set up honeypots
    and monitor what kind of traffic is received. It can aid with forensic investigations
    to determine which hosts acted maliciously and which hosts were exploited. It
    can assist in identifying bottlenecks in a network. It can also be used maliciously
    for stealing information from wireless networks, performing packet scanning, fuzzing,
    ARP spoofing, and other types of attacks.
  prefs: []
  type: TYPE_NORMAL
- en: These examples require a non-Go dependency and a `libpcap` package, and, therefore,
    they may present more of a challenge to get running. I highly recommend that you
    use Ubuntu or another Linux distribution in a virtual machine for best results
    when following these examples if you do not already use Linux as your primary
    desktop.
  prefs: []
  type: TYPE_NORMAL
- en: Tcpdump is the application written by the authors of `libpcap`. Tcpdump provides
    a command-line utility for capturing packets. These examples will allow you to
    replicate the functionality of the `tcpdump` package and embed it within other
    applications. Some of the examples closely mimic the existing functionality with
    `tcpdump`, and, when applicable, an example usage of `tcpdump` will be provided.
    Because `gopacket` and `tcpdump` both rely on the same underlying `libpcap` package,
    the file format is compatible between them. You can capture files with `tcpdump`
    and read them with `gopacket`, and you can capture packets with `gopacket` and
    read them with any application that uses `libpcap`, such as Wireshark.
  prefs: []
  type: TYPE_NORMAL
- en: The official documentation of the `gopacket` package is available at [https://godoc.org/github.com/google/gopacket](https://godoc.org/github.com/google/gopacket).
  prefs: []
  type: TYPE_NORMAL
- en: Prerequisites
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before running these examples, you need to have `libpcap` installed. In addition,
    we have to use a third-party Go package. Fortunately, this package is provided
    by Google, a trusted source. Go's `get` ability will download and install the
    remote package. Git will also be needed for `go get` to work properly.
  prefs: []
  type: TYPE_NORMAL
- en: Installing libpcap and Git
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `libpcap` package dependency does not come pre-installed on most systems,
    and the installation procedure is different for each operating system. Here we
    will cover the installation steps for `libpcap` and `git` for Ubuntu, Windows,
    and macOS. I highly recommend that you use Ubuntu or other Linux distributions
    for best results. Without `libpcap`, `gopacket` will not function, and `git` is
    required to fetch the `gopacket` dependency.
  prefs: []
  type: TYPE_NORMAL
- en: Installing libpcap on Ubuntu
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Ubuntu, `libpcap-0.8` is already installed by default. To install the `gopacket`
    library, though, you also need the header files in the development package. You
    can install the header files through the `libpcap-dev` package. We will also install
    `git` because it is needed to run the `go get` command later when installing `gopacket`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Installing libpcap on Windows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Windows is the trickiest and presents the most problems. The Windows implementation
    is not very well supported, and your mileage may vary. The WinPcap is compatible
    with libpcap, and the source code used in these examples will work without modification.
    The only noticeable difference when running in Windows is the naming of network
    devices.
  prefs: []
  type: TYPE_NORMAL
- en: A WinPcap installer is available from [https://www.winpcap.org/](https://www.winpcap.org/)
    and is a required component. The developer package, should you need it, is available
    at [https://www.winpcap.org/devel.htm](https://www.winpcap.org/devel.htm) and
    contains the include files and example programs written in C. You should not need
    the developer package for most cases. Git can be installed from [https://git-scm.com/download/win](https://git-scm.com/download/win).
    You will also need MinGW for the compiler from [http://www.mingw.org](http://www.mingw.org).
    You will need to make sure that the 32-bit and 64-bit settings match for everything.
    You can set the `GOARCH=386` or `GOARCH=amd64` environment variables to change
    between 32-bit and 64-bit.
  prefs: []
  type: TYPE_NORMAL
- en: Installing libpcap on macOS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In macOS, `libpcap` is already installed. You will also need Git, which is available
    through Homebrew at [https://brew.sh](https://brew.sh), or a Git package installer,
    which is available from [https://git-scm.com/downloads](https://git-scm.com/downloads).
  prefs: []
  type: TYPE_NORMAL
- en: Installing gopacket
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After fulfilling the requirement with the `libpcap` and `git` packages, you
    can get the `gopacket` package from GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Permission problems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When executing the programs in Linux and Mac environments, you may run into
    permission problems when attempting to access the network device. Run the examples
    using either `sudo` to elevate your permission or switch your user to `root`,
    which is not recommended.
  prefs: []
  type: TYPE_NORMAL
- en: Getting a list of network devices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Part of the `pcap` library includes a function for getting a list of network
    devices.
  prefs: []
  type: TYPE_NORMAL
- en: This program will simply get a list of network devices and list their information.
    In Linux, a common default device name is `eth0` or `wlan0`. On a Mac, it is `en0`.
    In Windows, the names are not pronounceable because they are much longer and represent
    a unique ID. You use the device name as a string to identify the device to capture
    from in later examples. You may need to run the example with administrative privileges
    (for example, `sudo`) if you don't see the lists of the exact devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'The equivalent `tcpdump` command to list devices is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can use this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use utilities such as `ifconfig` and `ip` to get the names of
    your network devices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Capturing packets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following program demonstrates the basics of capturing a packet. The device
    name is passed as a string. If you don't know the device name, use the previous
    example to get a list of the devices available on your machine. If you don't see
    the exact devices listed, you may need to elevate your privileges and run the
    program with `sudo`.
  prefs: []
  type: TYPE_NORMAL
- en: The promiscuous mode is an option you can enable to listen for packets that
    are not destined for your device. The promiscuous mode is particularly relevant
    with wireless devices because wireless network devices actually have the capability
    to pick up packets in the air that were intended for other recipients.
  prefs: []
  type: TYPE_NORMAL
- en: Wireless traffic is particularly vulnerable to *sniffing* because all the packets
    are broadcast through the air instead of through Ethernet, where physical access
    is required for the wire to intercept traffic. Providing free wireless internet
    with no encryption is very common for coffee shops and other venues. This is convenient
    for guests, but puts your information at risk. If a venue offers encrypted wireless
    internet, it is not automatically safer. If the password is posted somewhere on
    the wall, or it is given out freely, then anyone with the password can decrypt
    the wireless traffic. A popular technique to add security to guest wireless is
    with a captured portal. Captured portals require the user to authenticate in some
    way, even as a guest, and then their session is segmented with separate encryption
    so that others cannot decrypt it.
  prefs: []
  type: TYPE_NORMAL
- en: Wireless access points that offer completely unencrypted traffic must be used
    carefully. If you connect to a site where sensitive information is passed, be
    sure that it is using HTTPS so that your data is encrypted between you and the
    web server you are visiting. VPN connections also offer encrypted tunnels over
    unencrypted channels.
  prefs: []
  type: TYPE_NORMAL
- en: Some websites are built by unaware or negligent programmers who do not implement
    SSL on their servers. Some websites only encrypt the login page so that your password
    is secure, but subsequently pass the session cookie in plaintext. This means that
    anyone who can pick up the wireless traffic can see the session cookie and use
    it to impersonate the victim to the web server. The web server will treat the
    attacker as if they were logged in as the victim. The attacker never learns the
    password but doesn't need it as long as the session remains active.
  prefs: []
  type: TYPE_NORMAL
- en: Some websites do not have an expiration date on sessions, and they will remain
    active until explicitly logged out. Mobile applications are particularly vulnerable
    to this because users very rarely log out and log back into mobile apps. Closing
    an app and re-opening it does not necessarily create a new session.
  prefs: []
  type: TYPE_NORMAL
- en: 'This example will open the network device for live capture and then print the
    details of each packet received. The program will continue to run until the program
    is killed using *Ctrl* + *C*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Capturing with filters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following program demonstrates how to set filters. Filters use the BPF
    format. If you have ever used Wireshark, you are probably already familiar with
    filters. There are many filter options that can be logically combined. Filters
    can be incredibly complex, and there are many cheat sheets online with common
    filters and examples of neat tricks. Here are a few examples to give you an idea
    of some very basic filters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`host 192.168.0.123`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dst net 192.168.0.0/24`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`port 22`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`not broadcast and not multicast`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some of the preceding filters should be self-explanatory. The `host` filter
    will show only packets to or from that host. The `dst net` filter will capture
    incoming traffic that is going to a `192.168.0.*` address. The `port` filter is
    watching only for port `22` traffic. The `not broadcast and not multicast` filter
    demonstrates how you can negate and combine multiple filters. Filtering out `broadcast`
    and `multicast` is useful because they tend to clutter a capture.
  prefs: []
  type: TYPE_NORMAL
- en: 'The equivalent `tcpdump` command for a basic capture is simply running it and
    passing it an interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to pass filters, you just pass them as command-line arguments,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This example is using a filter that will only capture traffic on TCP port `80`,
    which should be HTTP traffic. It does not specify whether the local port or remote
    port is `80`, so it will capture any port `80` traffic that is coming in or going
    out. If you are running it on your personal computer, you probably do not have
    a web server running so that it will capture HTTP traffic you make through the
    web browser. If you were running the capture on a web server, it would capture
    incoming HTTP request traffic.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, a handle for the network device is created using `pcap.OpenLive()`.
    Before reading packets from the device, the filter is set using `handle.SetBPFFilter()`,
    and then the packets are read from the handle. Read more about filters at [https://en.wikipedia.org/wiki/Berkeley_Packet_Filter](https://en.wikipedia.org/wiki/Berkeley_Packet_Filter).
  prefs: []
  type: TYPE_NORMAL
- en: 'This example opens a network device for live capture and then sets a filter
    with `SetBPFFilter()`. In this case, we will use the `tcp and port 80` filter to
    look for HTTP traffic. Any packets captured are printed to standard output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Saving to the pcap file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This program will perform a packet capture and store the results in a file.
    The important step in this example is the call to the `pcapgo` package—the `WriteFileHeader()`
    function of `Writer`. After that, the `WritePacket()` function can be used to
    write the desired packets to a file. You can capture all the traffic and choose
    to write only specific packets based on your own filtering criteria, if desired.
    Perhaps you only want to write odd or malformed packets to log anomalies.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do the equivalent with `tcpdump`, just pass it the `-w` flag with a filename,
    as shown in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The pcap files created with this example can be opened with Wireshark and viewed
    just like files created with `tcpdump`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This example creates an output file named `test.pcap` and opens a network device
    for live capture. It captures 100 packets to the file and then exits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Reading from a pcap file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Instead of opening a device for live capture, you can also open a pcap file
    for inspection offline. After getting a handle, whether it was from `pcap.OpenLive()`
    or `pcap.OpenOffline()`, the handle is treated the same. No distinction is made
    between a live device and a capture file once the handle is created, except that
    a live device will continue to deliver packets, and a file will eventually end.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can read pcap files that were captured with any `libpcap` client, including
    Wireshark, `tcpdump`, or other `gopacket` applications. This example opens a file
    named `test.pcap` using `pcap.OpenOffline()` and then iterates through the packets
    using `range` and prints the basic packet information. Change the filename from
    `test.pcap` to whatever file you want to read:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Decoding packet layers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Packets can be decoded layer by layer with the `packet.Layer()` function. This
    program will inspect the packets, look for TCP traffic, and then output the Ethernet
    layer, IP layer, TCP layer, and application layer information. This is useful
    when you need to inspect the traffic and make a decision based on the information.
    When it gets to the application layer, it looks for the `HTTP` keyword and prints
    a message if one is detected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Creating a custom layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You are not restricted to the most common layers, such as Ethernet, IP, and
    TCP. You can create your own layers. This has limited use for most people, but
    in some extremely rare cases it may make sense to replace the TCP layer with something
    customized to meet specific requirements.
  prefs: []
  type: TYPE_NORMAL
- en: This example demonstrates how to create a custom layer. This is good for implementing
    a protocol that is not already included with `gopacket/layers` package. There
    are over 100 layer types already included with `gopacket`. You can create custom
    layers at any level.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing this code does is to define a custom data structure to represent
    our layer. The data structure not only holds our custom data (`SomeByte` and `AnotherByte`)
    but also needs a byte slice to store the rest of the actual payload, along with
    any other layers (`restOfData`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Converting bytes to and from packets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In some cases, there may be raw bytes that you want to convert into a packet
    or vice versa. This example creates a simple packet and then obtains the raw bytes
    that make up the packet. The raw bytes are then taken and converted back into
    a packet to demonstrate the process.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we will create and serialize a packet using `gopacket.SerializeLayers()`.
    The packet consists of several layers: Ethernet, IP, TCP, and payload. During
    serialization, if any of the packets come back as nil, this means that it could
    not decode it into the proper layer (malformed or incorrect packet type). After
    serializing the packet into a buffer, we will get a copy of the raw bytes that
    make up the packet with `buffer.Bytes()`. With the raw bytes, we can then decode
    the data layer by layer using `gopacket.NewPacket()`. By taking advantage of `SerializeLayers()`,
    you can convert packet structs to raw bytes, and using `gopacket.NewPacket()`,
    you can convert the raw bytes back to structured data.'
  prefs: []
  type: TYPE_NORMAL
- en: '`NewPacket()` takes the raw bytes as the first parameter. The second parameter
    is the lowest-level layer you want to decode. It will decode that layer and all
    layers on top of it. The third parameter for `NewPacket()` is the type of decoding
    and must be one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`gopacket.Default`: This is to decode all at once, and is the safest.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gopacket.Lazy`: This is to decode on demand, but it is not concurrent safe.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gopacket.NoCopy`: This will not create a copy of the buffer. Only use it if
    you can guarantee the packet data in the memory will not change'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is the full code to turn a packet structs into bytes and then back to
    packets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Creating and sending packets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This example does a couple of things. First, it will show you how to use the
    network device to send raw bytes, so you can use it almost like a serial connection
    to send data. This is useful for really low-level data transfer, but if you want
    to interact with an application, you probably want to build a packet that other
    hardware and software can recognize.
  prefs: []
  type: TYPE_NORMAL
- en: The next thing it does is show you how to create a packet with the Ethernet,
    IP, and TCP layers. Everything is default and empty, though, so it doesn't really
    do anything.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we will create another packet, but we'll actually fill in some MAC
    addresses for the Ethernet layer, some IP addresses for IPv4, and port numbers
    for the TCP layer. You should see how you can forge packets and impersonate devices
    with that.
  prefs: []
  type: TYPE_NORMAL
- en: The TCP layer struct has Boolean fields for the `SYN`, `FIN`, and `ACK` flags,
    which can be read or set. This is good for manipulating and fuzzing TCP handshakes,
    sessions, and port scanning.
  prefs: []
  type: TYPE_NORMAL
- en: The `pcap` library provides an easy way to send bytes, but the `layers` package
    in `gopacket` assists us in creating the byte structure for the several layers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the code implementation of this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Decoding packets faster
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we know what layers to expect, we can use existing structures to store the
    packet information instead of creating new structs for every packet that takes
    time and memory. It is faster to use `DecodingLayerParser`. It is like marshaling
    and unmarshaling data.
  prefs: []
  type: TYPE_NORMAL
- en: This example demonstrates how to create layer variables at the beginning of
    the program and reuse the same variables over and over instead of creating new
    ones for each packet. A parser is created with `gopacket.NewDecodingLayerParser()`,
    which we provide with the layer variables we want to use. One caveat here is that
    it will only decode the layer types that you created initially.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the code implementation of this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having read this chapter, you should now have a very good understanding of the
    `gopacket` package. You should be able to write a simple packet-capturing application
    using the examples from this chapter. Once again, it is not about memorizing all
    of the functions or the details about the layers. The important thing is to understand
    the big picture at a high level and be able to recall what tools are available
    to you when scoping and implementing an application.
  prefs: []
  type: TYPE_NORMAL
- en: Try writing your own program based on these examples to capture interesting
    network traffic from your machine. Try capturing and inspecting a specific port
    or application to see how it works over the wire. See the difference between applications
    that use encryption and ones that pass data over the wire in plaintext. You may
    just want to capture all the traffic going on in the background and see which
    applications are busy over the network, even when you are idle at the machine.
  prefs: []
  type: TYPE_NORMAL
- en: All kinds of useful tools can be built using the `gopacket` library. Aside from
    basic packet capturing for later review, you can implement a monitoring system
    that alerts when a large spike in traffic is identified, or for spotting anomalous
    traffic.
  prefs: []
  type: TYPE_NORMAL
- en: Because the `gopacket` library can also be used to send packets, a highly customized
    port scanner can be created. You can craft raw packets to perform TCP SYN-only
    scans, where the connection is never fully established; XMAS scans, where all
    of the flags are turned on; NULL scans, where every field is set to null; and
    a variety of other scans that require full control over the packets being sent,
    including sending malformed packets intentionally. You can also build fuzzers
    to send bad packets to a network service to see how it behaves. So, see what ideas
    you can come up with.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at cryptography with Go. We will start by
    looking at hashing, checksums, and storing passwords securely. Then we will look
    at symmetric and asymmetric encryption, what they are, how they differ, why they
    are useful, and how to use them in Go. We will look at how to create an encrypted
    server with certificates, and how to use an encrypted client to connect. Understanding
    the application of cryptography is critical for modern security, so we will look
    at the most common and practical use cases.
  prefs: []
  type: TYPE_NORMAL
