["```\nsudo apt-get update\nsudo apt-get install git python-dev python-pip autoconf automake \\\n autopoint libtool pkg-config\n```", "```\ngit clone https://github.com/libyal/libpff\n```", "```\ncd libpff\n./synclibs.ps1\n./autogen.ps1\n./configure --enable-python\nmake\nmake install\n```", "```\npython\n>>> import pypff\n>>> pypff.get_version()\nu'20180812'\n```", "```\n001 \"\"\"Index and summarize PST files\"\"\"\n002 import os\n003 import sys\n004 import argparse\n005 import logging\n006 from collections import Counter\n007 \n008 import jinja2\n009 import pypff\n010 import unicodecsv as csv\n```", "```\n040 __authors__ = [\"Chapin Bryce\", \"Preston Miller\"]\n041 __date__ = 20181027\n042 __description__ = '''This scripts handles processing and\n043     output of PST Email Containers'''\n044 logger = logging.getLogger(__name__)\n045 \n046 output_directory = \"\"\n047 date_dict = {x:0 for x in range(1, 25)}\n048 date_list = [date_dict.copy() for x in range(7)]\n```", "```\n051 def main():\n...\n078 def make_path():\n...\n089 def folder_traverse():\n...\n103 def check_for_msgs(): \n```", "```\n118 def process_msg():\n...\n138 def folder_report():\n...\n193 def word_stats():\n...\n208 def word_report():\n...\n235 def sender_report():\n...\n260 def date_report():\n...\n277 def html_report():\n```", "```\n302 if __name__ == \"__main__\":\n303     parser = argparse.ArgumentParser(\n304         description=__description__,\n305         epilog='Built by {}. Version {}'.format(\n306             \", \".join(__authors__), __date__),\n307        formatter_class=argparse.ArgumentDefaultsHelpFormatter\n308     )\n309     parser.add_argument('PST_FILE',\n310         help=\"PST File Format from Microsoft Outlook\")\n311     parser.add_argument('OUTPUT_DIR',\n312         help=\"Directory of output for temporary and report files.\")\n313     parser.add_argument('--title', default=\"PST Report\",\n314         help='Title of the HTML Report.')\n315     parser.add_argument('-l',\n316         help='File path of log file.')\n317     args = parser.parse_args()\n```", "```\n319     output_directory = os.path.abspath(args.OUTPUT_DIR)\n320 \n321     if not os.path.exists(output_directory):\n322         os.makedirs(output_directory)\n```", "```\n331     logger.setLevel(logging.DEBUG)\n332     msg_fmt = logging.Formatter(\"%(asctime)-15s %(funcName)-20s\"\n333         \"%(levelname)-8s %(message)s\")\n334     strhndl = logging.StreamHandler(sys.stderr) # Set to stderr\n335     strhndl.setFormatter(fmt=msg_fmt)\n336     fhndl = logging.FileHandler(log_path, mode='a')\n337     fhndl.setFormatter(fmt=msg_fmt)\n338     logger.addHandler(strhndl)\n339     logger.addHandler(fhndl)\n340     \n341     logger.info('Starting PST Indexer v. {}'.format(__date__))\n342     logger.debug('System ' + sys.platform)\n343     logger.debug('Version ' + sys.version.replace(\"\\n\", \" \"))\n344 \n345     logger.info('Starting Script')\n346     main(args.PST_FILE, args.title)\n347     logger.info('Script Complete')\n```", "```\n051 def main(pst_file, report_name):\n052     \"\"\"\n053     The main function opens a PST and calls functions to parse\n054     and report data from the PST\n055     :param pst_file: A string representing the path to the PST\n056     file to analyze\n057     :param report_name: Name of the report title\n058         (if supplied by the user)\n059     :return: None\n060     \"\"\"\n061     logger.debug(\"Opening PST for processing...\")\n062     pst_name = os.path.split(pst_file)[1]\n063     opst = pypff.open(pst_file)\n064     root = opst.get_root_folder()\n```", "```\n066     logger.debug(\"Starting traverse of PST structure...\")\n067     folder_traverse(root)\n068 \n069     logger.debug(\"Generating Reports...\")\n070     top_word_list = word_stats()\n071     top_sender_list = sender_report()\n072     date_report()\n073 \n074     html_report(report_name, pst_name, top_word_list,\n075         top_sender_list)\n```", "```\n078     def make_path(file_name):\n079     \"\"\"\n080     The make_path function provides an absolute path between the\n081     output_directory and a file\n082     :param file_name: A string representing a file name\n083     :return: A string representing the path to a specified file\n084     \"\"\"\n085     return os.path.abspath(os.path.join(output_directory,\n086         file_name))\n```", "```\n089 def folder_traverse(base):\n090     \"\"\"\n091     The folder_traverse function walks through the base of the\n092     folder and scans for sub-folders and messages\n093     :param base: Base folder to scan for new items within\n094         the folder.\n095     :return: None\n096     \"\"\"\n097     for folder in base.sub_folders:\n098         if folder.number_of_sub_folders:\n099             folder_traverse(folder) # Call new folder to traverse\n100         check_for_msgs(folder)\n```", "```\n103 def check_for_msgs(folder):\n104     \"\"\"\n105     The check_for_msgs function reads folder messages if\n106     present and passes them to the report function\n107     :param folder: pypff.Folder object\n108     :return: None\n109     \"\"\"\n110     logger.debug(\"Processing Folder: \" + folder.name)\n111     message_list = []\n112     for message in folder.sub_messages:\n113         message_dict = process_msg(message)\n114         message_list.append(message_dict)\n115     folder_report(message_list, folder.name)\n```", "```\n118 def process_msg(message):\n119     \"\"\"\n120     The process_msg function processes multi-field messages\n121     to simplify collection of information\n122     :param message: pypff.Message object\n123     :return: A dictionary with message fields (values) and\n124         their data (keys)\n125     \"\"\"\n126     return {\n127         \"subject\": message.subject,\n128         \"sender\": message.sender_name,\n129         \"header\": message.transport_headers,\n130         \"body\": message.plain_text_body,\n131         \"creation_time\": message.creation_time,\n132         \"submit_time\": message.client_submit_time,\n133         \"delivery_time\": message.delivery_time,\n134         \"attachment_count\": message.number_of_attachments,\n135     }\n```", "```\n138 def folder_report(message_list, folder_name):\n139     \"\"\"\n140     The folder_report function generates a report per PST folder\n141     :param message_list: A list of messages discovered\n142         during scans\n143     :folder_name: The name of an Outlook folder within a PST\n144     :return: None\n145     \"\"\"\n146     if not len(message_list):\n147         logger.warning(\"Empty message not processed\")\n148         return\n149 \n150     # CSV Report\n151     fout_path = make_path(\"folder_report_\" + folder_name + \".csv\")\n152     fout = open(fout_path, 'wb')\n153     header = ['creation_time', 'submit_time', 'delivery_time',\n154         'sender', 'subject', 'attachment_count']\n155     csv_fout = csv.DictWriter(fout, fieldnames=header,\n156         extrasaction='ignore')\n157     csv_fout.writeheader()\n158     csv_fout.writerows(message_list)\n159     fout.close()\n```", "```\n162     global date_list # Allow access to edit global variable\n163     body_out = open(make_path(\"message_body.txt\"), 'a')\n164     senders_out = open(make_path(\"senders_names.txt\"), 'a')\n165     for m in message_list:\n166         if m['body']:\n167             body_out.write(m['body'] + \"\\n\\n\")\n168         if m['sender']:\n169             senders_out.write(m['sender'] + '\\n')\n```", "```\n171         # Creation Time\n172         c_time = m['creation_time']\n173         if c_time isn't None:\n174             day_of_week = c_time.weekday()\n175             hour_of_day = c_time.hour + 1\n176             date_list[day_of_week][hour_of_day] += 1\n177         # Submit Time\n178         s_time = m['submit_time']\n179         if s_time isn't None:\n180             day_of_week = s_time.weekday()\n181             hour_of_day = s_time.hour + 1\n182             date_list[day_of_week][hour_of_day] += 1\n183         # Delivery Time\n184         d_time = m['delivery_time']\n185         if d_time isn't None:\n186             day_of_week = d_time.weekday()\n187             hour_of_day = d_time.hour + 1\n188             date_list[day_of_week][hour_of_day] += 1\n189     body_out.close()\n190     senders_out.close()\n```", "```\n193 def word_stats(raw_file=\"message_body.txt\"):\n194     \"\"\"\n195     The word_stats function reads and counts words from a file\n196     :param raw_file: The path to a file to read\n197     :return: A list of word frequency counts\n198     \"\"\"\n199     word_list = Counter()\n200     for line in open(make_path(raw_file), 'r').readlines():\n```", "```\n201         for word in line.split():\n202             # Prevent too many false positives/common words\n203             if word.isalnum() and len(word) > 4:\n204                 word_list[word] += 1\n205     return word_report(word_list)\n```", "```\n208 def word_report(word_list):\n209     \"\"\"\n210     The word_report function counts a list of words and returns\n211     results in a CSV format\n212     :param word_list: A list of words to iterate through\n213     :return: None or html_report_list, a list of word\n214         frequency counts\n215     \"\"\"\n216     if not word_list:\n217         logger.debug('Message body statistics not available')\n218         return []\n219 \n220     fout = open(make_path(\"frequent_words.csv\"), 'wb')\n221     fout.write(\"Count,Word\\n\")\n```", "```\n222     for e in word_list.most_common():\n223         if len(e) > 1:\n224             fout.write(str(e[1]) + \",\" + str(e[0]) + \"\\n\")\n225     fout.close()\n```", "```\n227     html_report_list = []\n228     for e in word_list.most_common(10):\n229         html_report_list.append(\n230             {\"word\": str(e[0]), \"count\": str(e[1])})\n231 \n232     return html_report_list\n```", "```\n235 def sender_report(raw_file=\"senders_names.txt\"):\n236     \"\"\"\n237     The sender_report function reports the most frequent_senders\n238     :param raw_file: The file to read raw information\n239     :return: html_report_list, a list of the most\n240         frequent senders\n241     \"\"\"\n242     sender_list = Counter(\n243         open(make_path(raw_file), 'r').readlines())\n```", "```\n245     fout = open(make_path(\"frequent_senders.csv\"), 'wb')\n246     fout.write(\"Count,Sender\\n\")\n247     for e in sender_list.most_common():\n248         if len(e) > 1:\n249             fout.write(str(e[1]) + \",\" + str(e[0]))\n250     fout.close()\n251 \n252     html_report_list = []\n253     for e in sender_list.most_common(5):\n254         html_report_list.append(\n255             {\"label\": str(e[0]), \"count\": str(e[1])})\n256 \n257     return html_report_list\n```", "```\n260 def date_report():\n261     \"\"\"\n262     The date_report function writes date information in a\n263     TSV report. No input args as the filename\n264     is static within the HTML dashboard\n265     :return: None\n266     \"\"\"\n267     csv_out = open(make_path(\"heatmap.tsv\"), 'w')\n268     csv_out.write(\"day\\thour\\tvalue\\n\")\n269     for date, hours_list in enumerate(date_list):\n```", "```\n270         for hour, count in hours_list.items():\n271             to_write = \"{}\\t{}\\t{}\\n\".format(date+1, hour, count)\n272             csv_out.write(to_write)\n273         csv_out.flush()\n274     csv_out.close()\n```", "```\n277 def html_report(report_title, pst_name, top_words, top_senders):\n278     \"\"\"\n279     The html_report function generates the HTML report from a\n280         Jinja2 Template\n281     :param report_title: A string representing the title of\n282         the report\n283     :param pst_name: A string representing the file name of\n284         the PST\n285     :param top_words: A list of the top 10 words\n286     :param top_senders: A list of the top 10 senders\n287     :return: None\n288     \"\"\"\n```", "```\n289     open_template = open(\"stats_template.html\", 'r').read()\n290     html_template = jinja2.Template(open_template)\n291 \n292     context = {\"report_title\": report_title, \"pst_name\": pst_name,\n293         \"word_frequency\": top_words,\n294         \"percentage_by_sender\": top_senders}\n295     new_html = html_template.render(context)\n296 \n297     html_report_file = open(make_path(\"pst_report.html\"), 'w')\n298     html_report_file.write(new_html)\n299     html_report_file.close()\n```", "```\n...\n038   </style>\n039   <title>{{ report_title }}</title>\n040 </head>\n041 <body>\n042   <div class=\"container\">\n043     <div class=\"row\">\n044       <h1>{{ report_title }}</h1>\n045     </div>\n046     <div class=\"row\">\n047         <div class=\"row\">\n048           <h3>Top 10 words in {{ pst_name }}</h3>\n049         </div>\n050         <div class=\"row\">\n051           <div id=\"wordchart\">\n052           </div>\n053         </div>\n054         <div class=\"row\">\n055           <h3>Top 5 Senders in {{ pst_name }}</h3>\n056         </div>\n057         <div class=\"row\">\n058           <div id=\"piechart\">\n059           </div>\n060         </div>\n061         <div class=\"row\">\n062           <h3>Heatmap of all date activity in {{ pst_name }}</h3>\n063         </div>\n064         <div class=\"row\">\n065           <div id=\"heatmap\"></div>\n066         </div>\n067       </div>\n068     </div>\n... \n```", "```\n...\n088         .attr(\"transform\", \"translate(\" + margin.left + \",\" + margin.top + \")\");\n089\n090         data = {{ word_frequency }}\n091\n092       function processData(data) {x.domain(data.map(function(d) {\n093         return d;\n094       }\n...\n```", "```\n...  \n129     (function(d3) { \n130       'use strict'; \n131  \n132       var dataset = {{ percentage_by_sender }}; \n133  \n134       var width = 960; \n...\n```", "```\n174         times = [\"1a\", \"2a\", \"3a\", \"4a\", \"5a\", \"6a\", \"7a\", \"8a\", \"9a\", \"10a\", \"11a\", \"12a\", \"1p\", \"2p\", \"3p\", \"4p\", \"5p\", \"6p\", \"7p\", \"8p\", \"9p\", \"10p\", \"11p\", \"12p\"];\n175\n176       datasets = [\"heatmap.tsv\"];\n177\n178       var svg = d3.select(\"#heatmap\").append(\"svg\") \n```", "```\n$ docker cp sample.pst pst_parser:/opt/book\n```"]