<html><head></head><body>
<div id="sbo-rt-content" class="calibre1">
<div id="_idContainer190" class="calibre2"><h1 class="chapter-number" id="_idParaDest-203"><a id="_idTextAnchor217" class="pcalibre1 pcalibre2 pcalibre"/>11</h1>

<h3 id="_idParaDest-204" class="calibre6"><a id="_idTextAnchor218" class="pcalibre1 pcalibre2 pcalibre"/>Analyzing Compromised Containers</h3>
<p class="calibre3">Until this chapter, we looked at some standard methods and techniques to acquire and analyze <a id="_idIndexMarker914" class="pcalibre1 pcalibre2 pcalibre"/>forensic images of <strong class="bold">virtual machines</strong> (<strong class="bold">VMs</strong>) and cloud services. However, developing and analyzing a containerized environment introduces an entirely <span>new challenge.</span></p>
<p class="calibre3">In today’s technology landscape, containerization and Kubernetes orchestration have become fundamental to modern application deployment; therefore, ensuring these containers’ security is paramount. Containers offer tremendous benefits in terms of efficiency and scalability, but they also present new challenges, with security being a <span>top concern.</span></p>
<p class="calibre3">This chapter aims to understand containers’ architecture and how containers are managed and orchestrated <span>via Kubernetes.</span></p>
<p class="calibre3">In this chapter, we will be looking at the <span>following topics:</span></p>

<ul class="calibre12">
<li class="calibre13">What <span>are containers?</span></li>
<li class="calibre13">Detecting and analyzing <span>compromised containers</span></li>
</ul>
</div>
</div>


<div id="sbo-rt-content" class="calibre1">
<div id="_idContainer190" class="calibre2">
<h1 id="_idParaDest-205" class="calibre5"><a id="_idTextAnchor219" class="pcalibre1 pcalibre2 pcalibre"/>What are containers?</h1>
<p class="calibre3"><strong class="bold">Containers</strong> are lightweight, standalone, and executable packages containing everything needed <a id="_idIndexMarker915" class="pcalibre1 pcalibre2 pcalibre"/>to run a piece of software, including the code, runtime, system tools, libraries, and settings. They are designed to provide consistency across different computing environments, from development and testing to deployment in production, by encapsulating the application and its dependencies in a <span>containerized environment.</span></p>
<p class="calibre3">Some critical advantages of containerized deployments include <span>the following:</span></p>

<ul class="calibre12">
<li class="calibre13"><strong class="bold">Isolation</strong>: Containers <a id="_idIndexMarker916" class="pcalibre1 pcalibre2 pcalibre"/>use operating system-level virtualization to create isolated environments. Each container shares the same OS kernel as the host but runs independently, ensuring separation from other containers on the <span>same system.</span></li>
<li class="calibre13"><strong class="bold">Portability</strong>: Containers are highly portable, allowing you to run the same application <a id="_idIndexMarker917" class="pcalibre1 pcalibre2 pcalibre"/>consistently across various platforms, such as Linux distributions or cloud providers. Containerization technologies such as Docker and container runtimes enable <span>this portability.</span></li>
<li class="calibre13"><strong class="bold">Lightweight</strong>: Containers are lightweight compared to traditional VMs. They consume fewer <a id="_idIndexMarker918" class="pcalibre1 pcalibre2 pcalibre"/>system resources because they do not require a full OS and only package the application and <span>its dependencies.</span></li>
<li class="calibre13"><strong class="bold">Resource efficiency</strong>: Containers start and stop quickly, making them efficient for <a id="_idIndexMarker919" class="pcalibre1 pcalibre2 pcalibre"/>scaling applications up and down dynamically in response to changes <span>in workload.</span></li>
<li class="calibre13"><strong class="bold">Immutable infrastructure</strong>: Containers are typically created from predefined images. When <a id="_idIndexMarker920" class="pcalibre1 pcalibre2 pcalibre"/>you want to update an application, you build a new container image with the changes, ensuring consistency and repeatability in <span>your infrastructure.</span></li>
<li class="calibre13"><strong class="bold">Orchestration</strong>: Container orchestration platforms such as Kubernetes provide automated <a id="_idIndexMarker921" class="pcalibre1 pcalibre2 pcalibre"/>management of containerized applications, including scaling, load balancing, and self-healing, making them suitable for deploying and managing <span>microservices-based architectures.</span></li>
<li class="calibre13"><strong class="bold">Version control</strong>: Container images can be versioned, making it easy to roll back to <a id="_idIndexMarker922" class="pcalibre1 pcalibre2 pcalibre"/>the previous version in case of issues. This supports a more controlled software development and <span>deployment process.</span></li>
<li class="calibre13"><strong class="bold">Security isolation</strong>: Containers <a id="_idIndexMarker923" class="pcalibre1 pcalibre2 pcalibre"/>offer a level of security isolation. However, it’s essential to configure and manage them correctly to ensure proper <span>security practices.</span></li>
<li class="calibre13"><strong class="bold">DevOps and CI/CD</strong>: Containers <a id="_idIndexMarker924" class="pcalibre1 pcalibre2 pcalibre"/>are a fundamental tool in <strong class="bold">DevOps</strong> practices, as they <a id="_idIndexMarker925" class="pcalibre1 pcalibre2 pcalibre"/>facilitate <strong class="bold">continuous integration and continuous deployment </strong>(<strong class="bold">CI/CD</strong>) pipelines, allowing for streamlined and <a id="_idIndexMarker926" class="pcalibre1 pcalibre2 pcalibre"/>automated software development and <span>delivery processes.</span></li>
<li class="calibre13"><strong class="bold">Microservices</strong>: Containers are often used in a microservices architecture, where <a id="_idIndexMarker927" class="pcalibre1 pcalibre2 pcalibre"/>applications are broken down into small, independent services that can be easily deployed and <span>scaled individually.</span></li>
</ul>
</div>
</div>


<div id="sbo-rt-content" class="calibre1">
<div id="_idContainer190" class="calibre2">
<h2 id="_idParaDest-206" class="calibre10"><a id="_idTextAnchor220" class="pcalibre1 pcalibre2 pcalibre"/>Docker versus Kubernetes</h2>
<p class="calibre3">Although <a id="_idIndexMarker928" class="pcalibre1 pcalibre2 pcalibre"/>Docker and Kubernetes are the most popular <a id="_idIndexMarker929" class="pcalibre1 pcalibre2 pcalibre"/>containerization technologies, they serve <span>different purposes:</span></p>

<ul class="calibre12">
<li class="calibre13"><strong class="bold">Docker</strong>: <strong class="bold">Docker</strong> is a containerization platform that allows developers to package applications and their dependencies into a single, portable container unit. Containers <a id="_idIndexMarker930" class="pcalibre1 pcalibre2 pcalibre"/>are lightweight and efficient, providing a consistent environment for running applications across different systems. Docker simplifies the development process by encapsulating everything an application needs to run, ensuring it runs consistently from a developer’s laptop to a <span>production server.</span>
<p class="calibre3">Docker’s <a id="_idIndexMarker931" class="pcalibre1 pcalibre2 pcalibre"/>ease of use and user-friendly <strong class="bold">command-line interface</strong> (<strong class="bold">CLI</strong>) have made it immensely popular among developers and operations teams. It’s a valuable tool for local development, creating container images and sharing them via Docker Hub or private registries. Docker’s primary focus is on application packaging and distribution, and it’s often used as the foundation for building container images that can be run in <span>various environments.</span></p>
</li>
<li class="calibre13"><strong class="bold">Kubernetes</strong>: <strong class="bold">Kubernetes</strong>, often abbreviated as <strong class="bold">K8s</strong>, is an open source container <a id="_idIndexMarker932" class="pcalibre1 pcalibre2 pcalibre"/>orchestration platform that manages the deployment, scaling, and operation of containerized applications. While Docker is primarily concerned with packaging and running individual containers, Kubernetes takes a higher-level approach by orchestrating multiple containers into groups or services. It automates tasks such as load balancing, scaling, rolling updates, and self-healing, making it well suited for complex and distributed <span>application architectures.</span>
<p class="calibre3">Kubernetes is particularly valuable for microservices-based applications where multiple containers must work together seamlessly. It abstracts the underlying infrastructure <a id="_idIndexMarker933" class="pcalibre1 pcalibre2 pcalibre"/>and provides a unified API for managing containers across various environments, such as on-premises servers, public clouds, or hybrid setups. Kubernetes ensures <strong class="bold">high availability</strong> (<strong class="bold">HA</strong>), <strong class="bold">fault tolerance</strong> (<strong class="bold">FT</strong>), and <a id="_idIndexMarker934" class="pcalibre1 pcalibre2 pcalibre"/>resource efficiency, making it a cornerstone in modern containerized <span>application deployment.</span></p>
</li>
</ul>
<p class="calibre3">In short, Docker and Kubernetes are rather complementary technologies. Docker is ideal for creating and packaging individual containers, while Kubernetes is the go-to solution for orchestrating, scaling, and managing those containers within a larger ecosystem. They can be used together, with Docker providing container images deployed and orchestrated by Kubernetes, allowing organizations to build and manage resilient, scalable, and efficient containerized applications. The choice between Docker and Kubernetes largely depends on your specific needs and the application lifecycle stage <span>you’re addressing.</span></p>
<p class="calibre3">Containers have revolutionized how applications are developed, deployed, and managed, providing a consistent and efficient way to package and run software across various environments. In the next section, we will look into the types of containers and some of the use cases <span>they serve.</span></p>

</div>
</div>


<div id="sbo-rt-content" class="calibre1">
<div id="_idContainer190" class="calibre2">
<h2 id="_idParaDest-207" class="calibre10"><a id="_idTextAnchor221" class="pcalibre1 pcalibre2 pcalibre"/>Types of containers and their use cases</h2>
<p class="calibre3">As indicated <a id="_idIndexMarker935" class="pcalibre1 pcalibre2 pcalibre"/>in the previous section, containers are packaged applications in various forms. Next are some forms of containers and their potential <span>use cases:</span></p>

<ul class="calibre12">
<li class="calibre13"><strong class="bold">Docker containers</strong>: Docker containers are perhaps the most well-known and widely <a id="_idIndexMarker936" class="pcalibre1 pcalibre2 pcalibre"/>used type. Docker provides a <a id="_idIndexMarker937" class="pcalibre1 pcalibre2 pcalibre"/>platform for developing, shipping, and running container applications. Docker containers are highly portable and easy to manage, making them suitable for various <span>use cases.</span></li>
<li class="calibre13"><strong class="bold">Linux Containers (LXC)</strong>: LXC is an operating-system-level virtualization method <a id="_idIndexMarker938" class="pcalibre1 pcalibre2 pcalibre"/>that uses the Linux kernel’s groups <a id="_idIndexMarker939" class="pcalibre1 pcalibre2 pcalibre"/>and namespaces to create isolated environments. LXC containers are less user-friendly than Docker but offer more flexibility and control, making them suitable for specific use cases where customization <span>is crucial.</span></li>
<li class="calibre13"><strong class="bold">Rocket (rkt) containers</strong>: Developed by CoreOS, <strong class="source-inline">rkt</strong> (pronounced <em class="italic">rocket</em>) is an alternative <a id="_idIndexMarker940" class="pcalibre1 pcalibre2 pcalibre"/>container runtime <a id="_idIndexMarker941" class="pcalibre1 pcalibre2 pcalibre"/>that focuses on security and simplicity. It is designed to be more secure and lightweight than Docker and is used in some <span>Kubernetes deployments.</span></li>
<li class="calibre13"><strong class="bold">containerd</strong>: <strong class="source-inline">containerd</strong> is an industry-standard core container runtime used by <a id="_idIndexMarker942" class="pcalibre1 pcalibre2 pcalibre"/>various container platforms and <a id="_idIndexMarker943" class="pcalibre1 pcalibre2 pcalibre"/>orchestration systems. It is designed to be a simple and reliable runtime <span>for containers.</span></li>
<li class="calibre13"><strong class="bold">Podman containers</strong>: Podman is an open source container management tool compatible <a id="_idIndexMarker944" class="pcalibre1 pcalibre2 pcalibre"/>with Docker but offers a <a id="_idIndexMarker945" class="pcalibre1 pcalibre2 pcalibre"/>more secure and rootless container experience. It is suitable for scenarios where you need Docker compatibility with <span>added security.</span></li>
<li class="calibre13"><strong class="bold">OpenVZ containers</strong>: OpenVZ is a containerization technology that provides a lightweight <a id="_idIndexMarker946" class="pcalibre1 pcalibre2 pcalibre"/>form of virtualization. It <a id="_idIndexMarker947" class="pcalibre1 pcalibre2 pcalibre"/>differs from traditional containers, as it uses a shared kernel and provides more isolation than typical containers but less than <span>full virtualization.</span></li>
<li class="calibre13"><strong class="bold">FreeBSD jails</strong>: FreeBSD <a id="_idIndexMarker948" class="pcalibre1 pcalibre2 pcalibre"/>jails are similar to Linux containers <a id="_idIndexMarker949" class="pcalibre1 pcalibre2 pcalibre"/>but are specific to the FreeBSD operating system. They provide lightweight virtualization on <span>FreeBSD systems.</span></li>
<li class="calibre13"><strong class="bold">Windows containers</strong>: Windows Server also supports containerization, while most <a id="_idIndexMarker950" class="pcalibre1 pcalibre2 pcalibre"/>containers are associated with Linux. Windows <a id="_idIndexMarker951" class="pcalibre1 pcalibre2 pcalibre"/>containers can run Windows-based applications within <span>isolated environments.</span></li>
<li class="calibre13"><strong class="bold">systemd-nspawn</strong>: <strong class="source-inline">systemd-nspawn</strong> is a containerization tool provided by the <strong class="source-inline">systemd init</strong> system. It <a id="_idIndexMarker952" class="pcalibre1 pcalibre2 pcalibre"/>offers lightweight <a id="_idIndexMarker953" class="pcalibre1 pcalibre2 pcalibre"/>OS-level virtualization, and it’s commonly used for development and testing environments on <span>Linux systems.</span></li>
<li class="calibre13"><strong class="bold">Kata Containers</strong>: Kata <a id="_idIndexMarker954" class="pcalibre1 pcalibre2 pcalibre"/>Containers is an open <a id="_idIndexMarker955" class="pcalibre1 pcalibre2 pcalibre"/>source project that combines the security benefits of VMs with the efficiency and speed of containers. It’s designed for workloads that require a high level <span>of isolation.</span></li>
</ul>
<p class="calibre3">The following <a id="_idIndexMarker956" class="pcalibre1 pcalibre2 pcalibre"/>are some use cases enterprises typically leveraged to deploy a <span>containerized environment:</span></p>

<ul class="calibre12">
<li class="calibre13"><strong class="bold">Application packaging and distribution</strong>: Containers package applications and all <a id="_idIndexMarker957" class="pcalibre1 pcalibre2 pcalibre"/>their dependencies into a single, portable unit. This ensures consistent and reliable application deployment across different environments, from development <span>to production.</span></li>
<li class="calibre13"><strong class="bold">Microservices architecture</strong>: Containers are central to microservices, where applications <a id="_idIndexMarker958" class="pcalibre1 pcalibre2 pcalibre"/>are broken down into small, independent services. Each microservice runs in its own container, allowing scalability, flexibility, and <span>easy maintenance.</span></li>
<li class="calibre13"><strong class="bold">Development and testing</strong>: Developers <a id="_idIndexMarker959" class="pcalibre1 pcalibre2 pcalibre"/>use containers to create isolated development and testing environments that mirror production conditions. This ensures that applications work as expected and eliminates the “<em class="italic">it works on my </em><span><em class="italic">machine</em></span><span>” problem.</span></li>
<li class="calibre13"><strong class="bold">CI/CD</strong>: Containers <a id="_idIndexMarker960" class="pcalibre1 pcalibre2 pcalibre"/>enable streamlined CI/CD pipelines. Developers package their code and dependencies in containers, which are tested, deployed, and scaled automatically, improving software delivery speed <span>and reliability.</span></li>
<li class="calibre13"><strong class="bold">Multi-cloud and hybrid cloud deployment</strong>: Containers can run consistently <a id="_idIndexMarker961" class="pcalibre1 pcalibre2 pcalibre"/>across cloud providers and on-premises environments. This makes them suitable for multi-cloud and hybrid cloud strategies, allowing for cloud-agnostic <span>application deployment.</span></li>
<li class="calibre13"><strong class="bold">Isolation and security</strong>: Containers <a id="_idIndexMarker962" class="pcalibre1 pcalibre2 pcalibre"/>provide lightweight isolation between applications, enhancing security and minimizing the risk of conflicts or vulnerabilities <span>between them.</span></li>
<li class="calibre13"><strong class="bold">Legacy application modernization</strong>: Containers can wrap legacy applications, making <a id="_idIndexMarker963" class="pcalibre1 pcalibre2 pcalibre"/>them more portable and easier to manage. This helps organizations modernize existing systems without <span>rewriting code.</span></li>
<li class="calibre13"><strong class="bold">Scalability and load balancing</strong>: Containers can be quickly scaled up or down <a id="_idIndexMarker964" class="pcalibre1 pcalibre2 pcalibre"/>in response to changing workloads, making them ideal for applications that require elastic scaling and efficient <span>resource utilization.</span></li>
<li class="calibre13"><strong class="bold">Stateful and statelessness</strong>: Containers can be used for stateful and stateless <a id="_idIndexMarker965" class="pcalibre1 pcalibre2 pcalibre"/>applications. Stateful applications such as databases can run in containers, and stateless services can <span>scale horizontally.</span></li>
<li class="calibre13"><strong class="bold">Resource efficiency</strong>: Containers are lightweight, requiring fewer system resources <a id="_idIndexMarker966" class="pcalibre1 pcalibre2 pcalibre"/>than traditional VMs, resulting in better resource utilization and <span>cost savings.</span></li>
<li class="calibre13"><strong class="bold">Orchestration</strong>: Container orchestration platforms such as Kubernetes provide automated <a id="_idIndexMarker967" class="pcalibre1 pcalibre2 pcalibre"/>management of containers. They handle scaling, load balancing, and self-healing, making them suitable for complex <span>application architectures.</span></li>
<li class="calibre13"><strong class="bold">HA and disaster recovery (DR)</strong>: Containers can be orchestrated across multiple <a id="_idIndexMarker968" class="pcalibre1 pcalibre2 pcalibre"/>nodes and data centers to ensure HA and DR capabilities, reducing downtime and <span>data loss.</span></li>
<li class="calibre13"><strong class="bold">Service discovery and load balancing</strong>: Containers can be easily integrated with <a id="_idIndexMarker969" class="pcalibre1 pcalibre2 pcalibre"/>service discovery and load balancing solutions to ensure efficient communication and distribution of traffic <span>among services.</span></li>
<li class="calibre13"><strong class="bold">Content delivery and content delivery networks (CDNs)</strong>: CDNs use containers <a id="_idIndexMarker970" class="pcalibre1 pcalibre2 pcalibre"/>to cache and distribute content globally, reducing latency and improving content <span>delivery performance.</span></li>
<li class="calibre13"><strong class="bold">Data processing and analytics</strong>: Containers are used for running data processing <a id="_idIndexMarker971" class="pcalibre1 pcalibre2 pcalibre"/>and analytics workloads, providing a scalable and isolated environment for <span>data-related tasks.</span></li>
<li class="calibre13"><strong class="bold">Internet of Things (IoT) and edge computing</strong>: Containers can be employed <a id="_idIndexMarker972" class="pcalibre1 pcalibre2 pcalibre"/>for deploying and managing applications on edge devices and IoT devices, bringing computation closer to <span>data sources.</span></li>
<li class="calibre13"><strong class="bold">Desktop virtualization</strong>: Containers can be used for desktop virtualization, allowing <a id="_idIndexMarker973" class="pcalibre1 pcalibre2 pcalibre"/>users to run isolated desktop environments with specific applications <span>and configurations.</span></li>
</ul>
<p class="calibre3">In the following few sections, we will look into how to analyze a compromised container, what steps are required, and which forensic collection mechanism can be applied to collect forensic images of a containerized <span>environment securely.</span></p>

</div>
</div>


<div id="sbo-rt-content" class="calibre1">
<div id="_idContainer190" class="calibre2">
<h1 id="_idParaDest-208" class="calibre5"><a id="_idTextAnchor222" class="pcalibre1 pcalibre2 pcalibre"/>Detecting and analyzing compromised containers</h1>
<p class="calibre3">Most organizations operate container architectures through Kubernetes since it offers many more <a id="_idIndexMarker974" class="pcalibre1 pcalibre2 pcalibre"/>scalable options and flexibility. Before we <a id="_idIndexMarker975" class="pcalibre1 pcalibre2 pcalibre"/>dive deeper into container analysis, it is essential to understand the components of Kubernetes, as they will play a pivotal role in <span>your investigations.</span></p>

</div>
</div>


<div id="sbo-rt-content" class="calibre1">
<div id="_idContainer190" class="calibre2">
<h2 id="_idParaDest-209" class="calibre10"><a id="_idTextAnchor223" class="pcalibre1 pcalibre2 pcalibre"/>About the Kubernetes orchestration platform</h2>
<p class="calibre3">The following <a id="_idIndexMarker976" class="pcalibre1 pcalibre2 pcalibre"/>screenshot illustrates the basic architecture of a Kubernetes cluster; in summary, as we know, Kubernetes is an orchestration framework that manages one or more nodes that run one or <span>more containers:</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer184"><img alt="Figure 11.1 – Simple Kubernetes architecture" src="../images/00130.jpeg" class="calibre185"/></div>
</div>
<p class="img---caption" lang="en-US">Figure 11.1 – Simple Kubernetes architecture</p>
<p class="calibre3">For the Kubernetes cluster, you need a master node that controls and orchestrates the cluster’s operations and worker nodes that run the pods and tasks assigned by the master node. Here are some critical components of a <span>Kubernetes cluster:</span></p>

<ul class="calibre12">
<li class="calibre13"><strong class="bold">API server</strong>: This is <a id="_idIndexMarker977" class="pcalibre1 pcalibre2 pcalibre"/>the frontend <a id="_idIndexMarker978" class="pcalibre1 pcalibre2 pcalibre"/>of the cluster; developers can connect to the Kubernetes cluster using the <strong class="source-inline">kubectl</strong> command. The API server operates as a RESTful API server, meaning it’s a stateless protocol, with no information on previous requests being retained by <span>the server.</span></li>
<li class="calibre13"><strong class="bold">Scheduler</strong>: The scheduler is responsible for determining the optimal placement <a id="_idIndexMarker979" class="pcalibre1 pcalibre2 pcalibre"/>of pods onto available nodes in a cluster. Its primary function is to make intelligent scheduling decisions <a id="_idIndexMarker980" class="pcalibre1 pcalibre2 pcalibre"/>based on resource requirements, node affinity, and user-defined constraints. By evaluating the available resources on each node, the scheduler aims to balance the workload across the cluster, ensuring efficient resource utilization. The scheduler also supports features such as pod priority, preemption, affinity rules, and taints/tolerations, providing flexibility and customization for workload distribution. Additionally, Kubernetes allows for the creation of custom schedulers to address specific <span>deployment requirements.</span></li>
<li class="calibre13"><strong class="bold">Controller manager</strong>: One of the core components of Kubernetes architecture, it is responsible for managing various controllers that regulate the state <a id="_idIndexMarker981" class="pcalibre1 pcalibre2 pcalibre"/>of the cluster. Each <a id="_idIndexMarker982" class="pcalibre1 pcalibre2 pcalibre"/>controller is a separate process responsible for monitoring and reconciling the actual state of cluster objects with their desired state, as defined in the Kubernetes API server. Key controllers managed by the controller manager include <span>the following:</span><ul class="calibre17"><li class="calibre13"><strong class="bold">Replication controller</strong>, which <a id="_idIndexMarker983" class="pcalibre1 pcalibre2 pcalibre"/>ensures the specified number of pod replicas <span>are running</span></li><li class="calibre13"><strong class="bold">Node controller</strong>, which <a id="_idIndexMarker984" class="pcalibre1 pcalibre2 pcalibre"/>handles node lifecycle and the <span>service account</span></li><li class="calibre13"><strong class="bold">Token controller</strong>, managing <a id="_idIndexMarker985" class="pcalibre1 pcalibre2 pcalibre"/>the lifecycle of service accounts and API <span>access tokens</span></li></ul>
<p class="calibre3">The controller manager enhances the self-healing capabilities of Kubernetes by continuously monitoring and adjusting the cluster to maintain the desired configuration, ensuring HA and resilience of <span>containerized applications.</span></p>
</li>
<li class="calibre13"><strong class="bold">etcd</strong>: <strong class="source-inline">etcd</strong> is a distributed key-value store central to Kubernetes, serving as the primary <a id="_idIndexMarker986" class="pcalibre1 pcalibre2 pcalibre"/>data repository for cluster <a id="_idIndexMarker987" class="pcalibre1 pcalibre2 pcalibre"/>configuration and state. Employing the <strong class="bold">Raft consensus</strong> algorithm, <strong class="source-inline">etcd</strong> ensures <a id="_idIndexMarker988" class="pcalibre1 pcalibre2 pcalibre"/>strong consistency and HA across distributed nodes, providing reliability and FT. It plays a vital role in cluster coordination, enabling components such as the API server and controller manager to synchronize and share real-time information. Providing support for features such as data backup, secure communication, and a watch mechanism for dynamic updates, <strong class="source-inline">etcd</strong> contributes to the resilience and efficiency of Kubernetes clusters, serving as a critical foundation for managing <span>containerized applications.</span></li>
<li class="calibre13"><strong class="bold">kubelet</strong>: The kubelet is responsible for maintaining the container lifecycle and ensuring <a id="_idIndexMarker989" class="pcalibre1 pcalibre2 pcalibre"/>containers run as expected. Acting as an agent, the kubelet communicates with the Kubernetes control plane to receive pod specifications <a id="_idIndexMarker990" class="pcalibre1 pcalibre2 pcalibre"/>and then ensures the containers are started, stopped, and continuously monitored. It interacts with <a id="_idIndexMarker991" class="pcalibre1 pcalibre2 pcalibre"/>the container runtime (such as <strong class="bold">Docker</strong> or <strong class="source-inline">containerd</strong>) to manage the containers on the node, implementing the desired state described in the pod specifications. Additionally, the kubelet performs health checks on the containers, restarts failed containers when necessary, and reports the node’s status back to the <span>control plane.</span></li>
<li class="calibre13"><strong class="bold">Pod</strong>: A pod is <a id="_idIndexMarker992" class="pcalibre1 pcalibre2 pcalibre"/>the smallest deployable and scalable unit in Kubernetes, representing a group of one or more containers that share the same network <a id="_idIndexMarker993" class="pcalibre1 pcalibre2 pcalibre"/>namespace and storage. Containers within a pod are scheduled together on the same node and can communicate with each other using <strong class="source-inline">localhost</strong>. This design allows them to share data and dependencies easily. Pods serve as the basic building blocks for deploying applications on Kubernetes, and they encapsulate one or more containers, along with shared storage resources and options for how the containers should be run. The Kubernetes API server manages pods and can be replicated, scaled, and updated to meet the dynamic demands of <span>containerized applications.</span></li>
<li class="calibre13"><strong class="bold">kube-proxy</strong>: <strong class="source-inline">kube-proxy</strong> is a vital component in Kubernetes responsible for network proxying and load balancing. Operating at the service level, it facilitates communication <a id="_idIndexMarker994" class="pcalibre1 pcalibre2 pcalibre"/>between pods and <a id="_idIndexMarker995" class="pcalibre1 pcalibre2 pcalibre"/>services by maintaining network rules and updating them based on changes in the cluster’s services and endpoints. With capabilities for service discovery, load balancing, and managing NodePort services, <strong class="source-inline">kube-proxy</strong> ensures efficient and reliable network connectivity within the cluster. It abstracts the complexities of networking, playing a pivotal role in enabling seamless communication between different components of containerized applications in a <span>Kubernetes environment.</span></li>
</ul>
<p class="calibre3">You can <a id="_idIndexMarker996" class="pcalibre1 pcalibre2 pcalibre"/>explore the Kubernetes architecture by running the <span>following command:</span></p>
<pre class="console">kubectl get pods -n kube-system --show-labels</pre>
<p class="calibre3">The preceding command will print the name of the pod, its status, its age (uptime), and labels. Adapting <strong class="source-inline">kubectl</strong> command parameters based on your Kubernetes cluster configurations would be best. A snippet of the output can be seen in the next screenshot; you can <a id="_idIndexMarker997" class="pcalibre1 pcalibre2 pcalibre"/>see various <a id="_idIndexMarker998" class="pcalibre1 pcalibre2 pcalibre"/>parts of Kubernetes architecture, such as the <strong class="bold">event exporter</strong>, <strong class="source-inline">kube-dns</strong>, <strong class="source-inline">kube-proxy</strong>, the <strong class="bold">metrics server</strong>, and so on. Since <a id="_idIndexMarker999" class="pcalibre1 pcalibre2 pcalibre"/>this cluster is operating <a id="_idIndexMarker1000" class="pcalibre1 pcalibre2 pcalibre"/>on <strong class="bold">Google Cloud Platform</strong> (<strong class="bold">GCP</strong>), you will notice pod associations and labels tagged with <strong class="source-inline">gke</strong> for <strong class="bold">Google Kubernetes </strong><span><strong class="bold">Engine</strong></span><span> (</span><span><strong class="bold">GKE</strong></span><span>):</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer185"><img alt="Figure 11.2 – List of pods associated with the GKE cluster system (no application pods)" src="../images/00149.jpeg" class="calibre186"/></div>
</div>
<p class="img---caption" lang="en-US">Figure 11.2 – List of pods associated with the GKE cluster system (no application pods)</p>
<p class="calibre3">In the next section, we will focus on extracting logs for investigations. Now that we understand <a id="_idIndexMarker1001" class="pcalibre1 pcalibre2 pcalibre"/>the Kubernetes architecture, accessing these logs will be much easier <span>and simpler.</span></p>

</div>
</div>


<div id="sbo-rt-content" class="calibre1">
<div id="_idContainer190" class="calibre2">
<h2 id="_idParaDest-210" class="calibre10"><a id="_idTextAnchor224" class="pcalibre1 pcalibre2 pcalibre"/>Acquiring forensic data and container logs for analysis</h2>
<p class="calibre3">Now that <a id="_idIndexMarker1002" class="pcalibre1 pcalibre2 pcalibre"/>we have an overview of key <a id="_idIndexMarker1003" class="pcalibre1 pcalibre2 pcalibre"/>components of the Kubernetes architecture, let us look at how investigators can obtain logs/artifacts from <span>a cluster.</span></p>

<h3 class="calibre11">Container logs</h3>
<p class="calibre3">Various logs <a id="_idIndexMarker1004" class="pcalibre1 pcalibre2 pcalibre"/>are typically available within Kubernetes clusters; some are operational logs, meaning they are related to the cluster’s health, while some are associated <a id="_idIndexMarker1005" class="pcalibre1 pcalibre2 pcalibre"/>with applications running within the containers. These can be specifically useful for <strong class="bold">Digital Forensics and Incident Response</strong> (<strong class="bold">DFIR</strong>) teams to investigate nefarious activities involving a <span>Kubernetes cluster.</span></p>
<p class="calibre3">To understand logs, we break them down into two categories—operational and security logs—along with <a id="_idIndexMarker1006" class="pcalibre1 pcalibre2 pcalibre"/>their use cases. You will notice that some of the logs offer operational insights and <span>security logs:</span></p>
<p class="calibre3"><span><strong class="bold">Operational logs</strong></span><span>:</span></p>

<ul class="calibre12">
<li class="calibre13"><strong class="bold">API server logs</strong>: Reflecting upon the Kubernetes architecture, the API server plays a <a id="_idIndexMarker1007" class="pcalibre1 pcalibre2 pcalibre"/>crucial role in ensuring the Kubernetes <a id="_idIndexMarker1008" class="pcalibre1 pcalibre2 pcalibre"/>cluster operates efficiently. API server logs provide insights into API-related activity, including requests, responses, and authentication details. Specifically, API server logs help monitor API server health, track user activity, and troubleshoot <span>API-related issues.</span>
<p class="calibre3">You can access API server logs using the <span>following command:</span></p>
<pre class="source-code"><strong class="bold">kubectl logs -n kube-system &lt;api-server-pod-name&gt;</strong></pre></li> <li class="calibre13"><strong class="bold">Controller manager logs</strong>: Provides logs related to controller activities, such as node, replication, and cluster interactions. Useful for monitoring the controller’s <a id="_idIndexMarker1009" class="pcalibre1 pcalibre2 pcalibre"/>health, tracking controller <a id="_idIndexMarker1010" class="pcalibre1 pcalibre2 pcalibre"/>decisions, and understanding replication and service-related events. You may access events related to the controller manager through the <span>following command:</span>
<pre class="source-code"><strong class="bold">kubectl logs -n kube-system &lt;controller-manager-pod-name&gt;</strong></pre></li> <li class="calibre13"><strong class="bold">Scheduler logs</strong>: Records logs associated with scheduling decisions made by the Kubernetes <a id="_idIndexMarker1011" class="pcalibre1 pcalibre2 pcalibre"/>scheduler, such as pod placement. This <a id="_idIndexMarker1012" class="pcalibre1 pcalibre2 pcalibre"/>log helps understand and monitor workload distribution, scheduling decisions, and node utilization. You can access logs specific to the Kubernetes controller through the <span>following command:</span>
<pre class="source-code"><strong class="bold">kubectl logs -n kube-system &lt;scheduler-pod-name&gt;</strong></pre></li> <li class="calibre13"><strong class="bold">kubelet logs</strong>: Provides <a id="_idIndexMarker1013" class="pcalibre1 pcalibre2 pcalibre"/>details about pod lifecycle <a id="_idIndexMarker1014" class="pcalibre1 pcalibre2 pcalibre"/>events, container runtime interactions, and heartbeats; logs associated with the kubelet provide insights into pod health and runtime issues. You can access logs related to a particular pod using the following command; note that this command will fetch operational events related to <a id="_idIndexMarker1015" class="pcalibre1 pcalibre2 pcalibre"/>running the pod and not the application logs running <a id="_idIndexMarker1016" class="pcalibre1 pcalibre2 pcalibre"/>within <span>the pod:</span>
<pre class="source-code"><strong class="bold">kubectl logs -n kube-system &lt;kubelet-pod-name&gt;</strong></pre></li> <li class="calibre13"><strong class="bold">kube-proxy logs</strong>: as the name suggests, <strong class="source-inline">kube-proxy</strong> contains logs associated <a id="_idIndexMarker1017" class="pcalibre1 pcalibre2 pcalibre"/>with proxying operations, network rules, and load-balancing activities. <strong class="source-inline">kube-proxy</strong> logs help monitor network-related <a id="_idIndexMarker1018" class="pcalibre1 pcalibre2 pcalibre"/>issues and understand load-balancing issues. To access <strong class="source-inline">kube-proxy</strong> logs, the following command <span>is utilized:</span>
<pre class="source-code"><strong class="bold">kubectl logs -n kube-system &lt;kube-proxy-pod-name&gt;</strong></pre></li> <li class="calibre13"><strong class="bold">etcd logs</strong>: Outlines <a id="_idIndexMarker1019" class="pcalibre1 pcalibre2 pcalibre"/>the cluster changes, cluster state <a id="_idIndexMarker1020" class="pcalibre1 pcalibre2 pcalibre"/>changes, and communication between <strong class="source-inline">etcd</strong> nodes. <strong class="source-inline">etcd</strong> logs provide critical insights into monitoring <strong class="source-inline">etcd</strong> health, tracking cluster state changes, and understanding <strong class="source-inline">etcd</strong>-related issues. You can access <strong class="source-inline">etcd</strong> logs using a <span>similar command:</span>
<pre class="source-code"><strong class="bold">kubectl logs -n kube-system &lt;etcd-pod-name&gt;</strong></pre></li> <li class="calibre13"><strong class="bold">Container runtime logs</strong>: Capture container lifecycle events, image pulls, and runtime-specific <a id="_idIndexMarker1021" class="pcalibre1 pcalibre2 pcalibre"/>details. Logs help monitor container <a id="_idIndexMarker1022" class="pcalibre1 pcalibre2 pcalibre"/>health, runtime issues, and image-associated events. Container runtime logs can be accessed via <strong class="source-inline">journalctl -u docker</strong> or <strong class="source-inline">journalctl -u containerd</strong>. However, if you are running Kubernetes on a cloud platform such as GCP, the best way to access <a id="_idIndexMarker1023" class="pcalibre1 pcalibre2 pcalibre"/>container runtime logs is via Logs Explorer or an equivalent log viewer offered by the <strong class="bold">cloud service </strong><span><strong class="bold">provider</strong></span><span> (</span><span><strong class="bold">CSP</strong></span><span>).</span></li>
<li class="calibre13"><strong class="bold">Network plugin logs</strong>: Provides <a id="_idIndexMarker1024" class="pcalibre1 pcalibre2 pcalibre"/>information on network <a id="_idIndexMarker1025" class="pcalibre1 pcalibre2 pcalibre"/>policies, pod routing, and communication between pods. Network plugin logs are helpful in troubleshooting network issues when clusters cannot communicate with each other. Another exciting use case for a network plugin is that DFIR teams can utilize the <a id="_idIndexMarker1026" class="pcalibre1 pcalibre2 pcalibre"/>log to monitor and analyze <a id="_idIndexMarker1027" class="pcalibre1 pcalibre2 pcalibre"/>traffic between pods. You can access network plugin logs via a similar <span><strong class="source-inline">kubectl</strong></span><span> command:</span>
<pre class="source-code"><strong class="bold">kubectl logs -n kube-system &lt;network plugin pod name&gt;</strong></pre></li> <li class="calibre13"><strong class="bold">Ingress controller logs</strong>: Instrumental in investigating issues when external network <a id="_idIndexMarker1028" class="pcalibre1 pcalibre2 pcalibre"/>traffic does not connect to the intended Kubernetes pod. Typical reasons could be misconfigurations on the ingress <a id="_idIndexMarker1029" class="pcalibre1 pcalibre2 pcalibre"/>controller itself. Ingress controllers are also responsible for terminating SSL/TLS connections; monitoring these events will provide crucial insights into service disruptions due to expired certificates. Similar to accessing other logs, ingress controller logs can be accessed through the <span>following command:</span>
<pre class="source-code"><strong class="bold">kubectl logs -n kube-system &lt;ingress controller pod name&gt;</strong></pre></li> </ul>
<p class="calibre3"><span><strong class="bold">Security logs</strong></span><span>:</span></p>

<ul class="calibre12">
<li class="calibre13"><strong class="bold">API server logs</strong>: From a DFIR perspective, investigators can look into API server logs <a id="_idIndexMarker1030" class="pcalibre1 pcalibre2 pcalibre"/>to identify unauthorized access attempts <a id="_idIndexMarker1031" class="pcalibre1 pcalibre2 pcalibre"/>or authentication failures. You can also use API server logs to monitor for suspicious changes to critical resources such as pods through API <span>server logs.</span></li>
<li class="calibre13"><strong class="bold">kubelet logs</strong>: You can use kubelet logs to look for container anomalies. kubelet logs <a id="_idIndexMarker1032" class="pcalibre1 pcalibre2 pcalibre"/>can provide insights into unexpected <a id="_idIndexMarker1033" class="pcalibre1 pcalibre2 pcalibre"/>behaviors or network activity. You can also use kubelet logs to investigate node-level activities, resource exhaustion, or <span>unusual activities.</span></li>
<li class="calibre13"><strong class="bold">etcd logs</strong>: Useful for <a id="_idIndexMarker1034" class="pcalibre1 pcalibre2 pcalibre"/>investigating changes to unauthorized <a id="_idIndexMarker1035" class="pcalibre1 pcalibre2 pcalibre"/>cluster configurations or parameters. Investigators can also use <strong class="source-inline">etcd</strong> logs to identify data corruption <span>or inconsistencies.</span></li>
<li class="calibre13"><strong class="bold">Network plugin logs</strong>: You <a id="_idIndexMarker1036" class="pcalibre1 pcalibre2 pcalibre"/>can use network <a id="_idIndexMarker1037" class="pcalibre1 pcalibre2 pcalibre"/>plugin logs to analyze network traffic patterns. You can also do a <strong class="source-inline">tcpdump</strong> to verify the network traffic activity using <span>this command:</span>
<pre class="source-code"><strong class="bold">kubectl exec -it &lt;pod-name&gt; -- tcpdump -i eth0</strong></pre>
<p class="calibre3">Network plugin logs provide insights into malicious network traffic between pods and identify evidence of <span>lateral movements.</span></p>
</li> </ul>
<p class="calibre3">All in all, Kubernetes provides a framework to access these logs within each of the pods; however, if the cluster is running on a cloud platform, investigators can also leverage the native log <a id="_idIndexMarker1038" class="pcalibre1 pcalibre2 pcalibre"/>viewer provided by each of the CSPs to quickly access the logs without accessing the logs directly via the cluster. In the following sections, we will look into both perspectives of accessing logs directly via the cluster and using the CSP’s logging console to access Kubernetes cluster logs <span>for investigation.</span></p>

<h3 class="calibre11">Examining the container runtime</h3>
<p class="calibre3">Let’s say you now have a Kubernetes cluster running on the cloud and a pod (applications) setup <a id="_idIndexMarker1039" class="pcalibre1 pcalibre2 pcalibre"/>exposed to the internet accepting user connections. To explain the investigative approach, we are going to define a situation. We have a Kubernetes cluster deployed on Google Cloud, with WordPress and a MySQL server deployed as pods. As outlined in the next screenshot, we have three pods that frame the part of <span>the application:</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer186"><img alt="Figure 11.3 – Pods under the GKE cluster" src="../images/00167.jpeg" class="calibre187"/></div>
</div>
<p class="img---caption" lang="en-US">Figure 11.3 – Pods under the GKE cluster</p>
<p class="calibre3">These pods are configured so that MySQL will store the contents of the WordPress blog and authentication information. As investigators, we are tasked to investigate brute-force attempts on the <span>MySQL server.</span></p>
<p class="calibre3">Now, there are multiple ways to address this. The most popular method is using Google’s Log Explorer. While we walk through an investigation using a cloud tool, you can perform similar tasks with other CSPs as long as Kubernetes logs are configured to be ingested within the CSPs’ cloud logging tools. Currently, there are two ways to investigate/gain access to logs. One is via Log Explorer, and the other is via the command line. It’s up <a id="_idIndexMarker1040" class="pcalibre1 pcalibre2 pcalibre"/>to the investigators to extract the logs and analyze them. We will explore both approaches and determine outcomes. Before investigating Kubernetes, investigators must understand how the organization has deployed the Kubernetes cluster and <span>its architecture.</span></p>

<h4 class="calibre136">Option 1 – Log Explorer</h4>
<ol class="calibre14">
<li class="calibre13">Once investigators can access Log Explorer, we can directly start pinpointing activities relevant <a id="_idIndexMarker1041" class="pcalibre1 pcalibre2 pcalibre"/>to the WordPress and MySQL servers. Remember that WordPress is a frontend tool, while the MySQL server provides <a id="_idIndexMarker1042" class="pcalibre1 pcalibre2 pcalibre"/>the backend database as part of the complete <span>application stack.</span></li>
<li class="calibre13">Through initial triage, we know that there were brute-force attempts; the resource usage dashboard can validate this. The following sample screenshot shows the general resource metrics associated with the Kubernetes cluster that highlight the increased <span>resource usage:</span></li>
</ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer187"><img alt="Figure 11.4 – Kubernetes cluster resource usage" src="../images/00186.jpeg" class="calibre188"/></div>
</div>
<p class="img---caption" lang="en-US">Figure 11.4 – Kubernetes cluster resource usage</p>

<ol class="calibre14">
<li value="3" class="calibre13">Once we have established the basics, we jump onto the Log Explorer page. If you are familiar with querying Log Explorer, you can query the logs in the cluster’s <strong class="source-inline">default</strong> namespace and where the container name is not <strong class="source-inline">wordpress</strong>. Next is the search query snippet that gathers all logs not associated <span>with WordPress:</span>
<pre class="source-code">resource.labels.namespace_name="default"
-resource.labels.container_name="wordpress"</pre></li> <li class="calibre13">Typically, brute-force attempts can be identified through a series of failed logins followed by <a id="_idIndexMarker1043" class="pcalibre1 pcalibre2 pcalibre"/>successful login attempts. We will modify the preceding query to pinpoint the investigator’s failed MySQL access attempts. As investigators, if we are <a id="_idIndexMarker1044" class="pcalibre1 pcalibre2 pcalibre"/>unfamiliar with Google’s Log Explorer query capabilities, we can always click and select appropriate filters, and the query will automatically <span>update itself:</span>
<pre class="source-code">resource.labels.namespace_name="default"
-resource.labels.container_name="wordpress"
--Show similar entries
textPayload=~"(\d{4}-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])) ((\d{2}):(\d{2})(?::(\d{2}(?:\.\d*)?))?(?:([+-](?:\d{2}):?(?:\d{2})?|Z)?)) ((?:\d[,.]?)*\d) \[Warning\] Access denied for user '[^ =\t\n\r\f\"\(\)\[\]\|']+'@'localhost' \(using password: [^ =\t\n\r\f\"\(\)\[\]\|']+"
--End of show similar entries</pre></li> <li class="calibre13">Once you filter down the logs, you can quickly pinpoint logs associated with brute-force attacks. The next screenshot demonstrates the outcomes of the analysis using Log Explorer. In the screenshot, you can see multiple failed login attempts against MySQL before a successful one. Depending upon the deployed container, some logs may also collect granular information. In this case, we can use various usernames being tried by the threat actor before successfully connecting to the server using the <span><strong class="source-inline">wp-admin</strong></span><span> account:</span></li>
</ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer188"><img alt="Figure 11.5 – Analysis of brute-force attacks on Kubernetes pod" src="../images/00006.jpeg" class="calibre189"/></div>
</div>
<p class="img---caption" lang="en-US">Figure 11.5 – Analysis of brute-force attacks on Kubernetes pod</p>
<p class="calibre3">Next, we look <a id="_idIndexMarker1045" class="pcalibre1 pcalibre2 pcalibre"/>into accessing <a id="_idIndexMarker1046" class="pcalibre1 pcalibre2 pcalibre"/>logs directly via the <span>command line.</span></p>

<h4 class="calibre136">Option 2 – Direct command-line access (kubectl)</h4>
<p class="calibre3">In situations <a id="_idIndexMarker1047" class="pcalibre1 pcalibre2 pcalibre"/>where access to the CSP’s logger service is not available, as investigators, you can always <strong class="source-inline">kubectl</strong> to access these individual <span>pod-based logs.</span></p>
<p class="calibre3">Accessing logs <a id="_idIndexMarker1048" class="pcalibre1 pcalibre2 pcalibre"/>from pods is relatively easy. Once you have enumerated all the pods, you can use <strong class="source-inline">kubectl logs &lt;pod name&gt;</strong> to access entire logs. Logs are printed by default to the console; however, you can write the logs to disk for offline analysis. In this case, let’s pull the logs associated with the MySQL pod—<strong class="source-inline">kubectl logs wordpress-1-mysql-0.</strong> The next screenshot extracts the logs associated with the <span>brute-force attack:</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer189"><img alt="Figure 11.6 – Log extract of MySQL pod, evidencing brute-force attack" src="../images/00022.jpeg" class="calibre190"/></div>
</div>
<p class="img---caption" lang="en-US">Figure 11.6 – Log extract of MySQL pod, evidencing brute-force attack</p>
<p class="calibre3">As investigators, we know the importance of logs; with Kubernetes, each pod will have its logs associated with the application it is running, along with other operational logs. However, knowing how <a id="_idIndexMarker1049" class="pcalibre1 pcalibre2 pcalibre"/>to access these logs is vital, as investigators’ access to <a id="_idIndexMarker1050" class="pcalibre1 pcalibre2 pcalibre"/>the CSP’s logging console will also immensely help as they can be maintained longer than hunting the <span>pod itself.</span></p>

</div>
</div>


<div id="sbo-rt-content" class="calibre1">
<div id="_idContainer190" class="calibre2">
<h1 id="_idParaDest-211" class="calibre5"><a id="_idTextAnchor225" class="pcalibre1 pcalibre2 pcalibre"/>Summary</h1>
<p class="calibre3">This chapter explored the distinctions between Docker and Kubernetes, emphasizing their collaborative use for comprehensive container management. We delved into various types of containers and their specific use cases, highlighting their efficiency in scenarios such as <span>microservices architectures.</span></p>
<p class="calibre3">Additionally, we looked at acquiring forensic data and logs for analysis in Kubernetes environments, emphasizing logging mechanisms, tools, and best practices for practical forensic analysis, including identifying security breaches and incident investigations. However, accessing Kubernetes logs is one of the most straightforward investigations. If Kubernetes is deployed in the cloud, CSPs are crucial for providing access to a centralized log explorer for longer-term <span>log access.</span></p>
<p class="calibre3">In our next chapter, we will review the analysis of the cloud productivity suites hosted on Microsoft 365 and Google Workspace. The focus of this chapter is to understand how to analyze common threat vectors on productivity suites and which logs are available <span>to investigators.</span></p>

</div>
</div>


<div id="sbo-rt-content" class="calibre1">
<div id="_idContainer190" class="calibre2">
<h1 id="_idParaDest-212" class="calibre5"><a id="_idTextAnchor226" class="pcalibre1 pcalibre2 pcalibre"/>Further reading</h1>
<ul class="calibre12">
<li class="calibre13"><em class="italic">The Raft Consensus </em><span><em class="italic">Algorithm</em></span><span>: </span><a href="https://raft.github.io/" class="pcalibre1 pcalibre2 pcalibre"><span>https://raft.github.io/</span></a></li>
<li class="calibre13"><em class="italic">Cluster </em><span><em class="italic">Networking</em></span><span>: </span><a href="https://kubernetes.io/docs/concepts/cluster-administration/networking/" class="pcalibre1 pcalibre2 pcalibre"><span>https://kubernetes.io/docs/concepts/cluster-administration/networking/</span></a></li>
<li class="calibre13"><em class="italic">Kubernetes </em><span><em class="italic">Forensics</em></span><span>:</span> <a href="mailto:https://medium.com/@cloud_tips/kubernetes-forensics-c1e558b10d53#:~:text=This%20can%20involve%20looking%20for,command%2Dline%20interface%20for%20Kubernetes" class="pcalibre1 pcalibre2 pcalibre"><span>https://medium.com/@cloud_tips/kubernetes-forensics-c1e558b10d53#:~:text=This%20can%20involve%20looking%20for,command%2Dline%20interface%20for%20Kubernetes</span></a></li>
<li class="calibre13"><em class="italic">Incident response and </em><span><em class="italic">forensics</em></span><span>:</span> <a href="https://aws.github.io/aws-eks-best-practices/security/docs/incidents/?source=post_page-----c1e558b10d53" class="pcalibre1 pcalibre2 pcalibre"><span>https://aws.github.io/aws-eks-best-practices/security/docs/incidents/?source=post_page-----c1e558b10d53</span></a></li>
<li class="calibre13"><em class="italic">Image </em><span><em class="italic">security</em></span><span>:</span> <a href="https://aws.github.io/aws-eks-best-practices/security/docs/image/" class="pcalibre1 pcalibre2 pcalibre"><span>https://aws.github.io/aws-eks-best-practices/security/docs/image/</span></a></li>
<li class="calibre13"><em class="italic">CIS Kubernetes </em><span><em class="italic">Benchmarks</em></span><span>:</span> <a href="https://www.cisecurity.org/benchmark/kubernetes" class="pcalibre1 pcalibre2 pcalibre"><span>https://www.cisecurity.org/benchmark/kubernetes</span></a></li>
<li class="calibre13"><em class="italic">10+ Top Kubernetes Security Tools in </em><span><em class="italic">2023</em></span><span>:</span> <a href="mailto:https://medium.com/@pdevsecops/10-top-kubernetes-security-tools-in-2023-df26642f995a" class="pcalibre1 pcalibre2 pcalibre"><span>https://medium.com/@pdevsecops/10-top-kubernetes-security-tools-in-2023-df26642f995a</span></a></li>
<li class="calibre13"><em class="italic">Top Kubernetes Security Tools in </em><span><em class="italic">2023</em></span><span>:</span> <a href="https://www.armosec.io/blog/kubernetes-security-tools/" class="pcalibre1 pcalibre2 pcalibre"><span>https://www.armosec.io/blog/kubernetes-security-tools/</span></a></li>
</ul></div>
</div>
</body></html>