- en: Now for Something Completely Different
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 现在，呈现一些完全不同的内容
- en: This book presents Python as a necessary tool to optimize digital forensic analysis—written
    from an examiner's perspective. In the first two chapters, we introduce the basics
    of Python in preparation for the remainder of this book, where we will develop
    scripts to accomplish forensic tasks. While focused on the use of the language
    as a tool, we will also explore the advantages of Python and how they allow many
    individuals in the field to create solutions for complex forensic challenges.
    Like Monty Python, Python's namesake, the next 12 chapters aim to present *something
    completely different*.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本书将Python作为优化数字取证分析的必要工具——从检查员的角度出发进行编写。在前两章中，我们将介绍Python的基础知识，为本书其余部分做准备，在后续章节中，我们将开发脚本以完成取证任务。虽然重点是将该语言作为工具使用，但我们也会探讨Python的优势，以及它如何帮助许多领域的从业者为复杂的取证挑战创建解决方案。就像Python的名字来源于Monty
    Python一样，接下来的12章旨在呈现*一些完全不同*的内容。
- en: In this fast-paced field, a scripting language provides flexible problem solving
    in an automated fashion, allowing the examiner additional time to investigate
    other artifacts that, due to time constraints, may not have been analyzed as thoroughly
    otherwise. Admittedly, Python may not always be the right tool to complete the
    task at hand, but it is an invaluable tool to add to anyone's DFIR arsenal. Should
    you undertake the task of mastering Python, it will more than pay off the time
    investment as you will increase your analysis capabilities many fold and greatly
    diversify your skill set. This chapter outlines the basics of Python, from `Hello
    World` to core scripting concepts.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个快速发展的领域中，脚本语言以自动化的方式提供灵活的问题解决方案，使检查员能够有更多的时间去调查其他由于时间限制可能未能彻底分析的证据。诚然，Python可能并不总是完成任务的最佳工具，但它是任何人的DFIR工具库中不可或缺的工具。如果你决定掌握Python，它将大大回报你投入的时间，因为你将显著提高分析能力，并大大拓展你的技能。
    本章概述了Python的基础知识，从`Hello World`到核心脚本概念。
- en: 'This chapter will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: An introduction to Python and healthy development practices
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python介绍及健康的开发实践
- en: Basic programming concepts
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本编程概念
- en: Manipulating and storing objects in Python
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Python中操作和存储对象
- en: Creating simple conditionals, loops, and functions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建简单的条件判断、循环和函数
- en: When to use Python
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 何时使用Python
- en: Python is a powerful forensic tool. However, before deciding to develop a script,
    it is important to consider the type of analysis that's required and the project
    timeline. In the examples that follow, we will outline situations where Python
    is invaluable and, conversely, when it is not worth the development effort. Though
    rapid development makes it easy to deploy a solution in a tough situation, Python
    is not always the best tool to implement. If a tool exists that performs the task
    at hand, and is available, it may be the more appropriate method for analysis.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Python是一个强大的取证工具。然而，在决定开发脚本之前，重要的是要考虑所需的分析类型和项目的时间表。在接下来的例子中，我们将概述Python在某些情况下如何是不可或缺的工具，反之，在其他情况下它的开发工作可能并不值得。尽管快速开发使得在复杂情况下轻松部署解决方案，Python并不总是实现任务的最佳工具。如果现有工具已经能够完成任务，并且可以使用，那么它可能是更合适的分析方法。
- en: 'Python is a preferred programming language for forensics due to its ease of
    use, library support, detailed documentation, and interoperability among operating
    systems. There are two main types of programming languages: those that are interpreted
    and those that are compiled. Compiling code allows the programming language to
    be converted into machine language. This lower-level language is more efficient
    for the computer to interpret. Interpreted languages are not as fast as compiled
    languages at runtime, but do not require compilation, which can take some time.
    Because Python is an interpreted language, we can make modifications to our code
    and immediately run and view the results. With a compiled language, we would have
    to wait for our code to re-compile before viewing the effect of our modifications.
    For this reason, Python may not run as quickly as a compiled language, but allows
    for rapid prototyping.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Python是取证工作中常用的编程语言，因其易用性、库支持、详细文档以及跨操作系统的互操作性。编程语言主要有两种类型：解释型语言和编译型语言。编译代码可以将编程语言转换为机器语言，这种低级语言计算机更容易解释。解释型语言在运行时的速度不如编译型语言，但不需要编译，这样可以节省一些时间。由于Python是解释型语言，我们可以修改代码并立即运行查看结果。而对于编译型语言，我们必须等待代码重新编译后才能看到修改效果。因此，虽然Python的运行速度可能不如编译型语言，但它支持快速原型开发。
- en: An incident response case presents an excellent example of when to use Python
    in a real-life setting. For example, let's consider that a client calls, panicked,
    reporting a data breach and is unsure of how many files were exfiltrated over
    the past 24 hours from their file server. Once on site, you are instructed to
    perform the fastest count of files accessed in the past 24 hours as this count,
    and the list of compromised files, will determine the course of action.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 事件响应案例是一个极好的示例，展示了在实际环境中何时使用Python。例如，假设客户打来电话，慌张地报告数据泄露，并且不确定过去24小时内有多少文件从他们的文件服务器中被外泄。到达现场后，你被指示执行最快的文件访问次数统计，因为这个统计数字和泄露文件的列表将决定下一步的行动。
- en: 'Python fits this bill quite nicely here. Armed with just a laptop, you can
    open a text editor and begin writing a solution. Python can be built and designed
    without the need for a fancy editor or toolset. The build process of your script
    may look like this, with each step building upon the previous one:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Python在这种情况下非常合适。只需要一台笔记本电脑，你就可以打开文本编辑器并开始编写解决方案。Python可以在没有复杂编辑器或工具集的情况下进行构建和设计。你脚本的构建过程可能是这样的，每一步都建立在前一步的基础上：
- en: Make the script read a single file's last accessed timestamp
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让脚本读取单个文件的最后访问时间戳
- en: Write a loop that steps through directories and subdirectories
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个循环，逐步遍历目录和子目录
- en: Test each file to see if that timestamp is from the past 24 hours
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试每个文件，看看该时间戳是否来自过去24小时
- en: If it has been accessed within 24 hours, then create a list of affected files
    to display file paths and access times
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果文件在过去24小时内被访问过，则创建一个受影响文件的列表，显示文件路径和访问时间
- en: The process here would result in a script that recurses over the entire server
    and output files found with a last accessed time in the past 24 hours for manual
    review. This script will likely be approximately 20 lines of code and have required
    10 minutes, or less, for an intermediate scripter to develop and validate—it is
    apparent this would be more efficient than manually reviewing timestamps on the
    filesystem.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的过程将生成一个脚本，该脚本会遍历整个服务器，并输出在过去24小时内最后一次访问时间的文件，以供人工审核。这个脚本可能只有大约20行代码，并且一个中级脚本员大约需要10分钟或更少的时间来开发和验证——显然，这比手动检查文件系统中的时间戳更高效。
- en: Before deploying any developed code, it is imperative that you validate its
    capability first. As Python is not a compiled language, we can easily run the
    script after adding new lines of code to ensure we haven't broken anything. This
    approach is known as **test-then-code**, a method commonly used in script development.
    Any software, regardless of who wrote it, should be scrutinized and evaluated
    to ensure accuracy and precision. Validation ensures that the code is operating
    properly, and although more time-consuming, provides reliable results that are
    capable of withstanding the courtroom, an important aspect in forensics.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在部署任何已开发的代码之前，必须首先验证其能力。由于 Python 不是编译型语言，我们可以在添加新代码行后轻松运行脚本，以确保没有破坏任何功能。这种方法被称为**先测试后编码**，是脚本开发中常用的方式。任何软件，不管是谁编写的，都应当经过仔细审查和评估，以确保准确性和精确性。验证确保代码正常运行，虽然这需要更多的时间，但它提供了可靠的结果，能够经得起法庭的考验，这是法医领域中的一个重要方面。
- en: A situation where Python may not be the best tool is for general case analysis.
    If you are handed a hard drive and asked to find evidence without additional insight,
    then a pre-existing tool will be the better solution. Python is invaluable for
    targeted solutions, such as analyzing a given file type and creating a metadata
    report. Developing a custom all-in-one solution for a given filesystem requires
    too much time to create when other tools, both paid and free, exist that support
    such generic analysis.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在一般案例分析中，Python 可能不是最佳工具。如果你拿到一个硬盘并被要求在没有额外线索的情况下寻找证据，那么使用已有的工具会是更好的解决方案。Python
    在针对性解决方案中非常有价值，比如分析特定类型的文件并生成元数据报告。为某一文件系统开发一个定制的全能解决方案所需的时间太长，尤其是考虑到市面上已有的支持这种通用分析的工具，不论是付费还是免费。
- en: Python is useful in pre-processing automation. If you find yourself repeating
    the same tasks for each piece of evidence, it may be worthwhile to develop a system
    that automates those steps. A great example of suites that perform such analysis
    is ManTech's analysis and triage system (mantaray: [http://github.com/mantarayforensics](http://github.com/mantarayforensics)),
    which leverages a series of tools to create general reports that can speed up
    analysis when there is no scope of what data may exist.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Python 在预处理自动化中非常有用。如果你发现自己在处理每一份证据时都在重复相同的任务，那么开发一个自动化这些步骤的系统可能是值得的。一个很好的例子是
    ManTech 的分析与分类系统（mantaray：[http://github.com/mantarayforensics](http://github.com/mantarayforensics)），它利用一系列工具生成通用报告，在数据范围不明确的情况下加快分析速度。
- en: When considering whether to commit resources to develop Python scripts, either
    on the fly or for larger projects, it is important to consider what solutions
    already exist, the time available to create a solution, and the time saved through
    automation. Despite best intentions, the development of solutions can go on for
    much longer than initially conceived without a strong design plan.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑是否投入资源开发 Python 脚本时，无论是临时开发还是针对较大项目开发，都应考虑已经存在的解决方案、可用的开发时间以及通过自动化节省的时间。尽管有着最佳的意图，解决方案的开发可能会比最初设想的时间要长得多，尤其是当没有一个强有力的设计计划时。
- en: Development life cycle
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发生命周期
- en: 'The development cycle involves at least five steps:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 开发周期至少包括五个步骤：
- en: Identify
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别
- en: Plan
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计划
- en: Program
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编程
- en: Validate
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证
- en: Bugs
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误
- en: 'The first step is self-explanatory; before you develop, you must identify the
    problem that needs to be solved. Planning is perhaps the most crucial step in
    the development cycle:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是不言自明的：在开发之前，你必须识别出需要解决的问题。规划可能是开发周期中最关键的一步：
- en: '![](img/289dd91f-6deb-4ef5-bb00-85fa1c63de51.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/289dd91f-6deb-4ef5-bb00-85fa1c63de51.png)'
- en: 'Good planning will help later by decreasing the amount of code required and
    the number of bugs. Planning becomes even more vital during the learning process.
    A forensic programmer must begin to answer the following questions: how will data
    be ingested, what Python data types are most appropriate, are third-party libraries
    necessary, and how will the results be displayed to the examiner? In the beginning,
    just as if we were writing a term paper, it is a good idea to write, or draw,
    an outline of your program. As you become more proficient in Python, planning
    will become second nature, but initially, it is recommended to create an outline
    or write pseudocode.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的规划将有助于减少所需的代码量和 bug 数量，从而在后期节省时间。规划在学习过程中变得尤为重要。一个取证程序员必须开始回答以下问题：数据将如何被接收，哪些
    Python 数据类型最为合适，是否需要第三方库，结果将如何呈现给检查员？刚开始时，就像写学期论文一样，最好先写一个大纲，或者画出程序的框架。随着 Python
    熟练度的提高，规划将变成第二天性，但在最初阶段，建议先创建一个大纲或编写伪代码。
- en: 'Pseudocode is an informal way of writing code before filling in the details
    with actual code. Pseudocode can represent the bare bones of the program, such
    as defining pertinent variables and functions while describing how they will all
    fit together within the script''s framework. Pseudocode for a function might look
    like this:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 伪代码是一种在填充实际代码之前编写代码的非正式方式。伪代码可以表示程序的框架，如定义相关的变量和函数，并描述它们如何在脚本框架中组合在一起。一个函数的伪代码可能是这样的：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: After identifying and planning, the next three steps make up the largest part
    of the development cycle. Once your program has been sufficiently planned, it
    is time to start writing code! Once the code is written, break in your new program
    with as much test data as possible. Especially in forensics, it is critical to
    thoroughly test your code instead of relying on the results of one example. Without
    comprehensive debugging, the code can crash when it encounters something unexpected,
    or, even worse, it could provide the examiner with false information and lead
    them down the wrong path. After the code has been tested, it is time to release
    it and prepare for bug reports. We are not talking about insects here! Despite
    a programmer's best efforts, there will always be bugs in the code. Bugs have
    a nasty way of multiplying even as you squash one, perpetually causing the programming
    cycle to begin repeatedly.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在确定和规划之后，接下来的三个步骤构成了开发周期的最大部分。一旦程序的规划充分完成，就可以开始编写代码了！编写代码后，用尽可能多的测试数据来测试你的新程序。尤其在取证领域，彻底测试代码至关重要，而不是仅仅依赖一个例子的结果。如果没有全面的调试，代码在遇到意外情况时可能会崩溃，或者更糟糕的是，它可能会给检查员提供错误的信息，导致他们走错方向。代码测试完成后，就可以发布，并准备接受错误报告了。我们这里说的可不是昆虫！尽管程序员尽了最大努力，代码中总是会存在
    bug。即便你修复了一个 bug，它们也有一种令人讨厌的方式会不断繁殖，导致编程周期不断地重复开始。
- en: Getting started
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门
- en: 'Before we get started, it is necessary that you install Python on your machine.
    It is important to understand that, at the time of writing this book, there are
    two supported versions of Python: Python 2 and 3\. We will use both Python 2 and
    3 to develop our solutions. Historically, many of the useful third-party forensic
    libraries were developed for Python 2\. At this point, most libraries are compatible
    with Python 3, which has superior Unicode handling, a major headache in Python
    2, among a number of other improvements. All of the code in this book has been
    tested with the latest appropriate versions of Python 2 (v. 2.7.15) or 3 (v. 3.7.1).
    In some cases, our code is compatible with both Python 2 and 3, or only works
    with one of the two. Each chapter will describe what version of Python is required
    to run the code.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，你需要在机器上安装 Python。需要明白的是，在编写本书时，Python 有两个支持的版本：Python 2 和 3。我们将同时使用
    Python 2 和 3 来开发我们的解决方案。从历史上看，许多有用的第三方取证库都是为 Python 2 开发的。目前，大部分库都与 Python 3 兼容，而
    Python 3 提供了更强大的 Unicode 处理能力，解决了 Python 2 中的一大难题，还做了许多其他改进。本书中的所有代码都已经在最新的 Python
    2（v. 2.7.15）或 3（v. 3.7.1）版本中进行过测试。在某些情况下，我们的代码兼容 Python 2 和 3，或者只兼容其中一个版本。每一章将会描述运行代码所需的
    Python 版本。
- en: Additionally, we recommend using an **integrated development environment**,
    or **IDE**, such as JetBrain's PyCharm. An IDE will highlight errors and offer
    suggestions that help streamline the development process and promote best practices
    when writing code. In the case that the installation of an IDE is not available,
    a simple text editor will work. We recommend an application such as Notepad++,
    Sublime Text, or Visual Studio Code. For those who are command line orientated,
    an editor such as vim or nano will work as well.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们建议使用**集成开发环境**，简称**IDE**，例如JetBrain的PyCharm。IDE能够高亮显示错误并提供建议，帮助简化开发过程并促进编码时的最佳实践。如果无法安装IDE，简单的文本编辑器也能使用。我们推荐像Notepad++、Sublime
    Text或Visual Studio Code这样的应用程序。对于喜欢命令行的用户，像vim或nano这样的编辑器也能使用。
- en: With Python installed, let's open the interactive prompt by typing `python`
    into your Command Prompt or Terminal. We will begin by introducing some built-in
    functions for use in troubleshooting. The first line of defense when confused
    by any object or function discussed in this book, or found in the wild, is the
    `type()`, `dir()`, and `help()` built-in functions. We realize we have not yet
    introduced common data types and so the following code might appear confusing.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装了Python后，让我们通过在命令提示符或终端中输入`python`来打开交互式提示符。我们将从介绍一些内置函数开始，以便用于故障排除。遇到本书中讨论的任何对象或函数，或在实际应用中遇到的函数时，第一步就是使用`type()`、`dir()`和`help()`这些内置函数。我们意识到我们尚未介绍常见的数据类型，因此以下代码可能看起来有些困惑。
- en: However, that is exactly the point of this exercise. During development, you
    will encounter data types you are unfamiliar with or be unsure what methods exist
    to interact with the object. These three functions help solve those issues. We
    will introduce the fundamental data types later in this chapter.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这正是本练习的重点。在开发过程中，你会遇到一些你不熟悉的数据类型，或者不确定如何与对象交互。这三个函数有助于解决这些问题。我们将在本章后面介绍基本数据类型。
- en: The `type()` function, when supplied with an object, will return its `__name__`
    attribute, providing type identifying information about the object. The `dir()`
    function, when supplied with a string representing the name of an object, will
    return its attributes, showing the available options of the functions and parameters
    belonging to the object. The `help()` function can be used to display the specifics
    of these methods through its **docstrings**. Docstrings are nothing more than
    descriptions of a function that detail the inputs, outputs, and how to use the
    function.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`type()`函数在传入一个对象时，会返回其`__name__`属性，提供关于对象的类型识别信息。`dir()`函数在传入表示对象名称的字符串时，会返回其属性，显示该对象所属函数和参数的可用选项。`help()`函数可以通过其**文档字符串**展示这些方法的具体信息。文档字符串其实就是对一个函数的描述，详细说明了函数的输入、输出以及如何使用该函数。'
- en: Let's look at the `str`, or string, object as an example of these three functions.
    In the following example, passing a series of characters surrounded by single
    quotes to the `type()` function results in a type of `str`, or string.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以`str`，即字符串对象，作为这三个函数的示例。在以下示例中，将一系列由单引号括起来的字符传递给`type()`函数，返回的类型是`str`，即字符串。
- en: When we show examples where our typed input follows the `>>>` symbol, this indicates
    that you should type these statements in the Python interactive prompt. The Python
    interactive prompt can be accessed by typing `python` in the Command Prompt.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们展示示例时，如果输入的内容紧跟在`>>>`符号之后，这表示你应在Python交互式提示符中输入这些语句。你可以通过在命令提示符中输入`python`来访问Python交互式提示符。
- en: These basic functions behave similarly in both Python 2 and 3\. Unless otherwise
    stated, these function calls and their output are executed with Python 3.7.1\.
    Please note, however, that the purposes of these built-in functions largely remain
    the same and have similar outputs between Python versions.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这些基本函数在Python 2和3中的表现相似。除非另有说明，以下函数调用及其输出都是在Python 3.7.1环境下执行的。然而请注意，这些内置函数的用途在不同的Python版本中大体相同，输出也非常类似。
- en: 'Here is an example:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例：
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If we pass in an object to the `dir()` function, such as `str`, we can see its
    methods and attributes. Let's say that we want to know what one of these functions,
    `title()`, does. We can use the `help()` function specifying the object and its
    function as the input.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将一个对象传递给`dir()`函数，例如`str`，我们可以看到它的方法和属性。假设我们想知道其中一个函数，`title()`，是做什么的。我们可以使用`help()`函数，指定对象和其函数作为输入。
- en: 'The output of the function tells us no input is required, the output is a string
    object, and that the function capitalized the first character of every word. Let''s
    use the `title` method on the `what am I?` string:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数的输出告诉我们不需要输入，输出是一个字符串对象，并且该函数将每个单词的第一个字符大写。让我们在`what am I?`字符串上使用`title`方法：
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, type `number = 5`. Now we have created a variable, called `number`, that
    has the numerical value of `5`. Using `type()` on that object indicates that `5`
    is an `int`, or integer. Going through the same procedure as before, we can see
    a series of available attributes and functions for the integer object. With the
    `help()` function, we can check what the `__add__()` function does for our `number`
    object. From the following output, we can see that this function is equivalent
    to using the `+` symbol on two values:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，输入`number = 5`。现在我们创建了一个名为`number`的变量，它的数值是`5`。使用`type()`函数查看该对象时，显示它是一个`int`（整数）。按照之前的步骤，我们可以看到整数对象的可用属性和函数。通过`help()`函数，我们可以查看`__add__()`函数在我们的`number`对象上执行了什么操作。从以下输出中，我们可以看到，这个函数等同于在两个值之间使用`+`符号：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let''s compare the difference between the `__add__()` function and the `+`
    symbol to verify our assumption. Using both methods to add `3` to our `number`
    object results in a returned value of `8`, as expected. Unfortunately, we''ve
    also broken a best practice rule illustrating this example:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们比较`__add__()`函数和`+`符号之间的区别，以验证我们的假设。使用这两种方法将`3`加到`number`对象上时，返回的值是`8`，如预期那样。不幸的是，我们在演示这个例子时也违反了最佳实践规则：
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Notice how some methods, such as `__add__()`, have double leading and trailing
    underscores. These are referred to as magic methods, and are methods the Python
    interpreter calls and should not be called by the programmer. These magic methods
    are instead called indirectly by the user. For example, the integer `__add__()`
    magic method is called when using the `+` symbol between two numbers. Following
    the previous example, you should never run `number.__add__(3)` instead of `number
    + 3`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意一些方法，例如`__add__()`，前后都有双下划线。这些被称为魔术方法，是Python解释器调用的方法，不应由程序员直接调用。这些魔术方法是通过用户间接调用的。例如，当在两个数字之间使用`+`符号时，整数的`__add__()`魔术方法会被调用。遵循前面的例子，你永远不应该运行`number.__add__(3)`来代替`number
    + 3`。
- en: This rule is broken in a few cases, which we will cover throughout this book,
    though unless the documentation recommends using a magic method, it is best to
    avoid them.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这个规则在一些情况下被打破，我们将在本书中讲解这些情况，不过除非文档推荐使用魔术方法，否则最好避免使用它们。
- en: Python, like any other programming language, has a specific syntax. Compared
    to other common programming languages, Python is rather English-like and can be
    read fairly easily in scripts. This feature has attracted many, including the
    forensics community, to use this language. Even though Python's language is easy
    to read, it is not to be underestimated as it is powerful and supports common
    programming paradigms.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Python和其他编程语言一样，有特定的语法。与其他常见的编程语言相比，Python更像英语，可以在脚本中相对轻松地阅读。这一特点吸引了许多人，包括法医学社区，使用这种语言。尽管Python的语言易于阅读，但它不容小觑，因为它功能强大并支持常见的编程范式。
- en: 'Most programmers start with a simple `Hello World` script, a test that proves
    they are able to execute code and print the famous message into the console window.
    With Python, the code to print this statement is a single line, as seen here,
    written on the first line of a file:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数程序员从一个简单的`Hello World`脚本开始，这是一个测试，证明他们能够执行代码并将著名的消息打印到控制台窗口。在Python中，打印这个语句的代码是一行，如下所示，写在文件的第一行：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Please note that when discussing the code in a script, as opposed to code in
    the interactive prompt, line numbers, starting at 001, are shown for reference
    purposes only. Please do not include these line numbers in your script. The code
    for this script and all scripts can be downloaded at [https://packtpub.com/books/content/support](https://packtpub.com/books/content/support).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当讨论脚本中的代码时，与交互式提示符中的代码不同，行号（从001开始）仅用于参考。请不要在您的脚本中包含这些行号。此脚本及所有脚本的代码可以在[https://packtpub.com/books/content/support](https://packtpub.com/books/content/support)下载。
- en: 'Save this line of code in a file called `hello.py`. To run this script, we
    call Python and the name of the script. If you are using Python 3, the message
    `Hello World!` should be displayed in your Terminal:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 将这一行代码保存在名为`hello.py`的文件中。要运行此脚本，我们调用Python和脚本的名称。如果你使用的是Python 3，`Hello World!`消息应该会显示在你的终端中：
- en: '![](img/383f350b-0090-40e5-88f1-cdc79124cb68.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](img/383f350b-0090-40e5-88f1-cdc79124cb68.png)'
- en: Let's discuss why this simple script will not execute successfully in some versions
    of Python 2.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论一下为什么这个简单的脚本在某些版本的 Python 2 中无法成功执行。
- en: The omnipresent print() function
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无处不在的 `print()` 函数
- en: Printing in Python is a very common technique as it allows the developer to
    display text to the console as the script executes. While there are many differences
    between Python 2 and 3, the way printing is called is the most obvious change,
    and is the reason why our previous example primarily only works with Python 3
    as it is currently written. With Python 3, `print` became a function rather than
    a statement, as was the case with older versions of Python 2\. Let's revisit our
    previous script and see a slight difference.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中打印是一项非常常见的技术，因为它允许开发者在脚本执行时将文本显示到控制台。虽然 Python 2 和 3 之间有许多差异，但打印调用方式是最明显的变化，也是我们之前的示例仅能在
    Python 3 中运行的原因。到了 Python 3，`print` 变成了一个函数，而不再是像旧版 Python 2 那样的语句。让我们回顾一下之前的脚本，看看有何微小差异。
- en: 'Note the following for Python 3:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 Python 3 中的以下内容：
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Note the following for Python 2:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 Python 2 中的以下内容：
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The difference is seemingly minor. In Python 2, where `print` is a statement,
    you do not need to wrap what is being printed in parentheses. It would be disingenuous
    to say the difference is just semantics; however, for now just understand that `print`
    is written in two different ways, depending on the version of Python being used.
    The ramifications of this minor change mean that legacy Python 2 scripts that
    use `print` as a statement cannot be executed by Python 3.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 差异看起来微不足道。在 Python 2 中，`print` 是一个语句，你不需要将要打印的内容括在圆括号中。说这种差异只是语义上的问题并不公平；然而，目前只需理解，`print`
    根据所使用的 Python 版本写法不同。这种微小变化的后果是，使用 `print` 作为语句的旧版 Python 2 脚本无法被 Python 3 执行。
- en: Where possible, our scripts will be written to be compatible with both versions
    of Python. This goal, while seemingly impossible due to the difference in `print`,
    can be accomplished by importing a special Python library, called `__future__`,
    and changing the `print` statement to a function. To do this, we need to import
    the `print` function from the `__future__` library and then write all `print`
    commands as `function`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在可能的情况下，我们的脚本将兼容 Python 2 和 3 两个版本。虽然由于 `print` 的差异，看似不可能实现这一目标，但可以通过导入一个名为
    `__future__` 的特殊 Python 库并将 `print` 语句更改为函数来实现。为此，我们需要从 `__future__` 库中导入 `print`
    函数，然后将所有 `print` 命令写为 `function`。
- en: 'The following script executes in both Python 2 and 3:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 以下脚本在 Python 2 和 3 中都能执行：
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '![](img/514ef83c-f121-4986-8c6f-afe695d17374.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](img/514ef83c-f121-4986-8c6f-afe695d17374.png)'
- en: In the previous screenshot, you can see the result of this script in Python
    2.7.15 and Python 3.7.1.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个截图中，您可以看到在 Python 2.7.15 和 Python 3.7.1 中执行此脚本的结果。
- en: Standard data types
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标准数据类型
- en: 'With our first script complete, it is time to understand the basic data types
    of Python. These data types are similar to those found in other programming languages,
    but are invoked with a simple syntax, which is described in the following table
    and sections. For a full list of standard data types available in Python, visit
    the official documentation at [https://docs.python.org/3/library/stdtypes.html](https://docs.python.org/3/library/stdtypes.html):'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 完成第一个脚本后，是时候理解 Python 的基本数据类型了。这些数据类型与其他编程语言中的类型类似，但通过简单的语法进行调用，详细描述见下表和相关章节。有关
    Python 中可用的所有标准数据类型的完整列表，请访问官方文档：[https://docs.python.org/3/library/stdtypes.html](https://docs.python.org/3/library/stdtypes.html)：
- en: '| **Data Type** | **Description** | **Example** |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| **数据类型** | **描述** | **示例** |'
- en: '| `Str` | String | `str()`, `"Hello"`, `''Hello''` |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `Str` | 字符串 | `str()`, `"Hello"`, `''Hello''` |'
- en: '| `Unicode` | Unicode characters | `unicode()`, `u''hello''`, `"world".encode(''utf-8'')`
    |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| `Unicode` | Unicode 字符 | `unicode()`, `u''hello''`, `"world".encode(''utf-8'')`
    |'
- en: '| `Int` | Integer | `int()`, `1`, `55` |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| `Int` | 整数 | `int()`, `1`, `55` |'
- en: '| `Float` | Decimal precision integers | `float()`, `1.0`, `.032` |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `Float` | 小数精度整数 | `float()`, `1.0`, `.032` |'
- en: '| `Bool` | Boolean values | `bool()`, `True`, `False` |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| `Bool` | 布尔值 | `bool()`, `True`, `False` |'
- en: '| `List` | List of elements | `list()`, `[3, ''asd'', True, 3]` |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `List` | 元素的列表 | `list()`, `[3, ''asd'', True, 3]` |'
- en: '| `Dictionary` | Set of key:value pairs used to structure data | `dict()`,
    `{''element'': ''Mn'', ''Atomic Number'': 25, ''Atomic Mass'': 54.938}` |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `Dictionary` | 键值对集合，用于结构化数据 | `dict()`, `{''element'': ''Mn'', ''Atomic
    Number'': 25, ''Atomic Mass'': 54.938}` |'
- en: '| `Set` | List of unique elements | `set()`, `[3, 4, ''hello'']` |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| `Set` | 唯一元素的集合 | `set()`, `[3, 4, ''hello'']` |'
- en: '| `Tuple` | Organized list of elements | `tuple()`, `(2, ''Hello World!'',
    55.6, [''element1''])` |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| `元组` | 有序元素列表 | `tuple()`, `(2, ''Hello World!'', 55.6, [''element1''])`
    |'
- en: '| `File` | A file object | `open(''write_output.txt'', ''w'')` |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| `文件` | 一个文件对象 | `open(''write_output.txt'', ''w'')` |'
- en: We are about to dive into the usage of data types in Python, and recommend that
    you repeat this section as needed to help with comprehension. While reading through
    how data types are handled is important, please be at a computer where you can
    run Python when you work through it the first few times. We invite you to explore
    the data type further in your interpreter and test them to see what they are capable
    of.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们即将深入了解 Python 中数据类型的使用，建议你根据需要反复阅读这一部分以帮助理解。虽然阅读数据类型如何处理很重要，但请确保在你第一次操作时使用可以运行
    Python 的计算机。我们鼓励你在解释器中进一步探索数据类型并进行测试，看看它们能做些什么。
- en: You will find that most of our scripts can be accomplished using only the standard
    data types Python offers. Before we take a look at one of the most common data
    types, strings, we will introduce comments.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现，我们的大多数脚本都可以仅使用 Python 提供的标准数据类型来完成。在我们查看其中一种最常见的数据类型——字符串之前，我们将介绍注释。
- en: 'Something that is always said, and can never be said enough, is to comment
    your code. In Python, comments are formed by any line beginning with the pound,
    or more recently known as the hashtag, `#` symbol. When Python encounters this
    symbol, it skips the remainder of the line and proceeds to the next line. For
    comments that span multiple lines, we can use three single or double quotes to
    mark the beginning and end of the comments rather than using a single pound symbol
    for every line. What follows are examples of types of comments in a file called
    `comments.py`. When running this script, we should only see `10` printed to the
    console as all comments are ignored:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 总是有人说，而且永远说不够的一点是：注释你的代码。在 Python 中，注释是由任何以井号（也就是现在称为“话题标签”）`#`符号开头的行形成的。当 Python
    遇到这个符号时，它会跳过该行的其余部分，继续到下一行。对于跨多行的注释，我们可以使用三个单引号或双引号来标记注释的开始和结束，而不是为每一行都使用单个井号符号。以下是名为
    `comments.py` 文件中不同类型注释的示例。运行此脚本时，我们只会看到 `10` 打印到控制台，因为所有的注释都被忽略了：
- en: '[PRE9]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The output is as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/11aa2e04-ae60-46ee-9779-591806708404.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](img/11aa2e04-ae60-46ee-9779-591806708404.png)'
- en: When this code is executed, we only see the preceding at the console.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行此代码时，我们只会看到前面的输出在控制台上显示。
- en: Strings and Unicode
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串与 Unicode
- en: Strings are a data type that contain any character, including alphanumeric characters,
    symbols, Unicode, and other codecs. With the vast amount of information that can
    be stored as a string, it is no surprise they are one of the most common data
    types. Examples of areas where strings are found include reading arguments at
    the command line, user input, data from files, and outputting data. To begin,
    let us look at how we can define a string in Python.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串是一种包含任何字符的数据类型，包括字母数字字符、符号、Unicode 和其他编码。由于字符串可以存储大量信息，毫不奇怪它们是最常见的数据类型之一。字符串出现的常见场景包括命令行读取参数、用户输入、文件中的数据以及输出数据。首先，让我们来看一下如何在
    Python 中定义一个字符串。
- en: 'There are three ways to create a string: with single quotes, double quotes,
    or with the built-in `str()` constructor method. Note that there is no difference
    between single- and double-quoted strings. Having multiple ways to create a string
    is advantageous, as it allows us to differentiate between intentional quotes within
    a string. For example, in the `''I hate when people use "air-quotes"!''` string,
    we use the single quotes to demarcate the beginning and end of the main string.
    The double quotes inside the string will not cause any issues with the Python
    interpreter. Let''s verify with the `type()` function that both single and double
    quotes create the same type of object:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 创建字符串有三种方式：使用单引号、双引号或内建的 `str()` 构造方法。请注意，单引号和双引号的字符串没有区别。能够通过多种方式创建字符串是有优势的，因为它允许我们在字符串中区分有意使用的引号。例如，在
    `'I hate when people use "air-quotes"!'` 字符串中，我们使用单引号来标记主字符串的开始和结束，字符串中的双引号不会导致
    Python 解释器出现问题。让我们通过 `type()` 函数来验证，单引号和双引号创建的是相同类型的对象：
- en: '[PRE10]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As we saw with comments, a block string can be defined by three single or double
    quotes to create multi-line strings. The only difference is whether we do something
    with the block-quoted value or not:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在注释中所看到的，可以通过三个单引号或双引号来定义块字符串，从而创建多行字符串。唯一的区别是是否对块引号值进行操作：
- en: '[PRE11]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `\n` character in the returned line signifies a line feed or a new line.
    The output in the interpreter displays these newline characters as `\n`, though
    when fed into a file or console, a new line is created. The `\n` character is
    one of the common escape characters in Python. Escape characters are denoted by
    a backslash following a specific character. Other common escape characters include
    `\t` for horizontal tabs, `\r` for carriage returns, `\'`, `\"`, and `\\` for
    literal single quotes, double quotes, and backslashes, among others. Literal characters
    allow us to use these characters without unintentionally using their special meaning
    in Python's context.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also use the add (`+`) or multiply (`*`) operators with strings. The
    add operator is used to concatenate strings together, and the multiply operator
    will repeat the provided string values:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let''s look at some common functions we use with strings. We can remove characters
    from the beginning or end of a string using the `strip()` function. The `strip()`
    function requires the character we want to remove as its input, otherwise it will
    replace whitespace by default. Similarly, the `replace()` function takes two inputs
    the character to replace and what to replace it with. The major difference between
    these two functions is that `strip()` only looks at the beginning and end of a
    string:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We can check if a character or characters are in a string using the `in` statement.
    Or, we can be more specific, and check if a string `startswith()` or `endswith()`
    a specific character(s) instead (you know a language is easy to understand when
    you can create sensible sentences out of functions). These methods return `True`
    or `False` Boolean objects:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We can quickly split a string into a list based on some delimiter. This can
    be helpful to quickly convert data separated by a delimiter into a list. For example,
    **comma-separated values** (**CSV**) data is separated by commas and could be
    split on that value:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Formatting parameters can be used on strings to manipulate them and convert
    them based on provided values. With the `.format()` function, we can insert values
    into strings, pad numbers, and display patterns with simple formatting. This chapter
    will highlight a few examples of the `.format()` method, and we will introduce
    more complex features of it throughout this book. The `.format()` method replaces
    curly brackets with the provided values in order.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the most basic operation for inserting values into a string dynamically:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Our second example displays some of the expressions we can use to manipulate
    a string. Inside the curly brackets, we place a colon, which indicates that we
    are going to specify a format for interpretation. Following this colon, we specify
    that there should be at least six characters printed. If the supplied input is
    not six characters long, we prepend zeroes to the beginning of the input. Lastly,
    the `d` character specifies that the input will be a base 10 decimal:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Our last example demonstrates how we can easily print a string of `20` equal
    signs by stating that our fill character is the equals symbol, followed by the
    caret (to center the symbols in the output), and the number of times to repeat
    the symbol. By providing this format string, we can quickly create visual separators
    in our outputs:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: While we will introduce more advanced features of the `.format()` method, the
    site [https://pyformat.info/](https://pyformat.info/) is a great resource for
    learning more about the capabilities of Python's string formatting.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: Integers and floats
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The integer is another valuable data type that is frequently used—an integer
    is any whole positive or negative number. The float data type is similar, but
    allows us to use numbers requiring decimal-level precision. With integers and
    floats, we can use standard mathematical operations, such as: `+`, `-`, `*`, and
    `/`. These operations return slightly different results based on the object''s
    type (for example, `integer` or `float`).'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: 'An integer uses whole numbers and rounding, for example dividing two integers
    will result in another whole number integer. However, by using one float in the
    equation, even one that has the same value as the integer will result in a float;
    for example, `3/2=1` and `3/2.0=1.5` in Python. The following are examples of
    integer and float operations:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We can use `**` to raise an integer by a power. For example, in the following
    section, we raise `11` by the power of `2`. In programming, it can be helpful
    to determine the numerator resulting from the division between two integers. For
    this, we use the modulus or percent (`%`) symbol. With Python, negative numbers
    are those with a dash character (`-`) preceding the value. We can use the built-in
    `abs()` function to get the absolute value of an integer or float:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'A float is defined by any number with a decimal. Floats follow the same rules
    and operations as we saw with integers, with the exception of the division behavior
    described previously:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Boolean and none
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The integers `0` and `1` can also represent Boolean values in Python. These
    values are the Boolean `False` or `True` objects, respectively. To define a Boolean,
    we can use the `bool()` constructor statement. These data types are used extensively
    in program logic to evaluate statements for conditionals, as covered later in
    this chapter.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: 'Another built-in data type is the null type, which is defined by the keyword
    `None`. When used, it represents an empty object, and when evaluated will return
    `False`. This is helpful when initializing a variable that may use several data
    types throughout execution. By assigning a null value, the variable remains sanitized
    until reassigned:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Structured data types
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are several data types that are more complex and allow us to create structures
    of raw data. This includes lists, dictionaries, sets, and tuples. Most of these
    structures are comprised of the previously mentioned data types. These structures
    are very useful in creating powerful units of values, allowing raw data to be
    stored in a manageable manner.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: Lists
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lists are a series of ordered elements. Lists support any data type as an element
    and will maintain the order of data as it is appended to the list. Elements can
    be called by position or a loop can be used to step through each item. In Python,
    unlike other languages, printing a list takes one line. In languages like Java
    or C++, it can take three or more lines to print a list. Lists in Python can be
    as long as needed and can expand or contract on the fly, another feature uncommon
    in other languages.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create lists by using brackets with elements separated by commas. Or,
    we can use the `list()` class constructor with an iterable object. List elements
    can be accessed by index where `0` is the first element. To access an element
    by position, we place the desired index in brackets following the list object.
    Rather than needing to know how long a list is (which can be accomplished with
    the `len()` function), we can use negative index numbers to access list elements
    in reference to the end (that is, `-3` would retrieve the third to last element):'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We can add, remove, or check if a value is in a list using a couple of different
    functions. The `append()` method adds data to the end of the list. Alternatively,
    the `insert()` method allows us to specify an index when adding data to the list.
    For example, we can add the string `fish` to the beginning, or `0` index, of our
    list:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `pop()` and `remove()` functions delete data from a list either by index
    or by a specific object, respectively. If an index is not supplied with the `pop()`
    function, the last element in the list is popped. Note that the `remove()` function
    only gets rid of the first instance of the supplied object in the list:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We can use the `in` statement to check if some object is in the list. The `count()`
    function tells us how many instances of an object are in the list:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If we want to access a subset of elements, we can use list slice notation.
    Other objects, such as strings, also support this same slice notation to obtain
    a subset of data. Slice notation has the following format, where `a` is our list
    or string object:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In the preceding example, `x` represents the start of the slice, `y` represents
    the end of the slice, and `z` represents the step of the slice. Note that each
    segment is separated by colons and enclosed in square brackets. A negative step
    is a quick way to reverse the contents of an object that supports slice notation and
    would be triggered by a negative number as `*z*`. Each of these arguments is optional.
    In the first example, our slice returns the second element and up to, but not
    including, the fifth element in the list. Using just one of these slice elements
    returns a list containing everything from the second index forward or everything
    up to the fifth index:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Using the third slice element, we can skip every other element or simply reverse
    the list with a negative one. We can use a combination of these slice elements
    to specify how to carve a subset of data from the list:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Dictionaries
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dictionaries, otherwise known as `dict`, are another common Python data container.
    Unlike lists, this object does not add data in a linear fashion. Instead, data
    is stored as key and value pairs, where you can create and name unique keys to
    act as an index for stored values. It is important to note that, in Python 2,
    dictionaries do not preserve the order in which items are added to it. This is
    no longer true as of Python 3.6.5, though in general, we should not rely on the
    `dict()` object maintaining order for us. These objects are used heavily in forensic
    scripting, as they allow us to store data by name in a single object; otherwise,
    we may be left assigning a lot of new variables. By storing data in dictionaries,
    it is possible to have one variable contain very structured data.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: 'We can define a dictionary by using curly braces (`{}`), where each key and
    value pair is delimited by a colon. Additionally, we can use the `dict()` class
    constructor to instantiate dictionary objects. Calling a value from a dictionary
    is accomplished by specifying the key in brackets following the dictionary object.
    If we supply a key that does not exist, we will receive a `KeyError` (notice that
    we have assigned our dictionary to a variable, `a`). While we have not introduced
    variables at this point, it is necessary to highlight some of the functions that
    are specific to dictionaries:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We can add or modify the value of a preexisting key in a dictionary by specifying
    a key and setting it equal to another object. We can remove objects using the
    `pop()` function, similar to the list `pop()` function, to remove an item in a
    dictionary by specifying its key instead of an index:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The `keys()` and `values()` functions return a list of keys and values in the
    dictionary. We can use the `items()` function to return a list of tuples containing
    each key and value pair. These three functions are often used for conditionals
    and loops:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Sets and tuples
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sets are similar to lists in that they contain a list of elements, though they
    must be unique items. With this, the elements must be immutable, meaning that
    the value must remain constant. For this, sets are best used on integers, strings,
    Boolean, floats, and tuples as elements. Sets do not index the elements, and therefore
    we cannot access the elements by their location in the `set`. Instead, we can
    access and remove elements through the use of the `pop()` method mentioned for
    the list method. Tuples are also similar to lists, though they are immutable.
    Built using parenthesis in lieu of brackets, elements do not have to be unique
    and of any data type:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The important difference between a tuple and a list is that a tuple is immutable.
    This means that we cannot change a tuple object. Instead, we must replace the
    object completely or cast it to a list, which is mutable. This casting process
    is described in the next section. Replacing an object is very slow since the operation
    to add a value to a tuple is `tuple = tuple + ('New value',)`, noting that the
    trailing comma is required to denote that this addition is a tuple.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: Data type conversions
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In some situations, the initial data type might not be the desired data type
    and needs to be changed while preserving its content. For example, when a user
    inputs arguments from the command line, they are commonly captured as strings
    and sometimes that user input needs to be, for example, an integer. We would need
    to use the integer class constructor to convert that string object before processing
    the data. Imagine we have a simple script that returns the square of a user-supplied
    integer; we would need to first convert the user input to an integer prior to
    squaring the input. One of the most common ways to convert data types is to wrap
    the variable or string with the constructor method, as shown here, for each of
    the data types:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Invalid conversions, for example, converting the letter `''a''` to an integer,
    will raise a `ValueError`. This error will state that the specified value cannot
    be converted to the desired type. In this case, we would want to use the built-in
    `ord()` method, which converts a character to its integer equivalent based on
    the ASCII value. In other scenarios, we may need to use other methods to convert
    between data types. The following is a table of common built-in data type conversion
    methods we can utilize for most scenarios:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method** | **Description** |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
- en: '| `str()`, `int()`, `float()`, `dict()`, `list()`, `set()`, `tuple()` | Class
    constructor methods |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
- en: '| `hex()`, `oct()` | Converts an integer into a base 16 (hex) or base 8 (octal)
    representation |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
- en: '| `chr()`, `unichr()` | Converts an integer into an ASCII or Unicode character
    |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
- en: '| `ord()` | Converts a character into an integer |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
- en: 'We can also interchange the type or ordered collections found in our list,
    set, and tuple types. Since sets have requirements for what data may be inserted,
    we generally do not cast anything to a set. It is more common, instead, to case
    a set to a list so that we can access values by position:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Files
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will often create file objects to read or write data from a file. File objects
    can be created using the built-in `open()` method. The `open()` function takes
    two arguments, the name of the file and the mode. These modes dictate how we can
    interact with the file object. The mode argument is optional, and if left blank defaults
    to read-only. The following table illustrates the different file modes available
    for use:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '| **File Mode** | **Description** |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
- en: '| `r` | Opens the file for read-only mode (default). *This does not offer forensic
    write protection! Please always use a certified process to protect evidence from
    modification.* |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
- en: '| `w` | Creates, or overwrites the file if it exists, for writing. |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
- en: '| `a` | Creates a file if it doesn''t exist for writing. If the file does exist,
    the file pointer is placed at the end of the file to append writes to the file.
    |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
- en: '| `rb`, `wb`, or `ab` | Opens the file for reading or writing in binary mode.
    |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
- en: '| `r+`, `rb+`, `w+`, `wb+`, `a+`, or `ab+` | Opens the file for reading and
    writing in either standard or binary mode. If the file does not exist, the `w`
    or `a` modes create the file. |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
- en: 'Most often, we will use read and write in standard or binary mode. Let''s take
    a look at a few examples and some of the common functions we might use. For this
    section, we will create a text file called `file.txt` with the following content:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In the following example, we open a file object that exists, `file.txt`, and
    assign it to a variable, `in_file`. Since we do not supply a file mode, it is
    opened in read-only mode by default. We can use the `read()` method to read all
    lines as a continuous string. The `readline()` method can be used to read individual
    lines as a string. Alternatively, the `readlines()` method creates a string for
    each line and stores it in a list. These functions take an optional argument,
    specifying the size of bytes to read.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: The `readline()` and `readlines()` functions use the `\n` or `\r` newline characters
    to segment the lines of a file. This is good for most files, though may not always
    work based on your input data. As an example, CSV files with multiple lines in
    a single cell would not display properly with this type of file-reading interface.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: 'Python keeps track of where we currently are in the file. To illustrate the
    examples we''ve described, we need to use the `seek()` operation to bring us back
    to the start of the file before we run our next example. The `seek()` operation
    accepts a number and will navigate to that decimal character offset within the
    file. For example, if we tried to use the `read()` method before seeking back
    to the start, our next print function (showcasing the `readline()` method) would
    not return anything. This is because the cursor would be at the end of the file
    as a result of the `read()` function:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In a similar fashion, we can create, or open and overwrite, an existing file
    using the `w` file mode. We can use the `write()` function to write an individual
    string or the `writelines()` method to write any iterable object to the file.
    The `writelines()` function essentially calls the `write()` method for each element
    of the iterable object.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, this is tantamount to calling `write()` on each element of a list:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Python does a great job of closing connections to a file object automatically.
    However, best practice dictates that we should use the `flush()` and `close()`
    methods after we finish writing data to a file. The `flush()` method writes any
    data remaining in a buffer to the file, and the `close()` function closes our
    connection to the file object:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Variables
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can assign values to variables using the data types we just covered. By
    assigning values to variables, we can refer to that value, which could be a large
    100-element list, by its variable name. This not only saves the programmer from
    re-typing out the value over and over again, but helps enhance the readability
    of the code and allows us to change the values of a variable over time. Throughout
    this chapter, we have already assigned objects to variables using the `=` sign.
    Variable names can technically be anything, although we recommend the following
    guidelines:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: Variable names should be short and descriptive of the stored content or purpose.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Begin with a letter or underscore.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constant variables should be denoted by capitalized words.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamic variables should be lowercase words separated by underscores.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Never be one of the following or any Python-reserved name: `input`, `output`,
    `tmp`, `temp`, `in`, `for`, `next`, `file`, `True`, `False`, `None`, `str`, `int`,
    `list`.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Never include a space in a variable name. Python thinks two variables are being
    defined and will raise a syntax error. Use underscores to separate words.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generally, programmers use memorable and descriptive names that indicate the
    data they hold. For example, in a script that prompts for the phone number of
    the user, the variable should be `phone_number`, which clearly indicates the purpose
    and contents of this variable. Another popular naming style is `CamelCase`, where
    every word is capitalized. This naming convention is often used in conjunction
    with class names (more on those later in this book).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: 'A variable assignment allows the value to be modified as the script runs. The
    general rule of thumb is to assign a value to a variable if it will be used again.
    Let''s practice by creating variables and assigning them data types we have just
    learned about. While this is simple, we recommend following along in the interactive
    prompt to get in the habit of assigning variables. In the first example here,
    we assign a string to a variable before printing the variable:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The second example introduces some new operators. First, we assign the integer,
    `5`, to the variable, `our_number`. Then, we use the plus-gets (`+=`) as a built-in
    shorthand for `our_number = our_number + 20`. In addition to plus-gets, there
    is minus-gets (`-=`), multiply-gets (`*=`), and divide-gets (`/=`):'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In the following code block, we assign a series of variables before printing
    them. The data types used for our variables are `string`, `integer`, `float`,
    `list`, and `Boolean`, respectively:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Notice the `BOOK_TITLE` and `AUTHOR_NAMES` variables. When a variable is static,
    for instance, non-changing throughout the execution of a script, it is referred
    to as a constant variable. Unlike other programming languages, there is not a
    built-in method for protecting constants from being overwritten, so we use naming
    conventions to assist in reminding us not to replace the value. While some variables
    such as the edition of the book, language, or version of Python might change,
    the title and authors should be constants (we hope). If there is ever confusion
    when it comes to naming and styling conventions in Python, try running the following
    statement in an interpreter:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'As we saw previously, we can use the `split()` method on a string to convert
    it into a list. We can also convert a list into a string using the `join()` method.
    This method follows a string containing the desired common denominator and the
    list as its only argument. In the following example, we are taking list containing
    two strings and joining them into one string, where the elements are separated
    by a comma:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Understanding scripting flow logic
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Flow control logic allows us to create dynamic operations by specifying different
    routes of program execution based upon a series of circumstances. In any script
    worth its salt, some manner of flow control is present. For example, flow logic
    would be required to create a dynamic script that returns different results based
    on options selected by the user. In Python, there are two basic sets of flow logic:
    conditionals and loops.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: 'Flow operators are frequently accompanied by flow logic. These operators can
    be strung together to create more complicated logic. The following table represents
    a *truth table* and illustrates the value of various flow operators based on the
    *A* or *B* variable Boolean state:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '| **A** | **B** | **A and B** | **A or B** | **not A** | **not B** |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
- en: '| F | F | F | F | T | T |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
- en: '| T | F | F | T | F | T |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
- en: '| F | T | F | T | T | F |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
- en: '| T | T | T | T | F | F |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
- en: The logical `AND` and `OR` operators are the third and fourth columns in the
    table. Both *A* and *B* must be `True` for the `AND` operator to return `True`.
    Only one of the variables needs to be `True` for the `OR` operator to be `True`.
    The `not` operator simply switches the Boolean value of the variable to its opposite
    (for example, `True` becomes `False` and vice versa).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: Mastering conditionals and loops will take our scripts to another level. At
    its core, flow logic relies on only two values, `True` or `False`. As noted earlier,
    in Python, these are represented by the Boolean `True` and `False` data types.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: Conditionals
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a script hits a conditional, it's much like standing at a fork in the road.
    Depending on some factor, say a more promising horizon, you may decide to go east
    over west. Computer logic is less arbitrary in that if something is true the script
    proceeds one way, and if it is false then it will go another. These junctions
    are critical; if the program decides to go off the path we've developed for it,
    we'll be in serious trouble.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three statements that are used to form a conditional block: `if`,
    `elif`, and `else`. The conditional block refers to the conditional statements,
    their flow logic, and code. A conditional block starts with an `if` statement
    followed by flow logic, a colon, and indented line(s) of code. If the flow logic
    evaluates to `True`, then the indented code following the `if` statement will
    be executed. If it does not evaluate to `True`, the **Python virtual machine**
    (**PVM**) will skip those lines of code and go to the next line on the same level
    of indentation as the `if` statement. This is usually a corresponding `elif` (else-if)
    or `else` statement.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: Indentation is very important in Python. It is used to demarcate code to be
    executed within a conditional statement or loop. A standard of four spaces for
    indentation is used in this book, though you may encounter code that uses a two-space
    indentation or uses tab characters. While all three of these practices are allowed
    in Python, four spaces are preferred and easier to read.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: In a conditional block, once one of the statements evaluates to `True`, the
    code is executed and the PVM exits the block without evaluating the other statements.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Until we define functions, we will stick to simple `if` statement examples:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Notice how when the flow logic evaluates to `True`, then the code indented following
    the `if` statement is executed. When it evaluates to `False`, the code is skipped.
    Typically, when the `if` statement is false, you will have a secondary statement,
    such as an `elif` or `else` to catch other possibilities, such as when `a` is
    less than or equal to `b`. However, it is important to note that we can just use
    an `if` statement without any `elif` or `else` statements.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: The difference between `if` and `elif` is subtle. We can only functionally notice
    a difference when we use multiple `if` statements. The `elif` statement allows
    for a second condition to be evaluated in the case that the first isn't successful.
    A second `if` statement will be evaluated regardless of the outcome of the first
    `if` statement.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: The `else` statement does not require any flow logic and can be treated as a
    catch-all case for any remaining or unaccounted for case. This does not mean,
    however, errors will not occur when the code in the `else` statement is executed.
    Do not rely on `else` statements to handle errors.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: 'Conditional statements can be made more comprehensive by using the logical
    `and` or `or` operators. These allow for more complex logic in a single conditional
    statement:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The following table can be helpful to understand how common operators work:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operator** | **Description** | **Example** | **Evaluation** |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
- en: '| `<`, `>` | less than, greater than | `8 < 3` | `False` |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
- en: '| `<=`, `>=` | less than equal to, greater than equal to | `5 =< 5` | `True`
    |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
- en: '| `==`, `!=` | equal to, not equal to | `2 != 3` | `True` |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
- en: '| `not` | switches Boolean value | `not True` | `False` |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
- en: Loops
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Loops provide another method of flow control, and are suited to perform iterative
    tasks. A loop will repeat inclusive code until the provided condition is no longer
    `True` or an exit signal is provided. There are two kinds of loops: `for` and
    `while`. For most iterative tasks, a `for` loop will be the best option to use.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: The for loop
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`for` loops are the most common and, in most cases, the preferred method to
    perform a task over and over again. Imagine a factory line; for each object on
    the conveyor belt, a `for` loop could be used to perform some task on it, such
    as placing a label on the object. In this manner, multiple `for` loops can come
    together in the form of an assembly line, processing each object, until they are
    ready to be presented to the user.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: Much like the rest of Python, the `for` loop is very simple syntactically, yet
    powerful. In some languages, a `for` loop needs to be initialized, have a counter
    of sorts, and a termination case. Python's `for` loop is much more dynamic and
    handles these tasks on its own. These loops contain indented code that is executed
    line by line. If the object being iterated over still has elements (for example,
    more items to process) at the end of the indented block, the PVM will position
    itself at the beginning of the loop and repeat the code again.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: 'The `for` loop syntax will specify the object to iterate over and what to call
    each of the elements within the object. Note that the object must be iterable.
    For example, `lists`, `sets`, `tuples`, and `strings` are iterable, but an integer
    is not. In the following example, we can see how a `for` loop treats strings and
    lists and helps us iterate over each element in iterable objects:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'There are additional, more advanced, ways to call a `for` loop. The `enumerate()`
    function can be used to start an index. This comes in handy when you need to keep
    track of the index of the current loop. Indexes are incremented at the beginning
    of the loop. The first object has an index of `0`, the second has an index of
    `1`, and so on. The `range()` function can execute a loop a certain number of
    times and provide an index:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The while loop
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`while` loops are not encountered as frequently in Python. A `while` loop executes
    as long as a statement is true. The simplest `while` loop would be a `while True`
    statement. This kind of loop would execute forever since the Boolean object `True` is
    always `True` and so the indented code would continually execute.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are not careful, you can inadvertently create an infinite loop, which
    will wreak havoc on your script''s intended functionality. It is imperative to
    utilize conditionals to cover all your bases such as `if`, `elif`, and `else`
    statements. If you fail to do so, your script can enter an unaccounted situation
    and crash. This is not to say that `while` loops are not worth using. `while`
    loops are quite powerful and have their own place in Python:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The `break`, `continue`, and `pass` statements are used in conjunction with
    `for` and `while` loops to create more dynamic loops. The `break` escapes from
    the current loop, while the `continue` statement causes the PVM to begin executing
    code at the beginning of the loop, skipping any indented code following the `continue`
    statement. The `pass` statement literally does nothing and acts as a placeholder.
    If you're feeling brave or bored, or worse, both, remove the `break` statement
    from the previous example and note what happens.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: Functions
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functions are the first step to creating more complex Python code. At a high
    level, they are containers of Python code that can be bundled together into a
    callable block. A simple model function requires a single input, performs an operation
    on the provided data, and returns a single output. However, this quickly becomes
    more complicated as functions can run without inputs or optional inputs or do
    not need to return an output at all.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: Functions are an integral component of any programming language and have already
    been encountered many times in this chapter. For example, the append from `list.append()`
    is a function that requires input to add to a list. Once a function is created,
    you can invoke it by its name and pass any required inputs.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to writing functions, more is better. It is much easier to handle
    and troubleshoot a bug in a program with many small functions than one big function.
    Smaller functions make your code more readable and make it easier to find troublesome
    logic. That being said, functions should contain code for a singular purpose,
    such as accessing a certain key in a registry file. There is no need to create
    functions for each line of code in your script. Consider using functions as logical
    blocks of code. Sometimes that is three lines, sometimes that is 50 lines; what's
    important is that the purpose and operation of the functional unit of code is
    clear.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: 'The function syntax starts with a definition, `def`, followed by the name of
    the function, any inputs in parenthesis, and a colon. Following this format are
    indented lines of code that will run when the function is called. Optionally,
    a function may have a return statement to pass information back to the instance
    where it was called from:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: In the example we've just seen, we've created a function named `simple_function()`
    that takes no inputs. This function does not return anything and instead prints
    a string. Let's take a look at more complicated examples.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: 'Our first function, `square()`, takes one input and squares it. As this function
    returns a value, we catch it by assigning it to a variable when invoking the function.
    This variable, `squared_number`, will be equal to the returned value of the function.
    While this is a very succinct function, it is very easily broken if given the
    wrong input. Give the square function some other data type, such as a string,
    and you will receive a `TypeError`:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Our second function, `even_or_odd`, is slightly more advanced. This function
    first checks if it is passed an input that is of type integer. If not, it returns
    immediately, which causes the function to exit. If it is an integer, it performs
    some logic that displays to the user whether the integer is even or odd. Notice
    that when we try to give the function the string, `''5''`, not to be confused
    with the integer, `5`, it returns nothing, whereas in the square function, which
    lacks any input validation checks, this would have caused an error:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Aspiring developers should get in the habit of writing functions. As always,
    functions should be well-commented to help explain their purpose. Functions will
    be used throughout this book, especially as we begin to develop our forensic scripts.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter has covered a wide range of introductory content that provides
    a foundation to be built upon throughout the duration of this book; by the end,
    you will become well-versed in Python development. These topics have been handpicked
    as the most important items to comprise a basic understanding of the language
    as we move forward. We have covered data types, what they are and when they are
    used, variable naming and the associated rules and guidelines, logic and operations
    to manipulate and make decisions based on values, and conditions and loops that
    provide a sequential organization for our scripts and form the baseline of everything
    we develop. The code for this project can be downloaded from GitHub or Packt,
    as described in the *Preface*.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: Please consider re-reading this chapter and working through the examples multiple
    times to help with comprehension. Just like anything else, learning a new language
    requires a lot of practice.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: Through these features alone, we can create basic scripts. Python is a very
    powerful and complex language belying its simplistic syntax. In the next chapter,
    we will explore more complex foundational items and continue expanding upon knowledge
    established in this chapter, prior to moving on to real-world examples.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
