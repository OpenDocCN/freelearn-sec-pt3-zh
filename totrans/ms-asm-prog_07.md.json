["```\naes_sbox:\ndb 0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5\ndb 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76\ndb 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0\ndb 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0\ndb 0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc\ndb 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15\ndb 0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a\ndb 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75\ndb 0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0\ndb 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84\ndb 0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b\ndb 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf\ndb 0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85\ndb 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8\ndb 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5\ndb 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2\ndb 0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17\ndb 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73\ndb 0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88\ndb 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb\ndb 0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c\ndb 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79\ndb 0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9\ndb 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08\ndb 0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6\ndb 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a\ndb 0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e\ndb 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e\ndb 0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94\ndb 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf\ndb 0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68\ndb 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16\n```", "```\nneeds_substitution db 0, 1,  2,  3,  4,  5,  6,  7\\\n                      8, 9, 10, 11, 12, 13, 14, 15\n```", "```\n   lea  ebx, [aes_sbox]\n   lea  esi, [needs_substitution] *; Set the source pointer (ESI) and*\n   mov  edi, esi                  *; destination pointer (EDI) as we* \n *; will be storing substituted* \n                                  ; byte back\n   mov  ecx, 0x10                 *; Set the counter*\n@@:\n   lodsb                          *; Load byte from the value*\n   xlatb                          *; Substitute byte from the s-box*  \n   stosb                          *; Store new byte to the value*\n   loop @b                        *; Loop while ECX != 1*\n```", "```\nmov al, [aes_sbox + eax] *; aes_sbox is the base and EAX is the index*\n```", "```\nftable  dd  1,\\           *; 0!*\n            1,\\           *; 1!*\n            2,\\           *; 2!*\n            6,\\           *; 3!*\n            24,\\          *; 4!*\n            120,\\         *; 5!*\n            720,\\         *; 6!*\n            5040,\\        *; 7!*\n            40320,\\       *; 8!*\n            362880,\\      *; 9!*\n            3628800,\\     *; 10!*\n            39916800,\\    *; 11!*\n            479001600     *; 12!*\n```", "```\nfactorial:\n   push  ebp\n   mov   ebp, esp\n   ;-------------\n   virtual at ebp + 8             *; Assign a readable name to*\n      arg0  dd ?                  *; a location on stack where* \n   end virtual                    *; the parameter is stored*\n   ;-------------\n   mov   eax, [arg0]              *; Load parameter from the stack*\n   cmp   eax, 0x0c                *; Check whether it is in range*\n   ja    .oops                    *; Go there if not*\n   mov   eax, [ftable + eax * 4]  *; Retrieve factorial from* \n *; the lookup table*\n @@:\n   leave\n   ret   4\n\n .oops:\n   xor   eax, eax                 *; Set return value to 0*\n   jmp   @b\n```", "```\nstruc strtabentry [s]\n{\n   .length dw  .pad - .string         *; Length of the string*\n   .string db  s, 0                   *; Bytes of the string*\n   .pad    rb  30 - (.pad - .string)  *; Padding to fill 30 bytes*\n   .size = $ - .length                *; Size of the structure (valid* \n *; in compile time only)*\n}\n```", "```\ntypedef struct\n{\n   short         length;\n   char          string[30];\n}strtabentry;\n```", "```\n*/* GCC (C99) */*\nstrtabentry my_strtab_entry = {.length = sizeof(\"Hello!\"), .string = {\"Hello!\"} };  \n\n*/* MSVC */*\nstrtabentry my_strtab_entry = {sizeof(\"Hello!\"), {\"Hello!\"} };              \n```", "```\nmy_strtab_entry strtabentry \"Hello!\"\n```", "```\nmov  al, [se.string + n]   *; 0 <= n < 30*\n```", "```\nget_string_length:\n   push  ebp\n   mov   ebp, esp\n   push  ebx\n   *;=========*\n   virtual at ebp + 8      *; Give a name to the parameter on stack*\n      .structPtr dd 0      *; The parameter itself is not modified*\n   end virtual\n   *;---------*\n   virtual at ebx          *; Give local name to the structure*\n      .s strtabentry 0     *; The structure is not really defined*\n   end virtual             *; so the string is not modified*\n   *;=========*\n   mov   ebx, [.structPtr] *; Load structure pointer to EBX*\n   mov   ax, [.s.length]   *; Load AX with the length*\n   movzx eax, ax          * ; Upper 16 bits may still contain garbage*\n *; so we need to clean it*\n *dec   eax               ; Exclude null terminator*\n   pop   ebx\n   leave\n   ret   4\n```", "```\nmov   ebx, [.structPtr]\n```", "```\nmov   ebx,[ebp + 8]\n```", "```\nvirtual at ebp + 8\n   .structPtr   dd 0\n   .secondParam dd 0\nend virtual\n```", "```\nmov   ecx, [.secondParam]\n```", "```\nmov   ecx, [ebp + 12]  *; Which is ebp + 8 + sizeof(.structPtr)*\n```", "```\nmov   ax, [.s.length]\n```", "```\nmov   ax, [ebx]\n```", "```\nlea   eax, [.s.string]\n```", "```\nlea   eax, [ebx + 2]\n```", "```\nmov  ebx, [lookup_table + ecx * 4] *; ECX contains the index into array* \n *; of pointers and 4 is the scale (size* \n *; of pointer on 32-bit systems)*\n```", "```\nmacro make_strtab strtabName, [strings]\n{\n   common\n   label strtabName#_ptr dword    *; The # operator concatenates strings*\n   local c                        *; resulting in strtabName_ptr*\n   c = 0\n\n   forward\n   c = c + 1                      *; Count number of structures*\n\n   common\n   dd c                           *; Prepend the array of pointers with* \n *; number of entries*\n\n   forward                        *; Build the pointer table*\n   local a\n   dd a\n\n   common                         *; Build the array of structures*\n   label strtabName dword\n\n   forward\n   a strtabentry strings\n}\n```", "```\nmake_strtab strtabName,\\          *; Spaces are intentionally appended to*\n            \"string 0\",\\          *; strings in order to provide us with* \n            \"string 1 \",\\         *; different lengths.*\n            \"string 2  \",\\\n            \"string 3   \"\n```", "```\nget_string_length:\n   push   ebp,\n   mov    ebp, esp\n   push   ebx ecx\n\n   virtual at ebp + 8\n      .structPtr   dd ?      *; Assign label to first parameter*\n      .structIdx   dd ?      *; Assign label to second parameter*\n   end virtual \n\n   virtual at ebx + ecx\n      .s strtabentry ?       *; Assign label to structure pointer*\n   end virtual\n\n   mov   ebx, [.structPtr]   *; Load pointer to array of structures*\n   mov   ecx, [.structIdx]   *; Load index of the structure of interest*\n   shl   ecx, 5              *; Multiply index by 32*\n   mov   ax, [.s.length]     *; Read the length*\n   movzx eax, ax\n   dec   eax\n   pop   ecx ebx\n   leave\n   ret   8\n```", "```\npush  2                 *; push index on stack*\npush  strtabName        *; push the address of the array*\ncall  get_string_length\n```", "```\nstruc strtabentry [s]\n{\n   .length dw  .pad - .string         *; Length of the string*\n   .string db  s, 0                   *; Bytes of the string*\n   .size = $ - .length                *; Size of the structure (valid* \n *; in compile time only)*\n}\n```", "```\nget_string_length:\n   push   ebp,\n   mov    ebp, esp\n   push   ebx ecx\n\n   virtual at ebp + 8\n      .structPPtr   dd ?     *; Assign label to first parameter*\n      .structIdx   dd ?      *; Assign label to second parameter*\n   end virtual \n\n   virtual at ebx\n      .s strtabentry ?       *; Assign label to structure pointer*\n   end virtual\n\n   mov   ebx, [.structPPtr]  *; Load pointer to array of structures*\n   mov   ecx, [.structIdx]   *; Load index of the structure of interest*\n   shl   ecx, 2              *; Multiply index by 4 (size of pointer\n*                             *; on a 32-bit platform\n*   cmp   ecx, [.structPPtr]  *; Check the index to fit the size of the \n*                             *; array of pointers\n*   jae   .idx_too_big        *; Return error if* index exceeds the bounds\n   mov   ebx, [ebx + ecx + 4]*; We have to add 4 (the size of int), in \n*                             *; order to skip the number of structure\n*                             *; pointers in the array*\n   mov   ax, [.s.length]     *; Read the length*\n   movzx eax, ax\n\n.return:\n   dec   eax\n   pop   ecx ebx\n   leave\n   ret   8\n\n.idx_too_big:\n   xor   eax, eax             *; The value of EAX would be -1 upon return*\n   jmp   .return\n```", "```\nstruc strtabentry [s]\n{\n   .length   dw   .pad - .string\n   .string   db   s, 0\n   .pad      rb   30 - (.pad - .string)\n   .previous dd   ?         *; Pointer to the next node*\n   .next     dd   ?         *; Pointer to the previous node*\n   .size = $ - .length\n}\n```", "```\nvoid add_node(strtabentry** top, strtabentry* node);\n```", "```\nadd_node:\n   push   ebp\n   mov    ebp, esp\n   push   eax ebx ecx\n\n   virtual at ebp + 8\n      .topPtr  dd ?\n      .nodePtr dd ?\n   end virtual\n   virtual at ebx\n      .scx strtabentry ?\n   end virtual\n   virtual at ecx\n      .sbx strtabentry ?\n   end virtual\n\n   mov    eax, [.topPtr]       *; Load pointer to list_top*\n   mov    ebx, [.nodePtr]      *; Load pointer to new structure*\n   or     dword [eax], 0       *; Check whether list_top == NULL*\n   jz     @f                   *; Simply store the structure pointer*\n *; to list_top if true*\n\n   mov    ecx, [eax]           *; Load ECX with pointer to current top*\n   mov    [.scx.next], ecx      *; node->next = top*\n   mov    [.sbx.previous], ebx  *; top->previous = node*\n\n @@:\n   mov    [eax], ebx           *; top = node*\n   pop    ecx ebx eax\n   leave\n   ret    8\n```", "```\n_start:\n   push strtabName + 40    *; Let the second structure be the first*\n   push list_top           *; in the list*\n   call add_node\n\n   push strtabName + 120   *; Then we add fourth structure*\n   push list_top\n   call add_node\n\n   push strtabName + 80    *; Then third*\n   push list_top\n   call add_node\n\n   push strtabName         *; And first*\n   push list_top\n   call add_node\n```", "```\n*; Structure for a simple linked list node*\nstruc list_node32\n{\n   .next     dd ?    *; Pointer to the next node*\n   .data     dd ?    *; Pointer to data object, which*\n *; may be anything. In case data fits*\n *; in 32 bits, the .data member itself*\n *; may be used for storing the data.*\n}\n\n*; Structure for a doubly linked list node*\nstruc dllist_node32\n{\n   .next     dd ?\n   .previous dd ?    *; Pointer to the previous node*\n   .data     dd ?\n}\n```", "```\nstruc tnode dataPtr, leftChild, rightChild\n{\n   .left  dd  leftChild   *; Pointer to left node or 0*\n   .right dd  rightChild  *; Pointer to right node or 0*\n   .data  dd  dataPtr     *; Pointer to data*\n}\n```", "```\ninclude 'vm_code.asm'\n```", "```\nmacro vm_load_key\n{\n   db 0x00\n}\n\nmacro vm_nop\n{\n   db 0x01\n}\n\nmacro vm_load_data_length\n{\n   db 0x02\n}\n\nmacro vm_loop loopTarget\n{\n   db 0x10\n   dd loopTarget - ($ + 4)\n}\n\nmacro vm_jump jumpTarget\n{\n   db 0x11\n   dd loopTarget - ($ + 4)\n}\n\nmacro vm_exit\n{\n   db 0x12\n}\n\nmacro vm_encrypt regId\n{\n   db 0x20\n   db regId\n}\n\nmacro vm_decrement regId\n{\n   db 0x21\n   db regId\n}\n\nmacro vm_increment regId\n{\n   db 0x22\n   db regId\n}\n\nmacro vm_load_data_byte regId\n{\n   db 0x30\n   db regId\n}\n\nmacro vm_store_data_byte regId\n{\n   db 0x31\n   db regId\n}\n\n*; Let's give readable names to registers*\nregister_a   = 0\nregister_b   = 1\nregister_cnt = 2\n```", "```\n*; Virtual code                     ; Binary output*\nvm_code_start:\n   vm_load_key                     *; 0x00*\n   vm_load_data_length             *; 0x02*\n   vm_nop                          *; 0x01*\n .encryption_loop:    \n   vm_load_data_byte register_b    *; 0x30 0x01*\n   vm_encrypt register_b           *; 0x20 0x01*\n   vm_store_data_byte register_b   *; 0x31 0x01*\n   vm_loop .encryption_loop        *; 0x10 0xf5 0xff 0xff 0xff*\n\n   vm_exit                         *; 0x12*\n```", "```\nstruc instruction opcode, target\n{\n   .opcode dd opcode\n   .target dd target\n}\n```", "```\n i_load_key         instruction 0x00,\\\n                                run_vm.load_key\n i_nop              instruction 0x01,\\\n                                run_vm.nop\n i_load_data_length instruction 0x02,\\\n                                run_vm.load_data_length\n i_loop             instruction 0x10,\\\n                                run_vm.loop\n i_jump             instruction 0x11,\\\n                                run_vm.jmp\n i_exit             instruction 0x12,\\\n                                run_vm.exit\n i_encrypt          instruction 0x20,\\\n                                run_vm.encrypt\n i_decrement        instruction 0x21,\\\n                                run_vm.decrement\n i_increment        instruction 0x22,\\\n                                run_vm.increment\n i_load_data_byte   instruction 0x30,\\\n                                run_vm.load_data_byte\n i_store_data_byte  instruction 0x31,\\\n                                run_vm.store_data_byte\n```", "```\n t_load_key         tnode i_load_key,\\              ; 0x00 <-\\\n                          0,\\                       ;          |\n                          0                         ;          |     \n t_nop              tnode i_nop,\\                   ; 0x01     | <-\\\n                          t_load_key,\\              ; ---------/   |\n                          t_load_data_length        ; ---------\\   |\n t_load_data_length tnode i_load_data_length,\\      ; 0x02   <-/   |\n                          0,\\                       ;              |\n                          0                         ;              |\n t_loop             tnode i_loop,\\                  ; 0x10         | <-\\\n                          t_nop,\\                   ; -------------/   |\n                          t_jmp                     ; --------\\        |\n t_jmp              tnode i_jump,\\                  ; 0x11  <-/        |\n                          0,\\                       ;                  |\n                          0                         ;                  |\n t_exit             tnode i_exit,\\                  ; 0x12             |\n                          t_loop,\\                  ; -----------------/\n                          t_decrement               ; --------\\\n t_encrypt          tnode i_encrypt,\\               ; 0x20    | <-\\  \n                          0,\\                       ;         |   |\n                          0                         ;         |   |\n t_decrement        tnode i_decrement,\\             ; 0x21  <-/   |\n                          t_encrypt,\\               ; ------------/\n                          t_load_data_byte          ; --------\\\n t_increment        tnode i_increment,\\             ; 0x22    | <-\\\n                          0,\\                       ;         |   |\n                          0                         ;         |   |\n t_load_data_byte   tnode i_load_data_byte,\\        ; 0x30  <-/   |\n                          t_increment,\\             ; ------------/\n                          t_store_data_byte         ; --------\\\n t_store_data_byte  tnode i_store_data_byte,\\       ; 0x31  <-/\n                          0,\\\n                          0 \n\ntree_root dd t_exit\n```", "```\ntree_lookup:\n   push ebp\n   mov  ebp, esp\n   push ebx ecx\n\n   virtual at ebp + 8\n      .treePtr dd ?               *; First parameter - pointer to tree_root*\n      .code dd ?                  *; Second parameter - opcode value*\n   end virtual\n   virtual at ecx\n      .node tnode ?,?,?           *; Lets us treat ECX as a pointer* \n                                  *; to tnode structure*\n   end virtual\n   virtual at eax\n      .instr instruction ?, ?     *; Lets us treat EAX as a pointer* \n *; to instruction structure*\n   end virtual\n\n   mov  ecx, [.treePtr]           *; Load the pointer to tree_root*\n   mov  ecx, [ecx]                *; Load the pointer to root node*\n   mov  ebx, [.code]              *; Read current opcode*\n   movzx ebx, bl                  *; Cast to unsigned int*\n\n@@:\n   or   ecx, 0                    *; Check whether ECX points to a node*\n   jz   .no_such_thing            *; and return zero if not*\n\n   mov  eax, [.node.data]         *; Load pointer to instruction structure*\n   cmp  ebx, [.instr.opcode]      *; Compare opcode value*\n   jz   @f\n   ja   .go_right                 *; If node contains lower opcode, then*\n                                  *; continue searching the right subtree*\n   mov  ecx, [.node.left]         *; Otherwise continue searching the* \n   jmp  @b                        *; left subtree*\n\n.go_right:\n   mov  ecx, [.node.right]\n   jmp  @b\n\n@@:\n   mov  eax, [.instr.target]      *; Relevant instruction structure has*\n                                  *; been found, so return the address*\n                                  *; of instruction implementation*\n@@:                    \n   pop  ecx ebx                   *; We are done*\n   leave\n   ret  8\n\n.no_such_thing:                   *; Zero out EAX to denote an error*\n   xor  eax, eax\n   jmp  @b \n```", "```\n        run_vm:\n           push  ebp\n           mov   ebp, esp\n           sub   esp, 4 * 3           *; We only need 12 bytes for storing* \n *; the state of virtual cpu*\n           push  eax ebx ecx edx esi  *; We will use these registers*\n\n           virtual at ebp + 8         *; Assign local labels to parameters*\n              .p_cmd_buffer_ptr  dd ? *; Pointer to VM code*\n              .p_data_buffer_ptr dd ? *; Pointer to data we want to \n                                      ; encrypt*\n              .p_data_length     dd ? *; Length of data in bytes*\n              .p_key             dd ? *; Key value cast to double word*\n           end virtual\n\n           virtual at ebp - 0x0c      *; Assign local labels to stack \n                                      ; variables*\n              .register_a        db ? *; Register A of virtual processor*\n              .register_b        db ? *; Register B of virtual processor*\n              .register_key      db ? *; Register to hold the key*\n              .register_cnt      db ? *; Counter register*\n              .data_base         dd ? *; Pointer to data buffer*\n              .data_length       dd ? *; Size of the data buffer in size*\n           end virtual\n```", "```\n        virtual_loop:\n           mov   al, [esi + ebx]  *; ESI - points to array of bytes \n                                  ; containing* \n *; virtual code*\n *; EBX - instruction pointer (offset\n                                  ; into virtual code)*\n           movzx eax, al          *; Cast opcode to double word*\n           push  eax\n           push  tree_root\n           call  tree_lookup      *; Get address of opcode emulation \n                                  ; code*\n           or    eax, 0           *; Check for error*\n           jz    .exit\n           jmp   eax              *; Jump to emulation code*\n```", "```\n        .exit:\n           pop   esi edx ecx ebx eax  *; Restore saved registers*\n           add   esp, 4 * 3           *; Destroy stack frame*\n           leave\n           ret   4 * 4\n```"]