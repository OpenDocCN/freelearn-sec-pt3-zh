- en: RE for Windows Platforms
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Windows 平台的逆向工程
- en: With Windows being one of the most popular operating systems in the world, most
    software in the cyber world has been written for it. This includes malware.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Windows 是全球最流行的操作系统之一，网络世界中的大多数软件都为其编写。这其中包括恶意软件。
- en: 'This chapter focuses on the analysis of the Windows native executable, the
    PE file, and evolves directly by doing file analysis, that is, gathering static
    information and performing dynamic analysis. We will dig deeper into understanding
    how the PE file behaves with the Windows operating system. The following topics
    will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章聚焦于 Windows 本地可执行文件 PE 文件的分析，并通过文件分析直接进行演变，即收集静态信息并执行动态分析。我们将深入了解 PE 文件如何与
    Windows 操作系统交互。以下主题将在本章中进行讲解：
- en: Analyzing Windows PE
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析 Windows PE 文件
- en: Tools
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工具
- en: Static analysis
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态分析
- en: Dynamic analysis
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态分析
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter requires knowledge of the Windows environment and its administration.
    The reader should also know how to use commands in Command Prompt. The first portion
    of this chapter requires the user to have basic knowledge of building and compiling
    C programs using Visual Studio or similar software.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章需要读者具备 Windows 环境及其管理的知识。读者还应了解如何在命令提示符中使用命令。本章的第一部分要求读者具备使用 Visual Studio
    或类似软件构建和编译 C 程序的基本知识。
- en: Hello World
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Hello World
- en: Programs in the Windows environment communicate with the system by using Windows
    APIs. These APIs are built around the file system, memory management (including
    processes, the stack, and allocations), the registry hive, network communication,
    and so forth. Regarding reverse engineering, a wide coverage of these APIs and
    their library modules is a good advantage when it comes to easily understanding
    how a program works when seen in its low-level language equivalent. So, the best
    way to begin exploring APIs and their libraries would be to develop some programs
    ourselves.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 环境中的程序通过使用 Windows API 与系统进行通信。这些 API 是围绕文件系统、内存管理（包括进程、栈和分配）、注册表、网络通信等构建的。在逆向工程方面，广泛覆盖这些
    API 及其库模块，在通过低级语言等效视角理解程序的工作方式时具有很大优势。因此，开始探索 API 及其库的最佳方式是自己开发一些程序。
- en: There are many high-level languages used by developers like C, C++, C#, and
    Visual Basic.  C, C++, and Visual Basic (native) compile to an executable that
    directly executes instructions in the x86 language. C# and Visual Basic (`p-code`)
    are usually compiled to use interpreters as a layer that turns the p-code into
    actual x86 instructions. For this chapter, we will focus on executable binaries
    compiled from C/C++ and assembly language. The goal is to have a better understanding
    of the behavior of programs that use Windows APIs.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者使用的高级语言有很多，比如 C、C++、C# 和 Visual Basic。C、C++ 和 Visual Basic（本地）编译为可执行文件，直接执行
    x86 语言的指令。C# 和 Visual Basic（`p-code`）通常会被编译成使用解释器的形式，解释器将 p-code 转换为实际的 x86 指令。本章将重点讨论从
    C/C++ 和汇编语言编译的可执行二进制文件。目标是更好地理解使用 Windows API 的程序行为。
- en: For this chapter, our choice for building C/C++ programs will be the Visual
    Studio Community edition. Visual Studio is widely used for building Microsoft
    Windows programs. Given that it is also a product of Microsoft, it already contains
    the compatible libraries required to compile programs. You can download and install
    Visual Studio Community edition from [https://visualstudio.microsoft.com/downloads/](https://visualstudio.microsoft.com/downloads/).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，我们选择使用 Visual Studio Community 版来构建 C/C++ 程序。Visual Studio 是广泛用于构建 Microsoft
    Windows 程序的工具。由于它也是微软的产品，已包含编译程序所需的兼容库。你可以从 [https://visualstudio.microsoft.com/downloads/](https://visualstudio.microsoft.com/downloads/)
    下载并安装 Visual Studio Community 版。
- en: 'These programs are neither harmful nor malicious. The following C programming
    activities can be done with Visual Studio in a bare metal machine. In case you
    are planning on installing Visual Studio in a Windows VM, at the time of writing
    this book, Visual Studio 2017 Community edition has the following recommended
    system requirements:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这些程序既不有害也不恶意。以下 C 编程活动可以在裸机上使用 Visual Studio 完成。如果你计划在 Windows 虚拟机上安装 Visual
    Studio，根据本书的编写时间，Visual Studio 2017 Community 版的推荐系统要求如下：
- en: 1.8 GHz dual core
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1.8 GHz 双核
- en: 4 GB of RAM
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4 GB 的内存
- en: 130 GB of disk space
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 130 GB 的磁盘空间
- en: These system requirements can be found at [https://docs.microsoft.com/en-us/visualstudio/productinfo/vs2017-system-requirements-vs](https://docs.microsoft.com/en-us/visualstudio/productinfo/vs2017-system-requirements-vs).
    You may need to perform some Windows updates and install the .NET framework. This
    can also be installed from the Windows 7 setup that we previously downloaded from
    [https://developer.microsoft.com/en-us/microsoft-edge/tools/vms/](https://developer.microsoft.com/en-us/microsoft-edge/tools/vms/)
    . Please visit the Microsoft Visual Studio website for the requirements of newer
    versions.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这些系统要求可以在[https://docs.microsoft.com/en-us/visualstudio/productinfo/vs2017-system-requirements-vs](https://docs.microsoft.com/en-us/visualstudio/productinfo/vs2017-system-requirements-vs)找到。你可能需要执行一些Windows更新，并安装.NET框架。也可以从我们之前下载的Windows
    7安装包中安装，下载链接为[https://developer.microsoft.com/en-us/microsoft-edge/tools/vms/](https://developer.microsoft.com/en-us/microsoft-edge/tools/vms/)。请访问微软Visual
    Studio网站，了解新版的要求。
- en: There are many Visual Studio alternatives that have minimal requirements like
    Bloodshed Dev C++, Zeus IDE, and Eclipse. However, some of these IDE may not be
    up-to-date and/or may need to the compiler and its dependencies to have been properly
    set up.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多Visual Studio的替代工具，它们有较小的系统要求，例如Bloodshed Dev C++、Zeus IDE和Eclipse。然而，这些IDE中的一些可能不是最新的，或者可能需要正确设置编译器及其依赖项。
- en: Learning about the APIs
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习API
- en: 'We''ll be skipping `Hello World` here since we have already made one in the
    previous chapters. Instead, we''ll be looking into the following example programs:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在此跳过`Hello World`，因为我们在前面的章节已经做过了。相反，我们将研究以下示例程序：
- en: A keylogger saved to a `filez`
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将键盘记录器保存到`filez`中
- en: Enumerating a registry key and printing it out
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 枚举注册表键并打印输出
- en: List processes and printing out
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列出进程并打印输出
- en: Encrypting data and storing it in a file
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加密数据并将其存储到文件中
- en: Decrypting an encrypted file
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解密加密文件
- en: Listening to port `9999` and sending back a message when connected
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监听端口`9999`并在连接时发送回一个消息
- en: The source code for these programs can be found at [https://github.com/PacktPublishing/Mastering-Reverse-Engineering/tree/master/ch7](https://github.com/PacktPublishing/Mastering-Reverse-Engineering/tree/master/ch7).
    Feel free to play with these programs, add your own code, or even create your
    own version. The aim here is to get you to learn how these APIs work, hand in
    hand.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这些程序的源代码可以在[https://github.com/PacktPublishing/Mastering-Reverse-Engineering/tree/master/ch7](https://github.com/PacktPublishing/Mastering-Reverse-Engineering/tree/master/ch7)找到。可以随意使用这些程序，添加自己的代码，甚至创建自己的版本。这里的目标是让你学习这些API如何协同工作。
- en: One of the keys to determining how a program behaves is to learn how APIs are
    used. The use of each API is documented in the Microsoft Developer Network (MSDN)
    library. The programs we are about to look into are just examples of program behaviors.
    We use these APIs to build upon these behaviors. Our goal here is to learn how
    these APIs are used and interact with each other.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 确定程序行为的关键之一是学习如何使用API。每个API的使用方法都在微软开发者网络（MSDN）文档库中有记录。我们即将查看的程序只是程序行为的示例。我们利用这些API在这些行为的基础上进行扩展。我们在这里的目标是学习这些API的使用方法以及它们如何相互交互。
- en: As a reverse engineer, it is expected and required for the reader to use the
    MSDN or other resources to further understand the details on how the API works.
    The API name can be searched in the MSDN library at [https://msdn.microsoft.com](https://msdn.microsoft.com).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一名逆向工程师，读者应当并且要求使用MSDN或其他资源进一步了解API的工作原理。可以在MSDN文档库中搜索API名称，网址为[https://msdn.microsoft.com](https://msdn.microsoft.com)。
- en: Keylogger
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 键盘记录器
- en: A keylogger is a program that logs what keys have been pressed by a user. The
    log is usually stored in a file. The core API used here is `GetAsyncKeyState`.
    Every button that can be pressed from the keyboard or the mouse has an assigned
    ID called a virtual key code. Specifying a virtual key code, the `GetAsyncKeyState`
    gives information about whether the key has been pressed or not.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 键盘记录器是一个记录用户按键的程序。日志通常保存在一个文件中。这里使用的核心API是`GetAsyncKeyState`。每个可以从键盘或鼠标按下的按钮都有一个被称为虚拟键代码的分配ID。指定虚拟键代码后，`GetAsyncKeyState`会提供关于该键是否被按下的信息。
- en: The source code for this program can be found at [https://github.com/PacktPublishing/Mastering-Reverse-Engineering/blob/master/ch7/keylogger.cpp](https://github.com/PacktPublishing/Mastering-Reverse-Engineering/blob/master/ch7/keylogger.cpp).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序的源代码可以在[https://github.com/PacktPublishing/Mastering-Reverse-Engineering/blob/master/ch7/keylogger.cpp](https://github.com/PacktPublishing/Mastering-Reverse-Engineering/blob/master/ch7/keylogger.cpp)找到。
- en: 'For keylogging to work, we will need to check the state of each virtual key
    code and run them in a loop. Once a key has been identified as pressed, the virtual
    key code gets stored into a file. The following code does just that:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使键盘记录功能正常工作，我们需要检查每个虚拟键码的状态，并将它们放入一个循环中。一旦识别到一个按键被按下，虚拟键码就会被存储到文件中。以下代码实现了这一功能：
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`LogFile` here is a function that accepts two parameters: the data that it
    writes and the file path of the log file. `lpBuffer` contains the data and is
    formatted by the `sprintf_s` API as `\\x%02x`. As a result, the format converts
    any numbers into a two-digit hexadecimal string. The number 9 becomes `\x09`,
    and the number 106 becomes `\x6a`.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`LogFile` 是一个函数，接受两个参数：它写入的数据和日志文件的文件路径。`lpBuffer` 包含数据，并通过 `sprintf_s` API
    格式化为 `\\x%02x`。因此，格式会将任何数字转换为两位数的十六进制字符串。数字 9 会变成 `\x09`，数字 106 会变成 `\x6a`。'
- en: 'All we need are three Windows API functions to implement the storage of data
    to a log file – `CreateFile`, `WriteFile`, and `CloseHandle` – as shown in the
    following code:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要三个 Windows API 函数来实现将数据存储到日志文件中——`CreateFile`、`WriteFile` 和 `CloseHandle`——如下面的代码所示：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`CreateFileA` is used to create or open a new file given the filename and how
    the file will be used. Since the purpose of this exercise is to continuously log
    the virtual key codes of pressed keys, we need to open the file in append mode
    (`FILE_APPEND_DATA`). A file handle is returned to `hFile` and is used by `WriteFile`. `lpBuffer`
    contains the formatted virtual key code. One of the parameters `WriteFile` requires
    is the size of the data to be written. The `strlen` API was used here to determine
    the length of the data. Finally, the file handle is closed using the `CloseHandle`.
    It is important to close file handles to make the file available for use.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`CreateFileA` 用于根据文件名和文件的使用方式创建或打开一个新文件。由于这个练习的目的是不断记录按键的虚拟键码，我们需要以追加模式打开文件（`FILE_APPEND_DATA`）。返回的文件句柄存储在
    `hFile` 中，并被 `WriteFile` 使用。`lpBuffer` 包含格式化的虚拟键码。`WriteFile` 需要的参数之一是要写入的数据大小。这里使用了
    `strlen` API 来确定数据的长度。最后，使用 `CloseHandle` 关闭文件句柄。关闭文件句柄是很重要的，这样文件才会可供使用。'
- en: There are different keyboard variants that cater to the language of the user.
    Thus, different keyboards may have different virtual key codes. At the start of
    the program, we used `GetKeyboardLayoutNameA(lpBuffer)` to identify the type of
    keyboard being used.  When reading the log, the type of keyboard will be used
    as a reference to properly identify which keys were pressed.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 有不同的键盘变体，旨在适应用户的语言。因此，不同的键盘可能具有不同的虚拟键码。在程序开始时，我们使用 `GetKeyboardLayoutNameA(lpBuffer)`
    来识别正在使用的键盘类型。在读取日志时，将使用键盘类型作为参考，以正确识别哪些键被按下。
- en: regenum
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: regenum
- en: The `regenum` program, as mentioned below, aims to enumerate all values and
    data in a given registry key. The parameters required for the APIs depend on the
    result of the previous APIs. Just like how we were able to write data to a file
    in the keylogger program, registry enumerating APIs also require a handle. In
    this case, a handle to the registry key is used by the `RegEnumValueA` and `RegQueryValueExA`
    APIs.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如下所述，`regenum` 程序旨在枚举给定注册表项中的所有值和数据。API 所需的参数取决于前一个 API 的结果。就像我们在键盘记录器程序中能够写入数据到文件一样，注册表枚举的
    API 也需要一个句柄。在这种情况下，`RegEnumValueA` 和 `RegQueryValueExA` API 使用的是注册表项的句柄。
- en: The source code for this program can be found at [https://github.com/PacktPublishing/Mastering-Reverse-Engineering/blob/master/ch7/regenum.cpp](https://github.com/PacktPublishing/Mastering-Reverse-Engineering/blob/master/ch7/regenum.cpp).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序的源代码可以在 [https://github.com/PacktPublishing/Mastering-Reverse-Engineering/blob/master/ch7/regenum.cpp](https://github.com/PacktPublishing/Mastering-Reverse-Engineering/blob/master/ch7/regenum.cpp)
    找到。
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The enumeration begins by retrieving a handle for the registry key via `RegOpenKeyExA`.
    A successful return value should be non-zero, while its output should show a handle
    stored in `hkResult`. The registry key that is being targeted here is `HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Run`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举从通过 `RegOpenKeyExA` 获取注册表项的句柄开始。成功的返回值应该是非零的，而输出应该显示存储在 `hkResult` 中的句柄。这里要访问的注册表项是
    `HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Run`。
- en: The handle in `hkResult` is used by `RegEnumValueA` to begin enumerating each
    registry value under the registry key. Subsequent calls to `RegEnumValueA` gives
    the next registry value entry. This block of code is therefore placed in a loop
    until it fails to return an `ERROR_SUCCESS` result. An `ERROR_SUCCESS` result
    means that a registry value was successfully retrieved.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`hkResult`中的句柄由`RegEnumValueA`使用，用于开始枚举注册表键下的每个注册表值。后续对`RegEnumValueA`的调用将返回下一个注册表值条目。因此，这段代码被放在循环中，直到返回`ERROR_SUCCESS`结果为止。`ERROR_SUCCESS`结果表示成功检索到注册表值。'
- en: For every registry value, `RegQueryValueExA` is called. Remember that we only
    go the registry value, but not its respective data. Using `RegQueryValueExA`,
    we should be able to acquire the registry data.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个注册表值，都会调用`RegQueryValueExA`。记住，我们只获取了注册表值，但没有获取其对应的数据。通过使用`RegQueryValueExA`，我们应该能够获取到注册表数据。
- en: Finally, we have to close the handle by using `RegCloseKey`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要通过使用`RegCloseKey`来关闭句柄。
- en: 'Other APIs that are used here are `printf`, `strlen`, and `sprintf`. `printf`
    was used in the program to print the target registry key, value, and data to the
    command-line console. `strlen` was used to get the text string length. Every registry
    key has a default value. Since `RegEnumValueA` will return `ERROR_SUCCEPantf`,
    we are able to replace the `ValueName` variable with a string called `(Default)`:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这里使用的其他API包括`printf`、`strlen`和`sprintf`。`printf`在程序中用于将目标注册表键、值和数据打印到命令行控制台。`strlen`用于获取文本字符串的长度。每个注册表键都有一个默认值。由于`RegEnumValueA`将返回`ERROR_SUCCEPantf`，我们可以将`ValueName`变量替换为一个名为`(Default)`的字符串：
- en: '![](img/3fd38a99-d50a-449c-8af2-5b5cd45d5fa6.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3fd38a99-d50a-449c-8af2-5b5cd45d5fa6.png)'
- en: processlist
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: processlist
- en: Similar to how enumerating registry values works, listing processes also works
    on the same concept. Since the processes in real-time change fast, a snapshot
    of the process list needs to be taken. The snapshot contains a list of process
    information at the time the snapshot was taken. The snapshot can be taken using
    `CreateToolhelp32Snapshot`. The result is stored in `hSnapshot`, which is the
    snapshot handle.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于枚举注册表值的方式，列出进程也基于相同的概念。由于实时进程变化快速，需要获取进程列表的快照。该快照包含快照创建时的进程信息列表。可以使用`CreateToolhelp32Snapshot`来获取快照。结果存储在`hSnapshot`中，它是快照句柄。
- en: To begin enumerating the list, `Process32First` is used to acquire the first
    process information from the list. This information is stored in the `pe32` variable,
    which is a `PROCESSENTRY32` type. Subsequent process information is retrieved
    by calling `Process32Next`. `CloseHandle` is finally used when done with the list.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始枚举列表，使用`Process32First`来获取列表中的第一个进程信息。该信息存储在`pe32`变量中，类型为`PROCESSENTRY32`。通过调用`Process32Next`来检索后续的进程信息。当处理完列表后，最终使用`CloseHandle`。
- en: 'Again, `printf` is used to print out the executable file name and the process
    ID:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 再次使用`printf`来打印出可执行文件名和进程ID：
- en: '[PRE3]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The source code for this program can be found at [https://github.com/PacktPublishing/Mastering-Reverse-Engineering/blob/master/ch7/processlist.cpp](https://github.com/PacktPublishing/Mastering-Reverse-Engineering/blob/master/ch7/processlist.cpp).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序的源代码可以在[https://github.com/PacktPublishing/Mastering-Reverse-Engineering/blob/master/ch7/processlist.cpp](https://github.com/PacktPublishing/Mastering-Reverse-Engineering/blob/master/ch7/processlist.cpp)找到。
- en: Encrypting and decrypting a file
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加密和解密文件
- en: Ransomware has been one of the most popular malware to spread out globally.
    Its core element is being able to encrypt files.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 勒索软件已成为全球传播的最流行恶意软件之一，其核心要素是能够加密文件。
- en: In these encrypt and decrypt programs, we are going to learn about some of the
    basic APIs used in encryption and decryption.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些加密和解密程序中，我们将学习一些用于加密和解密的基本API。
- en: The API used to encrypt is `CryptEncrypt`, while `CryptDecrypt` is used for
    decryption. However, these APIs require at least a handle to the encryption key.
    To obtain the handle to the encryption key, a handle to the **Cryptographic Service
    Provider** (**CSP**) is required. In essence, before calling `CryptEncrypt` or
    `CryptDecrypt`, calling a couple of APIs is required to set up the algorithm that
    will be used.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 用于加密的API是`CryptEncrypt`，而`CryptDecrypt`用于解密。然而，这些API至少需要一个加密密钥的句柄。为了获得加密密钥的句柄，需要先获得**加密服务提供商**（**CSP**）的句柄。从本质上讲，在调用`CryptEncrypt`或`CryptDecrypt`之前，必须先调用一些API来设置将要使用的算法。
- en: 'In our program, `CryptAcquireContextA` is used to get a `CryptoAPI` handle
    of a key container from a CSP. It is in this API where the algorithm, AES, is
    indicated. The key that the encryption will be using will be controlled by a user-defined
    password which is set in the `password[]` string. To get a handle to the derived
    key, the APIs `CryptCreateHash`, `CryptHashData`, and `CryptDeriveKey` are used
    while passing the user-defined `password` to `CryptHashData`. The data to be encrypted
    and assigned in the `buffer` variable,is passed to `CryptEncrypt`. The resulting
    encrypted data is written in the same data buffer, overwriting it in the process:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的程序中，`CryptAcquireContextA`用于从CSP获取一个`CryptoAPI`密钥容器句柄。在这个API中，算法AES被指定。加密将使用的密钥由用户定义的密码控制，该密码设置在`password[]`字符串中。为了获取派生密钥的句柄，使用了`CryptCreateHash`、`CryptHashData`和`CryptDeriveKey`这些API，并将用户定义的`password`传递给`CryptHashData`。要加密并赋值给`buffer`变量的数据，会传递给`CryptEncrypt`。最终加密后的数据会被写入同一数据缓冲区，并在此过程中覆盖原数据：
- en: '[PRE4]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Using the modified version of the `LogFile` function, which now includes the
    size of the data to write, the encrypted data is stored in the `message.enc` file:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 使用修改后的`LogFile`函数，该函数现在包括写入数据的大小，已将加密数据存储在`message.enc`文件中：
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: To gracefully close the `CryptoAPI` handles, `CryptDestroyKey`, `CryptDestroyHash`,
    and `CryptReleaseContext` are used.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 为了优雅地关闭`CryptoAPI`句柄，使用了`CryptDestroyKey`、`CryptDestroyHash`和`CryptReleaseContext`。
- en: 'The encrypted message `Hello World!` will now look like this:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 加密后的消息`Hello World!`现在会变成这样：
- en: '![](img/a1321858-fd88-4cbb-9dcc-a106625f8811.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a1321858-fd88-4cbb-9dcc-a106625f8811.png)'
- en: 'The way to decrypt the message is to use the same `CryptoAPIs`, but now use
    `CryptDecrypt`. This time, the contents of `message.enc` is read to the data buffer,
    decrypted, and then stored in `message.dec`. The CryptoAPIs are used in the same
    way as they were for acquiring the key handle. The buffer length stored in `dwDataLen`
    should initially contain the maximum length of the buffer:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 解密消息的方法是使用相同的`CryptoAPI`，但这次使用`CryptDecrypt`。这时，`message.enc`的内容会被读入数据缓冲区，解密后存储在`message.dec`中。CryptoAPI的使用方式与获取密钥句柄时相同。缓冲区的长度应存储在`dwDataLen`中，初始值应为缓冲区的最大长度：
- en: '[PRE6]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '![](img/66ef97e5-3570-4b6d-95c1-b2ca7bdcccb1.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](img/66ef97e5-3570-4b6d-95c1-b2ca7bdcccb1.png)'
- en: 'The source code for the encryption and decryption programs can be found at
    the following links:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 加密和解密程序的源代码可以在以下链接中找到：
- en: Encryption: [https://github.com/PacktPublishing/Mastering-Reverse-Engineering/blob/master/ch7/encfile.cpp](https://github.com/PacktPublishing/Mastering-Reverse-Engineering/blob/master/ch7/encfile.cpp).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 加密：[https://github.com/PacktPublishing/Mastering-Reverse-Engineering/blob/master/ch7/encfile.cpp](https://github.com/PacktPublishing/Mastering-Reverse-Engineering/blob/master/ch7/encfile.cpp)。
- en: Decryption: [https://github.com/PacktPublishing/Mastering-Reverse-Engineering/blob/master/ch7/decfile.cpp](https://github.com/PacktPublishing/Mastering-Reverse-Engineering/blob/master/ch7/decfile.cpp).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 解密：[https://github.com/PacktPublishing/Mastering-Reverse-Engineering/blob/master/ch7/decfile.cpp](https://github.com/PacktPublishing/Mastering-Reverse-Engineering/blob/master/ch7/decfile.cpp)。
- en: The server
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器
- en: In *[Chapter 6](079c24b7-4a53-4894-8890-74f9e16d53b9.xhtml), RE in Linux Platforms*,
    we learned about using socket APIs to control network communication between a
    client and a server. The same code can be implemented for the Windows operating
    system. For Windows, the socket library needs to be initiated by using the `WSAStartup`
    API before using socket APIs. In comparison to Linux functions, instead of using `write`, `send` is
    used to send data back to the client. Also, regarding `close`, the equivalent
    of this is `closesocket`, which is used to free up the socket handle.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在*[第6章](079c24b7-4a53-4894-8890-74f9e16d53b9.xhtml)，Linux平台上的逆向工程*中，我们学习了如何使用套接字API来控制客户端和服务器之间的网络通信。相同的代码也可以在Windows操作系统中实现。对于Windows，使用套接字API之前，需要通过`WSAStartup`API初始化套接字库。与Linux的函数相比，不再使用`write`，而是使用`send`来向客户端发送数据。同时，关于`close`，它在Windows中对应的是`closesocket`，用于释放套接字句柄。
- en: 'Here''s a graphical representation of how a server and a client generally communicate
    with the use of socket APIs.  Take note that the functions shown in the following
    diagram are Windows API functions:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个图示，展示了服务器和客户端通常如何通过使用套接字API进行通信。请注意，下面图示中显示的函数是Windows API函数：
- en: '![](img/666541d2-4b6c-4946-ac7d-a0dfe3caf938.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](img/666541d2-4b6c-4946-ac7d-a0dfe3caf938.png)'
- en: The `socket` function is used to initiate a socket connection. When we're done
    with the connection, the communication is closed via the `closesocket` function. 
    The server requires that we `bind` the program with a network port. The `listen`
    and `accept` function is used to  wait for client connections. The send and `recv`
    functions are used for the data transfer between the server and the client. `send`
    is used to send data while `recv` is used to receive data. Finally,  `closesocket`
    is used to terminate the transmission. The code below shows an actual C source
    code of a server-side program that accepts connections and replies with `You have
    connected to the Genie. Nothing to see here`<q>.</q>
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`socket` 函数用于初始化一个套接字连接。完成连接后，通过 `closesocket` 函数关闭通信。服务器要求我们将程序与一个网络端口 `bind`
    绑定。`listen` 和 `accept` 函数用于等待客户端连接。`send` 和 `recv` 函数用于服务器和客户端之间的数据传输。`send` 用于发送数据，而
    `recv` 用于接收数据。最后，`closesocket` 用于终止传输。以下代码显示了一个实际的服务器端程序 C 源代码，它接受连接并回复 `You have
    connected to the Genie. Nothing to see here`<q>.</q>'
- en: '[PRE7]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The source code for this program can be found at [https://github.com/PacktPublishing/Mastering-Reverse-Engineering/blob/master/ch7/server.cpp](https://github.com/PacktPublishing/Mastering-Reverse-Engineering/blob/master/ch7/server.cpp).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序的源代码可以在 [https://github.com/PacktPublishing/Mastering-Reverse-Engineering/blob/master/ch7/server.cpp](https://github.com/PacktPublishing/Mastering-Reverse-Engineering/blob/master/ch7/server.cpp)
    上找到。
- en: What is the password?
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 密码是什么？
- en: In this section, we are going to reverse the `passcode.exe` program. As a practice
    run, we'll gather the information we need by using static and dynamic analysis
    tools. We'll use some of the Windows tools that were introduced in the previous
    chapters. Do not be limited by the tools that we are going to use here. There
    are a lot of alternatives that can do the same task.  The OS environment used
    to analyze this program is a Windows 10, 32-bit, 2 GB RAM, 2 core processor in
    a VirtualBox.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将对 `passcode.exe` 程序进行逆向工程。作为练习，我们将通过使用静态和动态分析工具来收集我们需要的信息。我们将使用前几章介绍的一些
    Windows 工具。不要仅限于我们在这里使用的工具，实际上有很多其他工具也能完成相同的任务。用于分析该程序的操作系统环境是一个 Windows 10、32
    位、2 GB 内存、2 核处理器的虚拟机环境。
- en: Static analysis
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态分析
- en: 'The second piece of information that you''ll need to know, next to knowing
    the filename, is the hash of the file. Let''s pick Quickhash ([https://quickhash-gui.org/](https://quickhash-gui.org/))
    to help us with this task.  After opening the `passcode.exe` file using Quickhash,
    we can get the hash calculations for various algorithms.  The following screenshot
    shows the calculated `SHA256` hash for the `passcode.exe` file:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 除了文件名，你还需要知道的第二个信息是文件的哈希值。我们可以使用 Quickhash ([https://quickhash-gui.org/](https://quickhash-gui.org/))
    来帮助完成这个任务。在使用 Quickhash 打开 `passcode.exe` 文件后，我们可以获得各种算法的哈希计算。以下截图显示了 `passcode.exe`
    文件的 `SHA256` 哈希值：
- en: '![](img/e277180a-3544-4b33-8330-ebd5ccacd89a.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e277180a-3544-4b33-8330-ebd5ccacd89a.png)'
- en: 'The file has a name extension of `.exe`. This initially sets us to use tools
    for analyzing Windows executable files. However, to make sure that this is indeed
    a Windows executable, let''s use `TriD` to get the file type. `TrID` ([http://mark0.net/soft-trid-e.html](http://mark0.net/soft-trid-e.html))
    is console-based and should be run on the Command Prompt. We will also need to
    download and extract `TriD`''s definitions from[ http://mark0.net/download/triddefs.zip](http://mark0.net/download/triddefs.zip). 
    In the following screenshot, we used `dir` and `trid`. By using directory listing
    with `dir`, we were able to get the file''s time stamp and file size.  With the
    `trid` tool, we were able to identify what type of file `passcode.exe` is:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件的扩展名为 `.exe`。这使得我们首先想到使用用于分析 Windows 可执行文件的工具。但是，为了确保它确实是一个 Windows 可执行文件，我们可以使用
    `TriD` 来获取文件类型。`TrID` ([http://mark0.net/soft-trid-e.html](http://mark0.net/soft-trid-e.html))
    是基于命令行的工具，应在命令提示符下运行。我们还需要从 [http://mark0.net/download/triddefs.zip](http://mark0.net/download/triddefs.zip)
    下载并解压 `TrID` 的定义文件。在下面的截图中，我们使用了 `dir` 和 `trid`。通过使用 `dir` 获取目录列表，我们得到了文件的时间戳和文件大小。使用
    `trid` 工具后，我们能够识别 `passcode.exe` 是什么类型的文件：
- en: '![](img/606a1727-d929-435c-9ef7-eed012c1cecf.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](img/606a1727-d929-435c-9ef7-eed012c1cecf.png)'
- en: 'Now that we have verified that it is a Windows executable, using CFF Explorer
    should give us more file structure details. Download and install CFF Explorer
    from [https://ntcore.com/](https://ntcore.com/). Here is what you will see upon
    opening it:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经验证它是一个 Windows 可执行文件，使用 CFF Explorer 应该能给我们更多的文件结构细节。从 [https://ntcore.com/](https://ntcore.com/)
    下载并安装 CFF Explorer。打开后，你会看到以下界面：
- en: '![](img/1b396fed-b7e9-405a-b57b-3a9deb72eeae.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1b396fed-b7e9-405a-b57b-3a9deb72eeae.png)'
- en: Both `TrID` and CFF Explorer identified the file as a Windows executable, but
    are not agreeing on their decisions. This might be confusing since TrID identified
    the file as a `Win64 Executable` while CFF Explorer identified it as a `Portable
    Executable 32`.  This requires identifying the machine type from the PE header
    itself. The header reference for PE files can be viewed at [http://www.microsoft.com/whdc/system/platform/firmware/PECOFF.mspx](http://www.microsoft.com/whdc/system/platform/firmware/PECOFF.mspx).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`TrID` 和 CFF Explorer 都将该文件识别为 Windows 可执行文件，但它们的识别结果不一致。这可能会令人困惑，因为 TrID 将该文件识别为
    `Win64 可执行文件`，而 CFF Explorer 将其识别为 `可移植可执行文件 32`。这需要从 PE 头文件本身识别机器类型。PE 文件的头文件参考可以在
    [http://www.microsoft.com/whdc/system/platform/firmware/PECOFF.mspx](http://www.microsoft.com/whdc/system/platform/firmware/PECOFF.mspx)
    查看。'
- en: 'We can use CFF Explorer''s `Hex Editor` to view the binary. The first column
    shows the file offset, the middle column shows the hexadecimal equivalent of the
    binary, and the right-most column shows the printable characters:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 CFF Explorer 的 `Hex Editor` 查看二进制文件。第一列显示文件偏移量，中间列显示二进制的十六进制表示，最右边一列显示可打印字符：
- en: '![](img/ada629dc-e4d0-4abe-b076-717c6ed39dd9.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ada629dc-e4d0-4abe-b076-717c6ed39dd9.png)'
- en: The file begins with the `MZ` magic header, or `0x4d5a`, denoting a Microsoft
    executable file. At file offset `0x3c`, the `DWORD` value, read in little endian,
    is `0x00000080`. This is the file offset where the PE header is expected to be
    located. The PE header begins with a `DWORD` value equivalent of `0x00004550`
    or `PE` followed by two null bytes. This is followed by a `WORD` value that tells
    you on which machine type the program can run on. In this program, we get `0x014c`,
    which is equivalent to `IMAGE_FILE_MACHINE_I386` and means that it runs in Intel
    386 (a 32-bit microprocessor) processors or later, but also other compatible processors.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 文件以 `MZ` 魔术头（即 `0x4d5a`）开始，表示这是一个 Microsoft 可执行文件。在文件偏移量 `0x3c` 处，`DWORD` 值（按小端格式读取）为
    `0x00000080`。这就是 PE 头部所在的文件偏移位置。PE 头部以 `DWORD` 值 `0x00004550` 或 `PE` 开头，后面跟随两个空字节。接下来是一个
    `WORD` 值，告诉你程序可以运行的机器类型。在本程序中，我们得到 `0x014c`，这相当于 `IMAGE_FILE_MACHINE_I386`，意味着它可以在
    Intel 386（32 位微处理器）及更高版本的处理器上运行，也可以在其他兼容的处理器上运行。
- en: 'At this point, what we already know is as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们已经知道的信息如下：
- en: '[PRE8]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: To get to know the file better, let's run it in the sandbox.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地了解文件，我们将其在沙盒中运行。
- en: A quick run
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快速运行
- en: 'From the VM, open Windows sandbox, and then drop and run a copy of `passcode.exe`
    in it:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 从虚拟机中打开 Windows 沙盒，然后将 `passcode.exe` 的副本拖放并运行：
- en: '![](img/9c34cf4c-dfa0-4bc4-9ade-fe3a9a144677.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9c34cf4c-dfa0-4bc4-9ade-fe3a9a144677.png)'
- en: 'The program asks for a password. After guessing a password, the program suddenly
    closes. The information that we get from this event is as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 程序要求输入密码。猜测密码后，程序突然关闭。从这一事件中，我们获得的信息如下：
- en: The first piece of information is about the program asking for a password
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一条信息是关于程序要求输入密码的。
- en: The second piece of information is that it opens Command prompt
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二条信息是程序打开了命令提示符。
- en: This just means that the program should be run in the  Command prompt.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是意味着程序应该在命令提示符下运行。
- en: Deadlisting
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 死亡列表
- en: For the password, we may be able to find it in the text strings lying around
    the file itself. To get a list of strings from the file, we'll need to use SysInternal
    Suite's Strings ([https://docs.microsoft.com/en-us/sysinternals/downloads/strings](https://docs.microsoft.com/en-us/sysinternals/downloads/strings)).
    Strings is a console-based tool. The list of strings at the output are printed
    out on the console.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 对于密码，我们可能能在文件本身的文本字符串中找到它。为了从文件中获取字符串列表，我们需要使用 SysInternal Suite 的 Strings 工具（[https://docs.microsoft.com/en-us/sysinternals/downloads/strings](https://docs.microsoft.com/en-us/sysinternals/downloads/strings)）。Strings
    是一个基于控制台的工具，输出的字符串列表将打印到控制台上。
- en: The source code for this program can be found at [https://github.com/PacktPublishing/Mastering-Reverse-Engineering/blob/master/ch7/passcode.c](https://github.com/PacktPublishing/Mastering-Reverse-Engineering/blob/master/ch7/passcode.c).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序的源代码可以在 [https://github.com/PacktPublishing/Mastering-Reverse-Engineering/blob/master/ch7/passcode.c](https://github.com/PacktPublishing/Mastering-Reverse-Engineering/blob/master/ch7/passcode.c)
    找到。
- en: 'We should redirect the output to a text file by running it as `strings.exe
    passcode.exe > strings.txt`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该通过运行 `strings.exe passcode.exe > strings.txt` 将输出重定向到文本文件：
- en: '![](img/5890e0a1-68bd-4337-98e9-363148a50ab4.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5890e0a1-68bd-4337-98e9-363148a50ab4.png)'
- en: Regardless, we still get a wrong password when we try out the strings. That
    being said, the strings do show us that a correct message would most likely display
    `correct password. bye!`. The list also shows a lot of APIs that the program uses.
    However, knowing that this was compiled using MingWin-Dev C++, it is possible
    that most of the APIs used are part of the program's initialization.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: Disassembling the file using the IDA Pro 32-bit decompiler, we get to see the
    main function code. You can download and install IDA Pro from [https://github.com/PacktPublishing/Mastering-Reverse-Engineering/tree/master/tools/Disassembler%20Tools](https://github.com/PacktPublishing/Mastering-Reverse-Engineering/tree/master/tools/Disassembler%20Tools).
    Since we are working in a Windows 32-bit environment, install the 32-bit `idafree50.exe`
    file. These installers were pulled from the official IDA Pro website and are hosted
    in our GitHub repository for the purpose of availability.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: 'This file is a PE file, or Portable Executable. It should be opened as a Portable
    Executable to read the executable codes of the PE file. If opened using the MS-DOS
    executable, the resulting code will be the 16-bit MS-DOS stub:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c0a289fb-3640-4e17-bede-0b423f56019d.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
- en: 'IDA Pro was able to identify the main function. It is located at the address
    `0x004012B8`. Scrolling down to the Graph overview shows the branching of the
    blocks and may give you an idea of how the program''s code will flow when executed.
    To view the code in plain disassembly, that is, without the graphical representation,
    just change to Text view mode:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7b166065-08e0-43eb-a462-08ba6de3aaf4.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
- en: 'Knowing that this is a C compiled code, we only need to focus our analysis
    on the `_main` function. We will try to make pseudocode out of the analysis. The
    information that will be gathered are the APIs, since they are used in the flow
    of code, the conditions that make the jump branches, and the variables used. There
    might be some specific compiler code injected into the program that we may have
    identify and skip:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2aa631b8-027e-41ab-9a94-38912d12e9d5.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
- en: 'Quickly inspecting the functions `sub_401850` and `sub_4014F0`, we can see
    that the `_atexit` API was used here. The `atexit` API is used to set the code
    that will be executed once the program terminates normally. `atexit` and similar
    APIs are commonly used by high-level compilers to run cleanup code. This cleanup
    code is usually designed to prevent possible memory leaks, close opened and unused
    handles, de-allocate allocated memory, and/or realign the heap and stack for a
    graceful exit:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5f60e302-b265-4961-966f-0de079779645.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
- en: The parameter used in `_atexit` points to `sub_401450`,  and contains the cleanup
    codes.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: 'Continuing, we get to a call the `printf` function. In assembly language, calling
    APIs requires that its parameters are placed in sequence from the top of the stack.
    The `push` instruction is what we commonly use to store the data in the stack.
    This code does just the same thing. If you right-click on `[esp+88h+var_88]`,
    a drop-down menu will pop out, showing a list of possible variable structures.
    The instruction line can be better understood as `mov dword ptr [esp], offset
    aWhatIsThePassw`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0cbc9fee-7f3e-44ed-a8da-68a58646ab55.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
- en: This does the same as `push offset aWhatIsThePassw`.  The square brackets were
    used to define a data container. In this case, `esp` is the address of the container
    where the address of `what is the password? ` gets stored. There is a difference
    between using `push` and `mov`.  In the `push` instruction, the stack pointer, `esp`,
    is decremented. Overall, `printf` got the parameter it needed to display the message
    to the console.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: 'The next API is `scanf`.  `scanf` requires two parameters: the format of the
    input and the address where the input gets stored. The first parameter is located
    at the top of stack, and should be in the format of the input followed by the
    address where the input will be placed. Revising the variable structure should
    look like this:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/69f98b29-7b53-4ba1-845a-4d0fd6a94b41.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
- en: The format given is `"%30[0-9a-zA-Z ]"` , which means that `scanf` will only
    read 30 characters from the start of the input and that it will only accept the
    first set of characters that are within the square bracket. The accepted characters
    would only be "`0`" to "`9`", "`a`" to "`z`", "`A`" to "`Z`", and the space character.
    This type of input format is used to prevent exceeding a 30 character input. It
    is also used to prevent the rest of the code from processing non-alphanumeric
    characters, with the exception of the space character.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: The second parameter, placed at `[esp+4]`, should be an address to where the
    input will be stored. Tracing back, the value of the `eax` register is set as
    [`ebp+var_28`]. Let's just take note that the address stored at `var_28` is the
    inputted password.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: 'The `strlen` API comes right after and requires only one parameter. Tracing
    back the value of `eax`, `var_28`, the inputted password, is the string that `strlen`
    will be using. The resulting length of the string is stored in the `eax` register.
    The string size is compared to a value of `11h` or `17`.  After a `cmp`, a conditional
    jump is usually expected. The `jnz` instruction is used. The red line is followed
    if the comparison deems *false*. A green line is followed for a *true *condition.
    A blue line simply follows the next code block, as shown here:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/53406422-23b4-4c15-a2f6-452868f5b91e.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
- en: 'Following the red line means that the string length is equal to 17\. At this
    point, our pseudocode is as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'It is more than likely that if the size of the password is not 17, it will
    say wrong password. Let''s follow the green path first:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0b076472-1c2d-451d-8e79-e511d0686774.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
- en: 'The green line goes down to the `loc_4013F4` block, followed by the `loc_401400` block
    that ends the `_main` function. The instruction at `loc_4013F4` is a call to `sub_401290`. 
    This function contains code that indeed displays the wrong password message. Take
    note that a lot of lines point to `loc_4013F4`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2e29152e-209b-4530-b48e-8a8a787a2265.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
- en: 'Here''s the continuation of building our pseudocode with this wrong password
    function:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: One good technique in reverse engineering is to find the shortest exit path
    possible. However, this takes practice and experience. This makes it easier to
    picture the whole structure of the code.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s analyze the rest of the code under a 17 character string size.
    Let''s trace the branching instructions and work backwards with the conditions:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/50701e46-f8ec-426d-9484-fb1888571f81.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
- en: 'The condition for `jle` is a comparison between the values at `var_60` and
    0.  `var_60` is set with a value of 5, which came from `var_5c`. This prompts
    the code direction to follow the red line, like so:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/934fc0ad-e6d3-42ec-a70d-0a8bb6fc8ea5.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
- en: Zooming out, the code we are looking at is actually a loop that has two exit
    points. The first exit point is a condition that the value at `var_60` is less
    than or equal to `0`. The second exit point is a condition where the byte pointed
    to by register `eax` should not be equal to `65h`. If we inspect the variables
    in the loop further, the initial value, at `var_60`, is `5`. The value at `var_60`
    is being decremented in the `loc_401373` block. This means that the loop will
    iterate 5 times.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also see `var_8` and `var_5c` in the loop. However, since the start
    of the main code, `var_8` was never set. `var_5c` was also used not as a variable,
    but as part of a calculated address. IDA Pro helped to identify possible variable
    usage as part of the `main` function''s stack frame and set its base in the `ebp`
    register. This time, we may need to undo this variable identification by removing
    the variable structure only on `var_8` and `var_5c` in the loop code. This can
    be done by choosing the structure from the list given by right-clicking the variable
    names:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/866bdc1a-a774-427f-8081-06af3e03b364.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
- en: 'Thereby, for calculating the value in `eax`, we begin from the `lea` instruction
    line. The value stored to `edx` is the difference taken from `ebp` minus 8.  `lea`
    here does not take the value stored at `ebp-8`, unlike when using the `mov` instruction.
    The value stored in `ebp` is the value in the `esp` register after entering the
    `main` function. This makes `ebp` the stack frame''s base address. Referencing
    variables in the stack frame makes use of `ebp`. Remember that the stack is used
    by descending from a high memory address. This is the reason why referencing from
    the `ebp` register requires subtracting relatively:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a1e6eda0-6ae9-489f-8339-3546d1345d2f.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
- en: 'Now, in the `add` instruction line, the value to be stored in `edx` will be
    the sum of `edx`, and the value stored from a calculated address. This calculated
    address is `eax*4-5Ch`.  `eax` is the value from `var_60` which contains a value
    that decrements from `5` down to `0`.  But since the loop terminates when `var_60`
    reaches `0`, `eax` in this line will only have values from `5` down to `1`.   Calculating
    all five addresses, we should get the following output:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'It also happens that the values stored at these stack frame addresses were
    set before calling the first `printf` function. At this point, given the value
    of `eax` from `5` down to `1`, `edx` should have the resulting values:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The resulting value of `edx` is then stored in `eax` by the `mov` instruction.
    However, right after this, `20h` is subtracted from `eax`:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The next two lines of code is the second exit condition for the loop. The `cmp`
    instruction compares `65h` with the value stored at the address pointed to by
    `eax`. The equivalent ASCII character of `65h` is "e". If the values at the addresses
    pointed to by eax don't match a value of `65h`, the code exits the loop. If a
    mismatch happens, following the red line ends up with a call to `sub_401290`,
    which happens to be the wrong password function. The addresses being compared
    to with the character "`e`" must be part of the input string.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: 'If we made a map out of the stack frame in a table, it would look something
    like this:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '|  | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | A | B | C | D | E | F |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
- en: '| -60h |  |  |  |  |  |  |  |  | 03 | 00 | 00 | 00 | 05 | 00 | 00 | 00 |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
- en: '| -50h | 07 | 00 | 00 | 00 | 0e | 00 | 00 | 00 | 10 | 00 | 00 | 00 |  |  |  |  |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
- en: '| -40h |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
- en: '| -30h |  |  |  |  |  |  |  |  | X | X | X | e | X | e | X | e |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
- en: '| -20h | X | X | X | X | X | X | e | X | e |  |  |  |  |  |  |  |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
- en: '| -10h |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
- en: '| ebp |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
- en: We have to consider that `scanf` stored the input password at `ebp-var_28` or
    `ebp-28`. Knowing that there are exactly 17 characters for a correct password,
    we marked these input locations with X. Let's also set the addresses that should
    match with "`e`" to proceed. Remember that the string begins at offset `0`, not
    `1`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''re good with the loop, here''s what our pseudocode should look
    like by now:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Moving on, after the loop, we will see another block that uses `strcmp`. This
    time, we corrected some of the variable structures to get a better grasp of what
    our stack frame would look like:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7bd3c5ec-2c74-4cac-93c4-317d01dba058.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
- en: The first two instructions read `DWORD` values from `ebp-1Ah` and `ebp-25h`,
    and are used to calculate a binary, AND. Looking at our stack frame, both locations
    are within the inputted password string area. Eventually, a binary AND is again
    used on the resulting value and `0FFFFFFh`. The final value is stored at `ebp-2Ch`.
    `strcmp` is then used to compare the value stored at `ebp-2Ch` with the string
    "`ere`". If the string comparison does not match, the green line goes to the wrong
    password code block.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the `AND` instruction with `0FFFFFFh` means that it was only limited
    to `3` characters.  Using `AND` on the two `DWORD`s from the password string would
    only mean that both should be equal, at least on the 3 characters. Thus, `ebp-1Ah`
    and `ebp-25h` should contain "`ere`":'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '|  | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | A | B | C | D | E | F |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
- en: '| -60h |  |  |  |  |  |  |  |  | 03 | 00 | 00 | 00 | 05 | 00 | 00 | 00 |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
- en: '| -50h | 07 | 00 | 00 | 00 | 0e | 00 | 00 | 00 | 10 | 00 | 00 | 00 |  |  |  |  |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
- en: '| -40h |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
- en: '| -30h |  |  |  |  | e | r | e |  | X | X | X | e | r | e | X | e |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
- en: '| -20h | X | X | X | X | X | X | e | r | e |  |  |  |  |  |  |  |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
- en: '| -10h |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
- en: '| ebp |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
- en: 'Let''s mode on to the next set of code, following the red line:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/73b53cca-7aef-41c5-b9a3-0afc4e6ebca1.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
- en: All green lines point to the wrong password code block. So, to keep moving forward,
    we'll have to follow the conditions that go with the red line. The first code
    block in the preceding screenshot uses the `XOR` instruction to validate that
    the characters at `ebp-1Eh` and `ebp-22h` are equal.  The second block adds both
    character values from the same offsets, `ebp-1Eh` and `ebp-22h`.  The sum should
    be `40h`. In that case, the character should have an ASCII value of `20h`, a space
    character.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: The third block reads a `DWORD` value from `ebp-28h` and then uses the AND instruction
    to only take the first 3 characters. The result is compared with `647541h`. If
    translated to ASCII characters, it is read as "`duA`".
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: The fourth block does the same method as the third but takes the `DWORD` from
    `ebp-1Dh` and compares it with `636146h`, or "`caF`".
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: The last block takes a WORD value from `ebp-20h` and compares it with `7473h`,
    or "`ts`".
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: 'Writing all these down to our stack frame table should be done in little endian:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '|  | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | A | B | C | D | E | F |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
- en: '| -60h |  |  |  |  |  |  |  |  | 03 | 00 | 00 | 00 | 05 | 00 | 00 | 00 |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
- en: '| -50h | 07 | 00 | 00 | 00 | 0e | 00 | 00 | 00 | 10 | 00 | 00 | 00 |  |  |  |  |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
- en: '| -40h |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
- en: '| -30h |  |  |  |  | e | r | e |  | A | u | d | e | r | e |  | e |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
- en: '| -20h | s | t |  | F | a | c | e | r | e |  |  |  |  |  |  |  |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
- en: '| -10h |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
- en: '| ebp |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
- en: 'The password should be "`Audere est Facere`". If successful, it should run
    the correct password function:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c34a978b-bbf5-492c-8000-ce107e4ce454.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
- en: 'To complete our pseudocode, we have to compute the string''s relative offsets
    from `ebp-28h`.  `ebp-28h` is the password string''s offset, 0, while the last
    offset, offset 16, in the string should be at `ebp-18h`:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Dynamic analysis with debugging
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is nothing better than verifying what we assumed during our static analysis.
    Simply running the program and entering the password should finish the job:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/914f5cdf-219e-431e-8e7f-f8d26418db19.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
- en: Deadlisting is as important as debugging a program. Both can be done at the
    same time. Debugging can help speed up the deadlisting process as it is also validated
    at the same time. For this exercise, we're going to redo the analysis of `passcode.exe`
    by using `x32dbg` from [https://x64dbg.com](https://x64dbg.com).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: 'After opening `passcode.exe` in `x32dbg`, registering EIP will be at a high
    memory region. This is definitely not in any part of the `passcode.exe` image:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0b25b1d6-f32f-482d-a242-7cc8d83686e7.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
- en: 'To go around this, click on Options->Preferences, and then under the Events
    tab, uncheck *System Breakpoint**:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0755eb35-8860-4dd3-a857-289f1510204b.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
- en: 'Click on the Save button and then use Debug->Restart or press `Ctrl + F2`.
    This restarts the program, but now, EIP should stop at the PE file''s entry point
    address:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/12921e1d-8132-4ff3-98fd-80225be0baa4.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
- en: 'And since we also know the address of the `main` function, we need to set a
    breakpoint there and let the program run (`*F9*`). To do that, in the Command
    box, enter the following:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'After running, EIP should stop at the `main` function''s address. We get to
    see a familiar piece of code as we did during deadlisting:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bb43f02d-e2cc-4819-bf62-82d4264411ac.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
- en: '*F7* and *F8* are the shortcut keys for Step in and Step over. Click on the
    Debug menu and you should see the shortcut keys assigned to the debug command.
    Just keep on playing with the commands; if you ever mess things up, you can always
    restart.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: 'The advantage of using the Debugger is that you should easily be able to see
    the stack frame. There are five memory dump windows consisting of the stack frame.
    Let''s use Dump 2 to show us the stack frame. Make two instruction steps to get
    `ebp` set with the stack frame''s base. On the left pane, in the list of registers,
    right-click on Register EBP and then select Follow in Dump->Dump 2\. This should
    bring Dump 2 forward. Since the stack moves down from a higher address, you''ll
    have to roll the scroll bar up to show the initial data we have in the stack frame:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a37a6d40-e0fd-43a6-946e-d7303976767d.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
- en: 'Here''s the same stack frame after inputting for `scanf`. Also, during `scanf`,
    you''ll have to switch to the command prompt window to enter the password and
    then switch back after.  Also included in the following screenshot is the stack
    window, located in the right-hand pane:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8da5bf65-1ea5-48cf-b569-0a5e1cb06ef4.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
- en: Even while in the debugger, we can change the contents of the inputted string
    any time, thereby forcing it to continue in the condition toward the correct password.
    All we need to do is right-click on the byte in the Dump window and select Modify
    Value*.* For example, in the loop that compares `65h` ("`e`") with the value stored
    in the address pointed by register `eax`, before stepping on the `cmp` instruction,
    we can change the value at that address.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following screenshot the value stored at the address `0060FF20h` (EAX),
    which is being modifed from `35h` to `65h`:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1c5731fe-5dfc-421e-bed5-271800735c0f.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
- en: The same modification can be done by doing a binary edit through right-clicking
    on byte, and then selecting *Binary*->*Edit*.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: 'And here''s where we should end up if we have a correct password:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9afbc6dc-4f99-4647-b448-cdc9dce17759.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
- en: Decompilers
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It may be easier if the pseudocode were automatically given to us. Certain
    tools exist that may be able to help us with that. Let''s try and decompile `passcode.exe`
    ([https://github.com/PacktPublishing/Mastering-Reverse-Engineering/blob/master/ch7/passcode.exe](https://github.com/PacktPublishing/Mastering-Reverse-Engineering/blob/master/ch7/passcode.exe))
    using the standalone version of Snowman ([https://derevenets.com/](https://derevenets.com/)).
    Once the file has been opened, click on View->Inspector.  This should show a box
    containing resolved functions from the program. Look for the function definition
    `_main` and select it to show the equivalent pseudocode of the assembly language.
    This highlights the assembly language line in the left-hand pane and the psuedocode
    in the middle pane:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3db47a1f-e2dc-4d72-b225-ca744f400a4e.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
- en: As of the time of writing this book, the output C source may help, but not all
    are correctly decompiled. For instance, the loop where "`e`" was being compared
    was not decompiled correctly. The output shows a `while` loop, but we expect that
    the `v10` variable should have its value read from the offset calculated in the
    password string. However, most of the code should somehow aid us in understanding
    how the program should work. The decompiler engine for this is open source ([https://www.capstone-engine.org/](https://www.capstone-engine.org/)),
    so not much should be expected as support won't always be there.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: The good news is that there are more powerful decompilers that exist, such as
    HexRays. Most institutions and some individual analysts and researchers who perform
    reverse engineering are willing to pay for these decompilers. HexRays is one bang
    for its buck for most reverse engineers.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a HexRays decompiled version of `passcode.exe`:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/af8762c3-a506-4c10-8cf1-4b77d37555e3.png)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
- en: Decompilers are continuously developed since these tools speed up analysis.
    They do not decompile perfectly, but should be near the source.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we introduced reverse engineering, beginning with APIs, by
    learning how these are used in a functional program. We then used static and dynamic
    analysis tools to reverse a program.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: Overall, there are a lot of reversing tools for Windows available for use. This
    also includes the vast information and research on how to use them for specific
    reversing situations. Reverse engineering is mostly about acquiring the resources
    from the World Wide Web, and from what you already know, we have already done
    that.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[https://visualstudio.microsoft.com](https://visualstudio.microsoft.com): this
    is the download site for Visual Studio'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/visualstudio/productinfo/vs2017-system-requirements-vs:](https://docs.microsoft.com/en-us/visualstudio/productinfo/vs2017-system-requirements-vs)
    site shows recommended system requirements for installing Visual Studio'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://sourceforge.net/projects/orwelldevcpp/](https://sourceforge.net/projects/orwelldevcpp/):
    this site contains the binary downloads of Dev C++.'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://developer.microsoft.com/en-us/microsoft-edge/tools/vms/](https://developer.microsoft.com/en-us/microsoft-edge/tools/vms/): appliance
    versions of pre-installed Microsoft Windows can be downloaded here'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://mark0.net/soft-trid-e.html:](http://mark0.net/soft-trid-e.html) Download
    site of the TrID tool and its signature database file'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://www.microsoft.com/whdc/system/platform/firmware/PECOFF.mspx:](http://www.microsoft.com/whdc/system/platform/firmware/PECOFF.mspx) documentation
    of the Microsoft Portable E'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
