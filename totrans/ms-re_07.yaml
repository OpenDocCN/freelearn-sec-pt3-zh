- en: RE for Windows Platforms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With Windows being one of the most popular operating systems in the world, most
    software in the cyber world has been written for it. This includes malware.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter focuses on the analysis of the Windows native executable, the
    PE file, and evolves directly by doing file analysis, that is, gathering static
    information and performing dynamic analysis. We will dig deeper into understanding
    how the PE file behaves with the Windows operating system. The following topics
    will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing Windows PE
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Static analysis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamic analysis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter requires knowledge of the Windows environment and its administration.
    The reader should also know how to use commands in Command Prompt. The first portion
    of this chapter requires the user to have basic knowledge of building and compiling
    C programs using Visual Studio or similar software.
  prefs: []
  type: TYPE_NORMAL
- en: Hello World
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Programs in the Windows environment communicate with the system by using Windows
    APIs. These APIs are built around the file system, memory management (including
    processes, the stack, and allocations), the registry hive, network communication,
    and so forth. Regarding reverse engineering, a wide coverage of these APIs and
    their library modules is a good advantage when it comes to easily understanding
    how a program works when seen in its low-level language equivalent. So, the best
    way to begin exploring APIs and their libraries would be to develop some programs
    ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: There are many high-level languages used by developers like C, C++, C#, and
    Visual Basic.  C, C++, and Visual Basic (native) compile to an executable that
    directly executes instructions in the x86 language. C# and Visual Basic (`p-code`)
    are usually compiled to use interpreters as a layer that turns the p-code into
    actual x86 instructions. For this chapter, we will focus on executable binaries
    compiled from C/C++ and assembly language. The goal is to have a better understanding
    of the behavior of programs that use Windows APIs.
  prefs: []
  type: TYPE_NORMAL
- en: For this chapter, our choice for building C/C++ programs will be the Visual
    Studio Community edition. Visual Studio is widely used for building Microsoft
    Windows programs. Given that it is also a product of Microsoft, it already contains
    the compatible libraries required to compile programs. You can download and install
    Visual Studio Community edition from [https://visualstudio.microsoft.com/downloads/](https://visualstudio.microsoft.com/downloads/).
  prefs: []
  type: TYPE_NORMAL
- en: 'These programs are neither harmful nor malicious. The following C programming
    activities can be done with Visual Studio in a bare metal machine. In case you
    are planning on installing Visual Studio in a Windows VM, at the time of writing
    this book, Visual Studio 2017 Community edition has the following recommended
    system requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: 1.8 GHz dual core
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 4 GB of RAM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 130 GB of disk space
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These system requirements can be found at [https://docs.microsoft.com/en-us/visualstudio/productinfo/vs2017-system-requirements-vs](https://docs.microsoft.com/en-us/visualstudio/productinfo/vs2017-system-requirements-vs).
    You may need to perform some Windows updates and install the .NET framework. This
    can also be installed from the Windows 7 setup that we previously downloaded from
    [https://developer.microsoft.com/en-us/microsoft-edge/tools/vms/](https://developer.microsoft.com/en-us/microsoft-edge/tools/vms/)
    . Please visit the Microsoft Visual Studio website for the requirements of newer
    versions.
  prefs: []
  type: TYPE_NORMAL
- en: There are many Visual Studio alternatives that have minimal requirements like
    Bloodshed Dev C++, Zeus IDE, and Eclipse. However, some of these IDE may not be
    up-to-date and/or may need to the compiler and its dependencies to have been properly
    set up.
  prefs: []
  type: TYPE_NORMAL
- en: Learning about the APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll be skipping `Hello World` here since we have already made one in the
    previous chapters. Instead, we''ll be looking into the following example programs:'
  prefs: []
  type: TYPE_NORMAL
- en: A keylogger saved to a `filez`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enumerating a registry key and printing it out
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: List processes and printing out
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encrypting data and storing it in a file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decrypting an encrypted file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Listening to port `9999` and sending back a message when connected
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The source code for these programs can be found at [https://github.com/PacktPublishing/Mastering-Reverse-Engineering/tree/master/ch7](https://github.com/PacktPublishing/Mastering-Reverse-Engineering/tree/master/ch7).
    Feel free to play with these programs, add your own code, or even create your
    own version. The aim here is to get you to learn how these APIs work, hand in
    hand.
  prefs: []
  type: TYPE_NORMAL
- en: One of the keys to determining how a program behaves is to learn how APIs are
    used. The use of each API is documented in the Microsoft Developer Network (MSDN)
    library. The programs we are about to look into are just examples of program behaviors.
    We use these APIs to build upon these behaviors. Our goal here is to learn how
    these APIs are used and interact with each other.
  prefs: []
  type: TYPE_NORMAL
- en: As a reverse engineer, it is expected and required for the reader to use the
    MSDN or other resources to further understand the details on how the API works.
    The API name can be searched in the MSDN library at [https://msdn.microsoft.com](https://msdn.microsoft.com).
  prefs: []
  type: TYPE_NORMAL
- en: Keylogger
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A keylogger is a program that logs what keys have been pressed by a user. The
    log is usually stored in a file. The core API used here is `GetAsyncKeyState`.
    Every button that can be pressed from the keyboard or the mouse has an assigned
    ID called a virtual key code. Specifying a virtual key code, the `GetAsyncKeyState`
    gives information about whether the key has been pressed or not.
  prefs: []
  type: TYPE_NORMAL
- en: The source code for this program can be found at [https://github.com/PacktPublishing/Mastering-Reverse-Engineering/blob/master/ch7/keylogger.cpp](https://github.com/PacktPublishing/Mastering-Reverse-Engineering/blob/master/ch7/keylogger.cpp).
  prefs: []
  type: TYPE_NORMAL
- en: 'For keylogging to work, we will need to check the state of each virtual key
    code and run them in a loop. Once a key has been identified as pressed, the virtual
    key code gets stored into a file. The following code does just that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '`LogFile` here is a function that accepts two parameters: the data that it
    writes and the file path of the log file. `lpBuffer` contains the data and is
    formatted by the `sprintf_s` API as `\\x%02x`. As a result, the format converts
    any numbers into a two-digit hexadecimal string. The number 9 becomes `\x09`,
    and the number 106 becomes `\x6a`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'All we need are three Windows API functions to implement the storage of data
    to a log file – `CreateFile`, `WriteFile`, and `CloseHandle` – as shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '`CreateFileA` is used to create or open a new file given the filename and how
    the file will be used. Since the purpose of this exercise is to continuously log
    the virtual key codes of pressed keys, we need to open the file in append mode
    (`FILE_APPEND_DATA`). A file handle is returned to `hFile` and is used by `WriteFile`. `lpBuffer`
    contains the formatted virtual key code. One of the parameters `WriteFile` requires
    is the size of the data to be written. The `strlen` API was used here to determine
    the length of the data. Finally, the file handle is closed using the `CloseHandle`.
    It is important to close file handles to make the file available for use.'
  prefs: []
  type: TYPE_NORMAL
- en: There are different keyboard variants that cater to the language of the user.
    Thus, different keyboards may have different virtual key codes. At the start of
    the program, we used `GetKeyboardLayoutNameA(lpBuffer)` to identify the type of
    keyboard being used.  When reading the log, the type of keyboard will be used
    as a reference to properly identify which keys were pressed.
  prefs: []
  type: TYPE_NORMAL
- en: regenum
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `regenum` program, as mentioned below, aims to enumerate all values and
    data in a given registry key. The parameters required for the APIs depend on the
    result of the previous APIs. Just like how we were able to write data to a file
    in the keylogger program, registry enumerating APIs also require a handle. In
    this case, a handle to the registry key is used by the `RegEnumValueA` and `RegQueryValueExA`
    APIs.
  prefs: []
  type: TYPE_NORMAL
- en: The source code for this program can be found at [https://github.com/PacktPublishing/Mastering-Reverse-Engineering/blob/master/ch7/regenum.cpp](https://github.com/PacktPublishing/Mastering-Reverse-Engineering/blob/master/ch7/regenum.cpp).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The enumeration begins by retrieving a handle for the registry key via `RegOpenKeyExA`.
    A successful return value should be non-zero, while its output should show a handle
    stored in `hkResult`. The registry key that is being targeted here is `HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Run`.
  prefs: []
  type: TYPE_NORMAL
- en: The handle in `hkResult` is used by `RegEnumValueA` to begin enumerating each
    registry value under the registry key. Subsequent calls to `RegEnumValueA` gives
    the next registry value entry. This block of code is therefore placed in a loop
    until it fails to return an `ERROR_SUCCESS` result. An `ERROR_SUCCESS` result
    means that a registry value was successfully retrieved.
  prefs: []
  type: TYPE_NORMAL
- en: For every registry value, `RegQueryValueExA` is called. Remember that we only
    go the registry value, but not its respective data. Using `RegQueryValueExA`,
    we should be able to acquire the registry data.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we have to close the handle by using `RegCloseKey`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Other APIs that are used here are `printf`, `strlen`, and `sprintf`. `printf`
    was used in the program to print the target registry key, value, and data to the
    command-line console. `strlen` was used to get the text string length. Every registry
    key has a default value. Since `RegEnumValueA` will return `ERROR_SUCCEPantf`,
    we are able to replace the `ValueName` variable with a string called `(Default)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3fd38a99-d50a-449c-8af2-5b5cd45d5fa6.png)'
  prefs: []
  type: TYPE_IMG
- en: processlist
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Similar to how enumerating registry values works, listing processes also works
    on the same concept. Since the processes in real-time change fast, a snapshot
    of the process list needs to be taken. The snapshot contains a list of process
    information at the time the snapshot was taken. The snapshot can be taken using
    `CreateToolhelp32Snapshot`. The result is stored in `hSnapshot`, which is the
    snapshot handle.
  prefs: []
  type: TYPE_NORMAL
- en: To begin enumerating the list, `Process32First` is used to acquire the first
    process information from the list. This information is stored in the `pe32` variable,
    which is a `PROCESSENTRY32` type. Subsequent process information is retrieved
    by calling `Process32Next`. `CloseHandle` is finally used when done with the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, `printf` is used to print out the executable file name and the process
    ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The source code for this program can be found at [https://github.com/PacktPublishing/Mastering-Reverse-Engineering/blob/master/ch7/processlist.cpp](https://github.com/PacktPublishing/Mastering-Reverse-Engineering/blob/master/ch7/processlist.cpp).
  prefs: []
  type: TYPE_NORMAL
- en: Encrypting and decrypting a file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ransomware has been one of the most popular malware to spread out globally.
    Its core element is being able to encrypt files.
  prefs: []
  type: TYPE_NORMAL
- en: In these encrypt and decrypt programs, we are going to learn about some of the
    basic APIs used in encryption and decryption.
  prefs: []
  type: TYPE_NORMAL
- en: The API used to encrypt is `CryptEncrypt`, while `CryptDecrypt` is used for
    decryption. However, these APIs require at least a handle to the encryption key.
    To obtain the handle to the encryption key, a handle to the **Cryptographic Service
    Provider** (**CSP**) is required. In essence, before calling `CryptEncrypt` or
    `CryptDecrypt`, calling a couple of APIs is required to set up the algorithm that
    will be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our program, `CryptAcquireContextA` is used to get a `CryptoAPI` handle
    of a key container from a CSP. It is in this API where the algorithm, AES, is
    indicated. The key that the encryption will be using will be controlled by a user-defined
    password which is set in the `password[]` string. To get a handle to the derived
    key, the APIs `CryptCreateHash`, `CryptHashData`, and `CryptDeriveKey` are used
    while passing the user-defined `password` to `CryptHashData`. The data to be encrypted
    and assigned in the `buffer` variable,is passed to `CryptEncrypt`. The resulting
    encrypted data is written in the same data buffer, overwriting it in the process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the modified version of the `LogFile` function, which now includes the
    size of the data to write, the encrypted data is stored in the `message.enc` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: To gracefully close the `CryptoAPI` handles, `CryptDestroyKey`, `CryptDestroyHash`,
    and `CryptReleaseContext` are used.
  prefs: []
  type: TYPE_NORMAL
- en: 'The encrypted message `Hello World!` will now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a1321858-fd88-4cbb-9dcc-a106625f8811.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The way to decrypt the message is to use the same `CryptoAPIs`, but now use
    `CryptDecrypt`. This time, the contents of `message.enc` is read to the data buffer,
    decrypted, and then stored in `message.dec`. The CryptoAPIs are used in the same
    way as they were for acquiring the key handle. The buffer length stored in `dwDataLen`
    should initially contain the maximum length of the buffer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/66ef97e5-3570-4b6d-95c1-b2ca7bdcccb1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The source code for the encryption and decryption programs can be found at
    the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: Encryption: [https://github.com/PacktPublishing/Mastering-Reverse-Engineering/blob/master/ch7/encfile.cpp](https://github.com/PacktPublishing/Mastering-Reverse-Engineering/blob/master/ch7/encfile.cpp).
  prefs: []
  type: TYPE_NORMAL
- en: Decryption: [https://github.com/PacktPublishing/Mastering-Reverse-Engineering/blob/master/ch7/decfile.cpp](https://github.com/PacktPublishing/Mastering-Reverse-Engineering/blob/master/ch7/decfile.cpp).
  prefs: []
  type: TYPE_NORMAL
- en: The server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In *[Chapter 6](079c24b7-4a53-4894-8890-74f9e16d53b9.xhtml), RE in Linux Platforms*,
    we learned about using socket APIs to control network communication between a
    client and a server. The same code can be implemented for the Windows operating
    system. For Windows, the socket library needs to be initiated by using the `WSAStartup`
    API before using socket APIs. In comparison to Linux functions, instead of using `write`, `send` is
    used to send data back to the client. Also, regarding `close`, the equivalent
    of this is `closesocket`, which is used to free up the socket handle.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a graphical representation of how a server and a client generally communicate
    with the use of socket APIs.  Take note that the functions shown in the following
    diagram are Windows API functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/666541d2-4b6c-4946-ac7d-a0dfe3caf938.png)'
  prefs: []
  type: TYPE_IMG
- en: The `socket` function is used to initiate a socket connection. When we're done
    with the connection, the communication is closed via the `closesocket` function. 
    The server requires that we `bind` the program with a network port. The `listen`
    and `accept` function is used to  wait for client connections. The send and `recv`
    functions are used for the data transfer between the server and the client. `send`
    is used to send data while `recv` is used to receive data. Finally,  `closesocket`
    is used to terminate the transmission. The code below shows an actual C source
    code of a server-side program that accepts connections and replies with `You have
    connected to the Genie. Nothing to see here`<q>.</q>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The source code for this program can be found at [https://github.com/PacktPublishing/Mastering-Reverse-Engineering/blob/master/ch7/server.cpp](https://github.com/PacktPublishing/Mastering-Reverse-Engineering/blob/master/ch7/server.cpp).
  prefs: []
  type: TYPE_NORMAL
- en: What is the password?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to reverse the `passcode.exe` program. As a practice
    run, we'll gather the information we need by using static and dynamic analysis
    tools. We'll use some of the Windows tools that were introduced in the previous
    chapters. Do not be limited by the tools that we are going to use here. There
    are a lot of alternatives that can do the same task.  The OS environment used
    to analyze this program is a Windows 10, 32-bit, 2 GB RAM, 2 core processor in
    a VirtualBox.
  prefs: []
  type: TYPE_NORMAL
- en: Static analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The second piece of information that you''ll need to know, next to knowing
    the filename, is the hash of the file. Let''s pick Quickhash ([https://quickhash-gui.org/](https://quickhash-gui.org/))
    to help us with this task.  After opening the `passcode.exe` file using Quickhash,
    we can get the hash calculations for various algorithms.  The following screenshot
    shows the calculated `SHA256` hash for the `passcode.exe` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e277180a-3544-4b33-8330-ebd5ccacd89a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The file has a name extension of `.exe`. This initially sets us to use tools
    for analyzing Windows executable files. However, to make sure that this is indeed
    a Windows executable, let''s use `TriD` to get the file type. `TrID` ([http://mark0.net/soft-trid-e.html](http://mark0.net/soft-trid-e.html))
    is console-based and should be run on the Command Prompt. We will also need to
    download and extract `TriD`''s definitions from[ http://mark0.net/download/triddefs.zip](http://mark0.net/download/triddefs.zip). 
    In the following screenshot, we used `dir` and `trid`. By using directory listing
    with `dir`, we were able to get the file''s time stamp and file size.  With the
    `trid` tool, we were able to identify what type of file `passcode.exe` is:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/606a1727-d929-435c-9ef7-eed012c1cecf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that we have verified that it is a Windows executable, using CFF Explorer
    should give us more file structure details. Download and install CFF Explorer
    from [https://ntcore.com/](https://ntcore.com/). Here is what you will see upon
    opening it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1b396fed-b7e9-405a-b57b-3a9deb72eeae.png)'
  prefs: []
  type: TYPE_IMG
- en: Both `TrID` and CFF Explorer identified the file as a Windows executable, but
    are not agreeing on their decisions. This might be confusing since TrID identified
    the file as a `Win64 Executable` while CFF Explorer identified it as a `Portable
    Executable 32`.  This requires identifying the machine type from the PE header
    itself. The header reference for PE files can be viewed at [http://www.microsoft.com/whdc/system/platform/firmware/PECOFF.mspx](http://www.microsoft.com/whdc/system/platform/firmware/PECOFF.mspx).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use CFF Explorer''s `Hex Editor` to view the binary. The first column
    shows the file offset, the middle column shows the hexadecimal equivalent of the
    binary, and the right-most column shows the printable characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ada629dc-e4d0-4abe-b076-717c6ed39dd9.png)'
  prefs: []
  type: TYPE_IMG
- en: The file begins with the `MZ` magic header, or `0x4d5a`, denoting a Microsoft
    executable file. At file offset `0x3c`, the `DWORD` value, read in little endian,
    is `0x00000080`. This is the file offset where the PE header is expected to be
    located. The PE header begins with a `DWORD` value equivalent of `0x00004550`
    or `PE` followed by two null bytes. This is followed by a `WORD` value that tells
    you on which machine type the program can run on. In this program, we get `0x014c`,
    which is equivalent to `IMAGE_FILE_MACHINE_I386` and means that it runs in Intel
    386 (a 32-bit microprocessor) processors or later, but also other compatible processors.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, what we already know is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: To get to know the file better, let's run it in the sandbox.
  prefs: []
  type: TYPE_NORMAL
- en: A quick run
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'From the VM, open Windows sandbox, and then drop and run a copy of `passcode.exe`
    in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9c34cf4c-dfa0-4bc4-9ade-fe3a9a144677.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The program asks for a password. After guessing a password, the program suddenly
    closes. The information that we get from this event is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The first piece of information is about the program asking for a password
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second piece of information is that it opens Command prompt
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This just means that the program should be run in the  Command prompt.
  prefs: []
  type: TYPE_NORMAL
- en: Deadlisting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the password, we may be able to find it in the text strings lying around
    the file itself. To get a list of strings from the file, we'll need to use SysInternal
    Suite's Strings ([https://docs.microsoft.com/en-us/sysinternals/downloads/strings](https://docs.microsoft.com/en-us/sysinternals/downloads/strings)).
    Strings is a console-based tool. The list of strings at the output are printed
    out on the console.
  prefs: []
  type: TYPE_NORMAL
- en: The source code for this program can be found at [https://github.com/PacktPublishing/Mastering-Reverse-Engineering/blob/master/ch7/passcode.c](https://github.com/PacktPublishing/Mastering-Reverse-Engineering/blob/master/ch7/passcode.c).
  prefs: []
  type: TYPE_NORMAL
- en: 'We should redirect the output to a text file by running it as `strings.exe
    passcode.exe > strings.txt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5890e0a1-68bd-4337-98e9-363148a50ab4.png)'
  prefs: []
  type: TYPE_IMG
- en: Regardless, we still get a wrong password when we try out the strings. That
    being said, the strings do show us that a correct message would most likely display
    `correct password. bye!`. The list also shows a lot of APIs that the program uses.
    However, knowing that this was compiled using MingWin-Dev C++, it is possible
    that most of the APIs used are part of the program's initialization.
  prefs: []
  type: TYPE_NORMAL
- en: Disassembling the file using the IDA Pro 32-bit decompiler, we get to see the
    main function code. You can download and install IDA Pro from [https://github.com/PacktPublishing/Mastering-Reverse-Engineering/tree/master/tools/Disassembler%20Tools](https://github.com/PacktPublishing/Mastering-Reverse-Engineering/tree/master/tools/Disassembler%20Tools).
    Since we are working in a Windows 32-bit environment, install the 32-bit `idafree50.exe`
    file. These installers were pulled from the official IDA Pro website and are hosted
    in our GitHub repository for the purpose of availability.
  prefs: []
  type: TYPE_NORMAL
- en: 'This file is a PE file, or Portable Executable. It should be opened as a Portable
    Executable to read the executable codes of the PE file. If opened using the MS-DOS
    executable, the resulting code will be the 16-bit MS-DOS stub:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c0a289fb-3640-4e17-bede-0b423f56019d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'IDA Pro was able to identify the main function. It is located at the address
    `0x004012B8`. Scrolling down to the Graph overview shows the branching of the
    blocks and may give you an idea of how the program''s code will flow when executed.
    To view the code in plain disassembly, that is, without the graphical representation,
    just change to Text view mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7b166065-08e0-43eb-a462-08ba6de3aaf4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Knowing that this is a C compiled code, we only need to focus our analysis
    on the `_main` function. We will try to make pseudocode out of the analysis. The
    information that will be gathered are the APIs, since they are used in the flow
    of code, the conditions that make the jump branches, and the variables used. There
    might be some specific compiler code injected into the program that we may have
    identify and skip:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2aa631b8-027e-41ab-9a94-38912d12e9d5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Quickly inspecting the functions `sub_401850` and `sub_4014F0`, we can see
    that the `_atexit` API was used here. The `atexit` API is used to set the code
    that will be executed once the program terminates normally. `atexit` and similar
    APIs are commonly used by high-level compilers to run cleanup code. This cleanup
    code is usually designed to prevent possible memory leaks, close opened and unused
    handles, de-allocate allocated memory, and/or realign the heap and stack for a
    graceful exit:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5f60e302-b265-4961-966f-0de079779645.png)'
  prefs: []
  type: TYPE_IMG
- en: The parameter used in `_atexit` points to `sub_401450`,  and contains the cleanup
    codes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Continuing, we get to a call the `printf` function. In assembly language, calling
    APIs requires that its parameters are placed in sequence from the top of the stack.
    The `push` instruction is what we commonly use to store the data in the stack.
    This code does just the same thing. If you right-click on `[esp+88h+var_88]`,
    a drop-down menu will pop out, showing a list of possible variable structures.
    The instruction line can be better understood as `mov dword ptr [esp], offset
    aWhatIsThePassw`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0cbc9fee-7f3e-44ed-a8da-68a58646ab55.png)'
  prefs: []
  type: TYPE_IMG
- en: This does the same as `push offset aWhatIsThePassw`.  The square brackets were
    used to define a data container. In this case, `esp` is the address of the container
    where the address of `what is the password? ` gets stored. There is a difference
    between using `push` and `mov`.  In the `push` instruction, the stack pointer, `esp`,
    is decremented. Overall, `printf` got the parameter it needed to display the message
    to the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next API is `scanf`.  `scanf` requires two parameters: the format of the
    input and the address where the input gets stored. The first parameter is located
    at the top of stack, and should be in the format of the input followed by the
    address where the input will be placed. Revising the variable structure should
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/69f98b29-7b53-4ba1-845a-4d0fd6a94b41.png)'
  prefs: []
  type: TYPE_IMG
- en: The format given is `"%30[0-9a-zA-Z ]"` , which means that `scanf` will only
    read 30 characters from the start of the input and that it will only accept the
    first set of characters that are within the square bracket. The accepted characters
    would only be "`0`" to "`9`", "`a`" to "`z`", "`A`" to "`Z`", and the space character.
    This type of input format is used to prevent exceeding a 30 character input. It
    is also used to prevent the rest of the code from processing non-alphanumeric
    characters, with the exception of the space character.
  prefs: []
  type: TYPE_NORMAL
- en: The second parameter, placed at `[esp+4]`, should be an address to where the
    input will be stored. Tracing back, the value of the `eax` register is set as
    [`ebp+var_28`]. Let's just take note that the address stored at `var_28` is the
    inputted password.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `strlen` API comes right after and requires only one parameter. Tracing
    back the value of `eax`, `var_28`, the inputted password, is the string that `strlen`
    will be using. The resulting length of the string is stored in the `eax` register.
    The string size is compared to a value of `11h` or `17`.  After a `cmp`, a conditional
    jump is usually expected. The `jnz` instruction is used. The red line is followed
    if the comparison deems *false*. A green line is followed for a *true *condition.
    A blue line simply follows the next code block, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/53406422-23b4-4c15-a2f6-452868f5b91e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Following the red line means that the string length is equal to 17\. At this
    point, our pseudocode is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'It is more than likely that if the size of the password is not 17, it will
    say wrong password. Let''s follow the green path first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0b076472-1c2d-451d-8e79-e511d0686774.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The green line goes down to the `loc_4013F4` block, followed by the `loc_401400` block
    that ends the `_main` function. The instruction at `loc_4013F4` is a call to `sub_401290`. 
    This function contains code that indeed displays the wrong password message. Take
    note that a lot of lines point to `loc_4013F4`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2e29152e-209b-4530-b48e-8a8a787a2265.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here''s the continuation of building our pseudocode with this wrong password
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: One good technique in reverse engineering is to find the shortest exit path
    possible. However, this takes practice and experience. This makes it easier to
    picture the whole structure of the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s analyze the rest of the code under a 17 character string size.
    Let''s trace the branching instructions and work backwards with the conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/50701e46-f8ec-426d-9484-fb1888571f81.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The condition for `jle` is a comparison between the values at `var_60` and
    0.  `var_60` is set with a value of 5, which came from `var_5c`. This prompts
    the code direction to follow the red line, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/934fc0ad-e6d3-42ec-a70d-0a8bb6fc8ea5.png)'
  prefs: []
  type: TYPE_IMG
- en: Zooming out, the code we are looking at is actually a loop that has two exit
    points. The first exit point is a condition that the value at `var_60` is less
    than or equal to `0`. The second exit point is a condition where the byte pointed
    to by register `eax` should not be equal to `65h`. If we inspect the variables
    in the loop further, the initial value, at `var_60`, is `5`. The value at `var_60`
    is being decremented in the `loc_401373` block. This means that the loop will
    iterate 5 times.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also see `var_8` and `var_5c` in the loop. However, since the start
    of the main code, `var_8` was never set. `var_5c` was also used not as a variable,
    but as part of a calculated address. IDA Pro helped to identify possible variable
    usage as part of the `main` function''s stack frame and set its base in the `ebp`
    register. This time, we may need to undo this variable identification by removing
    the variable structure only on `var_8` and `var_5c` in the loop code. This can
    be done by choosing the structure from the list given by right-clicking the variable
    names:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/866bdc1a-a774-427f-8081-06af3e03b364.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Thereby, for calculating the value in `eax`, we begin from the `lea` instruction
    line. The value stored to `edx` is the difference taken from `ebp` minus 8.  `lea`
    here does not take the value stored at `ebp-8`, unlike when using the `mov` instruction.
    The value stored in `ebp` is the value in the `esp` register after entering the
    `main` function. This makes `ebp` the stack frame''s base address. Referencing
    variables in the stack frame makes use of `ebp`. Remember that the stack is used
    by descending from a high memory address. This is the reason why referencing from
    the `ebp` register requires subtracting relatively:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a1e6eda0-6ae9-489f-8339-3546d1345d2f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, in the `add` instruction line, the value to be stored in `edx` will be
    the sum of `edx`, and the value stored from a calculated address. This calculated
    address is `eax*4-5Ch`.  `eax` is the value from `var_60` which contains a value
    that decrements from `5` down to `0`.  But since the loop terminates when `var_60`
    reaches `0`, `eax` in this line will only have values from `5` down to `1`.   Calculating
    all five addresses, we should get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'It also happens that the values stored at these stack frame addresses were
    set before calling the first `printf` function. At this point, given the value
    of `eax` from `5` down to `1`, `edx` should have the resulting values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting value of `edx` is then stored in `eax` by the `mov` instruction.
    However, right after this, `20h` is subtracted from `eax`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The next two lines of code is the second exit condition for the loop. The `cmp`
    instruction compares `65h` with the value stored at the address pointed to by
    `eax`. The equivalent ASCII character of `65h` is "e". If the values at the addresses
    pointed to by eax don't match a value of `65h`, the code exits the loop. If a
    mismatch happens, following the red line ends up with a call to `sub_401290`,
    which happens to be the wrong password function. The addresses being compared
    to with the character "`e`" must be part of the input string.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we made a map out of the stack frame in a table, it would look something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | A | B | C | D | E | F |'
  prefs: []
  type: TYPE_TB
- en: '| -60h |  |  |  |  |  |  |  |  | 03 | 00 | 00 | 00 | 05 | 00 | 00 | 00 |'
  prefs: []
  type: TYPE_TB
- en: '| -50h | 07 | 00 | 00 | 00 | 0e | 00 | 00 | 00 | 10 | 00 | 00 | 00 |  |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| -40h |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| -30h |  |  |  |  |  |  |  |  | X | X | X | e | X | e | X | e |'
  prefs: []
  type: TYPE_TB
- en: '| -20h | X | X | X | X | X | X | e | X | e |  |  |  |  |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| -10h |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| ebp |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: We have to consider that `scanf` stored the input password at `ebp-var_28` or
    `ebp-28`. Knowing that there are exactly 17 characters for a correct password,
    we marked these input locations with X. Let's also set the addresses that should
    match with "`e`" to proceed. Remember that the string begins at offset `0`, not
    `1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''re good with the loop, here''s what our pseudocode should look
    like by now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Moving on, after the loop, we will see another block that uses `strcmp`. This
    time, we corrected some of the variable structures to get a better grasp of what
    our stack frame would look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7bd3c5ec-2c74-4cac-93c4-317d01dba058.png)'
  prefs: []
  type: TYPE_IMG
- en: The first two instructions read `DWORD` values from `ebp-1Ah` and `ebp-25h`,
    and are used to calculate a binary, AND. Looking at our stack frame, both locations
    are within the inputted password string area. Eventually, a binary AND is again
    used on the resulting value and `0FFFFFFh`. The final value is stored at `ebp-2Ch`.
    `strcmp` is then used to compare the value stored at `ebp-2Ch` with the string
    "`ere`". If the string comparison does not match, the green line goes to the wrong
    password code block.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the `AND` instruction with `0FFFFFFh` means that it was only limited
    to `3` characters.  Using `AND` on the two `DWORD`s from the password string would
    only mean that both should be equal, at least on the 3 characters. Thus, `ebp-1Ah`
    and `ebp-25h` should contain "`ere`":'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | A | B | C | D | E | F |'
  prefs: []
  type: TYPE_TB
- en: '| -60h |  |  |  |  |  |  |  |  | 03 | 00 | 00 | 00 | 05 | 00 | 00 | 00 |'
  prefs: []
  type: TYPE_TB
- en: '| -50h | 07 | 00 | 00 | 00 | 0e | 00 | 00 | 00 | 10 | 00 | 00 | 00 |  |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| -40h |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| -30h |  |  |  |  | e | r | e |  | X | X | X | e | r | e | X | e |'
  prefs: []
  type: TYPE_TB
- en: '| -20h | X | X | X | X | X | X | e | r | e |  |  |  |  |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| -10h |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| ebp |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: 'Let''s mode on to the next set of code, following the red line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/73b53cca-7aef-41c5-b9a3-0afc4e6ebca1.png)'
  prefs: []
  type: TYPE_IMG
- en: All green lines point to the wrong password code block. So, to keep moving forward,
    we'll have to follow the conditions that go with the red line. The first code
    block in the preceding screenshot uses the `XOR` instruction to validate that
    the characters at `ebp-1Eh` and `ebp-22h` are equal.  The second block adds both
    character values from the same offsets, `ebp-1Eh` and `ebp-22h`.  The sum should
    be `40h`. In that case, the character should have an ASCII value of `20h`, a space
    character.
  prefs: []
  type: TYPE_NORMAL
- en: The third block reads a `DWORD` value from `ebp-28h` and then uses the AND instruction
    to only take the first 3 characters. The result is compared with `647541h`. If
    translated to ASCII characters, it is read as "`duA`".
  prefs: []
  type: TYPE_NORMAL
- en: The fourth block does the same method as the third but takes the `DWORD` from
    `ebp-1Dh` and compares it with `636146h`, or "`caF`".
  prefs: []
  type: TYPE_NORMAL
- en: The last block takes a WORD value from `ebp-20h` and compares it with `7473h`,
    or "`ts`".
  prefs: []
  type: TYPE_NORMAL
- en: 'Writing all these down to our stack frame table should be done in little endian:'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | A | B | C | D | E | F |'
  prefs: []
  type: TYPE_TB
- en: '| -60h |  |  |  |  |  |  |  |  | 03 | 00 | 00 | 00 | 05 | 00 | 00 | 00 |'
  prefs: []
  type: TYPE_TB
- en: '| -50h | 07 | 00 | 00 | 00 | 0e | 00 | 00 | 00 | 10 | 00 | 00 | 00 |  |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| -40h |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| -30h |  |  |  |  | e | r | e |  | A | u | d | e | r | e |  | e |'
  prefs: []
  type: TYPE_TB
- en: '| -20h | s | t |  | F | a | c | e | r | e |  |  |  |  |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| -10h |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| ebp |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: 'The password should be "`Audere est Facere`". If successful, it should run
    the correct password function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c34a978b-bbf5-492c-8000-ce107e4ce454.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To complete our pseudocode, we have to compute the string''s relative offsets
    from `ebp-28h`.  `ebp-28h` is the password string''s offset, 0, while the last
    offset, offset 16, in the string should be at `ebp-18h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Dynamic analysis with debugging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is nothing better than verifying what we assumed during our static analysis.
    Simply running the program and entering the password should finish the job:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/914f5cdf-219e-431e-8e7f-f8d26418db19.png)'
  prefs: []
  type: TYPE_IMG
- en: Deadlisting is as important as debugging a program. Both can be done at the
    same time. Debugging can help speed up the deadlisting process as it is also validated
    at the same time. For this exercise, we're going to redo the analysis of `passcode.exe`
    by using `x32dbg` from [https://x64dbg.com](https://x64dbg.com).
  prefs: []
  type: TYPE_NORMAL
- en: 'After opening `passcode.exe` in `x32dbg`, registering EIP will be at a high
    memory region. This is definitely not in any part of the `passcode.exe` image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0b25b1d6-f32f-482d-a242-7cc8d83686e7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To go around this, click on Options->Preferences, and then under the Events
    tab, uncheck *System Breakpoint**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0755eb35-8860-4dd3-a857-289f1510204b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on the Save button and then use Debug->Restart or press `Ctrl + F2`.
    This restarts the program, but now, EIP should stop at the PE file''s entry point
    address:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/12921e1d-8132-4ff3-98fd-80225be0baa4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'And since we also know the address of the `main` function, we need to set a
    breakpoint there and let the program run (`*F9*`). To do that, in the Command
    box, enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'After running, EIP should stop at the `main` function''s address. We get to
    see a familiar piece of code as we did during deadlisting:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bb43f02d-e2cc-4819-bf62-82d4264411ac.png)'
  prefs: []
  type: TYPE_IMG
- en: '*F7* and *F8* are the shortcut keys for Step in and Step over. Click on the
    Debug menu and you should see the shortcut keys assigned to the debug command.
    Just keep on playing with the commands; if you ever mess things up, you can always
    restart.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The advantage of using the Debugger is that you should easily be able to see
    the stack frame. There are five memory dump windows consisting of the stack frame.
    Let''s use Dump 2 to show us the stack frame. Make two instruction steps to get
    `ebp` set with the stack frame''s base. On the left pane, in the list of registers,
    right-click on Register EBP and then select Follow in Dump->Dump 2\. This should
    bring Dump 2 forward. Since the stack moves down from a higher address, you''ll
    have to roll the scroll bar up to show the initial data we have in the stack frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a37a6d40-e0fd-43a6-946e-d7303976767d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here''s the same stack frame after inputting for `scanf`. Also, during `scanf`,
    you''ll have to switch to the command prompt window to enter the password and
    then switch back after.  Also included in the following screenshot is the stack
    window, located in the right-hand pane:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8da5bf65-1ea5-48cf-b569-0a5e1cb06ef4.png)'
  prefs: []
  type: TYPE_IMG
- en: Even while in the debugger, we can change the contents of the inputted string
    any time, thereby forcing it to continue in the condition toward the correct password.
    All we need to do is right-click on the byte in the Dump window and select Modify
    Value*.* For example, in the loop that compares `65h` ("`e`") with the value stored
    in the address pointed by register `eax`, before stepping on the `cmp` instruction,
    we can change the value at that address.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following screenshot the value stored at the address `0060FF20h` (EAX),
    which is being modifed from `35h` to `65h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1c5731fe-5dfc-421e-bed5-271800735c0f.png)'
  prefs: []
  type: TYPE_IMG
- en: The same modification can be done by doing a binary edit through right-clicking
    on byte, and then selecting *Binary*->*Edit*.
  prefs: []
  type: TYPE_NORMAL
- en: 'And here''s where we should end up if we have a correct password:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9afbc6dc-4f99-4647-b448-cdc9dce17759.png)'
  prefs: []
  type: TYPE_IMG
- en: Decompilers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It may be easier if the pseudocode were automatically given to us. Certain
    tools exist that may be able to help us with that. Let''s try and decompile `passcode.exe`
    ([https://github.com/PacktPublishing/Mastering-Reverse-Engineering/blob/master/ch7/passcode.exe](https://github.com/PacktPublishing/Mastering-Reverse-Engineering/blob/master/ch7/passcode.exe))
    using the standalone version of Snowman ([https://derevenets.com/](https://derevenets.com/)).
    Once the file has been opened, click on View->Inspector.  This should show a box
    containing resolved functions from the program. Look for the function definition
    `_main` and select it to show the equivalent pseudocode of the assembly language.
    This highlights the assembly language line in the left-hand pane and the psuedocode
    in the middle pane:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3db47a1f-e2dc-4d72-b225-ca744f400a4e.png)'
  prefs: []
  type: TYPE_IMG
- en: As of the time of writing this book, the output C source may help, but not all
    are correctly decompiled. For instance, the loop where "`e`" was being compared
    was not decompiled correctly. The output shows a `while` loop, but we expect that
    the `v10` variable should have its value read from the offset calculated in the
    password string. However, most of the code should somehow aid us in understanding
    how the program should work. The decompiler engine for this is open source ([https://www.capstone-engine.org/](https://www.capstone-engine.org/)),
    so not much should be expected as support won't always be there.
  prefs: []
  type: TYPE_NORMAL
- en: The good news is that there are more powerful decompilers that exist, such as
    HexRays. Most institutions and some individual analysts and researchers who perform
    reverse engineering are willing to pay for these decompilers. HexRays is one bang
    for its buck for most reverse engineers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a HexRays decompiled version of `passcode.exe`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/af8762c3-a506-4c10-8cf1-4b77d37555e3.png)'
  prefs: []
  type: TYPE_IMG
- en: Decompilers are continuously developed since these tools speed up analysis.
    They do not decompile perfectly, but should be near the source.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we introduced reverse engineering, beginning with APIs, by
    learning how these are used in a functional program. We then used static and dynamic
    analysis tools to reverse a program.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, there are a lot of reversing tools for Windows available for use. This
    also includes the vast information and research on how to use them for specific
    reversing situations. Reverse engineering is mostly about acquiring the resources
    from the World Wide Web, and from what you already know, we have already done
    that.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[https://visualstudio.microsoft.com](https://visualstudio.microsoft.com): this
    is the download site for Visual Studio'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/visualstudio/productinfo/vs2017-system-requirements-vs:](https://docs.microsoft.com/en-us/visualstudio/productinfo/vs2017-system-requirements-vs)
    site shows recommended system requirements for installing Visual Studio'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://sourceforge.net/projects/orwelldevcpp/](https://sourceforge.net/projects/orwelldevcpp/):
    this site contains the binary downloads of Dev C++.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://developer.microsoft.com/en-us/microsoft-edge/tools/vms/](https://developer.microsoft.com/en-us/microsoft-edge/tools/vms/): appliance
    versions of pre-installed Microsoft Windows can be downloaded here'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://mark0.net/soft-trid-e.html:](http://mark0.net/soft-trid-e.html) Download
    site of the TrID tool and its signature database file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://www.microsoft.com/whdc/system/platform/firmware/PECOFF.mspx:](http://www.microsoft.com/whdc/system/platform/firmware/PECOFF.mspx) documentation
    of the Microsoft Portable E'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
