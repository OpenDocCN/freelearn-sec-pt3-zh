- en: Chapter 7. Applications and Malware Analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although malware for iOS devices is not so common, it is more common when considering
    jailbroken devices. As a forensic analyst, you may be required to analyze a malicious
    application, or more generally the behavior of a suspicious application you have
    never seen before. While we are not trying to write a comprehensive guide to static
    reverse engineer iOS applications, this chapter gives an overview of how to analyze
    an application, whether it is malicious or not. In this chapter, you will first
    learn how to set up the working environment, and install and configure the basic
    tools needed for iOS application analysis. Then, we will move on to application
    analysis principles, learning at which state data can exist and where to look
    for it. Finally, we will see some tools in action that can help to speed up analysis
    and automate some tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first step to take in order to properly set up a testing environment for
    iOS application analysis is to jailbreak your testing device. This is because,
    as an analyst, you need to have full control of what is happening in the device,
    being able to access all kinds of information, whether they are stored in the
    memory or being sent over the network.
  prefs: []
  type: TYPE_NORMAL
- en: How to jailbreak an iPhone is out of the scope of this book, so we will not
    go into the details on how to do it. It is also quite simple. Just download one
    of the software options available, such as Evasi0n (for iOS 7), Redsn0w (for iOS
    8), PanGu (for iOS 8 or 9), and TaiG9 (for iOS 9) and follow the instructions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the device has been jailbroken and Cydia installed, you also need to install
    the following tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '**OpenSSH**: This tool allows you to log in to your jailbroken device via Wi-Fi
    or USB and have a root shell access into it'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**MTerminal**: This tool allows you to run terminal commands on your device
    directly from your device, rather than logging in via SSH from a different system'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**BigBoss recommended tools**: This package contains a series of useful command-line
    tools such as `apt`, `make`, `wget`, `sqlite3`, and so on'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Something you will always need to do when analyzing a malicious application
    is to interact with your iPhone via shell, whether to install new tools or launch
    specific commands from the shell; this is why we installed OpenSSH. The first
    thing you need to do is to change your default root password, which is `alpine`,
    in order to prevent someone else logging remotely into your device (and with root
    privileges). To do this, launch the MTerminal application you just installed and
    run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, there is a nice and comfortable way to connect to your iPhone via USB
    instead of being obliged to go over Wi-Fi. In your computer, edit the `~/.ssh/config`
    file by adding the following entry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This will map the `usb` hostname to the `ssh` connection with the proper parameters
    needed. Moreover, the last row sets up port forwarding such that any connections
    to port `8080` on the iPhone will be forwarded to port `8080` locally on the laptop.
    This will be useful when you have to set up a proxy to intercept the network communications,
    as you will see later in this chapter. Now, you need something listening on port
    `2222`: `usbmuxd`. This daemon is in charge of multiplexing connections over USB
    to the iDevice. To complete the procedure on OS X, you can simply use the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Done! Now you have a shell in your iPhone via USB.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before installing the other tools, it is a good practice to make sure that
    the baseline is up to date. To do this, just execute the following commands from
    your root shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `update` command gets the latest packages list from the default repository,
    while the `upgrade` command will fetch the new versions of packages that already
    exist on the device and don't have the latest version installed using the information
    received by the `update` command run before.
  prefs: []
  type: TYPE_NORMAL
- en: The following sections will quickly introduce three important utilities, which
    you will find useful for dumping encrypted content from memory (for example, code)
    and the Keychain password container.
  prefs: []
  type: TYPE_NORMAL
- en: class-dump
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**class-dump** is a command-line tool used to extract the **Objective-C** class
    information from (decrypted) iOS applications, and it comes installed with the
    Cydia package. Note that it will work only with Objective-C apps and not with
    Swift.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, be aware that the old `class-dump-z` is not compatible with 64-bit
    architectures, which means from iPhone 5s on.
  prefs: []
  type: TYPE_NORMAL
- en: Keychain Dumper
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A very interesting and useful tool is Keychain Dumper that, as the name suggests,
    will let you dump the contents from the Keychain. Normally, the way an application
    is granted access to the Keychain is specified in its entitlements, which define
    the information that can be accessed by that application. The way this tool works
    is that the binary is signed with a self-signed certificate with wildcard entitlements.
    Hence, it is able to access all the Keychain items. To install `keychain_dumper`,
    just download the `zip` archive from the GitHub repo at [https://github.com/ptoomey3/Keychain-Dumper](https://github.com/ptoomey3/Keychain-Dumper)
    and unpack it. Then, you only need to copy the `keychain_dumper` binary to the
    phone as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, make sure that `keychain_dumper` is executable and validate that `/private/var/Keychains/keychain-2.db`
    is world readable. If not, you can set them as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'You should now be able to run the tool without any issues:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from the preceding output, by default, `keychain_dumper` only
    dumps generic and Internet passwords. However, you can also specify optional flags
    to dump additional information from the Keychain, as shown from the help (`-h`)
    command as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: dumpDecrypted
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An executable of an application is encrypted when downloaded from the App Store.
    The `dumpDecrypted` tool, developed by Stefan Esser (his Twitter handle is `@i0n1c`),
    runs the targeted app and dumps it decrypted from memory to disk. To install `dumpDecrypted`,
    download the `zip` archive from its GitHub page ([https://github.com/stefanesser/dumpdecrypted](https://github.com/stefanesser/dumpdecrypted))
    in your Mac (it is for OS X only), unzip it, and compile it on your Mac first.
    Alternatively, `dumpDecrypted` comes also as a tool that can be installed via
    idb as we will see later.
  prefs: []
  type: TYPE_NORMAL
- en: Application analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When analyzing an application, you need to look at all its activities and interactions
    with the system by analyzing all the traces and artifacts left on the system while
    it was running and after it has run and to/from the system. This means being able
    to understand how and with whom the application communicates by sending and receiving
    data. Therefore, you need to look at the three states where data can exist. The
    following are the three states where data can exist:'
  prefs: []
  type: TYPE_NORMAL
- en: Data at rest
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With data at rest, we refer to all the data recorded on storage media; in our
    case, on the mobile device's internal memory. These are the `plist` files, the
    `sqlite` databases, logs, and any other information we can retrieve directly from
    the media itself. We will not go into much details here, since this procedure
    is the same as for the forensic analysis of a specific application that is going
    through the application directory tree structure to check its files and analyze
    the system logs. Refer to [Chapter 6](ch06.html "Chapter 6. Analyzing iOS Devices"),
    *Analyzing iOS Devices*, for more details.
  prefs: []
  type: TYPE_NORMAL
- en: Data in use
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Data in use is, as the name suggests, all data being currently used by the application.
    Such data resides in the memory (RAM) of the device. In a standard malware analysis
    for computer malware, memory analysis is, whenever possible, part of the game.
    Unfortunately, for iOS, but in general, for the entire mobile panorama, memory
    acquisition and analysis is not well developed yet, although some utilities/proof-of-concepts
    to dump the memory have been implemented. However, memory analysis and runtime
    manipulation/abuse are out of the scope of this book, but you can explore them
    yourself and refer to **memscan** ([https://hexplo.it/introducing-memscan/](https://hexplo.it/introducing-memscan/))
    or **heapdump-ios** ([https://blog.netspi.com/ios-tutorial-dumping-the-application-heap-from-memory/](https://blog.netspi.com/ios-tutorial-dumping-the-application-heap-from-memory/))
    to learn about memory analysis, and *Hacking and Securing iOS Applications*, *Jonathan
    Zdziarski*, *O'Reilly Media*, to learn about runtime manipulation/abuse.
  prefs: []
  type: TYPE_NORMAL
- en: Another interesting tool you may want to keep in your arsenal is **Frida** ([http://www.frida.re/](http://www.frida.re/)),
    a dynamic instrumentation framework that allows you to inject your own scripts
    into processes to execute custom debugging logic. Frida has a client/server model,
    which means you will need to install it both on your computer and on the iDevice.
  prefs: []
  type: TYPE_NORMAL
- en: 'On Mac, it is as easy as to type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'While on your jailbroken iDevice, start Cydia and add Frida''s repository by
    navigating to **Manage** | **Sources** | **Edit** |**Add** and entering [https://build.frida.re](https://build.frida.re).
    You should now be able to find and install the Frida package. You can find more
    details about the documentation on Frida''s official website. However, talking
    about memory, a very useful utility built on top of Frida is Fridump ([https://github.com/Nightbringer21/fridump](https://github.com/Nightbringer21/fridump)),
    an open source memory dumping tool. If Frida is correctly installed on both your
    computer and your iDevice (bear in mind that it would be better to have the same
    version installed on both), the approach to follow would be first to get the process
    name via Frida using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `-U` parameter indicates that you are targeting the USB connected device.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you get the process name, you can pass it to `fridump` as shown in the
    following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example will dump the Skype process from the device connected
    via USB (`-u`), reading in chunks of 1 MB (`--max-size`) and extracting also the
    strings on all dump files (`-s`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Fridump has been tested successfully on iOS 8, while on iOS 9 from time to
    time the dump gets stuck close to the end. Even in this case, most of the content
    is being dumped and you will be able to retrieve what you would expect from any
    memory dump in the classical computer environment: configuration files, passwords,
    code executed, everything in clear. Some more information, as well as some case
    examples, is retrievable from the author''s website ([http://pentestcorner.com/introduction-to-fridump/](http://pentestcorner.com/introduction-to-fridump/)).'
  prefs: []
  type: TYPE_NORMAL
- en: Data in transit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Data in transit refers to any information that is being transferred between
    two nodes in a network, which is, in our case, all data sent and received by the
    target application. Being able to observe and manipulate data sent over the network
    by an application is extremely interesting and useful for behavioral/dynamic analysis
    in the case of a suspicious app.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before starting, remember to isolate the device from the networks (all of them),
    especially if you are analyzing a malicious application. Therefore, create an
    ad hoc wireless network that is isolated (not connected to the Internet or to
    your internal network), then set your iPhone to Airplane Mode and switch on only
    the Wi-Fi afterwards so that the other network interfaces remain off.
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin with, you need to route the traffic of the phone through your computer
    in order to pose yourself as the man in the middle. To use the trick in your `ssh`
    configuration, as we did before, start by launching `iproxy` and establishing
    an `ssh` connection to your phone as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, from your device network configuration, set up an HTTP proxy to manual
    toward localhost `127.0.0.1` port `8080`. It will be redirected to your Mac to
    port `8080` :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Data in transit](img/image_07_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that the iPhone is set up, you need to set up a proxy listening on your
    local host port `8080`. **Burp Proxy** is probably the most popular proxy ([http://portswigger.net/burp/](http://portswigger.net/burp/));
    it is cross-platform and there is a free version that works just fine for our
    purposes. However, there are many others out there, so pick your favorite one.
    Once an HTTP request has been intercepted, with Burp you can perform several actions,
    such as modifying the request parameters, intercepting and modifying the response,
    and much more:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Data in transit](img/image_07_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'However, although Burp is great at intercepting the HTTP/HTTPS protocol, you
    may want to have a look at all the traffic, because some applications may not
    use standard HTTP to communicate, and record it for further analysis on a later
    stage. To do so, you will need to install Wireshark, the standard de facto packet
    analyzer, together with `tcpdump`, and run a capture on your loopback interface
    `127.0.0.1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Data in transit](img/image_07_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Of course, on a jailbroken iPhone, you have full control and may choose to install
    and go via `tcpdump` directly on the device.
  prefs: []
  type: TYPE_NORMAL
- en: Automating the analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section will quickly introduce some tools that will help you during the
    analysis, either by speeding up the most common tasks or providing you with some
    extra and very useful functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: idb
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Developed and maintained by Daniel Mayer (his Twitter handle is `@DanlAMayer`),
    idb is a tool that simplifies some of the most common tasks related to iOS application
    analysis. Originally built with a penetration tester/researcher focus, it can
    be of great value for any type of application analysis, thanks to the number of
    tools that it incorporates and the features offered. Written in Ruby, the installation
    procedure is quite straightforward; you just need to run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This is the procedure for Mac OS X. For more information on building and running
    it on other systems, you can refer to the official page at [http://www.idbtool.com/](http://www.idbtool.com/).
  prefs: []
  type: TYPE_NORMAL
- en: Once you have launched idb after following the configuration steps to install
    some needed extra tools on the device, you will have to connect idb to the USB
    device, select an application and start the analysis. Note that, even if it will
    be running a nice GUI, you will be prompted for the root password of the iDevice
    on the shell where you launched idb.
  prefs: []
  type: TYPE_NORMAL
- en: 'Clicking on **Analyze Binary...**, as you can see in the following screenshot,
    will give the first information on the binary itself, verifying, among other things,
    that **PIE**, Stack Smashing Protection, and **ARC** are enabled, which would
    reduce the likelihood of finding memory corruption vulnerabilities to exploit.
    Moreover, if the binary application is encrypted, `idb` will run `dumpdecrypted`
    to decrypt it before analyzing it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![idb](img/image_07_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Other information related to the binary app can also be extracted from the **Binary**
    tab. As you will see, idb extracts all the strings from the decrypted binary.
    This is a standard step you would do when analyzing standard computer malware.
    This is of great use since here you may find the API keys, credentials, encryption
    keys, URLs, and other useful hints. From a static analysis perspective, idb binary
    analysis allows you to dump all the class information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Talking about data at rest, under the **Storage** tab, you will be able to
    analyze all the files related to your target application, such as `plist`, the
    `sqlite` databases, and `Cache.db`, which contains cached HTTP requests/responses
    and offline data cached by web applications such as images, HTML, JavaScript,
    style sheets, and more. The idb tool will also allow you to navigate through the
    app tree structure from the **Filesystem** tab, taking and storing subsequent
    different snapshots to navigate and compare at a later stage:'
  prefs: []
  type: TYPE_NORMAL
- en: '![idb](img/image_07_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Two other interesting functionalities provided are **URL Handlers**, which shows
    you the list of URL handlers and includes a basic fuzzer that can be used to fuzz
    input data via the URL schemes, and the **Keychain** dumper, which is a functionality
    that allows you to dump the Keychain using `keychain_dump`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Tools** tab contains several different tools that are quite handy; they
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Background screenshot**: Although this tool is more useful for forensics/security
    purposes, it looks for an eventual screenshot taken by the system when putting
    the application in the background by pushing the Home button.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Certification manager**: This tool will speed up the management and installation
    of the CA certificate. This is extremely useful, for example, when using Burp
    for HTTPS traffic and an application that actually checks that SSL is in place.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**/etc/hosts file editor**: As we have seen before for the data in transit,
    apps do not always use the HTTP/S protocol, so Burp will not intercept. With this
    editor, you can quickly access and modify `/etc/hosts` of the iPhone in order
    to redirect the traffic toward custom services you may have fired up for the analysis.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![idb](img/image_07_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Last but not least, `idb` offers a real-time log (`syslog`) and pasteboard viewer
    (refer to the following screenshot) via the **Log** and **Pasteboard** tabs, respectively.
    Although it may not seem of great use to monitor the pasteboard when you are the
    one testing the application, it may surprise you to know that applications use
    the pasteboard also for **Inter-Process Communication** (**IPC**). By default,
    idb monitors only the main (default) pasteboard, but you can add additional pasteboard
    names to the list on the right-hand side so that you will also be able to monitor
    the private pasteboards.
  prefs: []
  type: TYPE_NORMAL
- en: 'Regarding the Log panel, idb includes both system messages and any log statements
    that the app produces using `NSLog`, which often discloses sensitive data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![idb](img/image_07_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we introduced some tools for analyzing iOS applications, suspicious
    or not, mainly from a behavioral/dynamic point of view. You learned how to quickly
    analyze the binary, review the data and logs produced by the targeted application,
    intercept, manipulate, and analyze the data sent and received over the network,
    and automate most of the tasks with ad hoc toolkits, such as idb.
  prefs: []
  type: TYPE_NORMAL
- en: Self-test questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Q1\. Which tool can be used to extract Objective-C class information from iOS
    applications?
  prefs: []
  type: TYPE_NORMAL
- en: OpenSSH
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: MTerminal
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: class-dump
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Keychain Dumper
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Q2\. Which tool can be used to dump an unencrypted application from memory?
  prefs: []
  type: TYPE_NORMAL
- en: usbmuxd
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Keychain Dumper
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: dumpDecrypted
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: OpenSSH
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Q3\. Which tool can be used to verify the pasteboard content?
  prefs: []
  type: TYPE_NORMAL
- en: dumpDecrypted
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: iRet
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: iLoot
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: idb
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Q4\. Which tools would you use to best analyze data in transit?
  prefs: []
  type: TYPE_NORMAL
- en: Burp Proxy + Wireshark
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: iproxy + Wireshark
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: dumpDecrypted + tcpdump
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: tcpdump + iproxy
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Q5\. Which set of tools allow automating a series of tasks in order to analyze
    and reverse engineer iOS applications?
  prefs: []
  type: TYPE_NORMAL
- en: iLoot
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: idb
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: class-dump
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: dumpDecrypted
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
