- en: Chapter 8. Performance Tuning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following troubleshooting topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing performance using `ping`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimizing performance using `iperf`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparing IPv4 and IPv6 speed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OpenSSL cipher speed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OpenVPN in Gigabit networks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compression tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Traffic shaping
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tuning UDP-based connections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tuning TCP-based connections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analyzing performance using `tcpdump`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter focuses on getting the best performance out of an OpenVPN setup.
    There are several parameters that can be tuned on both the server side and the
    client side for getting the highest throughput and the lowest latency. However,
    the optimal settings of these parameters largely depend on the network layout.
    The recipes in this chapter will therefore provide guidelines on how to tune these
    parameters and how to measure the increase or decrease in performance. These guidelines
    can then be applied to other network layouts to find the optimal performance.
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing performance using ping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will use the low-level `ping` command to determine the optimal **Maximum
    Transfer Unit** (**MTU**) size for our OpenVPN setup. Finding the right MTU size
    can have a tremendous impact on performance, especially, when using satellite
    links, or even some cable/ADSL providers. Especially, broadband connections using
    the **PPPoE** (**PPP over Ethernet**) protocol often have a non-standard MTU size.
    In a regular LAN setup, it is hardly ever required to optimize the MTU size, as
    OpenVPN's' default settings are close to optimal.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Make sure the client and the server computers are connected over a network.
    For this recipe, the server computer was running CentOS 6 Linux. The client was
    running Fedora 22 Linux, but instructions for a Windows client are given as well.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We first verify that we can reach the server from the client:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will send two ICMP ping packets to the server and two replies should be
    returned. If not, then a firewall or `iptables` rule is blocking ICMP traffic.
    Ensure that the server can be reached using `ping` before proceeding.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Next, try sending a large ping packet from the client to the server, with the `Don't
    Fragment` (**DF**) bit set. Strangely enough, on Linux, this is done using the
    parameter `-M do`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Normally, this command is not successful:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The maximum size of a packet that can be sent from this interface is 1500 bytes.
    From this, the Ethernet headers (normally 28 bytes) need to be subtracted, which
    means that the maximum size of an ICMP packet is 1472 bytes:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For Windows clients, the syntax of the `ping` command is slightly different:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The payload size of 1472 bytes is actually the regular size for an Ethernet-based
    network, even though this recipe was performed over a cable connection.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: A good initial value for OpenVPN's' `tun-mtu` setting is the maximum payload
    size plus the 28 bytes that were subtracted earlier. However, it does not mean
    this is the optimal value, as we will see in the later recipes.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The ICMP protocol which the `ping` command uses has the option to set a flag `Don't
    Fragment` (DF). With this bit set, an ICMP packet may not be broken up into separate
    pieces before it reaches its destination. If the packet were needed to be broken
    up by a router before it could be transmitted, it is dropped and an ICMP error
    code is returned. This provides a very easy method to determine the largest packet
    that can be transmitted to the server and vice versa. In particular, in high-latency
    networks, for example, when a satellite link is used, it is very important to
    limit the number of packets and to maximize the size of each packet.
  prefs: []
  type: TYPE_NORMAL
- en: By smartly using the `ping` command, the maximum packet size can be determined.
    This size can then be used to further optimize the OpenVPN performance.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In some network setups, ICMP traffic is filtered, rendering this recipe useless.
    If it is possible to reach the OpenVPN server, then the tunnel can also be used
    to find the maximum payload size.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start the OpenVPN server with the extra flags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Do the same for the OpenVPN client. Make sure compression is turned off (or
    simply not specified) and that the `fragment` option is not used. This will start
    a clear-text tunnel over which we can send ICMP packets of various sizes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ping the remote end''s VPN IP address, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: When the ICMP packet becomes too large, the traffic will be dropped by an intermittent
    router. Lower the ICMP packet size until the ping returns successfully. From that
    value, the MTU size can be derived.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Tuning UDP-based connections* recipe, which will explain in more detail
    how to tune the performance of UDP-based setups
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Tuning TCP-based connections* recipe, which goes deeper into the details
    of tuning TCP-based setups and also explains some of the intricacies of the MTU
    setting of the network adapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimizing performance using iperf
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe is not really about OpenVPN but more about how to use the network
    performance measurement tool `iperf` in an OpenVPN setup. The `iperf` utility
    can be downloaded from [http://sourceforge.net/projects/iperf/](http://sourceforge.net/projects/iperf/)
    for Linux, Windows, and MacOS.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will run `iperf` outside of OpenVPN and over the VPN tunnel
    itself, after which the differences in performance will be explained.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We use the following network layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/image00394.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Set up the client and server certificates using the *Setting up the public and
    private keys* recipe from [Chapter 2](part0025.xhtml#aid-NQU21 "Chapter 2.  Client-server
    IP-only Networks"), *Client-server IP-only Networks*. For this recipe, the server
    computer was running CentOS 6 Linux and OpenVPN 2.3.11\. The client was running
    Fedora 22 Linux and OpenVPN 2.3.11\. Keep the configuration file `basic-udp-server.conf`
    from the *Server-side routing* recipe from [Chapter 2](part0025.xhtml#aid-NQU21
    "Chapter 2.  Client-server IP-only Networks"), *Client-server IP-only Networks*,
    as well as the client configuration file `basic-udp-client.conf`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Start the server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, start the client:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we start `iperf` on the server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'First, we measure the performance outside the tunnel:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This actually measures the performance of data being sent to the server. The
    cable network used in this recipe has a theoretical upload limit of 4 Megabits
    per second (Mbps), which we are achieving in this test.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, we measure the performance inside the tunnel:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With this network setup, there is a small performance difference between traffic
    sent outside of the tunnel and traffic sent via the tunnel.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'A second test is done over a 802.11n wireless network:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Versus:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, there is a noticeable drop in performance, suggesting that the OpenVPN
    is not configured optimally. There was a lot of noise on this wireless network,
    which makes it difficult to optimize.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `iperf` tool is very straightforward: it sets up a TCP connection (or UDP,
    if desired) and measures how fast it can send or receive data over this connection.
    Normally, traffic is tested in only one direction, although a dual test can be
    triggered using the `-r` flag.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Tuning network performance depends heavily on both the network latency and the
    available bandwidth, as is outlined in more detail here.
  prefs: []
  type: TYPE_NORMAL
- en: Client versus server iperf results
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Both the client and the server `iperf` processes report the network throughput
    after a `iperf -c` session has ended. Practice shows that the numbers reported
    by the server used in this recipe were more accurate than the numbers reported
    by the client. On the cable network used when writing this recipe, the maximum
    upload speed is about 4 Mbps. The client sometimes reported speeds larger than
    4.4 Mbps, whereas the server reported a more accurate 4.1 Mbps.
  prefs: []
  type: TYPE_NORMAL
- en: Network latency
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the main reasons for the lack of performance drop over the cable network
    versus the performance drop over the wireless network is due to network latency.
    On the cable network, the latency was very stable at about 11 ms. On the wireless
    network, the latency varied between 2 ms and 90 ms. Especially, this variation
    in latency can skew the  `iperf` performance measurements, making it very hard
    to optimize the OpenVPN parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Gigabit networks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Performance tests on Gigabit networks show that the VPN itself is becoming the
    bottleneck. A normal TCP connection would show a transfer rate of 900 Mbps, whereas
    a TCP connection via an untuned OpenVPN tunnel would not perform faster than about
    320 Mbps. We will come back to this later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The recipe *OpenVPN in Gigabit networks*, which will explain in more detail
    how to tune OpenVPN for better performance over high-speed networks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparing IPv4 and IPv6 speed
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe is a continuation of the previous recipe, but here we will focus
    on the performance difference between tunneling Pv4 traffic and IPv6 traffic.
    In this recipe, we will run `iperf` over the VPN tunnel using IPv4 addresses and
    IPv6 addresses inside the tunnel, after which the differences in performance will
    be explained.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We use the following network layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/image00395.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Set up the client and server certificates using the *Setting up the public and
    private keys* recipe from [Chapter 2](part0025.xhtml#aid-NQU21 "Chapter 2.  Client-server
    IP-only Networks"), *Client-server IP-only Networks*. For this recipe, the server
    computer was running CentOS 6 Linux and OpenVPN 2.3.11\. The client was running
    Fedora 22 Linux and OpenVPN 2.3.11\. Keep the configuration file `example-2-4-server.conf`
    from the *Adding IPv6 support* recipe from [Chapter 2](part0025.xhtml#aid-NQU21
    "Chapter 2.  Client-server IP-only Networks"), *Client-server IP-only Networks*,
    as well as the client configuration file `basic-udp-client.conf`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Start the server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, start the client:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we start `iperf` on the server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'First, we measure the performance when tunneling IPv4 traffic:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we measure the performance using IPv6 packets:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This shows a performance difference of roughly 5%. This difference is measured
    consistently over all types of networks.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An IPv6 address is longer than an IPv4 address. The source and destination addresses
    for all packets are stored inside the encrypted packets that go over the OpenVPN
    tunnel. Thus, the larger the addressing scheme used, the less bytes are left for
    the actual "payload". An IPv6 packet can actually carry 20 bytes less "payload"
    than an IPv4 packet. These 20 bytes account for the 5% performance difference.
    There is very little that can be done about this.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Tuning network performance depends heavily on the network characteristics, as
    well as the tuning tools used, as is outlined in more detail here.
  prefs: []
  type: TYPE_NORMAL
- en: Client versus server iperf results
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Both the client and the server `iperf` processes report the network throughput
    after an `iperf -c` session has ended. Practice shows that the numbers reported
    by the server used in this recipe were more accurate than the numbers reported
    by the client. Also, more accurate results are achieved by running `iperf` with
    a fixed data size instead of the default fixed time interval of 10 seconds. We
    specify a fixed block size (1 Megabyte) and a fixed total size (8 Megabyte) using `iperf
    -l 1M -n 8M -c <IP-address>`.
  prefs: []
  type: TYPE_NORMAL
- en: This increases accuracy and improves the consistency of the numbers reported
    on the client and server side.
  prefs: []
  type: TYPE_NORMAL
- en: OpenSSL cipher speed
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OpenVPN uses OpenSSL to perform all cryptographic operations. This means that
    the performance of an OpenVPN client or server depends on how fast the incoming
    traffic can be decrypted and how fast the outgoing traffic can be encrypted. For
    a client with a single connection to the OpenVPN server, this is almost never
    an issue, but with an OpenVPN server with hundreds of clients, the cryptographic
    performance becomes very important. Also, when running OpenVPN over a high-speed
    network link (Gigabit or higher), the cryptographic performance also plays an
    important role.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will show how to measure the performance of the OpenSSL cryptographic
    routines and how this measurement can be used to improve the performance of an
    OpenVPN server.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This recipe is performed on a variety of computers:'
  prefs: []
  type: TYPE_NORMAL
- en: An old laptop with an Intel Core2 Duo T9300 processor running at 2.5 GHz, running
    Fedora Linux 22 64bit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An older server with an Intel Xeon X5660 processor running at 2.8 GHz and with
    support for the AESNI instructions, running CentOS 6 64bit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A high-end server with an Intel Xeon E5-2697A v4 processor running at 2.6 GHz
    and with support for the AESNI instructions, running CentOS 6 64bit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The recipe can easily be performed on MacOS as well. Each computer had OpenVPN
    2.3 installed, with the accompanying OpenSSL libraries.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'On each system, the following OpenSSL commands are run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The first command tests the speed of the OpenVPN default BlowFish cryptographic
    cipher. The second and third test the performance of the 128 and 256-bit AES ciphers,
    which are very commonly used to secure websites. All commands were run twice on
    the new high-end server: once with support for the AES-NI instruction set turned
    on and once with AES-NI support off using the `$ OPENSSL_ia32=0 openssl speed
    -evp <cipher>`.'
  prefs: []
  type: TYPE_NORMAL
- en: The results are displayed in the following table. All numbers in the tables
    are the bytes per second processed when encrypting a block of data. The size of
    the block of data is listed in the columns.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the `BlowFish` cipher, the following results were recorded:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Type** | **256 bytes** | **1024 bytes** | **8192 bytes** |'
  prefs: []
  type: TYPE_TB
- en: '| Laptop | 95851.54k | 95426.22k | 95862.84k |'
  prefs: []
  type: TYPE_TB
- en: '| Old Server | 111466.67k | 111849.47k | 112162.13k |'
  prefs: []
  type: TYPE_TB
- en: '| New Server | 151329.96k | 152054.10k | 152428.54k |'
  prefs: []
  type: TYPE_TB
- en: '| New Server, no AES-NI | 151128.49k | 151951.02k | 152048.98k |'
  prefs: []
  type: TYPE_TB
- en: 'For the `AES128` cipher, the following results were recorded:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Type** | **256 bytes** | **1024 bytes** | **8192 bytes** |'
  prefs: []
  type: TYPE_TB
- en: '| Laptop | 85588.05k | 179870.91k | 183104.85k |'
  prefs: []
  type: TYPE_TB
- en: '| Old Server | 758884.44k | 762378.58k | 755960.49k |'
  prefs: []
  type: TYPE_TB
- en: '| New Server | 802229.85k | 806787.75k | 807682.05k |'
  prefs: []
  type: TYPE_TB
- en: '| New Server, no AES-NI | 160414.98k | 361608.53k | 368836.61k |'
  prefs: []
  type: TYPE_TB
- en: 'And for `AES256`:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Type** | **256 bytes** | **1024 bytes** | **8192 bytes** |'
  prefs: []
  type: TYPE_TB
- en: '| Laptop | 60698.20k | 130553.15k | 132085.73k |'
  prefs: []
  type: TYPE_TB
- en: '| Old Server | 560398.93k | 562632.92k | 564687.49k |'
  prefs: []
  type: TYPE_TB
- en: '| New Server | 577053.35k | 578981.21k | 579532.12k |'
  prefs: []
  type: TYPE_TB
- en: '| New Server, no AES-NI | 114444.29k | 266473.47k | 270030.17k |'
  prefs: []
  type: TYPE_TB
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The output of the `openssl speed` command shows that the encryption and decryption
    performance is dependent on both the encryption key and the hardware used. Most
    OpenVPN packets are about 1500 bytes, so the column 1024 bytes is the most interesting
    column to look at.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `BlowFish` cipher results are quite interesting if you take the processor
    speed into account: if you divide the `BlowFish` performance by the processor
    clock speed the numbers are very similar. This means that the `BlowFish` performance
    is bound purely by the processor clock speed. An older type processor running
    at a higher clock speed might actually outperform a newer processor with a slightly
    lower clock speed.'
  prefs: []
  type: TYPE_NORMAL
- en: For the `AES128` and `AES256` ciphers, this is no longer true. Here the modern
    i5/i7 and Xeon architectures are much faster than the older Pentium 4 and Athlon
    architectures. With the AES-NI extensions, the performance jumps by a factor of
    4\. If an OpenVPN server is set up that must support many clients, then this cryptographic
    cipher is an excellent choice, provided that the server CPU supports these extensions.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe also provides a simple test of whether the AES-NI instructions are
    available and whether they are actually picked up by the underlying OpenSSL library.
    If the speed results between `openssl` and `OPENSSL_ia32cap=0 openssl` do not
    differ, then the AES-NI instructions are not being used for encryption or decryption.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The choice of the cryptographic cipher on the performance of OpenVPN is minimal
    for a single client. Measurements done for this recipe indicate that the client
    CPU has a load of less than 8% when downloading a file at the highest speed over
    the VPN tunnel on a modern system. However, on the older desktop, the choice of
    cryptographic cipher does become important: upload speed drops from 760 kbps to
    720 kbps when the `BlowFish` cipher changes to the `AES256` cipher. In particular,
    when older hardware or certain home router equipment is used, this can quickly
    become a bottleneck. Most home wireless routers capable of running OpenVPN, for
    example, the wireless routers that support the DD-WRT or OpenWRT distributions,
    have a processor speed of about 250 MHz. This processor speed can quickly become
    the bottleneck if this router is also used as an OpenVPN server, especially when
    multiple clients connect simultaneously.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Cipher mismatches* recipe from [Chapter 6](part0071.xhtml#aid-23MNU1 "Chapter 6. Troubleshooting
    OpenVPN - Configurations"), *Troubleshooting OpenVPN - Configurations*, which
    explains in more detail how to troubleshoot cipher mismatches in the client and
    server configuration files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OpenVPN in Gigabit networks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the advent of high-speed networks, the need for a high-speed VPN has also
    increased. OpenVPN is not particularly built for high speeds, but with modern
    hardware and the right encryption ciphers it is possible to achieve near-gigabit
    speeds with OpenVPN 2.4\. This recipe will show you how to achieve these speeds.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We use the following network layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/image00396.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The client used in this recipe was a laptop with a Core i7-4810 processor with
    a maximum Turboboost speed of 3.8 GHz. The server was a server with an Xeon E5-2697A
    v4 processor with a maximum Turboboost speed of 3.6 GHz. Connect the client and
    the server both to a Gigabit Ethernet switch. Set up the client and server certificates
    using the *Setting up the public and private keys* recipe from [Chapter 2](part0025.xhtml#aid-NQU21
    "Chapter 2.  Client-server IP-only Networks"), *Client-server IP-only Networks*.
    For this recipe, the server computer was running CentOS 6 Linux and OpenVPN 2.4.0.
    The client was running Fedora 22 Linux and OpenVPN 2.4.0\. Keep the configuration
    file `basic-udp-server.conf` from the *Server-side routing* recipe from [Chapter
    2](part0025.xhtml#aid-NQU21 "Chapter 2.  Client-server IP-only Networks"), *Client-server
    IP-only Networks*, as well as the client configuration file `basic-udp-client.conf`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Start the server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, start the client:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we start `iperf` on the server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'First, we measure the performance outside the tunnel:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: For a Gigabit Ethernet network, this is close to the theoretical limit.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, we measure the performance inside the tunnel:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is the performance of a default OpenVPN tunnel.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Stop both the client and server OpenVPN processes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, we switch to an AES-256 cipher to make use of the AES-NI instructions
    that both processors support:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And the client:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Again, we measure the performance inside the tunnel, testing both directions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This clearly shows that the AES-NI instructions make a difference.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Stop both the client and server OpenVPN processes again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, we switch to AES-256-GCM, a new cipher algorithm supported by OpenVPN
    2.4, which is more efficient compared to an AES-256 cipher and SHA2 HMAC function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And the client:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Again, we measure the performance inside the tunnel, testing both directions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The last performance numbers are actually quite close to the maximum speed that
    can be achieved over an OpenVPN tunnel on a Gigabit Ethernet network.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When processors are used that have a high clock speed and have support for the
    AES-NI instructions, OpenVPN and the operating system are capable of keeping up
    with the flood of packets that is coming in and needs to be sent out at Gigabit
    Ethernet speeds.
  prefs: []
  type: TYPE_NORMAL
- en: The new AES-256-GCM encryption cipher especially helps here, as the encryption
    and authentication (HMAC) are done in one step. This greatly improves performance,
    in part due to shorter computing time and in part due to the fact that this cipher
    has a smaller encryption overhead for each packet, leaving more bytes for the
    actual "payload".
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Tuning network performance on Gigabit Ethernet depends heavily on the hardware
    and operating system used.
  prefs: []
  type: TYPE_NORMAL
- en: Plain-text tunnel
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Another interesting test to run is to turn off all encryption and authentication
    (`--cipher none --auth none`) and then run the `iperf` tests once more. With the
    hardware used in this recipe the following numbers were achieved:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: These numbers are even closer to the actual line speed, mostly due to the fact
    that there is no encryption overhead, leaving optimal space for the "payload".
  prefs: []
  type: TYPE_NORMAL
- en: Windows performance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `iperf` tool is also available on Windows, so the above recipe can also
    be done using a Windows client and/or server. The results are very different compared
    to the Linux client or server. We can achieve similar "raw" Ethernet speeds by
    using `[WinClient]> iperf -w 128K -c <openvpn-server-ip>`.
  prefs: []
  type: TYPE_NORMAL
- en: However, performance over the OpenVPN tunnel, with or without encryption, is
    well below 200 Mbps, even with the fastest processors used. Most likely, this
    is due to a design issue in the Windows TAP driver. This issue is currently under
    investigation.
  prefs: []
  type: TYPE_NORMAL
- en: Compression tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OpenVPN has built-in support for LZO compression if compiled properly. All Windows
    binaries have LZO compression available by default. In this recipe, we will show
    what is the performance of using LZO compression when transferring both easily
    compressible data (such as web pages) and non-compressible data (such as photographs
    or binaries).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We use the following network layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/image00397.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Set up the client and server certificates using the *Setting up the public and
    private keys* recipe from [Chapter 2](part0025.xhtml#aid-NQU21 "Chapter 2.  Client-server
    IP-only Networks"), *Client-server IP-only Networks*. For this recipe, the server
    computer was running CentOS 6 Linux and OpenVPN 2.3.11\. The first client was
    running Fedora 22 Linux and OpenVPN 2.3.11\. Keep the configuration file `basic-udp-server.conf`
    from the *Server-side routing* recipe from [Chapter 2](part0025.xhtml#aid-NQU21
    "Chapter 2.  Client-server IP-only Networks"), *Client-server IP-only Networks*,
    as well as the client configuration file `basic-udp-client.conf`. The recipe was
    repeated with a second client running Windows 7 64bit and OpenVPN 2.3.11\. Keep
    the configuration file `basic-udp-server.conf` from the *Server-side routing*
    recipe from [Chapter 2](part0025.xhtml#aid-NQU21 "Chapter 2.  Client-server IP-only
    Networks"), *Client-server IP-only Networks*, as well as the client configuration
    file `basic-udp-client.ovpn` from the *Using an ifconfig-pool block* .
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Append the following line to the `basic-udp-server.conf` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save it as `example8-6-server.conf`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Start the server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Similarly, for the client, add a line to the `basic-udp-client.conf` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save it as `example8-6-client.conf`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Start the client:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we start `iperf` on the server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'First, we measure the performance when transferring data outside of the tunnel:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This results in a throughput of about 50 Mbps over an 802.11n wireless network.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, non-compressible data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the first step, we create a 60MB file with random data. Then, we measure
    the `iperf` performance when transferring this file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'And finally, compressible data (a file filled with zeroes):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The performance of the VPN tunnel when transferring compressible data such as
    text files and web pages is shown.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The same measurement can be made using a Windows PC. Add the following line
    to the `basic-udp-client.ovpn` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save it as `example8-6.ovpn`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Start the client.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The results of the `iperf` measurement are slightly different:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Outside the tunnel: 50 Mbps'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Non-compressible data: 16 Mbps'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Compressible data: 22 Mbps'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clearly, the OpenVPN configuration needs to be optimized, but that is outside
    the scope of this recipe. These results do show that for both Windows and Linux
    clients, there is a significant performance boost when the data that is sent over
    the tunnel is easily compressible.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When compression is enabled, all packets that are sent over the tunnel are compressed
    before they are encrypted and transferred to the other side. Compression is done
    using the LZO library, which is integrated into OpenVPN. This compression is done
    on-the-fly, which means that the compression ratios achieved are not as good as
    when compressing the data in advance. When transferring text pages, the performance
    gain is nevertheless significant.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When the following configuration directive is used, adaptive compression is
    enabled by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'When OpenVPN detects that a particular piece of data is not compressible, it
    sends the data to the remote VPN endpoint without compressing it first. By specifying
    the following on both ends each packet is always compressed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Depending on the type of data that is transferred, the performance is slightly
    better.
  prefs: []
  type: TYPE_NORMAL
- en: Traffic shaping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will use traffic shaping to limit the upload speed of an
    OpenVPN client. This can be used to throttle the bandwidth of a client to the
    server, or from client to client. Note that OpenVPN traffic shaping cannot be
    used to throttle the download speed of OpenVPN clients. Throttling download speeds
    can best be achieved using external traffic control tools, such as the `tc` utility
    on Linux, which is part of the LARTC package.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We use the following network layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/image00398.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Set up the client and server certificates using the *Setting up the public and
    private keys* recipe from [Chapter 2](part0025.xhtml#aid-NQU21 "Chapter 2.  Client-server
    IP-only Networks"), *Client-server IP-only Networks*. For this recipe, the server
    computer was running CentOS 6 Linux and OpenVPN 2.3.11\. The client was running
    Windows 7 64 bit and OpenVPN 2.3.11\. Keep the configuration file `basic-udp-server.conf`
    from the *Server-side routing* recipe from [Chapter 2](part0025.xhtml#aid-NQU21
    "Chapter 2.  Client-server IP-only Networks"), *Client-server IP-only Networks*,
    as well as the client configuration file `basic-udp-client.ovpn` from the *Using
    an ifconfig-pool block* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Append the following line to the `basic-udp-server.conf` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will throttle the upload speed of the VPN clients to 100,000 bytes per
    second (100 kbps). Save it as `example8-7-server.conf`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Start the server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Start the client:![How to do it...](img/image00399.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we start `iperf` on the server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When we run `iperf` on the Windows PC, the performance is close to 100 KB/s:![How
    to do it...](img/image00400.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The PNG number of bytes being sent over the tunnel, including encryption overhead,
    is actually very close to 100,000 bytes per second.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When the OpenVPN client connects to the server, the server pushes out an option
    to shape outgoing traffic over the VPN tunnel to 100 KB/s. Whenever traffic is
    sent over the tunnel, the OpenVPN client itself limits the outgoing traffic to
    a maximum of 100 KB/s. The download speed is not affected by this, and note that
    the following directive cannot be used on the OpenVPN server itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: To throttle traffic leaving the server, more advanced traffic control tools
    such as `tc` for Linux should be used.
  prefs: []
  type: TYPE_NORMAL
- en: Tuning UDP-based connections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we focus on some of the basic techniques for optimizing UDP-based
    VPN tunnels. These techniques need to be applied with care, as there is no fool-proof
    method for optimizing OpenVPN performance. The actual performance gain varies
    with each network setup. Therefore, this recipe only shows some of the configuration
    directives that can be used for this optimization.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We use the following network layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/image00401.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Set up the client and server certificates using the *Setting up the public and
    private keys* recipe from [Chapter 2](part0025.xhtml#aid-NQU21 "Chapter 2.  Client-server
    IP-only Networks"), *Client-server IP-only Networks*. For this recipe, the server
    computer was running CentOS 6 Linux and OpenVPN 2.3.11\. The client was running
    Fedora 22 Linux and OpenVPN 2.3.11\. Keep the configuration file `basic-udp-server.conf`
    from the *Server-side routing* recipe from [Chapter 2](part0025.xhtml#aid-NQU21
    "Chapter 2.  Client-server IP-only Networks"), *Client-server IP-only Networks*,
    as well as the client configuration file `basic-udp-client.conf`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Append the following line to the `basic-udp-server.conf` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save it as `example8-8-server.conf`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Start the server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Similarly, for the client, add a line to the `basic-udp- client.conf` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save it as `example8-8-client.conf`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Start the client:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we start `iperf` on the server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'First, we measure the performance outside the tunnel:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This actually measures the performance of data being sent to the server. The
    cable network used in this recipe has a theoretical upload limit of 4 Mbps. Note
    that this result is nearly the same as found in the recipe *Optimizing performance
    using iperf*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, we measure the performance inside the tunnel:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: A slight penalty is incurred due to the OpenVPN tunnel, but the results are
    nearly identical to the results found in the recipe *Optimizing performance using
    iperf*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Fragmentation does have an effect on the `ping` round-trip times, however.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'For various values of the `fragment` option, run the `ping` command from the
    client to server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The results are listed in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Fragmentation size** | **Ping result** |'
  prefs: []
  type: TYPE_TB
- en: '| Default (1500) | 9.4 +/- 1.0 ms |'
  prefs: []
  type: TYPE_TB
- en: '| 1400 | 9.9 +/- 1.5 ms |'
  prefs: []
  type: TYPE_TB
- en: '| 400 | 19.2 +/- 8 ms |'
  prefs: []
  type: TYPE_TB
- en: Thus, adding the `fragment` option to the server configuration is not a viable
    option for this network setup. However, in other network setups, this might improve
    performance.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The OpenVPN configuration directive `fragment 1400` causes all encrypted packets
    that are larger than 1400 bytes to be fragmented. If the network latency is low
    enough, this does not have a noticeable effect on performance, as the `iperf`
    results. By lowering the fragmentation size, packets are split into more and more
    packets. This causes the round-trip time for larger packets to increase. If the
    network latency is already high, this will cause even more latency issues. Hence,
    the `fragment` option and associated `mssfix` option must be used with care.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `fragment` directive is often used in conjunction with the `mssfix` directive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: This directive announces to TCP sessions running over the tunnel that they should
    limit their send packet sizes so that after OpenVPN has encapsulated them; the
    resulting UDP packet size that OpenVPN sends to its peer will not exceed the maximum
    segment size. It is also used internally by OpenVPN to set the maximum segment
    size of outbound packets. If no maximum segment size is specified, the value from
    the `fragment` directive is used.
  prefs: []
  type: TYPE_NORMAL
- en: Ideally, the `mssfix` and `fragment` directives are used together, where `mssfix`
    will try to keep TCP from needing packet fragmentation in the first place, and
    if big packets come through anyhow (for example, from protocols other than TCP),
    the `fragment` directive will internally fragment them.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next recipe in this chapter, which explains how to tune TCP-based connections
    in a very similar manner
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tuning TCP-based connections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we focus on some of the basic techniques for optimizing TCP-based
    VPN tunnels. In a TCP-based VPN setup, the connection between the VPN endpoints
    is a regular TCP connection. This has advantages and drawbacks. The main advantage
    is that it is often easier to set up a TCP connection than a UDP connection, mostly
    due to firewall restrictions. The main drawback of tunneling TCP traffic over
    a TCP-based tunnel is that there is chance of severe performance penalties, especially
    when the network connection is poor. This performance penalty is caused by the
    *tcp-over-tcp* syndrome. The TCP protocol guarantees the ordered delivery of packets,
    thus if a packet is dropped along the way, the packet will be resent. Once the
    new packet is received, the packet order is restored. Until that time, all packets
    after the `lost` packet are on hold. The problem with tunneling TCP traffic over
    a TCP connection is that both layers want to guarantee ordered packet delivery.
    This can lead to a large amount of retransmits and hence to a large performance
    penalty.
  prefs: []
  type: TYPE_NORMAL
- en: When tuned correctly, however, an OpenVPN tunnel over a TCP connection can achieve
    the same performance as an OpenVPN tunnel over a UDP connection. In this recipe,
    we will show some techniques for tuning such a TCP-based OpenVPN connection.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We use the following network layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/image00402.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Set up the client and server certificates using the *Setting up the public and
    private keys* recipe from [Chapter 2](part0025.xhtml#aid-NQU21 "Chapter 2.  Client-server
    IP-only Networks"), *Client-server IP-only Networks*. For this recipe, the server
    computer was running CentOS 6 Linux and OpenVPN 2.3.11\. The client was running
    Windows 7 64bit and OpenVPN 2.3.11\. Keep the configuration file `basic-udp-server.conf`
    from the *Server-side routing* recipe from [Chapter 2](part0025.xhtml#aid-NQU21
    "Chapter 2.  Client-server IP-only Networks"), *Client-server IP-only Networks*,
    as well as the client configuration file `basic-udp-client.ovpn` from the *Using
    an ifconfig-pool block *recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create the server configuration file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save it as `example8-9-server.conf`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Start the server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, create the client configuration file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save it as `example8-9.ovpn`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start the client:![How to do it...](img/image00403.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, start `iperf` on the server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, measure the performance of the tunnel:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'On this particular network, the following settings were tested:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Protocol** | **Result** |'
  prefs: []
  type: TYPE_TB
- en: '| UDP | 147 Mbits/sec |'
  prefs: []
  type: TYPE_TB
- en: '| TCP | 115 Mbits/sec |'
  prefs: []
  type: TYPE_TB
- en: '| TCP with tcp-nodelay | 146 Mbits/sec |'
  prefs: []
  type: TYPE_TB
- en: As can be seen, the performance of running OpenVPN over TCP is almost identical
    to the performance of OpenVPN over UDP, when the `--tcp-nodelay` directive is
    used.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When OpenVPN uses TCP as its underlying protocol, all packets are transferred
    over a regular TCP connection. By default, TCP connections make use of the Nagle
    algorithm, where smaller packets are held back and collected before they are sent.
    For an OpenVPN tunnel, this has an adverse effect on performance in most cases,
    hence it makes sense to disable the Nagle algorithm. By adding the `--tcp-nodelay`
    directive, we disable the Nagle algorithm and we see an immediate increase in
    performance.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The two important parameters that can be tweaked for TCP-based connections
    are:'
  prefs: []
  type: TYPE_NORMAL
- en: The `--tcp-nodelay` directive
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The MTU size of the TUN/TAP-Win32 adapter via either the `--tun-mtu` or  `--link-mtu`
    directives
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'On Linux, the MTU size of the TUN (or TAP) adapter can be adjusted on-the-fly,
    but on Windows, this is not as easy. OpenVPN must be configured to match the MTU
    size as specified on the server. Before the new MTU size is used, however, the
    MTU of the TAP adapter must be adjusted. Starting with Windows Vista, it is now
    also possible to do this on-the-fly, using the `netsh` command:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, find the right sub-interface number:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, in order to change the MTU size of a sub-interface, use:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that these commands must be run with elevated privileges.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the MTU setting of the Windows TAP-Win32 adapter is larger than the MTU
    size configured by OpenVPN, the following message can appear in the OpenVPN log
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: For this particular network, all changes made to the MTU size (with the appropriate
    Windows reboot) did not have a positive effect on performance.
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing performance using tcpdump
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will analyze the performance of an OpenVPN setup using the
    `tcpdump` utility. It is also possible to use the Wireshark utility, which is
    available for Linux, Windows, and Mac OS X. While this recipe does not cover any
    new OpenVPN functionality, it is useful to show how such an analysis can be made.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We use the following network layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/image00404.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Set up the client and server certificates using the *Setting up the public and
    private keys* recipe from [Chapter 2](part0025.xhtml#aid-NQU21 "Chapter 2.  Client-server
    IP-only Networks"), *Client-server IP-only Networks*. For this recipe, the server
    computer was running CentOS 6 Linux and OpenVPN 2.3.11\. The client was running
    Fedora 22 Linux and OpenVPN 2.3.11\. Keep the configuration file `example8-8-server.conf`
    from the *Tuning UDP-based connections* recipe from [Chapter 2](part0025.xhtml#aid-NQU21
    "Chapter 2.  Client-server IP-only Networks"), *Client-server IP-only Networks*,
    as well as the client configuration, `example8-8-client.conf`, from the same recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Start the server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, start the client:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'On the server, run `tcpdump` to watch for the incoming packets on the network
    interface (not the tunnel interface itself):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This instructs `tcpdump` to listen on the local network interface for all UDP
    traffic on port `1194`, which is the OpenVPN default.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'From the client, ping the server''s VPN IP address with two different sizes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following packets are seen in the `tcpdump` screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/image00405.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The first ICMP packets are sent unfragmented, as they are smaller than 1400
    bytes. The second set of encrypted ICMP packets is larger than the fragment size
    (1400) and hence are split into two parts.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The OpenVPN configuration directive `fragment 1400` causes all the encrypted
    packets that are larger than 1400 bytes to be fragmented. When watching the encrypted
    traffic, this can be verified by pinging the OpenVPN server. Note that packets
    which need to be fragmented are fragmented evenly: all packets have the same size.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, note that the following command causes the encrypted packet to be larger
    than 1400 bytes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: The encryption needed for the secure tunnel adds extra overhead to the packets
    that are transmitted. This is one of the root causes for a performance penalty
    when using VPN tunnels (not just OpenVPN) compared to non-encrypted traffic. In
    most networks, this overhead is not noticed, but it always exists.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Tuning UDP-based connections* recipe in this chapter, which explains how
    to use the `fragment` directive
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
