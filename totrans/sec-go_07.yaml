- en: Secure Shell (SSH)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Secure Shell** (**SSH**) is a cryptographic network protocol for communicating
    on an unsecure network. The most common use of SSH is in connecting to a remote
    server and interacting with a shell. File transfer is also used via SCP and SFTP
    over the SSH protocol. SSH was created to replace the plaintext protocol, Telnet.
    Over time, there have been numerous RFCs to define SSH. Here is a partial list
    to give you an idea of what is defined. Since it is such a common and critical
    protocol, it is worth taking the time to understand the details. The following
    are some of the RFCs:'
  prefs: []
  type: TYPE_NORMAL
- en: '*RFC 4250* ([https://tools.ietf.org/html/rfc4250](https://tools.ietf.org/html/rfc4250)):
    *The Secure Shell (SSH) Protocol Assigned Numbers*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*RFC 4251* ([https://tools.ietf.org/html/rfc4251](https://tools.ietf.org/html/rfc4251)):
    *The Secure Shell (SSH) Protocol Architecture*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*RFC 4252* ([https://tools.ietf.org/html/rfc4252](https://tools.ietf.org/html/rfc4252)):
    *The Secure Shell (SSH) Authentication Protocol*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*RFC 4253* ([https://tools.ietf.org/html/rfc4253](https://tools.ietf.org/html/rfc4253)):
    *The Secure Shell (SSH) Transport Layer Protocol*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*RFC 4254* ([https://tools.ietf.org/html/rfc4254](https://tools.ietf.org/html/rfc4254)):
    *The Secure Shell (SSH) Connection Protocol*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*RFC 4255* ([https://tools.ietf.org/html/rfc4255](https://tools.ietf.org/html/rfc4255)):
    *Using DNS to Securely Publish Secure Shell (SSH) Key Fingerprints*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*RFC 4256* ([https://tools.ietf.org/html/rfc4256](https://tools.ietf.org/html/rfc4256)):
    *Generic Message Exchange Authentication for the Secure Shell Protocol (SSH)*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*RFC 4335* ([https://tools.ietf.org/html/rfc4335](https://tools.ietf.org/html/rfc4335)):
    **The Secure Shell (SSH) Session Channel Break Extension**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*RFC 4344* ([https://tools.ietf.org/html/rfc4344](https://tools.ietf.org/html/rfc4344)):
    *The Secure Shell (SSH) Transport Layer Encryption Modes*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*RFC 4345* ([https://tools.ietf.org/html/rfc4345](https://tools.ietf.org/html/rfc4345)):
    *Improved Arcfour Modes for the Secure Shell (SSH) Transport Layer Protocol*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There were also additional expansions later to the standard, which you can read
    about at [https://en.wikipedia.org/wiki/Secure_Shell#Standards_documentation](https://en.wikipedia.org/wiki/Secure_Shell#Standards_documentation).
  prefs: []
  type: TYPE_NORMAL
- en: SSH is a common target for brute force and default credential attacks across
    the internet. For this reason, you might consider putting SSH on a nonstandard
    port, but keep it to a system port (less than 1024) so that a low-privileged user
    cannot potentially hijack the port if the service goes down. If you leave SSH
    on the default port, services such as `fail2ban` can be invaluable for rate limiting
    and blocking brute force attacks. Ideally, password authentication is disabled
    completely and key authentication is required.
  prefs: []
  type: TYPE_NORMAL
- en: 'The SSH package does not come packaged with the standard library, although
    it was written by the Go team. It is officially part of the Go project, but outside
    of the main Go source tree, so it is not installed with Go by default. It is available
    from [https://golang.org/](https://golang.org/) and can be installed using this
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In this chapter, we will cover how to use the SSH client to connect, execute
    commands, and use an interactive shell. We will also cover the different methods
    of authentication such as using a password or a private key. The SSH package provides
    functions for creating a server, but we'll cover only the client in this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will specifically cover the following for SSH:'
  prefs: []
  type: TYPE_NORMAL
- en: Authenticating with a password
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authenticating with a private key
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Verifying the key of a remote host
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executing a command over SSH
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Starting an interactive shell
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Go SSH client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `golang.org/x/crypto/ssh` package provides an SSH client that is compatible
    with SSH version 2—the latest version. The client will work with the OpenSSH servers
    and any other server that follows the SSH specifications. It supports the traditional
    client features such as subprocesses, port forwarding, and tunneling.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Authentication is not just the first step but also the most critical. Improper
    authentication can lead to potential loss of confidentiality, integrity, and availability.
    A man-in-the-middle attack can occur if the remote server is not verified, leading
    to spying, manipulation, or blocking of data. Weak password authentication can
    be exploited by brute force attacks.
  prefs: []
  type: TYPE_NORMAL
- en: Three examples are provided here. The first example covers password authentication,
    which is common, but not recommended due to the low entropy and bit count of passwords
    compared with that of cryptographic keys. The second example demonstrates how
    to use a private key to authenticate with a remote server. Both of these examples
    ignore the public key provided by the remote host. This is insecure, because you
    may end up connecting to a remote host you do not trust, but is good enough for
    testing. The third example of authentication is the ideal flow. It authenticates
    with a key and verifies the remote server.
  prefs: []
  type: TYPE_NORMAL
- en: Note that this chapter does not use PEM formatted key files as in [Chapter 6](f68073f0-8cc8-40b5-af0e-795ce30e5271.xhtml),
    *Cryptography*. This uses SSH formatted keys, which is naturally the most common
    format for working with SSH. These examples are compatible with the OpenSSH tools
    and keys such as `ssh`, `sshd`, `ssh-keygen`, `ssh-copy-id`, and `ssh-keyscan`.
  prefs: []
  type: TYPE_NORMAL
- en: 'I recommend that you use `ssh-keygen` to generate a public and private key
    pair for authentication. This will generate the `id_rsa` and `id_rsa.pub` files
    in the SSH key format. The `ssh-keygen` tool is part of the OpenSSH project and
    is packed with Ubuntu by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Use `ssh-copy-id` to copy your public key (`id_rsa.pub`) to the remote server''s
    `~/.ssh/authorized_keys` file so that you can authenticate using the private key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Authenticating with a password
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Password authentication over SSH is the simplest method. This example demonstrates
    how to configure an SSH client with the `ssh.ClientConfig` struct and then connect
    to an SSH server using `ssh.Dial()`. The client is configured to use a password
    by specifying `ssh.Password()` as the authentication function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Authenticating with private key
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A private key has a few advantages over password. It is much longer than a password,
    making it exponentially more difficult to brute force. It also eliminates the
    need to type in a password, making it convenient to connect to remote servers.
    Passwordless authentication is also helpful for cron jobs and other services that
    need to run automatically without human intervention. Some servers disable password
    authentication completely and require a key.
  prefs: []
  type: TYPE_NORMAL
- en: The remote server will need to have your public key as an authorized key before
    you can authenticate using the private key.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the `ssh-copy-id` tool if it is available on your system. It will
    copy your public key to the remote server, place it in your home folder SSH directory
    (`~/.ssh/authorized_keys`), and set the correct permissions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The following example is similar to the previous example, where we authenticate
    using a password, but `ssh.ClientConfig` is configured to use `ssh.PublicKeys()`
    as the authentication function, instead of `ssh.Password()`. We will also create
    a special function named `getKeySigner()` in order to load the private key for
    the client from a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Note that you can pass more than a single private key to the `ssh.PublicKeys()`
    function. It accepts an unlimited number of keys. If you provide multiple keys,
    and only one works for the server, it will automatically use the one key that
    works.
  prefs: []
  type: TYPE_NORMAL
- en: This is useful if you want to use the same configuration to connect to a number
    of servers. You may want to connect to 1,000 different hosts using 1,000 unique
    private keys. Instead of having to create multiple SSH client configs, you can
    reuse a single config that contains all of the private keys.
  prefs: []
  type: TYPE_NORMAL
- en: Verifying remote host
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To verify the remote host, in `ssh.ClientConfig`, set `HostKeyCallback` to `ssh.FixedHostKey()`
    and pass it the public key of the remote host. If you attempt to connect to the
    server and it provides a different public key, the connection will be aborted.
    This is important for ensuring that you are connecting to the expected server
    and not a malicious server. If DNS is compromised, or an attacker performs a successful
    ARP spoof, it's possible that your connection will be redirected or will be a
    victim of the man-in-the-middle attack, but an attacker will not be able to imitate
    the real server without the corresponding private key for the server. For testing
    purposes, you may choose to ignore the key provided by the remote host.
  prefs: []
  type: TYPE_NORMAL
- en: This example is the most secure way to connect. It uses a key to authenticate,
    as opposed to a password, and it verifies the public key of the remote server.
  prefs: []
  type: TYPE_NORMAL
- en: This method will use `ssh.ParseKnownHosts()`. This uses the standard `known_hosts`
    file. The `known_hosts` format is the standard for OpenSSH. The format is documented
    in the *sshd(8)* manual page.
  prefs: []
  type: TYPE_NORMAL
- en: Note that Go's `ssh.ParseKnownHosts()` will only parse a single entry, so you
    should create a unique file with a single entry for the server or ensure that
    the desired entry is at the top of the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'To obtain the remote server''s public key for verification, use `ssh-keyscan`.
    This returns the server key in the `known_hosts` format that will be used in the
    following example. Remember, the Go `ssh.ParseKnownHosts` command only reads the
    first entry from a `known_hosts` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ssh-keyscan` program will return multiple key types unless a key type
    is specified with the `-t` flag. Make sure that you choose the one with the desired
    key algorithm and that `ssh.ClientConfig()` has `HostKeyAlgorithm` listed to match.
    This example includes every possible `ssh.KeyAlgo*` option. I recommend that you
    choose the highest-strength algorithm possible and only allow that option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note that, in addition to the `ssh.KeyAlgo*` constants, there are `ssh.CertAlgo*`
    constants if certificates are used.
  prefs: []
  type: TYPE_NORMAL
- en: Executing a command over SSH
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have established multiple ways of authenticating and connecting
    to a remote SSH server, we need to put `ssh.Client` to work. So far we have only
    been printing out the client version. The first goal is to execute a single command
    and view the output.
  prefs: []
  type: TYPE_NORMAL
- en: Once `ssh.Client` is created, you can begin creating sessions. A client supports
    multiple sessions at once. A session has its own standard input, output, and error.
    They are standard reader and writer interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'To execute a command there are a few options: `Run()`, `Start()`, `Output()`,
    and `CombinedOutput()`. They are all very similar, but behave a little differently:'
  prefs: []
  type: TYPE_NORMAL
- en: '`session.Output(cmd)`: The `Output()` function will execute the command, and
    return `session.Stdout` as a byte slice.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`session.CombinedOutput(cmd)`: This does the same as `Output()`, but it returns
    both standard output and standard error combined.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`session.Run(cmd)`: The `Run()` function will execute the command and wait
    for it to finish. It will fill the standard output and error buffers, but it won''t
    do anything with them. You have to manually read the buffers or set the session
    output to go to the Terminal output before calling `Run()` (for example, `session.Stdout
    = os.Stdout`). It will only return without an error if the program exited with
    an error code of `0` and there were no issues copying the standard output buffers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`session.Start(cmd)`: The `Start()` function is similar to `Run()`, except
    that it will not wait for the command to finish. You must explicitly call `session.Wait()`
    if you want to block execution until the command is complete. This is useful for
    starting long running commands or if you want more control over the application
    flow.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A session can only perform one action. Once you call `Run()`, `Output()`, `CombinedOutput()`,
    `Start()`, or `Shell()`, you can''t use the session for executing any other commands.
    If you need to run multiple commands, you can string them together separated with
    a semicolon. For example, you can pass multiple commands in a single command string
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Otherwise, you can create a new session for each command you need to run. One
    session equates to one command.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example connects to a remote SSH server using key authentication,
    and then it creates a session using `client.NewSession()`. The standard output
    from the session is then connected to our local Terminal standard output before
    calling `session.Run()`, which will execute the command on the remote server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Starting an interactive shell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous example, we demonstrated how to run command strings. There is
    also an option to open a shell. By calling `session.Shell()`, an interactive login
    shell is executed, loading whatever default shell the user has and loading the
    default profile (for example, `.profile`). The call to `session.RequestPty()`
    is optional, but the shell works much better when requesting a psuedoterminal.
    You can set the terminal name to `xterm`, `vt100`, `linux`, or something custom.
    If you have issues with jumbled output due to color values being output, try `vt100`,
    and if that still does not work, use a nonstandard terminal name or a terminal
    name you know does not support colors. Many programs will disable color output
    if they do not recognize the terminal name. Some programs will not work at all
    with an unknown terminal type, such as `tmux`.
  prefs: []
  type: TYPE_NORMAL
- en: More information about Go terminal mode constants is available at [https://godoc.org/golang.org/x/crypto/ssh#TerminalModes](https://godoc.org/golang.org/x/crypto/ssh#TerminalModes).
    Terminal mode flags are a POSIX standard and are defined in *RFC 4254*,* Encoding
    of Terminal Modes* (section 8), which you can find at [https://tools.ietf.org/html/rfc4254#section-8](https://tools.ietf.org/html/rfc4254#section-8).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example connects to an SSH server using key authentication, and
    then creates a new session with `client.NewSession()`. Instead of executing a
    command with `session.Run()` like the previous example, we will use `session.RequestPty()`
    to get an interactive shell. Standard input, output, and error streams from the
    remote session are all connected to the local Terminal, so you can interact with
    it in real time just like any other SSH client (for example, PuTTY):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After reading this chapter, you should now understand how to use the Go SSH
    client to connect and authenticate using a password or a private key. In addition,
    you should now understand how to execute a command on a remote server or how to
    begin an interactive session.
  prefs: []
  type: TYPE_NORMAL
- en: How would you apply an SSH client programmatically? Can you think of any use
    cases? Do you manage multiple remote servers? Could you automate any tasks?
  prefs: []
  type: TYPE_NORMAL
- en: The SSH package also contains types and functions for creating an SSH server,
    but we have not covered them in this book. Read more about creating an SSH server
    at [https://godoc.org/golang.org/x/crypto/ssh#NewServerConn](https://godoc.org/golang.org/x/crypto/ssh#NewServerConn)
    and more about the SSH package overall at [https://godoc.org/golang.org/x/crypto/ssh](https://godoc.org/golang.org/x/crypto/ssh).
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll look at brute force attacks, where passwords are
    guessed until eventually a correct password is found. Brute forcing is something
    we can do with the SSH client, as well as other protocols and applications. Continue
    reading the next chapter to learn how to execute a brute force attack.
  prefs: []
  type: TYPE_NORMAL
