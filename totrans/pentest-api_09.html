<html><head></head><body>
		<div><h1 id="_idParaDest-139" class="chapter-number"><a id="_idTextAnchor141"/>9</h1>
			<h1 id="_idParaDest-140"><a id="_idTextAnchor142"/>API Abuse and Business Logic Testing</h1>
			<p>With this chapter, we will finish the fourth part of our book. We just learned about <strong class="bold">data exposure</strong> and <strong class="bold">information leakage</strong>, which are unfortunately very common nowadays. It is also unfortunate that there are even more dangerous ways to break API protection controls. Abusing the right way of using endpoints is one of them. Exploiting the API logic is another fearsome one.</p>
			<p><strong class="bold">API abuse</strong> refers to the misuse of an API beyond its intended purpose, leading to security vulnerabilities, data breaches, or service disruptions. <strong class="bold">Business logic testing</strong> involves identifying vulnerabilities in the application’s business rules and workflows. This ensures that the application behaves as intended in all scenarios. Together, these tests help secure APIs against misuse and logical flaws.</p>
			<p>In this chapter, we will stay engaged with the advanced API topics, but we will learn why the business logic behind an API can impact the frequency and/or depth at which API endpoints are exploited. We will begin by dissecting what business logic is and how it may have vulnerabilities. Then, we will take a look at abuse scenarios, simulating environments where such logic can be explored in a bad way. Finally, using a method like the one we applied in <a href="B19657_08.xhtml#_idTextAnchor131"><em class="italic">Chapter 8</em></a>, we will search for vulnerabilities in business logic. I hope you enjoy this journey. Let’s go on it together!</p>
			<p>In this chapter, we’re going to cover the following main topics:</p>
			<ul>
				<li>Understanding business logic vulnerabilities</li>
				<li>Exploring API abuse scenarios</li>
				<li>Testing for business logic vulnerabilities</li>
			</ul>
			<h1 id="_idParaDest-141"><a id="_idTextAnchor143"/>Technical requirements</h1>
			<p>We’ll leverage the same environment as the one pointed out in previous chapters, such as an Ubuntu distro. Some other new relevant utilities will be mentioned in the corresponding sections.</p>
			<p>We will create more code in this chapter, which we’ll leverage to simulate and test some vulnerabilities, this time focused on business logic.</p>
			<h1 id="_idParaDest-142"><a id="_idTextAnchor144"/>Understanding business logic vulnerabilities</h1>
			<p>To understand what types of<a id="_idIndexMarker636"/> vulnerabilities may arise from the business logic behind API endpoints and their applications, we first have to understand what business logic is. Well, it is nothing other than several processes, rules, and workflows that define how data can be processed by software. To reach specific business objectives, the software needs to handle interactions with the users, as well as transactions and data handling. In other words, it’s the implementation of business specificities into code.</p>
			<p>Using web commerce as a common scenario, the business logic part of the application (that could also be represented by APIs and their endpoints) handles various tasks such as the maintenance of the shopping cart, the insertion of discount codes, all logistics activities (such as calculating shipping costs and estimated delivery time), and finally, the processing or transferring to a trusted third party of payments. The final purpose is to ensure that the application behaves as it was designed to, such that all phases are deterministic and not probabilistic. That’s a very important point to remember.</p>
			<p>If it is not yet obvious, you could ask why business logic is so important. Well, it does the following:</p>
			<ul>
				<li><strong class="bold">Maintains integrity and efficiency</strong>: It guarantees that the application operates smoothly and handles data with integrity.</li>
				<li><strong class="bold">Converts business rules</strong>: By following <a id="_idIndexMarker637"/>some methodologies, business policies and rules are translated into lines of code. This allows the application to perform tasks such as validating user input, enforcing security measures, managing data flow, and complying with regulations. Imagine a banking application – its business logic would enforce rules around transaction limits, account access, and fraud detection.</li>
				<li><strong class="bold">Automates processes</strong>: By encapsulating these rules within the application, businesses can automate complex tasks, reduce errors, and ensure consistent execution of business activities.</li>
				<li><strong class="bold">Impacts reliability and security</strong>: Robust business logic directly affects the software’s reliability, security, and ultimately, user satisfaction.</li>
			</ul>
			<p>In simple terms, business<a id="_idIndexMarker638"/> logic is the software’s rulebook, making sure it runs efficiently and fulfills the specific needs of the business it serves.</p>
			<p>Nice! Now that we have established some groundwork on the subject, we can talk about the vulnerabilities that may affect it. They can usually bypass traditional security measures such as firewalls and <strong class="bold">Intrusion Detection Systems</strong> (<strong class="bold">IDSs</strong>), and they are dangerous for the following <a id="_idIndexMarker639"/>reasons:</p>
			<ul>
				<li>Their target is the core business.</li>
				<li>They are difficult to detect and block.</li>
			</ul>
			<p>There are some methods to cause errors in business logic:</p>
			<ul>
				<li><strong class="bold">Workflow tampering</strong>: With this, we<a id="_idIndexMarker640"/> change the sequence of operations to overcome security protections or to obtain unauthorized access.</li>
				<li><strong class="bold">Validation bypass</strong>: With this, we look for ways to skip or manipulate some validations.</li>
				<li><strong class="bold">Inconsistent error handling</strong>: In this, we identify patterns in error messages that could possibly leak sensitive data or the API behavior.</li>
				<li><strong class="bold">Escalate privileges</strong>: In this, through the leverage of some failure in the API’s code or some system supporting it, we gain higher levels of access.</li>
				<li><strong class="bold">Concurrency issues</strong>: APIs that implement concurrency may be vulnerable to this, where we can exploit race conditions or failures in logic synchronization.</li>
				<li><strong class="bold">Manipulate transactions</strong>: Through this, we directly interfere with the logic’s operations to impose inconsistencies or to obtain some benefit, usually financial.</li>
			</ul>
			<p>There were some notable incidents that deserve mention to illustrate how API business logic’s vulnerabilities can cause devastating damage to companies. You will find links with more information about all of them in the <em class="italic">Further reading</em> section. In April 2021, an independent security researcher discovered a vulnerability in an API used by <strong class="bold">Experian</strong> to assess individuals’ creditworthiness. This API used minimal authentication information, making it easy to exploit. Attackers could retrieve sensitive personal data, including <strong class="bold">Fair Isaac Corporation</strong> (<strong class="bold">FICO</strong>) scores and <a id="_idIndexMarker641"/>credit risk factors, using easily obtainable public information. This incident highlighted the risks of weak authentication and excessive data exposure.</p>
			<p>In the same month and year, security <a id="_idIndexMarker642"/>researchers from the <strong class="bold">Sick Codes</strong> security firm uncovered vulnerabilities in John Deere’s APIs, which allowed them to access user accounts and sensitive data <a id="_idIndexMarker643"/>without authentication. John Deere is a global company that produces agricultural, construction, and forestry equipment and solutions. The researchers were able to identify customers of John Deere, including major Fortune 1,000 companies, and retrieve personal data associated with their equipment. The lack of rate limiting and authentication controls in these APIs posed significant security risks.</p>
			<p>In December 2021, hackers exploited a vulnerability in the X (which was still called Twitter at the time) API to access the personal data of over 5.4 million users. By submitting email addresses or phone numbers to the API, attackers could retrieve the associated accounts. This breach exposed usernames, phone numbers, and email addresses, significantly affecting user trust and confidence in X.</p>
			<p>Again in December 2021, FlexBooker, a social media scheduling platform, experienced an API breach that exposed 3.7 million user records. The breach, caused by vulnerabilities in their AWS configuration, led to the download of sensitive user data and system downtime. The breach stemmed from flaws in how FlexBooker configured its access controls on AWS, which can be seen as a business logic issue related to API security. The exposed user data resided within FlexBooker’s system, likely accessed through a compromised API. This incident underscores the importance of securing API endpoints and storage systems.</p>
			<p>In January 2022, the <strong class="bold">Texas Department of Insurance</strong> had an API endpoint publicly exposed (for nearly three years) due to a software error. This breach exposed 1.8 million records containing Social Security numbers, addresses, and other personal information. There were two problems: a vulnerable web application, and data that was exposed. This vulnerability resided within the application’s code, suggesting a problem with business logic implementation. Among the exposed data, there were names, Social Security numbers, addresses, dates of birth, and details of claims. The incident highlighted the importance of continuous monitoring and proper configuration of API endpoints to protect sensitive data.</p>
			<p>Now that we have covered what API business logic is and the problems that may be caused as part of API vulnerabilities, let’s learn how we can abuse APIs.</p>
			<h1 id="_idParaDest-143"><a id="_idTextAnchor145"/>Exploring API abuse scenarios</h1>
			<p>API abuse is related to the unexpected <a id="_idIndexMarker644"/>use of an API in a way that deviates from its intended purpose or project/design. This can naturally uncover security vulnerabilities, which in turn can cause data breaches and/or service interruptions. Some common ways of abusing an API include the following:</p>
			<ul>
				<li><strong class="bold">Credential stuffing</strong>: By using stolen credentials, access to the API is gained.</li>
				<li><strong class="bold">Data scraping</strong>: Consists of exfiltrating large volumes of data from an API, which usually violates terms of service or its privacy policies.</li>
				<li><strong class="bold">Endpoint discovery</strong>: It’s accomplished with the use of automation tools to discover and exploit “hidden” (forgotten or undocumented) API endpoints.</li>
				<li><strong class="bold">Mass assignment</strong>: You send unexpected data fields to the endpoint to manipulate internal object properties.</li>
				<li><strong class="bold">Parameter tampering</strong>: Consists of changing API parameters to be able to access data or features that would be denied or restricted by default.</li>
				<li><strong class="bold">Rate limiting violations</strong>: Done by exceeding the maximum number of allowed requests per unit of time, which usually leads to DoS attacks.</li>
			</ul>
			<p>We have theoretically and practically covered some of the aforementioned methods. Let’s dive deeper into the ones that are completely new. For each method, we will have a dummy API written in Python and the steps that you may follow to accomplish the attack.</p>
			<h2 id="_idParaDest-144"><a id="_idTextAnchor146"/>Credential stuffing</h2>
			<p>This is a universal type of <a id="_idIndexMarker645"/>attack whereby criminals use a large database of stolen <a id="_idIndexMarker646"/>or leaked credentials to attempt to gain unauthorized access to user accounts that are accessible via API endpoints. The main intent here is to leverage what many human beings do in their daily lives: reusing the same password throughout various systems and websites. Criminals make use of automated tools to help them speed up these attacks. It is possible to generate millions of attempts in short periods of time. This is not the same as brute force attacks, wherein you need to generate random passwords and sometimes usernames or read them from dictionary files, or even rainbow tables (when the targets are hashes). Credential stuffing does use actual usernames and passwords.</p>
			<p>The damage of such attacks is based on their capability to overcome basic security countermeasures. Once valid credentials pairs are presented, if the protection mechanisms are based only on password length and complexity, they can easily be bypassed. They are especially dangerous to applications that deal with sensitive data since even small breaches<a id="_idIndexMarker647"/> can cause severe damage to the company’s reputation.</p>
			<p>On the subject of <a id="_idIndexMarker648"/>reputation, credential stuffing also imposes a reasonable economic impact. Research from the <strong class="bold">Ponemon Institute</strong> (<a href="https://ag.ny.gov/publications/business-guide-credential-stuffing-attacks">https://ag.ny.gov/publications/business-guide-credential-stuffing-attacks</a>) concluded that the average cost of this type of attack is around USD $6 million, including the expenses of incident response, customer notification, compliance, and regulatory fines. That’s without accounting for reputation. This is enough to bankrupt many small companies. To mitigate such threats, robust security measures need to be applied such as <strong class="bold">Multi-Factor Authentication</strong> (<strong class="bold">MFA</strong>), <strong class="bold">User Entity and Behavior Analytics</strong> (<strong class="bold">UEBA</strong>), and anomaly <a id="_idIndexMarker649"/>detection (nowadays, this is usually<a id="_idIndexMarker650"/> implemented with a <strong class="bold">Machine Learning</strong> (<strong class="bold">ML</strong>) solution).</p>
			<h3>Creating the dummy target</h3>
			<p>Credential stuffing is usually<a id="_idIndexMarker651"/> implemented with automated tools, such as <strong class="bold">Sentry MBA</strong>, <strong class="bold">Snipr</strong>, or <strong class="bold">OpenBullet</strong>. We will apply <strong class="bold">OpenBullet 2</strong> (<a href="https://github.com/openbullet/OpenBullet2">https://github.com/openbullet/OpenBullet2</a>), a superset <a id="_idIndexMarker652"/>of the initial version, to implement our <a id="_idIndexMarker653"/>attack. For that<a id="_idIndexMarker654"/> sake, the following <a id="_idIndexMarker655"/>dummy API will be used as a target. This code is available at <a href="https://github.com/PacktPublishing/Pentesting-APIs/blob/main/chapters/chapter09/credential_stuffing/api_credential.py">https://github.com/PacktPublishing/Pentesting-APIs/blob/main/chapters/chapter09/credential_stuffing/api_credential.py</a>:</p>
			<pre class="source-code">
from flask import Flask, request, jsonify
from datetime import datetime, timedelta
from collections import defaultdict
import time
app = Flask(__name__)
users = {
    "user1": "password123",
    "user2": "password456",
}
login_attempts = defaultdict(list)
def is_rate_limited(user):
    now = datetime.now()
    window_start = now - timedelta(minutes=1)
    attempts = [ts for ts in login_attempts[user] if ts &gt; window_start]
    login_attempts[user] = attempts
    return len(attempts) &gt;= 5
@app.route('/login', methods=['POST'])
def login():
    data = request.get_json()
    username = data.get('username')
    password = data.get('password')
    if is_rate_limited(username):
        return jsonify({"message": "Rate limit! Try again later."}), 429
    if users.get(username) == password:
        login_attempts[username].clear()
        return jsonify({"message": "Login successful"}), 200
    else:
        login_attempts[username].append(datetime.now())
        return jsonify({"message": "Invalid credentials"}), 401
if __name__ == '__main__':
    app.run(debug=True)</pre>			<p>Observe that the API has a single endpoint, to deal with the login process. It also has a function that applies a basic rate-limiting control. When the number of failed attempts is greater than or equal to five in one minute, the request is denied. There are only two dummy users. As we did not actually steal any credentials, we will create a file with other dummy usernames <a id="_idIndexMarker656"/>and passwords, including the ones present in the API. The purpose here is just to show that this logic is vulnerable to credential stuffing.</p>
			<p>We will run this API as a Docker container since, as you’ll see next, our attack tool will also run like that. This is not exactly required. You could also run the Python code directly on your host system. However, to be able to access its 5000/TCP port from a container, you’d have to tweak the container’s network a bit, since this communication might not be allowed at first depending on the Docker version you are using. To keep it safe, it’s easier to simply run both software as containers. If you don’t specify anything different while starting up the container or in its <code>Dockerfile</code>, they will both share the same Docker network (the <code>bridge</code> one):</p>
			<pre class="console">
$ docker network list
NETWORK ID     NAME      DRIVER    SCOPE
d8dd035a66bd   bridge    bridge    local
19ba2bd53bfd   host      host      local
821848b3ff50   none      null      local</pre>			<p>Great! So, to run this Python code as a Docker container, we need a <code>Dockerfile</code> file. The following content is just a suggestion. You are free to use any other container image that includes Python. I just recommend that you choose a light one to keep it small. For your convenience, this Dockerfile can be downloaded from <a href="https://github.com/PacktPublishing/Pentesting-APIs/blob/main/chapters/chapter09/credential_stuffing/Dockerfile">https://github.com/PacktPublishing/Pentesting-APIs/blob/main/chapters/chapter09/credential_stuffing/Dockerfile</a>:</p>
			<pre class="source-code">
FROM python:3.9-slim-buster
WORKDIR /app
COPY ./requirements.txt /app
RUN pip install -r requirements.txt
COPY . .
EXPOSE 5000
ENV FLASK_APP=api_credential.py
CMD ["flask", "run", "--host", "0.0.0.0"]</pre>			<p>The <code>requirements.txt</code> file that’s mentioned twice is a single-line file containing only <code>Flask</code>. I’m not sure <a id="_idIndexMarker657"/>about your Docker knowledge. So, let me give you a brief explanation here. This Dockerfile will expose <code>port 5000</code> (enabling other containers and the host itself to connect to it through this port), install Flask, and copy all of the current directory’s contents (including the <code>api_credential.py</code> Python file itself) to the container’s current directory (which is <code>/app</code>). Then, it will run the application. To put this container to work, type the following commands:</p>
			<pre class="console">
$ docker build -t api .
$ docker run -p 5000:5000 --name credential_api api</pre>			<p>The first command parses the <code>Dockerfile</code>, downloads the specified image, tags it as <code>api</code>, and follows the rest of the contents to finish building such an image. The second command effectively runs the container by mapping the host’s <code>port 5000</code> to the container’s <code>port 5000</code>, naming it <code>credential_api</code>, and picking the previously built <code>api</code> image. Now we are good to move to the attack tool.</p>
			<h3>Setting up OpenBullet2</h3>
			<p>OpenBullet2 has a native<a id="_idIndexMarker658"/> client for Windows. As we are not using this operating system, we will go with the other option: the web client. There is more than one path to install this second way. You can first install Microsoft’s .NET runtime environment, download OpenBullet2 (which includes Windows’ DLL files), and then use .NET to run it. This may impose some difficulties depending on the system you are using. On Ubuntu, I personally prefer to take the Docker approach. You just need to create a directory that the container will use to store configurations and attacks’ captured data, and then run the following command (which is in the product’s documentation):</p>
			<pre class="console">
$ docker run --name openbullet2 --rm -p 8069:5000 \
-v ./UserData/:/app/UserData/ \
-it openbullet/openbullet2:latest</pre>			<p>In this case, I specified a local <code>UserData</code> directory under my current directory that will be mounted on the container as <code>/app/UserData</code> volume (the <code>-v</code> option means volume). This command names the container <code>openbullet2</code> (<code>--name</code>) and runs it in interactive mode (<code>-it</code>), which is good to allow you to watch eventual log messages. The container listens on port 5000, which is mapped to the host’s port 8069. The container will be removed after you<a id="_idIndexMarker659"/> close it (<code>--rm</code>). Just open <code>http://localhost:8069</code> on your preferred browser, and you will see the utility’s interface (<em class="italic">Figure 9</em><em class="italic">.1</em>).</p>
			<div><div><img src="img/B19657_figure_09.01.jpg" alt="Figure 9.1 – OpenBullet2’s initial screen"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.1 – OpenBullet2’s initial screen</p>
			<p class="callout-heading">Note</p>
			<p class="callout">While conducting the tests with OpenBullet2, I wasted a reasonable amount of time trying to understand why my attacks were not working. I’m not sure whether it was some bug with the version I used. The truth is that the following helped me fix it and put the utility to work as expected. You are good to skip this note and keep reading the rest of the section, but if at some stage you face errors such as <code>UserData</code> local directory. You’ll realize that the tool creates several files and directories. The only one that’s important at this moment is <code>Environment.ini</code>. Check its permissions and grant write permission if it doesn’t have it yet. Edit it and change the <code>WORDLIST TYPE</code> Default block to look like this:</p>
			<pre class="source-code">
[WORDLIST TYPE]
Name=Default
Regex=^.*$
Verify=False
Separator=:
Slices=USERNAME,PASSWORD</pre>			<p>What we are doing here is instructing OpenBullet2 to use a colon (<code>:</code>) as a field separator, as well as to name the left part of such a colon <code>USERNAME</code> and the right part <code>PASSWORD</code>. This shouldn’t be <a id="_idIndexMarker660"/>the case, but it made a tremendous change to my environment. Save the file and run the container again as you did the first time. Now continue reading.</p>
			<p>When you click on the flag, other flags and languages are presented. When this chapter was being written, a total of twelve languages were available! After clicking on your preferred language/flag, the license will be presented, and you just need to accept it. Also, the first time the application is running, an initial setup is necessary (<em class="italic">Figure 9</em><em class="italic">.2</em>).</p>
			<div><div><img src="img/B19657_figure_09.02.jpg" alt="Figure 9.2 – The initial setup"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.2 – The initial setup</p>
			<p>We are setting it up to run locally. Then, just click on the corresponding button. You also have the option to set OpenBullet2 to run on a remote host. After selecting the option, the setup will be finished. You will see the dashboard, which shows an interesting number of options and <a id="_idIndexMarker661"/>general usage statistics, including CPU, memory, and network consumption. Do not waste too much time on the screen shown in <em class="italic">Figure 9</em><em class="italic">.2</em>, as we must focus on the attack.</p>
			<h3>Creating a configuration and attacking</h3>
			<p>We will start the attack by creating a <a id="_idIndexMarker662"/>configuration. Follow this sequence:</p>
			<ol>
				<li>Click on <strong class="bold">Configs</strong> on the left pane bar.</li>
				<li>On the new screen, click on <strong class="bold">New</strong>.<p class="list-inset">This will take you to a form where you can enter some metadata such as the config’s author, its name, and a graphical image located in a file or URL. This is the metadata part of the configuration. The other options are <strong class="bold">Readme</strong>, <strong class="bold">Stacker</strong>, <strong class="bold">LoliCode</strong>, <strong class="bold">Settings</strong>, and <strong class="bold">C# Code</strong>. It’s important to note that you can put C# code as part of the configuration. It will be executed by OpenBullet2 as part of the attack. When starting, the application logs a warning message to notify you that you shouldn’t run it as administrator or root due to the fact that binary code will be executed, and such code can bypass your host system’s security controls. <em class="italic">Figure 9</em><em class="italic">.3</em> shows OpenBullet2’s dashboard.</p></li>
			</ol>
			<div><div><img src="img/B19657_figure_09.03.jpg" alt="Figure 9.3 – The OpenBullet2 dashboard Screen"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.3 – The OpenBullet2 dashboard Screen</p>
			<p class="list-inset">The next figure <a id="_idIndexMarker663"/>shows the config’s metadata screen.</p>
			<div><div><img src="img/B19657_figure_09.04.jpg" alt="Figure 9.4 – The metadata part of the configuration"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.4 – The metadata part of the configuration</p>
			<ol>
				<li value="3">Just write a name for the configuration itself and an author name. Leave the rest as its defaults. <em class="italic">Figure 9</em><em class="italic">.5</em> shows the warning message when you start the application.</li>
			</ol>
			<div><div><img src="img/B19657_figure_09.05.jpg" alt="Figure 9.5 – The startup warning message"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.5 – The startup warning message</p>
			<ol>
				<li value="4">Before continuing with the configuration, we need to recall that both OpenBullet2 and the API are running as containers. This means that they have received IP addresses belonging to Docker’s bridge network. The IP segment may change<a id="_idIndexMarker664"/> according to the Docker engine version and the system you are running, so you need to check which addresses were assigned to them. The host usually picks the first address of the block. In my case, which looks like this:<pre class="source-code">
<strong class="bold">$ ifconfig docker0</strong>
<strong class="bold">docker0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</strong>
<strong class="bold">inet 172.17.0.1  netmask 255.255.0.0  broadcast 172.17.255.255</strong>
<strong class="bold">inet6 fe80::42:a2ff:fe20:673e  prefixlen 64  scopeid 0x20&lt;link&gt;</strong>
<strong class="bold">ether 02:42:a2:20:67:3e  txqueuelen 0  (Ethernet)</strong>
<strong class="bold">RX packets 0  bytes 0 (0.0 B)</strong>
<strong class="bold">RX errors 0  dropped 0  overruns 0  frame 0</strong>
<strong class="bold">TX packets 36  bytes 4857 (4.8 KB)</strong>
<code>172.17.0.1</code>. Containers will be allocated the subsequent addresses in the order in which they come up. I will presume that the API has <code>172.17.0.2</code>, as it was the first container to be started. Let’s confirm that:</p><pre class="source-code"><strong class="bold">$ docker inspect -f \</strong>
<strong class="bold">'{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' credential_api</strong>
<code>172.17.0.3</code>). Let’s get back to our process.</p></li>				<li>If you want to create some text to describe what it is about, which is useful when more people<a id="_idIndexMarker665"/> are using the same instance, you can go to the <strong class="bold">Readme</strong> section and write some instructions there. Now click on <strong class="bold">Stacker</strong>. There, we can tell OpenBullet2 how the attack must be carried out. You will see that the stack is currently empty.</li>
				<li>Click on the green plus sign to create a new stack config. This will open the <strong class="bold">Add </strong><strong class="bold">block</strong> window.</li>
				<li>Click on <strong class="bold">Requests</strong> | <strong class="bold">Http</strong> | <strong class="bold">Http Request</strong> (<em class="italic">Figure 9</em><em class="italic">.6</em>).</li>
			</ol>
			<div><div><img src="img/B19657_figure_09.06.jpg" alt="Figure 9.6 – Inserting an HTTP request block to the stack config"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.6 – Inserting an HTTP request block to the stack config</p>
			<p>You are back to the stack config screen where all of the request’s details can be edited. We’ll have to change the following:</p>
			<ol>
				<li>Set <code>URL</code> to <code>http://172.17.0.2:5000/login</code> (recall that the API’s endpoint is <code>/login</code>).</li>
				<li>Change the <code>POST</code>.</li>
				<li>Under <code>Content-Type: application/json</code>.</li>
				<li>Under <strong class="bold">Content</strong>, type what you want to send as the request’s body. It will consist of a simple<a id="_idIndexMarker666"/> JSON structure:<pre class="source-code">
{"username": "&lt;input.USERNAME&gt;", "password": "&lt;input.PASSWORD&gt;"}</pre></li>				<li>The <code>&lt;input.USERNAME&gt;</code> and <code>&lt;input.PASSWORD&gt;</code> parts will be replaced by lines in the <code>credentials.txt</code> file that we will create later.</li>
			</ol>
			<p>When reading a wordlist (you’ll see this later on), OpenBullet2 will iteratively pick each line of the <code>credentials.txt</code> file and consider the left part of the colon as <code>input.USERNAME</code> and the right part as <code>input.PASSWORD</code>. The dynamically built JSON string will then be sent to the API endpoint as login information. This will provide you with something like <em class="italic">Figure 9</em><em class="italic">.7</em>.</p>
			<div><div><img src="img/B19657_figure_09.07.jpg" alt="Figure 9.7 – Configuring the attack HTTP request"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.7 – Configuring the attack HTTP request</p>
			<p>We must analyze what the API is sending us as a response. Hence, we need to add another block. Click on the green plus sign again to add a new block. You won’t see it at first. Type <strong class="bold">key</strong> into the search bar and press <strong class="bold">Search</strong>. Select the <strong class="bold">Keycheck</strong> block (<em class="italic">Figure 9</em><em class="italic">.8</em>).</p>
			<div><div><img src="img/B19657_figure_09.08.jpg" alt="Figure 9.8 – Adding a Keycheck control block"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.8 – Adding a Keycheck control block</p>
			<p>You will be sent back to the stack config screen. Do this to finish the request config:</p>
			<ol>
				<li>Click on the other <a id="_idIndexMarker667"/>green plus sign that is available under the <strong class="bold">Keychains:</strong> string.</li>
				<li>Make sure that <strong class="bold">Result Status</strong> is set as <strong class="bold">SUCCESS</strong>.</li>
				<li>Click on the <strong class="bold">+String</strong> button. This will open a few text boxes.</li>
				<li>Select <strong class="bold">Contains</strong> on the combo box and type <strong class="bold">Login successful</strong> in the textbox right beside it.</li>
				<li>Repeat <em class="italic">steps 1</em> to <em class="italic">4</em> but with the following changes:<ul><li>For <code>Invalid credentials</code>.</li></ul><p class="list-inset">You will see something like <em class="italic">Figure 9</em><em class="italic">.9</em>.</p></li>
			</ol>
			<div><div><img src="img/B19657_figure_09.09.jpg" alt="Figure 9.9 – Configuring the expected successful and failed responses."/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.9 – Configuring the expected successful and failed responses.</p>
			<ol>
				<li value="6">Save the config using the <code>credentials.txt</code> and insert the following contents. For your convenience, this file can be downloaded from <a href="https://github.com/PacktPublishing/Pentesting-APIs/blob/main/chapters/chapter09/credential_stuffing/credentials.txt">https://github.com/PacktPublishing/Pentesting-APIs/blob/main/chapters/chapter09/credential_stuffing/credentials.txt</a>:<pre class="source-code">
userABC:mypassword
userDEF:du0CJB8Q
user1:password123
simple_user:EN3SZAbR
user2:password456</pre></li>			</ol>
			<p>We will put actual credentials that, in our case, are hardcoded into the API’s application among other useless values. Back to<a id="_idIndexMarker669"/> the utility’s interface, do the following:</p>
			<ol>
				<li>Click on <strong class="bold">Wordlists</strong> on the left pane.</li>
				<li>On this new screen, click on <strong class="bold">+Add</strong>. This will open a new window.</li>
				<li>Change <strong class="bold">My Wordlist</strong> to <strong class="bold">Credentials</strong>.</li>
				<li>Click on the <code>credentials.txt</code> file.</li>
				<li>Click on the <strong class="bold">Upload</strong> button.</li>
				<li>Your wordlist-adding screen will look like <em class="italic">Figure 9</em><em class="italic">.10</em>.</li>
			</ol>
			<div><div><img src="img/B19657_figure_09.10.jpg" alt="Figure 9.10 – Adding a wordlist"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.10 – Adding a wordlist</p>
			<ol>
				<li value="7">You will be taken back to the wordlists screen, and you’ll see the one you just added with the number of parsed lines (five). The next step we need to follow is to create a job to combine the configuration and the wordlist to actually send packets to the API. Click on <strong class="bold">Jobs</strong> on the left pane. On this screen, click on the green <strong class="bold">+New</strong> button to add a job. Click on the <strong class="bold">Multi Run</strong> button. At this stage, it’s important for you to know that you can leverage proxy serves to split the requests. OpenBullet2 comes with an empty <strong class="bold">Default</strong> proxy group. You can go to the <strong class="bold">Proxies</strong> area and either <a id="_idIndexMarker670"/>manually add their URLs or import them, either via URLs or text files. We won’t use proxies in our example.</li>
				<li>Click on the <strong class="bold">Select Config</strong> button. This will open a window showing all configs you have saved. As we only save the one we just created, click on it and push <strong class="bold">Select</strong> (<em class="italic">Figure 9</em><em class="italic">.11</em>).</li>
			</ol>
			<div><div><img src="img/B19657_figure_09.11.jpg" alt="Figure 9.11 – Selecting the config to be part of the job"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.11 – Selecting the config to be part of the job</p>
			<ol>
				<li value="9">After selecting it, you will be back to the job definition screen that’s now updated with the selected config. Click on the <strong class="bold">Select wordlist</strong> button located on the right of this screen. This will open another window will all the saved wordlists you have. As you have only added a single wordlist, it will be the only one showing up. Observe that, once you select the wordlist you’d like to add to the job, its contents will be displayed on the bottom part of this window. This is good to do a final visual check and attest whether they are as expected. Click on the green <strong class="bold">Select</strong> button (<em class="italic">Figure 9</em><em class="italic">.12</em>).</li>
			</ol>
			<div><div><img src="img/B19657_figure_09.12.jpg" alt="Figure 9.12 – Adding a wordlist to the job"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.12 – Adding a wordlist to the job</p>
			<ol>
				<li value="10">We are back to the job definition screen. Scroll down the screen a little bit until you see the green <strong class="bold">Create Job</strong> button. Push it. If you have done something wrong with the job, you can <a id="_idIndexMarker671"/>change the job definition by clicking on the corresponding button. Otherwise, you can shoot the job with the <strong class="bold">Start</strong> button. Do it! As our wordlist is small and we are running everything locally, the job will finish quickly. All valid credentials (<strong class="bold">Hits</strong>) are located under the control buttons. <strong class="bold">Fails</strong> and skipped lines also have their stats lines (<em class="italic">Figure 9</em><em class="italic">.13</em>).</li>
			</ol>
			<div><div><img src="img/B19657_figure_09.13.jpg" alt="Figure 9.13 – The results after running an attack job; valid credentials are shown in green"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.13 – The results after running an attack job; valid credentials are shown in green</p>
			<p>Now that this lab is complete, let’s learn<a id="_idIndexMarker672"/> more about other important topics.</p>
			<h3>Other features and security recommendations</h3>
			<p>OpenBullet2 has many other features that can be useful depending on the pentesting scenario you are facing. It suffered a revamp since the initial version and now has the web client option, which is quite handy when the testing system is not Windows. By the way, OpenBullet was initially designed and built as a .NET application.</p>
			<p>To get protected against credential stuffing, APIs should apply MFA. Rate limiting adds another protection layer since it reduces the impact of automated tools (such as OpenBullet2) carrying out too many login attempts in a specific timeframe. Finally, anomaly detection solutions, especially nowadays with the rich feature sets enabled by <strong class="bold">Artificial Intelligence</strong> (<strong class="bold">AI</strong>) and ML, are<a id="_idIndexMarker673"/> worth considering because they can track and analyze multiple different types of evidence at the same time, such as unusual login patterns, multiple failures from different geographic locations (something that can occur when you apply proxies), and notification of sysadmins based on some thresholds. In the next section, we will explore data scraping.</p>
			<h2 id="_idParaDest-145"><a id="_idTextAnchor147"/>Data scraping</h2>
			<p>Data scraping consists of extracting data from websites or APIs in an automated way, usually without proper authorization. It’s not always criminal though. You can be conducting research and <a id="_idIndexMarker674"/>need to aggregate publicly available data; this is legitimate. Nonetheless, it <a id="_idIndexMarker675"/>becomes a real problem when the target is private or sensitive data. APIs handling data exchanges between multiple systems may be particularly vulnerable to this threat since they can expose structured data using machine-readable formats, which makes the automated extraction even easier. With the large adoption of APIs, a part of which is driven by cloud providers, the attack surface has dramatically increased.</p>
			<p>Pentesters apply several tools and techniques to achieve success with this. The tools can vary from simple code written in <a id="_idIndexMarker676"/>Python or <strong class="bold">Golang</strong> to more sophisticated frameworks such as Scrapy, which we will exemplify in this section. Scrapy can handle very large data <a id="_idIndexMarker677"/>masses at once. Another notable example is <strong class="bold">Selenium</strong>, which is normally used to scrape dynamic content rendered by client-side JavaScript. The behavior is pretty much the same: these tools send requests to the API endpoints simulating human beings. These tools can be configured to adapt to different specificities presented by some endpoints, such as pagination, tokenization, rate limiting, and more. Being as adaptable and as human as this makes it easier for such tools to bypass some security countermeasures. One common evasion technique is switching source IP addresses (which can be accomplished with botnets) or employing proxy servers.</p>
			<p>Unauthorized data scraping<a id="_idIndexMarker678"/> can be extremely damaging for companies and organizations. They can lead to sensitive data thefts and/or leaks. Things such as user profiles, private datasets, financial records, intellectual property information, health records, or scholarly history<a id="_idIndexMarker679"/> are some examples of possible targets. Aside from financial and reputational damage, enterprises and their representatives can face legal outcomes, depending on the proportion of the leak and the nature of the leaked data. This can include trials and even imprisonment.</p>
			<p>In the next sub-sections, you’ll create and run a dummy target API and write some code to attack it.</p>
			<h3>Raising the dummy target</h3>
			<p>To practice data scraping, we will <a id="_idIndexMarker680"/>use the following GraphQL dummy API as a target. For your convenience, this code can be downloaded from <a href="https://github.com/PacktPublishing/Pentesting-APIs/blob/main/chapters/chapter09/data_scraping/api_scraping.py">https://github.com/PacktPublishing/Pentesting-APIs/blob/main/chapters/chapter09/data_scraping/api_scraping.py</a>:</p>
			<pre class="source-code">
from flask import Flask, request, jsonify
from flask_graphql import GraphQLView
import graphene
from flask_jwt_extended import JWTManager, create_access_token, jwt_required
app = Flask(__name__)
app.config['JWT_SECRET_KEY'] = 'Token_Secret_Key'
jwt = JWTManager(app)
class User(graphene.ObjectType):
    id = graphene.ID()
    name = graphene.String()
    email = graphene.String()
class Query(graphene.ObjectType):
    users = graphene.List(User)
    @jwt_required()
    def resolve_users(self, info):
        return [
            User(id=1, name="Alice", email="alice@example.com"),
            User(id=2, name="Bob", email="bob@example.com"),
            User(id=3, name="Charlie", email="charlie@example.com"),
        ]
class Mutation(graphene.ObjectType):
    login = graphene.Field(graphene.String, username=graphene.String(),
            password=graphene.String())
    def resolve_login(self, info, username, password):
        if username == "admin" and password == "password":
            return create_access_token(identity=username)
        return None
schema = graphene.Schema(query=Query, mutation=Mutation)
app.add_url_rule(
    '/graphql',
    view_func=GraphQLView.as_view(
        'graphql',
        schema=schema,
        graphiql=True,
    )
)
if __name__ == '__main__':
    app.run(debug=True)</pre>			<p>Observe that the API establishes a basic authentication mechanism through a pair of credentials (<code>admin</code> and <code>password</code>). When they are successfully sent by the client, a JWT is created and sent back. The only available endpoint (<code>/graphql</code>) only works when a valid JWT is presented <a id="_idIndexMarker681"/>by the client (enforced by the <code>@jwt_required()</code> decorator). The data itself is the user database. It’s our target.</p>
			<p>To run the code, you’ll need to install a few other Python modules. To be safe, simply type the following:</p>
			<pre class="console">
$ pip install Flask Flask-GraphQL graphene Flask-JWT-Extended</pre>			<p>You are good to put the API to run. Now, let’s focus on the attacking code.</p>
			<h3>Putting the attack to work</h3>
			<p>First, you must install <a id="_idIndexMarker682"/>Scrapy with <code>pip</code>. Then, create a project and enter its directory with the following commands:</p>
			<pre class="console">
$ scrapy startproject graphqlscraper
$ cd graphqlscraper</pre>			<p>Since we need to authenticate first, part of the code is dedicated to performing multiple authentication attempts until a valid credential pair is found. There’s a class named <code>BruteForcespider</code>. Everything starts with the <code>start_requests()</code> method. This is specified by Scrapy’s spider definition (which will be explained later on), and it iterates through the hardcoded credential pairs. Every time a request is sent, the code calls the <code>parse_login()</code> method to analyze the result. When the token is present in a result, it means that the authentication was successful. So, the code executes the GraphQL query to request the user database. Finally, the <code>parse_users()</code> method is invoked to print the gathered data. The <code>bruteforce_spider.py</code> code can be found at <a href="https://github.com/PacktPublishing/Pentesting-APIs/blob/main/chapters/chapter09/data_scraping/bruteforce_spider.py">https://github.com/PacktPublishing/Pentesting-APIs/blob/main/chapters/chapter09/data_scraping/bruteforce_spider.py</a>.</p>
			<p>Before we can run the code, we must create a Scrapy project. This is accomplished with the following:</p>
			<pre class="console">
$ scrapy startproject graphqlscraper</pre>			<p>When created, the <code>graphqlscraper</code> project is<a id="_idIndexMarker683"/> represented by a directory where several other files are inserted as well:</p>
			<pre class="console">
$ ls -lRhap
.:
total 16K
drwxrwxr-x 3 mauricio mauricio 4.0K May 22 22:22 ./
drwxrwxr-x 3 mauricio mauricio 4.0K May 22 22:29 ../
drwxrwxr-x 4 mauricio mauricio 4.0K May 22 22:24 graphqlscraper/
-rw-rw-r-- 1 mauricio mauricio  271 May 22 22:22 scrapy.cfg
./graphqlscraper:
total 32K
drwxrwxr-x 4 mauricio mauricio 4.0K May 22 22:24 ./
drwxrwxr-x 3 mauricio mauricio 4.0K May 22 22:22 ../
-rw-rw-r-- 1 mauricio mauricio    0 May 22 22:19 __init__.py
-rw-rw-r-- 1 mauricio mauricio  270 May 22 22:22 items.py
-rw-rw-r-- 1 mauricio mauricio 3.6K May 22 22:22 middlewares.py
-rw-rw-r-- 1 mauricio mauricio  368 May 22 22:22 pipelines.py
-rw-rw-r-- 1 mauricio mauricio 3.3K May 22 22:22 settings.py
drwxrwxr-x 3 mauricio mauricio 4.0K May 22 22:35 spiders/
./graphqlscraper/spiders:
total 28K
drwxrwxr-x 3 mauricio mauricio 4.0K May 22 22:35 ./
drwxrwxr-x 4 mauricio mauricio 4.0K May 22 22:24 ../
-rw-rw-r-- 1 mauricio mauricio 2.1K May 22 22:35 bruteforce_spider.py
-rw-rw-r-- 1 mauricio mauricio  161 May 22 22:19 __init__.py</pre>			<p>The code is located inside the <code>spiders</code> subdirectory. To run it, type the following:</p>
			<pre class="console">
$ scrapy crawl bruteforce_spider -o users.json</pre>			<p>This instructs Scrapy to start a crawler whose class can be found inside the <code>bruteforce_spider.py</code> file. The<a id="_idIndexMarker684"/> output is sent to <code>users.json</code>. After a few seconds, you should receive the chatty output of Scrapy:</p>
			<pre class="console">
$ scrapy crawl bruteforce_spider -o users.json
2024-05-22 22:36:05 [scrapy.utils.log] INFO: Scrapy 2.11.2 started (bot: graphqlscraper)
2024-05-22 22:36:05 [scrapy.utils.log] INFO: Versions: lxml 5.2.2.0, libxml2 2.12.6, cssselect 1.2.0, parsel 1.9.1, w3lib 2.1.2, Twisted 24.3.0, Python 3.10.12 (main, Nov 20 2023, 15:14:05) [GCC 11.4.0], pyOpenSSL 24.1.0 (OpenSSL 3.2.1 30 Jan 2024), cryptography 42.0.7, Platform Linux-5.15.0-107-generic-aarch64-with-glibc2.35
2024-05-22 22:36:05 [asyncio] DEBUG: Using selector: EpollSelector
2024-05-22 22:36:05 [scrapy.utils.log] DEBUG: Using reactor: twisted.internet.asyncioreactor.AsyncioSelectorReactor
<strong class="bold">…Output omitted for brevity…</strong>
2024-05-22 22:36:05 [scrapy.utils.log] DEBUG: Using asyncio event loop:
{'ID': '1', 'Name': 'Alice', 'Email': 'alice@example.com'}
2024-05-22 22:36:05 [scrapy.core.scraper] DEBUG: Scraped from &lt;200 http://127.0.0.1:5000/graphql&gt;
{'ID': '2', 'Name': 'Bob', 'Email': 'bob@example.com'}
2024-05-22 22:36:05 [scrapy.core.scraper] DEBUG: Scraped from &lt;200 http://127.0.0.1:5000/graphql&gt;
{'ID': '3', 'Name': 'Charlie', 'Email': 'charlie@example.com'}
2024-05-22 22:36:05 [scrapy.core.engine] INFO: Closing spider (finished)
2024-05-22 22:36:05 [scrapy.extensions.feedexport] INFO: Stored json feed (3 items) in: users.json
2024-05-22 22:36:05 [scrapy.statscollectors] INFO: Dumping Scrapy stats:
<code>INFO: Stored json feed (3 items) in: users.json</code>. Now<a id="_idIndexMarker685"/> check this file:</p>
			<pre class="console">
$ more graphqlscraper/spiders/users.json
[
{"ID": "1", "Name": "Alice", "Email": "alice@example.com"},
{"ID": "2", "Name": "Bob", "Email": "bob@example.com"},
{"ID": "3", "Name": "Charlie", "Email": "charlie@example.com"}
]</pre>			<p>That’s it. Mission accomplished. Scrapy is a very powerful framework with lots of new features. You should definitely invest some time into looking at its documentation. I shared the official website in the <em class="italic">Further reading</em> section. Next, we will learn what <strong class="bold">parameter tampering</strong> is about.</p>
			<h2 id="_idParaDest-146"><a id="_idTextAnchor148"/>Parameter tampering</h2>
			<p>This technique consists of deliberately<a id="_idIndexMarker686"/> manipulating the parameters exchanged between the client and server with the intent to alter the application’s behavior. The final objective could be to gain unauthorized data access, escalate privileges, or cause damage to data (such as temporary or permanent corruption). The core of the attack lies in exploiting the trust the<a id="_idIndexMarker687"/> API endpoint has in the parameters provided as part of the requests. A dangerous approach is putting too much trust on the client-side security controls. When running as JavaScript code or hidden form fields, for example, our API endpoints will likely be vulnerable to this threat.</p>
			<p>Any acceptable parameter, such as query parameters (including GraphQL), form fields, cookies, headers, and JSON structures, can be used to perpetrate this type of attack. A simple scenario could involve changing the user ID on a request header trying to access another user’s data or changing an exam grade on a school’s student system. Without proper validation, any supplied parameter, including the ones that are incorrectly formatted, could be an attack vector toward the API endpoint. APIs that are vulnerable to business logic attacks are also particularly vulnerable to this type of threat.</p>
			<p>This sort of pentesting usually involves a few steps. You need to do some reconnaissance in the sense of identifying which methods, verbs, and parameters are accepted by the API endpoints (supposing that they are not explicitly documented). Tools such as <strong class="bold">Burp Suite</strong>, <strong class="bold">OWASP ZAP</strong>, and <strong class="bold">Postman</strong> will be some of your best friends. You can still achieve<a id="_idIndexMarker688"/> reasonable results with Python code or some shell <a id="_idIndexMarker689"/>scripting. This comparison is <a id="_idIndexMarker690"/>not strictly appropriate, but we can establish a quick analogy with the work we’ve done tampering JWTs in <a href="B19657_04.xhtml#_idTextAnchor056"><em class="italic">Chapter 4</em></a>, <em class="italic">Authentication and Authorization Testing</em>. We analyzed which types of tokens were being handled by the API target and changed them in an attempt to deceive the backend.</p>
			<p>In 2021, Microsoft released several vulnerabilities affecting its mail product (Exchange). They were consolidated under the <strong class="bold">CVE-2021-26855</strong>. They consisted of implementing <strong class="bold">Server-Side Request Forgery</strong> (<strong class="bold">SSRF</strong>) attacks by tampering with some parameters before sending them to the HTTP/HTTPS listening endpoints. The vulnerability led to <strong class="bold">Remote Code Execution</strong> (<strong class="bold">RCE</strong>) on the affected Exchange servers.</p>
			<p>Yet in 2021, <strong class="bold">Ghost CMS</strong>, an open source publishing platform, was affected by a parameter tampering vulnerability. Identified as <strong class="bold">CVE 2021-201315</strong>, this vulnerability allowed <strong class="bold">crackers</strong> to change some query parameters, which resulted in authentication and authorization bypassing. In the end, criminals were able to access the admin interface, which created possibilities for inserting any type of malicious code.</p>
			<p>We will use the <code>api_tampering.py</code> file as the target. As usual, you need to install Flask. The code can be found at <a href="https://github.com/PacktPublishing/Pentesting-APIs/blob/main/chapters/chapter09/parameter_tampering/api_tampering.py">https://github.com/PacktPublishing/Pentesting-APIs/blob/main/chapters/chapter09/parameter_tampering/api_tampering.py</a>:</p>
			<ol>
				<li>Put the API to run. As usual, it’s listening <a id="_idIndexMarker691"/>on port 5000. We’ll carry out three different attacks. First, let’s try to escalate privileges by changing a user role. The <code>/user</code> endpoint gives us user data:<pre class="source-code">
<strong class="bold">$ curl http://localhost:5000/api/user/1</strong>
<strong class="bold">{</strong>
<strong class="bold">  "id": 1,</strong>
<strong class="bold">  "name": "Alice",</strong>
<strong class="bold">  "email": "alice@example.com",</strong>
<strong class="bold">  "role": "user"</strong>
<code>admin_secret</code>) password to provide special access, we can manipulate the <code>role</code> parameter with a single request in Python and make <em class="italic">Alice</em> an administrator (this code can be downloaded from <a href="https://github.com/PacktPublishing/Pentesting-APIs/blob/main/chapters/chapter09/parameter_tampering/manipulate_role.py">https://github.com/PacktPublishing/Pentesting-APIs/blob/main/chapters/chapter09/parameter_tampering/manipulate_role.py</a>):<pre class="source-code">
import requests
data = {
    'user_id': '1',
    'role': 'admin',
    'auth': 'admin_secret'
}
response = requests.post('http://localhost:5000/api/admin/change_role', data=data)
print(response.json())</pre></li>				<li>This results in the<a id="_idIndexMarker692"/> following:<pre class="source-code">
{
  "message": "User role updated"
}</pre></li>				<li>Confirm that the tampering actually worked:<pre class="source-code">
<strong class="bold">$ curl http://localhost:5000/api/user/1</strong>
<strong class="bold">{</strong>
<strong class="bold">  "id": 1,</strong>
<strong class="bold">  "name": "Alice",</strong>
<strong class="bold">  "email": "alice@example.com",</strong>
<strong class="bold">  "role": "admin"</strong>
<code>/transaction</code> one deals with financial information. To retrieve some data, we need to provide the transaction ID. We might infer the numerical sequence (how about <code>1</code>?):<pre class="source-code">
<strong class="bold">$ curl http://localhost:5000/api/transaction/1</strong>
<strong class="bold">{</strong>
<strong class="bold">  "id": 1,</strong>
<strong class="bold">  "user_id": 1,</strong>
<strong class="bold">  "amount": 100,</strong>
<strong class="bold">  "status": "pending"</strong>
<code>pending</code>. Let’s cause data corruption by forcing the transaction to complete and by leveraging the <em class="italic">top secret</em> password with another simple Python code (this code <a id="_idIndexMarker693"/>can be downloaded from <a href="https://github.com/PacktPublishing/Pentesting-APIs/blob/main/chapters/chapter09/parameter_tampering/manipulate_transaction_status.py">https://github.com/PacktPublishing/Pentesting-APIs/blob/main/chapters/chapter09/parameter_tampering/manipulate_transaction_status.py</a>):<pre class="source-code">
import requests
data = {
    'transaction_id': '1',
    'status': 'completed',
    'auth': 'admin_secret'
}
response = requests.post(
               'http://localhost:5000/api/admin/update_status', data=data
)
print(response.json())</pre><p class="list-inset">Guess what, the transaction is now finished.</p><pre class="source-code">{
  "message": "Transaction status updated"
}</pre></li>				<li>Let’s double-check it:<pre class="source-code">
<strong class="bold">$ curl http://localhost:5000/api/transaction/1</strong>
<strong class="bold">{</strong>
<strong class="bold">  "id": 1,</strong>
<strong class="bold">  "user_id": 1,</strong>
<strong class="bold">  "amount": 100,</strong>
<strong class="bold">  "status": "completed"</strong>
<code>/admin/update_status</code> endpoint without providing the corresponding password:<pre class="source-code">
<strong class="bold">$ curl http://localhost:5000/api/admin/update_status</strong>
<strong class="bold">{</strong>
<strong class="bold">  "error": "Unauthorized"</strong>
<strong class="bold">}</strong></pre></li>				<li>OK, that was expected. However, should we obtain such a password in some way, such as through <a id="_idIndexMarker694"/>social engineering, resource exhaustion, or data leaks, we could easily retrieve and manipulate data without proper authorization (this code can be downloaded from <a href="https://github.com/PacktPublishing/Pentesting-APIs/blob/main/chapters/chapter09/parameter_tampering/manipulate_authorization.py">https://github.com/PacktPublishing/Pentesting-APIs/blob/main/chapters/chapter09/parameter_tampering/manipulate_authorization.py</a>):<pre class="source-code">
import requests
data = {
    'auth': 'admin_secret'
}
response = requests.post(
               'http://localhost:5000/api/admin/update_status', data=data
)
print(response.json())</pre></li>				<li>This would give us the confirmation of unauthorized access:<pre class="source-code">
{
  "super_secret": "This is top secret data!"
}</pre></li>			</ol>
			<p>Results with parameter tampering attacks can be as easy to achieve as the implementation of the API that’s the target. You might need to combine techniques depending on the scenario, but it’s not<a id="_idIndexMarker695"/> difficult to detect whether the API is vulnerable to this category of threat. For the people responsible for watching and protecting the environment, it can be difficult to detect when such type of attack is running, as it may be confused with a user trying to communicate with the API but messing up with some parameters because of a lack of knowledge about the documentation. In the next section, we are going to cover how we can test for business logic vulnerabilities.</p>
			<h1 id="_idParaDest-147"><a id="_idTextAnchor149"/>Testing for business logic vulnerabilities</h1>
			<p>Unraveling vulnerabilities within an API’s business logic is a challenging but crucial aspect of security evaluations. Contrary to what we do with common flaws derived from coding errors or infrastructure<a id="_idIndexMarker696"/> misconfigurations, these types of vulnerabilities target the API’s designed and intended functionalities. To identify these chinks in the armor, security testers must possess a comprehensive understanding of the application’s business processes and how they might be contorted. This in-depth examination involves meticulously analyzing the application’s workflows, user permissions, and data flow to unearth potential weaknesses.</p>
			<p>Discovering business logic vulnerabilities within APIs is not straightforward since they can easily bypass traditional security watchdogs. Automated tools might miss these hidden weaknesses since they don’t necessarily involve strange inputs or well-known exploit patterns.  Instead, these vulnerabilities stem from how the application handles legitimate operations. For example, an attacker could leverage the way an API manages transactions, user permissions, or data processing tasks to their advantage. Uncovering these flaws demands a sophisticated grasp of the application’s internal logic and a sharp eye for potential misuses that could be manipulated for malicious purposes.</p>
			<p>Unveiling business logic vulnerabilities hinges on manual testing. Security specialists need to delve into the application’s functionalities by hand, brainstorming how various features intertwine and how they might be misused for malicious ends. This hands-on approach often involves crafting intricate test scenarios that explore diverse situations.  Testers might try running actions in an unorthodox order or feeding the application with unexpected data values.  By carefully sifting through the application’s workflows, testers can pinpoint subtle cracks in the system’s logic that could be exploited to execute unauthorized actions or access sensitive data.</p>
			<p>In 2022, a business logic vulnerability in PayPal’s API, tied to how it interprets transaction details, allowed attackers to tamper with money transfers. The vulnerability stemmed from flaws in how the system verified transaction parameters. By exploiting these gaps, attackers could manipulate the amounts being sent, resulting in financial losses. This incident highlighted the vital importance of fortifying all transaction-related checks within the system to safeguard the integrity of financial operations. You will find a detailed explanation at <a href="https://phoenixnap.com/blog/paypal-hacked">https://phoenixnap.com/blog/paypal-hacked</a>.</p>
			<p>You don’t need to apply graphical tools. Code written in Python or even in Bash with the help of curl may successfully exploit business logic vulnerabilities in badly written APIs. However, should you choose the graphical path, some already-known friends such as Burp Suite and Postman are handy. Spotlighting weaknesses within an application’s business logic requires a multi-pronged approach.  One powerful technique involves a deep dive into the application’s source code, if available. This grants testers a clear picture of how various <a id="_idIndexMarker697"/>components interact, potentially revealing flaws in the application’s decision-making processes. Automated code analysis tools can accelerate this process by highlighting areas where the business logic might be implemented incorrectly, or where security controls are lacking. However, these code audits shouldn’t be the sole focus. Real-world testing (dynamic testing) is crucial to understanding how the application behaves in a live environment and how different inputs affect its internal state. Combining these methods provides a more holistic view of potential vulnerabilities.</p>
			<p>For our exercises in this section, we’ll apply the <code>api_business_logic.py</code> file. It can be found at <a href="https://github.com/PacktPublishing/Pentesting-APIs/blob/main/chapters/chapter09/business_logic/api_business_logic.py">https://github.com/PacktPublishing/Pentesting-APIs/blob/main/chapters/chapter09/business_logic/api_business_logic.py</a>.</p>
			<p>We can list at least three weaknesses:</p>
			<ul>
				<li>Right in the beginning, we have a <code>users</code> variable raises this <a id="_idIndexMarker698"/>vulnerability. Instead of specifying this in the code, we should leverage environment variables or retrieve it from an external database service, either SQL or NoSQL.</li>
				<li>Incorrect input validation is present in the <code>/admin</code> endpoint. Rather than relying on what the user provides as input, the code should leverage the language’s features, such as safe functions or methods to retrieve data.</li>
				<li>Finally, <em class="italic">passwords should never be stored in clear text</em>. Before storing them, passwords should always be stored as hashes, and safe functions or modules should be used to apply the hashes.</li>
			</ul>
			<p>There are some useful utilities that you can make use of to help you spot code flaws:</p>
			<ul>
				<li><strong class="bold">Bandit</strong>: Python security<a id="_idIndexMarker699"/> analysis tool (<a href="https://pypi.org/project/bandit/">https://pypi.org/project/bandit/</a>).</li>
				<li><strong class="bold">Safety</strong>: Dependency vulnerability<a id="_idIndexMarker700"/> detection utility (<a href="https://pypi.org/project/safety/">https://pypi.org/project/safety/</a>).</li>
				<li><strong class="bold">Semgrep</strong>: Flexible<a id="_idIndexMarker701"/> code analysis tool (<a href="https://pypi.org/project/semgrep/">https://pypi.org/project/semgrep/</a>).</li>
			</ul>
			<p class="callout-heading">Note</p>
			<p class="callout">Safety is backed by a<a id="_idIndexMarker702"/> company nowadays (<a href="https://safetycli.com/">https://safetycli.com/</a>). Although claiming to be free software, to effectively run, it needs you to create an account with this company, which involves agreeing to their service terms and sharing an email address. The first time you run the utility, you’ll receive a message like the following:</p>
			<pre class="console">
$ safety scan --target .
Please login or register Safety CLI (free forever) to scan and secure your projects with Safety
(R)egister for a free account in 30 seconds, or (L)ogin with an existing account to continue (R/L): R
Redirecting your browser to register for a free account. Once registered, return here to start using Safety.
If the browser does not automatically open in 5 seconds, copy and paste this url into your browser:
&lt;&lt;&lt;A dynamic URL is presented here.&gt;&gt;&gt;
[=   ] waiting for browser authenticationupdate.go:85: cannot change mount namespace according to change mount (/var/lib/snapd/hostfs/usr/local/share/doc /usr/local/share/doc none bind,ro 0 0): cannot open directory "/usr/local/share": permission denied
[  ==] waiting for browser authenticationGtk-Message: 22:45:48.735: Not loading module "atk-bridge": The functionality is provided by GTK natively. Please try to not load it.
Successfully registered address@domain.com</pre>			<p class="callout">After the registration is complete, the next time you use the software, you’ll need to log in, and then all will be good. The utility downloads the requested (or default) rules from the internet before each run.</p>
			<p>Let’s start the attacks<a id="_idIndexMarker703"/> against the API. The steps are provided in the following sequence:</p>
			<ol>
				<li>The first thing we’ll do is to register a new user. This code does not check any authorization in this step. We’ll use Burp Suite for these exercises. Hence, run Burp Suite and click on the <strong class="bold">Proxy</strong> tab. Make sure that this service is on and that <strong class="bold">Intercept</strong> is <em class="italic">active</em>. We’ll need it to be active to change the request type and add more parameters. Finally, click on the <strong class="bold">Open </strong><strong class="bold">browser</strong> button.</li>
				<li>With Burp’s browser opened (usually, a Chromium instance), access <code>http://localhost:5000/register</code>. Immediately go back to Burp and click on the <code>POST</code> instead of <code>GET</code>. Then, we need to specify the <code>Content-Type</code> to be <code>application/json</code>, as expected. Then, we must add the JSON structure for a new user. You can put anything here since it’s a valid JSON element with <code>username</code> and <code>password</code> as keys (<em class="italic">Figure 9</em><em class="italic">.14</em>).</li>
			</ol>
			<div><div><img src="img/B19657_figure_09.14.jpg" alt="Figure 9.14﻿ – Changing a GET request to POST on Burp’s Intercept"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.14 – Changing a GET request to POST on Burp’s Intercept</p>
			<ol>
				<li value="3">Now click on the <strong class="bold">Forward</strong> button. This will send the crafted request to the API and the user will be registered. Back in the browser window, you’ll receive a message stating that the operation was successful (<em class="italic">Figure 9</em><em class="italic">.15</em>).</li>
			</ol>
			<div><div><img src="img/B19657_figure_09.15.jpg" alt="Figure 9.15 – A successful user registration attack"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.15 – A successful user registration attack</p>
			<ol>
				<li value="4">Moving on, let’s explore the <code>/order</code> endpoint. By analyzing the code, we can find out that it<a id="_idIndexMarker704"/> expects to receive a username (this just needs to be a valid one), a product ID (we can infer <code>1</code> as being valid), a quantity, and a discount code. We’ll send an arbitrary discount code by crafting a combination of possible values trying to cause the logic to fail. Go back to Burp’s browser and send a request to <code>/order</code>, then get back to Burp’s <strong class="bold">Intercept</strong>. Again, adapt the request accordingly, making equivalent changes to the ones you made before. This time though, the JSON structure will be more sophisticated since we need to send more keys (<em class="italic">Figure 9</em><em class="italic">.16</em>).</li>
			</ol>
			<div><div><img src="img/B19657_figure_09.16.jpg" alt="Figure 9.16 – Sending a crafted POST request to /order"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.16 – Sending a crafted POST request to /order</p>
			<ol>
				<li value="5">Again, click on the <strong class="bold">Forward</strong> button and go back to the browser. You’ll realize that the order was successfully submitted. However, the discount code was not applied, demonstrating that this logic doesn’t seem vulnerable to our attempts (<em class="italic">Figure 9</em><em class="italic">.17</em>).</li>
			</ol>
			<div><div><img src="img/B19657_figure_09.17.jpg" alt="Figure 9.17 – Submitting an order using the previously created user"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.17 – Submitting an order using the previously created user</p>
			<ol>
				<li value="6">Our final exercise will lie in the <code>/admin</code> endpoint. Since absolutely no other security control besides the credential pair checking is in place, we’ll add a 100% discount code<a id="_idIndexMarker705"/> using the hardcoded credentials (they could have been stolen by a parallel method, such as social engineering or invalid exception handling). Go to the browser one more time and submit a dummy request to <code>/admin</code>, then get back to Burp’s <strong class="bold">Intercept</strong> and change it to the following (<em class="italic">Figure 9</em><em class="italic">.18</em>).</li>
			</ol>
			<div><div><img src="img/B19657_figure_09.18.jpg" alt="Figure 9.18 – Adding an arbitrary discount code using a stolen admin credential"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.18 – Adding an arbitrary discount code using a stolen admin credential</p>
			<p class="list-inset">As expected, the discount code was correctly added to the application (<em class="italic">Figure 9</em><em class="italic">.19</em>).</p>
			<div><div><img src="img/B19657_figure_09.19.jpg" alt="Figure 9.19 – The discount code is applied"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.19 – The discount code is applied</p>
			<ol>
				<li value="7">Now, if we repeat the<a id="_idIndexMarker706"/> request to <code>/order</code> expressed in <em class="italic">Figure 9</em><em class="italic">.16</em> but change the <code>discount_code</code> to <code>CRAFTED_CODE</code> and reduce the quantity to <code>1</code> (to avoid receiving the <strong class="bold">Insufficient stock</strong> message), we’ll be successful (<em class="italic">Figure 9</em><em class="italic">.20</em>).</li>
			</ol>
			<div><div><img src="img/B19657_figure_09.20.jpg" alt="Figure 9.20 – The order is successfully submitted with a crafted discount code"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.20 – The order is successfully submitted with a crafted discount code</p>
			<p>In this section, you’ll realize how <a id="_idIndexMarker707"/>reasonably small and easy code can cause substantial damage to real API targets. Your toolbelt doesn’t have to be expensive or complex to help achieve success with your pentesting activities. Just a few open source utilities can be quite handy.</p>
			<h1 id="_idParaDest-148"><a id="_idTextAnchor150"/>Summary</h1>
			<p>This chapter finished the fourth part of our book, covering important aspects of API business logic and abuse scenarios. We learned how damaging the lack of source code analysis and API business logic testing can be for APIs. Some notable incidents involving threats of this nature were also mentioned.</p>
			<p>While some security teams are only worried about the traditional or more common threats and security measures, criminals may be trying to leverage other non-obvious attack scenarios, such as the ones we mentioned in the chapter, making use of techniques that exploit flaws in APIs’ business logic. We learned this in this chapter. It’s definitely a topic you should add to your toolbelt when conducting a professional pentest.</p>
			<p>In the next chapter, the final one of this book, we’ll discuss secure API coding practices. These are more geared toward developers, but every pentester should know about them as well.</p>
			<h1 id="_idParaDest-149"><a id="_idTextAnchor151"/>Further reading</h1>
			<ul>
				<li>Experian’s API vulnerability: <a href="https://salt.security/blog/what-happened-in-the-experian-api-leak">https://salt.security/blog/what-happened-in-the-experian-api-leak</a></li>
				<li>John Deere’s API Leak: <a href="https://sick.codes/leaky-john-deere-apis-serious-food-supply-chain-vulnerabilities-discovered-by-sick-codes-kevin-kenney-willie-cade/">https://sick.codes/leaky-john-deere-apis-serious-food-supply-chain-vulnerabilities-discovered-by-sick-codes-kevin-kenney-willie-cade/</a></li>
				<li>The Twitter/X API breach that damaged 5.4 million users: <a href="https://www.bbc.com/news/technology-64153381">https://www.bbc.com/news/technology-64153381</a></li>
				<li>Flexbooker’s cloud API vulnerability that exposed the data of 3.7 million users: <a href="https://www.imperva.com/blog/five-takeaways-from-flexbookers-data-breach/ ">https://www.imperva.com/blog/five-takeaways-from-flexbookers-data-breach/</a></li>
				<li>The Texas Department of Insurance’s API incident, exposed for nearly 3 years, which compromised 1.8 million records: <a href="https://www.texastribune.org/2022/05/16/texas-insurance-data-breach/">https://www.texastribune.org/2022/05/16/texas-insurance-data-breach/</a></li>
				<li>OpenBullet2, a web testing tool: <a href="https://github.com/openbullet/OpenBullet2 ">https://github.com/openbullet/OpenBullet2</a></li>
				<li>Scrapy, a data extraction framework: <a href="https://scrapy.org/">https://scrapy.org/</a></li>
				<li>Microsoft Exchange Parameter Tampering CVE: <a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-26855">https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-26855</a></li>
				<li>Microsoft Official Blog Post: <a href="https://www.microsoft.com/en-us/security/blog/2021/03/02/hafnium-targeting-exchange-servers/">https://www.microsoft.com/en-us/security/blog/2021/03/02/hafnium-targeting-exchange-servers/</a></li>
				<li>CVE 2021-201315: <a href="https://nvd.nist.gov/vuln/detail/CVE-2021-21315">https://nvd.nist.gov/vuln/detail/CVE-2021-21315</a></li>
			</ul>
		</div>
	

		<div><h1 id="_idParaDest-150" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor152"/>Part 5: API Security Best Practices</h1>
			<p>This is the final part of the book. You have been learning how to discover, get information on, and attack APIs in different scenarios. Throughout the previous parts, vulnerable code has been presented to you with exploitable points in RESTful and GraphQL APIs. In this part, you will understand that a reasonable portion of security problems with APIs originate from bad coding practices. Knowing best practices is vital for securing APIs in a more appropriate way. When a pentester gets more acquainted with how the API code was written and which parts were ignored or forgotten by the developers, this can definitely help in the invasion journey.</p>
			<p>This section contains the following chapter:</p>
			<ul>
				<li><a href="B19657_10.xhtml#_idTextAnchor153"><em class="italic">Chapter 10</em></a>, <em class="italic">Secure Coding Practices for APIs</em></li>
			</ul>
		</div>
		<div><div></div>
		</div>
		<div><div></div>
		</div>
	</body></html>