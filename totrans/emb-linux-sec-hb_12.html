<html><head></head><body><div><div><p>&#13;
			<h1 id="_idParaDest-183" class="chapter-number"><a id="_idTextAnchor364"/>12</h1>&#13;
			<h1 id="_idParaDest-184"><a id="_idTextAnchor365"/>Are My Devices’ Communications and Interactions Secure?</h1>&#13;
			<p>It can be said that the only really secure computer is one that is powered off and locked away in a vault. There’s no fun nor usability in that so we must determine appropriate measures to limit exposure to vulnerabilities while still having the system be usable for the mission it was intended for.</p>&#13;
			<p>In this chapter, you will learn how to determine the use cases and limitations of commonly used external buses for hardware communication. We’ll review network security with firewalls. We’ll work through some hands-on exercises in locking down your web-based services with SSL certificates. We will dive into the gotchas of legacy hardware and software and close out this chapter with the security validation of your appliance.</p>&#13;
			<p>“Why is this important to my project?” <a id="_idTextAnchor366"/>you may ask... Simply put, you might lock down the system itself incredibly well, however, that system’s connections to peripherals or other applications may not exactly be as secure as you might have thought. To be aware is to be forewarned.</p>&#13;
			<p>The main sections of this chapter are:</p>&#13;
			<ul>&#13;
				<li>Bus types and issues</li>&#13;
				<li>Enhancing security with certificates</li>&#13;
				<li>Confirming that your networking is secure</li>&#13;
				<li>Limitations of legacy hardware and software</li>&#13;
				<li>Validating your solution before shipping</li>&#13;
			</ul>&#13;
			<p>Let’s move on to our first section, where we’ll take a look at different system buses.</p>&#13;
			<h1 id="_idParaDest-185"><a id="_idTextAnchor367"/>Technical requirements</h1>&#13;
			<p>To complete the exercises in this chapter, you will need root-level access to the web server you built as a custom DNF repository back in <a href="B22104_05.xhtml#_idTextAnchor179"><em class="italic">Chapter 5</em></a>.</p>&#13;
			<p>If you have deleted that server/work, you will need to build a new custom repository server as detailed in those previous exercises before beginning this exercise.</p>&#13;
			<h1 id="_idParaDest-186"><a id="_idTextAnchor368"/>Bus types and issues</h1>&#13;
			<p>So, what is a <strong class="bold">bus</strong>? Most<a id="_idIndexMarker505"/> simply put, a bus is a type of communication channel to and from devices and your system’s CPU. With this channel, data signals from (or to) the device can be processed by the CPU. Without this line of communication, the attached device will not function.</p>&#13;
			<p>A more layman’s way of describing a bus would be to break it down in the least technical of terms. Let’s look at the forest for the trees. In total, a bus is the culmination of hardware, software, and the cabling required to allow for data transmission. I’ll use a non-technical childhood example. Ever take two tin cans and some string to make a communications system? Those two cans were connected by a string that, when tightly stretched, carried your voice (i.e., the data) from one can (peripheral) to the other can (main processor) and was interpreted by the end-user on the receiving end.</p>&#13;
			<p><strong class="bold">Systems buses</strong> do<a id="_idIndexMarker506"/> this in a vastly more technical manner, but the result is the same. Data travels from a peripheral to the CPU and gets processed. For my super technical readers, please let me go a little deeper. Various buses are in play when sensors, cameras, controls, or other directly attached peripherals are attached to a system and their interactions are transmitted through their connection medium and then, finally, received and processed by the system CPU. There are several standard buses, but in this chapter, we’ll cover the most important ones that you may come across while<a id="_idIndexMarker507"/> working with embedded Linux systems, and by that, I mean the <strong class="bold">CAN bus</strong> and <strong class="bold">USB</strong>. In the<a id="_idIndexMarker508"/> next few sections, we will focus on system buses (along with standard connection types and protocols) that leverage external connections to your hardware. As we continue, I want you to envision all things that may be able to connect to your solution, with or without your permission. Sometimes, as we previously inferred in the section about childproofing your solution within <a href="B22104_10.xhtml#_idTextAnchor305"><em class="italic">Chapter 10</em></a>, you must almost assume the end-user is a toddler who might just shove their sandwich into the VCR. I know I’m dating myself by mentioning a VCR but it’s to make a point and I hope that point is well received. Plan for the worst, and hope for the best.</p>&#13;
			<p>What could possibly go wrong? Well, if your system uses an insecure bus or peripheral connection and a bad actor has physical access to said connection, it may be hijacked without your knowing (or worse). When insecure connections are leveraged, physical security must also be part of the design consideration and deployment plan.</p>&#13;
			<p>Let’s also hope that your awesome solution has a custom shell or case that covers up any ports you do not want the end-user to know are there. It’s rare when this is an option, but I felt the necessity to mention it. Plus, a custom case also makes a solution look better. Some even have built-in weather resistance. Let your use case guide your design.</p>&#13;
			<p class="callout-heading">Important note</p>&#13;
			<p class="callout">For an embedded Linux system, we’ll assume the case has a level of tamper-proofing even if it’s just a warning sticker that states all warranties are void if the case is opened. For this reason, we will not be covering system hardware internals like the well-known <strong class="bold">PCI bus</strong>... There<a id="_idIndexMarker509"/> are countless texts dedicated to that hardware and kernel development, so let’s stay focused on the external connections in play.</p>&#13;
			<p>That all said, let’s move on to a household name. A bus and connection type we all know – <strong class="bold">Universal Serial </strong><strong class="bold">Bus</strong> (<strong class="bold">U<a id="_idTextAnchor369"/>SB</strong>).</p>&#13;
			<h2 id="_idParaDest-187"><a id="_idTextAnchor370"/>USB</h2>&#13;
			<p>Since its initial<a id="_idIndexMarker510"/> introduction in 1996, the USB interface has been the worldwide standard connectivity method of choice for virtually all consumer devices. Modern USB ports have such versatility (depending on the device), which is why they are everywhere in daily life.</p>&#13;
			<p>USB empowers computers to connect to mice, keyboards, storage devices, printers, gaming controllers, authentication keys, and many other types of commercial hardware. The same port can also charge some devices like cell phones, tablets, or portable power units. USB can even be used to add multiple displays to a system.</p>&#13;
			<p>USB does not protect your data while in transit. Most people choose to encrypt USB-attached storage devices but by default when accessing the data or processing it. That data in transit is not encrypted. This limitation is not limited to Linux systems but all systems leveraging the USB framework.</p>&#13;
			<p>There are some<a id="_idIndexMarker511"/> commercially available solutions to secure this data in transit; however, they are not open source and definitely not free. They are sold as enterprise-grade data loss prevention systems and support multiple platforms (not just Linux). You will need one of these third-party solutions if the securing of your data in transit to USB storage is an issue.</p>&#13;
			<p>Let’s now move on to our next section where we will review USB connections.</p>&#13;
			<h3>USB connectors</h3>&#13;
			<p>The <a id="_idIndexMarker512"/>USB family of <strong class="bold">connectors</strong> has evolved over the years, but since the beginning and still to this day, USB-A might be the world’s most common connection interface ever created. It can be found in household wall outlets, PCs, laptops, external storage devices, on the back of passenger aircraft seats, in the dashboards of cars and recreational vehicles (RVs), solar generators, power banks, and so, so, so much more… (Yeah, I know that’s not grammatically correct but I really want to emphasize that USB-A is <em class="italic">E-V-E-R-Y-W-H-E-R-E !!</em>)</p>&#13;
			<p>What’s ironic about USB is that virtually all the shown connectors are still being actively used today. Granted, there’s a difference in the quality of the materials used now vs. the older versions, but that’s there to simply allow for better data transfer <a id="_idTextAnchor371"/>rates. The cables themselves are not a security issue per se, as the issues reside in the chips and the USB bus itself. Let’s take a quick look at those connector types.</p>&#13;
			<p>From left to right in the following figure, we have USB-B, USB-A, USB-mini, USB-micro, and USB-C:</p>&#13;
			<div>&#13;
				<div>&#13;
					<img src="img/B22104_12_01.jpg" alt="Figure 12.1 – USB connectors over the years" width="1650" height="520"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.1 – USB connectors over the years</p>&#13;
			<p>In pondering how to compare the various versions of the USB standard that you will come across, I felt it imperative to throw some critical data in a table format for ease of viewing. Although the connectors may all be compatible, the speeds and throughput of the different<a id="_idIndexMarker513"/> versions are vastly and mind-blowingly different.</p>&#13;
			<p>Here’s a table of USB versions, performance, and connectors in use today:</p>&#13;
			<table id="table001-1" class="No-Table-Style _idGenTablePara-1">&#13;
				<colgroup>&#13;
					<col/>&#13;
					<col/>&#13;
					<col/>&#13;
					<col/>&#13;
				</colgroup>&#13;
				<tbody>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style">&#13;
							<p><strong class="bold">USB Version</strong></p>&#13;
						</td>&#13;
						<td class="No-Table-Style">&#13;
							<p><strong class="bold">Bandwidth</strong></p>&#13;
						</td>&#13;
						<td class="No-Table-Style">&#13;
							<p><strong class="bold">Data </strong><strong class="bold">Transfer Speed</strong></p>&#13;
						</td>&#13;
						<td class="No-Table-Style">&#13;
							<p><strong class="bold">Connectors</strong></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style">&#13;
							<p>USB4</p>&#13;
						</td>&#13;
						<td class="No-Table-Style">&#13;
							<p>20 or 40 Gbps</p>&#13;
						</td>&#13;
						<td class="No-Table-Style">&#13;
							<p>2560–5120 MB/s</p>&#13;
						</td>&#13;
						<td class="No-Table-Style">&#13;
							<p>C</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style">&#13;
							<p>USB 3.2</p>&#13;
						</td>&#13;
						<td class="No-Table-Style">&#13;
							<p>20 Gbps</p>&#13;
						</td>&#13;
						<td class="No-Table-Style">&#13;
							<p>2560 MB/s</p>&#13;
						</td>&#13;
						<td class="No-Table-Style">&#13;
							<p>C</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style">&#13;
							<p>USB 3.1</p>&#13;
						</td>&#13;
						<td class="No-Table-Style">&#13;
							<p>10 Gbps</p>&#13;
						</td>&#13;
						<td class="No-Table-Style">&#13;
							<p>1280 MB/s</p>&#13;
						</td>&#13;
						<td class="No-Table-Style">&#13;
							<p>A, C</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style">&#13;
							<p>USB 3.0</p>&#13;
						</td>&#13;
						<td class="No-Table-Style">&#13;
							<p>5 Gbps</p>&#13;
						</td>&#13;
						<td class="No-Table-Style">&#13;
							<p>640 MB/s</p>&#13;
						</td>&#13;
						<td class="No-Table-Style">&#13;
							<p>A, B. C</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style">&#13;
							<p>USB 2.0</p>&#13;
						</td>&#13;
						<td class="No-Table-Style">&#13;
							<p>480 Mbps</p>&#13;
						</td>&#13;
						<td class="No-Table-Style">&#13;
							<p>60 MB/s</p>&#13;
						</td>&#13;
						<td class="No-Table-Style">&#13;
							<p>A, B, Mini, Micro</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style">&#13;
							<p>USB 1.1</p>&#13;
						</td>&#13;
						<td class="No-Table-Style">&#13;
							<p>12 Mbps</p>&#13;
						</td>&#13;
						<td class="No-Table-Style">&#13;
							<p>1.5 MB/s</p>&#13;
						</td>&#13;
						<td class="No-Table-Style">&#13;
							<p>A, B, Mini, Micro</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style">&#13;
							<p>USB 1.0</p>&#13;
						</td>&#13;
						<td class="No-Table-Style">&#13;
							<p>1.5 Mbps</p>&#13;
						</td>&#13;
						<td class="No-Table-Style">&#13;
							<p>1.5 MB/s</p>&#13;
						</td>&#13;
						<td class="No-Table-Style">&#13;
							<p>A, B, Mini, Micro</p>&#13;
						</td>&#13;
					</tr>&#13;
				</tbody>&#13;
			</table>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 12.1 – Speed and capabilities of different USB versions</p>&#13;
			<p>As you can see from the above table, the wide range of connections of the USB standard has greatly evolved in the past 30 years. USB has been a game changer and a trendsetter and will <a id="_idIndexMarker514"/>continue onward for many more years to come. Let’s move on by looking at its predecessor, the serial bus, next.<a id="_idTextAnchor372"/></p>&#13;
			<h2 id="_idParaDest-188"><a id="_idTextAnchor373"/>Serial port</h2>&#13;
			<p>Known for <a id="_idIndexMarker515"/>being notoriously insecure, <strong class="bold">serial ports</strong> have been providing text terminal access since the old Unix days. There are still many serial devices that are used every day. Keyboards and mice are still quite commonplace (nowadays using USB) and may also be part of your solution. Serial connections are still incredibly common for engineers to use from their laptops to networking equipment such as switches, firewalls, and routers. Today, that often requires an adapter device that connects to an engineer’s laptop via USB and then to a serial cable that connects to a serial port on the device to be managed. These devices will automatically establish connections once attached to your Linux system with no effort required from you.</p>&#13;
			<p>Serial ports (more commonly called terminal ports) can be physical or virtual. Most physical serial connections today are auto-negotiated through the USB bus; however, on older systems, those devices may have used a PS2 connection or the older serial port otherwise known<a id="_idIndexMarker516"/> as <strong class="bold">DB9</strong>. Serial ports may also be used by industrial automation systems, printers, scanners, and some medical devices. The following figure shows the serial connection female connector (left) and the serial connection male (right):</p>&#13;
			<p class="IMG---Figure">  </p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B22104_12_02.jpg" alt="Figure 12.2 – Serial connector examples" width="1185" height="460"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.2 – Serial connector examples</p>&#13;
			<p>Linux systems can also<a id="_idIndexMarker517"/> have <strong class="bold">virtual serial connections</strong>. It’s important to know how your system is mapping these connections. First, why should<a id="_idIndexMarker518"/> you care? Well, this directly impacts how many terminal sessions can be directly established with your system concurrently. If your appliance is a console/text-based appliance, this metric is crucial in its management and control. In the simplest terms possible, this metric denotes how many doors can be opened at once. When not crucial to your appliance’s user experience, these TTY console sessions should be limited as much as possible without breaking the operation of the appliance.</p>&#13;
			<p>To get a great sense of just how many TTY sessions your system starts at boot time, here’s an example command that will show you how your system has these ports named and mapped. Consider each one an open door that either should be locked, boarded up, or simply guarded.</p>&#13;
			<p>Let’s see how many TTY sessions are possible in our current system:<a id="_idTextAnchor374"/></p>&#13;
			<pre class="console">&#13;
$ ls -l /sys/class/tty/*</pre>			<p>The output for<a id="_idIndexMarker519"/> this one will definitely be lengthy so I have truncated it... What you will see will be an exhaustive list of physical and virtual terminal port possibilities.</p>&#13;
			<pre class="console">&#13;
     ((( output truncated )))&#13;
lrwxrwxrwx. 1 root root 0 Aug 25 09:33 /sys/class/tty/ttyS4 -&gt; ../../devices/pci0000:00/0000:00:16.3/0000:00:16.3:0/0000:00:16.3:0.0/tty/ttyS4&#13;
lrwxrwxrwx. 1 root root 0 Aug 25 09:33 /sys/class/tty/ttyS5 -&gt; ../../devices/platform/serial8250/serial8250:0/serial8250:0.5/tty/ttyS5&#13;
lrwxrwxrwx. 1 root root 0 Aug 25 09:33 /sys/class/tty/ttyS6 -&gt; ../../devices/platform/serial8250/serial8250:0/serial8250:0.6/tty/ttyS6&#13;
lrwxrwxrwx. 1 root root 0 Aug 25 09:33 /sys/class/tty/ttyS7 -&gt; ../../devices/platform/serial8250/serial8250:0/serial8250:0.7/tty/ttyS7&#13;
lrwxrwxrwx. 1 root root 0 Aug 25 09:33 /sys/class/tty/ttyS8 -&gt; ../../devices/platform/serial8250/serial8250:0/serial8250:0.8/tty/ttyS8&#13;
lrwxrwxrwx. 1 root root 0 Aug 25 09:33 /sys/class/tty/ttyS9 -&gt; ../../devices/platform/serial8250/serial8250:0/serial8250:0.9/tty/ttyS9</pre>			<p>Knowing how to track these connections is crucial for maintaining device security. Let’s move on to yet another bus that also uses the DB9 connector – the CAN b<a id="_idTextAnchor375"/>us.</p>&#13;
			<h2 id="_idParaDest-189"><a id="_idTextAnchor376"/>The CAN bus</h2>&#13;
			<p>The <strong class="bold">Controller Area Network</strong> (<strong class="bold">CAN</strong>) bus is a vehicular standard. Its main purpose is to <a id="_idIndexMarker520"/>control communication between <strong class="bold">electronic control units</strong> (<strong class="bold">ECUs</strong>). It <a id="_idIndexMarker521"/>was first introduced back in 1983; however, it still has no standard connector, although the DB9 connector seems to be a de facto standard today.</p>&#13;
			<p>As cars nowadays are becoming rolling data centers (even the non-self-driving ones), I felt it important to mention this bus type as many manufacturers are jumping to build embedded systems in this evolving space.</p>&#13;
			<p>However, CAN is not limited to automobiles. CAN bus architectures can be seen deployed in maritime environments, agricultural equipment, and even in large buildings to control elevators, escalators, and other building automation. It’s even being leveraged in modern robotics.</p>&#13;
			<p>Sadly, CAN is not encrypted. Be mindful and be aware. Another problem with CAN is the lack of authentication. Ultimately, this means whoever can access the bus has control of the bus. All security be abandoned. What could possibly go wrong?</p>&#13;
			<p>There’s a whole community around hacking cars’ control systems. Most who engage in this journey do so to squeeze a little more performance out of their own vehicle. No malicious intent there, just an engineer’s curiosity. That said, a bad actor could easily access a car’s locks, GPS records, or controls, or possibly conduct other malicious activities.</p>&#13;
			<p>Another factor, just like with USB and serial, is that the lack of encryption means any credentials passed across the bus are done in plain text. Anyone watching traffic on the bus can see that data and potentially use it to do less than nice things.</p>&#13;
			<p>As more and more vehicles rely on electronics to create a better driver’s experience, let’s hope that the CAN standard itself can get some much-needed security added in its next version.</p>&#13;
			<p>Let’s move on to a key component in setting up encryption – creating certific<a id="_idTextAnchor377"/>ates.</p>&#13;
			<h1 id="_idParaDest-190"><a id="_idTextAnchor378"/>Enhancing security with certificates</h1>&#13;
			<p><strong class="bold">Certificates</strong> are<a id="_idIndexMarker522"/> used for many facets of secure communications globally. Your hardware and software vendors often digitally sign their drivers and operating system<a id="_idIndexMarker523"/> packages. Trusted authorities use certificates to ensure you can safely use DNS and the internet. The list of use cases for certificates is significant. Generally, these security certificates<a id="_idIndexMarker524"/> are obtained through a global <strong class="bold">certificate authority</strong> (<strong class="bold">CA</strong>) organization. Many internet service providers (ISPs) also have the ability to grant their customers an SSL certificate.</p>&#13;
			<p>These shared system certificates enable things like NSS, TLS, OpenSSL, and applications to have a joint shared source of trust via a system certificate (trust anchor). Not having an SSL certificate will prevent you from using an encrypted web server.</p>&#13;
			<p>There is also the ability in Linux to create a self-signed certificate. These are generally good enough for internal lab work but are considered insufficient in a production environ<a id="_idTextAnchor379"/>ment and definitely not a good idea for your product.</p>&#13;
			<p>In thinking of where I can show you an example suitable for lab or demo usage, I came up with this thought, “Where might we consider using a certificate? Your DNF repository server?”</p>&#13;
			<p>Let’s explore that thought with some hands-on ex<a id="_idTextAnchor380"/>ercises.</p>&#13;
			<h2 id="_idParaDest-191"><a id="_idTextAnchor381"/>Exercise 1: Creating a self-signed certificate</h2>&#13;
			<p>In this <a id="_idIndexMarker525"/>hands-on exercise, we’ll create a self-signed<a id="_idIndexMarker526"/> certificate that we could possibly use to encrypt a web server. Let’s begin:</p>&#13;
			<ol>&#13;
				<li>First, we’ll verify that the web server is hosting our repository as previously configured in <a href="B22104_05.xhtml#_idTextAnchor179"><em class="italic">Chapter 5</em></a>.<pre class="source-code">&#13;
<strong class="bold">$ sudo systemctl status httpd.service</strong>&#13;
<strong class="bold">●</strong><strong class="bold"> httpd.service - The Apache HTTP Server</strong>&#13;
<strong class="bold">     Loaded: loaded (/usr/lib/systemd/system/httpd.service; enabled; preset: disabled)</strong>&#13;
<strong class="bold">    Drop-In: /usr/lib/systemd/system/service.d</strong>&#13;
<strong class="bold">             └─10-timeout-abort.conf</strong>&#13;
<strong class="bold">     Active: active (running) since Sun 2024-10-06 17:53:55 EDT; 2min 43s ago</strong>&#13;
<strong class="bold">       Docs: man:httpd.service(8)</strong>&#13;
<strong class="bold">   Main PID: 1215 (httpd)</strong>&#13;
<strong class="bold">     Status: "Total requests: 1; Idle/Busy workers 100/0;Requests/sec: 0.00617; Bytes served/sec:  12 B/sec"</strong>&#13;
<strong class="bold">      Tasks: 178 (limit: 38323)</strong>&#13;
<strong class="bold">     Memory: 21.2M (peak: 22.4M)</strong>&#13;
<strong class="bold">        CPU: 225ms</strong>&#13;
<strong class="bold">CGroup: /system.slice/httpd.service</strong>&#13;
<strong class="bold">             ├─1215 /usr/sbin/httpd -DFOREGROUND</strong>&#13;
<strong class="bold">             ├─1294 /usr/sbin/httpd -DFOREGROUND</strong>&#13;
<strong class="bold">             ├─1295 /usr/sbin/httpd -DFOREGROUND</strong>&#13;
<strong class="bold">             ├─1296 /usr/sbin/httpd -DFOREGROUND</strong>&#13;
<strong class="bold">             ├─1297 /usr/sbin/httpd -DFOREGROUND</strong>&#13;
<strong class="bold">             └─1298 /usr/sbin/httpd -DFOREGROUND</strong>&#13;
<strong class="bold"> Oct 06 17:53:55 bm02.local systemd[1]: Starting httpd.service - The Apache HTTP Server...</strong>&#13;
<strong class="bold">Oct 06 17:53:55 bm02.local (httpd)[1215]: httpd.service: Referenced but unset environment variable evaluates to an &gt;</strong>&#13;
<strong class="bold">Oct 06 17:53:55 bm02.local httpd[1215]: Server configured, listening on: port 443, port 80</strong>&#13;
<strong class="bold">Oct 06 17:53:55 bm02.local systemd[1]: Started httpd.service - The Apache HTTP Server.</strong></pre></li>			</ol>&#13;
			<p class="callout-heading">Important note</p>&#13;
			<p class="callout">You’ll need to substitute your hostname or IP address that you configured for your system.</p>&#13;
			<ol>&#13;
				<li value="2">Confirm<a id="_idIndexMarker527"/> that the service is hosting<a id="_idIndexMarker528"/> your repository via your web browser.</li>&#13;
			</ol>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B22104_12_03.jpg" alt="Figure 12.3 – Verifying your repository via a web browser" width="754" height="368"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.3 – Verifying your repository via a web browser</p>&#13;
			<ol>&#13;
				<li value="3">We will now begin setting up the environment by setting a system variable. For this next step, replace <code>&lt;hostname&gt;</code> with your system’s FQDN. As root, execute the following command.<pre class="source-code">&#13;
<code>.pem</code> file, which will store your certificate information.<pre class="source-code">&#13;
<code>.</code><code>pem</code> file.<pre class="source-code">&#13;
<strong class="bold"># ls -l *.pem</strong>&#13;
<code>EmbeddedBook</code> as the challenge password at the end. Please feel free to use your own challenge password (but do make a note of it for later). As root, run the following command:<pre class="source-code">&#13;
<strong class="bold"># openssl req -new -key ${ssl_name}.pem -out ${ssl_name}.csr</strong></pre><p class="list-inset">Let’s see the interactive prompts/output:</p><pre class="source-code"><strong class="bold">You are about to be asked to enter information that will be incorporated</strong>&#13;
<strong class="bold">into your certificate request.</strong>&#13;
<strong class="bold">What you are about to enter is what is called a Distinguished Name or a DN.</strong>&#13;
<strong class="bold">There are quite a few fields but you can leave some blank</strong>&#13;
<strong class="bold">For some fields there will be a default value,</strong>&#13;
<strong class="bold">If you enter '.', the field will be left blank.</strong>&#13;
<strong class="bold">-----</strong>&#13;
<strong class="bold">Country Name (2 letter code) [XX]:US</strong>&#13;
<strong class="bold">State or Province Name (full name) []:MA</strong>&#13;
<strong class="bold">Locality Name (eg, city) [Default City]:Wilmington</strong>&#13;
<strong class="bold">Organization Name (eg, company) [Default Company Ltd]:Embedded Security Book</strong>&#13;
<strong class="bold">Organizational Unit Name (eg, section) []:Development</strong>&#13;
<strong class="bold">Common Name (eg, your name or your server's hostname) []:bm02.local</strong>&#13;
<strong class="bold">Email Address []:admin@bm02.local</strong>&#13;
<strong class="bold">Please enter the following 'extra' attributes</strong>&#13;
<strong class="bold">to be sent with your certificate request</strong>&#13;
<strong class="bold">A challenge password []:EmbeddedBook</strong>&#13;
<code>.csr</code> file properly.<pre class="source-code">&#13;
<strong class="bold"># ls -l *.csr</strong>
<strong class="bold">-rw-r--r--. 1 root root 1850 Aug 25 21:22 bm02.local.csr</strong></pre><p class="list-inset">This CSR file is what you would be sending to your CA if you were procuring an enterprise SSL certificate. We can also leverage this to create a temporary self-signed certi<a id="_idTextAnchor382"/>ficate locally.</pre></li>				<li>Let’s create a temporary cert that’s good for 90 days.<pre class="source-code">&#13;
<strong class="bold"># openssl x509 -req -days 90 -in ${ssl_name}.csr \</strong>&#13;
<strong class="bold">-signkey ${ssl_name}.pem \</strong>&#13;
<strong class="bold">-out ${ssl_name}.cert</strong></pre><p class="list-inset">Your output should look something like the following:</p><pre class="source-code"><strong class="bold">Certificate request self-signature ok</strong>&#13;
<code>&lt;hostname&gt;</code> with your system’s hostname. Mine is shown just for <a id="_idIndexMarker534"/>example purposes.<pre class="source-code">&#13;
<strong class="bold"># ls -l *&lt;hostname&gt;*</strong></pre><p class="list-inset">Your output should contain at least the files shown that are identified by your system’s hostname.</p><pre class="source-code"><strong class="bold">-rw-r--r--. 1 root root 2110 Aug 25 21:30 bm02.local.cert</strong>&#13;
<strong class="bold">-rw-r--r--. 1 root root 1850 Aug 25 21:22 bm02.local.csr</strong>&#13;
<strong class="bold">-rw-------. 1 root root 3272 Aug 25 21:12 bm02.local.pem</strong></pre></li>			</ol>&#13;
			<p>Wow, wasn’t that easy?! You’ve now created your first self-signed server certificate. Please never use that in production unless there is no other way of securing your web service. Now that we’ve created our certificate, let’s put it to good use in our next exercise by attaching it to<a id="_idTextAnchor383"/> our web service.</p>&#13;
			<h2 id="_idParaDest-192"><a id="_idTextAnchor384"/>Exercise 2: Adding a certificate to your custom repository server</h2>&#13;
			<p>In this<a id="_idIndexMarker535"/> exercise, we’ll install your previously created self-signed certificate into the web server you built previously to host your custom DNF repository. Once completed, the web server itself will default to leverage the HTTPS protocol versus the previous default of HTTP. The change in protocol means you’ll also need to ensure that the firewall rules have also been updated. Let’s get started.</p>&#13;
			<ol>&#13;
				<li>As root, install <code>mod_ssl</code>.<pre class="source-code">&#13;
<strong class="bold"># dnf install -y mod_ssl</strong></pre><p class="list-inset">Your output may be lengthy, but it should look somewhat like this – I have truncated the output to save space.</p><pre class="source-code"><strong class="bold">((( truncated output )))</strong>&#13;
<strong class="bold">Running transaction check</strong>&#13;
<strong class="bold">Transaction check succeeded.</strong>&#13;
<strong class="bold">Running transaction test</strong>&#13;
<strong class="bold">Transaction test succeeded.</strong>&#13;
<strong class="bold">Running transaction</strong>&#13;
<strong class="bold">  Preparing        :                               </strong>&#13;
<strong class="bold">                                                   </strong>&#13;
<strong class="bold">           1/1</strong>&#13;
<strong class="bold">  Installing       : mod_ssl-1:2.4.62-2.fc40.x86_64</strong>&#13;
<strong class="bold">                                                   </strong>&#13;
<strong class="bold">           1/1</strong>&#13;
<strong class="bold">  Running scriptlet: mod_ssl-1:2.4.62-2.fc40.x86_64</strong>&#13;
<strong class="bold">                                                   </strong>&#13;
<strong class="bold">           1/1</strong>&#13;
<strong class="bold">Installed:</strong>&#13;
<strong class="bold">  mod_ssl-1:2.4.62-2.fc40.x86_64</strong>&#13;
<code>.cert</code> file (mine is shown as an example).<pre class="source-code">&#13;
<code>.pem</code> file to the proper directory. Remember to substitute your<a id="_idIndexMarker536"/> own <code>.pem</code> file (mine is show<a id="_idTextAnchor385"/>n as an example).<pre class="source-code">&#13;
<code>.pem</code> file to an additional directory. Remember to substitute your own <code>.pem</code> file (mine is shown as an example).<pre class="source-code">&#13;
<code>/etc/httpd/conf.d/ssl.conf</code> file as root. Follow the instructions on which lines to uncomment and edit. When done with the listed changes, save and exit the editor.<pre class="source-code">&#13;
<code>443</code>.</li></ol><pre class="source-code"><strong class="bold">#ServerName www.example.com:443</strong>&#13;
<strong class="bold">ServerName bm02.local:443</strong></pre><ol><li class="upper-roman" value="3">Change this line to your own CRT file – mine is shown for example.</li></ol><pre class="source-code"><strong class="bold">SSLCertificateFile /etc/pki/tls/certs/localhost.crt</strong>&#13;
<strong class="bold">SSLCertificateFile /etc/pki/tls/certs/bm02.local.cert</strong></pre><ol><li class="upper-roman" value="4">Change this line to your own PEM file – mine is shown for example.</li></ol><pre class="source-code"><strong class="bold">SSLCertificateKeyFile /etc/pki/tls/private/localhost.key</strong>&#13;
<code>.pem</code> file – mine is shown for example.</li></ol><pre class="source-code"><strong class="bold">#SSLCertificateChainFile /etc/pki/tls/certs/server-chain.crt</strong>&#13;
<code>httpd</code> service as root and test. Run the following commands as root.<pre class="source-code">&#13;
<code>httpd</code> service is running as expected.<pre class="source-code">&#13;
<strong class="bold"># systemctl status httpd</strong></pre><p class="list-inset">Your output should resemble something like this:</p><pre class="source-code"><strong class="bold">●</strong><strong class="bold"> httpd.service - The Apache HTTP Server</strong>&#13;
<strong class="bold">     Loaded: loaded (/usr/lib/systemd/system/httpd.service; enabled; preset: disabled)</strong>&#13;
<strong class="bold">    Drop-In: /usr/lib/systemd/system/service.d</strong>&#13;
<strong class="bold">             └─10-timeout-abort.conf</strong>&#13;
<strong class="bold">     Active: active (running) since Sun 2024-08-25 22:14:15 EDT; 8s ago</strong>&#13;
<strong class="bold">       Docs: man:httpd.service(8)</strong>&#13;
<strong class="bold">   Main PID: 4907 (httpd)</strong>&#13;
<strong class="bold">     Status: "Started, listening on: port 443, port 80"</strong>&#13;
<strong class="bold">      Tasks: 178 (limit: 38323)</strong>&#13;
<strong class="bold">     Memory: 16.2M (peak: 17.8M)</strong>&#13;
<strong class="bold">        CPU: 115ms</strong>&#13;
<strong class="bold">     CGroup: /system.slice/httpd.service</strong>&#13;
<strong class="bold">             ├─4907 /usr/sbin/httpd -DFOREGROUND</strong>&#13;
<strong class="bold">             ├─4908 /usr/sbin/httpd -DFOREGROUND</strong>&#13;
<strong class="bold">             ├─4909 /usr/sbin/httpd -DFOREGROUND</strong>&#13;
<strong class="bold">             ├─4910 /usr/sbin/httpd -DFOREGROUND</strong>&#13;
<strong class="bold">             ├─4911 /usr/sbin/httpd -DFOREGROUND</strong>&#13;
<strong class="bold">             └─4912 /usr/sbin/httpd -DFOREGROUND</strong>&#13;
<strong class="bold">Aug 25 22:14:15 bm02.local systemd[1]: Starting httpd.service - The Apache HTTP Server...</strong>&#13;
<strong class="bold">Aug 25 22:14:15 bm02.local (httpd)[4907]: httpd.service: Referenced but unset environment variable evaluates to an e&gt;</strong>&#13;
<strong class="bold">Aug 25 22:14:15 bm02.local httpd[4907]: Server configured, listening on: port 443, port 80</strong>&#13;
<code>https</code>). Since we have used a self-signed certificate, your browser will definitely not like it, and it will make you confirm that you wish to proceed to that site. Some browsers are more forgiving than others (regardless of the operating system they are run on).<p class="list-inset">Confirm in your <a id="_idIndexMarker539"/>browser window that you wish to continue by clicking the <code>https</code> and the self-signed cert.</p></li>&#13;
			</ol>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B22104_12_04.jpg" alt="Figure 12.4 – SSL warning because of the self-signed certificate" width="960" height="740"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.4 – SSL warning because of the self-signed certificate</p>&#13;
			<p class="list-inset">If all has worked as planned, you should have been able to get to your newly encrypted web server and the page should look something like this:</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B22104_12_05.jpg" alt="Figure 12.5 – HTTPS main test page" width="949" height="755"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.5 – HTTPS main test page</p>&#13;
			<ol>&#13;
				<li value="9">Now let’s test<a id="_idIndexMarker540"/> the repository URL. Remember to use HTTPS (not HTTP) in the URL. You may be prompted with the same SSL cert warnings. Drive on and confirm it’s OK (substitute your own URL – mine is shown again as an example).</li>&#13;
			</ol>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B22104_12_06.jpg" alt="Figure 12.6 – Our custom DNF repository now uses HTTPS !!!" width="479" height="216"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.6 – Our custom DNF repository now uses HTTPS !!!</p>&#13;
			<p>So, now that<a id="_idIndexMarker541"/> we’ve walked through the creation of a self-signed certificate and then taken it to make our custom DNF repository SSL-enabled, I want to impart to you yet another consideration before we close.</p>&#13;
			<p>If your solution is going to use HTTPS, please build into your interface a way for the end-user to click a button and have this process automated for them. Even better, add in the option for the appliance to automatically ingest keys and a certificate from a CA in your interface as well. These efforts are in line with the tamper-proofing and user experience topics that were covered in <a href="B22104_10.xhtml#_idTextAnchor305"><em class="italic">Chapter 10</em></a>. We should always strive to provide our end-users with a positive user experience when using our appliance.</p>&#13;
			<p>In this section, we secured the HTTPS service with encryption and a certificate. Let’s move on to our next section, where we will review tools for securing all of the actual network connections to services and por<a id="_idTextAnchor386"/>ts of your appliance.</p>&#13;
			<h1 id="_idParaDest-193"><a id="_idTextAnchor387"/>Confirming that your networking is secure</h1>&#13;
			<p>Almost all machines at some level communicate with other machines. In the embedded Linux systems space, this <a id="_idIndexMarker542"/>may not always be true. Some appliances are simply standalone solutions that are not connected to any network. In other use cases, the security posture of where they may reside might dictate that they are on a heavily restricted LAN segment that has limited access to other systems and no access whatsoever to the internet or other segments of the enterprise.</p>&#13;
			<p>Network configuration and securitization are intrinsic to basic Linux systems administration. But we are not designing systems to reside within our own datacenter or network. We are building products that will reside in a customer’s ecosystem, whatever level of security that might entail. Our customers have placed a level of trust and responsibility in our hands to ensure that what we deliver to them is already locked down and secure. Oftentimes, more so than what their own limited staff might have had the skills to perform. That’s why they are buying your solution.</p>&#13;
			<p>In the next few blocks, we’ll very briefly cover command-line and graphical tools that I truly hope you already know. My reasoning is blunt and simple. Use what works for your team, your environment, and your company’s build chain style. I am actually hoping that this section is redundant and unnecessary for you. Even better if it actually helps a little. Let’s move on to do a quick review of how we can prepare our appliances (somewhat) for their new homes by using tools to secure what traffic may pass in our next secti<a id="_idTextAnchor388"/>on covering firewalls.</p>&#13;
			<h2 id="_idParaDest-194"><a id="_idTextAnchor389"/>Firewalls</h2>&#13;
			<p>Here’s a <a id="_idIndexMarker543"/>quick breakdown of some of the major settings groups for <a id="_idIndexMarker544"/>Linux firewalls:</p>&#13;
			<ul>&#13;
				<li><strong class="bold">Connection</strong>: This is a defined <em class="italic">named</em> network connection.</li>&#13;
				<li><strong class="bold">Zone</strong>: A firewalld zone is a predefined level of trust for you to leverage.</li>&#13;
				<li><strong class="bold">Interface</strong>: This one is pretty self-explanatory. It’s the interface that you plan to apply new settings onto.</li>&#13;
				<li><strong class="bold">Services</strong>: These are predefined services that can be made accessible. Having them predefined<a id="_idIndexMarker545"/> absolutely helps in the configuration process as memorizing every service to port mapping and whether it’s UDP or TCP can be daunting.</li>&#13;
				<li><strong class="bold">Ports</strong>: This is a fast way of defining multiple ports or ranges to make them accessible.</li>&#13;
				<li><strong class="bold">Configuration</strong>: There are two possible selections for the state of the configuration that you may be editing – <strong class="bold">runtime</strong> and <strong class="bold">permanent</strong>. Runtime state changes are lost after a reboot or after a<a id="_idIndexMarker546"/> restart of the <strong class="bold">firewalld</strong> service.</li>&#13;
				<li><strong class="bold">IPSets</strong>: These are whitelists or blacklists that you can manage and easily deploy.</li>&#13;
			</ul>&#13;
			<p>There are several different <a id="_idIndexMarker547"/>ways of configuring a Linux firewall (firewalld). Let’s br<a id="_idTextAnchor390"/>owse through some examples.</p>&#13;
			<h2 id="_idParaDest-195"><a id="_idTextAnchor391"/>The command line</h2>&#13;
			<p>The <a id="_idIndexMarker548"/>command-line tools for managing firewalls are virtually always installed for you when you build a new system. The main tool we’ll highlight <a id="_idIndexMarker549"/>here is <strong class="bold">firewall-cmd</strong>. As you can see from the <em class="italic">massively truncated</em> listing of all the possible settings, firewall-cmd is a feature-rich toolset. It can easily be scripted as well.</p>&#13;
			<p>For an example of all the options, one could run the following command in a terminal.</p>&#13;
			<pre class="console">&#13;
$ firewall-cmd --help</pre>			<p>The output of that command is rather lengthy. I’d recommend that you study it on your own machine, pipe the output to the more or less command, and then page your way through it.</p>&#13;
			<pre class="console">&#13;
Usage: firewall-cmd [OPTIONS...]&#13;
General Options&#13;
  -h, --help        Prints a short help text and exits&#13;
  -V, --version     Print the version string of firewalld&#13;
  -q, --quiet       Do not print status messages&#13;
Status Options&#13;
  --state           Return and print firewalld state&#13;
((( output truncated )))&#13;
Options to Handle Bindings of Sources&#13;
  --list-sources    List sources that are bound to a zone&#13;
                    [P] [Z]&#13;
  --add-source=&lt;source&gt;[/&lt;mask&gt;]|&lt;MAC&gt;|ipset:&lt;ipset&gt;&#13;
                    Bind the source to a zone [P] [Z]&#13;
  --change-source=&lt;source&gt;[/&lt;mask&gt;]|&lt;MAC&gt;|ipset:&lt;ipset&gt;&#13;
                    Change zone the source is bound to [Z]&#13;
  --query-source=&lt;source&gt;[/&lt;mask&gt;]|&lt;MAC&gt;|ipset:&lt;ipset&gt;&#13;
                    Query whether the source is bound to a&#13;
                    zone [P] [Z]&#13;
  --remove-source=&lt;source&gt;[/&lt;mask&gt;]|&lt;MAC&gt;|ipset:&lt;ipset&gt;&#13;
                    Remove binding of the source from a&#13;
                    zone [P] [Z]&#13;
Helper Options&#13;
  --new-helper=&lt;helper&gt; --module=&lt;module&gt; [--family=&lt;family&gt;]&#13;
                    Add a new helper [P only]&#13;
  --new-helper-from-file=&lt;filename&gt; [--name=&lt;helper&gt;]&#13;
                    Add a new helper from file with optional name [P only]&#13;
  --delete-helper=&lt;helper&gt;&#13;
                    Delete an existing helper [P only]&#13;
  --load-helper-defaults=&lt;helper&gt;&#13;
                    Load helper default settings [P only]&#13;
  --info-helper=&lt;helper&gt; Print information about an helper&#13;
(((output truncated)))&#13;
Lockdown Options&#13;
  --lockdown-on      Enable lockdown.&#13;
  --lockdown-off     Disable lockdown.&#13;
  --query-lockdown   Query whether lockdown is enabled&#13;
Lockdown Whitelist Options&#13;
  --list-lockdown-whitelist-commands&#13;
                     List all command lines that are on the&#13;
                     whitelist [P]&#13;
  --add-lockdown-whitelist-command=&lt;command&gt;&#13;
                     Add the command to the whitelist [P]&#13;
(((output truncated)))&#13;
Panic Options&#13;
  --panic-on         Enable panic mode&#13;
  --panic-off        Disable panic mode&#13;
  --query-panic      Query whether panic mode is enabled</pre>			<p>The <a id="_idIndexMarker550"/>command line is the greatest and most flexible way to set firewall parameters, but let’s be honest, it will take a bit of skill to master it. This methodology is the preferred method by sysadmins around the world as it can be scripted and easily repeated. It’s the ease of scripting that will aid your team greatly in making such functionality behind the scenes from the end-users of your solution.</p>&#13;
			<p>Let’s take a look at some other alternative mea<a id="_idTextAnchor392"/>ns to configure your firewall.</p>&#13;
			<h2 id="_idParaDest-196"><a id="_idTextAnchor393"/>Web console</h2>&#13;
			<p>The <strong class="bold">web console</strong> has<a id="_idIndexMarker551"/> been evolving rapidly over the <a id="_idIndexMarker552"/>past few years by extending its basic sysadmin functionality to creating systems images or managing containers or virtual machines. The further enhancement of the web console has lowered the bar for admins of other platforms to get comfortable in the management of Linux systems when their skills were rooted in other platforms.</p>&#13;
			<p>Here’s an example screenshot of the web console (aka Cockpit) running on Fedora 40. Under the <strong class="bold">Networking</strong> submenu, we can easily modify the firewall rules as well as configure connections and other networking settings.</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B22104_12_07.jpg" alt="Figure 12.7 – Configuring a firewall via the web console" width="1422" height="729"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.7 – Configuring a firewall via the web console</p>&#13;
			<p>The <a id="_idIndexMarker553"/>web console is great for configuring your own systems in a lab or datacenter environment; however, I strongly recommend avoiding this from being used by your end-users on your appliances as it will require administrative privileges to do most tasks… And now we’re back to the childproofing discussion again. Let’s move on to a quick review of graphi<a id="_idTextAnchor394"/>cal UI tools for your firewall.</p>&#13;
			<h2 id="_idParaDest-197"><a id="_idTextAnchor395"/>Graphical UI-based tools</h2>&#13;
			<p>In Fedora (and most Linux distributions), there are actually multiple graphical firewall configuration<a id="_idIndexMarker554"/> tools. Any can be installed via the gnome-software application or via the command line. These tools make configuring and managing the firewall vastly easier than trying to memorize the thousands of options found within the command line.</p>&#13;
			<p>Please note that when you search for tools to manage your firewall, gnome-software (the app store within the Gnome desktop) also offers up the web console (Cockpit) as a solution.</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B22104_12_08.jpg" alt="Figure 12.8 – Searching for software via the gnome-software GUI" width="631" height="498"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.8 – Searching for software via the gnome-software GUI</p>&#13;
			<p>Here’s what the<a id="_idIndexMarker555"/> firewall management GUI looks like while running it within the Gnome desktop environment GUI.</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B22104_12_09.jpg" alt="Figure 12.9 – The firewall GUI" width="1650" height="902"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.9 – The firewall GUI</p>&#13;
			<p>My stance <a id="_idIndexMarker556"/>on these GUI-based firewall tools is the same as with the web console. They’re great in the datacenter and the lab but I wouldn’t give an end-user of an appliance access to them. Ever. Seriously.</p>&#13;
			<p>Should your appliance provide services that may require the end-user to open additional ports on your appliance, you should automate and build into your interface anything that might possibly require the end-user to have root access – just like we covered in depth in <a href="B22104_10.xhtml#_idTextAnchor305"><em class="italic">Chapter 10</em></a>. This isn’t just tamper-proofing. You should think of it as futureproofing, or even better, enhancing the user experience.</p>&#13;
			<p>Honestly, it’s doubtful anyone will actually care which tools you used or didn’t use to configure your appliance. Here’s where we shift from configuring the firewall to confirming that what you think you’ve configured is the actual state of your appliance. This is where I (again) remind you of that old saying, <em class="italic">Trust, but verify</em>. Trust in your team’s efforts but verify that what you think you have configured is what the appliance’s state actually is. I greatly recommend automating this where you find it appropriate, but <a id="_idIndexMarker557"/>make sure that human hands still touch the appliance, human eyes inspect the appliance, and all is well documented for each unit.</p>&#13;
			<p>Let’s move on to activities that should always be religiously enacted at the end of your build or upgrade cycles. Let’s revie<a id="_idTextAnchor396"/>w the validation of your solution.</p>&#13;
			<h1 id="_idParaDest-198"><a id="_idTextAnchor397"/>Limitations of legacy hardware and software</h1>&#13;
			<p>Here’s where<a id="_idIndexMarker558"/> I feel compelled to deliver some bad news. You may not always have a choice in which hardware, connectivity methods, or buses your solution leverages. The long-term supportability of your solution may force you and your team to implement something less than ideal in order to maintain backward and forward compatibility (a perfect example is the CAN bus).</p>&#13;
			<p>Older, legacy hardware wouldn’t be so bad if there wasn’t a common practice for deprecating driver support for extremely old or unsupported chipsets. This means that one could be forced to use unsupported drivers that are not included in your operating system, that may not have been updated for a significant amount of time, or that come from an unreliable source. Unsupported drivers (software) may also mean that there are risks and vulnerabilities that are not addressed. It’s a ticking time bomb.</p>&#13;
			<p>A compounding problem is that newer operating systems tend to require much newer components. It seems that with each new release of Linux (regardless of distribution), we get vastly more capabilities and functions. These new bells and whistles come with a price tag – newer, more powerful hardware.</p>&#13;
			<p>Why does using the most current hardware and software matter? Here’s a real-world example: most cars, short of catastrophic accidents, can realistically be on the road for many years and outlive their computer subsystems’ normal lifecycle. That’s just one example among countless possibilities.</p>&#13;
			<p>Security starts at the design table, but that doesn’t mean that you’ll always have the best components (hardware or software) to choose from. Keep in mind there will be limits.</p>&#13;
			<h1 id="_idParaDest-199"><a id="_idTextAnchor398"/>Validating your solution before shipping</h1>&#13;
			<p>As we have progressed in our journey to secure our solution as much as possible, there are still some critical activities that must be completed before you can confidently ship your solution. These should be considered non-negotiable. Ignore them at your peril.</p>&#13;
			<p>First is compliance integrations and testing, where you’ll confirm that your appliance meets or exceeds any government or industry standards that may be applicable within the domain it will be used. I feel this is such a crucial subject, that the entire next chapter is dedicated to it entirely.</p>&#13;
			<p>Secondly, <strong class="bold">penetration testing</strong> (aka <strong class="bold">pen-testing</strong>) by a <a id="_idIndexMarker559"/>third party can give you peace of mind and detailed insights as to anything you may have overlooked. In this scenario, a professional ethical hacker (contractor) would leverage all the tools of the trade in an attempt to gain unauthorized access or degrade the usability of the appliance. Passing this type of testing will be a testament to your team’s success and the brightness of your product’s future.</p>&#13;
			<p>Let’s move on to our end-of-chapter summary.</p>&#13;
			<h1 id="_idParaDest-200"><a id="_idTextAnchor399"/>Summary</h1>&#13;
			<p>What is attached to your solution and what it communicates with absolutely matters. These communications will also dictate what security concerns need to be addressed proactively. In this chapter, we’ve toured a key group of buses and connection types that you are most likely to encounter along with their unique use cases. As we progressed, we reviewed a critical set of securitizations – your firewall and encryption for your web traffic. These activities require a special amount of attention to detail. The knowledge gained in this chapter should empower you and your team to prepare for and design for such connectivity risks. We then closed out the chapter with a simple reminder that you may have to worry about forward and backward compatibility, which will impact your security profile.</p>&#13;
			<p>Again, I’d like to thank you for continuing this journey with me. In the next chapter, we’ll be diving headfirst into applying security standards to our solutions.</p>&#13;
		</div>&#13;
	</div></div></body></html>