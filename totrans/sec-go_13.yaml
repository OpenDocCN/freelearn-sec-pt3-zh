- en: Post Exploitation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Post exploitation refers to the phase of a penetration test where a machine
    has already been exploited and code execution is available. The primary task is
    generally to maintain persistence so that you can keep a connection alive or leave
    a way to reconnect later. This chapter covers some common techniques for persistence;
    namely, bind shells, reverse bind shells, and web shells. We will also look at
    cross compiling, which is incredibly helpful when compiling shells for different
    operating systems from a single host.
  prefs: []
  type: TYPE_NORMAL
- en: Other objectives during the post exploit phase include finding sensitive data,
    making changes to files, and hiding your tracks so that forensic investigators
    will not be able to find evidence. You can cover your tracks by changing timestamps
    on files, modifying permissions, disabling shell history, and removing logs. This
    chapter covers some techniques for finding interesting files and covering tracks.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 4](1368accc-3f1c-4034-948f-009147d26eab.xhtml), *Forensics*, is closely
    related because performing a forensic investigation is not that different from
    exploring a freshly exploited machine. Both tasks are about learning what is on
    the system and finding interesting files. Similarly, [Chapter 5](e69a87b2-99ff-47cf-a935-4ef39304ed15.xhtml),
    *Packet Capturing and Injection*, is useful for doing network analysis from an
    exploited host. Many of the tools such as finding large files or finding recently
    modified files are helpful during this phase too. Refer to [Chapter 4](1368accc-3f1c-4034-948f-009147d26eab.xhtml),
    *Forensics*, and [Chapter 5](e69a87b2-99ff-47cf-a935-4ef39304ed15.xhtml), *Packet
    Capturing and Injection*, for more examples that can be used during the post exploitation
    phase.'
  prefs: []
  type: TYPE_NORMAL
- en: The post exploitation phase covers a wide variety of tasks, including privilege
    escalation, pivoting, stealing or destroying data, and host and network analyses.
    Because the scope is so broad and varies widely depending on the type of system
    you have exploited, this chapter focuses on a narrow scope of topics that should
    be useful in most scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: When going through these exercises, try to look at things from the perspective
    of an attacker. Taking on this mindset while working through the examples will
    help you understand how to better protect your systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Cross compiling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bind shells
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reverse bind shells
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Web shells
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding files with write permissions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modifying file timestamps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modifying file permissions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modifying file ownership
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cross compiling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cross compiling is a feature that comes with Go and is very easy to use. It
    can be particularly useful if you are on a Linux machine performing a penetration
    test and you need to compile a custom reverse shell that will run on a Windows
    machine that you compromised.
  prefs: []
  type: TYPE_NORMAL
- en: You can target several architectures and operating systems, and all you need
    to do is modify an environment variable. There is no need for any extra tools
    or compilers. Everything is built in for Go.
  prefs: []
  type: TYPE_NORMAL
- en: Simply change the `GOARCH` and `GOOS` environment variables to match your desired
    build target. You can build for Windows, Mac, Linux, and more. You can also build
    for the prominent 32-bit and 64-bit desktop processors as well as ARM and MIPS
    for devices such as the Raspberry Pi.
  prefs: []
  type: TYPE_NORMAL
- en: 'As of this writing, the possible values for `GOARCH` are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `386` | `amd64` |'
  prefs: []
  type: TYPE_TB
- en: '| `amd64p32` | `arm` |'
  prefs: []
  type: TYPE_TB
- en: '| `armbe` | `arm64` |'
  prefs: []
  type: TYPE_TB
- en: '| `arm64be` | `ppc64` |'
  prefs: []
  type: TYPE_TB
- en: '| `ppc64le` | `mips` |'
  prefs: []
  type: TYPE_TB
- en: '| `mipsle` | `mips64` |'
  prefs: []
  type: TYPE_TB
- en: '| `mips64le` | `mips64p32` |'
  prefs: []
  type: TYPE_TB
- en: '| `mips64p32le` | `ppc` |'
  prefs: []
  type: TYPE_TB
- en: '| `s390` | `s390x` |'
  prefs: []
  type: TYPE_TB
- en: '| `sparc` | `sparc64` |'
  prefs: []
  type: TYPE_TB
- en: 'The options for `GOOS` are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `android` | `darwin` |'
  prefs: []
  type: TYPE_TB
- en: '| `dragonfly` | `freebsd` |'
  prefs: []
  type: TYPE_TB
- en: '| `linux` | `nacl` |'
  prefs: []
  type: TYPE_TB
- en: '| `netbsd` | `openbsd` |'
  prefs: []
  type: TYPE_TB
- en: '| `plan9` | `solaris` |'
  prefs: []
  type: TYPE_TB
- en: '| `windows` | `zos` |'
  prefs: []
  type: TYPE_TB
- en: Note that not every architecture can be used with every operating system. Refer
    to the Go official documentation ([https://golang.org/doc/install/source#environment](https://golang.org/doc/install/source#environment))
    to know which architectures and operating systems can be combined.
  prefs: []
  type: TYPE_NORMAL
- en: If you are targeting the ARM platform, you can optionally specify the ARM version
    by setting the `GOARM` environment variable. A reasonable default is chosen automatically,
    and it is recommended that you do not change it. The possible `GOARM` values are
    `5`, `6`, and `7`, at the time of this writing.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Windows, set the environment variables in Command Prompt, as given here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In Linux/Mac you can also set the environment variables in a number of ways,
    but you can specify it for a single build command like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Read more about environment variables and cross compiling at [https://golang.org/doc/install/source#environment](https://golang.org/doc/install/source#environment).
  prefs: []
  type: TYPE_NORMAL
- en: This method of cross compiling was introduced with Go 1.5\. Before that, a shell
    script was provided by the Go developers, but it is no longer supported, and it
    is archived at [https://github.com/davecheney/golang-crosscompile/tree/archive](https://github.com/davecheney/golang-crosscompile/tree/archive).
  prefs: []
  type: TYPE_NORMAL
- en: Creating bind shells
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Bind shells are programs that bind to a port and listen for connections and
    serves shells. Whenever a connection is received, it runs a shell, such as Bash,
    and passes off the standard input, output, and error handles to the remote connection.
    It can listen forever and serve shells to multiple incoming connections.
  prefs: []
  type: TYPE_NORMAL
- en: Bind shells are useful when you want to add persistent access to a machine.
    You can run the bind shell and then disconnect or inject the bind shell into memory
    through a remote code execution vulnerability.
  prefs: []
  type: TYPE_NORMAL
- en: The biggest problem with bind shells is that firewalls and the NAT routing can
    prevent direct remote access to the computer. Incoming connections are usually
    blocked or routed in a way that prevent connecting to the bind shell. For this
    reason, reverse bind shells are often used. The next section covers reverse bind
    shells.
  prefs: []
  type: TYPE_NORMAL
- en: When compiling this example on Windows, it comes out to 1,186 bytes. Considering
    that some shells written in C/Assembly can be under 100 bytes, it could be considered
    relatively large. If you are exploiting an application, you may have very limited
    space to inject a bind shell. You could make the example smaller by omitting the
    `log` package, removing the optional command-line arguments, and ignoring errors.
  prefs: []
  type: TYPE_NORMAL
- en: TLS can be used instead of plaintext by swapping `net.Listen()` with `tls.Listen()`.
    [Chapter 6](f68073f0-8cc8-40b5-af0e-795ce30e5271.xhtml), *Cryptography*, has an
    example of a TLS client and server.
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces are a powerful feature of Go, and their convenience is exemplified
    here with the reader and writer interfaces. The only requirement to satisfy the
    reader and writer interfaces is to implement the `.Read()` and `.Write()` functions,
    respectively, for the type. Here, the network connection implements the `Read()`
    and `Write()` functions and so does `exec.Command`. We tie the reader and writer
    interfaces together easily because of the shared interfaces they implement.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this next example, we look at creating a bind shell for Linux, using the
    built-in `/bin/sh` shell. It will bind and listen for connections, serving a shell
    to anyone who connects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Creating reverse bind shells
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reverse bind shells overcome the firewall and NAT issue. Instead of listening
    for incoming connections, it dials out to a remote server (one you control and
    are listening on). When you get the connection on your machine, you have a shell
    that is running on the computer behind the firewall.
  prefs: []
  type: TYPE_NORMAL
- en: This example uses plaintext TCP sockets, but you can easily swap `net.Dial()`
    with `tls.Dial()`. [Chapter 6](f68073f0-8cc8-40b5-af0e-795ce30e5271.xhtml), *Cryptography*,
    has examples of a TLS client and server if you want to modify these examples to
    use TLS.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Creating web shells
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A web shell is similar to a bind shell, but, instead of listening as a raw TCP
    socket, it listens and communicates as an HTTP server. It is a useful method of
    creating persistent access to a machine.
  prefs: []
  type: TYPE_NORMAL
- en: One reason a web shell may be necessary, is because of firewalls or other network
    restrictions. HTTP traffic may be treated differently than other traffic. Sometimes
    the `80` and `443` ports are the only ports allowed through a firewall. Some networks
    may inspect the traffic to ensure that only HTTP formatted requests are allowed
    through.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that using plain HTTP means the traffic can be logged in plaintext.
    HTTPS can be used to encrypt the traffic, but the SSL certificate and key are
    going to reside on the server so that a server admin will have access to it. All
    you need to do to make this example use SSL is to change `http.ListenAndServe()`
    to `http.ListenAndServeTLS()`. An example of this is provided in [Chapter 9](f15910a1-239e-49a5-b4d9-3881a524bfa9.xhtml),
    *Web Applications*.
  prefs: []
  type: TYPE_NORMAL
- en: The convenient thing about a web shell is that you can use any web browser and
    command-line tools, such as `curl` or `wget`. You could even use `netcat` and
    manually craft an HTTP request. The drawback is that you don't have a truly interactive
    shell, and you can send only one command at a time. You can run multiple commands
    with one string if you separate multiple commands with a semicolon.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can manually craft an HTTP request in `netcat` or a custom TCP client like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This would be similar to the request that is created by a web browser. For example,
    if you ran `webshell localhost:8080`, you could access the URL on port `8080`,
    and run a command with `http://localhost:8080/?cmd=df`.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the `/bin/sh` shell command is for Linux and Mac. Windows uses the
    `cmd.exe` Command Prompt. In Windows, you can enable Windows Subsystem for Linux
    and install Ubuntu from the Windows store to run all of these Linux examples in
    a Linux environment without installing a virtual machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this next example, the web shell creates a simple web server that listens
    for requests over HTTP. When it receives a request, it looks for the `GET` query
    named `cmd`. It will execute a shell, run the command provided, and return the
    results as an HTTP response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Finding writable files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once you gain access to a system, you want to start exploring. Typically, you
    will look for ways to escalate your privilege or maintain persistence. A great
    way to look for methods of persistence is to identify which files have write permissions.
  prefs: []
  type: TYPE_NORMAL
- en: You can look at the file permission settings and see if you or everyone has
    write permission. You can look explicitly for modes such as `777`, but a better
    way is to use a bitmask and look specifically at the write permission bits.
  prefs: []
  type: TYPE_NORMAL
- en: 'The permissions are represented by several bits: the user permissions, group
    permissions, and finally, the permissions for everyone. The string representation
    of a `0777` permission would look like this: `-rwxrwxrwx`. The bit we are interested
    in is the one that gives everyone the write permission, which is represented by
    `--------w-`.'
  prefs: []
  type: TYPE_NORMAL
- en: The second bit is the only one we care about, so we will use a bitwise AND to
    mask the file's permission with `0002`. If the bit was set, it will remain the
    only bit set. If it was off, it remains off and the entire value will be `0`.
    To check the write bit for the group or the user, you could bitwise AND with `0020`
    and `0200` respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'To search recursively through a directory, Go provides a `path/filepath` package
    in the standard library. This function simply takes a starting directory and a
    function. It performs the function on every file found. The function it expects
    is actually a specially defined type. It is defined like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As long as you create a function that matches this format, your function will
    be compatible with the `WalkFunc` type and can be used in the `filepath.Walk()`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this next example, we will walk-through a starting directory and check the
    file permissions of each file. We will also cover subdirectories. Any file that
    is writable by your current user will be printed to the standard output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Changing file timestamp
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the same way you can modify file permissions, you can modify the timestamps
    to make it look like it was modified in the past or in the future. This can be
    useful for covering your tracks and making it look like a file that has not been
    accessed in a long time or set it for a future date to confuse forensic investigators.
    The Go `os` package contains the utilities for modifying files.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this next example, a file''s timestamp is modified to look like it was modified
    in the future. You can tweak the `futureTime` variable to make a file look like
    it has been modified to any specific time. This example provides a relative time
    by adding 50 hours and 15 minutes to the current time, but you can also specify
    an absolute time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Changing file permissions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Changing the permission of a file so that you can access it later from a lower-privileged
    user may also be useful. This example demonstrates how to change file permissions
    using the `os` package. You can change file permissions easily using the `os.Chmod()`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: This program is named `chmode.go` so that it does not conflict with the default
    `chmod` program provided on most systems. It has the same basic functionality
    as `chmod`, but without any extra features.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `os.Chmod()` function is straightforward, but it must be provided an `os.FileMode`
    type. The `os.FileMode` type is simply a `uint32` type so that you can provide
    it a `uint32` literal (a hardcoded number) or you will have to ensure that the
    file mode value you provide is casted to an `os.FileMode` type. In this example,
    we will take the string value provided from the command line (for example, `"777"`)
    and convert it to an unsigned integer. We will tell `strconv.ParseUint()` to treat
    it as a base 8 octal number instead of a base 10 decimal number. We also provide
    `strconv.ParseUint()` a parameter of 32 so that we get a 32-bit number back instead
    of 64-bit number. After we have an unsigned 32-bit integer from the string value,
    we will cast it to an `os.FileMode` type. This is how `os.FileMode` is defined
    in the standard library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In this next example, a file''s permissions are changed to the value provided
    as a command-line argument. It behaves similarly to the `chmod` program in Linux
    and accepts permissions in octal format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Changing file ownership
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This program will take the file provided and change the user and group ownership.
    This could be used in tandem with the example that finds files that you have permission
    to modify.
  prefs: []
  type: TYPE_NORMAL
- en: Go provides `os.Chown()` in the standard library, but it does not accept string
    values for the user and group names. The user and group must be provided as integer
    ID values. Fortunately, Go also comes with an `os/user` package that contains
    functions for looking up an ID based on a name. These functions are `user.Lookup()`
    and `user.LookupGroup()`.
  prefs: []
  type: TYPE_NORMAL
- en: You could look up your own user and group information on Linux/Mac with the
    `id`, `whoami`, and `groups` commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that this does not work on Windows because ownership is treated differently.
    The following is the code implementation of this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having reading this chapter, you should now have a high-level understanding
    of the post exploitation phase of an attack. By working through the examples and
    taking on the mindset of an attacker, you should have developed a better understanding
    of how to protect your files and network. It is primarily about persistence and
    information gathering. You can also use an exploited machine to perform all of
    the examples from [Chapter 11](25a78b3b-7295-4deb-9297-a1803c2edb71.xhtml), *Host
    Discovery and Enumeration*.
  prefs: []
  type: TYPE_NORMAL
- en: The bind shell, reverse bind shell, and web shell were examples of techniques
    attackers use to maintain persistence. Even if you never need to employ a bind
    shell, it is important to understand what it is and how attackers use it if you
    want to identify malicious behavior and keep your systems secure. You can use
    the port-scanning examples from [Chapter 11](25a78b3b-7295-4deb-9297-a1803c2edb71.xhtml),
    *Host Discovery and Enumeration*, to search for machines with a listening bind
    shell. You can use packet capturing from [Chapter 5](e69a87b2-99ff-47cf-a935-4ef39304ed15.xhtml),
    *Packet Capturing and Injection*, to look for outgoing reverse bind shells.
  prefs: []
  type: TYPE_NORMAL
- en: Finding writable files gives you the tools necessary to look through a filesystem.
    The `Walk()` function demonstration is incredibly powerful and can be adapted
    for many use cases. You can easily adapt it to search for files with different
    characteristics. For example, maybe you want to narrow down the search to look
    for files that are owned by root but also writable to you, or you want to find
    files of a certain extension.
  prefs: []
  type: TYPE_NORMAL
- en: What other things would you look for on a machine that you just gained access
    to? Can you think of any other methods of regaining access once you disconnect?
    Cron jobs are one way you can execute code, if you find a cron job that executes
    a script that you have write access to. If you are able to modify a cron script,
    then you could potentially have a reverse shell call out to you every day so that
    you don't have to maintain an active session, which is easier to find using a
    tool such as `netstat` to identify established connections.
  prefs: []
  type: TYPE_NORMAL
- en: Remember, be responsible whenever testing or performing a penetration test.
    Even if you have a full scope, it is imperative that you understand the possible
    consequences of any actions you take. For example, if you are performing a penetration
    test for a client, and you have full scope, you may find a vulnerability on a
    production system. You may consider installing a bind shell backdoor to prove
    you can maintain persistence. If we consider a production server that faces the
    internet, it would be very irresponsible to leave a bind shell open to the whole
    internet with no encryption and no password on a production system. If you are
    ever unsure about the repercussions of certain software or certain commands, don't
    be afraid to ask others who are knowledgeable.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will recap the topics you have learned throughout this
    book. I will provide some more thoughts on the use of Go for security, which I
    hope you take away from this book, and we will talk about where to go from here
    and where to find help. We will also reflect once more on the legal, ethical,
    and technical boundaries involved with using the information from this book.
  prefs: []
  type: TYPE_NORMAL
