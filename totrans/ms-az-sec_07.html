<html><head></head><body>
		<div><h1 id="_idParaDest-97"><em class="italic">Chapter 5</em>: <a id="_idTextAnchor099"/>Azure Key Vault</h1>
			<p>When talking about cloud computing, discussions are often directed towards data protection, encryption, compliance, data loss (and data loss prevention), trust, and other buzzwords that center around the same group of topics. What they all have in common is the need for a trusted service that helps them to secure cloud data without giving a cloud vendor access to both<a id="_idTextAnchor100"/> your data and the corresponding encryption keys. Let's imagine that you want to create an Azure resource, like a virtual machine, that you will need admin credentials for. In this case, you don't want to hard code usernames and passwords in your deployment script or template, do you? This is a scenario where Azure Key Vault comes into play. In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Understanding Azure Key Vault</li>
				<li>Understanding service-to-service authentication</li>
				<li>Using Azure Key Vault in deployment scenarios</li>
			</ul>
			<h1 id="_idParaDest-98"><a id="_idTextAnchor101"/>Understanding Azure Key Vault</h1>
			<p>Azure Key Vault is a secure, cloud-based storage solution for keys, secrets, and certificates. Tokens, passwords, certificates, API keys, and other secrets can be securely stored and <a id="_idIndexMarker288"/>access to them can be granularly controlled using Azure Key Vault. The service can also be used as a key-management solution. Azure Key Vault makes it easy to create and control the encryption keys that are used to encrypt your data. Another usage scenario is Secure Sockets Layer/Transport Layer Security (SSL/TLS) certificate enrolment and management. You can use Azure Key Vault to address certificate lifecycle management for both Azure and internally connected resources. Secrets and keys that are stored in an Azure Key Vault can be protected either by software or HSMs (hardware security modules) that are FIPS 140-2 Level 2 validated.</p>
			<p>As you have already learned, you can use Azure Key Vault to manage keys, secrets, and certificates.</p>
			<ul>
				<li>A cryptographic key is used <a id="_idIndexMarker289"/>for data encryption. Azure Key <a id="_idIndexMarker290"/>Vault represents keys as <strong class="bold">JSON Web Key</strong> (<strong class="bold">JWK</strong>) objects, which are declared as soft or hard keys. A hard key is processed in a <strong class="bold">hardware security module</strong> (<strong class="bold">HSM</strong>), whereas a soft key is processed in <a id="_idIndexMarker291"/>the software by Azure Key Vault. A soft key is still encrypted at rest using a hard key, which is stored in an HSM. Clients can <a id="_idIndexMarker292"/>either request Azure Key Vault to generate a key or import an existing RSA or <strong class="bold">elliptic</strong> <strong class="bold">curve</strong> (<strong class="bold">EC</strong>) key. RSA and EC are the algorithms that are supported by Azure Key Vault.</li>
				<li>A secret is basically <a id="_idIndexMarker293"/>a string that is encrypted and stored in Azure Key Vault. A secret can be used to securely store passwords, storage account keys, and other highly valuable strings.</li>
				<li>A certificate <a id="_idIndexMarker294"/>in Azure Key Vault is an x509 certificate <a id="_idIndexMarker295"/>that is issued by a <strong class="bold">public key infrastructure</strong> (<strong class="bold">PKI</strong>). You can either let Azure Key Vault <a id="_idIndexMarker296"/>request a certificate from a supported public <strong class="bold">certification authority</strong> (<strong class="bold">CA</strong>), which today are DigiCert and GlobalSign, or you <a id="_idIndexMarker297"/>can create a <strong class="bold">certificate signing request</strong> (<strong class="bold">CSR</strong>) within Azure Key Vault and manually let this CSR be signed by any public CA of your choice. </li>
			</ul>
			<p>In this chapter, you will learn how to work with key vault entities. But first, let's look at service-to-service authentication in Azure Key Vault, which is needed to enable other Azure services to leverage Azure Key Vault during deployment or resource-management operations.</p>
			<p>Access to an <a id="_idIndexMarker298"/>Azure key vault is granted by RBAC. That said, you need to have an Azure AD account to get access to the service, which means that you can use all the protective options for interactive authentications that were discussed in <a href="B15414_03_Final_JM_ePub.xhtml#_idTextAnchor060"><em class="italic">Chapter 3</em></a>, <em class="italic">Managing Cloud Identities</em>. Furthermore, access to items protected by Azure key vault can be restricted to only single aspects of Azure Key Vault. For example, an account could be granted access only to secrets, but not to keys or certificates, or you could grant an account only a subset of permissions, but for all entities stored in a key vault. This granular rights management, in addition to RBAC, which will only grant access to an Azure key vault (being an Azure resource), is implemented by access policies. Let's look at these policies in a little more detail in the next section.</p>
			<h2 id="_idParaDest-99"><a id="_idTextAnchor102"/>Understanding access policies</h2>
			<p>With <a id="_idIndexMarker299"/>access policies, you can granularly define who will get what level of access rights to a single Azure Key Vault instance:</p>
			<div><div><img src="img/Fig_5.1.jpg" alt="Fig. 5.1 – Azure Key Vault access policies&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Fig. 5.1 – Azure Key Vault access policies</p>
			<p>As you can see in the preceding screenshot, the user account called Tom has been granted several <a id="_idIndexMarker300"/>permissions to access keys, secrets, and certificates in the <strong class="bold">Access policies</strong> settings section of the Azure Key Vault <strong class="bold">MasteringAzSec</strong> section. Besides <a id="_idIndexMarker301"/>that, you can enable access to keys and secrets for Azure VMs, ARM, and Azure Disk Encryption. These options are necessary if you want to grant Azure VMs in your tenant read access to secrets so that they can be retrieved during VM deployments or if you want to enable Azure Resource Manager to retrieve secrets so they can be used in a template deployment. The third option specifies whether Azure Disk Encryption—a service that encrypts Azure VMs' disks using BitLocker or dm-crypt, depending on the operating system used in the Azure VM—is allowed to retrieve secrets from the Azure key vault and unwrap values from stored keys.</p>
			<p>Before we move on to learn more about service-to-service authentication with Azure Key Vault, let's first take a deeper look at what the single entities in Azure Key Vault are.</p>
			<h1 id="_idParaDest-100"><a id="_idTextAnchor103"/>Understanding service-to-service authentication</h1>
			<p>As we <a id="_idIndexMarker302"/>mentioned before, access to an Azure key vault and its entities is usually granted on a per-user basis. That said, to enable service-to-service authentication, you could create an Azure AD application with associated credentials and use this service principal to get an access token for your application. It's a pretty straightforward process:</p>
			<ol>
				<li>Go to <strong class="bold">Azure Active Directory</strong> | <strong class="bold">App registrations</strong> in the Azure portal and select <strong class="bold">New registration</strong> to start the wizard:<div><img src="img/Fig_5.2.jpg" alt="Fig. 5.2 – Creating a new app registration&#13;&#10;"/></div><p class="figure-caption">Fig. 5.2 – Creating a new app registration</p></li>
				<li>Enter a <a id="_idIndexMarker303"/>name and confirm your choice.</li>
				<li>Create a client secret by navigating to the <strong class="bold">Certificates &amp; secrets</strong> option in the app registration and then select <strong class="bold">New client secret</strong>:<div><img src="img/Fig_5.3.jpg" alt="Fig. 5.3 – Creating a new client secret&#13;&#10;"/></div><p class="figure-caption">Fig. 5.3 – Creating a new client secret</p></li>
				<li>Enter a description and decide whether the secret will expire in 1 or 2 years, or whether it will always be valid. After confirming your choices and leaving the wizard, you are presented with the new client secret and its value, which you can copy and then use for authentication:</li>
			</ol>
			<div><div><img src="img/Fig_5.4.jpg" alt="Fig. 5.4 – Your client secret&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Fig. 5.4 – Your client secret</p>
			<p>A quicker way is to use the Azure CLI. With the following command, you can simply create a new service principal with the name <code>MasteringAzSecSP</code>:</p>
			<pre>Az ad sp create-for-rbac --name MasteringAzSecSP</pre>
			<p>The engine will use default settings for the account creation, and once the process is finished, you will find the username <code>appId</code> and the client secret password in the CLI window, as shown in <a id="_idIndexMarker304"/>the following screenshot<code>:</code></p>
			<div><div><img src="img/Fig_5.5.jpg" alt="Fig. 5.5 – Using the Azure CLI to create a new service principal&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Fig. 5.5 – Using the Azure CLI to create a new service principal</p>
			<p>The service principal behaves similarly to a user account in terms of access management, which means that you can use the username (the application or client ID) as a principal when granting access to the key vault and its entities.</p>
			<p>While this approach works great, there are two downsides that come with it:</p>
			<ul>
				<li>When creating the application credentials, you will get the app ID and the client secret, which are usually hardcoded in your source code. It's a dilemma, because you cannot store these credentials in Azure Key Vault as they are needed to authenticate before being granted access to the key vault.</li>
				<li>Application credentials expire and the renewal process may cause application downtime. You don't want to use a client secret that will never expire and that is hardcoded <a id="_idIndexMarker305"/>in your source code.</li>
			</ul>
			<p>So, for automated deployments, we need another approach, which is where the <strong class="bold">Managed Identities for Azure Resources</strong> service comes into play. So let's move one step further and learn how this service can address the dilemma.</p>
			<h2 id="_idParaDest-101"><a id="_idTextAnchor104"/>Understanding Managed Identities for Azure Resources</h2>
			<p>Needing credentials to get access to services is a common problem that you will often encounter. Azure Key Vault is an important part of your application design because you can <a id="_idIndexMarker306"/>use it to securely store and manage credentials for other services. But Azure Key Vault itself is a service <a id="_idIndexMarker307"/>that requires authentication before you are granted access. With <em class="italic">Managed Identities for Azure Resources</em>, a free feature of <a id="_idIndexMarker308"/>Azure Active Directory, you can solve this dilemma. The service provides other Azure services with an automatically managed identity in Azure AD. </p>
			<p>There are two different types of managed identities within the service:</p>
			<ul>
				<li>A system-assigned <a id="_idIndexMarker309"/>managed identity is directly <a id="_idIndexMarker310"/>enabled on an instance of an Azure service. When the managed identity is enabled, Azure AD automatically creates an identity for the particular service in Azure AD that is automatically trusted by the Azure subscription that the service instance is created in. The credentials are automatically provided to the service instance after the identity is created. The identity's lifecycle is directly tied to the service's lifecycle, which means that a system-assigned managed identity is automatically removed from Azure AD when the service is deleted. </li>
				<li>A user-assigned managed identity is a manually created Azure resource. When creating <a id="_idIndexMarker311"/>a user-assigned managed <a id="_idIndexMarker312"/>identity, Azure AD will create a service principal in the Azure AD tenant that is trusted by the Azure subscription you are currently using. After creating the identity, you can assign it in one or several Azure service instances. The user-assigned managed identity's lifecycle is organized separately from the services' lifecycles that the identity is assigned to. In other words, when an Azure resource with a user-assigned managed identity is deleted, the managed identity is not automatically removed from Azure AD.</li>
			</ul>
			<p>The relationship between a system-assigned managed identity and an Azure resource is 1:1, which means that an Azure resource can only have one system-assigned managed identity and this identity is only usable by the particular service it was created for.</p>
			<p>The relationship between the user-assigned managed identity and the Azure resource is <code>n</code><code>:n</code>, which means that you can use several user-assigned managed identities with <a id="_idIndexMarker313"/>one Azure resource <a id="_idIndexMarker314"/>at the same time, and that a single <a id="_idIndexMarker315"/>user-assigned managed identity can be used by several different Azure resources.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">Microsoft provides a list of Azure services that currently support system-assigned, user-assigned, or both <a id="_idIndexMarker316"/>types of managed identities at <a href="https://docs.microsoft.com/en-us/azure/active-directory/managed-identities-azure-resources/services-support-managed-identities">https://docs.microsoft.com/en-us/azure/active-directory/managed-identities-azure-resources/services-support-managed-identities.</a></p>
			<p>The creation process of a system-assigned managed identity in the Azure portal is very easy. All Azure resources that currently support managed identities have an <strong class="bold">Identity</strong> option in the resource's <strong class="bold">Settings</strong> section: </p>
			<div><div><img src="img/Fig_5.6.jpg" alt="Fig. 5.6 – Activating a system-assigned managed identity for an Azure virtual machine&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Fig. 5.6 – Activating a system-assigned managed identity for an Azure virtual machine</p>
			<p>The following steps show you how to activate a system-assigned managed identity for an Azure virtual machine:</p>
			<ol>
				<li value="1">On the <strong class="bold">Settings</strong> page, you can choose whether you want to activate a system-assigned managed identity or whether you want to assign a user-assigned managed identity. To activate a system-assigned managed identity, you just have to set the <strong class="bold">Status</strong> toggle switch to <strong class="bold">On</strong> and then save your selection, as shown in the preceding screenshot.</li>
				<li>You will <a id="_idIndexMarker317"/>then be informed that once you confirm this configuration, a managed identity for your resource will be registered in Azure AD, and that once the process has <a id="_idIndexMarker318"/>finished, you can grant permissions to that particular managed ID. In the preceding example, I have enabled a system-assigned managed identity for an Azure VM with the name <code>DC01</code>. </li>
				<li>When creating <a id="_idIndexMarker319"/>a new key vault access policy, we can now select the identity with the same name to grant access to the key vault's entities. </li>
			</ol>
			<p>If you want to create a new user-assigned managed identity, you have to navigate to the managed identity service in the Azure portal:</p>
			<ol>
				<li value="1">To do so, go to <strong class="bold">All resources</strong> and then search for <strong class="bold">Managed Identities</strong>.</li>
				<li>Once you find the dialog, you can choose to create a new user-assigned managed identity. As mentioned before, this is a new Azure resource and therefore needs to be created in an Azure subscription and stored in an Azure resource group:<div><img src="img/Fig_5.7.jpg" alt="Fig. 5.7 – Creating a user-assigned managed identity&#13;&#10;"/></div><p class="figure-caption">Fig. 5.7 – Creating a user-assigned managed identity</p></li>
				<li>Once the <a id="_idIndexMarker320"/>user-assigned managed identity is created, you can assign it to your Azure resource, like the virtual machine we used in the preceding scenario.</li>
			</ol>
			<p>Managed identities <a id="_idIndexMarker321"/>can also be used for Azure <a id="_idIndexMarker322"/>DevOps or Terraform authentication against your Azure environment.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">You can also use the Azure CLI, PowerShell, ARM templates, and Terraform to create managed identities in Azure. You can find examples of these methods in the GitHub repository that has <a id="_idIndexMarker323"/>been created for this book, at <a href="https://github.com/PacktPublishing/Mastering-Azure-Security">https://github.com/PacktPublishing/Mastering-Azure-Security</a>.</p>
			<p>Let's assume that you only want to allow Azure resource creation via a DevOps pipeline with all related processes, such as pull requests, authoring, and so on. From a technical point of view, Azure DevOps is nothing but an application that needs to be granted access to an Azure subscription (or management group). Therefore, Azure DevOps needs a service principal that is either manually managed as an application registration with all its downsides, or that can be automatically managed using a managed identity. The same applies to Terraform, which is also just an application that needs rights in an Azure environment.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">You can use a managed identity for Terraform authentication against Azure AD; however, in this case, the managed identity is created for an Azure VM and Terraform needs to be started from within the VM so that it can make use of the ID.</p>
			<p>Now <a id="_idIndexMarker324"/>that you know how managed identities work and what options you have for service-to-service <a id="_idIndexMarker325"/>authentication, let's move one step <a id="_idIndexMarker326"/>forward and see how you can use Azure Key Vaults in your deployment scenarios.</p>
			<h1 id="_idParaDest-102"><a id="_idTextAnchor105"/>Using Azure Key Vault in deployment scenarios</h1>
			<p>Azure Key Vault is a nice service when it comes to securely storing and retrieving credentials <a id="_idIndexMarker327"/>that are needed during resource creation. It also helps you to encrypt Azure resources, such as Azure storage accounts or VM disks, with your own encryption key.</p>
			<p>In this section, we will cover several options for how to use Azure Key Vault in deployment scenarios. You will find examples for PowerShell, ARM templates, and Terraform, as these are the most common deployment tools when it comes to creating Azure resources.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">The first step you will always have to go through is to authenticate with Azure AD using a principal that has been assigned the appropriate set of access rights in the Azure environment that you want to deploy resources to, depending on the task you want to perform and the resource that is affected by it.</p>
			<p>Are you ready? Then let's start by creating a new Azure key vault and a secret that can later be used in a VM deployment scenario in the following section.</p>
			<h2 id="_idParaDest-103"><a id="_idTextAnchor106"/>Creating an Azure key vault and a secret</h2>
			<p>As with all Azure resources, you can use the Azure portal to create and manage an Azure key vault. Although it might be convenient to click through the portal, it is a better idea to <a id="_idIndexMarker328"/>use a scripting or template language for this. Azure Key Vault is a critical resource when it comes to automated deployments. Today, there is no way to <a id="_idIndexMarker329"/>granularly grant access to single items of the same type within the same key vault. You can manage levels of access to keys, secrets, and certificates, but only on a key-vault level, not on an item level. This is why you might want to create several key vaults in the same Azure subscription. Using deployment automation, you can make sure that all key vaults in your environment adhere to the rules and policies you have defined. </p>
			<h3 id="_idParaDest-104">Key vault creation in PowerShell</h3>
			<p>With PowerShell being an imperative scripting language, you need to define all the steps <a id="_idIndexMarker330"/>that are necessary in the correct order: </p>
			<ol>
				<li value="1">The first thing you need to do is to log in with an account that has the appropriate set of access rights to create a new resource group and Azure key vault instance in your Azure subscription:<pre><strong class="bold"># Login to your Azure subscription</strong>
<strong class="bold">Login-AzAccount</strong></pre></li>
				<li>You will then be prompted to enter your Azure login credentials, which are used by PowerShell to go through the next steps. After logging in, you either create a new resource group or refer to an existing one. </li>
				<li>We will now assume that a new RG will be created using the following code snippet. Before we do so, it makes sense to define all values for variables that are then used in the following script sections:<pre><strong class="bold"># Define variable values</strong>
<strong class="bold">$rgName = "myResourceGroup"</strong>
<strong class="bold">$azRegion= "WestEurope"</strong>
<strong class="bold">$kvName = "myAzKeyVault"</strong>
<strong class="bold">$secretName = "localAdmin"</strong>
<strong class="bold">$localAdminUsername = "myLocalAdmin"</strong>
<strong class="bold"># Create a new resource group in your Azure suscription</strong>
<strong class="bold">$resourceGroup = New-AzResourceGroup `</strong>
<strong class="bold">-Name $rgName `</strong>
<strong class="bold">-Location $azRegion</strong></pre></li>
				<li>Now you can move on and create a new Azure key vault:<pre><code>VaultName</code> defines the name of the Azure key vault. We are using the <code>$kvName</code> variable, which is defined at the beginning of the script.</li><li><code>ResourceGroupName</code> defines the Azure resource group that the key vault will be created in.</li><li><code>Location</code> defines the Azure region that the key vault will be created in.</li></ul></li>
			</ol>
			<p>There are also some optional parameters that are defined in the preceding section:</p>
			<ul>
				<li><code>EnabledForDeployment</code> enables the <code>Microsoft.Compute</code> resource provider to retrieve secrets from the Azure key vault during resource creation—for example, when deploying a new VM.</li>
				<li><code>EnabledForTemplateDeployment</code> enables the <strong class="bold">Azure Resource Manager</strong><em class="italic"> </em>(<strong class="bold">ARM</strong>) to get <a id="_idIndexMarker333"/>secrets for an Azure key vault when it is referenced in a template deployment, such as when you are using ARM or Terraform.</li>
				<li><code>EnabledForDiskEncryption</code> enables the <strong class="bold">Azure Disk Encryption</strong> service to get secrets and unwrap keys from an Azure key vault to use them in the disk encryption process.</li>
				<li><code>SKU</code> defines the Azure key vault's SKU (standard or premium).</li>
			</ul>
			<ol>
				<li value="5">After the <a id="_idIndexMarker334"/>Azure key vault has been created, you need to create an access policy. In the following example, we grant access <a id="_idIndexMarker335"/>rights to secrets in the new Azure key vault for the currently logged-in user account:<pre># Grant your user account access rights to Azure Key Vault secrets
Set-AzKeyVaultAccessPolicy `
	-VaultName $kvName `
	-ResourceGroupName $rgName `
	-UserPrincipalName (Get-AzContext).account.id `
	-PermissionsToSecrets get, set</pre></li>
				<li>You can then create a new key vault secret. In the following snippet, you enter the secret as a secure string in the PowerShell session:<pre># Create a new Azure Key Vault secret
$password = read-host -assecurestring
Set-AzKeyVaultSecret ` 
	-VaultName $kvName `
	-Name $secretName `
	-SecretValue $password</pre></li>
			</ol>
			<p>Congratulations! You have just created your first Azure key vault and a secret using PowerShell. Now, that you know how to create an Azure key vault and a key vault secret for your deployment scenario, we can move on to the next section, <em class="italic">Azure VM deployment</em>, in which you will learn how to use the resources that you have just created in a more complex scenario.</p>
			<h2 id="_idParaDest-105"><a id="_idTextAnchor107"/>Azure VM deployment</h2>
			<p>When deploying <a id="_idIndexMarker336"/>an Azure VM, you always <a id="_idIndexMarker337"/>need to pass local admin credentials to it during the deployment process. The downside of deploying VMs using the Azure portal is that you need to manually enter the respective local admin credentials instead of using a secret that is stored in an Azure key vault. This is only one of the reasons why infrastructure-as-code deployments <a id="_idIndexMarker338"/>definitely make sense in an enterprise environment. In this section, you will learn how to reference credentials that are stored in an Azure key <a id="_idIndexMarker339"/>vault instead of hardcoding the information in the deployment script or template.</p>
			<p>We will start by referencing a key vault secret for VM deployments using PowerShell.</p>
			<h3 id="_idParaDest-106">VM deployments with PowerShell</h3>
			<p>You can <a id="_idIndexMarker340"/>easily access secrets in an Azure key vault with PowerShell, but also with ARM templates and Terraform. Let's see how we can <a id="_idIndexMarker341"/>do this by going through the following steps: </p>
			<ol>
				<li value="1">After you have retrieved a secret, you need to create a new <code>PSCredential</code> object that can be used in the VM deployment, as follows:<pre># retrieve an Azure Key Vault secret
$secret = Get-AzKeyVaultSecret `	-VaultName $kvName `
	-Name $secretName
# Create a new PSCredential object
$cred = [PSCredential]::new($localAdminUsername,$secret.SecretValue)</pre></li>
				<li>Later, you can use this <code>PSCredential</code> object in your deployment in the respective position. This would look similar to the following code snippet:<pre>$myVM = Set-AzVMOperatingSystem ` 
	-VM $myVM `
	-Windows `
	-ComputerName $vmName `
	-Credential $cred `
	[…]</pre></li>
			</ol>
			<p>It is always a good idea to work with variables in a PowerShell script. By doing so, you can have a variable section at the beginning of the script where you can define values that change depending on your needs and the environments that the script is used in.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Since the complete VM deployment script in PowerShell consists of almost 200 lines, we have not printed it in the book, but have published it in the book's GitHub repository. </p>
			<p>PowerShell is a <a id="_idIndexMarker342"/>good way to deploy Azure resources, but being an imperative scripting language, it is not the best fit for usage in DevOps/CI/CD scenarios. This is why we will explain how to reference a key vault secret in Terraform <a id="_idIndexMarker343"/>in the next section.</p>
			<h3 id="_idParaDest-107">Referencing a key vault secret in Terraform</h3>
			<p>In <a id="_idIndexMarker344"/>Terraform, you <a id="_idIndexMarker345"/>can refer to an existing Azure <a id="_idIndexMarker346"/>object with data sources. For a key vault secret, the data <a id="_idIndexMarker347"/>source is called <code>azurerm_key_vault_secret</code>:</p>
			<pre># Azure Key Vault data source to access local admin password
data "azurerm_key_vault_secret" "mySecret" {
	name = "secretName"
	key_vault_id = "/subscriptions/GUID/resourceGroups/RGName/providers/Microsoft.KeyVault/vaults/VaultName"
}</pre>
			<p>This object can then be <a id="_idIndexMarker348"/>referenced in the <code>os_profile</code> section of a Terraform deployment template, as shown in the following screenshot:</p>
			<pre>os_profile {
	computer_name = "myVM"
	admin_username = "myLocalAdminUserName"
	admin_password = "$(data.azurerm_key_vault_secret.mySecret.value)"
}</pre>
			<p>Terraform is quite an easy way of deploying and referencing Azure resources. As you can see from the preceding examples, you simply need to define a data source and then reference it in the respective resource section of your deployment template.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">We have published a complete example for a VM deployment with Terraform in this book's GitHub repository: <a href="https://github.com/PacktPublishing/Mastering-Azure-Security">https://github.com/PacktPublishing/Mastering-Azure-Security</a></p>
			<p>ARM templates <a id="_idIndexMarker349"/>are Microsoft's way <a id="_idIndexMarker350"/>of using <a id="_idIndexMarker351"/>automatic Azure resource deployments <a id="_idIndexMarker352"/>in DevOps pipelines. This example is described in detail in the following section.</p>
			<h3 id="_idParaDest-108">Referencing a key vault secret in ARM templates</h3>
			<p>ARM templates might be the most complex way to refer to key vault secrets during a template <a id="_idIndexMarker353"/>deployment. This is because you need <a id="_idIndexMarker354"/>to use linked templates in this scenario. That said, you need to have two different template files that are used for different purposes.</p>
			<p>The main <a id="_idIndexMarker355"/>template is used as a reference to existing Azure resources, such as the Azure key vault and its <a id="_idIndexMarker356"/>secrets. In it, there is a <code>parameters</code> section that contains values that are either defined directly in the main template or passed to the template by an external call that is an Azure CLI or a PowerShell call and then passed directly to the linked template.</p>
			<p>If the <code>parameters</code> section is filled by pipeline input, it will only contain the parameters' definitions:</p>
			<pre>"parameters": {
	"vaultName": {
		"type": "string"
	},
	"vaultResourceGroup": {
		"type": "string"
	},
	"secretName": {
		"type": "string"
	}
}</pre>
			<p>If the parameters' values are defined within the main template, then this section will look like this:</p>
			<pre>"parameters": {
	"vaultName": {
		"type": "string",
		"defaultValue": "&lt;default-value-of-parameter&gt;"
	},
	"vaultResourceGroup": {
		"type": "string",
		"defaultValue": "&lt;default-value-of-parameter&gt;"
	},
	"secretName": {
		"type": "string",
		"defaultValue": "&lt;default-value-of-parameter&gt;"
	}
}</pre>
			<p>Behind <a id="_idIndexMarker357"/>the <code>parameters</code> section, there <a id="_idIndexMarker358"/>is a <code>resource</code> section in which the key vault reference is defined:</p>
			<pre>"parameters": {
	"adminPassword": {
		"reference": {
			"keyVault": {
				"id": "[resourceId(subscription().subscriptionId,  parameters('VaultResourceGroup'), 'Microsoft.KeyVault/vaults', parameters('vaultName'))]"
			},
			"secretName": "[parameters('secretName')]"
		}
	}
}</pre>
			<p>The <em class="italic">linked template</em> is used <a id="_idIndexMarker359"/>for the actual resource deployment. In <a id="_idIndexMarker360"/>this file, the <a id="_idIndexMarker361"/>local admin username is defined, but the password value is passed from the main template, as follows:</p>
			<pre>"resources": {
"parameters": {
		"adminUsername": {
			"type": "string",
			"defaultValue": "localAdminUsername",
			"metadata": {
				"description": ""
			}
		},
		"adminPassword": {
			"type": "securestring"
		}
}
}</pre>
			<p>Using <a id="_idIndexMarker362"/>ARM templates to refer to a key vault <a id="_idIndexMarker363"/>secret is a bit more complex, but also works well in DevOps pipelines.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">We have published a complete example of a VM depl<a id="_idTextAnchor108"/>oyment with ARM templates in this book's GitHub repository: <a href="https://github.com/PacktPublishing/Mastering-Azure-Security">https://github.com/PacktPublishing/Mastering-Azure-Security</a></p>
			<p>You have <a id="_idIndexMarker364"/>now learned how to use Azure key vaults and key vault secrets during automated Azure resource deployments with PowerShell, Terraform, and ARM templates. Please make sure that you take a look at this book's GitHub repository, as you will find examples of the steps that we have outlined in this chapter for your reference.</p>
			<h1 id="_idParaDest-109"><a id="_idTextAnchor109"/>Summary</h1>
			<p>Azure Key Vault is one of the many services that are underrated but very valuable when it comes to security in Azure. In this chapter, you have learned how to create Azure key vaults and their entities not only with the Azure portal, but also with scripting and deployment languages. You now know how to grant access to an Azure key vault for both individual users and Azure resources and how to reference items that have been securely stored in a key vault. </p>
			<p>In the next chapter, we will address data security and encryption, two topics that are heavily dependent on Azure Key Vault, so make sure that you have read and understood this chapter before moving on.</p>
			<h1 id="_idParaDest-110"><a id="_idTextAnchor110"/>Questions</h1>
			<ol>
				<li value="1">Azure Key Vault is used to secure…<p>A. Keys</p><p>B. Secrets</p><p>C. Certificates</p><p>D. All of the above</p><p>E. None of the above</p></li>
				<li>How do we control who can access Azure Key Vault information?<p>A. Key Vault permissions</p><p>B. Access policies</p><p>C. Conditional access</p></li>
				<li>Service-to-service authentication is done via…<p>A. Service principal</p><p>B. Certificate</p><p>C. Direct link</p></li>
				<li>In order to use Azure Key Vault for <code>EnabledForDeployment</code></p><p>B. <code>EnabledForTemplateDeployment</code></p><p>C. <code>EnabledForDiskEncryption</code></p></li>
				<li>In order to use Azure Key Vault for <code>EnabledForDeployment</code></p><p>B. <code>EnabledForTemplateDeployment</code></p><p>C. <code>EnabledForDiskEncryption</code></p></li>
				<li>In order to use Azure Key Vault for VM encryption, which option do we need to enable?<p>A. <code>EnabledForDeployment</code></p><p>B. <code>EnabledForTemplateDeployment</code></p><p>C. <code>EnabledForDiskEncryption</code></p></li>
				<li>In order to secure secrets during deployment, we need to…<p>A. Provide a password</p><p>B. Encrypt a password</p><p>C. Reference an Azure key vault</p></li>
			</ol>
		</div>
	</body></html>