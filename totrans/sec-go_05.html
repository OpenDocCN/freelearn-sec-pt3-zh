<html><head></head><body>
        

                            
                    <h1 class="header-title">Packet Capturing and Injection</h1>
                
            
            
                
<p>Packet capturing is the process of monitoring the raw traffic going through a network. This applies to wired Ethernet and wireless network devices. The <kbd>tcpdump</kbd> and <kbd>libpcap</kbd> packages are the standard when it comes to packet capturing. They were written in the 1980s and are still being used today. The <kbd>gopacket</kbd> package not only wraps the C libraries but also adds layers of Go abstraction to make it more idiomatic to Go and practical to use.</p>
<p>The <kbd>pcap</kbd> library allows you to gather information about network devices, read packets <em>off the wire</em>, store traffic in a <kbd>.pcap</kbd> file, filter traffic based on a number of criteria, or forge custom packets and send them through the network device. For the <kbd>pcap</kbd> library, filtering is done with <strong>Berkeley Packet Filters</strong> (<strong>BPF</strong>).</p>
<p>There are countless uses of packet capturing. It can be used to set up honeypots and monitor what kind of traffic is received. It can aid with forensic investigations to determine which hosts acted maliciously and which hosts were exploited. It can assist in identifying bottlenecks in a network. It can also be used maliciously for stealing information from wireless networks, performing packet scanning, fuzzing, ARP spoofing, and other types of attacks.</p>
<p>These examples require a non-Go dependency and a <kbd>libpcap</kbd> package, and, therefore, they may present more of a challenge to get running. I highly recommend that you use Ubuntu or another Linux distribution in a virtual machine for best results when following these examples if you do not already use Linux as your primary desktop.</p>
<p>Tcpdump is the application written by the authors of <kbd>libpcap</kbd>. Tcpdump provides a command-line utility for capturing packets. These examples will allow you to replicate the functionality of the <kbd>tcpdump</kbd> package and embed it within other applications. Some of the examples closely mimic the existing functionality with <kbd>tcpdump</kbd>, and, when applicable, an example usage of <kbd>tcpdump</kbd> will be provided. Because <kbd>gopacket</kbd> and <kbd>tcpdump</kbd> both rely on the same underlying <kbd>libpcap</kbd> package, the file format is compatible between them. You can capture files with <kbd>tcpdump</kbd> and read them with <kbd>gopacket</kbd>, and you can capture packets with <kbd>gopacket</kbd> and read them with any application that uses <kbd>libpcap</kbd>, such as Wireshark.</p>
<p>The official documentation of the <kbd>gopacket</kbd> package is available at <a href="https://godoc.org/github.com/google/gopacket">https://godoc.org/github.com/google/gopacket</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Prerequisites</h1>
                
            
            
                
<p>Before running these examples, you need to have <kbd>libpcap</kbd> installed. In addition, we have to use a third-party Go package. Fortunately, this package is provided by Google, a trusted source. Go's <kbd>get</kbd> ability will download and install the remote package. Git will also be needed for <kbd>go get</kbd> to work properly.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Installing libpcap and Git</h1>
                
            
            
                
<p>The <kbd>libpcap</kbd> package dependency does not come pre-installed on most systems, and the installation procedure is different for each operating system. Here we will cover the installation steps for <kbd>libpcap</kbd> and <kbd>git</kbd> for Ubuntu, Windows, and macOS. I highly recommend that you use Ubuntu or other Linux distributions for best results. Without <kbd>libpcap</kbd>, <kbd>gopacket</kbd> will not function, and <kbd>git</kbd> is required to fetch the <kbd>gopacket</kbd> dependency.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Installing libpcap on Ubuntu</h1>
                
            
            
                
<p>In Ubuntu, <kbd>libpcap-0.8</kbd> is already installed by default. To install the <kbd>gopacket</kbd> library, though, you also need the header files in the development package. You can install the header files through the <kbd>libpcap-dev</kbd> package. We will also install <kbd>git</kbd> because it is needed to run the <kbd>go get</kbd> command later when installing <kbd>gopacket</kbd>:</p>
<pre><strong>sudo apt-get install git libpcap-dev</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Installing libpcap on Windows</h1>
                
            
            
                
<p>Windows is the trickiest and presents the most problems. The Windows implementation is not very well supported, and your mileage may vary. The WinPcap is compatible with libpcap, and the source code used in these examples will work without modification. The only noticeable difference when running in Windows is the naming of network devices.</p>
<p>A WinPcap installer is available from <a href="https://www.winpcap.org/">https://www.winpcap.org/</a> and is a required component. The developer package, should you need it, is available at <a href="https://www.winpcap.org/devel.htm">https://www.winpcap.org/devel.htm</a> and contains the include files and example programs written in C. You should not need the developer package for most cases. Git can be installed from <a href="https://git-scm.com/download/win">https://git-scm.com/download/win</a>. You will also need MinGW for the compiler from <a href="http://www.mingw.org">http://www.mingw.org</a>. You will need to make sure that the 32-bit and 64-bit settings match for everything. You can set the <kbd>GOARCH=386</kbd> or <kbd>GOARCH=amd64</kbd> environment variables to change between 32-bit and 64-bit.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Installing libpcap on macOS</h1>
                
            
            
                
<p>In macOS, <kbd>libpcap</kbd> is already installed. You will also need Git, which is available through Homebrew at <a href="https://brew.sh">https://brew.sh</a>, or a Git package installer, which is available from <a href="https://git-scm.com/downloads">https://git-scm.com/downloads</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Installing gopacket</h1>
                
            
            
                
<p>After fulfilling the requirement with the <kbd>libpcap</kbd> and <kbd>git</kbd> packages, you can get the <kbd>gopacket</kbd> package from GitHub:</p>
<pre><strong>go get github.com/google/gopacket</strong>  </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Permission problems</h1>
                
            
            
                
<p>When executing the programs in Linux and Mac environments, you may run into permission problems when attempting to access the network device. Run the examples using either <kbd>sudo</kbd> to elevate your permission or switch your user to <kbd>root</kbd>, which is not recommended.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting a list of network devices</h1>
                
            
            
                
<p>Part of the <kbd>pcap</kbd> library includes a function for getting a list of network devices.</p>
<p>This program will simply get a list of network devices and list their information. In Linux, a common default device name is <kbd>eth0</kbd> or <kbd>wlan0</kbd>. On a Mac, it is <kbd>en0</kbd>. In Windows, the names are not pronounceable because they are much longer and represent a unique ID. You use the device name as a string to identify the device to capture from in later examples. You may need to run the example with administrative privileges (for example, <kbd>sudo</kbd>) if you don't see the lists of the exact devices.</p>
<p>The equivalent <kbd>tcpdump</kbd> command to list devices is as follows:</p>
<pre><strong>tcpdump -D</strong></pre>
<p>Alternatively, you can use this command:</p>
<pre><strong>tcpdump --list-interfaces</strong></pre>
<p>You can also use utilities such as <kbd>ifconfig</kbd> and <kbd>ip</kbd> to get the names of your network devices:</p>
<pre>package main<br/><br/>import (<br/>   "fmt"<br/>   "log"<br/>   "github.com/google/gopacket/pcap"<br/>)<br/><br/>func main() {<br/>   // Find all devices<br/>   devices, err := pcap.FindAllDevs()<br/>   if err != nil {<br/>      log.Fatal(err)<br/>   }<br/><br/>   // Print device information<br/>   fmt.Println("Devices found:")<br/>   for _, device := range devices {<br/>      fmt.Println("\nName: ", device.Name)<br/>      fmt.Println("Description: ", device.Description)<br/>      fmt.Println("Devices addresses: ", device.Description)<br/>      for _, address := range device.Addresses {<br/>         fmt.Println("- IP address: ", address.IP)<br/>         fmt.Println("- Subnet mask: ", address.Netmask)<br/>      }<br/>   }<br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Capturing packets</h1>
                
            
            
                
<p>The following program demonstrates the basics of capturing a packet. The device name is passed as a string. If you don't know the device name, use the previous example to get a list of the devices available on your machine. If you don't see the exact devices listed, you may need to elevate your privileges and run the program with <kbd>sudo</kbd>.</p>
<p>The promiscuous mode is an option you can enable to listen for packets that are not destined for your device. The promiscuous mode is particularly relevant with wireless devices because wireless network devices actually have the capability to pick up packets in the air that were intended for other recipients.</p>
<p>Wireless traffic is particularly vulnerable to <em>sniffing</em> because all the packets are broadcast through the air instead of through Ethernet, where physical access is required for the wire to intercept traffic. Providing free wireless internet with no encryption is very common for coffee shops and other venues. This is convenient for guests, but puts your information at risk. If a venue offers encrypted wireless internet, it is not automatically safer. If the password is posted somewhere on the wall, or it is given out freely, then anyone with the password can decrypt the wireless traffic. A popular technique to add security to guest wireless is with a captured portal. Captured portals require the user to authenticate in some way, even as a guest, and then their session is segmented with separate encryption so that others cannot decrypt it.</p>
<p>Wireless access points that offer completely unencrypted traffic must be used carefully. If you connect to a site where sensitive information is passed, be sure that it is using HTTPS so that your data is encrypted between you and the web server you are visiting. VPN connections also offer encrypted tunnels over unencrypted channels.</p>
<p>Some websites are built by unaware or negligent programmers who do not implement SSL on their servers. Some websites only encrypt the login page so that your password is secure, but subsequently pass the session cookie in plaintext. This means that anyone who can pick up the wireless traffic can see the session cookie and use it to impersonate the victim to the web server. The web server will treat the attacker as if they were logged in as the victim. The attacker never learns the password but doesn't need it as long as the session remains active.</p>
<p>Some websites do not have an expiration date on sessions, and they will remain active until explicitly logged out. Mobile applications are particularly vulnerable to this because users very rarely log out and log back into mobile apps. Closing an app and re-opening it does not necessarily create a new session.</p>
<p>This example will open the network device for live capture and then print the details of each packet received. The program will continue to run until the program is killed using <em>Ctrl</em> + <em>C</em>:</p>
<pre>package main<br/><br/>import (<br/>   "fmt"<br/>   "github.com/google/gopacket"<br/>   "github.com/google/gopacket/pcap"<br/>   "log"<br/>   "time"<br/>)<br/><br/>var (<br/>   device            = "eth0"<br/>   snapshotLen int32 = 1024<br/>   promiscuous       = false<br/>   err         error<br/>   timeout     = 30 * time.Second<br/>   handle      *pcap.Handle<br/>)<br/><br/>func main() {<br/>   // Open device<br/>   handle, err = pcap.OpenLive(device, snapshotLen, promiscuous,  <br/>      timeout)<br/>   if err != nil {<br/>      log.Fatal(err)<br/>   }<br/>   defer handle.Close()<br/><br/>   // Use the handle as a packet source to process all packets<br/>   packetSource := gopacket.NewPacketSource(handle, handle.LinkType())<br/>   for packet := range packetSource.Packets() {<br/>      // Process packet here<br/>      fmt.Println(packet)<br/>   }<br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Capturing with filters</h1>
                
            
            
                
<p>The following program demonstrates how to set filters. Filters use the BPF format. If you have ever used Wireshark, you are probably already familiar with filters. There are many filter options that can be logically combined. Filters can be incredibly complex, and there are many cheat sheets online with common filters and examples of neat tricks. Here are a few examples to give you an idea of some very basic filters:</p>
<ul>
<li><kbd>host 192.168.0.123</kbd></li>
<li><kbd>dst net 192.168.0.0/24</kbd></li>
<li><kbd>port 22</kbd></li>
<li><kbd>not broadcast and not multicast</kbd></li>
</ul>
<p>Some of the preceding filters should be self-explanatory. The <kbd>host</kbd> filter will show only packets to or from that host. The <kbd>dst net</kbd> filter will capture incoming traffic that is going to a <kbd>192.168.0.*</kbd> address. The <kbd>port</kbd> filter is watching only for port <kbd>22</kbd> traffic. The <kbd>not broadcast and not multicast</kbd> filter demonstrates how you can negate and combine multiple filters. Filtering out <kbd>broadcast</kbd> and <kbd>multicast</kbd> is useful because they tend to clutter a capture.</p>
<p>The equivalent <kbd>tcpdump</kbd> command for a basic capture is simply running it and passing it an interface:</p>
<pre><strong>tcpdump -i eth0</strong></pre>
<p>If you want to pass filters, you just pass them as command-line arguments, like this:</p>
<pre><strong>tcpdump -i eth0 tcp port 80</strong></pre>
<p>This example is using a filter that will only capture traffic on TCP port <kbd>80</kbd>, which should be HTTP traffic. It does not specify whether the local port or remote port is <kbd>80</kbd>, so it will capture any port <kbd>80</kbd> traffic that is coming in or going out. If you are running it on your personal computer, you probably do not have a web server running so that it will capture HTTP traffic you make through the web browser. If you were running the capture on a web server, it would capture incoming HTTP request traffic.</p>
<p>In this example, a handle for the network device is created using <kbd>pcap.OpenLive()</kbd>. Before reading packets from the device, the filter is set using <kbd>handle.SetBPFFilter()</kbd>, and then the packets are read from the handle. Read more about filters at <a href="https://en.wikipedia.org/wiki/Berkeley_Packet_Filter">https://en.wikipedia.org/wiki/Berkeley_Packet_Filter</a>.</p>
<p>This example opens a network device for live capture and then sets a filter with <kbd>SetBPFFilter()</kbd>. In this case, we will use the <kbd>tcp and port 80</kbd> filter to look for HTTP traffic. Any packets captured are printed to standard output:</p>
<pre>package main<br/><br/>import (<br/>   "fmt"<br/>   "github.com/google/gopacket"<br/>   "github.com/google/gopacket/pcap"<br/>   "log"<br/>   "time"<br/>)<br/><br/>var (<br/>   device            = "eth0"<br/>   snapshotLen int32 = 1024<br/>   promiscuous       = false<br/>   err         error<br/>   timeout     = 30 * time.Second<br/>   handle      *pcap.Handle<br/>)<br/><br/>func main() {<br/>   // Open device<br/>   handle, err = pcap.OpenLive(device, snapshotLen, promiscuous,  <br/>      timeout)<br/>   if err != nil {<br/>      log.Fatal(err)<br/>   }<br/>   defer handle.Close()<br/><br/>   // Set filter<br/>   var filter string = "tcp and port 80" // or os.Args[1]<br/>   err = handle.SetBPFFilter(filter)<br/>   if err != nil {<br/>      log.Fatal(err)<br/>   }<br/>   fmt.Println("Only capturing TCP port 80 packets.")<br/><br/>   packetSource := gopacket.NewPacketSource(handle, handle.LinkType())<br/>   for packet := range packetSource.Packets() {<br/>      // Do something with a packet here.<br/>      fmt.Println(packet)<br/>   }<br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Saving to the pcap file</h1>
                
            
            
                
<p>This program will perform a packet capture and store the results in a file. The important step in this example is the call to the <kbd>pcapgo</kbd> package—the <kbd>WriteFileHeader()</kbd> function of <kbd>Writer</kbd>. After that, the <kbd>WritePacket()</kbd> function can be used to write the desired packets to a file. You can capture all the traffic and choose to write only specific packets based on your own filtering criteria, if desired. Perhaps you only want to write odd or malformed packets to log anomalies.</p>
<p>To do the equivalent with <kbd>tcpdump</kbd>, just pass it the <kbd>-w</kbd> flag with a filename, as shown in the following command:</p>
<pre><strong>tcpdump -i eth0 -w my_capture.pcap</strong></pre>
<p>The pcap files created with this example can be opened with Wireshark and viewed just like files created with <kbd>tcpdump</kbd>.</p>
<p>This example creates an output file named <kbd>test.pcap</kbd> and opens a network device for live capture. It captures 100 packets to the file and then exits:</p>
<pre>package main<br/><br/>import (<br/>   "fmt"<br/>   "os"<br/>   "time"<br/><br/>   "github.com/google/gopacket"<br/>   "github.com/google/gopacket/layers"<br/>   "github.com/google/gopacket/pcap"<br/>   "github.com/google/gopacket/pcapgo"<br/>)<br/><br/>var (<br/>   deviceName        = "eth0"<br/>   snapshotLen int32 = 1024<br/>   promiscuous       = false<br/>   err         error<br/>   timeout     = -1 * time.Second<br/>   handle      *pcap.Handle<br/>   packetCount = 0<br/>)<br/><br/>func main() {<br/>   // Open output pcap file and write header<br/>   f, _ := os.Create("test.pcap")<br/>   w := pcapgo.NewWriter(f)<br/>   w.WriteFileHeader(uint32(snapshotLen), layers.LinkTypeEthernet)<br/>   defer f.Close()<br/><br/>   // Open the device for capturing<br/>   handle, err = pcap.OpenLive(deviceName, snapshotLen, promiscuous, <br/>      timeout)<br/>   if err != nil {<br/>      fmt.Printf("Error opening device %s: %v", deviceName, err)<br/>      os.Exit(1)<br/>   }<br/>   defer handle.Close()<br/><br/>   // Start processing packets<br/>   packetSource := gopacket.NewPacketSource(handle, handle.LinkType())<br/>   for packet := range packetSource.Packets() {<br/>      // Process packet here<br/>      fmt.Println(packet)<br/>      w.WritePacket(packet.Metadata().CaptureInfo, packet.Data())<br/>      packetCount++<br/><br/>      // Only capture 100 and then stop<br/>      if packetCount &gt; 100 {<br/>         break<br/>      }<br/>   }<br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Reading from a pcap file</h1>
                
            
            
                
<p>Instead of opening a device for live capture, you can also open a pcap file for inspection offline. After getting a handle, whether it was from <kbd>pcap.OpenLive()</kbd> or <kbd>pcap.OpenOffline()</kbd>, the handle is treated the same. No distinction is made between a live device and a capture file once the handle is created, except that a live device will continue to deliver packets, and a file will eventually end.</p>
<p>You can read pcap files that were captured with any <kbd>libpcap</kbd> client, including Wireshark, <kbd>tcpdump</kbd>, or other <kbd>gopacket</kbd> applications. This example opens a file named <kbd>test.pcap</kbd> using <kbd>pcap.OpenOffline()</kbd> and then iterates through the packets using <kbd>range</kbd> and prints the basic packet information. Change the filename from <kbd>test.pcap</kbd> to whatever file you want to read:</p>
<pre>package main<br/><br/>// Use tcpdump to create a test file<br/>// tcpdump -w test.pcap<br/>// or use the example above for writing pcap files<br/><br/>import (<br/>   "fmt"<br/>   "github.com/google/gopacket"<br/>   "github.com/google/gopacket/pcap"<br/>   "log"<br/>)<br/><br/>var (<br/>   pcapFile = "test.pcap"<br/>   handle   *pcap.Handle<br/>   err      error<br/>)<br/><br/>func main() {<br/>   // Open file instead of device<br/>   handle, err = pcap.OpenOffline(pcapFile)<br/>   if err != nil {<br/>      log.Fatal(err)<br/>   }<br/>   defer handle.Close()<br/><br/>   // Loop through packets in file<br/>   packetSource := gopacket.NewPacketSource(handle, handle.LinkType())<br/>   for packet := range packetSource.Packets() {<br/>      fmt.Println(packet)<br/>   }<br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Decoding packet layers</h1>
                
            
            
                
<p>Packets can be decoded layer by layer with the <kbd>packet.Layer()</kbd> function. This program will inspect the packets, look for TCP traffic, and then output the Ethernet layer, IP layer, TCP layer, and application layer information. This is useful when you need to inspect the traffic and make a decision based on the information. When it gets to the application layer, it looks for the <kbd>HTTP</kbd> keyword and prints a message if one is detected:</p>
<pre>package main<br/><br/>import (<br/>   "fmt"<br/>   "github.com/google/gopacket"<br/>   "github.com/google/gopacket/layers"<br/>   "github.com/google/gopacket/pcap"<br/>   "log"<br/>   "strings"<br/>   "time"<br/>)<br/><br/>var (<br/>   device            = "eth0"<br/>   snapshotLen int32 = 1024<br/>   promiscuous       = false<br/>   err         error<br/>   timeout     = 30 * time.Second<br/>   handle      *pcap.Handle<br/>)<br/><br/>func main() {<br/>   // Open device<br/>   handle, err = pcap.OpenLive(device, snapshotLen, promiscuous, <br/>      timeout)<br/>   if err != nil {<br/>      log.Fatal(err)<br/>   }<br/>   defer handle.Close()<br/><br/>   packetSource := gopacket.NewPacketSource(handle, handle.LinkType())<br/>   for packet := range packetSource.Packets() {<br/>      printPacketInfo(packet)<br/>   }<br/>}<br/><br/>func printPacketInfo(packet gopacket.Packet) {<br/>   // Let's see if the packet is an ethernet packet<br/>   ethernetLayer := packet.Layer(layers.LayerTypeEthernet)<br/>   if ethernetLayer != nil {<br/>      fmt.Println("Ethernet layer detected.")<br/>      ethernetPacket, _ := ethernetLayer.(*layers.Ethernet)<br/>      fmt.Println("Source MAC: ", ethernetPacket.SrcMAC)<br/>      fmt.Println("Destination MAC: ", ethernetPacket.DstMAC)<br/>      // Ethernet type is typically IPv4 but could be ARP or other<br/>      fmt.Println("Ethernet type: ", ethernetPacket.EthernetType)<br/>      fmt.Println()<br/>   }<br/><br/>   // Let's see if the packet is IP (even though the ether type told <br/>   //us)<br/>   ipLayer := packet.Layer(layers.LayerTypeIPv4)<br/>   if ipLayer != nil {<br/>      fmt.Println("IPv4 layer detected.")<br/>      ip, _ := ipLayer.(*layers.IPv4)<br/><br/>      // IP layer variables:<br/>      // Version (Either 4 or 6)<br/>      // IHL (IP Header Length in 32-bit words)<br/>      // TOS, Length, Id, Flags, FragOffset, TTL, Protocol (TCP?),<br/>      // Checksum, SrcIP, DstIP<br/>      fmt.Printf("From %s to %s\n", ip.SrcIP, ip.DstIP)<br/>      fmt.Println("Protocol: ", ip.Protocol)<br/>      fmt.Println()<br/>   }<br/><br/>   // Let's see if the packet is TCP<br/>   tcpLayer := packet.Layer(layers.LayerTypeTCP)<br/>   if tcpLayer != nil {<br/>      fmt.Println("TCP layer detected.")<br/>      tcp, _ := tcpLayer.(*layers.TCP)<br/><br/>      // TCP layer variables:<br/>      // SrcPort, DstPort, Seq, Ack, DataOffset, Window, Checksum, <br/>      //Urgent<br/>      // Bool flags: FIN, SYN, RST, PSH, ACK, URG, ECE, CWR, NS<br/>      fmt.Printf("From port %d to %d\n", tcp.SrcPort, tcp.DstPort)<br/>      fmt.Println("Sequence number: ", tcp.Seq)<br/>      fmt.Println()<br/>   }<br/><br/>   // Iterate over all layers, printing out each layer type<br/>   fmt.Println("All packet layers:")<br/>   for _, layer := range packet.Layers() {<br/>      fmt.Println("- ", layer.LayerType())<br/>   }<br/><br/>   // When iterating through packet.Layers() above,<br/>   // if it lists Payload layer then that is the same as<br/>   // this applicationLayer. applicationLayer contains the payload<br/>   applicationLayer := packet.ApplicationLayer()<br/>   if applicationLayer != nil {<br/>      fmt.Println("Application layer/Payload found.")<br/>      fmt.Printf("%s\n", applicationLayer.Payload())<br/><br/>      // Search for a string inside the payload<br/>      if strings.Contains(string(applicationLayer.Payload()), "HTTP")    <br/>      {<br/>         fmt.Println("HTTP found!")<br/>      }<br/>   }<br/><br/>   // Check for errors<br/>   if err := packet.ErrorLayer(); err != nil {<br/>      fmt.Println("Error decoding some part of the packet:", err)<br/>   }<br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a custom layer</h1>
                
            
            
                
<p>You are not restricted to the most common layers, such as Ethernet, IP, and TCP. You can create your own layers. This has limited use for most people, but in some extremely rare cases it may make sense to replace the TCP layer with something customized to meet specific requirements.</p>
<p>This example demonstrates how to create a custom layer. This is good for implementing a protocol that is not already included with <kbd>gopacket/layers</kbd> package. There are over 100 layer types already included with <kbd>gopacket</kbd>. You can create custom layers at any level.</p>
<p>The first thing this code does is to define a custom data structure to represent our layer. The data structure not only holds our custom data (<kbd>SomeByte</kbd> and <kbd>AnotherByte</kbd>) but also needs a byte slice to store the rest of the actual payload, along with any other layers (<kbd>restOfData</kbd>):</p>
<pre>package main<br/><br/>import (<br/>   "fmt"<br/>   "github.com/google/gopacket"<br/>)<br/><br/>// Create custom layer structure<br/>type CustomLayer struct {<br/>   // This layer just has two bytes at the front<br/>   SomeByte    byte<br/>   AnotherByte byte<br/>   restOfData  []byte<br/>}<br/><br/>// Register the layer type so we can use it<br/>// The first argument is an ID. Use negative<br/>// or 2000+ for custom layers. It must be unique<br/>var CustomLayerType = gopacket.RegisterLayerType(<br/>   2001,<br/>   gopacket.LayerTypeMetadata{<br/>      "CustomLayerType",<br/>      gopacket.DecodeFunc(decodeCustomLayer),<br/>   },<br/>)<br/><br/>// When we inquire about the type, what type of layer should<br/>// we say it is? We want it to return our custom layer type<br/>func (l CustomLayer) LayerType() gopacket.LayerType {<br/>   return CustomLayerType<br/>}<br/><br/>// LayerContents returns the information that our layer<br/>// provides. In this case it is a header layer so<br/>// we return the header information<br/>func (l CustomLayer) LayerContents() []byte {<br/>   return []byte{l.SomeByte, l.AnotherByte}<br/>}<br/><br/>// LayerPayload returns the subsequent layer built<br/>// on top of our layer or raw payload<br/>func (l CustomLayer) LayerPayload() []byte {<br/>   return l.restOfData<br/>}<br/><br/>// Custom decode function. We can name it whatever we want<br/>// but it should have the same arguments and return value<br/>// When the layer is registered we tell it to use this decode function<br/>func decodeCustomLayer(data []byte, p gopacket.PacketBuilder) error {<br/>   // AddLayer appends to the list of layers that the packet has<br/>   p.AddLayer(&amp;CustomLayer{data[0], data[1], data[2:]})<br/><br/>   // The return value tells the packet what layer to expect<br/>   // with the rest of the data. It could be another header layer,<br/>   // nothing, or a payload layer.<br/><br/>   // nil means this is the last layer. No more decoding<br/>   // return nil<br/>   // Returning another layer type tells it to decode<br/>   // the next layer with that layer's decoder function<br/>   // return p.NextDecoder(layers.LayerTypeEthernet)<br/><br/>   // Returning payload type means the rest of the data<br/>   // is raw payload. It will set the application layer<br/>   // contents with the payload<br/>   return p.NextDecoder(gopacket.LayerTypePayload)<br/>}<br/><br/>func main() {<br/>   // If you create your own encoding and decoding you can essentially<br/>   // create your own protocol or implement a protocol that is not<br/>   // already defined in the layers package. In our example we are    <br/>   // just wrapping a normal ethernet packet with our own layer.<br/>   // Creating your own protocol is good if you want to create<br/>   // some obfuscated binary data type that was difficult for others<br/>   // to decode. Finally, decode your packets:<br/>   rawBytes := []byte{0xF0, 0x0F, 65, 65, 66, 67, 68}<br/>   packet := gopacket.NewPacket(<br/>      rawBytes,<br/>      CustomLayerType,<br/>      gopacket.Default,<br/>   )<br/>   fmt.Println("Created packet out of raw bytes.")<br/>   fmt.Println(packet)<br/><br/>   // Decode the packet as our custom layer<br/>   customLayer := packet.Layer(CustomLayerType)<br/>   if customLayer != nil {<br/>      fmt.Println("Packet was successfully decoded.")<br/>      customLayerContent, _ := customLayer.(*CustomLayer)<br/>      // Now we can access the elements of the custom struct<br/>      fmt.Println("Payload: ", customLayerContent.LayerPayload())<br/>      fmt.Println("SomeByte element:", customLayerContent.SomeByte)<br/>      fmt.Println("AnotherByte element:",  <br/>         customLayerContent.AnotherByte)<br/>   }<br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Converting bytes to and from packets</h1>
                
            
            
                
<p>In some cases, there may be raw bytes that you want to convert into a packet or vice versa. This example creates a simple packet and then obtains the raw bytes that make up the packet. The raw bytes are then taken and converted back into a packet to demonstrate the process.</p>
<p>In this example, we will create and serialize a packet using <kbd>gopacket.SerializeLayers()</kbd>. The packet consists of several layers: Ethernet, IP, TCP, and payload. During serialization, if any of the packets come back as nil, this means that it could not decode it into the proper layer (malformed or incorrect packet type). After serializing the packet into a buffer, we will get a copy of the raw bytes that make up the packet with <kbd>buffer.Bytes()</kbd>. With the raw bytes, we can then decode the data layer by layer using <kbd>gopacket.NewPacket()</kbd>. By taking advantage of <kbd>SerializeLayers()</kbd>, you can convert packet structs to raw bytes, and using <kbd>gopacket.NewPacket()</kbd>, you can convert the raw bytes back to structured data.</p>
<p><kbd>NewPacket()</kbd> takes the raw bytes as the first parameter. The second parameter is the lowest-level layer you want to decode. It will decode that layer and all layers on top of it. The third parameter for <kbd>NewPacket()</kbd> is the type of decoding and must be one of the following:</p>
<ul>
<li><kbd>gopacket.Default</kbd>: This is to decode all at once, and is the safest.</li>
<li><kbd>gopacket.Lazy</kbd>: This is to decode on demand, but it is not concurrent safe.</li>
<li><kbd>gopacket.NoCopy</kbd>: This will not create a copy of the buffer. Only use it if you can guarantee the packet data in the memory will not change</li>
</ul>
<p>Here is the full code to turn a packet structs into bytes and then back to packets:</p>
<pre>package main<br/><br/>import (<br/>   "fmt"<br/>   "github.com/google/gopacket"<br/>   "github.com/google/gopacket/layers"<br/>)<br/><br/>func main() {<br/>   payload := []byte{2, 4, 6}<br/>   options := gopacket.SerializeOptions{}<br/>   buffer := gopacket.NewSerializeBuffer()<br/>   gopacket.SerializeLayers(buffer, options,<br/>      &amp;layers.Ethernet{},<br/>      &amp;layers.IPv4{},<br/>      &amp;layers.TCP{},<br/>      gopacket.Payload(payload),<br/>   )<br/>   rawBytes := buffer.Bytes()<br/><br/>   // Decode an ethernet packet<br/>   ethPacket :=<br/>      gopacket.NewPacket(<br/>         rawBytes,<br/>         layers.LayerTypeEthernet,<br/>         gopacket.Default,<br/>      )<br/><br/>   // with Lazy decoding it will only decode what it needs when it <br/>   //needs it<br/>   // This is not concurrency safe. If using concurrency, use default<br/>   ipPacket :=<br/>      gopacket.NewPacket(<br/>         rawBytes,<br/>         layers.LayerTypeIPv4,<br/>         gopacket.Lazy,<br/>      )<br/><br/>   // With the NoCopy option, the underlying slices are referenced<br/>   // directly and not copied. If the underlying bytes change so will<br/>   // the packet<br/>   tcpPacket :=<br/>      gopacket.NewPacket(<br/>         rawBytes,<br/>         layers.LayerTypeTCP,<br/>         gopacket.NoCopy,<br/>      )<br/><br/>   fmt.Println(ethPacket)<br/>   fmt.Println(ipPacket)<br/>   fmt.Println(tcpPacket)<br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating and sending packets</h1>
                
            
            
                
<p>This example does a couple of things. First, it will show you how to use the network device to send raw bytes, so you can use it almost like a serial connection to send data. This is useful for really low-level data transfer, but if you want to interact with an application, you probably want to build a packet that other hardware and software can recognize.</p>
<p>The next thing it does is show you how to create a packet with the Ethernet, IP, and TCP layers. Everything is default and empty, though, so it doesn't really do anything.</p>
<p>Finally, we will create another packet, but we'll actually fill in some MAC addresses for the Ethernet layer, some IP addresses for IPv4, and port numbers for the TCP layer. You should see how you can forge packets and impersonate devices with that.</p>
<p>The TCP layer struct has Boolean fields for the <kbd>SYN</kbd>, <kbd>FIN</kbd>, and <kbd>ACK</kbd> flags, which can be read or set. This is good for manipulating and fuzzing TCP handshakes, sessions, and port scanning.</p>
<p>The <kbd>pcap</kbd> library provides an easy way to send bytes, but the <kbd>layers</kbd> package in <kbd>gopacket</kbd> assists us in creating the byte structure for the several layers.</p>
<p>The following is the code implementation of this example:</p>
<pre>package main<br/><br/>import (<br/>   "github.com/google/gopacket"<br/>   "github.com/google/gopacket/layers"<br/>   "github.com/google/gopacket/pcap"<br/>   "log"<br/>   "net"<br/>   "time"<br/>)<br/><br/>var (<br/>   device            = "eth0"<br/>   snapshotLen int32 = 1024<br/>   promiscuous       = false<br/>   err         error<br/>   timeout     = 30 * time.Second<br/>   handle      *pcap.Handle<br/>   buffer      gopacket.SerializeBuffer<br/>   options     gopacket.SerializeOptions<br/>)<br/><br/>func main() {<br/>   // Open device<br/>   handle, err = pcap.OpenLive(device, snapshotLen, promiscuous, <br/>      timeout)<br/>   if err != nil {<br/>      log.Fatal("Error opening device. ", err)<br/>   }<br/>   defer handle.Close()<br/><br/>   // Send raw bytes over wire<br/>   rawBytes := []byte{10, 20, 30}<br/>   err = handle.WritePacketData(rawBytes)<br/>   if err != nil {<br/>      log.Fatal("Error writing bytes to network device. ", err)<br/>   }<br/><br/>   // Create a properly formed packet, just with<br/>   // empty details. Should fill out MAC addresses,<br/>   // IP addresses, etc.<br/>   buffer = gopacket.NewSerializeBuffer()<br/>   gopacket.SerializeLayers(buffer, options,<br/>      &amp;layers.Ethernet{},<br/>      &amp;layers.IPv4{},<br/>      &amp;layers.TCP{},<br/>      gopacket.Payload(rawBytes),<br/>   )<br/>   outgoingPacket := buffer.Bytes()<br/>   // Send our packet<br/>   err = handle.WritePacketData(outgoingPacket)<br/>   if err != nil {<br/>      log.Fatal("Error sending packet to network device. ", err)<br/>   }<br/><br/>   // This time lets fill out some information<br/>   ipLayer := &amp;layers.IPv4{<br/>      SrcIP: net.IP{127, 0, 0, 1},<br/>      DstIP: net.IP{8, 8, 8, 8},<br/>   }<br/>   ethernetLayer := &amp;layers.Ethernet{<br/>      SrcMAC: net.HardwareAddr{0xFF, 0xAA, 0xFA, 0xAA, 0xFF, 0xAA},<br/>      DstMAC: net.HardwareAddr{0xBD, 0xBD, 0xBD, 0xBD, 0xBD, 0xBD},<br/>   }<br/>   tcpLayer := &amp;layers.TCP{<br/>      SrcPort: layers.TCPPort(4321),<br/>      DstPort: layers.TCPPort(80),<br/>   }<br/>   // And create the packet with the layers<br/>   buffer = gopacket.NewSerializeBuffer()<br/>   gopacket.SerializeLayers(buffer, options,<br/>      ethernetLayer,<br/>      ipLayer,<br/>      tcpLayer,<br/>      gopacket.Payload(rawBytes),<br/>   )<br/>   outgoingPacket = buffer.Bytes()<br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Decoding packets faster</h1>
                
            
            
                
<p>If we know what layers to expect, we can use existing structures to store the packet information instead of creating new structs for every packet that takes time and memory. It is faster to use <kbd>DecodingLayerParser</kbd>. It is like marshaling and unmarshaling data.</p>
<p>This example demonstrates how to create layer variables at the beginning of the program and reuse the same variables over and over instead of creating new ones for each packet. A parser is created with <kbd>gopacket.NewDecodingLayerParser()</kbd>, which we provide with the layer variables we want to use. One caveat here is that it will only decode the layer types that you created initially.</p>
<p>The following is the code implementation of this example:</p>
<pre>package main<br/><br/>import (<br/>   "fmt"<br/>   "github.com/google/gopacket"<br/>   "github.com/google/gopacket/layers"<br/>   "github.com/google/gopacket/pcap"<br/>   "log"<br/>   "time"<br/>)<br/><br/>var (<br/>   device            = "eth0"<br/>   snapshotLen int32 = 1024<br/>   promiscuous       = false<br/>   err         error<br/>   timeout     = 30 * time.Second<br/>   handle      *pcap.Handle<br/>   // Reuse these for each packet<br/>   ethLayer layers.Ethernet<br/>   ipLayer  layers.IPv4<br/>   tcpLayer layers.TCP<br/>)<br/><br/>func main() {<br/>   // Open device<br/>   handle, err = pcap.OpenLive(device, snapshotLen, promiscuous, <br/>   timeout)<br/>   if err != nil {<br/>      log.Fatal(err)<br/>   }<br/>   defer handle.Close()<br/><br/>   packetSource := gopacket.NewPacketSource(handle, handle.LinkType())<br/>   for packet := range packetSource.Packets() {<br/>      parser := gopacket.NewDecodingLayerParser(<br/>         layers.LayerTypeEthernet,<br/>         &amp;ethLayer,<br/>         &amp;ipLayer,<br/>         &amp;tcpLayer,<br/>      )<br/>      foundLayerTypes := []gopacket.LayerType{}<br/><br/>      err := parser.DecodeLayers(packet.Data(), &amp;foundLayerTypes)<br/>      if err != nil {<br/>         fmt.Println("Trouble decoding layers: ", err)<br/>      }<br/><br/>      for _, layerType := range foundLayerTypes {<br/>         if layerType == layers.LayerTypeIPv4 {<br/>            fmt.Println("IPv4: ", ipLayer.SrcIP, "-&gt;", ipLayer.DstIP)<br/>         }<br/>         if layerType == layers.LayerTypeTCP {<br/>            fmt.Println("TCP Port: ", tcpLayer.SrcPort,               <br/>               "-&gt;", tcpLayer.DstPort)<br/>            fmt.Println("TCP SYN:", tcpLayer.SYN, " | ACK:", <br/>               tcpLayer.ACK)<br/>         }<br/>      }<br/>   }<br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>Having read this chapter, you should now have a very good understanding of the <kbd>gopacket</kbd> package. You should be able to write a simple packet-capturing application using the examples from this chapter. Once again, it is not about memorizing all of the functions or the details about the layers. The important thing is to understand the big picture at a high level and be able to recall what tools are available to you when scoping and implementing an application.</p>
<p>Try writing your own program based on these examples to capture interesting network traffic from your machine. Try capturing and inspecting a specific port or application to see how it works over the wire. See the difference between applications that use encryption and ones that pass data over the wire in plaintext. You may just want to capture all the traffic going on in the background and see which applications are busy over the network, even when you are idle at the machine.</p>
<p>All kinds of useful tools can be built using the <kbd>gopacket</kbd> library. Aside from basic packet capturing for later review, you can implement a monitoring system that alerts when a large spike in traffic is identified, or for spotting anomalous traffic.</p>
<p>Because the <kbd>gopacket</kbd> library can also be used to send packets, a highly customized port scanner can be created. You can craft raw packets to perform TCP SYN-only scans, where the connection is never fully established; XMAS scans, where all of the flags are turned on; NULL scans, where every field is set to null; and a variety of other scans that require full control over the packets being sent, including sending malformed packets intentionally. You can also build fuzzers to send bad packets to a network service to see how it behaves. So, see what ideas you can come up with.</p>
<p>In the next chapter, we will look at cryptography with Go. We will start by looking at hashing, checksums, and storing passwords securely. Then we will look at symmetric and asymmetric encryption, what they are, how they differ, why they are useful, and how to use them in Go. We will look at how to create an encrypted server with certificates, and how to use an encrypted client to connect. Understanding the application of cryptography is critical for modern security, so we will look at the most common and practical use cases.</p>


            

            
        
    </body></html>