- en: Chapter 7. Registry Analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Understanding system configuration and settings and user activities is always
    an important step in the forensics analysis process. This configuration used to
    be stored in INI files, which were text files with a simple format. However, starting
    from Windows 3.1, the concept of registry was introduced to store the com-based
    components only. **COM** or **Component Object Model** was introduced by Microsoft
    in 1993 to enable inter-process communication and dynamic object creation in a
    wide range of programming languages. Since then, it has been used on a larger
    scale to include most of the Windows settings.
  prefs: []
  type: TYPE_NORMAL
- en: The registry can be considered as the Windows-structured database. It contains
    the operating system's configurations and settings, and also contains the settings
    of running services and installed applications along with users' preferences.
    It is not mandatory for the installed applications to use the registry to store
    its configurations and settings. Some programs use XML or text files to store
    their configurations.
  prefs: []
  type: TYPE_NORMAL
- en: Portable applications usually keep their configuration data within files in
    the directory or folder from where the application executable runs. The registry
    also keeps track of users' activities, stores their settings, and supports the
    multi-profile structure, where each user has their configuration for their account.
    The registry of each user stores under that user's directory in a separate file
    called `NTUSER.DAT`, which will be discussed in detail later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Registry analysis in the digital forensics process is a valuable source of evidential
    information for investigators. Malicious programs are like any other program.
    They use the system resources while running, so they may leave some traces in
    the registry. These traces will help in understanding the circumstances of the
    incident under investigation.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will discuss the structure of the registry and some tools
    that are used to perform analysis.
  prefs: []
  type: TYPE_NORMAL
- en: The registry structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The registry has a specific structure, which is divided into key and value.
    Like the directory structure, main root keys represent the root directory, sub-keys
    represent the sub folders, and values represent the files. Figure 1 depicts the
    registry structure opened from Windows native tool "registry editor". This tool
    can be opened in editable mode by typing regedit.exe in Run.
  prefs: []
  type: TYPE_NORMAL
- en: 'The items in the round-edged rectangle are the root keys, while the items in
    the rectangle below it are the sub-keys. The items inside the oval are the values
    of the registry. Each value has these three entries:'
  prefs: []
  type: TYPE_NORMAL
- en: Name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To access a specific value, the user needs to know the path to this value.
    The path can be found in the tail of the regedit window. In our example, the path
    is `Computer\HKEY_CURRENT_USER\Environment`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The registry structure](img/image_07_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure1: The main components of the registry'
  prefs: []
  type: TYPE_NORMAL
- en: Root keys
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Windows system, in this case Windows 8.1, has five root keys. Each root
    key stores different information and settings about the running system and the
    system''s users. Each root key shown in the registry editor is actually a file
    in the filesystem called **registry hive**. The root keys are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`HKEY_CLASSES_ROOT`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HKEY_LOCAL_MACHINE`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HKEY_USERS`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HKEY_CURRENT_USER`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HKEY_CURRENT_CONFIG`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the following section, we will discuss each root key in brief and the registry
    hive structure, before discussing the analysis programs to explain how it could
    be useful in the analysis process.
  prefs: []
  type: TYPE_NORMAL
- en: HKEY_CLASSES_ROOT or HKCR
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This key contains subkeys. Each subkey is named after one extension that can
    be found in the system, such as `.exe` and `.jpeg`. This root key describes the
    default program that has to be used to open this extension to the system. Also,
    this key stores the right-click menu's details and the icon of the program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider that during an analysis, we (the investigator) need to know which
    program is used to open a specific file type, such as the executable files with
    the flv extension. We would then use the following process:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to search for the subkey named `.flv`, without quotes, under
    the root key and locate the associated value of this subkey.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, we need to search under the same root key for another subkey named after
    the associated value `VLC.flv`. This subkey contains some values about how the
    operating system deals with `.flv` media files:![HKEY_CLASSES_ROOT or HKCR](img/image_07_002.jpg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Figure 2: The flv extension associated value in the registry'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: On searching for the `VLC.flv` value in the same registry key, we will locate
    the executable that was used to run the `.flv` file types. In this case, this
    is the VLC media player. It also mentions the location of the executable in the
    filesystem:![HKEY_CLASSES_ROOT or HKCR](img/image_07_003.jpg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Figure 3: location of the VLC player used to run the .flv file type'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For example, in a multiuser Windows environment, if two different users have
    installed two different programs to open PDF files, then when one user logs in
    to the system, the operating system will load the profile of this specific user,
    including their selected program to open the PDF file.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, the information in the HKCR comes from two different locations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`HKEY_LOCAL_MACHINE\SOFTWARE\Classes`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HKEY_CURRENT_USER\SOFTWARE\Classes`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Usually, this is an alias to only `HKEY_LOCAL_MACHINE\SOFTWARE\Classes`. When
    a user registers a different association to specific file type, it uses the per-user
    class registration feature to register the new association to this user only.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, if the user opens one file of a specific type, and this file type
    has two different associations in `HKEY_LOCAL_MACHINE\SOFTWARE\Classes` and `HKEY_CURRENT_USER\SOFTWARE\Classes`,
    then the one in `HKEY_CURRENT_USER\SOFTWARE\Classes`, which relates to this specific
    user, will be used.
  prefs: []
  type: TYPE_NORMAL
- en: HKEY_LOCAL_MACHINE
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This key contains configuration and settings that are used by the system during
    start-up. It is independent from the user login. This root key contains the following
    five subkeys:'
  prefs: []
  type: TYPE_NORMAL
- en: '**System**: This contains system configuration, such as the computer name,
    system time zone, and network interfaces.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Software**: This contains settings and configuration about the installed
    applications on the system and the operating system services.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SAM**: This is the Security Account Manager, and it stores the user and group
    security information. It summarizes the total rights of the user that are granted
    by the administrator on the local system and domain. It contains the username,
    the unique SID of the user, and a hash message of the user''s password. This file
    will be empty if opened from a running system by the `regedit.exe` tool because
    of Windows security. It can be extracted and opened in a different analysis machine
    to display all its contents.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security**: This contains the security policy in the system, if any. This
    is the same as SAM, its contents can''t be viewed from a live system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hardware**: This holds information about the hardware devices connected to
    the system. This information is stored during the system boot.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HKEY_USERS or HKU
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The HKU registry root key contains a number of subkeys. We will use Windows
    8.1 for this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![HKEY_USERS or HKU](img/image_07_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4: HKEY_USERS'
  prefs: []
  type: TYPE_NORMAL
- en: 'Its subkeys are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**S-1-5-18**: This is the system profile located at `%systemroot%\system32\config\systemprofile`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**S-1-5-19**: This is related to LocalService and located at `%systemroot%\C:\Windows\ServiceProfiles\LocalService`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**S-1-5-20**: This is related to the NetworkService and located under `%systemroot%\C:\Windows\ServiceProfiles\NetworkService`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**S-1-5-21-4123892437-111928464-3716307427-1002**: This is the currently signed
    in user with their full SID. Ours is located in the user directory `C:\Users\Forensics2`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Default user**: This is the default profile for any new user. It is located
    at `%SystemDrive%\Users\Default`. When a new user was created, a copy of this
    profile is copied for this user, and all the changes in configuration made by
    this user are recorded under this profile. This process doesn''t happen until
    the first login for this new user. The system starts building this user profile,
    as we can see in the following figure:![HKEY_USERS or HKU](img/image_07_005.jpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Figure 5: Creating a new user profile in Windows'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Only the logged on user can be found under HKU, not all the users. However,
    on a live system, we can find the location and more details about the system's
    users in the `HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\ProfileList`
    key in the registry.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this key, we can find basic information about all the system users'' profiles,
    including the location of each profile, but not the configurations and settings
    of each user. In the following screenshot, we can find another user profile with
    SID ends with 1002, which we can''t find under HKU:'
  prefs: []
  type: TYPE_NORMAL
- en: '![HKEY_USERS or HKU](img/image_07_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6: The list of system profiles'
  prefs: []
  type: TYPE_NORMAL
- en: HKEY_CURRENT_USER or HKCU
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'HKCU is only a pointer to the current user under the HKU,  with the same configuration
    and settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '![HKEY_CURRENT_USER or HKCU](img/image_07_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7: HKCU VS HKU'
  prefs: []
  type: TYPE_NORMAL
- en: Mapping a hive to the filesystem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each root key in the registry is actually mapped to a single file in the filesystem,
    which differs from one Windows version to another. In the following table, we
    target Windows NT to Windows 10\. These files have specific formats, which the
    operating system parses for either read or write data in the registry.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can view the location of each hive in the filesystem in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Hive name** | **Location in the filesystem** |'
  prefs: []
  type: TYPE_TB
- en: '| `HKEY_LOCAL_MACHINE\System` | `%WINDIR%\system32\config\System` |'
  prefs: []
  type: TYPE_TB
- en: '| `HKEY_LOCAL_MACHINE\SAM` | `%WINDIR%\system32\config\Sam` |'
  prefs: []
  type: TYPE_TB
- en: '| `HKEY_LOCAL_MACHINE\Security` | `%WINDIR%\system32\config\Security` |'
  prefs: []
  type: TYPE_TB
- en: '| `HKEY_LOCAL_MACHINE\Software` | `%WINDIR%\system32\config\Software` |'
  prefs: []
  type: TYPE_TB
- en: '| `HKEY_USERS\User SID` | This is the user profile (`NTUSER.DAT`); `Documents
    and Settings\User` (this was changed to `Users\User` in Vista). Each profile under
    HKU must be linked to one `NTUSER.DAT` file under the user profile directory.
    This directory can be determined, as in Figure 6, under:`HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows
    NT\CurrentVersion\ProfileList` |'
  prefs: []
  type: TYPE_TB
- en: '| `HKEY_CURRENT_USER` | This acts as a pointer to the HKU of the currently
    logged in user. |'
  prefs: []
  type: TYPE_TB
- en: '| `HKEY_USERS\.Default` | `%WINDIR%\system32\config\default` |'
  prefs: []
  type: TYPE_TB
- en: 'Table 1: Hive to filesystem mapping'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Backing up the registry files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Windows OS backs up the hive files by default every 10 days. The backup files
    are located at `%WINDIR%\repair` in Windows XP and at `%WINDIR%\System32\config\RegBack`
    starting from Windows Vista. The backup hives are useful in determining the changed
    configuration from the last update. They are also useful in case the normal hives
    are corrupted.
  prefs: []
  type: TYPE_NORMAL
- en: 'The backup is done by the local system in Windows tasks under `%WINDIR%\System32\Tasks\Microsoft\Windows\Registry`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Backing up the registry files](img/image_07_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8: The registry backup task in Windows'
  prefs: []
  type: TYPE_NORMAL
- en: Extracting registry hives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Performing a postmortem analysis on the system registry requires extracting
    the hives from the filesystem. In this section, we will look at extracting files
    from a live system and from a forensic image.
  prefs: []
  type: TYPE_NORMAL
- en: Extracting registry files from a live system
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Copying the backup files on a live system is quite easy; simply copy and paste
    or type the following command in the administrator command prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'As discussed earlier, these files could be 10 days old. This may not contain
    any traces of the incident under investigation. So, we need to extract the working
    hive files, which won''t be allowed by the system because these files are in use
    in the live system:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Extracting registry files from a live system](img/image_07_009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9: Error in copying registry files in live system'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to copy registry files from the live system, we need to use a program,
    such as FTK imager. We will use the lite version in this exercise, which is better
    in case of live analysis because it does not leave large traces in the system
    as compared to the installation version:'
  prefs: []
  type: TYPE_NORMAL
- en: In the Windows live system, open the FTK imager lite program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select ****add evidence item**** from **File**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This will ask you to select a source. In this case, we can either select a physical
    or logical drive. It won't make a difference in our case here; we can anyway select
    a logical drive:![Extracting registry files from a live system](img/image_07_010.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 10: FTK source type'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: After this we need to select the source drive, and we need to select the Windows
    working partition, which in our case is partition C:![Extracting registry files
    from a live system](img/image_07_011.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 11: Source partition'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The contents of partition C will be in the left pane of the program.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We need to browse to the registry files location. Select the hive file, and
    export these files to the external connected storage or shared folder over the
    network and not to the local machine. This avoids overwriting possible related
    evidential data, as shown in the following image:![Extracting registry files from
    a live system](img/image_07_012.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 12: Exporting registry files by FTK imager'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: After this, we can take the extracted files to our Linux machine for analysis.
  prefs: []
  type: TYPE_NORMAL
- en: It is worth mentioning here that FTK Imager has a built-in feature to acquire
    all the registry files and protected system files. It can be accessed by navigating
    to File à Obtain protected system files from a live system without adding any
    devices or partitions.
  prefs: []
  type: TYPE_NORMAL
- en: Extracting registry files from a forensic image
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To extract files from a forensic image in Linux, we need to mount the system
    partition to the system first as read only and then perform a simple copy and
    paste operation of the registry files.
  prefs: []
  type: TYPE_NORMAL
- en: 'To mount one partition from a forensic image in Linux, we need to know the
    offset of this partition in the forensic image in the first place. This task can
    be done using the mmls command from the TSK or The Sleuth Kit. TSK will be discussed
    later in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Extracting registry files from a forensic image](img/image_07_013.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13: Windows partition'
  prefs: []
  type: TYPE_NORMAL
- en: 'The results show that the system partition starts at sector 2048\. Using this
    piece of information, we can mount this partition as read only:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to create a directory as the mount point at `</mnt/mountpoint>`,
    and then we run the mount command, as follows:![Extracting registry files from
    a forensic image](img/image_07_014.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 14: Creating a mount point and mounting the image'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: As we can see, the offset must be in bytes. So, we need to put it in this formula
    (512*2048), where 512 is the sector size and the 2048 is the sector number. In
    this command, we also selected to mount the image as read only, show system files,
    and ignore case, to make it easier to browse through the files without mistakes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: So, we can see that all the filesystem structure can be accessed easily from
    the mount point:![Extracting registry files from a forensic image](img/image_07_015.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 15: Mounted system partition'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: As we know the location of the registry files in the system, we can start copying
    them:![Extracting registry files from a forensic image](img/image_07_016.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 16: Copying registry files'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The same can be done with the users' profiles. Here, we have two users, forensics
    and forensics2:![Extracting registry files from a forensic image](img/image_07_017.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 17: Copying users'' profiles'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Parsing registry files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Suppose that you have a corrupted registry file, or you need to recover some
    data, or you want to verify the results of a new analysis tool. All these reasons,
    besides your need to know how the analysis tools work to parse and recover registry
    files, make it important to understand the registry file structure.
  prefs: []
  type: TYPE_NORMAL
- en: The registry file consists of blocks with the same concept of clusters in the
    filesystem. The block size is 4Kb. The hive expands in the whole block, again
    like the clusters in the filesystem. The first cluster is called the **base block**.
  prefs: []
  type: TYPE_NORMAL
- en: The base block
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The base block is the first 4KB of the hive file. It contains the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The hive signature, which identifies this file as a hive file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A timestamp of the last write operation on this hive.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checksum.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The hive format, which differs from one OS version to another. There are differences
    in how data treated in different versions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The real name of the hive file and its full path in the system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The offset to the root cell, which is relative to the beginning of the hbin.
    (Both will be explained shortly.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The two sequence numbers. We can consider the sequence number as a way to preserve
    the integrity of the hive file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When one write operation needs to be performed in the registry hives, it is
    first done in memory. The operating system needs to write these changes to the
    nonvolatile on-disk file to keep it updated. The operating system keeps tracking
    all the sectors of the hive.
  prefs: []
  type: TYPE_NORMAL
- en: To write to the on-disk file, the operating system schedules what is called
    a lazy write operation or hive sync. The lazy write starts synchronizing the hive
    changes from memory to the on-disk file and updates the last write time. If something
    crashed during the synchronization process, the file will be corrupted.
  prefs: []
  type: TYPE_NORMAL
- en: In order to avoid this, the lazy write updates the first number of the sequence
    before it starts the synchronization process. After finishing the write process,
    it updates the second sequence number with the same value. If the operating system
    finds two different values in the sequence numbers, it knows that there was a
    crash during the last synchronization process. It then starts the recovery process
    following the log file of the hive to keep the file consistent.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will consider an example of the `forensics2.dat` registry
    file. To view the registry file as raw data, we will use the hexdump utility or
    hd and start to interpret the registry file data.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the forensic machine, run the following command to view only the first
    200 bytes of the base block:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The base block](img/image_07_018.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 18: First 200 bytes of the base block'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s interpret the values in the previous image. Note that now that
    these values are little endian, we need to read them byte by byte from right to
    left:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Offset** | **Length (Bytes)** | **Value** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| 0x0000 | 4 | Regf | This is the registry file signature. |'
  prefs: []
  type: TYPE_TB
- en: '| 0x0004 | 4 | 0x00000055 | This is the first sequence number that the OS writes
    before editing the registry. |'
  prefs: []
  type: TYPE_TB
- en: '| 0x0008 | 4 | 0x00000055 | This is the second sequence number. The first and
    second sequence numbers are the same, which means that the last write operation
    was successful. |'
  prefs: []
  type: TYPE_TB
- en: '| 0x000C | 8 | 0x01D048BC17BA58E0 | This is the timestamp of the last write
    operation. This value can be decoded with the `dcode.exe` program, from [http://digitaldetective.com/](http://digitaldetective.com/):![The
    base block](img/image_07_019.jpg)From these results, we can see that the last
    write time was Sunday, February 15, 2015, at 01:09:48 UTC. |'
  prefs: []
  type: TYPE_TB
- en: '| 0x0014 | 4 | 0x00000001 | This is the major version of the file. In this
    case, it is 1. |'
  prefs: []
  type: TYPE_TB
- en: '| 0x0018 | 4 | 0x00000003 | This is the minor version of the file. In this
    case, it is 3\. So, the file format version is 1.3. |'
  prefs: []
  type: TYPE_TB
- en: '| 0x0024 | 4 | 0x00000020 | This is the offset of the first cell relative to
    the first hbin. |'
  prefs: []
  type: TYPE_TB
- en: '| 0x0030 | 64 maximum | `C:\Users\Forensics2\ntuser.dat` | This is the location
    and the name of the file. From this piece of information, we know that this file
    is the user''s profile under `C:\Users\Forensics2`. Despite the name of the file
    under investigation, the file name is `ntuser.dat`. |'
  prefs: []
  type: TYPE_TB
- en: '*Table 2 : Parsing base block*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Hbin and CELL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The cell is the data container in the registry file; it contains a key, subkey,
    or value. Each type has a different signature and a different data structure within
    the cell. If the cell signature is kn or key node, then the following information
    will be interpreted as for a key. The operating system allocates these cells within
    another container called HBIN. The HBIN can contain more than one cell, and it
    has its own header in the signature file. For our example here, let's take the
    first cell within the first hbin.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first hbin can be found directly after the base block, that is, 4,096 bytes
    from the beginning of the file. We will display the first 200 bytes after the
    first 4,096 bytes or 0x1000 in hex:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Hbin and CELL](img/image_07_020.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 19: The first 200 bytes of the first HBIN'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can interpret the information in the header as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Offset** | **Length (Bytes)** | **Value** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| 0x1000 | 4 | hbin | This is the beginning of the hbin signature. |'
  prefs: []
  type: TYPE_TB
- en: '| 0x1004 | 4 | 0x00000000 | This is the offset, which is relative to the first
    hbin structure. The value here is 0, which means that this is the first hbin in
    the file. |'
  prefs: []
  type: TYPE_TB
- en: '| 0x1008 | 2 | 0x1000 | This is the size of the current hbin. It is 4096 bytes.
    Usually, it is either equal to 4096 bytes or a multiple of this number. |'
  prefs: []
  type: TYPE_TB
- en: '*Table 3: The header of hbin*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: From parsing the base block at 0x0024, the offset to the first cell is 0x20
    relative to the first hbin.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, to find the header of the first cell, we need to go to offset 0x1020 at
    the current hbin:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Offset** | **Length (Bytes)** | **Value** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| 0x1020 | 4 | 0xFFFFFF78 | This is the size of the cell in negative implementation.
    The negative sign indicates that this cell is in use.The value here is (-136).
    This cell is used, and it has a size of 136. |'
  prefs: []
  type: TYPE_TB
- en: '| 0x1024 | 2 | nk | This is the nk signature, which means that this cell contains
    a key node value. |'
  prefs: []
  type: TYPE_TB
- en: '| 0x1026 | 2 | 0x002C | This is the properties flag of the record; it has different
    values. The binary representation or the value here is 00101100, which indicates
    that the file is:CompressedName: (00100000)[2]NoDelete: (00001000)[2]HiveEntryRootKey:
    (00000100)[2]As we expected before, this entry holds root key information. |'
  prefs: []
  type: TYPE_TB
- en: '| 0x1028 | 8 | 0x01D048B03FC412EF | This is the timestamp of the last write
    time of this entry. The value is Sat, 14 February 2015 23:45:01 UTC, according
    to the decode value from `Dcode.exe`![Hbin and CELL](img/image_07_021.jpg) |'
  prefs: []
  type: TYPE_TB
- en: '| 0x1034 | 2 | 0x0600 | This value is the offset to the parent key record.
    As this is the parent kn record, this value can be ignored here as long as this
    is already the kn root key record. |'
  prefs: []
  type: TYPE_TB
- en: '| 0x1038 | 4 | 0x0000000B | This is the number or subkeys list under this root
    key. Here, the value is 11, so there are 11 subkey under this key. |'
  prefs: []
  type: TYPE_TB
- en: '| 0x1040 | 4 | 0x00011E28 | This is a pointer to the list of the subkeys under
    this root key. |'
  prefs: []
  type: TYPE_TB
- en: '| 0x104C | 4 | 0xFFFFFFFF | This is a pointer to the list of the values under
    this root key. The value here is 0xFFFFFFFF, which means that there are no values
    under this root key. |'
  prefs: []
  type: TYPE_TB
- en: '| 0x106C | 2 | 0x0034 | The size of the key name. In this case, it is 52 bytes.
    |'
  prefs: []
  type: TYPE_TB
- en: '| 0x1070 | 52 | CMI-CreateHive{D43B12BB-09B5-40DB-B4F6-F6DFEB78DAEC} | This
    is the name of the root key. Its length is 52 bytes or character. |'
  prefs: []
  type: TYPE_TB
- en: '*Table 4: Cell analysis*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Now, we can conclude that this is a root key named `CMI-CreateHive{D43B12BB-09B5-40DB-B4F6-F6DFEB78DAEC}`
    with a size of 136 bytes, and this contains 11 subkeys and no values. Now, we
    need to find the names of the subkeys under this root key.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the previous analysis, the offset to the subkeys list is 0x11E28 relative
    to the beginning of the hbin. So, we need to add 0x1000 to get it from the beginning
    of the hive file itself. The offset will be 0x12E28:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Hbin and CELL](img/image_07_022.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 20: The subkeys list'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see that this is a new cell that needs to be parsed, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Offset** | **Length (Bytes)** | **Value** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| 0x12E28 | 4 | 0xFFFFFFA0 | This is the size of the cell in negative implementation.
    The negative sign indicates that this cell is in use.The value here is (-96).
    This cell is used, and it has a size of 96. |'
  prefs: []
  type: TYPE_TB
- en: '| 0x12E2C | 2 | lf | The lf signature indicates that this contains a list of
    subkeys. |'
  prefs: []
  type: TYPE_TB
- en: '| 0x12E2E | 2 | 0x000B | This is the number of elements in the list. In this
    case, this is 11, which matches the value from the previous analysis. |'
  prefs: []
  type: TYPE_TB
- en: '| 0x12E30 | --- | ---- | Starting from this point, each 8 bytes represent one
    subkey. The first 4 bytes are the offset to the subkey location relative to the
    beginning of the hbin. The second 4 bytes are used as the checksum. |'
  prefs: []
  type: TYPE_TB
- en: '*Table 5: The lf entry analysis*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'From the previous analysis, we can determine the location of each subkey to
    be to the following offsets:'
  prefs: []
  type: TYPE_NORMAL
- en: '0x00011DC8'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '0x00003C30'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '0x00000EB8'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '0x00000318'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '0x00018BF0'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '0x000499F0'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '0x0001E2F0'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '0x00006820'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '0x00006BD8'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '0x00000160'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '0x00000C60'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To see the contents that are related to the beginning of the hive file, we
    need to add 0x1000 to each offset, which represents the size of the base block,
    and then view the first 100 bytes. We will see that each offset will point to
    another entry with a different name, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Hbin and CELL](img/image_07_023.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We can see that in the new entries, the parent cell offset in the new entries
    is 0x0020, which is the offset of the first entry named `CMI-CreateHive{D43B12BB-09B5-40DB-B4F6-F6DFEB78DAEC}`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The complete list of subkeys is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: AppEvents
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Console
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Control Panel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: EUDC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keyboard Layout
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Printers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Software
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: System
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To confirm these results with the actual case, we can display the registry
    in our test live machine using the native regedit tool. If the list matched the
    results, then the parsing went well, as we can see in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Hbin and CELL](img/image_07_024.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 21: Actual subkeys from the live machine'
  prefs: []
  type: TYPE_NORMAL
- en: Auto-run keys
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Malware programs usually tend to preserve their existence in the system in
    case the system was rebooted or different users log on to the system. The following
    listing shows two important autorun keys that run when the system boots:'
  prefs: []
  type: TYPE_NORMAL
- en: '`HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\ShellServiceObjectDelayLoad`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These locations can host malware that targets the machine itself, such as rootkit,
    botnet, or backdoor. Other malware executables target some users on the system
    and run when the specific user or any user logs on to the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'They can be found in the following locations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Runonce`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Run`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\RunOnce`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HKEY_LOCAL_MACHINE\Software\Microsoft\WindowsNT\CurrentVersion\Winlogon\Userinit`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An example of these keys is the Zeus banking malware. It adds its executable
    in the Userinit key to run when anyone logs on to the system:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Auto-run keys](img/image_07_025.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 22: The Zeus autorun technique'
  prefs: []
  type: TYPE_NORMAL
- en: Registry analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After we have extracted the registry files from the live system or the forensic
    image, we need to analyze them.
  prefs: []
  type: TYPE_NORMAL
- en: We will use RegistryRipper, and sysinternals for registry parsing and analysis.
  prefs: []
  type: TYPE_NORMAL
- en: RegistryRipper
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Regripper is a Perl open source and cross-platform tool by Harlan Carvey, which
    can be downloaded from [https://code.google.com/p/regripper/](https://code.google.com/p/regripper/)
    . It parses the registry structure, searches for the forensically important areas,
    and lists the contents of these areas. The investigator needs to understand the
    results and extract the anomalies from the output.
  prefs: []
  type: TYPE_NORMAL
- en: 'The tool is a command line tool, and it also has a simple GUI to carve different
    types of hives. Through the GUI, the investigator will be able to select one hive
    file for analysis and the list of plugins to run against this hive file by selecting
    the type of the hive file from the Profile dropdown. The report will be created
    in the txt format, and a log file will be created through the analysis process
    in order to view the successful and failed plugins:'
  prefs: []
  type: TYPE_NORMAL
- en: '![RegistryRipper](img/image_07_026.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 23: The RegRipper GUI'
  prefs: []
  type: TYPE_NORMAL
- en: 'RegRipper also has a command line interface, which can be used with other Linux
    tools, such as grep, to directly filter the analysis results. The command line
    is simple, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Run the complete profile against the hive file, where the profile will provide
    you with a list of the plugins that run against this specific hive:![RegistryRipper](img/image_07_027.jpg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Figure 24: Run a complete profile against the hive file'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Alternatively, you can run only one plugin against a hive file to extract a
    single piece of information from this hive. In the following figure, only the
    appcompatcache plugin is running against the system hive:![RegistryRipper](img/image_07_028.jpg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Figure 25: Extracting single information from a hive file.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: It is worth mentioning that appcompatcache parses the registry for the Application
    compatibility cache, which stores information about runnable programs in the system.
    It stores information about the path, size, the timestamp of the last modification,
    and the time of the most recent run of the executable file and also whether it
    was executed in the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the malicious results that can be an indication of malware installation
    on a system is the executable related to one of the banking malware in the following
    figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![RegistryRipper](img/image_07_029.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 26: Malware in the Application compatibility cache'
  prefs: []
  type: TYPE_NORMAL
- en: Here, we can find an executable in the temp folder, which can be an indication
    of downloading this executable from the Internet during browsing. It had a malicious
    name and was executed in the system under investigation.
  prefs: []
  type: TYPE_NORMAL
- en: Sysinternals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sysinternals is a suite used to troubleshoot the Windows system. It was developed
    by Mark Russinovich and can be found at [https://technet.microsoft.com/en-us/sysinternals/bb545021.aspx](https://technet.microsoft.com/en-us/sysinternals/bb545021.aspx).
    It can be used in the forensic analysis to give an indication of infection. It
    usually runs and parses a live system, but it can also work on an offline system.
    We just need to point to the registry locations; these are Windows directory and
    username directory in the offline system.
  prefs: []
  type: TYPE_NORMAL
- en: In Linux, under the Wine environment, privilege escalation is not available,
    and this program needs to run as administrator. So, we need to run this tool on
    any Windows machine. It won't run if you provide the program with the read-only
    mounted image. From the forensics perspective, mounting an image as read/write
    is not acceptable.
  prefs: []
  type: TYPE_NORMAL
- en: 'In such cases, we only need to simulate the locations of the registry files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Windows`: This should be a folder with the following subfolder:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`System32`: This should be a folder with the following subfolder and files:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Config`: This should be a folder with the following files:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SYSTEM`: This is an extracted registry hive'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SOFTWARE`: This is an extracted registry hive'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SAM`: This is an extracted registry hive'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SECURITY`: This is an extracted registry hive'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ntdll.dll`: Copy this file from the mounted image as well (or just empty file
    with that name)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<Username>`: This should be a folder with the following files:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NTUSER.DAT`: This is an extracted registry hive:![Sysinternals](img/image_07_030.jpg)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Figure 27: Simulate Windows registry folders'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Then, we run the `autoruns.exe` within Wine. The `autoruns.exe` tool will display
    many autoruns registry keys and services along with much more useful information
    for analysis.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Analyze Offline System…** from File and browse to the newly created
    folders:![Sysinternals](img/image_07_031.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 28: Open the simulated directories'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The program has different tabs to filter the registry. For example, the Logon
    tab filters the entire registry, which runs while logging to the system. These
    keys are usually used by malware executables in order to preserve its existence
    in the system after a reboot, as discussed earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Sysinternals](img/image_07_032.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 29: An example of offline system registry analysis'
  prefs: []
  type: TYPE_NORMAL
- en: As we can see in Figure 29, for all the entries thst are in yellow and under
    `Image Path` we will find File not found. This is normal because the related system
    isn't actually running.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Scheduled Tasks list is important; it needs to be checked. One technique
    for a malicious executable to preserve its existence is to add itself as a task
    to run every period of time.
  prefs: []
  type: TYPE_NORMAL
- en: MiTeC Windows registry recovery
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'MiTeC WRR is another registry analysis program worth mentioning. It opens one
    hive at a time, and you can open all the hives concurrently. Besides viewing the
    registry in its structured format, it filters the registry based on tasks, such
    as start-up programs and userdata. WRR can be run under Linux within the Wine
    environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '![MiTeC Windows registry recovery](img/image_07_033.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 30: MiTeC WRR'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we got introduced to the registry as one of the most important
    Windows artifacts, which holds most of the operating system and the installed
    programs' configurations and settings. We explained the function of each registry
    hive and its location in the filesystem. Besides this, we parsed the structure
    of one registry file as an important process in case a corrupted registry file
    or a recovered fragment of the registry file needs to be analyzed. Then, we explained
    how malware programs use the registry to preserve their existence in the system
    and how to discover their presence. We used different tools to view and analyze
    the registry files.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will cover another important artifact of the Windows
    operating system, the Event Log files. We will explore how to use event files
    to track the activities of the users in the system and how to discover malicious
    activities within the system.
  prefs: []
  type: TYPE_NORMAL
