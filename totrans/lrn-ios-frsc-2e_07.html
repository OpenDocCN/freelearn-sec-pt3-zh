<html><head></head><body><div class="chapter" title="Chapter&#xA0;7.&#xA0;Applications and Malware Analysis"><div class="titlepage"><div><div><h1 class="title"><a id="ch07"/>Chapter 7. Applications and Malware Analysis</h1></div></div></div><p>Although malware for iOS devices is not so common, it is more common when considering jailbroken devices. As a forensic analyst, you may be required to analyze a malicious application, or more generally the behavior of a suspicious application you have never seen before. While we are not trying to write a comprehensive guide to static reverse engineer iOS applications, this chapter gives an overview of how to analyze an application, whether it is malicious or not. In this chapter, you will first learn how to set up the working environment, and install and configure the basic tools needed for iOS application analysis. Then, we will move on to application analysis principles, learning at which state data can exist and where to look for it. Finally, we will see some tools in action that can help to speed up analysis and automate some tasks.</p><div class="section" title="Setting up the environment"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec58"/>Setting up the environment</h1></div></div></div><p>The first step to take in order to properly set up a testing environment for iOS application analysis is to jailbreak your testing device. This is because, as an analyst, you need to have full control of what is happening in the device, being able to access all kinds of information, whether they are stored in the memory or being sent over the network.</p><p>How to jailbreak an iPhone is out of the scope of this book, so we will not go into the details on how to do it. It is also quite simple. Just download one of the software options available, such as Evasi0n (for iOS 7), Redsn0w (for iOS 8), PanGu (for iOS 8 or 9), and TaiG9 (for iOS 9) and follow the instructions.</p><p>Once the device has been jailbroken and Cydia installed, you also need to install the following tools:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>OpenSSH</strong></span>: This tool allows you to log in to your jailbroken device via Wi-Fi or USB and have a root shell access into it</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>MTerminal</strong></span>: This tool allows you to run terminal commands on your device directly from your device, rather than logging in via SSH from a different system</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>BigBoss recommended tools</strong></span>: This package contains a series of useful command-line tools such as <code class="literal">apt</code>, <code class="literal">make</code>, <code class="literal">wget</code>, <code class="literal">sqlite3</code>, and so on</li></ul></div><p>Something you will always need to do when analyzing a malicious application is to interact with your iPhone via shell, whether to install new tools or launch specific commands from the shell; this is why we installed OpenSSH. The first thing you need to do is to change your default root password, which is <code class="literal">alpine</code>, in order to prevent someone else logging remotely into your device (and with root privileges). To do this, launch the MTerminal application you just installed and run the following commands:</p><pre class="programlisting">
<span class="strong"><strong># su root</strong></span>
<span class="strong"><strong>Password:</strong></span>
<span class="strong"><strong># passwd</strong></span>
<span class="strong"><strong>Changing password for root.</strong></span>
<span class="strong"><strong>New password:</strong></span>
<span class="strong"><strong>Retype new password:</strong></span>
<span class="strong"><strong># </strong></span>
</pre><p>Now, there is a nice and comfortable way to connect to your iPhone via USB instead of being obliged to go over Wi-Fi. In your computer, edit the <code class="literal">~/.ssh/config</code> file by adding the following entry:</p><pre class="programlisting">
<span class="strong"><strong>Host usb</strong></span>
<span class="strong"><strong>HostName 127.0.0.1</strong></span>
<span class="strong"><strong>Port 2222</strong></span>
<span class="strong"><strong>User root</strong></span>
<span class="strong"><strong>RemoteForward 8080 127.0.0.1:8080</strong></span>
</pre><p>This will map the <code class="literal">usb</code> hostname to the <code class="literal">ssh</code> connection with the proper parameters needed. Moreover, the last row sets up port forwarding such that any connections to port <code class="literal">8080</code> on the iPhone will be forwarded to port <code class="literal">8080</code> locally on the laptop. This will be useful when you have to set up a proxy to intercept the network communications, as you will see later in this chapter. Now, you need something listening on port <code class="literal">2222</code>: <code class="literal">usbmuxd</code>. This daemon is in charge of multiplexing connections over USB to the iDevice. To complete the procedure on OS X, you can simply use the following command:</p><pre class="programlisting">
<span class="strong"><strong>$ brew install usbmuxd</strong></span>
<span class="strong"><strong>$ iproxy 2222 22</strong></span>
<span class="strong"><strong>$ ssh usb</strong></span>
</pre><p>Done! Now you have a shell in your iPhone via USB.</p><p>Before installing the other tools, it is a good practice to make sure that the baseline is up to date. To do this, just execute the following commands from your root shell:</p><pre class="programlisting">
<span class="strong"><strong># apt-get update</strong></span>
<span class="strong"><strong># apt-get upgrade</strong></span>
</pre><p>The <code class="literal">update</code> command gets the latest packages list from the default repository, while the <code class="literal">upgrade</code> command will fetch the new versions of packages that already exist on the device and don't have the latest version installed using the information received by the <code class="literal">update</code> command run before.</p><p>The following sections will quickly introduce three important utilities, which you will find useful for dumping encrypted content from memory (for example, code) and the Keychain password container.</p><div class="section" title="class-dump"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec68"/>class-dump</h2></div></div></div><p><span class="strong"><strong>class-dump</strong></span> is a command-line tool used to extract the <span class="strong"><strong>Objective-C</strong></span> class information from (decrypted) iOS applications, and it comes installed with the Cydia package. Note that it will work only with Objective-C apps and not with Swift.</p><p>Finally, be aware that the old <code class="literal">class-dump-z</code> is not compatible with 64-bit architectures, which means from iPhone 5s on.</p></div><div class="section" title="Keychain Dumper"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec69"/>Keychain Dumper</h2></div></div></div><p>A very interesting and useful tool is Keychain Dumper that, as the name suggests, will let you dump the contents from the Keychain. Normally, the way an application is granted access to the Keychain is specified in its entitlements, which define the information that can be accessed by that application. The way this tool works is that the binary is signed with a self-signed certificate with wildcard entitlements. Hence, it is able to access all the Keychain items. To install <code class="literal">keychain_dumper</code>, just download the <code class="literal">zip</code> archive from the GitHub repo at <a class="ulink" href="https://github.com/ptoomey3/Keychain-Dumper">https://github.com/ptoomey3/Keychain-Dumper</a> and unpack it. Then, you only need to copy the <code class="literal">keychain_dumper</code> binary to the phone as follows:</p><pre class="programlisting">
<span class="strong"><strong>$ scp keychain_dumper root@usb:/tmp/</strong></span>
</pre><p>Then, make sure that <code class="literal">keychain_dumper</code> is executable and validate that <code class="literal">/private/var/Keychains/keychain-2.db</code> is world readable. If not, you can set them as follows:</p><pre class="programlisting">
<span class="strong"><strong># chmod u+x keychain_dumper</strong></span>
<span class="strong"><strong># chmod +r /private/var/Keychains/keychain-2.db</strong></span>
</pre><p>You should now be able to run the tool without any issues:</p><pre class="programlisting">
<span class="strong"><strong># ./keychain_dumper</strong></span>
<span class="strong"><strong>Generic Password</strong></span>
<span class="strong"><strong>----------------</strong></span>
<span class="strong"><strong>Service: AirPort</strong></span>
<span class="strong"><strong>Account: ******** Work</strong></span>
<span class="strong"><strong>Entitlement Group: apple</strong></span>
<span class="strong"><strong>Label: (null)</strong></span>
<span class="strong"><strong>Generic Field: (null)</strong></span>
<span class="strong"><strong>Keychain Data: s***iami**********</strong></span>
<span class="strong"><strong>...</strong></span>
<span class="strong"><strong>...</strong></span>
</pre><p>As you can see from the preceding output, by default, <code class="literal">keychain_dumper</code> only dumps generic and Internet passwords. However, you can also specify optional flags to dump additional information from the Keychain, as shown from the help (<code class="literal">-h</code>) command as follows:</p><pre class="programlisting">
<span class="strong"><strong># ./keychain_dumper -h</strong></span>
<span class="strong"><strong>Usage: keychain_dumper [-e]|[-h]|[-agnick]</strong></span>
<span class="strong"><strong>&lt;no flags&gt;: Dump Password Keychain Items (Generic Password, Internet</strong></span>
<span class="strong"><strong>Passwords)</strong></span>
<span class="strong"><strong>-a: Dump All Keychain Items (Generic Passwords, Internet Passwords,</strong></span>
<span class="strong"><strong>Identities, Certificates, and Keys)</strong></span>
<span class="strong"><strong>-e: Dump Entitlements</strong></span>
<span class="strong"><strong>-g: Dump Generic Passwords</strong></span>
<span class="strong"><strong>-n: Dump Internet Passwords</strong></span>
<span class="strong"><strong>-i: Dump Identities</strong></span>
<span class="strong"><strong>-c: Dump Certificates</strong></span>
<span class="strong"><strong>-k: Dump Keys</strong></span>
</pre></div><div class="section" title="dumpDecrypted"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec70"/>dumpDecrypted</h2></div></div></div><p>An executable of an application is encrypted when downloaded from the App Store. The <code class="literal">dumpDecrypted</code> tool, developed by Stefan Esser (his Twitter handle is <code class="literal">@i0n1c</code>), runs the targeted app and dumps it decrypted from memory to disk. To install <code class="literal">dumpDecrypted</code>, download the <code class="literal">zip</code> archive from its GitHub page (<a class="ulink" href="https://github.com/stefanesser/dumpdecrypted">https://github.com/stefanesser/dumpdecrypted</a>) in your Mac (it is for OS X only), unzip it, and compile it on your Mac first. Alternatively, <code class="literal">dumpDecrypted</code> comes also as a tool that can be installed via idb as we will see later.</p></div></div></div>
<div class="section" title="Application analysis"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec59"/>Application analysis</h1></div></div></div><p>When analyzing an application, you need to look at all its activities and interactions with the system by analyzing all the traces and artifacts left on the system while it was running and after it has run and to/from the system. This means being able to understand how and with whom the application communicates by sending and receiving data. Therefore, you need to look at the three states where data can exist. The following are the three states where data can exist:</p><div class="section" title="Data at rest"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec71"/>Data at rest</h2></div></div></div><p>With data at rest, we refer to all the data recorded on storage media; in our case, on the mobile device's internal memory. These are the <code class="literal">plist</code> files, the <code class="literal">sqlite</code> databases, logs, and any other information we can retrieve directly from the media itself. We will not go into much details here, since this procedure is the same as for the forensic analysis of a specific application that is going through the application directory tree structure to check its files and analyze the system logs. Refer to <a class="link" href="ch06.html" title="Chapter 6. Analyzing iOS Devices">Chapter 6</a>, <span class="emphasis"><em>Analyzing iOS Devices</em></span>, for more details.</p></div><div class="section" title="Data in use"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec72"/>Data in use</h2></div></div></div><p>Data in use is, as the name suggests, all data being currently used by the application. Such data resides in the memory (RAM) of the device. In a standard malware analysis for computer malware, memory analysis is, whenever possible, part of the game. Unfortunately, for iOS, but in general, for the entire mobile panorama, memory acquisition and analysis is not well developed yet, although some utilities/proof-of-concepts to dump the memory have been implemented. However, memory analysis and runtime manipulation/abuse are out of the scope of this book, but you can explore them yourself and refer to <span class="strong"><strong>memscan</strong></span> (<a class="ulink" href="https://hexplo.it/introducing-memscan/">https://hexplo.it/introducing-memscan/</a>) or <span class="strong"><strong>heapdump-ios</strong></span> (<a class="ulink" href="https://blog.netspi.com/ios-tutorial-dumping-the-application-heap-from-memory/">https://blog.netspi.com/ios-tutorial-dumping-the-application-heap-from-memory/</a>) to learn about memory analysis, and <span class="emphasis"><em>Hacking and Securing iOS Applications</em></span>, <span class="emphasis"><em>Jonathan Zdziarski</em></span>, <span class="emphasis"><em>O'Reilly Media</em></span>, to learn about runtime manipulation/abuse.</p><p>Another interesting tool you may want to keep in your arsenal is <span class="strong"><strong>Frida</strong></span> (<a class="ulink" href="http://www.frida.re/">http://www.frida.re/</a>), a dynamic instrumentation framework that allows you to inject your own scripts into processes to execute custom debugging logic. Frida has a client/server model, which means you will need to install it both on your computer and on the iDevice.</p><p>On Mac, it is as easy as to type the following:</p><pre class="programlisting">
<span class="strong"><strong>sudo pip install frida</strong></span>
</pre><p>While on your jailbroken iDevice, start Cydia and add Frida's repository by navigating to <span class="strong"><strong>Manage</strong></span> | <span class="strong"><strong>Sources</strong></span> | <span class="strong"><strong>Edit</strong></span> |<span class="strong"><strong>Add</strong></span> and entering <a class="ulink" href="https://build.frida.re">https://build.frida.re</a>. You should now be able to find and install the Frida package. You can find more details about the documentation on Frida's official website. However, talking about memory, a very useful utility built on top of Frida is Fridump (<a class="ulink" href="https://github.com/Nightbringer21/fridump">https://github.com/Nightbringer21/fridump</a>), an open source memory dumping tool. If Frida is correctly installed on both your computer and your iDevice (bear in mind that it would be better to have the same version installed on both), the approach to follow would be first to get the process name via Frida using the following command:</p><pre class="programlisting">
<span class="strong"><strong>$ frida-ps -U</strong></span>
<span class="strong"><strong> PID  Name</strong></span>
<span class="strong"><strong>----  ----------------</strong></span>
<span class="strong"><strong>1744  Cydia</strong></span>
<span class="strong"><strong> 137  Mail</strong></span>
<span class="strong"><strong>1738  Settings</strong></span>
<span class="strong"><strong>1808  Skype</strong></span>
<span class="strong"><strong>  78  BTServer</strong></span>
<span class="strong"><strong>1792  CacheDeleteAppCo</strong></span>
<span class="strong"><strong>...</strong></span>
</pre><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note15"/>Note</h3><p>The <code class="literal">-U</code> parameter indicates that you are targeting the USB connected device.</p></div></div><p>Once you get the process name, you can pass it to <code class="literal">fridump</code> as shown in the following example:</p><pre class="programlisting">
<span class="strong"><strong>$ python fridump.py -u -s --max-size 1048576 Skype</strong></span>
<span class="strong"><strong>        ______    _     _</strong></span>
<span class="strong"><strong>        |  ___|  (_)   | |</strong></span>
<span class="strong"><strong>        | |_ _ __ _  __| |_   _ _ __ ___  _ __</strong></span>
<span class="strong"><strong>        |  _| '__| |/ _` | | | | '_ ` _ \| '_ \</strong></span>
<span class="strong"><strong>        | | | |  | | (_| | |_| | | | | | | |_) |</strong></span>
<span class="strong"><strong>        \_| |_|  |_|\__,_|\__,_|_| |_| |_| .__/</strong></span>
<span class="strong"><strong>                                         | |</strong></span>
<span class="strong"><strong>                                         |_|</strong></span>
<span class="strong"><strong>Current Directory: /Projects/iosmem/fridump</strong></span>
<span class="strong"><strong>Output directory is set to: /Projects/iosmem/dump</strong></span>
<span class="strong"><strong>Creating directory...</strong></span>
<span class="strong"><strong>Starting Memory dump...</strong></span>
<span class="strong"><strong>Progress: [########################################----]88.42% </strong></span>
</pre><p>The preceding example will dump the Skype process from the device connected via USB (<code class="literal">-u</code>), reading in chunks of 1 MB (<code class="literal">--max-size</code>) and extracting also the strings on all dump files (<code class="literal">-s</code>).</p><p>Fridump has been tested successfully on iOS 8, while on iOS 9 from time to time the dump gets stuck close to the end. Even in this case, most of the content is being dumped and you will be able to retrieve what you would expect from any memory dump in the classical computer environment: configuration files, passwords, code executed, everything in clear. Some more information, as well as some case examples, is retrievable from the author's website (<a class="ulink" href="http://pentestcorner.com/introduction-to-fridump/">http://pentestcorner.com/introduction-to-fridump/</a>).</p></div><div class="section" title="Data in transit"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec73"/>Data in transit</h2></div></div></div><p>Data in transit refers to any information that is being transferred between two nodes in a network, which is, in our case, all data sent and received by the target application. Being able to observe and manipulate data sent over the network by an application is extremely interesting and useful for behavioral/dynamic analysis in the case of a suspicious app.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note16"/>Note</h3><p>Before starting, remember to isolate the device from the networks (all of them), especially if you are analyzing a malicious application. Therefore, create an ad hoc wireless network that is isolated (not connected to the Internet or to your internal network), then set your iPhone to Airplane Mode and switch on only the Wi-Fi afterwards so that the other network interfaces remain off.</p></div></div><p>To begin with, you need to route the traffic of the phone through your computer in order to pose yourself as the man in the middle. To use the trick in your <code class="literal">ssh</code> configuration, as we did before, start by launching <code class="literal">iproxy</code> and establishing an <code class="literal">ssh</code> connection to your phone as follows:</p><pre class="programlisting">
<span class="strong"><strong>$ iproxy 2222 22</strong></span>
<span class="strong"><strong>$ ssh usb</strong></span>
</pre><p>Then, from your device network configuration, set up an HTTP proxy to manual toward localhost <code class="literal">127.0.0.1</code> port <code class="literal">8080</code>. It will be redirected to your Mac to port <code class="literal">8080 </code>:</p><div class="mediaobject"><img src="graphics/image_07_001.jpg" alt="Data in transit"/></div><p>Now that the iPhone is set up, you need to set up a proxy listening on your local host port <code class="literal">8080</code>. <span class="strong"><strong>Burp Proxy</strong></span> is probably the most popular proxy (<a class="ulink" href="http://portswigger.net/burp/">http://portswigger.net/burp/</a>); it is cross-platform and there is a free version that works just fine for our purposes. However, there are many others out there, so pick your favorite one. Once an HTTP request has been intercepted, with Burp you can perform several actions, such as modifying the request parameters, intercepting and modifying the response, and much more:</p><div class="mediaobject"><img src="graphics/image_07_002.jpg" alt="Data in transit"/></div><p>However, although Burp is great at intercepting the HTTP/HTTPS protocol, you may want to have a look at all the traffic, because some applications may not use standard HTTP to communicate, and record it for further analysis on a later stage. To do so, you will need to install Wireshark, the standard de facto packet analyzer, together with <code class="literal">tcpdump</code>, and run a capture on your loopback interface <code class="literal">127.0.0.1</code>:</p><div class="mediaobject"><img src="graphics/image_07_003.jpg" alt="Data in transit"/></div><p>Of course, on a jailbroken iPhone, you have full control and may choose to install and go via <code class="literal">tcpdump</code> directly on the device.</p></div></div>
<div class="section" title="Automating the analysis"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec60"/>Automating the analysis</h1></div></div></div><p>This section will quickly introduce some tools that will help you during the analysis, either by speeding up the most common tasks or providing you with some extra and very useful functionalities.</p><div class="section" title="idb"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec74"/>idb</h2></div></div></div><p>Developed and maintained by Daniel Mayer (his Twitter handle is <code class="literal">@DanlAMayer</code>), idb is a tool that simplifies some of the most common tasks related to iOS application analysis. Originally built with a penetration tester/researcher focus, it can be of great value for any type of application analysis, thanks to the number of tools that it incorporates and the features offered. Written in Ruby, the installation procedure is quite straightforward; you just need to run the following commands:</p><pre class="programlisting">
<span class="strong"><strong>$ rvm install 2.1 --enable-shared</strong></span>
<span class="strong"><strong>$ gem install bundler</strong></span>
<span class="strong"><strong>$ brew install qt cmake usbmuxd libimobiledevice</strong></span>
<span class="strong"><strong>$ gem install idb</strong></span>
<span class="strong"><strong>$ idb</strong></span>
</pre><p>This is the procedure for Mac OS X. For more information on building and running it on other systems, you can refer to the official page at <a class="ulink" href="http://www.idbtool.com/">http://www.idbtool.com/</a>.</p><p>Once you have launched idb after following the configuration steps to install some needed extra tools on the device, you will have to connect idb to the USB device, select an application and start the analysis. Note that, even if it will be running a nice GUI, you will be prompted for the root password of the iDevice on the shell where you launched idb.</p><p>Clicking on <span class="strong"><strong>Analyze Binary...</strong></span>, as you can see in the following screenshot, will give the first information on the binary itself, verifying, among other things, that <span class="strong"><strong>PIE</strong></span>, Stack Smashing Protection, and <span class="strong"><strong>ARC</strong></span> are enabled, which would reduce the likelihood of finding memory corruption vulnerabilities to exploit. Moreover, if the binary application is encrypted, <code class="literal">idb</code> will run <code class="literal">dumpdecrypted</code> to decrypt it before analyzing it:</p><div class="mediaobject"><img src="graphics/image_07_004.jpg" alt="idb"/></div><p>Other information related to the binary app can also be extracted from the <span class="strong"><strong>Binary</strong></span> tab. As you will see, idb extracts all the strings from the decrypted binary. This is a standard step you would do when analyzing standard computer malware. This is of great use since here you may find the API keys, credentials, encryption keys, URLs, and other useful hints. From a static analysis perspective, idb binary analysis allows you to dump all the class information.</p><p>Talking about data at rest, under the <span class="strong"><strong>Storage</strong></span> tab, you will be able to analyze all the files related to your target application, such as <code class="literal">plist</code>, the <code class="literal">sqlite</code> databases, and <code class="literal">Cache.db</code>, which contains cached HTTP requests/responses and offline data cached by web applications such as images, HTML, JavaScript, style sheets, and more. The idb tool will also allow you to navigate through the app tree structure from the <span class="strong"><strong>Filesystem</strong></span> tab, taking and storing subsequent different snapshots to navigate and compare at a later stage:</p><div class="mediaobject"><img src="graphics/image_07_005.jpg" alt="idb"/></div><p>Two other interesting functionalities provided are <span class="strong"><strong>URL Handlers</strong></span>, which shows you the list of URL handlers and includes a basic fuzzer that can be used to fuzz input data via the URL schemes, and the <span class="strong"><strong>Keychain</strong></span> dumper, which is a functionality that allows you to dump the Keychain using <code class="literal">keychain_dump</code>.</p><p>The <span class="strong"><strong>Tools</strong></span> tab contains several different tools that are quite handy; they are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Background screenshot</strong></span>: Although this tool is more useful for forensics/security purposes, it looks for an eventual screenshot taken by the system when putting the application in the background by pushing the Home button.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Certification manager</strong></span>: This tool will speed up the management and installation of the CA certificate. This is extremely useful, for example, when using Burp for HTTPS traffic and an application that actually checks that SSL is in place.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>/etc/hosts file editor</strong></span>: As we have seen before for the data in transit, apps do not always use the HTTP/S protocol, so Burp will not intercept. With this editor, you can quickly access and modify <code class="literal">/etc/hosts</code> of the iPhone in order to redirect the traffic toward custom services you may have fired up for the analysis.</li></ul></div><div class="mediaobject"><img src="graphics/image_07_006.jpg" alt="idb"/></div><p>Last but not least, <code class="literal">idb</code> offers a real-time log (<code class="literal">syslog</code>) and pasteboard viewer (refer to the following screenshot) via the <span class="strong"><strong>Log</strong></span> and <span class="strong"><strong>Pasteboard</strong></span> tabs, respectively. Although it may not seem of great use to monitor the pasteboard when you are the one testing the application, it may surprise you to know that applications use the pasteboard also for <span class="strong"><strong>Inter-Process Communication</strong></span> (<span class="strong"><strong>IPC</strong></span>). By default, idb monitors only the main (default) pasteboard, but you can add additional pasteboard names to the list on the right-hand side so that you will also be able to monitor the private pasteboards.</p><p>Regarding the Log panel, idb includes both system messages and any log statements that the app produces using <code class="literal">NSLog</code>, which often discloses sensitive data:</p><div class="mediaobject"><img src="graphics/image_07_007.jpg" alt="idb"/></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec61"/>Summary</h1></div></div></div><p>In this chapter, we introduced some tools for analyzing iOS applications, suspicious or not, mainly from a behavioral/dynamic point of view. You learned how to quickly analyze the binary, review the data and logs produced by the targeted application, intercept, manipulate, and analyze the data sent and received over the network, and automate most of the tasks with ad hoc toolkits, such as idb.</p></div>
<div class="section" title="Self-test questions"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec62"/>Self-test questions</h1></div></div></div><p>Q1. Which tool can be used to extract Objective-C class information from iOS applications?</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">OpenSSH</li><li class="listitem"> MTerminal</li><li class="listitem"> class-dump</li><li class="listitem"> Keychain Dumper</li></ol></div><p>Q2. Which tool can be used to dump an unencrypted application from memory?</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">usbmuxd</li><li class="listitem">Keychain Dumper</li><li class="listitem">dumpDecrypted</li><li class="listitem">OpenSSH</li></ol></div><p>Q3. Which tool can be used to verify the pasteboard content?</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">dumpDecrypted</li><li class="listitem">iRet</li><li class="listitem">iLoot</li><li class="listitem">idb</li></ol></div><p>Q4. Which tools would you use to best analyze data in transit?</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Burp Proxy + Wireshark</li><li class="listitem">iproxy + Wireshark</li><li class="listitem">dumpDecrypted + tcpdump</li><li class="listitem">tcpdump + iproxy</li></ol></div><p>Q5. Which set of tools allow automating a series of tasks in order to analyze and reverse engineer iOS applications?</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">iLoot</li><li class="listitem">idb</li><li class="listitem">class-dump</li><li class="listitem">dumpDecrypted</li></ol></div></div></body></html>