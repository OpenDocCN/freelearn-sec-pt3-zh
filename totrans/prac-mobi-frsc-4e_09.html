<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Understanding Android</h1>
                </header>
            
            <article>
                
<p>In the previous chapters, we covered details about iOS devices, including the filesystem structure, key artifacts, backup files, and acquisition and analysis methods. Starting with this chapter, we will focus on the Android platform and how to perform forensics on Android devices. Having a good understanding of the Android ecosystem, security constraints, filesystems, and other features would prove useful during a forensic investigation. Gaining knowledge of these fundamentals would help a forensic expert to make informed decisions while conducting an investigation.</p>
<p>We will cover the following topics in this chapter:</p>
<ul>
<li>The evolution of Android</li>
<li>The Android architecture</li>
<li>Android security</li>
<li>The Android file hierarchy</li>
<li>The Android filesystem</li>
</ul>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The evolution of Android</h1>
                </header>
            
            <article>
                
<p>Android is a Linux-based mobile operating system developed for touchscreen mobile devices. It is developed by a consortium of companies known as the <strong>Open Handset Alliance</strong> (<strong>OHA</strong>), with the primary contributor and commercial marketer being Google. The Android operating system has evolved significantly since its inaugural release date. Android was officially launched to the public in 2008, with Android version 1.0. With the Android 1.5 Cupcake release in 2009, the tradition of naming Android versions after confectionery was born. The version names were also released in alphabetical order for the next 10 years. However, in 2019, Google announced that they were ending the confectionery-based naming, and were using numerical ordering for future versions. In the initial years, Android versions were updated more than twice a year, but in more recent years, version updates are done once per year. The most recent major Android update is Android 11, the eleventh major version of the Android operating system, announced by Google on February 19, 2020. </p>
<p>The following is an overview of Android version history as of the time of writing:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td>
<p><strong>Version</strong></p>
</td>
<td>
<p><strong>Version name</strong></p>
</td>
<td>
<p><strong>Release year</strong></p>
</td>
</tr>
<tr>
<td>
<p>Android 1.0</p>
</td>
<td>
<p>Apple Pie</p>
</td>
<td>
<p>2008</p>
</td>
</tr>
<tr>
<td>
<p>Android 1.1</p>
</td>
<td>
<p>Banana Bread</p>
</td>
<td>
<p>2009</p>
</td>
</tr>
<tr>
<td>
<p>Android 1.5</p>
</td>
<td>
<p>Cupcake</p>
</td>
<td>
<p>2009</p>
</td>
</tr>
<tr>
<td>
<p>Android 1.6</p>
</td>
<td>
<p>Donut</p>
</td>
<td>
<p>2009</p>
</td>
</tr>
<tr>
<td>
<p>Android 2.0</p>
</td>
<td>
<p>Eclair</p>
</td>
<td>
<p>2009</p>
</td>
</tr>
<tr>
<td>
<p>Android 2.2</p>
</td>
<td>
<p>Froyo</p>
</td>
<td>
<p>2010</p>
</td>
</tr>
<tr>
<td>
<p>Android 2.3</p>
</td>
<td>
<p>Gingerbread</p>
</td>
<td>
<p>2010</p>
</td>
</tr>
<tr>
<td>
<p>Android 3.0</p>
</td>
<td>
<p>Honeycomb</p>
</td>
<td>
<p>2011</p>
</td>
</tr>
<tr>
<td>
<p>Android 4.0</p>
</td>
<td>
<p>Ice Cream Sandwich</p>
</td>
<td>
<p>2011</p>
</td>
</tr>
<tr>
<td>
<p>Android 4.1</p>
</td>
<td>
<p>Jelly Bean</p>
</td>
<td>
<p>2012</p>
</td>
</tr>
<tr>
<td>
<p>Android 4.4</p>
</td>
<td>
<p>KitKat</p>
</td>
<td>
<p>2013</p>
</td>
</tr>
<tr>
<td>
<p>Android 5.0</p>
</td>
<td>
<p>Lollipop</p>
</td>
<td>
<p>2014</p>
</td>
</tr>
<tr>
<td>
<p>Android 6.0</p>
</td>
<td>
<p>Marshmallow</p>
</td>
<td>
<p>2015</p>
</td>
</tr>
<tr>
<td>
<p>Android 7.0</p>
</td>
<td>
<p>Nougat</p>
</td>
<td>
<p>2016</p>
</td>
</tr>
<tr>
<td>
<p>Android 8.0</p>
</td>
<td>
<p>Oreo</p>
</td>
<td>
<p>2017</p>
</td>
</tr>
<tr>
<td>
<p>Android 9.0</p>
</td>
<td>
<p>Pie</p>
</td>
<td>
<p>2018</p>
</td>
</tr>
<tr>
<td>
<p>Android 10.0</p>
</td>
<td>
<p>Q</p>
</td>
<td>
<p>2019</p>
</td>
</tr>
<tr>
<td>
<p>Android 11</p>
</td>
<td>
<p>R</p>
</td>
<td>
<p>2020</p>
</td>
</tr>
</tbody>
</table>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p>This evolution has also dramatically impacted the security considerations of Android and how forensics techniques are applied. For example, the initial versions of Android did not have a <strong>Full Disk Encryption</strong> (<strong>FDE</strong>) mechanism to store data in an encrypted format within the device. As a result, extracting data from the device was much easier for a forensic investigator than it is currently. With each Android version update, more and more security features, such as app permissions, <strong>trusted execution environment</strong> (<strong>TEE</strong>), and secure kernel, have been added to improve the security of the platform overall but at the same time complicate the process of data extraction. We shall cover these security features in detail in the other sections of this chapter. </p>
<p class="mce-root">Now that we know about the history and versions of Android, we will take a look at the Android architecture in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Android architecture</h1>
                </header>
            
            <article>
                
<p>To effectively understand forensic concepts when dealing with Android, you should have a basic understanding of the Android architecture. Just like a computer, any computing system that interacts with the user and performs complicated tasks requires an operating system to handle the tasks effectively. This operating system (whether it's a desktop operating system or a mobile phone operating system) is responsible for managing the resources of the system, to provide a way for the applications to talk to the hardware or physical components to accomplish certain tasks. Android is currently the most popular mobile operating system designed to power mobile devices. You can find out more about this at <a href="https://developer.android.com/about/android.html" target="_blank"><span class="URLPACKT">https://developer.android.com/about/android.html</span></a>.</p>
<p>Android, as an open source operating system, releases its code under the Apache License, one of the many open source licenses. Practically, this means anyone (especially device manufacturers) can access it, freely modify it, and use the software according to the requirements of any device. This is one of the primary reasons for its wide acceptance. Notable players that use Android include Samsung, HTC, Sony, and LG.</p>
<p>As with any other platform, Android consists of a stack of layers running one above the other. To understand the Android ecosystem, it's essential to have a basic understanding of what these layers are and what they do.</p>
<p class="mce-root"/>
<p>The following diagram summarizes the various layers involved in the Android software stack:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1192 image-border" src="assets/6ee0ce43-84de-41ea-8a04-dec28c003cc9.png" style="width:31.75em;height:46.17em;"/></p>
<div class="packt_figure packt_figref CDPAlignCenter CDPAlign"><span>Android architecture <br/></span> This image is modified based on work created and shared by the Android Open Source Project: https://developer.android.com/guide/platform<br/>
License: https://creativecommons.org/licenses/by/4.0/</div>
<p class="mce-root"/>
<p>Each of these layers performs several operations that support specific operating system functions. Each layer provides services to the layers lying on top of it. Let's look at them in a little more detail.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Linux kernel layer</h1>
                </header>
            
            <article>
                
<p>The Android operating system is built on top of the Linux kernel, with some architectural changes made by Google. There are several reasons for choosing the Linux kernel. Most importantly, Linux is a portable platform that can be compiled easily on different hardware. The kernel acts as an abstraction layer between the software and hardware present on the device. Consider the case of a camera. What happens when you take a photo using the camera button on your device? At some point, the hardware instruction (pressing a button) has to be converted to a software instruction (to take a picture and store it in the gallery). The kernel contains drivers to facilitate this process. When the user presses the button, the instruction goes to the corresponding camera driver in the kernel, which sends the necessary commands to the camera hardware, similar to what occurs when a key is pressed on a keyboard. In simple words, the drivers in the kernel command control the underlying hardware. As shown in the Android architecture model, the kernel contains drivers related to Wi-Fi, Bluetooth, <strong>Universal Service Bus</strong> (<strong>USB</strong>), audio, display, and so on.</p>
<p>The Linux kernel is responsible for managing the core functionality of Android, such as process management, memory management, security, and networking. Linux is a proven platform when it comes to security and process management. Android has taken leverage of the existing Linux open source operating system to build a solid foundation for its ecosystem. Each version of Android has a different version of the underlying Linux kernel. The Oreo Android version is known to use Linux kernel 3.18 or 4.9, whereas the Pie version is known to use Linux kernel 4.4, 4.9, or 4.14. Android Q, targets Linux kernel 4.9, 4.14, or 4.19. The actual kernel depends on the individual device.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Hardware Abstraction Layer</h1>
                </header>
            
            <article>
                
<p>The device hardware capabilities are exposed to the high-level Java framework through the <strong>Hardware Abstraction Layer</strong> (<strong>HAL</strong>). The HAL consists of several library modules that implement interfaces for a specific type of hardware component. This allows hardware vendors to implement functionality without changing the higher-level system.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Libraries</h1>
                </header>
            
            <article>
                
<p>The next layer in the Android architecture consists of Android's native libraries. The libraries are written in C or C++, and help the device to handle different kinds of data. For example, the SQLite libraries are useful for storing and retrieving the data from a database. Other libraries include Media Framework, WebKit, Surface Manager, and <strong>Secure Sockets Library</strong> (<strong>SSL</strong>).</p>
<p>The Media Framework library acts as the main interface to provide a service to the other underlying libraries. The WebKit library provides web pages in web browsers, and the Surface Manager library maintains the graphics. In the same layer, we have <strong>Android Runtime</strong> (<strong>ART</strong>) and core libraries. ART is responsible for running applications on Android devices. The term <em>runtime</em> refers to the time from when an application is launched until it is shut down.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Dalvik Virtual Machine (DVM)</h1>
                </header>
            
            <article>
                
<p>All the applications that you install on the Android device are written in the Java programming language. When a Java program is compiled, we get bytecode. A <strong>virtual machine</strong> (<strong>VM</strong>) is an application that acts as an operating system—that is, it is possible to run an instance of the Windows operating system on a Mac, or vice versa, using a VM. <strong>Java Virtual Machine</strong> (<strong>JVM</strong>) is one such VM that can execute the previously mentioned bytecode. But Android versions before Android 5.0 used something called DVM to run their applications.</p>
<p>DVM runs Dalvik bytecode, which is Java bytecode converted by the <strong>Dalvik Executable</strong> (<strong>DEX</strong>) compiler. Thus, the <kbd>.class</kbd> files are converted to <kbd>dex</kbd> files using the <kbd>dx</kbd> tool. Dalvik bytecode, when compared with Java bytecode, is more suitable for low-memory and low-processing environments. Also, note that JVM's bytecode consists of one or more <kbd>.class</kbd> files, depending on the number of Java files that are present in an application, but Dalvik bytecode is composed of only one <kbd>dex</kbd> file. Each Android application runs its own instance of DVM. This is a crucial aspect of Android security and will be addressed in detail in <a href="b1621e6e-80a3-495e-a288-c8db601149f8.xhtml" target="_blank">Chapter 8</a>, <em>Android Forensic Setup and Pre-Data Extraction Techniques</em>.</p>
<p>The following diagram provides an insight into how Android's DVM differs from Java's JVM:</p>
<p class="mce-root"/>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-691 image-border" src="assets/ff51cea3-861f-42fb-b320-de90d9d3b12a.png" style="width:21.33em;height:34.67em;"/></p>
<div class="packt_figure packt_figref CDPAlignCenter CDPAlign">JVM versus DVM</div>
<p>Now that we have understood the basic differences between JVM and DVM, let's quickly have a look at ART.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">ART</h1>
                </header>
            
            <article>
                
<p>From the Android 5.0 Lollipop version onward, Dalvik was replaced by ART. Earlier versions of Android used <strong>just-in-time</strong> (<strong>JIT</strong>) compilation with Dalvik (frequently executed operations are identified and dynamically compiled to native machine code). This native execution of these frequently used bytecodes, called traces, provides significant performance improvements.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Unlike Dalvik, ART uses <strong>ahead-of-time</strong> (<strong>AOT</strong>) compilation, which compiles entire applications into native machine code upon their installation. This automatically increases the install time for an application, but a major advantage is that this eliminates Dalvik's interpretation and trace-based JIT compilation, and thereby increases efficiency and reduces power consumption. ART uses a utility called <kbd>dex2oat</kbd> that accepts <kbd>DEX</kbd> files as input and generates a compiled app executable for the target device. With ART, the <strong>optimized DEX</strong> (<strong>.odex</strong>) files have been replaced with the <strong>Executable and Linkable Format</strong> (<strong>ELF</strong>) executables.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Java API framework layer</h1>
                </header>
            
            <article>
                
<p>The application framework is the layer responsible for handling the basic functioning of a phone, such as resource management, handling calls, and so on. This is the block through which the applications installed on the device directly talk to it. The following are some of the important blocks in the application framework layer:</p>
<ul>
<li><strong>Telephony Manager</strong>: This block manages all the voice calls.</li>
<li><strong>Content Provider</strong>: This block manages the sharing of data between different applications.</li>
<li><strong>Resource Manager</strong>: This block manages various resources used in applications.</li>
</ul>
<p>The final layer is the system apps layer, which will be discussed next.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The system apps layer</h1>
                </header>
            
            <article>
                
<p>This is the topmost layer where the user can interact directly with the device. There are two kinds of applications—preinstalled applications and user-installed applications. Preinstalled applications—such as dialer, web browser, and contacts—come along with the device. User-installed applications can be downloaded from different places, such as Google Play Store, Amazon Marketplace, and so on. Everything that you see on your phone (contacts, mail, camera, and so on) is an application.</p>
<p>So far, we have learned about the Android architecture and the important building blocks. We shall now dive into some of the inherent security features in the Android operating system. </p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Android security</h1>
                </header>
            
            <article>
                
<p>Android was designed with a specific focus on security. Android as a platform offers and enforces certain features that safeguard the user data present on the mobile through multilayered security. There are certain safe defaults that will protect the user, and there are certain offerings that can be leveraged by the development community to build secure applications. As a forensic investigator, understanding the internals of Android security is crucial as it helps to identify the best techniques to apply in a given situation, the technical limitations of certain techniques, and so on. </p>
<p>The next few sections will help us understand more about Android's security features and offerings.</p>
<div class="packt_infobox">A detailed explanation on Android security can be found at <a href="https://source.android.com/security/" target="_blank"><span class="URLPACKT">https://source.android.com/security/</span></a>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Secure kernel</h1>
                </header>
            
            <article>
                
<p>The kernel is at the heart of the security of any operating system. By choosing Linux, which has evolved as a trusted platform over the years, Android has established a very solid security foundation. Most of the security features that are inherent to the Linux kernel are automatically adopted by Android. For example, the user-based permission model of Linux has, in fact, worked well for Android. As mentioned earlier, there is a lot of specific code built into the Linux kernel. With each Android version release, the kernel version has also changed. The following table shows Android versions and their corresponding kernel versions:</p>
<table style="border-collapse: collapse;width: 100%" class="table" border="1">
<tbody>
<tr>
<td>
<p><strong>Android version</strong></p>
</td>
<td>
<p><strong>Linux kernel version</strong></p>
</td>
</tr>
<tr>
<td>
<p>1</p>
</td>
<td>
<p>2.6.25</p>
</td>
</tr>
<tr>
<td>
<p>1.5</p>
</td>
<td>
<p>2.6.27</p>
</td>
</tr>
<tr>
<td>
<p>1.6</p>
</td>
<td>
<p>2.6.29</p>
</td>
</tr>
<tr>
<td>
<p>2.2</p>
</td>
<td>
<p>2.6.32</p>
</td>
</tr>
<tr>
<td>
<p>2.3</p>
</td>
<td>
<p>2.6.35</p>
</td>
</tr>
<tr>
<td>
<p>3.0</p>
</td>
<td>
<p>2.6.36</p>
</td>
</tr>
<tr>
<td>
<p>4.0</p>
</td>
<td>
<p>3.0.1</p>
</td>
</tr>
<tr>
<td>
<p>4.1</p>
</td>
<td>
<p>3.0.31</p>
</td>
</tr>
<tr>
<td>
<p>4.2</p>
</td>
<td>
<p>3.4.0</p>
</td>
</tr>
<tr>
<td>
<p>4.2</p>
</td>
<td>
<p>3.4.39</p>
</td>
</tr>
<tr>
<td>
<p>4.4</p>
</td>
<td>
<p>3.8</p>
</td>
</tr>
<tr>
<td>
<p>5.0</p>
</td>
<td>
<p>3.16.1</p>
</td>
</tr>
<tr>
<td>
<p>6.0</p>
</td>
<td>
<p>3.18.1</p>
</td>
</tr>
<tr>
<td>
<p>7.0</p>
</td>
<td>
<p>4.4.1</p>
</td>
</tr>
<tr>
<td>
<p>8.0</p>
</td>
<td>
<p>4.10</p>
</td>
</tr>
<tr>
<td>
<p>9.0</p>
</td>
<td>
<p>4.4, 4.9, and 4.14</p>
</td>
</tr>
<tr>
<td>
<p><span>10.0</span></p>
</td>
<td>
<p><span> 4.9, 4.14, and 4.19</span></p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p class="mce-root">The Linux kernel automatically brings some of its inherent security features, such as the following, to the Android platform:</p>
<ul>
<li class="mce-root">A user-based permissions model</li>
<li class="mce-root">Isolation of running processes (application sandbox)</li>
<li class="mce-root">Secure <strong>inter-process communication</strong> (<strong>IPC</strong>)</li>
</ul>
<p>We shall now learn about each of these features. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The permission model</h1>
                </header>
            
            <article>
                
<p>As shown in the following screenshot, any Android application must be granted permissions to access sensitive functionality—such as the internet, dialer, and so on—by the user. This provides an opportunity for the user to know in advance which functionality on the device is being accessed by the application. Simply put, it requires the user's permission to perform any kind of malicious activity (stealing data, compromising the system, and so on).</p>
<p>This model helps the user to prevent attacks, but if the user is unaware and gives away a lot of permissions, it leaves them in trouble (remember—when it comes to installing malware on any device, the weakest link is always the user).</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/cd2f6a83-7870-4892-8d69-d73868619edd.png" style="width:22.08em;height:38.33em;"/></p>
<div class="packt_figure packt_figref CDPAlignCenter CDPAlign">The permission model in Android</div>
<p>Until Android 6.0, users needed to grant the permissions during install time. Users had to either accept all the permissions or not install the application. But, starting from Android 6.0, users grant permissions to apps while the app is running. This new permission system also gives the user more control over the app's functionality by allowing the user to grant selective permissions. For example, a user can deny a particular app access to their location but provide access to the internet. The user can revoke the permissions at any time by going to the app's <span class="packt_screen">Settings</span> screen. From a forensic perspective, what this means is that the kind of information that can be extracted from a device depends not only on the device and the installed apps but also on the permissions that are configured by the user. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Application sandbox</h1>
                </header>
            
            <article>
                
<p>In Linux systems, each user is assigned a unique <strong>user identifier</strong> (<strong>UID</strong>), and users are segregated so that one user cannot access the data of another user. However, all applications under a particular user are run with the same privileges. Similarly, in Android, each application runs as a unique user. In other words, a UID is assigned to each application and is run as a separate process. This concept ensures an application sandbox at the kernel level. The kernel manages the security restrictions between the applications by making use of existing Linux concepts, such as UID and <strong>group identifier</strong> (<strong>GID</strong>). If an application attempts to do something malicious—say, to read the data of another application—this is not permitted as the application does not have user privileges. Hence, the operating system protects an application from accessing the data of another application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Secure IPC</h1>
                </header>
            
            <article>
                
<p>Android offers secure IPC, through which one activity in an application can send messages to another activity in the same or a different application. To achieve this, Android provides IPC mechanisms: Intents, Services, Content Providers, and so on. This is more relevant to developers who code third-party apps for the Android platform. Behind the scenes, forensic tools exploit some of these concepts to gain access to the device information. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Application signing</h1>
                </header>
            
            <article>
                
<p>It is mandatory that all of the installed applications are digitally signed. Developers can place their applications in Google's Play Store only after signing the applications. The private key with which the application is signed is held by the developer. Using the same key, a developer can provide updates to their application, share data between the applications, and so on. Unsigned applications, if attempted to be installed, will be rejected by either Google Play or the package installer on the Android device. In Android 8.0 and above, users must navigate to the <span class="packt_screen">Install unknown apps</span> setting in order to run unsigned apps, as shown in the following screenshot:</p>
<p class="mce-root"/>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1232 image-border" src="assets/c0984e6e-5005-4e9e-ab00-3b83223b7431.png" style="width:27.83em;height:25.58em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref"><span>Install unknown apps screen in Android</span></div>
<p>Now that we have some basic knowledge about digitally signed applications, let's look at one of the security features in Android.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Security-Enhanced Linux (SELinux)</h1>
                </header>
            
            <article>
                
<p>SELinux is a security feature that was introduced in Android 4.3 and fully enforced in Android 5.0. Until this addition, Android security was based on <strong>Discretionary Access Control</strong> (<strong>DAC</strong>), which means applications can ask for permissions, and users can grant or deny those permissions. Thus, malware can create havoc on phones by gaining those permissions. But SE Android uses <strong>Mandatory Access Control</strong> (<strong>MAC</strong>), which ensures that applications work in isolated environments. Hence, even if a user installs a malware app, the malware cannot access the operating system and corrupt the device. SELinux is used to enforce MAC over all the processes, including the ones running with root privileges. In SELinux, anything that is not explicitly allowed is, by default, denied. SELinux can operate in one of the two global modes: <strong>Permissive</strong> mode, which logs the permission denials but does not enforce them; and <strong>Enforcing</strong> mode, which logs and also enforces the permission denials. More details about SELinux can be found at <a href="https://source.android.com/security/selinux/concepts"><span class="URLPACKT">https://source.android.com/security/selinux/concepts</span></a>.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">FDE</h1>
                </header>
            
            <article>
                
<p>With Android 6.0 Marshmallow, Google has mandated FDE for most devices, provided that the hardware meets certain minimum standards. Encryption is the process of converting data into ciphertext using a secret key. On Android devices, FDE refers to the process of encrypting all user data using a secret key. This key is in turn encrypted by the device's <strong>personal identification number</strong> (<strong>PIN</strong>)/pattern/password that is set by the user. Once a device is encrypted, all user-created data is automatically encrypted before writing it to disk, and all reads automatically decrypt data before returning it to the calling process. FDE in Android works only with an <strong>Embedded Multimedia Card</strong> (<strong>eMMC</strong>) and similar flash devices that present themselves to the kernel as block devices.</p>
<p>Staring from Android 7.x, Google decided to shift the encryption feature from FDE to <strong>file-based encryption</strong> (<strong>FBE</strong>). In FBE, different files are encrypted with different keys. By doing so, those files can be accessed independently, without the need to decrypt the complete partition. As a result of this, the system can now display open notifications or access boot-related files without having to wait until the user unlocks the phone.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Android Keystore</h1>
                </header>
            
            <article>
                
<p>Android K<span>eystore</span><span> </span><span>is used to protect sensitive cryptographic keys from unauthorized access. Keys stored within a Keystore can be used to perform cryptographic operations, but they can never be extracted outside of the Keystore. The hardware-backed Keystores provide security at hardware level—that is, even if the operating system is compromised, the keys in the hardware module would still be secure.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">TEE</h1>
                </header>
            
            <article>
                
<p>A TEE is an isolated area (typically, a separate microprocessor) intended to guarantee the security of data stored inside it, and also to execute code with integrity. The main processor on mobile devices is considered untrusted and cannot be used to store secret data (such as cryptographic keys). Hence, a TEE is used specifically to perform such operations, and the software running on the main processor delegates any operations that require the use of secret data to the TEE processor.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Verified Boot</h1>
                </header>
            
            <article>
                
<p>Verified Boot tries to ensure that all code that is executed on an Android device comes from a legitimate source rather than from an attacker or a fraud. It establishes a full chain of trust and prevents side-loading of any other operating system. During device boot-up, each stage validates the integrity and authenticity of the next stage before handing over execution.</p>
<p>We shall now look into the various partitions and filesystems available on an Android device. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Android file hierarchy</h1>
                </header>
            
            <article>
                
<p>In order to perform forensic analysis on any system (desktop or mobile), it's important to understand the underlying file hierarchy. A basic understanding of how Android organizes its data in files and folders helps a forensic analyst narrow down their research to specific issues. Just as with any other operating system, Android uses several partitions. This chapter provides an insight into some of the most significant partitions and the content stored in them.</p>
<p>It's worth mentioning again that Android uses the Linux kernel. Hence, if you are familiar with Unix-like systems, you will understand the file hierarchy in Android very well. For those who are not very well acquainted with the Linux model, here is some basic information: in Linux, the file hierarchy is a single tree, with the top of the tree being denoted as <kbd>/</kbd> (called the <em>root</em>). This is different from the concept of organizing files in drives (as with Windows). Whether the filesystem is local or remote, it will be present under the root.</p>
<p class="mce-root"/>
<p>The Android file hierarchy is a customized version of this existing Linux hierarchy. Based on the device manufacturer and the underlying Linux version, the structure of this hierarchy may have a few insignificant changes. The following is a list of important folders that are common to most Android devices. Some of the folders listed are only visible through root access. Rooting is the process of gaining privileged access on an Android device. More details about rooting and executing the <kbd>adb</kbd> commands (which are shown in the following list) are covered in detail in <a href="b1621e6e-80a3-495e-a288-c8db601149f8.xhtml" target="_blank">Chapter 8</a>, <em>Android Forensic Setup and Pre-Data Extraction Techniques</em>:</p>
<ul>
<li><kbd>/boot</kbd>: As the name suggests, this partition has the information and files required for the phone to boot. It contains the kernel and <strong>Random Access Memory</strong> (<strong>RAM</strong>) disk, so without this partition, the phone cannot start its processes. Data residing in RAM is rich in value and should be captured during a forensic acquisition.</li>
<li><kbd>/system</kbd>: This partition contains system-related files other than the kernel and RAM disk. This folder should never be deleted as that will make the device unbootable. The contents of this partition can be viewed using the following command:</li>
</ul>
<p class="CDPAlignCenter CDPAlign"><img src="assets/d596a874-3308-425c-8db7-270b404755f3.png" style="width:15.42em;height:24.00em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">/system partition</div>
<ul>
<li>* <kbd>/recovery</kbd>: This is designed for backup purposes and allows the device to boot into recovery mode. In recovery mode, you can find tools to repair your phone installation.</li>
<li><kbd>/data</kbd>: This is the partition that contains the data of each application. Most of the data belonging to the user—such as the contacts, SMS, and dialed numbers—is stored in this folder. This folder has significant importance from a forensic point of view as it holds valuable data. The contents of the data folder can be viewed using the following command:</li>
</ul>
<p class="CDPAlignCenter CDPAlign"><img src="assets/dbfb40c0-e007-4322-be05-327102e4b80c.png" style="width:14.50em;height:29.67em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>/data partition</span></div>
<ul>
<li>* <kbd>/cache</kbd>: This is the folder used to store the frequently accessed data and some of the logs for faster retrieval. The <kbd>/cache</kbd> partition is also important to a forensic investigation as the data residing here may no longer be present in the <kbd>/data</kbd> partition.</li>
<li>* <kbd>/misc</kbd>: As the name suggests, this folder contains information about miscellaneous settings. These settings mostly define the state of the device—that is, on/off. Information about hardware settings, USB settings, and so on can be accessed from this folder.</li>
<li><kbd>/sdcard</kbd>: This is the partition that holds all the information present on the <strong>Secure Digital</strong> (<strong>SD</strong>) card. It is valuable as it can contain information such as pictures, videos, files, documents, and so on.</li>
</ul>
<p>Now that we have understood the Android file hierarchy and looked at the important folders in it, let's have a look at the filesystem in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Android filesystem</h1>
                </header>
            
            <article>
                
<p>Understanding the filesystem is one essential part of forensic methodologies. Knowledge about the properties and the structure of a filesystem proves to be useful during forensic analysis. The filesystem refers to the way data is stored, organized, and retrieved from a volume. A basic installation may be based on one volume split into several partitions; here, each partition can be managed by a different filesystem. As is true in Linux, Android utilizes mount points, and not drives (that is, <kbd>C:</kbd> or <kbd>E:</kbd>).</p>
<div class="packt_infobox">In Linux, mounting is an act of attaching an additional filesystem to the currently accessible filesystem of a computer. <span>The filesystems in Linux are not accessed by drive names but instead are organized into a multi-level <span>hierarchy with a directory called</span></span> <kbd>root</kbd> <span><span>at the top</span>. Each new filesystem is added into this single filesystem tree when it is mounted.</span></div>
<p>It does not make any difference whether the filesystem exists on the local device or on a remote device. Everything is in a single hierarchy that begins with <kbd>root</kbd>. Each filesystem defines its own rules for managing the files in the volume. Depending on these rules, each filesystem offers a different speed for file retrieval, security, size, and so on. Linux uses several filesystems, and so does Android. From a forensic point of view, it's important to understand which filesystems are used by Android and to identify the filesystems that are of significance to the investigation. For example, the filesystem that stores the user's data is of primary concern to us, as opposed to a filesystem used to boot the device.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Viewing filesystems on an Android device</h1>
                </header>
            
            <article>
                
<p>The filesystems supported by the Android kernel can be determined by checking the contents of the <kbd>filesystems</kbd> file in the <kbd>proc</kbd> folder. The content of this file can be viewed using the <kbd># cat /proc/filesystems</kbd> command:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/233ac818-3d93-4d98-8b96-8a364216653d.png" style="width:22.83em;height:29.58em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Filesystems on an Android device</div>
<p>In the preceding output, the first column tells us whether the filesystem is mounted on the device. The ones with the <kbd>nodev</kbd> property are not mounted on the device.</p>
<p class="mce-root"/>
<p>The second column lists all the filesystems present on the device. A simple <kbd>mount</kbd> command displays different partitions available on the device, as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/33438950-4399-4e5b-aa48-07cbeb9abf73.png"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>Partitions on the Android device</span></div>
<p>Next, let's look at the common filesystems on Android.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Common filesystems found on Android</h1>
                </header>
            
            <article>
                
<p>The filesystems present in Android can be organized primarily into three main categories, as follows:</p>
<ul>
<li>Flash memory filesystems</li>
<li>Media-based filesystems</li>
<li>Pseudo filesystems</li>
</ul>
<p>Let's look at each of them in detail.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Flash memory filesystems</h1>
                </header>
            
            <article>
                
<p>Flash memory is a type of constantly powered <strong>nonvolatile memory</strong> (<strong>NVM</strong>) that retains data in the absence of a power supply. Flash memory can be erased and reprogrammed in units of memory called blocks. While the supported filesystems vary based on the device and underlying Linux kernel, the common flash memory filesystems are as follows:</p>
<ul>
<li><strong>Extended File Allocation Table</strong> (<strong>exFAT</strong>) is a Microsoft proprietary filesystem that was created to be used on flash drives such as USB memory sticks and SD cards. Because of the license requirements, it isn't part of the standard Linux kernel. But still, a few manufacturers provide support for this filesystem.</li>
<li><strong>Flash Friendly File System </strong>(<strong>F2FS</strong>) was released in February 2013 to support Samsung devices running the Linux 3.8 kernel. F2FS relies on log-structured methods that optimize the NAND flash memory. The offline support features are a highlight of this filesystem, though it is still transient and being updated.</li>
<li><strong>Yet Another Flash File System 2 </strong>(<strong>YAFFS2</strong>) is an open source, single-threaded filesystem released in 2002. It is mainly designed to be fast when dealing with the NAND flash. YAFFS2 utilizes <strong>Out</strong>-<strong>of</strong>-<strong>band </strong>(<strong>OOB</strong>), and this is often not captured or decoded correctly during forensic acquisition, which makes analysis difficult. We will discuss this further in <a href="https://cdp.packtpub.com/practical_mobile_forensics__fourth_edition/wp-admin/post.php?post=60&amp;action=edit#post_470">Chapter 9</a>, <em>Android Data Extraction Techniques</em>. YAFFS2 was the most popular release at one point and is still widely used in Android devices. YAFFS2 is a log-structured filesystem. Data integrity is guaranteed, even in the case of a sudden power outage. In 2010, there was an announcement stating that in releases after Gingerbread, devices were going to move from YAFFS2 to <strong>fourth extended file system</strong> (<strong>EXT4</strong>). Currently, YAFFS2 is not supported by newer kernel versions, but certain mobile manufacturers might still continue to support it.</li>
<li><strong>Robust File System </strong>(<strong>RFS</strong>) supports NAND flash memory on Samsung devices. RFS can be summarized as a <strong>File Allocation Table 16</strong> (<strong>FAT16</strong>) or FAT32 filesystem, whereby journaling is enabled through a transaction log. Many users complain that Samsung should stick with EXT4. RFS has been known to have lag times that slow down the features of Android.</li>
</ul>
<p>Next in line is media-based filesystems.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Media-based filesystems</h1>
                </header>
            
            <article>
                
<p>The following are some of the media-based filesystems supported by Android devices.</p>
<p>The <strong>Extended File System</strong> (<strong>EXT</strong>), which was introduced in 1992 specifically for the Linux kernel, was one of the first filesystems, and it used a virtual filesystem. EXT2, EXT3, and EXT4 are the subsequent versions. Journaling is the main advantage of EXT3 over EXT2. With EXT3, if there is an unexpected shutdown, there is no need to verify the filesystem. The EXT4 filesystem has gained significance with mobile devices implementing dual-core processors. The YAFFS2 filesystem is known to have a bottleneck on dual-core systems. With the Gingerbread version of Android, the YAFFS filesystem was swapped for EXT4.</p>
<p>The following are the mount points that use EXT4 on the Samsung Galaxy mobile:</p>
<pre><strong>/dev/block/mmcblk0p9 /system ext4 ro,noatime,barrier=1,data=ordered 0    0</strong>
<strong>/dev/block/mmcblk0p3 /efs ext4 rw,nosuid,nodev,noatime,barrier=1,journal_async_commit,data=ordered 0 0</strong>
<strong>/dev/block/mmcblk0p8 /cache ext4 rw,nosuid,nodev,noatime,barrier=1,journal_async_commit,data=ordered 0 0</strong>
<strong>/dev/block/mmcblk0p12 /data ext4 rw,nosuid,nodev,noatime,barrier=1,journal_async_commit,data=ordered,n oauto_da_alloc,discard 0 0</strong>  </pre>
<p><strong>Virtual File Allocation Table</strong> (<strong>VFAT</strong>) is an extension to the FAT16 and FAT32 filesystems. Microsoft's FAT32 filesystem is supported by most Android devices. It is supported by almost all the major operating systems, including Windows, Linux, and macOS. This enables these systems to easily read, modify, and delete the files present on the FAT32 portion of the Android device. Most of the external SD cards are formatted using the FAT32 filesystem.</p>
<p>Observe the following output, which shows that the <kbd>/sdcard</kbd> and <kbd>/secure/asec</kbd> mount points use the VFAT filesystem:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/3d4cba12-e8f5-458a-af33-cce3f715f589.png"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">mount command output in Android </div>
<p>The final category is pseudo filesystems.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Pseudo filesystems</h1>
                </header>
            
            <article>
                
<p>Pseudo filesystems, as the name suggests, are not actual files but a logical grouping of files. The following are some of the important pseudo filesystems in Android: </p>
<ul>
<li>The root filesystem (<kbd>rootfs</kbd>) is one of the main components of Android and contains all the information required to boot the device. When the device starts the boot process, it needs access to many core files, and thus, it mounts the root filesystem. As shown in the preceding <kbd>mount</kbd> command-line output, this filesystem is mounted at<span> </span><kbd>/</kbd><span> </span>(<kbd>root</kbd><span> </span>folder). Hence, this is the filesystem on which all the other filesystems are slowly mounted. If this filesystem is corrupt, the device cannot be booted.</li>
<li>The<span> </span><kbd>sysfs</kbd><span> </span>filesystem mounts the<span> </span><kbd>/sys</kbd><span> </span>folder, which contains information about the configuration of the device. The following output shows various folders under the<span> </span><kbd>sys</kbd><span> </span>directory in an Android device:</li>
</ul>
<p class="CDPAlignCenter CDPAlign"><img src="assets/5539a170-e9b9-432a-b089-f9a0aaf70de5.png"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Folders under /sys directory in Android</div>
<p>Since the data present in these folders is mostly related to configuration, this is not usually of much significance to a forensic investigator. But there can be some circumstances where we might want to check whether a particular setting was enabled on the phone, and analyzing this folder could be useful under such conditions.</p>
<div class="packt_infobox">Note that each folder consists of a large number of files. Capturing this data through forensic acquisition is the best method to ensure that this data is not changed during an examination.</div>
<ul>
<li>The<span> </span><kbd>devpts</kbd><span> </span>filesystem presents an interface to the Terminal session on an Android device. It is mounted at<span> </span><kbd>/dev/pts</kbd>. Whenever a Terminal connection is established—for instance, when an<span> </span><kbd>adb</kbd><span> </span>shell is connected to an Android device—a new node is created under<span> </span><kbd>/dev/pts</kbd>. The following is the output showing this when the<span> </span><kbd>adb</kbd><span> </span>shell is connected to the device:</li>
</ul>
<pre style="padding-left: 60px"><strong>shell@Android:/ $ ls -l /dev/pts ls -l /dev/pts</strong>
<strong>crw------- shell shell 136, 0 2013-10-26 16:56 0</strong></pre>
<ul>
<li>The<span> </span><kbd>cgroup</kbd><span> </span>filesystem stands for <strong>control groups</strong>. Android devices use this filesystem to track their job. They are responsible for aggregating the tasks and keeping track of them. This data is generally not very useful during forensic analysis.</li>
<li>The<span> </span><kbd>proc</kbd><span> </span>filesystem contains information about kernel data structures, processes, and other system-related information in the<span> </span><kbd>/proc</kbd><span> </span>directory. For instance, the<span> </span><kbd>/sys</kbd><span> </span>directory contains files related to kernel parameters. Similarly,<span> </span><kbd>/proc/filesystems</kbd><span> </span>displays the list of available filesystems on the device. The following command shows all the information about the <strong>central processing unit</strong> (<strong>CPU</strong>) of the device:</li>
</ul>
<p class="CDPAlignCenter CDPAlign"><img src="assets/f84b90ee-5d42-419a-abf3-b9b5871a95e5.png" style="width:32.50em;height:22.25em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Output of the cpuinfo command on an Android device </div>
<p style="padding-left: 60px">Similarly, there are many other useful files that provide valuable information when you traverse them.</p>
<ul>
<li>The<span> </span><kbd>tmpfs</kbd><span> </span>filesystem is a temporary storage facility on the device that stores the files in RAM (volatile memory). The main advantage of using RAM is faster access and retrieval. But once the device is restarted or switched off, this data will not be accessible anymore. Hence, it's important for a forensic investigator to examine the data in RAM before a device reboot happens, or to extract the data via RAM acquisition methods.</li>
</ul>
<p>Today's forensic tools can easily mount these filesystems and display the contents in a <strong>graphical user interface</strong> (<strong>GUI</strong>) screen, thereby enabling forensic investigators to easily navigate and parse through the files. In the initial days of Android forensics, an investigator had to typically run a set of Linux or Windows commands to format and view these filesystems.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we covered the Android operating system's underlying features, filesystems, and other details that are useful in a forensic investigation. We learned about interesting security capabilities that are built into Android. Unlike iOS, several variants of Android exist as many devices run the Android operating system, and each may have different filesystems and unique features. The fact that Android is open and customizable also changes the playing field of digital forensics. This knowledge will be helpful to understand forensic acquisition techniques. </p>
<p>In the next chapter, we will discuss how to set up a forensic workstation before performing the analysis. </p>


            </article>

            
        </section>
    </body></html>