<html><head></head><body><div class="chapter" title="Chapter&#xA0;1.&#xA0;Setting Up the Lab and Introduction to Python ctypes"><div class="titlepage"><div><div><h1 class="title"><a id="ch01"/>Chapter 1. Setting Up the Lab and Introduction to Python ctypes</h1></div></div></div><p>
<span class="strong"><strong>Cyber Security</strong></span> and <span class="strong"><strong>Digital Forensics</strong></span> are two topics of increasing importance. Digital forensics <a id="id0" class="indexterm"/>especially, is getting more and more important, not only during law <a id="id1" class="indexterm"/>enforcement investigations, but also in the field of incident response. During all of the previously mentioned investigations, it's fundamental to get to know the root cause of a security breach, malfunction of a system, or a crime. Digital forensics plays a major role in overcoming these challenges.</p><p>In this book, we will teach you how to build your own lab and perform profound digital forensic investigations, which originate from a large range of platforms and systems, with the help of Python. We will start with common Windows and Linux desktop machines, then move forward to cloud and virtualization platforms, and end up with mobile phones. We will not only show you how to examine the data at rest or in transit, but also take a deeper look at the volatile memory.</p><p>Python provides an excellent development platform to build your own investigative tools because of its decreased complexity, increased efficiency, large number of third-party libraries, and it's also easy to read and write. During the journey of reading this book, you will not only learn how to use the most common Python libraries and extensions to analyze the evidence, but also how to write your own scripts and helper tools to work faster on the cases or incidents with a huge amount of evidence that has to be analyzed.</p><p>Let's begin our journey of mastering Python forensics by setting up our lab environment, followed by a brief introduction of the Python ctypes.</p><p>If you have already worked <a id="id2" class="indexterm"/>with Python <span class="strong"><strong>ctypes</strong></span> and have a working lab environment, feel free to skip the first chapter and start directly with one of the other chapters. After the first chapter, the other chapters are fairly independent of each other and can be read in any order.</p><div class="section" title="Setting up the Lab"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec08"/>Setting up the Lab</h1></div></div></div><p>As a base for our scripts and investigations, we need a comprehensive and powerful lab environment that<a id="id3" class="indexterm"/> is able to handle a large number of different file types and structures as well as connections to mobile devices. To achieve this goal, we will use the latest Ubuntu LTS version 14.04.2 and install it in a virtual machine (VM). Within the following sections, we will explain the setup of the VM and introduce<a id="id4" class="indexterm"/> Python <span class="strong"><strong>virtualenv</strong></span>, which we will use to establish our working environment.</p><div class="section" title="Ubuntu"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec07"/>Ubuntu</h2></div></div></div><p>To work in a <a id="id5" class="indexterm"/>similar lab environment, we suggest you to download a <a id="id6" class="indexterm"/>copy of the latest Ubuntu LTS Desktop Distribution from <a class="ulink" href="http://www.ubuntu.com/download/desktop/">http://www.ubuntu.com/download/desktop/</a>, preferably the 32-bit version. The<a id="id7" class="indexterm"/> distribution provides a simple-to-use UI and already has the Python 2.7.6 environment installed and preconfigured. Throughout the book, we will use Python 2.7.x and not the newer 3.x versions. Several examples and case studies in this book will rely on the tools or libraries that are already a part of the Ubuntu distribution. When a chapter or section of the book requires a third-party package or library, we will provide the additional information on how to install it in the <span class="strong"><strong>virtualenv</strong></span> (the setup of this environment will be explained in the next section) or on Ubuntu in general.</p><p>For better performance of the system, we recommend that the virtual machine that is used for the lab has at least 4 GB of volatile memory and about 40 GB of storage.</p><div class="mediaobject"><img src="graphics/2087_01_01.jpg" alt="Ubuntu"/><div class="caption"><p>Figure 1: The Atom editor</p></div></div><p>To write your first Python script, you can use a simple editor such as <span class="strong"><strong>vi</strong></span> or a powerful but cluttered IDE <a id="id8" class="indexterm"/>such as <span class="strong"><strong>eclipse</strong></span>. As a really powerful alternative, we<a id="id9" class="indexterm"/> would <a id="id10" class="indexterm"/>suggest you to use <span class="strong"><strong>atom</strong></span>, a very <a id="id11" class="indexterm"/>clean but highly customizable editor that can be freely downloaded<a id="id12" class="indexterm"/> from <a class="ulink" href="https://atom.io/">https://atom.io/</a>.</p></div><div class="section" title="Python virtual environment (virtualenv)"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec08"/>Python virtual environment (virtualenv)</h2></div></div></div><p>According to the<a id="id13" class="indexterm"/> official Python documentation, Virtual Environment is a <a id="id14" class="indexterm"/>tool to keep the dependencies required by different projects in separate places by creating virtual Python environments for them. It solves the "Project X depends on version 1.x, but Project Y needs 4.x" dilemma and keeps your global site-packages directory<a id="id15" class="indexterm"/> clean and manageable.</p><p>This is also what we will use in the following chapters to keep a common environment for all the readers of the book and not run into any compatibility issues. First of all, we have to install<a id="id16" class="indexterm"/> the <span class="strong"><strong>virtualenv</strong></span> package. This is done by the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user@lab:~$ pip install virtualenv</strong></span>
</pre></div><p>We will now create a folder in the users' home directory for our virtual Python environment. This directory will contain the executable Python files and a copy of the pip library, which can be used to install other packages in the environment. The name of the virtual environment (in our case, it is called <span class="strong"><strong>labenv</strong></span>) can be of your choice. Our virtual lab environment can<a id="id17" class="indexterm"/> be created by executing the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user@lab:~$ virtualenv labenv</strong></span>
<span class="strong"><strong>New python executable in labenv/bin/python</strong></span>
<span class="strong"><strong>Installing setuptools, pip...done.</strong></span>
</pre></div><p>To start working with the new lab environment, it first needs to be activated. This can be done through:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user@lab:~$ source labenv/bin/activate</strong></span>
<span class="strong"><strong>(labenv)user@lab:~$</strong></span>
</pre></div><p>Now, you can see that the command prompt starts with the name of the virtual environment that we activated. From now on, any package that you install using pip will be placed in the <span class="strong"><strong>labenv</strong></span> folder, isolated from the global Python installation in the underlying Ubuntu.</p><p>Throughout the book, we will use this virtual python environment and install new packages and libraries in it from time to time. So, every time you try to recap a shown example remember or challenge to change into the <span class="strong"><strong>labenv</strong></span> environment before running your scripts.</p><p>If you are done working in the virtual environment for the moment and you want to return to your "normal" Python environment, you can deactivate the virtual environment by executing the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>(labenv)user@lab:~$ deactivate</strong></span>
<span class="strong"><strong>user@lab:~$</strong></span>
</pre></div><p>This puts you back in the system's default Python interpreter with all its installed libraries and dependencies.</p><p>If you are using<a id="id18" class="indexterm"/> more than one virtual or physical machine for the <a id="id19" class="indexterm"/>investigations, the virtual environments can help you to keep your libraries and packages synced with all these workplaces. In order to ensure that your environments are consistent, it's a good idea to "freeze" the current state of environment packages. To do this, just run:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>(labenv)user@lab:~$ pip freeze &gt; requirenments.txt</strong></span>
</pre></div><p>This will create a <code class="literal">requirements.txt</code> file, which contains a simple list of all the packages in the current environment and their respective versions. If you want to now install the same packages using the same version on a different machine, just copy the <code class="literal">requirements.txt</code> file to the desired machine, create the <span class="strong"><strong>labenv</strong></span> environment as described earlier and execute the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>(labenv)user@lab:~$ pip install -r requirements.txt</strong></span>
</pre></div><p>Now, you will have consistent Python environments on all the machines and don't need to worry about different library versions or other dependencies.</p><p>After we have created the Ubuntu virtual machine with our dedicated lab environment, we are nearly ready to start our first forensic analysis. But before that, we need more knowledge of the helpful Python libraries and backgrounds. Therefore, we will start with an introduction to the Python <span class="strong"><strong>ctypes</strong></span> in the following section.</p></div></div></div>
<div class="section" title="Introduction to Python ctypes"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec09"/>Introduction to Python ctypes</h1></div></div></div><p>According to the <a id="id20" class="indexterm"/>official Python documentation, <span class="strong"><strong>ctypes</strong></span> is a foreign function library that provides C compatible data types and allows calling functions in DLLs or shared libraries. A foreign function library means that the Python code can call C functions using only Python, without requiring special or custom-made extensions.</p><p>This module is one of the most powerful libraries available to the Python developer. The <span class="strong"><strong>ctypes</strong></span> library enables you to not only call functions in dynamically linked libraries (as described earlier), but can also be used for low-level memory manipulation. It is important that you understand the basics of how to use the <span class="strong"><strong>ctypes</strong></span> library as it will be used for many examples and real-world cases throughout the book.</p><p>In the following <a id="id21" class="indexterm"/>sections, we will introduce some basic features of Python <span class="strong"><strong>ctypes</strong></span> and how to use them.</p><div class="section" title="Working with Dynamic Link Libraries"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec09"/>Working with Dynamic Link Libraries</h2></div></div></div><p>Python <span class="strong"><strong>ctypes</strong></span> export the <code class="literal">cdll</code> and on Windows <code class="literal">windll</code> or respectively <code class="literal">oledll</code> objects, to load the<a id="id22" class="indexterm"/> requested dynamic link libraries. A<a id="id23" class="indexterm"/> dynamically linked library is a compiled binary that is linked at runtime to the executable main process. On Windows platforms, these binaries are called <span class="strong"><strong>Dynamic Link Libraries</strong></span> (<span class="strong"><strong>DLL</strong></span>) and on Linux, they are called <span class="strong"><strong>shared objects</strong></span> (<span class="strong"><strong>SO</strong></span>). You can load these linked libraries by accessing them as <a id="id24" class="indexterm"/>the attributes of the <code class="literal">cdll</code>, <code class="literal">windll</code> or <code class="literal">oledll</code> objects. Now, we will demonstrate a very brief example for Windows and Linux to get the current time directly out of the <code class="literal">time</code> function in <code class="literal">libc</code> (this library defines the system calls and other basic facilities such as <code class="literal">open</code>, <code class="literal">printf</code>, or <code class="literal">exit</code>).</p><p>Note that in the case of Windows, <code class="literal">msvcrt</code> is the MS standard C library containing most of the standard C functions and uses the <code class="literal">cdecl</code> calling convention (on Linux systems, the similar library would be <code class="literal">libc.so.6</code>):</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>C:\Users\Admin&gt;python</strong></span>

<span class="strong"><strong>&gt;&gt;&gt; from ctypes import *</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; libc = cdll.msvcrt</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; print libc.time(None)</strong></span>
<span class="strong"><strong>1428180920</strong></span>
</pre></div><p>Windows appends the usual <code class="literal">.dll</code> file suffix automatically. On Linux, it is required to specify the filename, including the extension, to load the chosen library. Either the <code class="literal">LoadLibrary()</code> method of the DLL loaders should be used or you should load the library by creating an instance of <code class="literal">CDLL</code> by calling the constructor, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>(labenv)user@lab:~$ python</strong></span>

<span class="strong"><strong>&gt;&gt;&gt; from ctypes import *</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; libc = CDLL("libc.so.6")</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; print libc.time(None)</strong></span>
<span class="strong"><strong>1428180920</strong></span>
</pre></div><p>As shown in these two examples, it is very easy to be able to call to a dynamic library and use a function that is exported. You will be using this technique many times throughout the book, so it is important that you understand how it works.</p></div><div class="section" title="C data types"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec10"/>C data types</h2></div></div></div><p>When looking<a id="id25" class="indexterm"/> at the two examples from the earlier section in detail, you can <a id="id26" class="indexterm"/>see that we use <code class="literal">None</code> as one of the parameters for a dynamically linked C library. This is possible because <code class="literal">None</code>, <code class="literal">integers</code>, <code class="literal">longs</code>, <code class="literal">byte strings</code>, and <code class="literal">unicode strings</code> are the native Python objects that can be directly used as the parameters in these function calls. <code class="literal">None</code> is passed as a C, <code class="literal">NULL pointer</code>, <code class="literal">byte strings</code>, and <code class="literal">unicode strings</code> are passed as pointers to the memory block that contains their data (<code class="literal">char *</code> or <code class="literal">wchar_t *</code>). Python <code class="literal">integers</code> and Python <code class="literal">longs</code> are passed as the platform's default C <code class="literal">int type</code>, their value is masked to fit into the C type. A complete overview of the Python types and their corresponding ctype types can be seen in <span class="emphasis"><em>Table 1</em></span>:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>ctypes type</p>
</th><th style="text-align: left" valign="bottom">
<p>C type</p>
</th><th style="text-align: left" valign="bottom">
<p>Python type</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>c_bool (<a class="ulink" href="https://docs.python.org/2/library/ctypes.html#ctypes.c_bool">https://docs.python.org/2/library/ctypes.html#ctypes.c_bool</a>)</p>
</td><td style="text-align: left" valign="top">
<p>_Bool</p>
</td><td style="text-align: left" valign="top">
<p>bool (1)</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>c_char (<a class="ulink" href="https://docs.python.org/2/library/ctypes.html#ctypes.c_char">https://docs.python.org/2/library/ctypes.html#ctypes.c_char</a>)</p>
</td><td style="text-align: left" valign="top">
<p>char</p>
</td><td style="text-align: left" valign="top">
<p>1-character string</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>c_wchar (<a class="ulink" href="https://docs.python.org/2/library/ctypes.html#ctypes.c_wchar">https://docs.python.org/2/library/ctypes.html#ctypes.c_wchar</a>)</p>
</td><td style="text-align: left" valign="top">
<p>wchar_t</p>
</td><td style="text-align: left" valign="top">
<p>1-character unicode string</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>c_byte (<a class="ulink" href="https://docs.python.org/2/library/ctypes.html#ctypes.c_byte">https://docs.python.org/2/library/ctypes.html#ctypes.c_byte</a>)</p>
</td><td style="text-align: left" valign="top">
<p>char</p>
</td><td style="text-align: left" valign="top">
<p>int/long</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>c_ubyte (<a class="ulink" href="https://docs.python.org/2/library/ctypes.html#ctypes.c_ubyte">https://docs.python.org/2/library/ctypes.html#ctypes.c_ubyte</a>)</p>
</td><td style="text-align: left" valign="top">
<p>unsigned char</p>
</td><td style="text-align: left" valign="top">
<p>int/long</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>c_short (<a class="ulink" href="https://docs.python.org/2/library/ctypes.html#ctypes.c_short">https://docs.python.org/2/library/ctypes.html#ctypes.c_short</a>)</p>
</td><td style="text-align: left" valign="top">
<p>short</p>
</td><td style="text-align: left" valign="top">
<p>int/long</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>c_ushort (<a class="ulink" href="https://docs.python.org/2/library/ctypes.html#ctypes.c_ushort">https://docs.python.org/2/library/ctypes.html#ctypes.c_ushort</a>)</p>
</td><td style="text-align: left" valign="top">
<p>unsigned short</p>
</td><td style="text-align: left" valign="top">
<p>int/long</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>c_int (<a class="ulink" href="https://docs.python.org/2/library/ctypes.html#ctypes.c_int">https://docs.python.org/2/library/ctypes.html#ctypes.c_int</a>)</p>
</td><td style="text-align: left" valign="top">
<p>int</p>
</td><td style="text-align: left" valign="top">
<p>int/long</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>c_uint (<a class="ulink" href="https://docs.python.org/2/library/ctypes.html#ctypes.c_uint">https://docs.python.org/2/library/ctypes.html#ctypes.c_uint</a>)</p>
</td><td style="text-align: left" valign="top">
<p>unsigned int</p>
</td><td style="text-align: left" valign="top">
<p>int/long</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>c_long (<a class="ulink" href="https://docs.python.org/2/library/ctypes.html#ctypes.c_long">https://docs.python.org/2/library/ctypes.html#ctypes.c_long</a>)</p>
</td><td style="text-align: left" valign="top">
<p>long</p>
</td><td style="text-align: left" valign="top">
<p>int/long</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>c_ulong (<a class="ulink" href="https://docs.python.org/2/library/ctypes.html#ctypes.c_ulong">https://docs.python.org/2/library/ctypes.html#ctypes.c_ulong</a>)</p>
</td><td style="text-align: left" valign="top">
<p>unsigned long</p>
</td><td style="text-align: left" valign="top">
<p>int/long</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>c_longlong (<a class="ulink" href="https://docs.python.org/2/library/ctypes.html#ctypes.c_longlong">https://docs.python.org/2/library/ctypes.html#ctypes.c_longlong</a>)</p>
</td><td style="text-align: left" valign="top">
<p>__int64 or long long</p>
</td><td style="text-align: left" valign="top">
<p>int/long</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>c_ulonglong (<a class="ulink" href="https://docs.python.org/2/library/ctypes.html#ctypes.c_ulonglong">https://docs.python.org/2/library/ctypes.html#ctypes.c_ulonglong</a>)</p>
</td><td style="text-align: left" valign="top">
<p>unsigned __int64 or unsigned long long</p>
</td><td style="text-align: left" valign="top">
<p>int/long</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>c_float (<a class="ulink" href="https://docs.python.org/2/library/ctypes.html#ctypes.c_float">https://docs.python.org/2/library/ctypes.html#ctypes.c_float</a>)</p>
</td><td style="text-align: left" valign="top">
<p>float</p>
</td><td style="text-align: left" valign="top">
<p>float</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>c_double (<a class="ulink" href="https://docs.python.org/2/library/ctypes.html#ctypes.c_double">https://docs.python.org/2/library/ctypes.html#ctypes.c_double</a>)</p>
</td><td style="text-align: left" valign="top">
<p>double</p>
</td><td style="text-align: left" valign="top">
<p>float</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>c_longdouble (<a class="ulink" href="https://docs.python.org/2/library/ctypes.html#ctypes.c_longdouble">https://docs.python.org/2/library/ctypes.html#ctypes.c_longdouble</a>)</p>
</td><td style="text-align: left" valign="top">
<p>long double</p>
</td><td style="text-align: left" valign="top">
<p>float</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>c_char_p (<a class="ulink" href="https://docs.python.org/2/library/ctypes.html#ctypes.c_char_p">https://docs.python.org/2/library/ctypes.html#ctypes.c_char_p</a>)</p>
</td><td style="text-align: left" valign="top">
<p>char * (NUL terminated)</p>
</td><td style="text-align: left" valign="top">
<p>string or None</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>c_wchar_p (<a class="ulink" href="https://docs.python.org/2/library/ctypes.html#ctypes.c_wchar_p">https://docs.python.org/2/library/ctypes.html#ctypes.c_wchar_p</a>)</p>
</td><td style="text-align: left" valign="top">
<p>wchar_t * (NUL terminated)</p>
</td><td style="text-align: left" valign="top">
<p>unicode or None</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>c_void_p (<a class="ulink" href="https://docs.python.org/2/library/ctypes.html#ctypes.c_void_p">https://docs.python.org/2/library/ctypes.html#ctypes.c_void_p</a>)</p>
</td><td style="text-align: left" valign="top">
<p>void *</p>
</td><td style="text-align: left" valign="top">
<p>int/long or None</p>
</td></tr></tbody></table></div><div class="blockquote"><blockquote class="blockquote"><p>Table 1: Fundamental Data Types</p></blockquote></div><p>This table is<a id="id27" class="indexterm"/> very helpful because all the Python types except <code class="literal">integers</code>, <code class="literal">strings</code>, and <code class="literal">unicode strings</code> have to be wrapped in their corresponding ctypes type so that they <a id="id28" class="indexterm"/>can be converted to the required C data type in the linked library and not throw the <code class="literal">TypeError</code> exceptions, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>(labenv)user@lab:~$ python</strong></span>

<span class="strong"><strong>&gt;&gt;&gt; from ctypes import *</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; libc = CDLL("libc.so.6")</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; printf = libc.printf</strong></span>

<span class="strong"><strong>&gt;&gt;&gt; printf("An int %d, a double %f\n", 4711, 47.11)</strong></span>
<span class="strong"><strong>Traceback (most recent call last):</strong></span>
<span class="strong"><strong>  File "&lt;stdin&gt;", line 1, in &lt;module&gt;</strong></span>
<span class="strong"><strong>ctypes.ArgumentError: argument 3: &lt;type 'exceptions.TypeError'&gt;: Don't know how to convert parameter 3</strong></span>

<span class="strong"><strong>&gt;&gt;&gt; printf("An int %d, a double %f\n", 4711, c_double(47.11))</strong></span>
<span class="strong"><strong>An int 4711, a double 47.110000</strong></span>
</pre></div><div class="section" title="Defining Unions and Structures"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec11"/>Defining Unions and Structures</h3></div></div></div><p>
<span class="strong"><strong>Unions</strong></span> and <span class="strong"><strong>Structures</strong></span> are important data types because they are frequently used throughout the <code class="literal">libc</code> on Linux and also in the Microsoft Win32 API.</p><p>Unions are<a id="id29" class="indexterm"/> simply a group of variables, which can be of the same or <a id="id30" class="indexterm"/>different data types, where all of its members share the <a id="id31" class="indexterm"/>same memory location. By storing variables in this way, unions<a id="id32" class="indexterm"/> allow you to specify the same value in different types. For the upcoming example, we will change from the interactive Python shell to the atom editor on our Ubuntu lab environment. You just need to open atom editor, type in the following code, and save it under the name <code class="literal">new_evidence.py</code>:</p><div class="informalexample"><pre class="programlisting">from ctypes import *

class case(Union):
        _fields_ = [
        ("evidence_int", c_int),
        ("evidence_long", c_long),
        ("evidence_char", c_char * 4)
        ]

value = raw_input("Enter new evidence number:")
new_evidence = case(int(value))
print "Evidence number as a int: %i" % new_evidence.evidence_int
print "Evidence number as a long: %ld" % new_evidence.evidence_long
print "Evidence number as a char: %s" % new_evidence.evidence_char</pre></div><p>If you assign the <code class="literal">evidence</code> union's member variable <code class="literal">evidence_int</code> a value of <code class="literal">42</code>, you can then use the <code class="literal">evidence_char</code> member to display the character representation of that number, as shown in the following example:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>(labenv)user@lab:~$ python new_evidence.py</strong></span>

<span class="strong"><strong>Enter new evidence number:42</strong></span>

<span class="strong"><strong>Evidence number as a long: 42</strong></span>
<span class="strong"><strong>Evidence number as a int: 42</strong></span>
<span class="strong"><strong>Evidence number as a char: *</strong></span>
</pre></div><p>As you can see in the preceding example, by assigning the union a single value, you get three different representations of that value. For <code class="literal">int</code> and <code class="literal">long</code>, the displayed output is obvious but for the <code class="literal">evidence_char</code> variable, it could be a bit confusing. In this case, <code class="literal">'*'</code> is the ASCII character with the value of the equivalent of decimal <code class="literal">42</code>. The <code class="literal">evidence_char</code> member variable is a good example of how to define an <code class="literal">array</code> in ctypes. In ctypes, an array is defined by multiplying a type by the number of elements that you want to allocate in the array. In this example, a four-element character array was defined for the member variable <code class="literal">evidence_char</code>.</p><p>A structure is <a id="id33" class="indexterm"/>very similar to unions, but the members do not share the <a id="id34" class="indexterm"/>same memory location. You can access any of the <a id="id35" class="indexterm"/>member variables in the structure using dot notation, such<a id="id36" class="indexterm"/> as <code class="literal">case.name</code>. This would access the <code class="literal">name</code> variable contained in the <code class="literal">case</code> structure. The following is a very brief example of how to create a <code class="literal">structure</code> (or <span class="strong"><strong>struct,</strong></span> as they are often called) with three members: <code class="literal">name</code>, <code class="literal">number</code>, and <code class="literal">investigator_name</code> so that all can be accessed by the dot notation:</p><div class="informalexample"><pre class="programlisting">from ctypes import *

class case(Structure):
        _fields_ = [
        ("name", c_char * 16),
        ("number", c_int),
        ("investigator_name", c_char * 8)
        ]</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip02"/>Tip</h3><p>
<span class="strong"><strong>Downloading the example code</strong></span>
</p><p>You can download the example code files from your account at <a class="ulink" href="http://www.packtpub.com">http://www.packtpub.com</a> for all the Packt Publishing books you have purchased. If you purchased this book elsewhere, you can visit <a class="ulink" href="http://www.packtpub.com/support">http://www.packtpub.com/support</a> and register to have the files e-mailed directly to you.</p></div></div></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec10"/>Summary</h1></div></div></div><p>In the first chapter, we created our lab environment: a virtual machine running <span class="strong"><strong>Ubuntu 14.04.2 LTS</strong></span>. This step is really important as you can now create snapshots before working on real evidence and are able to roll back to a clean machine state after finishing the investigation. This can be helpful, especially, when working with compromised system backups, where you want to be sure that your system is clean when working on a different case afterwards.</p><p>In the second part of this chapter, we demonstrated how to work with Python's <span class="strong"><strong>virtual environments (virtualenv)</strong></span> that will be used and extended throughout the book.</p><p>In the last section of this chapter, we introduced the Python <span class="strong"><strong>ctypes</strong></span> to you, which is a very powerful library available to the Python developer. With those <span class="strong"><strong>ctypes</strong></span>, you are not only able to call functions in the dynamically linked libraries (available Microsoft Win32 APIs or common Linux shared objects), but they can also be used for low-level memory manipulation.</p><p>After completing this chapter, you will have a basic environment created to be used for the rest of the book, and you will also understand the fundamentals of Python <span class="strong"><strong>ctypes</strong></span> that will be helpful in some of the following chapters.</p></div></body></html>