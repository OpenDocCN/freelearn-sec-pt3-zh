<html><head></head><body>
		<div><h1 id="_idParaDest-116" class="chapter-number"><a id="_idTextAnchor255" class="pcalibre pcalibre1 calibre6"/>6</h1>
			<h1 id="_idParaDest-117" class="calibre5"><a id="_idTextAnchor256" class="pcalibre pcalibre1 calibre6"/>Building Automated Security Pipelines with Python Using Third-Party Tools</h1>
			<p class="calibre3">In the previous chapter, we talked about cloud security, data extraction, and exploitation. This part is all about making it easier. This chapter looks into how Python’s different libraries and tools can be used to create efficient automated security pipelines. By incorporating third-party tools, we may improve the functionality and scope of these pipelines, assuring comprehensive protection and efficient security operations. We’ll discuss being proactive, which includes anticipating future problems. In doing so, we’ll use Python, and we’ll combine it with additional tools to automate jobs.</p>
			<p class="calibre3"><a id="_idTextAnchor257" class="pcalibre pcalibre1 calibre6"/>In this chapter, we’re going to cover the following main topics:</p>
			<ul class="calibre17">
				<li class="calibre16"><a id="_idTextAnchor258" class="pcalibre pcalibre1 calibre6"/><a id="_idTextAnchor259" class="pcalibre pcalibre1 calibre6"/>The art of security automation – fundamentals and benefits</li>
				<li class="calibre16">What is an application programming interface (API)?</li>
				<li class="calibre16">Designing end-to-end security pipelines with Python</li>
				<li class="calibre16">Integrating third-party tools for enhanced functionality</li>
				<li class="calibre16">Ensuring reliability and resilience in automated workflows</li>
				<li class="calibre16">Monitoring and continuously improving security pipelines</li>
			</ul>
			<h1 id="_idParaDest-118" class="calibre5"><a id="_idTextAnchor260" class="pcalibre pcalibre1 calibre6"/>The art of <a id="_idIndexMarker508" class="pcalibre pcalibre1 calibre6"/>security automation – f<a id="_idTextAnchor261" class="pcalibre pcalibre1 calibre6"/>undamentals and benefits</h1>
			<p class="calibre3"><strong class="bold">Cybersecurity automation</strong> is a method of automating<a id="_idIndexMarker509" class="pcalibre pcalibre1 calibre6"/><a id="_idIndexMarker510" class="pcalibre pcalibre1 calibre6"/> security tasks to reduce the time and effort required to respond to threats. This approach leverages advanced technologies to detect, prevent, contain, and recover from cyber threats with greater efficiency and precision. By automating repetitive and time-consuming security tasks, organizations can focus on more strategic initiatives and respond to incidents in real time. Automation in cybersecurity <a id="_idIndexMarker511" class="pcalibre pcalibre1 calibre6"/><a id="_idIndexMarker512" class="pcalibre pcalibre1 calibre6"/>not only improves the speed and accuracy of threat detection and response but also helps in managing the growing complexity and volume of security threats.</p>
			<h2 id="_idParaDest-119" class="calibre7"><a id="_idTextAnchor262" class="pcalibre pcalibre1 calibre6"/>The benefits of cybersecurity automation</h2>
			<p class="calibre3">Automating cybersecurity processes offers <a id="_idIndexMarker513" class="pcalibre pcalibre1 calibre6"/>numerous advantages, especially in busy environments with high workloads. Here are the key benefits:</p>
			<ul class="calibre17">
				<li class="calibre16"><strong class="bold">Enhanced efficiency</strong>: Automation streamlines tasks in cybersecurity departments, reducing the need for manual intervention. This efficiency boost allows professionals to allocate time to more critical areas, minimizing the workload and associated costs.</li>
				<li class="calibre16"><strong class="bold">Proactive cyber threat defense</strong>: Automated systems can detect and thwart potential cyberattacks in real time, preventing escalation. Continuous network monitoring provides a robust defense against unauthorized access and safeguards sensitive data.</li>
				<li class="calibre16"><strong class="bold">Error reduction</strong>: Human error is a common risk in cybersecurity. Automation eliminates the potential for mistakes such as forgetting password updates or neglecting software upgrades, enhancing overall system reliability.</li>
				<li class="calibre16"><strong class="bold">Threat intelligence and analysis</strong>: Automated cybersecurity systems provide rapid identification of emerging threats. By storing detailed activity logs, these systems offer valuable insights into attack patterns, enabling proactive measures to fortify data security.</li>
			</ul>
			<p class="calibre3">In summary, cybersecurity automation not only improves operational efficiency but also fortifies defenses, reduces errors, and empowers businesses with actionable threat intelligence.</p>
			<h2 id="_idParaDest-120" class="calibre7"><a id="_idTextAnchor263" class="pcalibre pcalibre1 calibre6"/>Functions of cybersecurity automation</h2>
			<p class="calibre3">Cybersecurity automation streamlines various<a id="_idIndexMarker514" class="pcalibre pcalibre1 calibre6"/><a id="_idIndexMarker515" class="pcalibre pcalibre1 calibre6"/> business operations through the following functions:</p>
			<ul class="calibre17">
				<li class="calibre16"><strong class="bold">Detection and prevention</strong>: One of the primary roles of cybersecurity automation is fortifying business defenses against potential threats. It swiftly identifies risks and employs automated solutions to halt further damage. While automation is <a id="_idIndexMarker516" class="pcalibre pcalibre1 calibre6"/><a id="_idIndexMarker517" class="pcalibre pcalibre1 calibre6"/>crucial, a comprehensive strategy may also involve integrating specific tools such as <strong class="bold">Residential Proxies</strong> for enhanced <a id="_idIndexMarker518" class="pcalibre pcalibre1 calibre6"/><a id="_idIndexMarker519" class="pcalibre pcalibre1 calibre6"/>protection in areas such as <strong class="bold">IP Masking</strong>, <strong class="bold">Malware Defense</strong>, <strong class="bold">Email Filtering</strong>, <strong class="bold">Web Application Firewalls</strong> (<strong class="bold">WAFs</strong>), and <strong class="bold">Intrusion Detection </strong><strong class="bold">Systems</strong> (<strong class="bold">IDSs</strong>).</li>
				<li class="calibre16"><strong class="bold">Forensics and incident response</strong>: Automation, particularly <a id="_idIndexMarker520" class="pcalibre pcalibre1 calibre6"/><a id="_idIndexMarker521" class="pcalibre pcalibre1 calibre6"/>powered by AI, plays a crucial role in forensics, gathering evidence to understand system breaches. Incident response involves reacting effectively to such incidents and ensuring a well-prepared plan for network attacks. Automated systems aid in comprehending the extent of breaches and guide teams on the necessary steps during and after an attack.</li>
				<li class="calibre16"><strong class="bold">Remediation</strong>: Automated remediation accelerates problem resolution. In the aftermath of an attack, manual tasks can be time-consuming and error-prone. Automated remediation allows IT teams to swiftly address issues, enabling a faster return to normal operations. It ensures accuracy and efficiency in each step, preventing repeated mistakes through automatic detection and immediate alerts if anything <a id="_idIndexMarker522" class="pcalibre pcalibre1 calibre6"/><a id="_idIndexMarker523" class="pcalibre pcalibre1 calibre6"/>goes awry during tasks such as software patching or updates.</li>
				<li class="calibre16"><strong class="bold">Compliance</strong>: Cybersecurity automation serves as a robust tool for enforcing security policies and procedures, demonstrating a commitment to information security compliance. In regulated industries such as healthcare or finance, automation becomes essential for showcasing due diligence and adherence to best practices. It provides a proactive approach to security, highlighting a dedication to maintaining a secure network and potentially reducing accountability concerns.</li>
			</ul>
			<p class="calibre3">Incorporating cybersecurity automation into your strategy not only enhances overall security but also contributes to operational efficiency and regulatory compliance.</p>
			<h2 id="_idParaDest-121" class="calibre7"><a id="_idTextAnchor264" class="pcalibre pcalibre1 calibre6"/>Cybersecurity automation best practices</h2>
			<p class="calibre3">Implementing cybersecurity automation <a id="_idIndexMarker524" class="pcalibre pcalibre1 calibre6"/><a id="_idIndexMarker525" class="pcalibre pcalibre1 calibre6"/>requires adherence to best practices to effectively scale your security efforts and adapt to the dynamic cyber threat landscape. Here are some key guidelines to keep you on the right track:</p>
			<ul class="calibre17">
				<li class="calibre16"><strong class="bold">Establish a comprehensive </strong><strong class="bold"><a id="_idIndexMarker526" class="pcalibre pcalibre1 calibre6"/></strong><strong class="bold">security automation plan</strong>: Develop a clear plan for integrating automation into your cybersecurity strategy and adhere to it consistently.</li>
				<li class="calibre16"><strong class="bold">Regularly test automated processes</strong>: Conduct routine tests to ensure that automated processes are functioning as intended and are capable of responding effectively to emerging threats.</li>
				<li class="calibre16"><strong class="bold">Evaluate the benefits and drawbacks of automation</strong>: Consider the advantages of automation in enhancing security and also assess potential drawbacks that may arise if automation is not utilized appropriately.</li>
				<li class="calibre16"><strong class="bold">Phased implementation</strong>: Roll out automation gradually, starting with addressing commonly occurring security threats. This phased approach allows for smoother integration and adaptation.</li>
				<li class="calibre16"><strong class="bold">Integration with existing systems</strong>: Integrate automation seamlessly with your existing systems to create a cohesive and efficient cybersecurity infrastructure.</li>
				<li class="calibre16"><strong class="bold">Centralized data storage</strong>: Utilize a centralized database for critical data storage. This facilitates quick identification of issues and enables prompt resolution.</li>
				<li class="calibre16"><strong class="bold">Engage third-party service providers</strong>: Consider outsourcing cybersecurity processes to a reputable third-party service provider. This can relieve your organization of the technical complexities associated with maintaining an effective cyber defense program.</li>
				<li class="calibre16"><strong class="bold">Employee training</strong>: Educate your staff, particularly the security team, on effectively utilizing automated cybersecurity systems. Clearly define the roles of both humans and machines in the cybersecurity framework.</li>
			</ul>
			<p class="calibre3">In conclusion, embrace the power of cybersecurity automation to enhance your organization’s security posture. Detect threats early, prevent attacks, and minimize damage with this powerful tool.</p>
			<p class="calibre3">Before getting straight into <a id="_idIndexMarker527" class="pcalibre pcalibre1 calibre6"/><a id="_idIndexMarker528" class="pcalibre pcalibre1 calibre6"/>automation, you should be familiar with APIs. Understanding APIs is essential because they form the backbone of automated workflows, facilitating data exchange, triggering automated actions, and enhancing the overall efficiency of security operations.</p>
			<h1 id="_idParaDest-122" class="calibre5"><a id="_idTextAnchor265" class="pcalibre pcalibre1 calibre6"/>What is an API?</h1>
			<p class="calibre3">An API is essentially a contract between two software <a id="_idIndexMarker529" class="pcalibre pcalibre1 calibre6"/><a id="_idIndexMarker530" class="pcalibre pcalibre1 calibre6"/>applications. It specifies how software components should interact, what data they can request, and what actions they can perform. APIs enable the integration of different software systems, allowing them to work together seamlessly. APIs let developers use certain features or get data from a service without needing to know how that service works inside.</p>
			<p class="calibre3">APIs have the following <a id="_idIndexMarker531" class="pcalibre pcalibre1 calibre6"/><a id="_idIndexMarker532" class="pcalibre pcalibre1 calibre6"/>components:</p>
			<ul class="calibre17">
				<li class="calibre16"><strong class="bold">Endpoints</strong>: Specific URLs or URIs that an API exposes for different functionalities.</li>
				<li class="calibre16"><strong class="bold">Request methods</strong>: HTTP methods such as <strong class="source-inline1">GET</strong>, <strong class="source-inline1">POST</strong>, <strong class="source-inline1">PUT</strong>, <strong class="source-inline1">DELETE</strong>, and others. These are used to perform different actions on the resources.</li>
				<li class="calibre16"><strong class="bold">Request and response formats</strong>: APIs define how data should be structured when it’s sent to the API (request) and how the API will structure its response.</li>
			</ul>
			<p class="calibre3">Let’s imagine an API for a book catalog, and discuss the aforementioned components for it. In this API, we might have different endpoints representing various functionalities:</p>
			<ul class="calibre17">
				<li class="calibre16"><strong class="source-inline1">/books</strong>: This endpoint could be used to retrieve a list of all the books in the catalog.</li>
				<li class="calibre16"><strong class="source-inline1">/books/{id}</strong>: This endpoint could be used to retrieve details about a specific book, where <strong class="source-inline1">{id}</strong> is the unique identifier of the book.</li>
			</ul>
			<p class="calibre3">So, the API might expose the following URLs:</p>
			<ul class="calibre17">
				<li class="calibre16"><strong class="source-inline1">https://api.example.com/books</strong></li>
				<li class="calibre16"><strong class="source-inline1">https://api.example.com/books/123</strong> (assuming <strong class="source-inline1">123</strong> is the ID of a specific book)</li>
			</ul>
			<p class="calibre3">Now, coming to request methods, HTTP methods such as <code>GET</code>, <code>POST</code>, <code>PUT</code>, and <code>DELETE</code> are used to perform different actions on the resources represented by the endpoints. Let’s look at some examples:</p>
			<ul class="calibre17">
				<li class="calibre16"><strong class="source-inline1">GET /books</strong>: Retrieves a list of all books</li>
				<li class="calibre16"><strong class="source-inline1">GET /books/123</strong>: Retrieves details about the book with ID <strong class="source-inline1">123</strong></li>
				<li class="calibre16"><strong class="source-inline1">POST /books</strong>: Adds a new book to the catalog</li>
				<li class="calibre16"><strong class="source-inline1">PUT /books/123</strong>: Updates the details of the book with ID <strong class="source-inline1">123</strong></li>
				<li class="calibre16"><strong class="source-inline1">DELETE /books/123</strong>: Deletes the book with ID <strong class="source-inline1">123</strong> from the catalog</li>
			</ul>
			<p class="calibre3">As for the request and response formats, APIs define how data should be structured when it’s sent to the API (request) and how the API will structure its response.</p>
			<p class="calibre3">For example, when adding a new book (<code>POST</code> request), the request might be in JSON format, specifying details such as title, author, and genre. The API might expect a request similar to the following:</p>
			<pre class="source-code">
{ "title": "The Great Gatsby", "author": "F. Scott Fitzgerald", "genre": "Fiction" }</pre>			<p class="calibre3">In response to a <code>GET</code> request for a specific book, the API might return information in a structured format, such as JSON:</p>
			<pre class="source-code">
{ "id": 123, "title": "The Great Gatsby", "author": "F. Scott Fitzgerald", "genre": "Fiction" }</pre>			<p class="calibre3">In summary, the combination <a id="_idIndexMarker533" class="pcalibre pcalibre1 calibre6"/>of endpoints, request methods, and request/response formats allows developers to interact with an API in a standardized way. It provides a clear and consistent means of accessing and manipulating data in the book catalog, or any other system for which the API is designed.</p>
			<p class="calibre3">With this fundamental understanding of APIs, we can move on to the next section, where we will cover the design and development of security pipelines.</p>
			<h1 id="_idParaDest-123" class="calibre5"><a id="_idTextAnchor266" class="pcalibre pcalibre1 calibre6"/>Designing end-to-end security pipelines with Python</h1>
			<p class="calibre3">A <strong class="bold">security pipeline</strong> can be envisioned <a id="_idIndexMarker534" class="pcalibre pcalibre1 calibre6"/><a id="_idIndexMarker535" class="pcalibre pcalibre1 calibre6"/>as a strategic assembly line of automated processes and tools that are designed to fortify applications against potential threats and vulnerabilities. It extends beyond the traditional boundaries of development, reaching into deployment<a id="_idIndexMarker536" class="pcalibre pcalibre1 calibre6"/><a id="_idIndexMarker537" class="pcalibre pcalibre1 calibre6"/> and operational phases. The essence lies in integrating security seamlessly into the software<a id="_idIndexMarker538" class="pcalibre pcalibre1 calibre6"/><a id="_idIndexMarker539" class="pcalibre pcalibre1 calibre6"/> development lifecycle, embodying the principles of <strong class="bold">DevSecOps</strong>.</p>
			<p class="calibre3">The significance of a security pipeline in the<a id="_idIndexMarker540" class="pcalibre pcalibre1 calibre6"/><a id="_idIndexMarker541" class="pcalibre pcalibre1 calibre6"/> context of cybersecurity can be outlined as follows:</p>
			<ul class="calibre17">
				<li class="calibre16"><strong class="bold">Early detection of vulnerabilities</strong>: By integrating security checks into the development process, vulnerabilities can be identified early in the lifecycle, reducing the cost and effort required to fix them. This proactive approach is crucial in preventing security issues from reaching production.</li>
				<li class="calibre16"><strong class="bold">Consistent security practices</strong>: Security pipelines enforce consistent security practices across the development, deployment, and operation phases. This consistency helps in maintaining a robust security posture and reduces the risk of overlooking security measures.</li>
				<li class="calibre16"><strong class="bold">Automation of security processes</strong>: Security pipelines automate various security processes, such as code analysis, vulnerability scanning, and compliance checks. Automation not only accelerates the development pipeline but also ensures that security measures are consistently applied without relying solely on manual efforts.</li>
				<li class="calibre16"><strong class="bold">Continuous monitoring and improvement</strong>: A security pipeline facilitates continuous monitoring of applications and systems for security issues. This continuous feedback loop allows teams to adapt to evolving threats, update security controls, and improve the overall security posture over time.</li>
				<li class="calibre16"><strong class="bold">Integration with DevOps practices</strong>: Security pipelines align with DevOps principles by seamlessly integrating security into the <strong class="bold">continuous integration</strong>/<strong class="bold">continuous deployment</strong> (<strong class="bold">CI</strong>/<strong class="bold">CD</strong>) workflows. This integration<a id="_idIndexMarker542" class="pcalibre pcalibre1 calibre6"/><a id="_idIndexMarker543" class="pcalibre pcalibre1 calibre6"/> ensures that security is not <a id="_idIndexMarker544" class="pcalibre pcalibre1 calibre6"/><a id="_idIndexMarker545" class="pcalibre pcalibre1 calibre6"/>a bottleneck but rather an integral part of the rapid and iterative development process.</li>
			</ul>
			<p class="calibre3">An end-to-end security pipeline covers the<a id="_idIndexMarker546" class="pcalibre pcalibre1 calibre6"/><a id="_idIndexMarker547" class="pcalibre pcalibre1 calibre6"/> entire software development lifecycle, from the initial stages of code development to deployment, as well as ongoing operations. It involves the following key stages:</p>
			<ol class="calibre15">
				<li class="calibre16"><strong class="bold">Development phase</strong>: Security checks begin in the development phase, where secure coding practices are enforced. Developers utilize tools <a id="_idIndexMarker548" class="pcalibre pcalibre1 calibre6"/><a id="_idIndexMarker549" class="pcalibre pcalibre1 calibre6"/>for static code analysis, identifying and addressing security vulnerabilities in the early stages of writing code.</li>
				<li class="calibre16"><strong class="bold">Build and integration phase</strong>: During the<a id="_idIndexMarker550" class="pcalibre pcalibre1 calibre6"/><a id="_idIndexMarker551" class="pcalibre pcalibre1 calibre6"/> build and integration phase, the security pipeline performs automated tests, including <strong class="bold">Dynamic Application Security Testing</strong> (<strong class="bold">DAST</strong>), <strong class="bold">Dependency Scanning</strong>, and other security <a id="_idIndexMarker552" class="pcalibre pcalibre1 calibre6"/><a id="_idIndexMarker553" class="pcalibre pcalibre1 calibre6"/>checks. This ensures that the built artifacts are free from vulnerabilities before the deployment stage takes place.</li>
				<li class="calibre16"><strong class="bold">Deployment phase</strong>: Security controls are applied as part of the <a id="_idIndexMarker554" class="pcalibre pcalibre1 calibre6"/><a id="_idIndexMarker555" class="pcalibre pcalibre1 calibre6"/>deployment process, ensuring that the application is configured <a id="_idIndexMarker556" class="pcalibre pcalibre1 calibre6"/><a id="_idIndexMarker557" class="pcalibre pcalibre1 calibre6"/>securely and that no new vulnerabilities are introduced during deployment. Container security checks may also be included if the application is containerized.</li>
				<li class="calibre16"><strong class="bold">Operations and monitoring phase</strong>: Continuous<a id="_idIndexMarker558" class="pcalibre pcalibre1 calibre6"/><a id="_idIndexMarker559" class="pcalibre pcalibre1 calibre6"/> monitoring is a key component of an end-to-end security pipeline. Security measures such as log analysis, intrusion detection, and anomaly detection help with identifying and responding to security incidents promptly.</li>
				<li class="calibre16"><strong class="bold">Feedback loop and iterative improvement</strong>: The security pipeline provides a feedback loop that allows teams to continuously improve security measures. Lessons learned from security incidents or vulnerabilities discovered in production are fed back into the development cycle, fostering a culture of continuous improvement.</li>
			</ol>
			<p class="calibre3">In summary, an end-to-end security pipeline is a comprehensive approach to integrating security into every phase of the software development lifecycle. It ensures that security is not a one-time consideration but a continuous and integral part of the development and operational processes, contributing to a more resilient and secure application or system.</p>
			<p class="calibre3">Even though the use of Python in creating a DevSecOps pipeline is minimal, we can always use Python to write intermediate scripts for various purposes.</p>
			<p class="calibre3">To build upon this foundation, next, we’ll explore how to integrate third-party tools to enhance the functionality and effectiveness of our security pipeline.</p>
			<h1 id="_idParaDest-124" class="calibre5"><a id="_idTextAnchor267" class="pcalibre pcalibre1 calibre6"/>Integrating third-party tools for enhanced functionality</h1>
			<p class="calibre3">This section covers the process of using Python so that you can include the popular web application security scanner ZAP in your security workflow. You can speed up vulnerability assessments and easily incorporate them into your development <a id="_idIndexMarker560" class="pcalibre pcalibre1 calibre6"/><a id="_idIndexMarker561" class="pcalibre pcalibre1 calibre6"/>cycle by automating ZAP scans. We chose ZAP because it is the most widely used web application scanner on the market, is open source, and is extremely powerful. Additionally, we’ll explore how to leverage CI/CD for automation and how to integrate Beagle Security, a proprietary automated penetration testing tool for web applications and APIs.</p>
			<p class="calibre3">ZAP is a widely used open source web application security scanner. It helps in identifying security vulnerabilities in web applications during the development and testing phases. ZAP provides a range of features, including automated scanning, passive scanning, active scanning, and API access, making it an excellent tool for integrating into automated security pipelines.</p>
			<h2 id="_idParaDest-125" class="calibre7"><a id="_idTextAnchor268" class="pcalibre pcalibre1 calibre6"/>Why automate ZAP with Python?</h2>
			<p class="calibre3">Automating ZAP using Python offers several advantages:</p>
			<ul class="calibre17">
				<li class="calibre16"><strong class="bold">Efficiency</strong>: Automation reduces the manual effort <a id="_idIndexMarker562" class="pcalibre pcalibre1 calibre6"/><a id="_idIndexMarker563" class="pcalibre pcalibre1 calibre6"/>required for security testing, allowing teams to focus on other critical tasks.</li>
				<li class="calibre16"><strong class="bold">Consistency</strong>: Automated tests ensure that security scans are performed consistently across different environments and iterations.</li>
				<li class="calibre16"><strong class="bold">Integration</strong>: Python’s extensive libraries and frameworks make it easy to integrate ZAP into existing CI/CD pipelines and toolchains.</li>
				<li class="calibre16"><strong class="bold">Customization</strong>: Python allows you to easily customize ZAP scans to fit specific project requirements.</li>
				<li class="calibre16"><strong class="bold">Scalability</strong>: Automated scans can be easily scaled to accommodate large and complex web applications.</li>
			</ul>
			<h2 id="_idParaDest-126" class="calibre7"><a id="_idTextAnchor269" class="pcalibre pcalibre1 calibre6"/>Setting up the ZAP automation environment</h2>
			<p class="calibre3">Before we dive into automating ZAP with Python, let’s set<a id="_idIndexMarker564" class="pcalibre pcalibre1 calibre6"/><a id="_idIndexMarker565" class="pcalibre pcalibre1 calibre6"/> up our environment:</p>
			<ol class="calibre15">
				<li class="calibre16"><strong class="bold">Install ZAP</strong>: Download and install ZAP from the official website (<a href="https://www.zaproxy.org/" class="pcalibre pcalibre1 calibre6">https://www.zaproxy.org/</a>).</li>
				<li class="calibre16"><strong class="bold">Python environment</strong>: Ensure you have Python installed on your system. You can download Python from <a href="https://www.python.org/" class="pcalibre pcalibre1 calibre6">https://www.python.org/</a> and set up a virtual environment for your project.</li>
				<li class="calibre16"><strong class="bold">ZAP API key</strong>: Generate an API key in ZAP. This key will be used to authenticate API requests from our Python scripts.</li>
			</ol>
			<h2 id="_idParaDest-127" class="calibre7"><a id="_idTextAnchor270" class="pcalibre pcalibre1 calibre6"/>Automating ZAP with Python</h2>
			<p class="calibre3">Now, let’s look into the process <a id="_idIndexMarker566" class="pcalibre pcalibre1 calibre6"/><a id="_idIndexMarker567" class="pcalibre pcalibre1 calibre6"/>of automating ZAP using Python:</p>
			<ol class="calibre15">
				<li class="calibre16"><strong class="bold">Install the required Python packages</strong>: We’ll need the <strong class="source-inline1">python-owasp-zap-v2</strong> package to interact with ZAP programmatically. Install it using <strong class="source-inline1">pip</strong>:<pre class="source-code">
<strong class="bold1">pip install python-owasp-zap-v2</strong></pre></li>				<li class="calibre16"><strong class="bold">Initialize a ZAP session</strong>: In our Python script, we’ll start by initializing a session with ZAP:<pre class="source-code">
 from zapv2 import ZAPv2
 zap = ZAPv2()</pre></li>				<li class="calibre16"><strong class="bold">Configure target URLs</strong>: Specify the URLs of the web applications you want to scan:<pre class="source-code">
 target_url = 'http://example.com'</pre></li>				<li class="calibre16"><strong class="bold">Perform an active scan</strong>: Next, we’ll trigger an active scan on the specified target URL:<pre class="source-code">
 scan_id = zap.spider.scan(target_url)
 zap.spider.wait_for_complete(scan_id)
 scan_id = zap.ascan.scan(target_url)
 zap.ascan.wait_for_complete(scan_id)</pre></li>				<li class="calibre16"><strong class="bold">Get scan results</strong>: Once the scan is complete, we can retrieve the scan results:<pre class="source-code">
 alerts = zap.core.alerts()
 for alert in alerts:
     print('Alert: {}'.format(alert))</pre></li>				<li class="calibre16"><strong class="bold">Generate a report</strong>: Finally, we can generate a report of the scan’s findings:<pre class="source-code">
 report = zap.core.htmlreport()
 with open('report.html', 'w') as f:
     f.write(report)</pre></li>			</ol>
			<p class="calibre3">Let’s enhance the provided script by adding a function to send the result to a webhook. This will allow us to integrate it seamlessly with communication platforms such as Slack or Microsoft Teams, which typically require specific formats to accept and display the results effectively. You can format the result however you see fit. So, let’s add that function:</p>
			<pre class="source-code">
  import requests
  from zapv2 import ZAPv2
  def send_webhook_notification(report):
      webhook_url = 'https://your.webhook.endpoint'  # Replace this with your actual webhook URL
      headers = {'Content-Type': 'application/json'}
      data = {'report': report}
      try:
         response = requests.post(webhook_url, json=data, headers=headers)
         response.raise_for_status()
         print("Webhook notification sent successfully.")
     except requests.exceptions.RequestException as e:
         print(f"Failed to send webhook notification: {e}")
 def main():
     # Step 2: Initialize OWASP ZAP Session
     zap = ZAPv2()
     # Step 3: Configure Target URLs
     target_url = 'http://example.com'
     # Step 4: Perform Active Scan
     scan_id = zap.spider.scan(target_url)
     zap.spider.wait_for_complete(scan_id)
     scan_id = zap.ascan.scan(target_url)
     zap.ascan.wait_for_complete(scan_id)
     # Step 5: Get Scan Results
     alerts = zap.core.alerts()
     for alert in alerts:
         print('Alert: {}'.format(alert))
     # Step 6: Generate Report
     report = zap.core.htmlreport()
     # Step 7: Send Webhook Notification
     send_webhook_notification(report)
     with open('report.html', 'w') as f:
         f.write(report)
 if __name__ == "__main__":
     main()</pre>			<p class="calibre3">In this updated script, I’ve defined a <code>send_webhook_notification</code> function that takes the generated report as input and sends it to the specified webhook URL using an HTTP POST request. The <code>main</code> function remains the<a id="_idIndexMarker568" class="pcalibre pcalibre1 calibre6"/><a id="_idIndexMarker569" class="pcalibre pcalibre1 calibre6"/> same, but after generating the report, it calls the <code>send_webhook_notification</code> function to send the report to the webhook endpoint.</p>
			<p class="calibre3">Note that you should replace <code>'https://your.webhook.endpoint'</code> with the actual URL of your webhook endpoint.</p>
			<p class="calibre3">With this addition, the script will now send the scan results to the specified webhook endpoint after completing the security scan. Make sure your webhook endpoint can receive and process the incoming data accordingly.</p>
			<p class="calibre3">Now, let’s explore CI/CD, the method we’ll use to integrate ZAP into the development workflow.</p>
			<h2 id="_idParaDest-128" class="calibre7"><a id="_idTextAnchor271" class="pcalibre pcalibre1 calibre6"/>CI/CD – what is it and why is it important for <a id="_idIndexMarker570" class="pcalibre pcalibre1 calibre6"/>security automation?</h2>
			<p class="calibre3"><strong class="bold">CI</strong> means developers regularly add their code changes to a shared code base. Each time this happens, automated tests are run to catch any mistakes early. <strong class="bold">CD</strong> goes a step further, automatically putting those changes into action in the real world after they pass all tests.</p>
			<p class="calibre3">Let’s take a look at why CI/CD is important for <a id="_idIndexMarker571" class="pcalibre pcalibre1 calibre6"/><a id="_idIndexMarker572" class="pcalibre pcalibre1 calibre6"/>security automation:</p>
			<ul class="calibre17">
				<li class="calibre16"><strong class="bold">Faster updates</strong>: CI/CD lets us deliver updates to our software quickly and safely.</li>
				<li class="calibre16"><strong class="bold">Better quality</strong>: Automated testing helps us find and fix problems before they affect users.</li>
				<li class="calibre16"><strong class="bold">Less manual work</strong>: With automation, we spend less time doing repetitive tasks.</li>
				<li class="calibre16"><strong class="bold">Team collaboration</strong>: CI/CD brings developers, testers, and operations teams together to work more efficiently.</li>
			</ul>
			<p class="calibre3">Now, let’s see how we can use Jenkins to automate ZAP.</p>
			<h3 class="calibre9">Introduction to Jenkins</h3>
			<p class="calibre3">Jenkins is a free tool that helps set up and manage CI/CD pipelines. It’s easy to customize and works with many other tools. Jenkins makes it simple to automate tasks such as building, testing, and deploying software.</p>
			<p class="calibre3">Let’s understand why we<a id="_idIndexMarker573" class="pcalibre pcalibre1 calibre6"/><a id="_idIndexMarker574" class="pcalibre pcalibre1 calibre6"/> should use Jenkins for <a id="_idIndexMarker575" class="pcalibre pcalibre1 calibre6"/>security automation:</p>
			<ul class="calibre17">
				<li class="calibre16"><strong class="bold">Free and open source</strong>: Jenkins doesn’t cost anything to use, and anyone can contribute to its development.</li>
				<li class="calibre16"><strong class="bold">Flexible</strong>: Jenkins can be customized to work with different tools and technologies, making it adaptable to different projects.</li>
				<li class="calibre16"><strong class="bold">Supportive community</strong>: There’s a big community of Jenkins users who share tips and help each other out.</li>
				<li class="calibre16"><strong class="bold">Scales easily</strong>: Jenkins can handle projects of all sizes, from small teams to large organizations.</li>
			</ul>
			<p class="calibre3">Integrating the ZAP automation <a id="_idIndexMarker576" class="pcalibre pcalibre1 calibre6"/><a id="_idIndexMarker577" class="pcalibre pcalibre1 calibre6"/>script into a Jenkins pipeline involves defining stages and steps in <code>Jenkinsfile</code> format to execute the script as part of the pipeline. Let’s learn how to set up a Jenkins pipeline to run the ZAP automation script:</p>
			<ol class="calibre15">
				<li class="calibre16"><strong class="bold">Configure Jenkins</strong>: First, ensure that Jenkins is set up and configured correctly on your system.</li>
				<li class="calibre16"><strong class="bold">Create a Jenkins pipeline</strong>: Create a new pipeline project in Jenkins and configure it to use a <strong class="source-inline1">Jenkinsfile</strong> file from source control (for example, a Git repository).</li>
				<li class="calibre16"><strong class="bold">Define the stages and steps in a Jenkinsfile</strong>: The following is an example <strong class="source-inline1">Jenkinsfile</strong> that defines the stages and steps to execute the ZAP automation script:<pre class="source-code">
  pipeline {
      agent any
      stages {
          stage('Initialize') {
              steps {
                  // Checkout source code from repository if needed
                  // For example: git 'https://github.com/your/repository.git'
              }
         }
         stage(' ZAP Scan') {
             steps {
                 sh '''
                     python3 -m venv venv
                     source venv/bin/activate
                     pip install python-owasp-zap-v2 requests
                     python owasp_zap_scan.py
                 '''
             }
         }
     }
 }</pre></li>				<li class="calibre16"><strong class="bold">Script execution</strong>: Here’s a breakdown of the execution process to provide context for each substep:<ol class="calibre19"><li class="upper-roman">The <strong class="source-inline1">agent any</strong> directive tells Jenkins to execute the pipeline on any available agent.</li><li class="upper-roman">The <strong class="source-inline1">stages</strong> block defines the different stages of the pipeline.</li><li class="upper-roman">The <strong class="source-inline1">Initialize</strong> stage checks out the source code from the repository if needed.</li><li class="upper-roman">The <strong class="source-inline1">ZAP Scan</strong> stage executes the ZAP automation script. In this example, it activates a Python virtual environment, installs the required packages, and executes the script (<strong class="source-inline1">zap_scan.py</strong>).</li><li class="upper-roman">Ensure that <strong class="source-inline1">zap_scan.py</strong> and the Jenkinsfile are present in the source code repository.</li></ol></li>
				<li class="calibre16"><strong class="bold">Save and run the pipeline</strong>: Save the <strong class="source-inline1">Jenkinsfile</strong> file, configure any additional settings if necessary, and run the pipeline.</li>
				<li class="calibre16"><strong class="bold">View the results</strong>: Once the<a id="_idIndexMarker578" class="pcalibre pcalibre1 calibre6"/><a id="_idIndexMarker579" class="pcalibre pcalibre1 calibre6"/> pipeline execution is complete, you can view the results, including the ZAP scan report and webhook notifications if configured.</li>
			</ol>
			<p class="callout-heading">Important note</p>
			<p class="callout">Ensure that the Jenkins environment has Python installed and that it has access to the internet to download the required packages.</p>
			<p class="callout">Customize the pipeline script according to your project’s requirements, such as configuring Git repository details, specifying Python versions, and adjusting paths as needed.</p>
			<p class="callout">Set up webhook endpoints to receive notifications from the pipeline as required.</p>
			<p class="calibre3">By following these steps, you can integrate the ZAP automation script into a Jenkins pipeline to automate security testing in your CI/CD workflow.</p>
			<p class="calibre3">We have successfully created an automated pipeline with the open source tools ZAP and Jenkins. With a few minor code modifications, you can integrate this into your development cycle as the concept remains the same – just the tools you explicitly require have to be identified.</p>
			<p class="calibre3">This time, let’s integrate Beagle Security, a proprietary program, into our workflow.</p>
			<h2 id="_idParaDest-129" class="calibre7"><a id="_idTextAnchor272" class="pcalibre pcalibre1 calibre6"/>Integrating Beagle Security into our security pipeline</h2>
			<p class="calibre3">In this section, we’ll explore how to automate the process <a id="_idIndexMarker580" class="pcalibre pcalibre1 calibre6"/><a id="_idIndexMarker581" class="pcalibre pcalibre1 calibre6"/>of testing an application using Beagle Security’s API and Python. Beagle Security provides<a id="_idIndexMarker582" class="pcalibre pcalibre1 calibre6"/><a id="_idIndexMarker583" class="pcalibre pcalibre1 calibre6"/> a comprehensive suite of APIs that enable developers to seamlessly integrate security testing into their CI/CD pipelines or automation workflows. By leveraging these APIs, developers can initiate tests, monitor their progress, retrieve results, and much more, all done programmatically.</p>
			<h3 class="calibre9">Understanding Beagle Security’s API</h3>
			<p class="calibre3">Before we delve into the automation process, let’s<a id="_idIndexMarker584" class="pcalibre pcalibre1 calibre6"/><a id="_idIndexMarker585" class="pcalibre pcalibre1 calibre6"/> familiarize ourselves with the key endpoints provided by Beagle Security’s API:</p>
			<ol class="calibre15">
				<li class="calibre16"><strong class="bold">Start a test</strong> (<strong class="source-inline1">POST /test/start</strong>):<ul class="calibre18"><li class="calibre16">Initiates a security test for a specified application</li><li class="calibre16">Requires the application token</li><li class="calibre16">Returns the status URL, result URL, result token, and a message indicating the success or failure of the test start</li></ul></li>
				<li class="calibre16"><strong class="bold">Stop a test</strong> (<strong class="source-inline1">POST /test/stop</strong>):<ul class="calibre18"><li class="calibre16">Halts a running test</li><li class="calibre16">Requires the application token</li><li class="calibre16">Returns a status code and a message indicating the success or failure of the stop request</li></ul></li>
				<li class="calibre16"><strong class="bold">Get test result</strong> (<strong class="source-inline1">GET /test/result</strong>):<ul class="calibre18"><li class="calibre16">Retrieves the result of a completed test in JSON format</li><li class="calibre16">Requires the application token and result token</li><li class="calibre16">Returns the test result in JSON format, along with a status code and a message</li></ul></li>
			</ol>
			<p class="calibre3">To fully utilize the potential of the Beagle Security platform, you can benefit from the versatile and user-friendly design of the v2 APIs. The whole API documentation is available at <a href="https://beaglesecurity.com/developer/apidoc" class="pcalibre pcalibre1 calibre6">https://beaglesecurity.com/developer/apidoc</a>; however, we will only be using a selection of them in this chapter.</p>
			<p class="calibre3">Now that we have a clear understanding of the API endpoints provided by Beagle Security, let’s proceed with automating the testing process using Python.</p>
			<h2 id="_idParaDest-130" class="calibre7"><a id="_idTextAnchor273" class="pcalibre pcalibre1 calibre6"/>Automating testing with Python</h2>
			<p class="calibre3">To automate the testing process, we’ll utilize Python’s <code>requests</code> library to interact with Beagle Security’s API endpoints. The following is a step-by-step guide <a id="_idIndexMarker586" class="pcalibre pcalibre1 calibre6"/><a id="_idIndexMarker587" class="pcalibre pcalibre1 calibre6"/>on how to implement each part of the automation process:</p>
			<ol class="calibre15">
				<li class="calibre16"><strong class="bold">Retrieve projects and create new ones</strong>: Before we can begin testing methods, we must check that our project is present within Beagle Security. If it is missing, we will quickly create a replacement:<pre class="source-code">
  import requests
  def get_projects():
      # Retrieve existing projects
      url = "https://api.beaglesecurity.com/rest/v2/projects"
      headers = {
          "Authorization": "Bearer YOUR_ACCESS_TOKEN"
      }
      response = requests.get(url, headers=headers)
     return response.json()
 def create_project(name):
     # Formulate a new project
     url = "https://api.beaglesecurity.com/rest/v2/projects"
     headers = {
         "Content-Type": "application/json",
         "Authorization": "Bearer YOUR_ACCESS_TOKEN"
     }
     data = {
         "name": name
     }
     response = requests.post(url, json=data, headers=headers)
     return response.json()
 # Usage Example
 projects = get_projects()
 if "desired_project_name" not in projects:
     create_project("desired_project_name")</pre><p class="calibre3">Let’s take a closer look at this<a id="_idIndexMarker588" class="pcalibre pcalibre1 calibre6"/><a id="_idIndexMarker589" class="pcalibre pcalibre1 calibre6"/> code snippet:</p><ol class="calibre19"><li class="upper-roman">We import the <strong class="source-inline1">requests</strong> module to handle HTTP requests.</li><li class="upper-roman">The <strong class="source-inline1">get_projects</strong> function sends a <strong class="source-inline1">GET</strong> request to the Beagle Security API to retrieve existing projects associated with the provided access token.</li><li class="upper-roman">The <strong class="source-inline1">create_project</strong> function sends a <strong class="source-inline1">POST</strong> request to create a new project with the specified name.</li><li class="upper-roman">In this example, we fetch the existing projects and create a new one if the desired project name is not found in the list of projects retrieved.</li></ol></li>				<li class="calibre16"><strong class="bold">Create a new application</strong>: Once the project framework has been constructed, we will proceed to build a new application beneath it:<pre class="source-code">
  def create_application(project_id, name, url):
      # Establish a new application within the designated project
      url = "https://api.beaglesecurity.com/rest/v2/applications"
      headers = {
          "Content-Type": "application/json",
          "Authorization": "Bearer YOUR_ACCESS_TOKEN"
      }
      data = {
          "projectId": project_id,
         "name": name,
         "url": url
     }
     response = requests.post(url, json=data, headers=headers)
     return response.json()
 # Usage Example
 project_id = "your_project_id"
 application_name = "Your Application"
 application_url = "https://your-application-url.com"
 application = create_application(project_id, application_name, application_url)</pre><p class="calibre3">Let’s take a closer look at this code:</p><ol class="calibre19"><li class="upper-roman">The <strong class="source-inline1">create_application</strong> function sends a <strong class="source-inline1">POST</strong> request to create a new application under the specified project.</li><li class="upper-roman">It requires parameters such as <strong class="source-inline1">project_id</strong>, <strong class="source-inline1">name</strong>, and <strong class="source-inline1">url</strong> for the new application.</li><li class="upper-roman">In the usage example, we provide the project ID, application name, and URL to create a new application.</li></ol></li>				<li class="calibre16"><strong class="bold">Verify the domain</strong>: Before testing, domain<a id="_idIndexMarker590" class="pcalibre pcalibre1 calibre6"/><a id="_idIndexMarker591" class="pcalibre pcalibre1 calibre6"/> ownership verification is required to guarantee proper ownership and authorization for security assessments:<pre class="source-code">
  def verify_domain(application_token):
      # Retrieve domain verification signature
      url = f"https://api.beaglesecurity.com/rest/v2/applications/signature?application_token={application_token}"
      headers = {
          "Authorization": "Bearer YOUR_ACCESS_TOKEN"
      }
      response = requests.get(url, headers=headers)
      return response.json()
 # Usage Example
 application_token = "your_application_token"
 domain_verification_signature = verify_domain(application_token)
13.</pre><p class="calibre3">Let’s take a look at this code example:</p><ol class="calibre19"><li class="upper-roman">The <strong class="source-inline1">verify_domain</strong> function sends a <strong class="source-inline1">GET</strong> request to obtain the domain verification signature for the specified application token.</li><li class="upper-roman">It constructs the URL dynamically using f-strings to include the application token in the request.</li><li class="upper-roman">In the usage example, we <a id="_idIndexMarker592" class="pcalibre pcalibre1 calibre6"/><a id="_idIndexMarker593" class="pcalibre pcalibre1 calibre6"/>provide the application token to retrieve the domain verification signature.</li></ol></li>				<li class="calibre16"><strong class="bold">Start the test</strong>: After domain validation, we begin the security test for our application:<pre class="source-code">
  def start_test(application_token):
      # Commence the test for the specified application
      url = "https://api.beaglesecurity.com/rest/v2/test/start"
      headers = {
          "Content-Type": "application/json",
          "Authorization": "Bearer YOUR_ACCESS_TOKEN"
      }
      data = {
          "applicationToken": application_token
     }
     response = requests.post(url, json=data, headers=headers)
     return response.json()
 # Usage Example
 test_start_response = start_test(application_token)</pre><p class="calibre3">Here’s an explanation for this code:</p><ol class="calibre19"><li class="upper-roman">The <strong class="source-inline1">start_test</strong> function sends a <strong class="source-inline1">POST</strong> request to initiate the security test for the specified application token.</li><li class="upper-roman">It includes the application token in the request payload.</li><li class="upper-roman">In the usage example, we pass the application token to start the test.</li></ol></li>			</ol>
			<p class="calibre3">Now, let’s merge all of these functions into a single script that we can use for our automated workflow:</p>
			<pre class="source-code">
   import requests
   import sys
   # Define global variables
   BEAGLE_API_BASE_URL = "https://api.beaglesecurity.com/rest/v2"
   ACCESS_TOKEN = "YOUR_ACCESS_TOKEN"
   def get_projects():
       # Retrieve projects from Beagle Security
      url = f"{BEAGLE_API_BASE_URL}/projects"
      headers = {"Authorization": f"Bearer {ACCESS_TOKEN}"}
      response = requests.get(url, headers=headers)
      return response.json()
  def create_project(name):
      # Create a new project if it doesn't exist
      url = f"{BEAGLE_API_BASE_URL}/projects"
      headers = {
          "Content-Type": "application/json",
          "Authorization": f"Bearer {ACCESS_TOKEN}",
      }
      data = {"name": name}
      response = requests.post(url, json=data, headers=headers)
      return response.json()
  def create_application(project_id, name, url):
      # Create a new application under the specified project
      url = f"{BEAGLE_API_BASE_URL}/applications"
      headers = {
          "Content-Type": "application/json",
          "Authorization": f"Bearer {ACCESS_TOKEN}",
      }
      data = {"projectId": project_id, "name": name, "url": url}
      response = requests.post(url, json=data, headers=headers)
      return response.json()
  def verify_domain(application_token):
      # Verify domain ownership for the application
      url = f"{BEAGLE_API_BASE_URL}/applications/signature?application_token={application_token}"
      headers = {"Authorization": f"Bearer {ACCESS_TOKEN}"}
      response = requests.get(url, headers=headers)
      return response.json()
  def start_test(application_token):
      # Start a security test for the specified application
      url = f"{BEAGLE_API_BASE_URL}/test/start"
      headers = {
          "Content-Type": "application/json",
          "Authorization": f"Bearer {ACCESS_TOKEN}",
      }
      data = {"applicationToken": application_token}
      response = requests.post(url, json=data, headers=headers)
      return response.json()
  def send_results_to_webhook(application_token, result_token, webhook_url):
      # Get test result
      url = f"{BEAGLE_API_BASE_URL}/test/result?application_token={application_token}&amp;result_token={result_token}"
      headers = {"Authorization": f"Bearer {ACCESS_TOKEN}"}
      response = requests.get(url, headers=headers)
      test_result = response.json()
      # Send result to webhook
      webhook_data = {
          "application_token": application_token,
          "result_token": result_token,
          "result": test_result,
      }
      webhook_response = requests.post(webhook_url, json=webhook_data)
      return webhook_response.status_code
  def main():
      # Check if project name argument is provided
      if len(sys.argv) &lt; 2:
          print("Usage: python script.py &lt;project_name&gt;")
          sys.exit(1)
      # Extract project name from command-line arguments
      project_name = sys.argv[1]
      # Example usage
      application_name = "Your Application"
      application_url = "https://your-application-url.com"
      webhook_url = "https://your-webhook-url.com"
      # Retrieve projects or create a new one
      projects = get_projects()
      project_id = projects.get(project_name)
      if not project_id:
          new_project = create_project(project_name)
          project_id = new_project["id"]
      # Create a new application under the project
      new_application = create_application(project_id, application_name, application_url)
      application_token = new_application["applicationToken"]
      # Verify domain ownership
      domain_verification_signature = verify_domain(application_token)
      # Start a security test
      test_start_response = start_test(application_token)
     result_token = test_start_response["resultToken"]
     # Send results to webhook
     webhook_status_code = send_results_to_webhook(application_token, result_token, webhook_url)
     print(f"Webhook status code: {webhook_status_code}")
 if __name__ == "__main__":
     main()</pre>			<p class="calibre3">The <code>main()</code> function serves as the entry point of our Python script. It orchestrates the various steps involved in automating application testing using <a id="_idIndexMarker594" class="pcalibre pcalibre1 calibre6"/><a id="_idIndexMarker595" class="pcalibre pcalibre1 calibre6"/>Beagle Security’s API. Let’s break down each part of the <code>main()</code> function in detail:</p>
			<ol class="calibre15">
				<li class="calibre16"><strong class="bold">Argument validation</strong>: The function begins by checking if the user has provided the required command-line arguments. In this case, we expect at least two arguments: the script name and the project name. If fewer than two arguments are provided, the function prints a usage message and exits with an error code.</li>
				<li class="calibre16"><strong class="bold">Project name extraction</strong>: If the correct number of arguments is provided, the script extracts the project name from the command-line arguments. This is done using <strong class="source-inline1">sys.argv[1]</strong>, which retrieves the second command-line argument (the first argument is always the script’s name).</li>
				<li class="calibre16"><strong class="bold">Additional variables are defined</strong>: Next, we define additional variables, such as <strong class="source-inline1">application_name</strong>, <strong class="source-inline1">application_url</strong>, and <strong class="source-inline1">webhook_url</strong>. These variables represent the name, URL, and webhook URL of the application being tested, respectively. These values are placeholders and should be replaced with actual values relevant to your application.<p class="calibre3">The following code block is related to the previous three points and demonstrates their implementation in Python:</p><pre class="source-code">
 def main():
      # Check if project name argument is provided
      if len(sys.argv) &lt; 2:
          print("Usage: python script.py &lt;project_name&gt;")
          sys.exit(1)
      # Extract project name from command-line arguments
     project_name = sys.argv[1]
      # Example usage
     application_name = "Your Application"
     application_url = "https://your-application-url.com"
     webhook_url = "https://your-webhook-url.com"</pre></li>				<li class="calibre16"><strong class="bold">Retrieve or create a project</strong>: The script calls the <strong class="source-inline1">get_projects()</strong> function to retrieve a list of existing projects from Beagle Security. It then attempts<a id="_idIndexMarker596" class="pcalibre pcalibre1 calibre6"/><a id="_idIndexMarker597" class="pcalibre pcalibre1 calibre6"/> to find the project specified by the user. If the project does not exist (<strong class="source-inline1">project_id</strong> is <strong class="source-inline1">None</strong>), the script creates a new project using the <strong class="source-inline1">create_project()</strong> function and assigns the obtained project ID to <strong class="source-inline1">project_id</strong>:<pre class="source-code">
     # Retrieve projects or create a new one
     projects = get_projects()
     project_id = projects.get(project_name)
     if not project_id:
         new_project = create_project(project_name)
         project_id = new_project["id"]</pre></li>				<li class="calibre16"><strong class="bold">Create the application</strong>: Once we know the project exists, the script proceeds to create a new application under the specified project. It calls the <strong class="source-inline1">create_application()</strong> function, passing the project ID, application name, and URL as arguments. The function returns a dictionary containing information about the newly created application, from which we extract the application token (<strong class="source-inline1">applicationToken</strong>):<pre class="source-code">
     # Create a new application under the project
     new_application = create_application(project_id, application_name, application_url)
     application_token = new_application["applicationToken"]</pre></li>				<li class="calibre16"><strong class="bold">Verify the domain</strong>: The script verifies domain ownership for the newly created application by calling the <strong class="source-inline1">verify_domain()</strong> function with the application token as an argument. This step ensures that the security tests are conducted by the rightful owner:<pre class="source-code">
     # Verify domain ownership
     domain_verification_signature = verify_domain(application_token)</pre></li>				<li class="calibre16"><strong class="bold">Start the test</strong>: With domain ownership verified, the script initiates a security test for the application by calling the <strong class="source-inline1">start_test()</strong> function with the application token as an argument. It then extracts <strong class="source-inline1">result_token</strong> from the response, which is needed to retrieve the test results later:<pre class="source-code">
# Start a security test
     test_start_response = start_test(application_token)
     result_token = test_start_response["resultToken"]</pre></li>				<li class="calibre16"><strong class="bold">Send the results to a webhook</strong>: Finally, the script sends the test results to a webhook URL by calling the <strong class="source-inline1">send_results_to_webhook()</strong> function with the application token, result token, and webhook URL as arguments. It prints the status code of the webhook’s response for verification purposes:<pre class="source-code">
 # Send results to webhook
     webhook_status_code = send_results_to_webhook(application_token, result_token, webhook_url)
     print(f"Webhook status code: {webhook_status_code}")</pre></li>			</ol>
			<p class="calibre3">By using Beagle Security’s API and Python, we built a fully automated flow that we will now put into our CI/CD flow while using GitHub Actions as our tool of choice.</p>
			<p class="calibre3">GitHub Actions enables you to define workflows<a id="_idIndexMarker598" class="pcalibre pcalibre1 calibre6"/><a id="_idIndexMarker599" class="pcalibre pcalibre1 calibre6"/> directly within your repository’s code base, automating tasks such as building, testing, and deploying your applications.</p>
			<p class="calibre3">So, let’s create a GitHub Actions workflow so that we can start a test on code push to the repository:</p>
			<ol class="calibre15">
				<li class="calibre16"><strong class="bold">Create a workflow file</strong>: Begin by creating a <strong class="source-inline1">.github/workflows</strong> directory in your repository if it doesn’t already exist. Inside this directory, create a YAML file where you will define your GitHub Actions workflow. You can name this file whatever you like – for example, <strong class="source-inline1">beagle_security_test.yml</strong>.</li>
				<li class="calibre16"><strong class="bold">Define the workflow’s steps</strong>: Define the steps of your workflow within the YAML file. These steps will include tasks such as checking out the code, running tests, and interacting with Beagle Security’s API:<pre class="source-code">
  name: Beagle Security Test
  on:
    push:
      branches:
        - main  # Adjust branch name as needed
  jobs:
    build:
     runs-on: ubuntu-latest
     steps:
       - name: Checkout code
         uses: actions/checkout@v2
       - name: Set up Python
         uses: actions/setup-python@v2
         with:
           python-version: '3.x'  # Specify Python version
       - name: Install dependencies
         run: pip install requests  # Install requests library
       - name: Run Beagle Security tests
         run: python beagle_security_test.py argument_value</pre></li>			</ol>
			<p class="calibre3">Now that the GitHub Actions workflow is set up, we can integrate automated testing into the workflow using Beagle Security.</p>
			<p class="calibre3">We’ll use a Python script (<code>beagle_security_test.py</code>) to interact with Beagle Security’s API and automate the testing process. The Python script contains functions to interact with Beagle Security’s API, including retrieving projects, creating applications, verifying domains, and starting tests.</p>
			<p class="calibre3">Within the GitHub Actions workflow, add a step to execute the Python script, ensuring that the necessary dependencies (for example, the <code>requests</code> library) are installed:</p>
			<pre class="source-code">
 steps:
   ...
   - name: Run Beagle Security tests
     run: python beagle_security_test.py</pre>			<p class="calibre3">By integrating automated testing with Beagle<a id="_idIndexMarker600" class="pcalibre pcalibre1 calibre6"/><a id="_idIndexMarker601" class="pcalibre pcalibre1 calibre6"/> Security into GitHub Actions, you can speed up the process of delivering high-quality, safe software while reducing manual effort and increasing overall efficiency.</p>
			<p class="calibre3">While APIs are designed to be flexible and for custom use cases, Beagle Security also offers plugins for all CI/CD tools to speed up the process for you. You can find the full documentation at <a href="https://beaglesecurity.com/developer/devsecopsdoc" class="pcalibre pcalibre1 calibre6">https://beaglesecurity.com/developer/devsecopsdoc</a>.</p>
			<p class="calibre3">To summarize, in this section, we identified OWASP ZAP and Beagle Security as our automated DAST tools, and we built two security pipelines while utilizing Jenkins and GitHub Actions. We only covered basic routines here; however, we can modify them to meet our needs.</p>
			<p class="calibre3">In the next section, we’ll learn how to achieve resilience and reliability in our automated workflows.</p>
			<h1 id="_idParaDest-131" class="calibre5"><a id="_idTextAnchor274" class="pcalibre pcalibre1 calibre6"/>Ensuring reliability and resilience in automated workflows</h1>
			<p class="calibre3">Reliability and resilience are fundamental aspects of any <a id="_idIndexMarker602" class="pcalibre pcalibre1 calibre6"/><a id="_idIndexMarker603" class="pcalibre pcalibre1 calibre6"/>automated workflow, especially in the context of DevOps, where CI/CD pipelines are prevalent. In this section, we will delve into various strategies and best practices that you can use to ensure the reliability and resilience of your automated workflows.</p>
			<h2 id="_idParaDest-132" class="calibre7"><a id="_idTextAnchor275" class="pcalibre pcalibre1 calibre6"/>Robust error-handling mechanisms</h2>
			<p class="calibre3">Error handling is crucial in automated workflows<a id="_idIndexMarker604" class="pcalibre pcalibre1 calibre6"/><a id="_idIndexMarker605" class="pcalibre pcalibre1 calibre6"/> to gracefully manage unexpected failures and errors. The following are some robust error-handling <a id="_idIndexMarker606" class="pcalibre pcalibre1 calibre6"/><a id="_idIndexMarker607" class="pcalibre pcalibre1 calibre6"/>mechanisms:</p>
			<ul class="calibre17">
				<li class="calibre16"><strong class="bold">Exception handling</strong>: Implement <strong class="source-inline1">try</strong>-<strong class="source-inline1">except</strong> blocks to catch and handle exceptions that may occur during script execution. This allows for graceful degradation and prevents the entire workflow from failing due to isolated errors.</li>
				<li class="calibre16"><strong class="bold">Logging</strong>: Incorporate logging <a id="_idIndexMarker608" class="pcalibre pcalibre1 calibre6"/><a id="_idIndexMarker609" class="pcalibre pcalibre1 calibre6"/>mechanisms to record errors, warnings, and informational messages. Detailed logs facilitate troubleshooting and provide valuable insights into the execution flow of automated workflows.</li>
				<li class="calibre16"><strong class="bold">Meaningful error messages</strong>: Ensure that<a id="_idIndexMarker610" class="pcalibre pcalibre1 calibre6"/><a id="_idIndexMarker611" class="pcalibre pcalibre1 calibre6"/> error messages are informative and actionable, providing relevant details about the nature of the error and potential resolution steps.</li>
			</ul>
			<h2 id="_idParaDest-133" class="calibre7"><a id="_idTextAnchor276" class="pcalibre pcalibre1 calibre6"/>Implementing retry logic</h2>
			<p class="calibre3">Transient failures, such as network<a id="_idIndexMarker612" class="pcalibre pcalibre1 calibre6"/><a id="_idIndexMarker613" class="pcalibre pcalibre1 calibre6"/> timeouts or temporary service disruptions, are common in distributed systems. Implementing retry logic helps <a id="_idIndexMarker614" class="pcalibre pcalibre1 calibre6"/><a id="_idIndexMarker615" class="pcalibre pcalibre1 calibre6"/>mitigate the impact of such failures:</p>
			<ul class="calibre17">
				<li class="calibre16"><strong class="bold">Exponential backoff</strong>: Use exponential backoff strategies when retrying failed operations to prevent overwhelming the system with repeated requests. Gradually increasing the interval between retries reduces the likelihood of exacerbating the issue.</li>
				<li class="calibre16"><strong class="bold">Retry limits and expiry</strong>: Define sensible <a id="_idIndexMarker616" class="pcalibre pcalibre1 calibre6"/><a id="_idIndexMarker617" class="pcalibre pcalibre1 calibre6"/>limits on the number of retries and the maximum duration for retry attempts. Excessive retries can prolong downtime and increase resource consumption, while indefinite retries may indicate a systemic issue that requires manual intervention.</li>
			</ul>
			<h2 id="_idParaDest-134" class="calibre7"><a id="_idTextAnchor277" class="pcalibre pcalibre1 calibre6"/>Building idempotent operations</h2>
			<p class="calibre3">Designing idempotent operations<a id="_idIndexMarker618" class="pcalibre pcalibre1 calibre6"/><a id="_idIndexMarker619" class="pcalibre pcalibre1 calibre6"/> ensures that repeated executions produce the same outcome, regardless of the previous state:</p>
			<ul class="calibre17">
				<li class="calibre16"><strong class="bold">Idempotent scripts</strong>: Structure scripts and workflows so that they’re idempotent, meaning they can be safely rerun without causing unintended side effects or inconsistencies in the system’s state. This is particularly important in scenarios where retries or re-executions are necessary.</li>
				<li class="calibre16"><strong class="bold">Transactional integrity</strong>: Group related operations into transactional units to maintain atomicity and ensure data integrity. If a transaction fails midway, mechanisms should be in place to roll back or compensate for partial changes to avoid data corruption.</li>
			</ul>
			<h2 id="_idParaDest-135" class="calibre7"><a id="_idTextAnchor278" class="pcalibre pcalibre1 calibre6"/>Automated testing and validation</h2>
			<p class="calibre3">Continuous testing is integral to verifying the<a id="_idIndexMarker620" class="pcalibre pcalibre1 calibre6"/><a id="_idIndexMarker621" class="pcalibre pcalibre1 calibre6"/> reliability and correctness of automated workflows:</p>
			<ul class="calibre17">
				<li class="calibre16"><strong class="bold">Test automation</strong>: Integrate <a id="_idIndexMarker622" class="pcalibre pcalibre1 calibre6"/><a id="_idIndexMarker623" class="pcalibre pcalibre1 calibre6"/>automated tests, including unit tests, integration tests, and end-to-end tests, into the CI/CD pipeline to validate changes and configurations. Automated testing ensures that new features or modifications do not introduce regressions or unexpected behavior.</li>
				<li class="calibre16"><strong class="bold">Test environments</strong>: Maintain separate<a id="_idIndexMarker624" class="pcalibre pcalibre1 calibre6"/><a id="_idIndexMarker625" class="pcalibre pcalibre1 calibre6"/> environments for testing and validation, mirroring production as closely as possible. Automatically provisioning and tearing down test environments helps ensure consistency and reproducibility across tests.</li>
			</ul>
			<h2 id="_idParaDest-136" class="calibre7"><a id="_idTextAnchor279" class="pcalibre pcalibre1 calibre6"/>Documentation and knowledge sharing</h2>
			<p class="calibre3">Comprehensive documentation and knowledge <a id="_idIndexMarker626" class="pcalibre pcalibre1 calibre6"/><a id="_idIndexMarker627" class="pcalibre pcalibre1 calibre6"/>sharing promote understanding and collaboration among team members:</p>
			<ul class="calibre17">
				<li class="calibre16"><strong class="bold">Documentation standards</strong>: Document workflows, scripts, configurations, and dependencies thoroughly to aid in onboarding and troubleshooting. Include information on prerequisites, inputs, outputs, and expected behavior to facilitate usage and maintenance.</li>
				<li class="calibre16"><strong class="bold">Knowledge-sharing culture</strong>: Foster a culture of knowledge-sharing and collaboration within the team. Conduct regular code reviews, share best practices, and organize training sessions to disseminate knowledge and promote continuous improvement.</li>
			</ul>
			<h2 id="_idParaDest-137" class="calibre7"><a id="_idTextAnchor280" class="pcalibre pcalibre1 calibre6"/>Security and access control</h2>
			<p class="calibre3">Ensuring the security of automated<a id="_idIndexMarker628" class="pcalibre pcalibre1 calibre6"/><a id="_idIndexMarker629" class="pcalibre pcalibre1 calibre6"/> workflows involves safeguarding access to sensitive resources and data:</p>
			<ul class="calibre17">
				<li class="calibre16"><strong class="bold">Access controls</strong>: Implement robust access controls and authentication mechanisms to restrict access to critical resources. Use <a id="_idIndexMarker630" class="pcalibre pcalibre1 calibre6"/><strong class="bold">Role-Based Access Control</strong> (<strong class="bold">RBAC</strong>) to grant permissions based on user roles and responsibilities.</li>
				<li class="calibre16"><strong class="bold">Secret management</strong>: Securely manage credentials, API keys, and other sensitive information using dedicated secret management solutions. Avoid hardcoding secrets in scripts or configuration files and utilize encryption and secure storage options.</li>
			</ul>
			<p class="calibre3">By incorporating these strategies and best practices into your automated workflows, you can enhance their reliability, resilience, and security, thereby enabling smoother and more efficient software delivery processes.</p>
			<p class="calibre3">To illustrate the strategies and best practices discussed in the previous sections, let’s enhance the Beagle Security automation code to ensure reliability and resilience in the automated workflow. We’ll implement error handling and recovery in the<a id="_idIndexMarker631" class="pcalibre pcalibre1 calibre6"/><a id="_idIndexMarker632" class="pcalibre pcalibre1 calibre6"/> existing code and explain the changes in detail to help you better understand their practical application:</p>
			<pre class="source-code">
  import requests
  import sys
  import time
  # Define global variables
  BEAGLE_API_BASE_URL = "https://api.beaglesecurity.com/rest/v2"
  ACCESS_TOKEN = "YOUR_ACCESS_TOKEN"
  # Define maximum retry attempts
 MAX_RETRIES = 3
 def get_projects():
     # Retrieve projects from Beagle Security
     url = f"{BEAGLE_API_BASE_URL}/projects"
     headers = {"Authorization": f"Bearer {ACCESS_TOKEN}"}
     # Implement retry logic for network issues
     retries = 0
     while retries &lt; MAX_RETRIES:
         try:
             response = requests.get(url, headers=headers)
             response.raise_for_status()  # Raise an exception for HTTP errors
             return response.json()
         except requests.exceptions.RequestException as e:
             print(f"Error fetching projects: {e}")
             retries += 1
             if retries &lt; MAX_RETRIES:
                 print("Retrying...")
                 time.sleep(5)  # Wait for 5 seconds before retrying
             else:
                 print("Max retries reached. Exiting...")
                 sys.exit(1)
 def create_project(name):
     # Create a new project if it doesn't exist
     url = f"{BEAGLE_API_BASE_URL}/projects"
     headers = {
         "Content-Type": "application/json",
         "Authorization": f"Bearer {ACCESS_TOKEN}",
     }
     data = {"name": name}
     # Implement error handling for API responses
     try:
         response = requests.post(url, json=data, headers=headers)         response.raise_for_status()
         return response.json()
     except requests.exceptions.RequestException as e:
         print(f"Error creating project: {e}")
         sys.exit(1)
 # Similarly, implement error handling for other functions: create_application, verify_domain, start_test, send_results_to_webhook</pre>			<p class="calibre3">Let’s take a closer look at this code:</p>
			<ul class="calibre17">
				<li class="calibre16"><strong class="bold">Error handling mechanisms</strong>: We added robust error handling using <strong class="source-inline1">try</strong>-<strong class="source-inline1">except</strong> blocks to catch exceptions and handle HTTP errors gracefully. This ensures that the script doesn’t crash abruptly and provides meaningful error messages.</li>
				<li class="calibre16"><strong class="bold">Retry logic</strong>: We implemented retry logic for network-related issues, such as timeouts or intermittent connectivity problems. The script retries failed requests for a predefined number of attempts before exiting.</li>
			</ul>
			<p class="calibre3">By incorporating error handling and<a id="_idIndexMarker633" class="pcalibre pcalibre1 calibre6"/><a id="_idIndexMarker634" class="pcalibre pcalibre1 calibre6"/> retry mechanisms into the automated workflow, we ensure reliability and resilience, thereby minimizing the impact of failures and enhancing the overall robustness of the system. These practices enable smoother execution, effective troubleshooting, and continuous improvement of the automated processes.</p>
			<p class="calibre3">Now, let’s look at how to add logging as part of continuously improving our pipeline. We will work on the same code and learn how to make it work.</p>
			<h1 id="_idParaDest-138" class="calibre5"><a id="_idTextAnchor281" class="pcalibre pcalibre1 calibre6"/>Implementing a logger for security pipelines</h1>
			<p class="calibre3">Continuously monitoring automated<a id="_idIndexMarker635" class="pcalibre pcalibre1 calibre6"/><a id="_idIndexMarker636" class="pcalibre pcalibre1 calibre6"/> workflows is required to<a id="_idIndexMarker637" class="pcalibre pcalibre1 calibre6"/><a id="_idIndexMarker638" class="pcalibre pcalibre1 calibre6"/> detect errors and performance issues early. In this section, we’ll look at the necessity of implementing logging in our tools. Later, these logs can be utilized to monitor critical metrics, performance indicators, and system health in real time.</p>
			<p class="calibre3">Let’s implement a logger in our code:</p>
			<pre class="source-code">
  # Import necessary libraries
  import logging
  # Configure logging
  logging.basicConfig(filename='automation.log', level=logging.INFO)
  def main():
      # Configure logging
     logger = logging.getLogger(__name__)
     # Example usage     project_name = "Your Project"
     application_name = "Your Application"
     application_url = "https://your-application-url.com"
     webhook_url = "https://your-webhook-url.com"
     try:
         # Retrieve projects or create a new one
         projects = get_projects()
         project_id = projects.get(project_name)
         if not project_id:
             new_project = create_project(project_name)
             project_id = new_project["id"]
         # Create a new application under the project
         new_application = create_application(project_id, application_name, application_url)
         application_token = new_application["applicationToken"]
         # Verify domain ownership
         domain_verification_signature = verify_domain(application_token)
         # Start a security test
         test_start_response = start_test(application_token)
         result_token = test_start_response["resultToken"]
         # Send results to webhook
         webhook_status_code = send_results_to_webhook(application_token, result_token, webhook_url)
         logger.info(f"Webhook status code: {webhook_status_code}")     except Exception as e:
         logger.error(f"An error occurred: {e}", exc_info=True)
 if __name__ == "__main__":
     main()</pre>			<p class="calibre3">Let’s take a closer look at this code:</p>
			<ul class="calibre17">
				<li class="calibre16"><strong class="bold">Logging</strong>: We introduced logging to record events, errors, and status information during the execution of the automated workflow. Logging<a id="_idIndexMarker639" class="pcalibre pcalibre1 calibre6"/><a id="_idIndexMarker640" class="pcalibre pcalibre1 calibre6"/> ensures visibility into the workflow’s behavior and aids in troubleshooting and analysis.</li>
				<li class="calibre16"><strong class="bold">Error logging</strong>: We configured <a id="_idIndexMarker641" class="pcalibre pcalibre1 calibre6"/><a id="_idIndexMarker642" class="pcalibre pcalibre1 calibre6"/>the script so that it logs errors, including exceptions and traceback information, in the specified log file. This enables operators to identify and address issues effectively.</li>
				<li class="calibre16"><strong class="bold">Centralized monitoring</strong>: By centralizing logs in a dedicated log file (<strong class="source-inline1">automation.log</strong>), operators can easily monitor the script’s execution and identify any anomalies or failures.</li>
			</ul>
			<p class="calibre3">In this section, we implemented a logger for just one function. However, you can implement this logger for all the functions in the program. Later, these centralized logs can be used for monitoring, a process we can undertake by using the monitoring tools that will be explained in detail in later chapters.</p>
			<h1 id="_idParaDest-139" class="calibre5"><a id="_idTextAnchor282" class="pcalibre pcalibre1 calibre6"/><a id="_idTextAnchor283" class="pcalibre pcalibre1 calibre6"/><a id="_idTextAnchor284" class="pcalibre pcalibre1 calibre6"/>Summary</h1>
			<p class="calibre3">This chapter explored the use of Python and third-party tools to create automated security pipelines. We looked at how to use Python’s adaptability and third-party tools to automate several elements of security testing, such as vulnerability scanning and penetration testing. We discussed how Python can be integrated with popular third-party security solutions such as OWASP ZAP and Beagle Security’s API. We used various examples and code snippets to show how Python scripts may interact with these tools to automate processes such as vulnerability detection, compliance testing, and security assessment.</p>
			<p class="calibre3">Furthermore, we went over best practices for creating resilient and dependable automated security pipelines. We investigated solutions for handling errors, logging, and monitoring to ensure the resilience of our automated workflows.</p>
			<p class="calibre3">Overall, this chapter gave you a comprehensive understanding of how to leverage Python and third-party tools to automate and enhance your security processes while learning practical techniques for building and maintaining robust security pipelines, ensuring your applications are secure and resilient.</p>
			<p class="calibre3">The next chapter acts as a continuation of this chapter. There, you’ll learn how to design <a id="_idIndexMarker643" class="pcalibre pcalibre1 calibre6"/>security automation tools that are aligned with your requirements.</p>
		</div>
	</body></html>