<html><head></head><body><div><p>&#13;
			<h1 id="_idParaDest-141"><em class="italic"><a id="_idTextAnchor174"/>Chapter 10</em>: Developing Ghidra Plugins</h1>&#13;
			<p><a id="_idTextAnchor175"/>In this chapter, we will dig into the details of Ghidra plugin development, as introduced in <a href="B16207_04_Final_SK_ePub.xhtml#_idTextAnchor063"><em class="italic">Chapter 4</em></a>, <em class="italic">Using Ghidra Extensions</em>. Throughout this chapter, you will learn how to implement your own plugins in order to arbitrarily extend Ghidra's features.</p>&#13;
			<p>We will start by providing an overview of some existing plugins so that you can explore some ideas from other developers that may inspire you. Next, we will analyze the source code of the plugin skeleton included with Ghidra and available from Eclipse when creating a new plugin.</p>&#13;
			<p><a id="_idTextAnchor176"/><a id="_idTextAnchor177"/>Finally, we will review a Ghidra plugin example based on the skeleton mentioned previously. This will allow us to dig into the details of implementing a new GUI docking window by adding components and actions to it.</p>&#13;
			<p>In this chapter, we're going to cover the following topics:  </p>&#13;
			<ul>&#13;
				<li>Overview of existing plugins</li>&#13;
				<li>The Ghidra plugin skeleton</li>&#13;
				<li>Ghidra plugin development</li>&#13;
			</ul>&#13;
			<p>Let's get started!</p>&#13;
			<h1 id="_idParaDest-142"><a id="_idTextAnchor178"/>Technical requirements </h1>&#13;
			<p>The following are the technical requirements for this chapter:</p>&#13;
			<ul>&#13;
				<li>This book's GitHub repository, which contains all the necessary code for this chapter, at <a href="https://github.com/PacktPublishing/Ghidra-Software-Reverse-Engineering-for-Beginners/tree/master/Chapter10">https://github.com/PacktPublishing/Ghidra-Software-Reverse-Engineering-for-Beginners/tree/master/Chapter10</a>.</li>&#13;
				<li>Java JDK 11 for x86_64 (available here: <a href="https://adoptopenjdk.net/releases.html?variant=openjdk11&amp;jvmVariant=hotspot">https://adoptopenjdk.net/releases.html?variant=openjdk11&amp;jvmVariant=hotspot</a>).</li>&#13;
				<li>Eclipse IDE for Java developers (any version that supports JDK 11 that's available here: <a href="https://www.eclipse.org/downloads/packages/">https://www.eclipse.org/downloads/packages/</a>) since it is the IDE that's officially integrated and supported by Ghidra.</li>&#13;
				<li>Gradle, a build automation tool required for compiling Ghidra extensions (<a href="https://gradle.org/install/">https://gradle.org/install/</a>).</li>&#13;
				<li>PyDev 6.3.1 (available here: <a href="https://netix.dl.sourceforge.net/project/pydev/pydev/PyDev%206.3.1/PyDev%206.3.1.zip">https://netix.dl.sourceforge.net/project/pydev/pydev/PyDev%206.3.1/PyDev%206.3.1.zip</a>).</li>&#13;
			</ul>&#13;
			<p>Check out the following video to see the Code in Action: <a href="https://bit.ly/3gmDazk">https://bit.ly/3gmDazk</a></p>&#13;
			<h1 id="_idParaDest-143"><a id="_idTextAnchor179"/>Overview of existing plugins</h1>&#13;
			<p>As we <a id="_idIndexMarker352"/>saw in the <em class="italic">Analyzing the code of the Sample Table Provider plugin</em> section in <a href="B16207_04_Final_SK_ePub.xhtml#_idTextAnchor063"><em class="italic">Chapter 4</em></a>, <em class="italic">Using Ghidra Extensions</em>, a plugin extension is a Java program that extends from the <code>ghidra.app.plugin.ProgramPlugin</code> class, allowing us to handle the most common program events and implement GUI components.</p>&#13;
			<p>In this section, we will overview how Ghidra features are mostly implemented by plugins which can be easily found on the Ghidra repository. By analyzing an example we will understand the relation between the source code of an existing plugin and the Ghidra component that it implements.</p>&#13;
			<h2 id="_idParaDest-144"><a id="_idTextAnchor180"/>Plugins included with the Ghidra distribution</h2>&#13;
			<p>A lot of Ghidra <a id="_idIndexMarker353"/>features are implemented as plugins, so, in addition to the plugin examples that come with Ghidra and the ones available in the <code>ghidra_9.1.2\ Extensions\Ghidra</code> folder, you can also learn how to implement your own features by reviewing the source code of the program and/or reusing it.</p>&#13;
			<p>You can easily find plugins by looking for classes containing the string <code>extends ProgramPlugin</code> (<a href="https://github.com/NationalSecurityAgency/ghidra/search?p=1&amp;q=extends+ProgramPlugin&amp;unscoped_q=extends+ProgramPlugin">https://github.com/NationalSecurityAgency/ghidra/search?p=1&amp;q=extends+ProgramPlugin&amp;unscoped_q=extends+ProgramPlugin</a>), as shown in the following screenshot:</p>&#13;
			<p class="figure-caption">  </p>&#13;
			<div>&#13;
				<div>&#13;
					<img src="img/B16207_10_001.jpg" alt="Figure 10.1 – Looking for Ghidra features implemented as plugins&#13;&#10;"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption">Figure 10.1 – Looking for Ghidra features implemented as plugins</p>&#13;
			<p>As you can see, 70 plugins (of course, these search results include plugin examples) are part of Ghidra. A lot of <a id="_idIndexMarker354"/>the features that are available from Ghidra's GUI that you are already familiar with are implemented in this way. Remember that when you download a release version of Ghidra, the mentioned source code will be compiled in JAR files and distributed via compressed ZIP files named following the pattern: <code>*-src.zip</code>.</p>&#13;
			<p>For instance, you can locate the <code>ByteViewer</code> extension in the <code>ghidra_9.1.2\Features</code> folder distributed in both forms: compiled JAR file and source code. These are available in the <code>lib</code> directory of the module:</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B16207_10_002.jpg" alt="Figure 10.2 – ByteViewer extension file tree view – I&#13;&#10;"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption"> </p>&#13;
			<p class="figure-caption">Figure 10.2 – ByteViewer extension file tree view – I</p>&#13;
			<p>It is implemented as a Ghidra plugin extension located at <code>ghidra_9.1.2/Ghidra/Features/ByteViewer/src/main/java/ghidra/app/plugin/core/byteviewer/ByteViewerPlugin.java</code>, as shown in the following screenshot:</p>&#13;
			<p class="figure-caption">  </p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B16207_10_003.jpg" alt="Figure 10.3 – ByteViewer extension file tree view – II&#13;&#10;"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption">Figure 10.3 – ByteViewer extension file tree view – II</p>&#13;
			<p>This plugin <a id="_idIndexMarker355"/>implements an essential reverse engineering framework feature. The following screenshot shows the functionality provided by Ghidra's GUI mode when the <a href="B16207_04_Final_SK_ePub.xhtml#_idTextAnchor063"><em class="italic">Chapter 4</em></a>, <em class="italic">Using Ghidra Extensions</em>' <code>hello_world.exe</code> program is run:</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B16207_10_004.jpg" alt="Figure 10.4 – ByteViewer extension file tree view – III&#13;&#10;"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption"> </p>&#13;
			<p class="figure-caption">Figure 10.4 – ByteViewer extension file tree view – III</p>&#13;
			<p>By doing this, you <a id="_idIndexMarker356"/>can relate the GUI component to its source code, which allows you to modify it or reuse some code snippets when you're developing your own Ghidra plugins. </p>&#13;
			<h2 id="_idParaDest-145"><a id="_idTextAnchor181"/>Third-party plugins</h2>&#13;
			<p>In addition to the plugins <a id="_idIndexMarker357"/>that come with your Ghidra distribution, you can install third-party plugins from the internet. The following are some examples of useful third-party developed plugins:</p>&#13;
			<ul>&#13;
				<li><code>ret-sync</code> (<a href="https://github.com/bootleg/ret-sync">https://github.com/bootleg/ret-sync</a>): A Ghidra <a id="_idIndexMarker358"/>plugin extension that <a id="_idIndexMarker359"/>allows you to synchronize Ghidra with a lot of common debuggers, such as WinDbg, GDB, LLDB, OllyDbg, OllyDbg2, and x64dbg.</li>&#13;
				<li><code>gdbghidra</code> (<a href="https://github.com/Comsecuris/gdbghidra">https://github.com/Comsecuris/gdbghidra</a>): This <a id="_idIndexMarker360"/>plugin allows you to <a id="_idIndexMarker361"/>synchronize Ghidra with GDB, set breakpoints from Ghidra, show the register values on Ghidra while debugging, and more. Since Ghidra does not incorporate its own debugger, this Ghidra plugin extension can be very useful.</li>&#13;
				<li><code>OOAnalyzer</code> (<a href="https://github.com/cmu-sei/pharos/tree/master/tools/ooanalyzer/ghidra/OOAnalyzerPlugin">https://github.com/cmu-sei/pharos/tree/master/tools/ooanalyzer/ghidra/OOAnalyzerPlugin</a>): A plugin that <a id="_idIndexMarker362"/>allows you to import C++ object-oriented <a id="_idIndexMarker363"/>information provided by the OOAnalyzer component of the Pharos Static Binary Analysis Framework (https://github.com/cmu-sei/pharos/blob/master/tools/ooanalyzer/ooanalyzer.pod). This is extremely useful for reverse engineering C++ binary files.</li>&#13;
			</ul>&#13;
			<p>In the next section, we will provide an overview of the structure of the simplest Ghidra plugin: the plugin skeleton.</p>&#13;
			<h1 id="_idParaDest-146"><a id="_idTextAnchor182"/>The Ghidra plugin skeleton</h1>&#13;
			<p>As we <a id="_idIndexMarker364"/>explained in the <em class="italic">Deveeloping a Ghidra extension</em> section of <a href="B16207_04_Final_SK_ePub.xhtml#_idTextAnchor063"><em class="italic">Chapter 4</em></a>, <em class="italic">Using Ghidra Extensions</em>, by clicking on <strong class="bold">New</strong> | <strong class="bold">Ghidra Module Project…</strong>, you can <a id="_idIndexMarker365"/>create any kind of Ghidra extension by starting from a given skeleton.</p>&#13;
			<p>In this section, we will provide an overview of the Ghidra plugin extension skeleton in order to understand the basics that allow us to develop complex plugins.</p>&#13;
			<h2 id="_idParaDest-147"><a id="_idTextAnchor183"/>The plugin documentation</h2>&#13;
			<p>The first part of a <a id="_idIndexMarker366"/>plugin's skeleton is the documentation that describes the plugin. Its documentation contains four required fields (optionally, you can add some others):</p>&#13;
			<ul>&#13;
				<li>The status of the plugin, which can be one of four possible values: <code>HIDDEN</code>, <code>RELEASED</code>, <code>STABLE</code>, or <code>UNSTABLE</code>. (See line <code>01</code> of the following code).</li>&#13;
				<li>The package of the plugin (see line <code>02</code>).</li>&#13;
				<li>A short description of the plugin (see line <code>03</code>).</li>&#13;
				<li>A long description of the plugin (see line <code>04</code>).</li>&#13;
			</ul>&#13;
			<p>The following code is a plugin documentation skeleton that you can customize:</p>&#13;
			<pre>00  @PluginInfo(</pre>&#13;
			<pre>01    status = PluginStatus.STABLE,</pre>&#13;
			<pre>02    packageName = ExamplesPluginPackage.NAME,</pre>&#13;
			<pre>03    category = PluginCategoryNames.EXAMPLES,</pre>&#13;
			<pre>04    shortDescription = "Plugin short description.",</pre>&#13;
			<pre>05    description = "Plugin long description goes here."</pre>&#13;
			<pre>06  )</pre>&#13;
			<p class="callout-heading">PluginInfo documentation</p>&#13;
			<p class="callout">If you want to include optional <a id="_idIndexMarker367"/>description fields inside <code>PluginInfo</code>, check out the following link: https://ghidra.re/ghidra_docs/api/ghidra/framework/plugintool/PluginInfo.html.</p>&#13;
			<p>As shown in the <a id="_idIndexMarker368"/>following screenshot, the plugin's information is shown by Ghidra once the plugin has been installed and detected:</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B16207_10_005.jpg" alt="Figure 10.5 – Plugin configuration&#13;&#10;"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption"> </p>&#13;
			<p class="figure-caption">Figure 10.5 – Plugin configuration</p>&#13;
			<p>After installing <code>PluginInfo</code>, you can write the code for the plugin.</p>&#13;
			<h2 id="_idParaDest-148"><a id="_idTextAnchor184"/>Writing the plugin code</h2>&#13;
			<p>Plugins and their <a id="_idIndexMarker369"/>actions are managed by <code>PluginTool</code>, so, it is provided as a parameter to the plugin class. There are three important things in all Ghidra plugin source code:</p>&#13;
			<ul>&#13;
				<li><code>provider</code> (line <code>09</code>) implements the plugin's GUI. It can be permanent (closing the plugin only hides it) or transient (closing the plugin removes the plugin, such as when you're showing the results of a search).</li>&#13;
				<li>The constructor can customize <code>provider</code> and the plugin's help options.</li>&#13;
				<li>The <code>init()</code> method can be used to acquire services like <code>FileImporterService</code> or <code>GraphService</code>. Check the following link for a full list of documented services: https://ghidra.re/ghidra_docs/api/ghidra/app/services/package-.summary.html.</li>&#13;
			</ul>&#13;
			<p>The following code is the body of an extremely simple plugin example named <code>SkeletonPlugin</code>. Of course, the <code>MyProvider</code> class (line <code>09</code>), as we mentioned previously, is a plugin <code>provider</code> that implements the GUI of the plugin. We will explain this in detail later: </p>&#13;
			<pre>07  public class SkeletonPlugin extends ProgramPlugin {</pre>&#13;
			<pre>08</pre>&#13;
			<pre>09    MyProvider provider;</pre>&#13;
			<pre>10    public SkeletonPlugin (PluginTool tool) {</pre>&#13;
			<pre>11      super(tool, true, true);</pre>&#13;
			<pre>12</pre>&#13;
			<pre>13      // TODO: Customize provider (or remove if a provider</pre>&#13;
			<pre>14      //       is not desired)</pre>&#13;
			<pre>15      String pluginName = getName();</pre>&#13;
			<pre>16      provider = new MyProvider(this, pluginName);</pre>&#13;
			<pre>17</pre>&#13;
			<pre>18      // TODO: Customize help (or remove if help is not</pre>&#13;
			<pre>19      //       desired)</pre>&#13;
			<pre>20      String topicName = </pre>&#13;
			<pre>21                   this.getClass().getPackage().getName();</pre>&#13;
			<pre>22      String anchorName = "HelpAnchor";</pre>&#13;
			<pre>23      provider.setHelpLocation(new HelpLocation(</pre>&#13;
			<pre>24                                          topicName,</pre>&#13;
			<pre>25                                          anchorName)</pre>&#13;
			<pre>26      );</pre>&#13;
			<pre>27    }</pre>&#13;
			<pre>28</pre>&#13;
			<pre>29    @Override</pre>&#13;
			<pre>30    public void init() {</pre>&#13;
			<pre>31      super.init();</pre>&#13;
			<pre>32      // TODO: Acquire services if necessary</pre>&#13;
			<pre>33    }</pre>&#13;
			<pre>34  }</pre>&#13;
			<p>If you want to offer a <a id="_idIndexMarker370"/>GUI feature with your plugin, then you need to implement a provider. This can be developed using a separate Java file. In the next section, we will provide an overview of the structure of a Ghidra plugin provider.</p>&#13;
			<h2 id="_idParaDest-149"><a id="_idTextAnchor185"/>The provider for a plugin</h2>&#13;
			<p>The provider <a id="_idIndexMarker371"/>implements the GUI component of a plugin. It is usually stored in a separated file named <code>*Provider.java</code>, which consists of the following things:</p>&#13;
			<ul>&#13;
				<li>The constructor (lines <code>05-09</code>), which builds the panel and creates the required actions.</li>&#13;
				<li>The panel (lines <code>11-18</code>), which creates the GUI components and customizes them.</li>&#13;
				<li>The actions of the GUI (lines <code>21-43</code>), which are added using <code>addLocalAction(docking.action.DockingActionIf)</code>.</li>&#13;
				<li>A getter that lets us get the panel (lines <code>46-48</code>).</li>&#13;
			</ul>&#13;
			<p>The following code is the implementation for a custom plugin <code>provider</code>; that is, the one for the <code>MyProvider</code> class (used in line <code>09</code> of the preceding code):</p>&#13;
			<pre>00  private static class MyProvider extends ComponentProvider{</pre>&#13;
			<pre>01  </pre>&#13;
			<pre>02  		private JPanel panel;</pre>&#13;
			<pre>03  		private DockingAction action;</pre>&#13;
			<pre>04  </pre>&#13;
			<pre>05  		public MyProvider(Plugin plugin, String owner) {</pre>&#13;
			<pre>06  			super(plugin.getTool(), owner, owner);</pre>&#13;
			<pre>07  			buildPanel();</pre>&#13;
			<pre>08  			createActions();</pre>&#13;
			<pre>09  		}</pre>&#13;
			<pre>10  </pre>&#13;
			<pre>11  		// Customize GUI</pre>&#13;
			<pre>12  		private void buildPanel() {</pre>&#13;
			<pre>13  			panel = new JPanel(new BorderLayout());</pre>&#13;
			<pre>14  			JTextArea textArea = new JTextArea(5, 25);</pre>&#13;
			<pre>15  			textArea.setEditable(false);</pre>&#13;
			<pre>16  			panel.add(new JScrollPane(textArea));</pre>&#13;
			<pre>17  			setVisible(true);</pre>&#13;
			<pre>18  		}</pre>&#13;
			<pre>19  </pre>&#13;
			<pre>20  		// TODO: Customize actions</pre>&#13;
			<pre>21  		private void createActions() {</pre>&#13;
			<pre>22  			action = new DockingAction(</pre>&#13;
			<pre>23                                         "My Action", </pre>&#13;
			<pre>24                                         getName()) {</pre>&#13;
			<pre>25  				@Override</pre>&#13;
			<pre>26  				public void actionPerformed(</pre>&#13;
			<pre>27                                 ActionContext context) {</pre>&#13;
			<pre>28  					Msg.showInfo(</pre>&#13;
			<pre>29                               getClass(),</pre>&#13;
			<pre>30                               panel,</pre>&#13;
			<pre>31                               "Custom Action",</pre>&#13;
			<pre>32                               "Hello!"</pre>&#13;
			<pre>33                         );</pre>&#13;
			<pre>34  				}</pre>&#13;
			<pre>35  			};</pre>&#13;
			<pre>36  			action.setToolBarData(new ToolBarData(</pre>&#13;
			<pre>37                                           Icons.ADD_ICON,</pre>&#13;
			<pre>38                                           null)</pre>&#13;
			<pre>39              );</pre>&#13;
			<pre>40  			action.setEnabled(true);</pre>&#13;
			<pre>41  			action.markHelpUnnecessary();</pre>&#13;
			<pre>42  			dockingTool.addLocalAction(this, action);</pre>&#13;
			<pre>43  		}</pre>&#13;
			<pre>44  </pre>&#13;
			<pre>45  		@Override</pre>&#13;
			<pre>46  		public JComponent getComponent() {</pre>&#13;
			<pre>47  			return panel;</pre>&#13;
			<pre>48  		}</pre>&#13;
			<pre>49  	}</pre>&#13;
			<p class="callout-heading">The Provider Actions documentation</p>&#13;
			<p class="callout">You can learn more <a id="_idIndexMarker372"/>about the <code>addLocalAction</code> method (used in line <code>31</code> of the preceding code) at the following link: <a href="https://ghidra.re/ghidra_docs/api/docking/ComponentProvider.html#addLocalAction(docking.action.DockingActionIf">https://ghidra.re/ghidra_docs/api/docking/ComponentProvider.html#addLocalAction(docking.action.DockingActionIf</a>). You can learn more about Docking <a id="_idIndexMarker373"/>Actions by looking for the <code>DockingActionIf</code> interface known implementing classes at: <a href="https://ghidra.re/ghidra_docs/api/docking/action/DockingActionIf.html">https://ghidra.re/ghidra_docs/api/docking/action/DockingActionIf.html</a>.</p>&#13;
			<p>The <a id="_idIndexMarker374"/>following screenshot shows the result of executing this plugin, which you can do by going to <strong class="bold">Window</strong> | <strong class="bold">SkeletonPlugin</strong> via <strong class="bold">CodeBrowser</strong>, and clicking on the green cross button located at the top-right of the screen, which triggers the action (a message box appears once you've done this):</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B16207_10_006.jpg" alt="Figure 10.6 – Plugin configuration&#13;&#10;"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption"> </p>&#13;
			<p class="figure-caption">Figure 10.6 – Plugin configuration</p>&#13;
			<p>In the next section, we will learn how to implement a plugin using this skeleton as a reference.</p>&#13;
			<h1 id="_idParaDest-150"><a id="_idTextAnchor186"/>Developing a Ghidra plugin</h1>&#13;
			<p>In this section, we'll <a id="_idIndexMarker375"/>analyze how the <code>ShowInfoPlugin</code> Ghidra plugin example is implemented in order to understand how to develop a more complex plugin.</p>&#13;
			<p class="callout-heading">The source code for ShowInfoPlugin</p>&#13;
			<p class="callout">The source code for <code>ShowInfoPlugin</code> is available <a id="_idIndexMarker376"/>here: <a href="https://github.com/NationalSecurityAgency/ghidra/blob/49c2010b63b56c8f20845f3970fedd95d003b1e9/Ghidra/Extensions/sample/src/main/java/ghidra/examples/ShowInfoPlugin.java">https://github.com/NationalSecurityAgency/ghidra/blob/49c2010b63b56c8f20845f3970fedd95d003b1e9/Ghidra/Extensions/sample/src/main/java/ghidra/examples/ShowInfoPlugin.java</a>. The component provider used by this plugin is available in a separate file: <a href="https://github.com/NationalSecurityAgency/ghidra/blob/49c2010b63b56c8f20845f3970fedd95d003b1e9/Ghidra/Extensions/sample/src/main/java/ghidra/examples/ShowInfoComponentProvider.java">https://github.com/NationalSecurityAgency/ghidra/blob/49c2010b63b56c8f20845f3970fedd95d003b1e9/Ghidra/Extensions/sample/src/main/java/ghidra/examples/ShowInfoComponentProvider.java</a>.</p>&#13;
			<p>To implement a plugin, you need to master three key steps. Let's take a look at each!</p>&#13;
			<h2 id="_idParaDest-151"><a id="_idTextAnchor187"/>Documenting the plugin</h2>&#13;
			<p>To document a plugin, you <a id="_idIndexMarker377"/>must describe it using the <code>PluginInfo</code> structure:</p>&#13;
			<pre>00  @PluginInfo(</pre>&#13;
			<pre>01    status = PluginStatus.RELEASED,</pre>&#13;
			<pre>02    packageName = ExamplesPluginPackage.NAME,</pre>&#13;
			<pre>03    category = PluginCategoryNames.EXAMPLES,</pre>&#13;
			<pre>04    shortDescription = "Show Info",</pre>&#13;
			<pre>05    description = "Sample plugin demonstrating how to "</pre>&#13;
			<pre>06                + "access information from a program. "</pre>&#13;
			<pre>07                + "To see it work, use with the "</pre>&#13;
			<pre>08                + "CodeBrowser."</pre>&#13;
			<pre>09  )</pre>&#13;
			<p>As you can see, the documentation indicates that this is a release version of the plugin (line <code>01</code>). The package that the plugin belongs to is <code>ExamplesPluginPackage.NAME</code>, as established in line <code>02</code>. The plugin is classified in the <code>PluginCategoryNames.EXAMPLES</code> category to indicate that this is an example plugin. Finally, the <a id="_idIndexMarker378"/>plugin is described in both short (line <code>04</code>) and full (lines <code>05</code>-<code>08</code>).</p>&#13;
			<h2 id="_idParaDest-152"><a id="_idTextAnchor188"/>Implementing the plugin class</h2>&#13;
			<p>The plugin class is <a id="_idIndexMarker379"/>called <code>ShowInfoPlugin</code> and extends from <code>ProgramPlugin</code> (line <code>00</code>), as expected by Ghidra when you're developing a plugin extension. It declares a <code>ShowInfoComponentProvider</code> (for implementing the GUI of the plugin) named provider (line <code>02</code>) that is initialized inside the constructor of the class (line <code>06</code>). This, as usual, receives <code>PluginTool</code> as a parameter (line <code>04</code>).</p>&#13;
			<p>On the other hand, two of the methods provided by <code>ProgramPlugin</code> are overridden. The first method, <code>programDeactivated</code>, allows us to perform certain actions when the program becomes inactive – in this case, it lets us clear the provider (line <code>11</code>). The second method, <code>locationChanged</code>, allows us to act once we've received program location events. In this case, it passes the current program and the location to the provider's <code>locationChanged</code> method (line <code>19</code>). The body of the plugin looks as follows:</p>&#13;
			<pre>00  public class ShowInfoPlugin extends ProgramPlugin {</pre>&#13;
			<pre>01</pre>&#13;
			<pre>02    private ShowInfoComponentProvider provider;</pre>&#13;
			<pre>03</pre>&#13;
			<pre>04    public ShowInfoPlugin(PluginTool tool) {</pre>&#13;
			<pre>05      super(tool, true, false);</pre>&#13;
			<pre>06      provider = new ShowInfoComponentProvider(</pre>&#13;
			<pre>07                                               tool,</pre>&#13;
			<pre>08                                               getName()</pre>&#13;
			<pre>09      );</pre>&#13;
			<pre>10    }</pre>&#13;
			<pre>11</pre>&#13;
			<pre>12    @Override</pre>&#13;
			<pre>13    protected void programDeactivated(Program program) {</pre>&#13;
			<pre>14      provider.clear();</pre>&#13;
			<pre>15    }</pre>&#13;
			<pre>16</pre>&#13;
			<pre>17    @Override</pre>&#13;
			<pre>18    protected void locationChanged(ProgramLocation loc) {</pre>&#13;
			<pre>19      provider.locationChanged(currentProgram, loc);</pre>&#13;
			<pre>20    }</pre>&#13;
			<pre>21  }</pre>&#13;
			<p>As we <a id="_idIndexMarker380"/>mentioned previously, the preceding code declares a <code>ShowInfoComponentProvider</code> for implementing the plugin's GUI on line <code>02</code>. In the next section, we will cover the implementation of this class.</p>&#13;
			<h2 id="_idParaDest-153"><a id="_idTextAnchor189"/>Implementing the provider</h2>&#13;
			<p>As we mentioned <a id="_idIndexMarker381"/>previously, the provider consists of a class (in this case, <code>ShowInfoComponentProvider</code>) that extends from <code>ComponentProviderAdapter</code> (lines <code>00</code> and <code>01</code>) that implements the GUI of a Ghidra plugin and handles related events and actions. </p>&#13;
			<p>It starts by loading two image resources (lines <code>02</code> and <code>05</code>). The appropriate way to load resources in Ghidra is by using the resource manager (<a href="https://ghidra.re/ghidra_docs/api/resources/ResourceManager.html">https://ghidra.re/ghidra_docs/api/resources/ResourceManager.html</a>), as shown in the following code snippet:</p>&#13;
			<pre>00  public class ShowInfoComponentProvider extends </pre>&#13;
			<pre>01                                  ComponentProviderAdapter {</pre>&#13;
			<pre>02    private final static ImageIcon CLEAR_ICON = </pre>&#13;
			<pre>03        ResourceManager.loadImage("images/erase16.png");</pre>&#13;
			<pre>04    private final static ImageIcon INFO_ICON =</pre>&#13;
			<pre>05        ResourceManager.loadImage("images/information.png");</pre>&#13;
			<p>To implement <a id="_idIndexMarker382"/>the GUI, the <code>06</code>) and a text area component (line <code>07</code>).</p>&#13;
			<p>A <code>DockingAction</code> (line <code>08</code>) associating a user action with a toolbar icon and/or menu item (<a href="https://ghidra.re/ghidra_docs/api/docking/action/DockingAction.html">https://ghidra.re/ghidra_docs/api/docking/action/DockingAction.html</a>) is also defined here. Finally, two <a id="_idIndexMarker383"/>attributes are also declared for accessing the current location (line <code>09</code>) of the current program (line <code>10</code>). </p>&#13;
			<p>The following code corresponds to the aforementioned provider attributes:</p>&#13;
			<pre>06    private JPanel panel;</pre>&#13;
			<pre>07    private JTextArea textArea;</pre>&#13;
			<pre>08    private DockingAction clearAction;</pre>&#13;
			<pre>09    private Program currentProgram;</pre>&#13;
			<pre>10    private ProgramLocation currentLocation;  </pre>&#13;
			<p>Next, the class constructor creates the GUI by calling the <code>create()</code> function declared on lines <code>13</code> and <code>55</code>. It sets some provider attributes, including the provider icon (line <code>14</code>), the default window position (line <code>15</code>), and its title (<code>16</code>) before setting the provider to visible on line <code>17</code>. It also creates the <code>DockingActions</code> call to the <code>createActions()</code> function that's defined on line <code>18</code> and implemented on line <code>62</code>:</p>&#13;
			<pre>11    public ShowInfoComponentProvider(</pre>&#13;
			<pre>                                       PluginTool tool,</pre>&#13;
			<pre>                                       String name) {</pre>&#13;
			<pre>12      super(tool, name, name);</pre>&#13;
			<pre>13      create();</pre>&#13;
			<pre>14      setIcon(INFO_ICON);</pre>&#13;
			<pre>15      setDefaultWindowPosition(WindowPosition.BOTTOM);</pre>&#13;
			<pre>16      setTitle("Show Info");</pre>&#13;
			<pre>17      setVisible(true);</pre>&#13;
			<pre>18      createActions();</pre>&#13;
			<pre>19    } </pre>&#13;
			<p>Since the <code>getComponent()</code> (line <code>21</code>) function of a component provider returns the component to be displayed, it returns <code>panel</code> (line <code>22</code>), which contains the GUI components:</p>&#13;
			<pre>20    @Override</pre>&#13;
			<pre>21    public JComponent getComponent() {</pre>&#13;
			<pre>22      return panel;</pre>&#13;
			<pre>23    }</pre>&#13;
			<p>The <code>clear</code> function clears the <a id="_idIndexMarker384"/>current program and current location by setting it to <code>null</code> (lines <code>25</code> and <code>26</code>) and clears the text of the text area component (line <code>27</code>):</p>&#13;
			<pre>24    void clear() {</pre>&#13;
			<pre>25      currentProgram = null;</pre>&#13;
			<pre>26      currentLocation = null;</pre>&#13;
			<pre>27      textArea.setText("");</pre>&#13;
			<pre>28    }  </pre>&#13;
			<p>When the location of the program changes, its location information is updated (lines <code>33</code> and <code>34</code>). Not only does it change the program and its new location, but it also updates the program's information by calling the <code>updateInfo()</code> function (line <code>36</code>), which is implemented on line <code>33</code>. This is the main feature of this plugin:</p>&#13;
			<pre>29    void locationChanged(</pre>&#13;
			<pre>30                         Program program,</pre>&#13;
			<pre>31                         ProgramLocation location</pre>&#13;
			<pre>32                         ) {</pre>&#13;
			<pre>33      this.currentProgram = program;</pre>&#13;
			<pre>34      this.currentLocation = location;</pre>&#13;
			<pre>35      if (isVisible()) {</pre>&#13;
			<pre>36        updateInfo();</pre>&#13;
			<pre>37      }</pre>&#13;
			<pre>38    }  </pre>&#13;
			<p>The <code>updateInfo()</code> function starts checking whether it can access the address of the current location (line <code>34</code>). If this is not possible, then it returns.</p>&#13;
			<p>In this case, the <code>updateInfo()</code> function obtains <code>CodeUnit</code> (<a href="https://ghidra.re/ghidra_docs/api/ghidra/program/model/listing/CodeUnit.html">https://ghidra.re/ghidra_docs/api/ghidra/program/model/listing/CodeUnit.html</a>) from the current location address of the listing of the program (<a href="https://ghidra.re/ghidra_docs/api/ghidra/program/model/listing/Listing.html">https://ghidra.re/ghidra_docs/api/ghidra/program/model/listing/Listing.html</a>) by using the <code>getCodeUnitContaining</code> function (line <code>46</code>). Finally, it shows the <code>CodeUnit</code> string representation (line <code>52</code>) for prepending a substring, which indicates whether the current <code>CodeUnit</code> is an instruction (lines <code>55</code>-<code>57</code>), a defined piece of data (lines <code>58</code>-<code>62</code>), or an undefined <a id="_idIndexMarker385"/>piece of data (lines <code>63</code>-<code>65</code>):</p>&#13;
			<pre>39    private void updateInfo() {</pre>&#13;
			<pre>40      if (currentLocation == null || </pre>&#13;
			<pre>41          currentLocation.getAddress() == null) {</pre>&#13;
			<pre>42        return;</pre>&#13;
			<pre>43      }</pre>&#13;
			<pre>44  </pre>&#13;
			<pre>45      CodeUnit cu = </pre>&#13;
			<pre>46         currentProgram.getListing().getCodeUnitContaining(</pre>&#13;
			<pre>47                          currentLocation.getAddress()</pre>&#13;
			<pre>48      );</pre>&#13;
			<pre>49  </pre>&#13;
			<pre>50      // TODO -- create the string to set</pre>&#13;
			<pre>51      String preview = </pre>&#13;
			<pre>52             CodeUnitFormat.DEFAULT.getRepresentationString(</pre>&#13;
			<pre>53                                                  cu, true</pre>&#13;
			<pre>54      );</pre>&#13;
			<pre>55      if (cu instanceof Instruction) {</pre>&#13;
			<pre>56        textArea.setText("Instruction: " + preview);</pre>&#13;
			<pre>57      }</pre>&#13;
			<pre>58      else {</pre>&#13;
			<pre>59        Data data = (Data) cu;</pre>&#13;
			<pre>60        if (data.isDefined()) {</pre>&#13;
			<pre>61          textArea.setText("Defined Data: " + preview);</pre>&#13;
			<pre>62        }</pre>&#13;
			<pre>63        else {</pre>&#13;
			<pre>64          textArea.setText("Undefined Data: " + preview);</pre>&#13;
			<pre>65        }</pre>&#13;
			<pre>66      }</pre>&#13;
			<pre>67    }  </pre>&#13;
			<p>The <code>create()</code> method creates a new panel containing <code>BorderLayout</code> (line <code>69</code>). This allows us to put GUI components on any of the four borders of the panel, as well as in the center of it.</p>&#13;
			<p>Then, it creates a non-editable text area that's 5 rows and 25 columns in size (lines <code>70</code>-<code>71</code>) with scroll <a id="_idIndexMarker386"/>capabilities (line <code>72</code>) and attaches it to the panel (line <code>73</code>):</p>&#13;
			<pre>68    private void create() {</pre>&#13;
			<pre>69      panel = new JPanel(new BorderLayout());</pre>&#13;
			<pre>70      textArea = new JTextArea(5, 25);</pre>&#13;
			<pre>71      textArea.setEditable(false);</pre>&#13;
			<pre>72      JScrollPane sp = new JScrollPane(textArea);</pre>&#13;
			<pre>73      panel.add(sp);</pre>&#13;
			<pre>74    }  </pre>&#13;
			<p>Finally, the <code>createActions()</code> function creates a <code>DockingAction</code> to clear the text area (you can locate it on line <code>76</code> of the following code snippet).</p>&#13;
			<p>In the following screenshot, you can see how the implementation of <code>createActions()</code>produces a GUI button that allows us to trigger the <strong class="bold">Clear Text Area</strong> action:</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B16207_10_007.jpg" alt="Figure 10.7 – Docking Action – Clear Text Area&#13;&#10;"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption"> </p>&#13;
			<p class="figure-caption">Figure 10.7 – Docking Action – Clear Text Area</p>&#13;
			<p>The <code>createActions()</code> function also overrides the <code>actionPerformed()</code> function (<a href="https://ghidra.re/ghidra_docs/api/ghidra/app/context/ListingContextAction.html#actionPerformed(docking.ActionContext">https://ghidra.re/ghidra_docs/api/ghidra/app/context/ListingContextAction.html#actionPerformed(docking.ActionContext</a>) with the implementation of the clearing action (line <code>82</code>). It also establishes a link between the action's logic and the GUI by preparing the toolbar icon of the action (lines <code>85</code>-<code>87</code>), setting it to enabled (line <code>89</code>), and adding it to the current tool (line <code>90</code>):</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B16207_10_008.jpg" alt="Figure 10.8 – ShowInfo plugin extension available from CodeBrowser's Window menu option&#13;&#10;"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption"> </p>&#13;
			<p class="figure-caption">Figure 10.8 – ShowInfo plugin extension available from CodeBrowser's Window menu option</p>&#13;
			<p>When the GUI component is shown (line <code>94</code>), it immediately populates the text area with the corresponding <code>CodeUnit</code> information (line <code>95</code>):</p>&#13;
			<pre>75    private void createActions() {</pre>&#13;
			<pre>76      clearAction = new DockingAction(</pre>&#13;
			<pre>77                                      "Clear Text Area",</pre>&#13;
			<pre>78                                      getName()</pre>&#13;
			<pre>79                                      ) {</pre>&#13;
			<pre>80        @Override</pre>&#13;
			<pre>81        public void actionPerformed(ActionContext context) {</pre>&#13;
			<pre>82          textArea.setText("");</pre>&#13;
			<pre>83        }</pre>&#13;
			<pre>84      };</pre>&#13;
			<pre>85      clearAction.setToolBarData(new ToolBarData(CLEAR_ICON, </pre>&#13;
			<pre>86                                                 null)</pre>&#13;
			<pre>87      );</pre>&#13;
			<pre>88  </pre>&#13;
			<pre>89      clearAction.setEnabled(true);</pre>&#13;
			<pre>90      tool.addLocalAction(this, clearAction);</pre>&#13;
			<pre>91    }</pre>&#13;
			<pre>92  </pre>&#13;
			<pre>93    @Override</pre>&#13;
			<pre>94    public void componentShown() {</pre>&#13;
			<pre>95      updateInfo();</pre>&#13;
			<pre>96    }</pre>&#13;
			<pre>97  }</pre>&#13;
			<p>Here, we learned how to <a id="_idIndexMarker387"/>implement a simple <a id="_idTextAnchor190"/>plugin provider. If you are interested in implementing more complex GUI extensions, it is highly recommended that you learn more about the <strong class="bold">Swing widget toolkit</strong>. For learning about it, please, check the online documentation (<a href="https://docs.oracle.com/javase/7/docs/api/javax/swing/package-summary.html">https://docs.oracle.com/javase/7/docs/api/javax/swing/package-summary.html</a>) or refer to <em class="italic">Further reading</em> section located at the end of this chapter.</p>&#13;
			<h1 id="_idParaDest-154"><a id="_idTextAnchor191"/>Summary</h1>&#13;
			<p>In this chapter, we learned how to incorporate both official and third-party extensions for Ghidra. This new skill allowed us to mitigate Ghidra's drawback of not including a debugger. We performed a search over Ghidra's source code to discover that a lot of Ghidra's core features are implemented as Ghidra plugins. Finally, we learned how to extend Ghidra with our own ideas, access the program being analyzed by it, implement custom GUI socking windows, and add actions to it.</p>&#13;
			<p>In the next chapter, we will learn how to incorporate support for new binary formats in Ghidra. This skill will be very valuable to you because it will enable you to reverse-engineer exoteric binary files using Ghidra.</p>&#13;
			<h1 id="_idParaDest-155"><a id="_idTextAnchor192"/>Questions</h1>&#13;
			<ol>&#13;
				<li>Ghidra plugin extensions are implemented in the Java language. Is Ghidra fully implemented using Java?</li>&#13;
				<li>How can you add external debugging synchronization to Ghidra?</li>&#13;
				<li>What is a provider in the context of Ghidra plugin development?</li>&#13;
			</ol>&#13;
			<h1 id="_idParaDest-156"><a id="_idTextAnchor193"/>Further reading</h1>&#13;
			<p>Please refer to the following links for more information on the topics that were covered in this chapter:</p>&#13;
			<ul>&#13;
				<li><em class="italic">From 0 to 1: JavaFX and Swing for Awesome Java UIs</em> [Video]: <a href="https://www.packtpub.com/product/from-0-to-1-javafx-and-swing-for-awesome-java-uis-video/9781789132496">https://www.packtpub.com/product/from-0-to-1-javafx-and-swing-for-awesome-java-uis-video/9781789132496</a></li>&#13;
				<li><em class="italic">Swing Extreme Testing</em>, <em class="italic">Lindsay Peters, Tim Lavers</em>, <em class="italic">June 2008</em>: <a href="https://www.packtpub.com/product/swing-extreme-testing/9781847194824">https://www.packtpub.com/product/swing-extreme-testing/9781847194824</a></li>&#13;
				<li><em class="italic">Java 9 Cookbook</em>, <em class="italic">Mohamed Sanaulla, Nick Samoylov</em>, <em class="italic">August 2017</em>: <a href="https://www.packtpub.com/product/java-9-cookbook/9781786461407">https://www.packtpub.com/product/java-9-cookbook/9781786461407</a> </li>&#13;
			</ul>&#13;
		</div>&#13;
	</div></body></html>