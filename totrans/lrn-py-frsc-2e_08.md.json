["```\npip install pillow==5.3.0\n```", "```\n>>> from PIL import Image \n>>> image = Image.open('img_42.jpg') \n>>> exif = image._getexif() \n>>> if 271 in exif.keys(): \n...     print('Make:', exif[271]) \n...  \nMake: Nokia\n```", "```\npip install mutagen==1.41.1 \n```", "```\n>>> from mutagen import id3 \n>>> id = id3.ID3('music.mp3') \n>>> if 'TP1' in id.keys(): \n...     print('Artist:', id['TP1']) \n... \nArtist: The Artist \n```", "```\npip install lxml==4.2.5 \n```", "```\n>>> import lxml.etree.ElementTree as ET \n>>> core = ET.parse('core.xml') \n>>> root = core.getroot() \n>>> for child in root.iter(): \n...     print(child.tag, ':', child.text) \n...  \n{http://purl.org/dc/elements/1.1/}title : Metadata Title \n{http://purl.org/dc/elements/1.1/}subject : Digital Forensics \n{http://purl.org/dc/elements/1.1/}creator : Preston Miller & Chapin Bryce \n... \n```", "```\n  |-- metadata_parser.py \n  |-- plugins \n      |-- __init__.py \n      |-- exif_parser.py \n      |-- id3_parser.py \n      |-- office_parser.py \n  |-- processors \n      |-- __init__.py \n      |-- utility.py \n  |-- writers \n      |-- __init__.py \n      |-- csv_writer.py \n      |-- kml_writer.py \n```", "```\n001 \"\"\"EXIF, ID3, and Office Metadata parser.\"\"\"\n002 from __future__ import print_function\n003 import argparse\n004 import os\n005 import sys\n006 import logging\n007 \n008 import plugins\n009 import writers\n...\n045 def main(input_dir, output_dir):\n```", "```\n131 if __name__ == '__main__':\n132 \n133     parser = argparse.ArgumentParser(description=__description__,\n134                                 epilog='Developed by ' +\n135                                 __author__ + ' on ' +\n136                                 __date__)\n137     parser.add_argument('INPUT_DIR', help='Input Directory')\n138     parser.add_argument('OUTPUT_DIR', help='Output Directory')\n139     parser.add_argument('-l', help='File path of log file.')\n140     args = parser.parse_args()\n141 \n142     if args.l:\n143         if not os.path.exists(args.l):\n144             os.makedirs(args.l)\n145         log_path = os.path.join(args.l, 'metadata_parser.log')\n146     else:\n147         log_path = 'metadata_parser.log'\n148     logging.basicConfig(filename=log_path, level=logging.DEBUG,\n149                         format=('%(asctime)s | %(levelname)s | '\n150                         '%(message)s'), filemode='a')\n151 \n152     logging.info('Starting Metadata_Parser')\n153     logging.debug('System ' + sys.platform)\n154     logging.debug('Version ' + sys.version) \n```", "```\n156     if not os.path.exists(args.OUTPUT_DIR):\n157         os.makedirs(args.OUTPUT_DIR)\n158 \n159     if(os.path.exists(args.INPUT_DIR) and\n160     os.path.isdir(args.INPUT_DIR)):\n161         main(args.INPUT_DIR, args.OUTPUT_DIR)\n162     else:\n163         msg =('Supplied input directory doesn't exist or is'\n164         'not a directory')\n165         print('[-]', msg)\n166         logging.error(msg)\n167         sys.exit(1)\n```", "```\n045 def main(input_dir, output_dir):\n046     \"\"\"\n047     The main function generates a file listing, sends files to be\n048     processed, and output written.\n049     :param input_dir: The input directory to scan for suported\n050         embedded metadata containing files\n051     :param output_dir: The output directory to write metadata\n052         reports to\n053     :return: Nothing.\n054     \"\"\"\n055     # Create lists to store each supported embedded metadata\n056     # before writing to output\n057     exif_metadata = []\n058     office_metadata = []\n059     id3_metadata = []\n060 \n061     # Walk through list of files\n062     msg = 'Generating file listing and running plugins.'\n063     print('[+]', msg)\n064     logging.info(msg)\n065     for root, subdir, files in os.walk(input_dir, topdown=True):\n066         for file_name in files:\n067             current_file = os.path.join(root, file_name)\n068             ext = os.path.splitext(current_file)[1].lower() \n```", "```\n>>> '/path/to/metadata_image.jpg'.split('.')[-1] \njpg \n```", "```\n070             # PLUGINS\n071             if ext == '.jpeg' or ext == '.jpg':\n072                 try:\n073                     ex_metadata, exif_headers = plugins.exif_parser.exif_parser(\n074                     current_file)\n075                     exif_metadata.append(ex_metadata)\n076                 except TypeError:\n077                     print(('[-] File signature mismatch. '\n078                         'Continuing to next file.'))\n079                     logging.error((('JPG & TIFF File Signature '\n080                     'check failed for ' + current_file)))\n081                     continue\n```", "```\n083             elif ext == '.docx' or ext == '.pptx' or ext == '.xlsx':\n084                 try:\n085                     of_metadata, office_headers = plugins.office_parser.office_parser(\n086                     current_file)\n087                     office_metadata.append(of_metadata)\n088                 except TypeError:\n089                     print(('[-] File signature mismatch. '\n090                         'Continuing to next file.'))\n091                     logging.error((('DOCX, XLSX, & PPTX File '\n092                     'Signature check failed for ' + current_file))\n093                     )\n094                     continue\n095 \n096             elif ext == '.mp3':\n097                 try:\n098                     id_metadata, id3_headers = plugins.id3_parser.id3_parser(\n099                     current_file)\n100                     id3_metadata.append(id_metadata)\n101                     except TypeError:\n102                         print(('[-] File signature mismatch. '\n103                             'Continuing to next file.'))\n104                         logging.error((('MP3 File Signature check '\n105                             'failed for ' + current_file)))\n106                         continue\n```", "```\n108     # WRITERS\n109     msg = 'Writing output to ' + output_dir\n110     print('[+]', msg)\n111     logging.info(msg)\n112 \n113     if len(exif_metadata) > 0:\n114         writers.kml_writer.kml_writer(exif_metadata,\n115             output_dir, 'exif_metadata.kml')\n116         writers.csv_writer.csv_writer(exif_metadata, exif_headers,\n117             output_dir, 'exif_metadata.csv')\n118 \n119     if len(office_metadata) > 0:\n120         writers.csv_writer.csv_writer(office_metadata,\n121             office_headers, output_dir, 'office_metadata.csv')\n122 \n123     if len(id3_metadata) > 0:\n124         writers.csv_writer.csv_writer(id3_metadata, id3_headers,\n125             output_dir, 'id3_metadata.csv')\n126 \n127     msg = 'Program completed successfully -- exiting..'\n128     print('[*]', msg)\n129     logging.info(msg)\n```", "```\n001 from datetime import datetime\n002 import os\n003 from time import gmtime, strftime\n004 \n005 from PIL import Image\n006 \n007 import processors\n...\n039 def exif_parser(): \n... \n062 def get_tags(): \n... \n172 def dms_to_decimal(): \n```", "```\n039 def exif_parser(filename):\n040     \"\"\"\n041     The exif_parser function confirms the file type and sends it\n042     to be processed.\n043     :param filename: name of the file potentially containing EXIF\n044     metadata.\n045     :return: A dictionary from get_tags, containing the embedded\n046     EXIF metadata.\n047     \"\"\"\n```", "```\n049     # JPEG signatures\n050     signatures = ['ffd8ffdb','ffd8ffe0', 'ffd8ffe1', 'ffd8ffe2',\n051         'ffd8ffe3', 'ffd8ffe8']\n052     if processors.utility.check_header(\n053             filename,signatures, 4) == True:\n054         return get_tags(filename)\n055     else:\n056         print(('File signature doesn't match known '\n057             'JPEG signatures.'))\n058         raise TypeError(('File signature doesn't match ' \n059             'JPEG object.'))\n```", "```\n062 def get_tags(filename):\n063     \"\"\"\n064     The get_tags function extracts the EXIF metadata from the data\n065     object.\n066     :param filename: the path and name to the data object.\n067     :return: tags and headers, tags is a dictionary containing\n068     EXIF metadata and headers are the order of keys for the\n069     CSV output.\n070     \"\"\"\n071     # Set up CSV headers\n072     headers = ['Path', 'Name', 'Size', 'Filesystem CTime',\n073     'Filesystem MTime', 'Original Date', 'Digitized Date', 'Make',\n074     'Model', 'Software', 'Latitude', 'Latitude Reference',\n075     'Longitude', 'Longitude Reference', 'Exif Version', 'Height',\n076     'Width', 'Flash', 'Scene Type']\n```", "```\n077     image = Image.open(filename)\n078 \n079     # Detects if the file is corrupt without decoding the data\n080     image.verify()\n081 \n082     # Descriptions and values of EXIF tags\n083     # http://www.exiv2.org/tags.html\n084     exif = image._getexif()\n```", "```\n086     tags = {}\n087     tags['Path'] = filename\n088     tags['Name'] = os.path.basename(filename)\n089     tags['Size'] = processors.utility.convert_size(\n090         os.path.getsize(filename))\n091     tags['Filesystem CTime'] = strftime('%m/%d/%Y %H:%M:%S',\n092         gmtime(os.path.getctime(filename)))\n093     tags['Filesystem MTime'] = strftime('%m/%d/%Y %H:%M:%S',\n094         gmtime(os.path.getmtime(filename)))\n```", "```\n2015:11:11 10:32:15\n```", "```\n095     if exif:\n096         for tag in exif.keys():\n097             if tag == 36864:\n098                 tags['Exif Version'] = exif[tag]\n099             elif tag == 36867:\n100                 dt = datetime.strptime(exif[tag],\n101                 '%Y:%m:%d %H:%M:%S')\n102                 tags['Original Date'] = dt.strftime(\n103                 '%m/%d/%Y %H:%M:%S')\n104             elif tag == 36868:\n105                 dt = datetime.strptime(exif[tag],\n106                 '%Y:%m:%d %H:%M:%S')\n107                 tags['Digitized Date'] = dt.strftime(\n108                 '%m/%d/%Y %H:%M:%S')\n```", "```\n109             elif tag == 41990:\n110                 # Scene tags\n111                 # http://www.awaresystems.be/imaging/tiff/tifftags/privateifd/exif/scenecapturetype.html\n112                 scenes = {0: 'Standard', 1: 'Landscape',\n113                 2: 'Portrait', 3: 'Night Scene'}\n114                 if exif[tag] in scenes:\n115                     tags['Scene Type'] = scenes[exif[tag]]\n116                 else:\n117                     pass\n118             elif tag == 37385:\n119                 # Flash tags\n120                 # http://www.awaresystems.be/imaging/tiff/tifftags/privateifd/exif/flash.html\n121                 flash = {0: 'Flash did not fire',\n122                 1: 'Flash fired',\n123                 5: 'Strobe return light not detected',\n124                 7: 'Strobe return light detected',\n125                 9: 'Flash fired, compulsory flash mode',\n126                 13: 'Flash fired, compulsory flash mode, return light not detected',\n127                 15: 'Flash fired, compulsory flash mode, return light detected',\n128                 16: 'Flash did not fire, compulsory flash mode',\n129                 24: 'Flash did not fire, auto mode',\n130                 25: 'Flash fired, auto mode',\n131                 29: 'Flash fired, auto mode, return light not detected',\n132                 31: 'Flash fired, auto mode, return light detected',\n133                 32: 'No flash function',\n134                 65: 'Flash fired, red-eye reduction mode',\n135                 69: 'Flash fired, red-eye reduction mode, return light not detected',\n136                 71: 'Flash fired, red-eye reduction mode, return light detected',\n137                 73: 'Flash fired, compulsory flash mode, red-eye reduction mode',\n138                 77: 'Flash fired, compulsory flash mode, red-eye reduction mode, return light not detected',\n139                 79: 'Flash fired, compulsory flash mode, red-eye reduction mode, return light detected',\n140                 89: 'Flash fired, auto mode, red-eye reduction mode',\n141                 93: 'Flash fired, auto mode, return light not detected, red-eye reduction mode',\n142                 95: 'Flash fired, auto mode, return light detected, red-eye reduction mode'}\n143                 if exif[tag] in flash:\n144                     tags['Flash'] = flash[exif[tag]]\n145             elif tag == 271:\n146                 tags['Make'] = exif[tag]\n147             elif tag == 272:\n148                 tags['Model'] = exif[tag]\n149             elif tag == 305:\n150                 tags['Software'] = exif[tag]\n151             elif tag == 40962:\n152                 tags['Width'] = exif[tag]\n153             elif tag == 40963:\n154                 tags['Height'] = exif[tag]\n```", "```\n155             elif tag == 34853:\n156                 for gps in exif[tag]:\n157                     if gps == 1:\n158                         tags['Latitude Reference'] = exif[tag][gps]\n159                     elif gps == 2:\n160                         tags['Latitude'] = dms_to_decimal(\n161                         exif[tag][gps])\n162                     elif gps == 3:\n163                         tags['Longitude Reference'] = exif[tag][gps]\n164                     elif gps == 4:\n165                         tags['Longitude'] = dms_to_decimal(\n166                         exif[tag][gps])\n167                     else:\n168                         pass\n169     return tags, headers\n```", "```\n172 def dms_to_decimal(dms):\n173     \"\"\"\n174     Converts GPS Degree Minute Seconds format to Decimal format.\n175     :param dms: The GPS data in Degree Minute Seconds format.\n176     :return: The decimal formatted GPS coordinate.\n177     \"\"\"\n178     deg, min, sec = [x[0] for x in dms]\n179     if deg > 0:\n180         return \"{0:.5f}\".format(deg + (min / 60.) + (\n181             sec / 3600000.))\n182     else:\n183         return \"{0:.5f}\".format(deg - (min / 60.) - (\n184             sec / 3600000.))\n```", "```\n001 import os\n002 from time import gmtime, strftime\n003 \n004 from mutagen import mp3, id3\n005 \n006 import processors\n..   \n037 def id3_parser(): \n... \n059 def get_tags(): \n```", "```\n037 def id3_parser(filename):\n038     \"\"\"\n039     The id3_parser function confirms the file type and sends it to\n040     be processed.\n041     :param filename: name of the file potentially containing exif\n042     metadata.\n043     :return: A dictionary from get_tags, containing the embedded\n044     EXIF metadata.\n045     \"\"\"\n```", "```\n047     # MP3 signatures\n048     signatures = ['494433']\n049     if processors.utility.check_header(\n050     filename, signatures, 3) == True:\n051         return get_tags(filename)\n052     else:\n053         print(('File signature doesn't match known '\n054         'MP3 signatures.'))\n055         raise TypeError(('File signature doesn't match ' \n056         'MP3 object.')) \n```", "```\n059 def get_tags(filename):\n060     \"\"\"\n061     The get_tags function extracts the ID3 metadata from the data\n062     object.\n063     :param filename: the path and name to the data object.\n064     :return: tags and headers, tags is a dictionary containing ID3\n065     metadata and headers are the order of keys for the CSV output.\n066     \"\"\"\n067 \n068     # Set up CSV headers\n069     header = ['Path', 'Name', 'Size', 'Filesystem CTime',\n070     'Filesystem MTime', 'Title', 'Subtitle', 'Artist', 'Album',\n071     'Album/Artist', 'Length (Sec)', 'Year', 'Category',\n072     'Track Number', 'Comments', 'Publisher', 'Bitrate',\n073     'Sample Rate', 'Encoding', 'Channels', 'Audio Layer']\n```", "```\n074     tags = {}\n075     tags['Path'] = filename\n076     tags['Name'] = os.path.basename(filename)\n077     tags['Size'] = processors.utility.convert_size(\n078         os.path.getsize(filename))\n079     tags['Filesystem CTime'] = strftime('%m/%d/%Y %H:%M:%S',\n080         gmtime(os.path.getctime(filename)))\n081     tags['Filesystem MTime'] = strftime('%m/%d/%Y %H:%M:%S',\n082         gmtime(os.path.getmtime(filename)))\n```", "```\n084     # MP3 Specific metadata\n085     audio = mp3.MP3(filename)\n086     if 'TENC' in audio.keys():\n087         tags['Encoding'] = audio['TENC'][0]\n088         tags['Bitrate'] = audio.info.bitrate\n089         tags['Channels'] = audio.info.channels\n090         tags['Audio Layer'] = audio.info.layer\n091         tags['Length (Sec)'] = audio.info.length\n092         tags['Sample Rate'] = audio.info.sample_rate \n```", "```\n{'TPE1': TPE1(encoding=0, text=[u'The Artist']),...} \n```", "```\n094     # ID3 embedded metadata tags\n095     id = id3.ID3(filename)\n096     if 'TPE1' in id.keys():\n097         tags['Artist'] = id['TPE1'][0]\n098     if 'TRCK' in id.keys():\n099         tags['Track Number'] = id['TRCK'][0]\n100     if 'TIT3' in id.keys():\n101         tags['Subtitle'] = id['TIT3'][0]\n102     if 'COMM::eng' in id.keys():\n103         tags['Comments'] = id['COMM::eng'][0]\n104     if 'TDRC' in id.keys():\n105         tags['Year'] = id['TDRC'][0]\n106     if 'TALB' in id.keys():\n107         tags['Album'] = id['TALB'][0]\n108     if 'TIT2' in id.keys():\n109         tags['Title'] = id['TIT2'][0]\n110     if 'TCON' in id.keys():\n111         tags['Category'] = id['TCON'][0]\n112     if 'TPE2' in id.keys():\n113         tags['Album/Artist'] = id['TPE2'][0]\n114     if 'TPUB' in id.keys():\n115         tags['Publisher'] = id['TPUB'][0]\n116 \n117     return tags, header\n```", "```\n001 import zipfile\n002 import os\n003 from time import gmtime, strftime\n004 \n005 from lxml import etree\n006 import processors\n...   \n037 def office_parser(): \n...\n059 def get_tags(): \n```", "```\n037 def office_parser(filename):\n038     \"\"\"\n039     The office_parser function confirms the file type and sends it\n040     to be processed.\n041     :param filename: name of the file potentially containing\n042     embedded metadata.\n043     :return: A dictionary from get_tags, containing the embedded\n044     metadata.\n045     \"\"\"\n046 \n047     # DOCX, XLSX, and PPTX signatures\n048     signatures = ['504b030414000600']\n049     if processors.utility.check_header(\n050     filename, signatures, 8) == True:\n051         return get_tags(filename)\n052     else:\n053         print(('File signature doesn't match known '\n054         'signatures.'))\n055         raise TypeError(('File signature doesn't match ' \n056         'Office objects.'))\n```", "```\n059 def get_tags(filename):\n060     \"\"\"\n061     The get_tags function extracts the office metadata from the\n062     data object.\n063     :param filename: the path and name to the data object.\n064     :return: tags and headers, tags is a dictionary containing\n065     office metadata and headers are the order of keys for the CSV\n066     output.\n067     \"\"\"\n068 \n069     # Set up CSV headers\n070     headers = ['Path', 'Name', 'Size', 'Filesystem CTime',\n071     'Filesystem MTime', 'Title', 'Author(s)','Create Date',\n072     'Modify Date', 'Last Modified By Date', 'Subject', 'Keywords',\n073     'Description', 'Category', 'Status', 'Revision',\n074     'Edit Time (Min)', 'Page Count', 'Word Count',\n075     'Character Count', 'Line Count',\n076     'Paragraph Count', 'Slide Count', 'Note Count',\n077     'Hidden Slide Count', 'Company', 'Hyperlink Base']\n078 \n079     # Create a ZipFile class from the input object\n080     # This allows us to read or write to the 'Zip archive'\n081     zf = zipfile.ZipFile(filename)\n```", "```\n083     # These two XML files contain the embedded metadata of\n084     # interest\n085     try:\n086         core = etree.fromstring(zf.read('docProps/core.xml'))\n087         app = etree.fromstring(zf.read('docProps/app.xml'))\n088     except KeyError as e:\n089         assert Warning(e)\n090         return {}, headers\n```", "```\n092     tags = {}\n093     tags['Path'] = filename\n094     tags['Name'] = os.path.basename(filename)\n095     tags['Size'] = processors.utility.convert_size(\n096         os.path.getsize(filename))\n097     tags['Filesystem CTime'] = strftime('%m/%d/%Y %H:%M:%S',\n098         gmtime(os.path.getctime(filename)))\n099     tags['Filesystem MTime'] = strftime('%m/%d/%Y %H:%M:%S',\n100         gmtime(os.path.getmtime(filename)))\n```", "```\n102     # Core Tags\n103 \n104     for child in core.iterchildren():\n105 \n106         if 'title' in child.tag:\n107             tags['Title'] = child.text\n108         if 'subject' in child.tag:\n109             tags['Subject'] = child.text\n110         if 'creator' in child.tag:\n111             tags['Author(s)'] = child.text\n112         if 'keywords' in child.tag:\n113             tags['Keywords'] = child.text\n114         if 'description' in child.tag:\n115             tags['Description'] = child.text\n116         if 'lastModifiedBy' in child.tag:\n117             tags['Last Modified By Date'] = child.text\n118         if 'created' in child.tag:\n119             tags['Create Date'] = child.text\n120         if 'modified' in child.tag:\n121             tags['Modify Date'] = child.text\n122         if 'category' in child.tag:\n123             tags['Category'] = child.text\n124         if 'contentStatus' in child.tag:\n125             tags['Status'] = child.text\n126 \n127         if (filename.endswith('.docx') or\n128         filename.endswith('.pptx')):\n129             if 'revision' in child.tag:\n130                 tags['Revision'] = child.text\n```", "```\n132     # App Tags\n133     for child in app.iterchildren():\n134 \n135         if filename.endswith('.docx'):\n136             if 'TotalTime' in child.tag:\n137                 tags['Edit Time (Min)'] = child.text\n138             if 'Pages' in child.tag:\n139                 tags['Page Count'] = child.text\n140             if 'Words' in child.tag:\n141                 tags['Word Count'] = child.text\n142             if 'Characters' in child.tag:\n143                 tags['Character Count'] = child.text\n144             if 'Lines' in child.tag:\n145                 tags['Line Count'] = child.text\n146             if 'Paragraphs' in child.tag:\n147                 tags['Paragraph Count'] = child.text\n148             if 'Company' in child.tag:\n149                 tags['Company'] = child.text\n150             if 'HyperlinkBase' in child.tag:\n151                 tags['Hyperlink Base'] = child.text\n152 \n153         elif filename.endswith('.pptx'):\n154             if 'TotalTime' in child.tag:\n155                 tags['Edit Time (Min)'] = child.text\n156             if 'Words' in child.tag:\n157                 tags['Word Count'] = child.text\n158             if 'Paragraphs' in child.tag:\n159                 tags['Paragraph Count'] = child.text\n160             if 'Slides' in child.tag:\n161                 tags['Slide Count'] = child.text\n162             if 'Notes' in child.tag:\n163                 tags['Note Count'] = child.text\n164             if 'HiddenSlides' in child.tag:\n165                 tags['Hidden Slide Count'] = child.text\n166             if 'Company' in child.tag:\n167                 tags['Company'] = child.text\n168             if 'HyperlinkBase' in child.tag:\n169                 tags['Hyperlink Base'] = child.text\n170         else:\n171             if 'Company' in child.tag:\n172                 tags['Company'] = child.text\n173             if 'HyperlinkBase' in child.tag:\n174                 tags['Hyperlink Base'] = child.text\n175 \n176     return tags, headers\n```", "```\n001 from __future__ import print_function\n002 import sys\n003 import os\n004 if sys.version_info[0] == 2:\n005     import unicodecsv as csv\n006 elif sys.version_info[0] == 3:\n007     import csv\n008 import logging\n...\n040 def csv_writer(output_data, headers, output_dir, output_name):\n041     \"\"\"\n042     The csv_writer function uses the csv DictWriter module to\n043     write the list of dictionaries. The DictWriter can take\n044     a fieldnames argument, as a list, which represents the\n045     desired order of columns.\n046     :param output_data: The list of dictionaries containing\n047     embedded metadata.\n048     :param headers: A list of keys in the dictionary that\n049     represent the desired order of columns in the output.\n050     :param output_dir: The folder to write the output CSV to.\n051     :param output_name: The name of the output CSV.\n052     :return:\n053     \"\"\"\n054     msg = 'Writing ' + output_name + ' CSV output.'\n055     print('[+]', msg)\n056     logging.info(msg)\n057\n058     out_file = os.path.join(output_dir, output_name)\n059 \n060     if sys.version_info[0] == 2:\n061         csvfile = open(out_file, \"wb\")\n062     elif sys.version_info[0] == 3:\n063         csvfile = open(out_file, \"w\", newline='',\n064             encoding='utf-8')\n```", "```\n066     with csvfile:\n067         # We use DictWriter instead of Writer to write\n068         # dictionaries to CSV.\n069         writer = csv.DictWriter(csvfile, fieldnames=headers)\n070 \n071         # Writerheader writes the header based on the supplied\n072         # headers object\n073         writer.writeheader()\n074         for dictionary in output_data:\n075             if dictionary:\n076                 writer.writerow(dictionary)\n```", "```\npip install simplekml==1.3.1\n```", "```\n001 from __future__ import print_function\n002 import os\n003 import logging\n004 \n005 import simplekml\n...\n036 def kml_writer(output_data, output_dir, output_name):\n037     \"\"\"\n038     The kml_writer function writes JPEG and TIFF EXIF GPS data to\n039     a Google Earth KML file. This file can be opened\n040     in Google Earth and will use the GPS coordinates to create\n041     'pins' on the map of the taken photo's location.\n042     :param output_data: The embedded EXIF metadata to be written\n043     :param output_dir: The output directory to write the KML file.\n044     :param output_name: The name of the output KML file.\n045     :return:\n046     \"\"\"\n```", "```\n047     msg = 'Writing ' + output_name + ' KML output.'\n048     print('[+]', msg)\n049     logging.info(msg)\n050     # Instantiate a Kml object and pass along the output filename\n051     kml = simplekml.Kml(name=output_name)\n052     for exif in output_data:\n053         if ('Latitude' in exif.keys() and\n054                 'Latitude Reference' in exif.keys() and\n055                 'Longitude Reference' in exif.keys() and\n056                 'Longitude' in exif.keys()):\n057 \n058             if 'Original Date' in exif.keys():\n059                 dt = exif['Original Date']\n060             else:\n061                 dt = 'N/A'\n062 \n063             if exif['Latitude Reference'] == 'S':\n064                 latitude = '-' + exif['Latitude']\n065             else:\n066                 latitude = exif['Latitude']\n067 \n068             if exif['Longitude Reference'] == 'W':\n069                 longitude = '-' + exif['Longitude']\n070             else:\n071                 longitude = exif['Longitude']\n```", "```\n073             kml.newpoint(name=exif['Name'],\n074             description='Originally Created: ' + dt,\n075             coords=[(longitude, latitude)])\n076         else:\n077             pass\n078     kml.save(os.path.join(output_dir, output_name))\n```", "```\n001 import binascii\n002 import logging\n...\n033 def check_header(filename, headers, size):\n034     \"\"\"\n035     The check_header function reads a supplied size of the file\n036     and checks against known signatures to determine the file\n037     type.\n038     :param filename: The name of the file.\n039     :param headers: A list of known file signatures for the\n040     file type(s).\n041     :param size: The amount of data to read from the file for\n042     signature verification.\n043     :return: Boolean, True if the signatures match;\n044     otherwise, False.\n045     \"\"\"\n```", "```\n046     with open(filename, 'rb') as infile:\n047         header = infile.read(size)\n048         hex_header = binascii.hexlify(header).decode('utf-8')\n049         for signature in headers:\n050             if hex_header == signature:\n051                 return True\n052             else:\n053                 pass\n054         logging.warn(('The signature for {} ({}) doesn't match '\n055             'known signatures: {}').format(\n056                 filename, hex_header, headers))\n057         return False\n```", "```\n059 def convert_size(size):\n060     \"\"\"\n061     The convert_size function converts an integer representing\n062     bytes into a human-readable format.\n063     :param size: The size in bytes of a file\n064     :return: The human-readable size.\n065     \"\"\"\n066     sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB']\n```", "```\n067     index = 0\n068     while size > 1024:\n069         size /= 1024.\n070         index += 1\n071     return '{:.2f} {}'.format(size, sizes[index])\n```"]