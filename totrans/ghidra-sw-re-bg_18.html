<html><head></head><body><div><p>&#13;
			<h1 id="_idParaDest-208"><a id="_idTextAnchor260"/>Assessments</h1>&#13;
			<h1 id="_idParaDest-209"><a id="_idTextAnchor261"/>Chapter 1</h1>&#13;
			<ol>&#13;
				<li>No one reverse engineering framework is the ultimate. Each reverse engineering framework has its own strengths and weaknesses. We can mention some current Ghidra strengths when comparing Ghidra with most other reverse engineering frameworks:<p>- It is open source and free (including its decompiler).</p><p>- It supports a lot of architectures (it may be the framework you are using is not supported yet).</p><p>- It can load multiple binaries at the same time in a project. This feature allows you to easily apply operations over many related binaries (for example, an executable binary and its libraries).</p><p>- It allows collaborative reverse engineering by design.</p><p>- It supports big firmware images (1 GB +) without problems.</p><p>- It has awesome documentation, which includes examples and courses.</p><p>- It allows version tracking of binaries allowing the matching of functions and data and their markup between different versions of the binary.</p><p>But we can also mention an important weakness:</p><p>- Ghidra Python scripting relies on Jython (a Java implementation of Python) and it currently doesn't support Python 3. Since Python 2.x is currently deprecated, this is a significant weakness of Ghidra.</p></li>&#13;
				<li>The bar located in the upper-right margin of the disassembly window allows you to customize the disassembly view: <div><img src="img/image_00_001.jpg" alt="Disassembly listing configuration&#13;&#10;"/></p><p class="figure-caption"> </p><p class="figure-caption">Disassembly listing configuration</p><p>By right-clicking on the <strong class="bold">PCode</strong> field, PCode will appear in the disassembly listing:</p><div><img src="img/image_00_002.jpg" alt="Enable the PCode field in disassembly&#13;&#10;"/></div><p class="figure-caption">Enable the PCode field in disassembly</p><p>The following figure shows the resulting disassembly listing after enabling the <strong class="bold">PCode</strong> field: </p><div><img src="img/image_00_003.jpg" alt="Disassembly listing with PCode enabled&#13;&#10;"/></div><p class="figure-caption">Disassembly listing with PCode enabled</p><p>As you can see in the screenshot, for each assembly instruction, one or more PCode instructions are generated.</p></li>&#13;
				<li>The disassembly view is a view of the instructions using the language of the processor while the decompiler view shows pseudo-C decompiled code: <div><img src="img/image_00_004.jpg" alt="Comparing disassembled with decompiled code&#13;&#10;"/></div></li>&#13;
			</ol>&#13;
			<p class="figure-caption"> </p>&#13;
			<p class="figure-caption">Comparing disassembled with decompiled code</p>&#13;
			<p>In the preceding screenshot, you can see a disassembly view in the left margin showing the same code as the decompiled view located in the right margin.</p>&#13;
			<h1 id="_idParaDest-210"><a id="_idTextAnchor262"/>Chapter 2</h1>&#13;
			<ol>&#13;
				<li value="1">Ghidra scripts are useful because they can be used to automatize reverse engineering tasks.<p>Some tasks that you can automatize using Ghidra scripts are the following:</p><p>- Searching for strings and code patterns</p><p>- Automatically deobfuscating code</p><p>- Adding useful comments to enrich the dissasembly</p></li>&#13;
				<li>Scripts are organized by category, as shown on the left-hand side of the following screenshot:<div><img src="img/image_00_005.jpg" alt="Script Manager&#13;&#10;"/></div><p class="figure-caption">Script Manager</p><p>When clicking on the checklist icon located in the upper-right margin, as shown in the preceding screenshot taken from the Script Manager window, the paths of script directories will be shown:</p><div><img src="img/image_00_006.jpg" alt="Script Directories&#13;&#10;"/></div><p class="figure-caption"> </p><p class="figure-caption">Script Directories</p><p>But the organization of the scripts in the Script Manager is taken from the <code>@category</code> field located in the header of the script code, as shown in the following listing:</p><p class="source-code">//TODO write a description for this script //@author <strong class="bold">//@category Strings</strong>&#13;
//@keybinding //@menupath //@toolbar </p><p>Notice that the previous script header is a Python header, but an analogous header is used when writing JavaScript for Ghidra.</p></li>&#13;
				<li>Ghidra is written in the Java language (of course, the decompiler is not; it is written in the C++ programming language), so the API of Ghidra is exposed in Java. It is the same in Python because the Python API consists of a Java bridge powered by Jython, a Java implementation of Python.</li>&#13;
			</ol>&#13;
			<h1 id="_idParaDest-211"><a id="_idTextAnchor263"/>Chapter 3</h1>&#13;
			<ol>&#13;
				<li value="1">Yes. ZIP files containing the source code are attached to the same folder that the JAR file you want to debug exists in. To link the source code with the JAR file using the Eclipse IDE, right-click on the JAR file and then enter the ZIP file in the Workspace location field of the Java Source Attachment section as shown in the following screenshot:<div><img src="img/image_00_007.jpg" alt="Linking to Graph.jar file with its own source code&#13;&#10;"/></div><p class="figure-caption"> </p><p class="figure-caption">Linking to Graph.jar file with its own source code</p><p>After that, you will be able to expand the JAR file, showing included <code>*.class</code> files.</p></li>&#13;
				<li>Yes, it is possible, as demonstrated in the following blog post: <p><a href="https://reversing.technology/2019/11/18/ghidra-dev-pt1.html">https://reversing.technology/2019/11/18/ghidra-dev-pt1.html</a></p><p>But remember that the Eclipse IDE is the only one officially supported by Ghidra.</p></li>&#13;
				<li>Some vulnerabilities were found in Ghidra but those and any other ones are probably not NSA backdoors into the program. The NSA has its own zero-day exploits to hack computers and, for sure, doesn't need to introduce backdoors into its own programs to hack the computers of people around the world. In fact, to do so would be a terrible move in terms of reputation.</li>&#13;
			</ol>&#13;
			<h1 id="_idParaDest-212"><a id="_idTextAnchor264"/>Chapter 4</h1>&#13;
			<ol>&#13;
				<li value="1">A Ghidra extension is code that extends Ghidra with new features while scripts are code for assisting the reverse engineering process by automating tasks.</li>&#13;
				<li>Since this task consists of analyzing the code and improving it, you will need to write or incorporate a new Ghidra Analyzer extension in order to extend the analysis capabilities of Ghidra.</li>&#13;
				<li>As explained in the first question for this chapter, Ghidra scripts and Ghidra extensions have different purposes so use Ghidra scripts to automate reverse engineering tasks applied over the disassembly listing and use Ghidra extensions if you want to extend or improve Ghidra with new features.</li>&#13;
			</ol>&#13;
			<h1 id="_idParaDest-213"><a id="_idTextAnchor265"/>Chapter 5</h1>&#13;
			<ol>&#13;
				<li value="1">Imports leak the capabilities of malware taken from dynamic linking libraries, including operating system libraries, which enables communication for the malware with the outside. Sometimes the malware dynamically loads dynamic linking libraries (via the LoadLibrary API) and dynamically imports functions (via the <code>GetProcAddress</code> API), so you will not see the full set of imported libraries during a static analysis without further analysis than opening the binary with Ghidra and looking for the imports.</li>&#13;
				<li>Yes. You can use a Ghidra analyzer to extract object-oriented information from the disassembly (for example, objects, methods, and so on) and improve the disassembly listing using this information. Or, use a Ghidra analyzer to enrich the disassembly listing with object-oriented information obtained from a third-party source.</li>&#13;
				<li>There are a lot of benefits to it:<p>- Bypass firewall rules if the application the code is injected into has associated firewall rules that are less restrictive than the original process.</p><p>- To be more stealthy, it is better to inject into a legitimate process than creating a new process.</p><p>This list includes some general reasons but the whole list would be extensive.</p></li>&#13;
			</ol>&#13;
			<h1 id="_idParaDest-214"><a id="_idTextAnchor266"/>Chapter 6</h1>&#13;
			<ol>&#13;
				<li value="1">The appropriate Ghidra API function to set a byte at a given memory address is <code>setByte</code>.<p>I followed these steps to reach this Ghidra Flat API function:</p><p>1. I checked the Ghidra Flat API reference provided in <a href="B16207_06_Final_SK_ePub.xhtml#_idTextAnchor108"><em class="italic">Chapter 6</em></a>, <em class="italic">Scripting Malware Analysis</em>.</p><p>2. I located the set of Ghidra Flat API functions of interest: <code>setByte</code>.</p><p>4. I checked the online documentation of the function to confirm that it was the function I was looking for:<a href="https://ghidra.re/ghidra_docs/api/ghidra/program/database/mem/MemoryMapDB.html#setByte(ghidra.program.model.address.Address,byte">https://ghidra.re/ghidra_docs/api/ghidra/program/database/mem/MemoryMapDB.html#setByte(ghidra.program.model.address.Address,byte</a>).</p><p>5. The description matched my needs: <strong class="bold">Write byte at addr</strong>. So, we can use it for that.</p></li>&#13;
				<li>Ghidra is written in the Java programming language and this is why this language is the most supported (of course, the decompiler is not; it is written in the C++ programming language) so the API of Ghidra is naturally exposed in Java.The Java API is better than the Python API because the Python API is a bridge to the Java API implemented by Jython, a Java implementation of Python.So, issues with Jython could happen, which doesn't happen with Java. Let's pick a random issue to demonstrate this: <a href="https://github.com/NationalSecurityAgency/ghidra/issues/2369">https://github.com/NationalSecurityAgency/ghidra/issues/2369</a>.<p>Or look for Jython issues on your own following this link: <a href="https://github.com/NationalSecurityAgency/ghidra/search?q=jython&amp;type=issues">https://github.com/NationalSecurityAgency/ghidra/search?q=jython&amp;type=issues</a>.</p></li>&#13;
				<li>Yes. By using Ghidra scripts, you can compute values that are calculated at runtime and enrich the disassembly with it.</li>&#13;
			</ol>&#13;
			<h1 id="_idParaDest-215"><a id="_idTextAnchor267"/>Chapter 7</h1>&#13;
			<ol>&#13;
				<li value="1">You can execute headed scripts in headless mode only if those scripts don't make use of GUI APIs and vice versa. You can execute headless mode scripts in Ghidra headed mode only if those scripts don't make use of functions proper of headless, otherwise, an exception will be thrown. </li>&#13;
				<li>Ghidra headed mode is useful to perform a visual and mostly manual analysis of the binary by analyzing the graph, improving it, reading the disassembly listing, and so on. On the other hand, headless mode is adequate to perform automatic analysis or apply a script over a set of binaries.</li>&#13;
				<li>The difference is that <code>grep</code> or <code>strings</code> will return any matching string found in the binary while Ghidra will return matching strings recognized by the analyzer. So, for instance, you will also be able to identify references to it in the disassembly listing and spurious strings won't will be taken into account by Ghidra.</li>&#13;
			</ol>&#13;
			<h1 id="_idParaDest-216"><a id="_idTextAnchor268"/>Chapter 8</h1>&#13;
			<ol>&#13;
				<li value="1">No, memory corruption is a type of software vulnerability but many more exist. For instance, race condition vulnerabilities:<p>- <code>free()</code> twice on the same memory address, potentially leading to the modification of unexpected memory locations.</p></li>&#13;
				<li>It is considered unsafe because the size of the destination buffer where the source buffer will be copied is not taken into account, so it can easily lead to a buffer overflow.</li>&#13;
				<li>The three usual binary protection methods are as follows:<p>- <strong class="bold">Stack canaries</strong>: In this method we put a precomputed value (the canary) before the return address such that the return address cannot be overwritten without overwriting that value first. The integrity of the canary can be checked after returning from the function.</p><p>- <strong class="bold">DEP (Data Execution Prevention) / NX (do not execute)</strong>: Makes the stack non-executable, so the attacker cannot simply execute the shellcode on the stack.</p><p>- <strong class="bold">ASLR (Address Space Layout Randomization)/PIE (Position-Independent Executable)</strong>: Randomizes the location where system executables are loaded into memory, so the attacker cannot easily know where exactly to redirect the flow of the program if hijacked.</p><p>Yes, it is sometimes possible to bypass all the methods mentioned to achieve code execution.</p></li>&#13;
			</ol>&#13;
			<h1 id="_idParaDest-217"><a id="_idTextAnchor269"/>Chapter 9</h1>&#13;
			<ol>&#13;
				<li value="1">SLEIGH is a processor specification language that formally describes the translation from the bit encoding of machine instructions, for a particular processor, to human-readable assembly language and into PCode.<p>On the other hand, PCode is an <strong class="bold">intermediate representation</strong> <strong class="bold">(IR)</strong> that can be translated into the assembly instructions of a specific processor. Being more precise, it is a <strong class="bold">register transfer language</strong> <strong class="bold">(RTL)</strong>. PCode is used to describe data flow at the register-transfer level of an architecture.</p></li>&#13;
				<li>No, it isn't.<p>PCode is useful because it can be translated into a large set of different assembly languages. In practice, if you develop a tool for Pcode, you automatically support a lot of architectures. Furthermore, PCode offers more granularity than assembly language (one assembly instruction is translated into one or more PCode instructions) so you can control side-effects better. This property is very useful when developing some kinds of tools.</p></li>&#13;
			</ol>&#13;
			<h1 id="_idParaDest-218"><a id="_idTextAnchor270"/>Chapter 10</h1>&#13;
			<ol>&#13;
				<li value="1">Ghidra is mostly implemented in the Java language but, of course, the decompiler was implemented in the C++ language.</li>&#13;
				<li>You can use a Ghidra plugin for that. For instance, you can install the following available plugins, allowing debugging synchronization:<p>- <strong class="bold">GDBGhidra</strong>: <a href="https://github.com/Comsecuris/gdbghidra">https://github.com/Comsecuris/gdbghidra</a></p><p>- <strong class="bold">ret-sync (Reverse-Engineering Tools SYNChronization)</strong>: <a href="https://github.com/bootleg/ret-sync">https://github.com/bootleg/ret-sync</a></p></li>&#13;
				<li>A provider is Java code implementing the Ghidra plugin <strong class="bold">Graphical User Interface (GUI)</strong>.</li>&#13;
			</ol>&#13;
			<h1 id="_idParaDest-219"><a id="_idTextAnchor271"/>Chapter 11</h1>&#13;
			<ol>&#13;
				<li value="1">A raw binary is a file that contains unprocessed data, so it has no format in any way while formatted binaries are binary files following a format specification such that they can be parsed, for instance, by Ghidra.</li>&#13;
				<li>If the file being analyzed follows a format specification, it is much more comfortable to let the loader automatically define the bytes as code or strings, create symbols, and so on. When dealing with raw binaries you will need to manually process the data. Therefore, it is much more confortable for a reverse engineer to deal with formatted binaries when possible rather than raw binaries.</li>&#13;
				<li>Old-style DOS executable is the format for MS-DOS executable binaries. The Ghidra loader for old-style DOS executable files is developed by the following pieces of software:<p>- <code>DOSHeader.java</code>: A Java file implementing the old-style DOS executable parser.</p><p>- <code>OldStyleExecutable.java</code>: A class that uses <code>FactoryBundledWithBinaryReader</code> to read data from a generic byte provider and passes it to the <code>DOSHeader</code> class in order to parse it. The <code>OldStyleExecutable</code> class exposes both via getter methods: <code>DOSHeader</code> and the underlying <code>FactoryBundledWithBinaryReader</code> object.</p></li>&#13;
			</ol>&#13;
			<h1 id="_idParaDest-220"><a id="_idTextAnchor272"/>Chapter 12</h1>&#13;
			<ol>&#13;
				<li value="1">A processor module adds support for a processor using the SLEIGH processor specification language while an analyzer module is Java code for extending Ghidra code analysis in order to identify functions, detect parameters when calling a function, and so on.</li>&#13;
				<li>Yes. Tags indicating the possible start of a function or a code boundary are relative to the patterns being declared.</li>&#13;
				<li>A language refers to a microprocessor architecture. Since a microprocessor architecture embraces a family of instruction set architectures, the term language variant means each one of those instruction set architectures belonging to the same microprocessor architecture.</li>&#13;
			</ol>&#13;
			<h1 id="_idParaDest-221"><a id="_idTextAnchor273"/>Chapter 13</h1>&#13;
			<ol>&#13;
				<li value="1">No. Ghidra is an open source project and you can join the community whenever you wish. You can join it by simply creating a Ghidra account and going to the following URL:<p><a href="https://github.com/NationalSecurityAgency/ghidra/">https://github.com/NationalSecurityAgency/ghidra/</a></p></li>&#13;
				<li>You can interact with them, for instance, via GitHub by writing comments, proposing pull requests to Ghidra with your own code, and much more: <a href="https://github.com/NationalSecurityAgency/ghidra/">https://github.com/NationalSecurityAgency/ghidra/</a>.<p>There are several chat links you can follow to chat with other members:</p><p>- Telegram: <a href="https://t.me/GhidraREandhttps://t.me/GhidraRE_dev">https://t.me/GhidraREandhttps://t.me/GhidraRE_dev</a></p><p>- Matrix: <a href="https://riot.im/app/#/group/+ghidra:matrix.org">https://riot.im/app/#/group/+ghidra:matrix.org</a></p><p>- Discord: <a href="https://discord.com/invite/S4tQnUB">https://discord.com/invite/S4tQnUB</a></p></li>&#13;
			</ol>&#13;
			<h1 id="_idParaDest-222"><a id="_idTextAnchor274"/>Chapter 14</h1>&#13;
			<ol>&#13;
				<li value="1">Concrete execution means running a program using concrete values (for example, the <code>eax</code> register takes the value 5) while symbolic execution runs the program using symbolic values that can be expressed using <code>eax</code> register is a vector of 32 bits whose value, at this moment, is less than 5).</li>&#13;
				<li>No, it can't. It is not possible to perform symbolic execution in an efficient way for general cases.</li>&#13;
				<li>Yes. You can extend Ghidra to apply symbolic and/or concolic execution to binary files.</li>&#13;
			</ol>&#13;
		</div>&#13;
	</div></body></html>