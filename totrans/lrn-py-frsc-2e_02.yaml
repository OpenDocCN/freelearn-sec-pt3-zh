- en: Python Fundamentals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have explored the basic concepts behind Python and fundamental elements used
    to construct scripts. We will now build a series of scripts throughout this book
    using the data types and built-in functions that we have discussed in the first
    chapter. Before we begin developing scripts, let's walk through some additional
    important features of the Python language, building upon our existing knowledge.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will explore more advanced features that we will utilize
    when building our forensic Python scripts. This includes complex data types and
    functions, creating our first script, handling errors, using libraries, interacting
    with the user, and some best practices for development. After completing this
    chapter, we will be ready to dive into real-world examples featuring the utility
    of Python in forensic casework.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Advanced features, including iterators and `datetime` objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing and using modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Error handling with `try`, `except`, and `raise` statements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sanity checking and accessing user-supplied data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating forensic scripts to find USB vendor and product information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advanced data types and functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section highlights two common features, iterators and `datetime` objects,
    of Python that we will frequently encounter in forensic scripts. Therefore, we
    will introduce these objects and functionality in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Iterators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You previously learned about several iterable objects, such as `lists`, `sets`,
    and `tuples`. In Python, a data type is considered an iterator if an `__iter__` method
    is defined or if elements can be accessed in a sequenced manner. These three data
    types (that is, `lists`, `sets`, and `tuples`) allow us to iterate through their
    contents in a simple and efficient manner. For this reason, we often use these
    data types when iterating through the lines in a file or through file entries
    within a directory listing, or when trying to identify a file based on a series
    of file signatures.
  prefs: []
  type: TYPE_NORMAL
- en: The `iter` data type allows us to step through data in a manner that doesn't
    preserve the initial object. This seems undesirable; however, when working with
    large sets or on machines with limited resources, it is very useful. This is due
    to the resource allocation associated with the `iter` data type, where only active
    data is stored in memory. This preserves memory allocation when stepping through
    every line of a 3 GB file by feeding one line at a time and preventing massive
    memory consumption while still handling each line in order.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code block mentioned here steps through the basic usage of iterables. We
    use the `next()` function on an iterable to retrieve the next element. Once an
    object is accessed using `next()`, it is no longer available in `iter()`, as the
    cursor has moved past the element. If we have reached the end of the iterable
    object, we will receive `StopIteration` for any additional `next()` method calls.
    This exception allows us to gracefully exit loops with an iterator and alerts
    us to when we are out of content to read from the iterator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In Python 2.7, you can use the `obj.next()` method call to get the same output
    as the preceding example via use of the `next()` function. For simplicity and
    uniformity, Python 3 renamed `obj.next()` to `obj.__next__()` and encourages the
    use of the `next()` function. With this, it is recommended to use `next(y)`, as
    shown previously, in place of `y.next()` or `y.__next__()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `reversed()` built-in function can be used to create a reversed iterator.
    In the following example, we reverse a list and retrieve the following object
    from the iterator using the `next()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: By implementing generators, we can further take advantage of the `iter` data
    type. Generators are a special type of function that produces iterator objects.
    Generators are similar to functions, as those discussed in [Chapter 1](8764f55f-76ef-4890-afbd-2fd1b6d39210.xhtml),
    *Now for Something Completely Different—*though, instead of returning objects,
    they `yield` iterators. Generators are best used with large datasets that would
    consume vast quantities of memory, similar to the use case of the `iter` data
    type.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code block mentioned here shows the implementation of a generator. In the `file_sigs()` function,
    we create a list of tuples stored in the `sigs` variable. We then loop through
    each element in `sigs` and yield a `tuple` data type. This creates a generator,
    allowing us to use the `next()` function to retrieve each tuple individually and
    limit the generators'' memory impact. See the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: You can find additional file signatures at [http://www.garykessler.net/library/file_sigs.html](http://www.garykessler.net/library/file_sigs.html).
  prefs: []
  type: TYPE_NORMAL
- en: datetime objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Investigators are often asked to determine when a file was deleted, when a text
    message was read, or the correct order for a sequence of events. Consequently,
    a great deal of analysis revolves around timestamps and other temporal artifacts.
    Understanding time can help us piece together the puzzle and further understand
    the context surrounding an artifact. For this, and many other reasons, let's practice
    handling timestamps using the `datetime` module.
  prefs: []
  type: TYPE_NORMAL
- en: Python's `datetime` module supports the interpretation and formatting of timestamps.
    This module has many features, most notably getting the current time, determining
    the change (or delta) between two timestamps, and converting common timestamp
    formats into a human readable date. The `datetime.datetime()` method creates a
    `datetime` object and accepts the year, month, day, and optionally hour, minute,
    second, millisecond, and time zone arguments. The `timedelta()` method shows the
    difference between two `datetime` objects by storing the difference in days, seconds,
    and microseconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to import the `datetime` library so that we can use functions
    from the module. We can see the current date with the `datetime.now()` method.
    This creates a `datetime` object, which we then manipulate. For instance, let''s
    create a `timedelta` object by subtracting two `datetime` objects, separated by
    a few seconds. We can add or subtract the `timedelta` object to or from our `right_now`
    variable to generate another `datetime` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The output may vary, as you are running these commands at a different time than
    when they were for this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another highly used application of the `datetime` module is `strftime()`, which
    allows `datetime` objects to be converted into custom-formatted strings. This
    function takes a string format as its input. This format string is made up of
    special characters beginning with the percentage sign. The following table illustrates
    examples of the formatters we can use with the `strftime()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Description** | **Formatter** |'
  prefs: []
  type: TYPE_TB
- en: '| Year (YYYY) | `%Y` |'
  prefs: []
  type: TYPE_TB
- en: '| Month (MM) | `%m` |'
  prefs: []
  type: TYPE_TB
- en: '| Day (DD) | `%d` |'
  prefs: []
  type: TYPE_TB
- en: '| 24 hour (HH) | `%H` |'
  prefs: []
  type: TYPE_TB
- en: '| 12 hour (HH) | `%I` |'
  prefs: []
  type: TYPE_TB
- en: '| Minute (MM) | `%M` |'
  prefs: []
  type: TYPE_TB
- en: '| Second (SS) | `%S` |'
  prefs: []
  type: TYPE_TB
- en: '| Microseconds (SSSSSS) | `%f` |'
  prefs: []
  type: TYPE_TB
- en: '| Timezone (Z) | `%z` |'
  prefs: []
  type: TYPE_TB
- en: '| AM/PM | `%p` |'
  prefs: []
  type: TYPE_TB
- en: You can find additional timestamp formatting information at [http://strftime.org/](http://strftime.org/)
    or via the official documentation:[ https://docs.python.org/3/library/datetime.html#strftime-and-strptime-behavior](https://docs.python.org/3/library/datetime.html#strftime-and-strptime-behavior).
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, the `strptime()` function, which we do not showcase here, can
    be used for the reverse process. The `strptime()` function will take a string
    containing a date and time and convert it into a `datetime` object using the formatting
    string. We can also interpret epoch time (also called Unix or POSIX time), represented
    as an integer, into a UTC `datetime` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We can print this new object and it will be automatically converted into a
    string representing the `datetime` object. However, let''s pretend that we do
    not like to separate our date by hyphens. Instead, we can use the `strftime()`
    method to display the date with forward slashes or using any of the defined formatters.
    Lastly, the `datetime` library has a few pre-built formatters such as `isoformat()`,
    which we can use to easily produce a standard timestamp format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As a note, we have imported `print_function` into our interpreter to allow us
    to print these date values in both Python 2 and Python 3.
  prefs: []
  type: TYPE_NORMAL
- en: The `datetime` library alleviates a great deal of stress involved in handling
    date and time values in Python. This module is also well-suited for processing
    time formats that are often encountered during investigations.
  prefs: []
  type: TYPE_NORMAL
- en: Libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Libraries, or modules, expedite the development process, making it easier to
    focus on the intended purpose of our script rather than developing everything
    from scratch. External libraries can save large amounts of developing time and,
    if we''re being honest, they are often more accurate and efficient than any code
    we, as developers, can cobble together during investigations. There are two categories
    of libraries: standard and third-party. Standard libraries are distributed with
    every installation of Python and carry commonly used code that''s supported by
    the Python Software Foundation. The number and names of the standard libraries
    vary between Python versions, especially as you move between Python 2 and Python
    3\. We will do our best to call out when a library is imported or used differently
    between Python 2 and 3\. In the other category, third-party libraries introduce
    new code, add or improve functionality to the standard Python installation, and
    allow for the community to contribute modules.'
  prefs: []
  type: TYPE_NORMAL
- en: Installing third-party libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We know that we do not need to install standard modules because they come with
    Python, but what about third-party modules? The Python Package Index is a great
    place to start looking for third-party libraries. This can be found at [https://pypi.org/](https://pypi.org/).
    This service allows tools, such as `pip`, to install packages automatically. If
    an internet connection is not available or the package is not found on PyPi, a
    `setup.py` file can usually be used to install the module manually. The examples
    of using `pip` and `setup.py` are shown later. Tools such as `pip` are very convenient
    as they handle the installation of dependencies, check whether items are already
    installed, and suggest upgrades if an older version is installed. An internet
    connection is required to check for online resources, such as dependencies and
    newer versions of a module; however, `pip` can also be used to install code on
    an offline machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'These commands are run in the Terminal or Command Prompt, not the Python interpreter.
    Please note that in the example mentioned below, full paths may be necessary if
    your Python executable is not included in the current environment''s `PATH` variable.
    `pip` may need to be run from an elevated console, either using `sudo` or an elevated
    Windows Command Prompt. Full documentation for `pip` can be found at [http://pip.pypa.io/en/stable/reference/pip/](http://pip.pypa.io/en/stable/reference/pip/):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Libraries in this book
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this book, we use many third-party libraries that can be installed with `pip`
    or the `setup.py` method. However, not all third-party modules can be installed
    so easily and sometimes require you to search the internet. As you may have noted
    in the previous code block, some third-party modules, such as the `yarp` module,
    are hosted on source code management systems such as GitHub. GitHub and other
    SCM services allow us to access publicly available code and view changes made
    to it over time. Alternatively, Python code can sometimes be found on a blog or
    a self-hosted website. In this book, we will provide instructions on how to install
    any third-party modules that we use.
  prefs: []
  type: TYPE_NORMAL
- en: Python packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Python package is a directory containing Python modules and a `__init__.py`
    file. When we import a package, the `__init__.py` code is executed. This file
    contains the imports and code that's required to run other modules in the package.
    These packages can be nested within subdirectories. For example, the `__init__.py`
    file can contain `import` statements that bring in each Python file in the directory
    and all of the available classes or functions when the folder is imported. The
    following is an example directory structure and below that is the `__init__.py`
    file, which shows us how the two interact when imported. The last line in the
    following code block imports all specified items in the subdirectory's `__init__.py`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The hypothetical folder structure is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The top-level `__init__.py` file''s contents is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The code mentioned below executes the `__init__` script we mentioned previously,
    and it will import all functions from `script1.py`, only `function_name` from
    `script2.py`, and any additional specifications from `subDirectory/__init__.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Classes and object-oriented programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python supports **object-oriented programming** (**OOP**) using the built-in
    class keyword. Object-oriented programming allows advanced programming techniques
    and sustainable code that supports better software development. Because OOP is
    not commonly used in scripting and is above the introductory level, this book
    will implement OOP and some of its features in later chapters after we master
    the basic features of Python. What's important to keep in mind is almost everything
    in Python, including classes, functions, and variables, are objects. Classes are
    useful in a variety of situations, allowing us to design our own objects to interact
    with data in a custom manner.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at the `datetime` module for an example of how we will interact with
    classes and their methods. This library contains several classes, such as `datetime`,
    `timedelta`, and `tzinfo`. Each of these classes handles different functionality
    associated with timestamps. The most commonly used is the `datetime` class, which
    can be confusing as it is a member of the `datetime` module. This class is used
    to represent dates as Python objects. The two other mentioned classes support
    the `datetime` class by allowing dates to be added or subtracted, through the
    `timedelta` class, and time zones represented through the `tzinfo` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Focusing on the `datetime.datetime` class, we will look at how we can use this
    object to create multiple instances of dates and extract data from them. To begin,
    as seen in the following code block, we must import our printing statement and
    this library to access the `datetime` module''s classes and methods. Next, we
    pass arguments to the `datetime` class and assign the `datetime` object to `date_1`.
    Our `date_1` variable contains the value to represent April Fool''s Day, 2018\.
    Since we did not specify a time value when initiating the class, the value will
    reflect midnight, down to the millisecond. As we can see, like functions, classes
    too can have arguments. Additionally, a class can contain their own functions,
    commonly called methods. An example of a method is the call to `now()`, allowing
    us to gather the current timestamp for our local machine and store the value as
    `date_2`. These methods allow us to manipulate data that''s specific to the defined
    instance of the class. We can see the contents of our two date objects by printing
    them in the interactive prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We can access the properties of our date objects by calling specific class
    attributes. These attributes are usually leveraged by code within the class to
    process the data, though we can also use these attributes to our advantage. For
    example, the hour or year attributes allow us to extract the hour or the year
    from our date objects. Though this may seem simple, it becomes more helpful in
    other modules when accessing the parsed or extracted data from the class instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'As mentioned previously, we can always run the `dir()` and `help()` functions
    to provide context on what methods and attributes are available for a given object.
    If we run the following code, we can see that we can extract the weekday or format
    the date using the ISO format. These methods provide additional information about
    our `datetime` objects and allow us to take full advantage of what the class object
    has to offer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Try and except
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The try and except syntax is used to catch and safely handle errors that are
    encountered during runtime. As a new developer, you'll eventually become accustomed
    to having people telling you that your scripts don't work. In Python, we use the
    `try` and `except` blocks to stop preventable errors from crashing our code. Please
    use the `try` and `except` blocks in moderation. Don't use them as if they were
    band-aids to plug up holes in a sinking ship—instead, reconsider your original
    design and contemplate modifying the logic to better prevent errors. One great
    way to help with this is to provide instructions for use through command-line
    arguments, documentation, or otherwise. Using these correctly will enhance the
    stability of your program. However, improper usage will not add any stability
    and can mask underlying issues in your code. A good practice is to use as few
    lines of code within a `try` and `except` block as possible; this way, the error
    handling is focused and addressed properly.
  prefs: []
  type: TYPE_NORMAL
- en: For example, say we have some code that performs a mathematical calculation
    on two numerical variables. If we anticipate that a user may accidentally enter
    non-integer or float values, we may want to wrap a `try` and `except` around the
    calculation to catch any `TypeError` exceptions that may arise. When we catch
    the error, we can try and convert the variables to integers with the class constructor
    method before entering the `try` and `except` block again. If successful, we have
    saved our code from a preventable crash and maintained specificity to prevent
    our program from accepting dictionary input, for example. In the case of receiving
    a dictionary object, we would want the script to crash and present debug information
    to the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Any line that has a reasonable chance of generating an error should be handled
    by its own try and except block with a solution for that specific line to ensure
    that we are properly handling the specific error. There are a few variations of
    the `try` and `except` block. In short, there are catch-all, catch-as-variable,
    and catch-specific types of blocks. The following pseudocode shows examples of
    how the blocks are formed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The catch-all or bare except will catch any error. **This is often regarded
    as a poor coding practice as it can lead to undesired program behaviors.** Catching
    an exception as a variable is useful in a variety of situations. The error message
    of the exception stored in `e` can be printed or written to a log by calling `e.message`—this
    can be particularly useful when an error occurs within a large multi-module program.
    In addition, the built-in `isinstance()` function can be used to determine the
    type of error.
  prefs: []
  type: TYPE_NORMAL
- en: For support in both Python 2 and Python 3, please use the `except Exception
    as error` syntax as described previously, as opposed to the `except Exception,
    error` syntax supported by Python 2.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the example that we''ll look at next, we define two functions: `give_error()`
    and `error_handler()`. The `give_error()` function tries to append `5` to the
    `my_list` variable. This variable has not yet been instantiated and will generate
    a `NameError` instance. In the except clause, we are catching a base `Exception`
    and storing it in the `e` variable. We then pass this exception object to our
    `error_handler()` function, which we define later.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `error_handler()` function takes an exception object as its input. It checks
    whether the error is an instance of `NameError` or `TypeError`, or it passes otherwise.
    Based on the type of exception, it will print out the exception type and error
    message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Finally, the catch-specific try and except block can be used to catch individual
    exceptions and has targeted error-handling code for that specific error. A scenario
    that might require a catch-specific try and except block is working with an object,
    such as a list or dictionary, which may or may not be instantiated at that point
    in the program.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, the results list does not exist when it is called
    in the function. Fortunately, we wrapped the append operation in a `try` and `except`
    to catch the `NameError` exceptions. When we catch this exception, we first instantiate
    the results list as an empty list and then append the appropriate data before
    returning the list. Here is the example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: For (hopefully) obvious reasons, the previous code sample is intended to show
    the handling of exceptions. We should always be sure to initiate variables before
    usage.
  prefs: []
  type: TYPE_NORMAL
- en: The raise function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As our code can generate its own exceptions during execution, we can also manually
    trigger an exception to occur with the built-in `raise()` function. The `raise()` method
    is often used to raise an exception to the function that called it. While this
    may seem unnecessary, in larger programs, this can actually be quite useful.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine a function, `function_b()`, which receives parsed data in the form
    of a packet from `function_a()`. Our `function_b()` function does some further
    processing on the packet and then calls `function_c()` to continue to process
    the packet. If `function_c()` raises an exception back to `function_b()`, we might
    design some logic to alert the user of the malformed packet instead of trying
    to process it and producing faulty results. The following is some pseudocode representing
    such a scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In addition, raising custom or built-in exceptions can be useful when dealing
    with exceptions that Python doesn't recognize on its own. Let's revisit the example
    of the malformed packet. When the second function received the raised error, we
    might design some logic that tests some possible sources of error. Depending on
    those results, we might raise different exceptions back to the calling function,
    `function_a()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When raising a built-in exception, make sure to use an exception that most
    closely matches the error. For example, if the error revolves around an index
    issue, use the `IndexError` exception. When raising an exception, we should pass
    in a string containing a description of the error. This string should be descriptive
    and help the developer identify the issue, unlike the following string that''s
    used. The adage *do what we say, not what we do* applies here, as we are simply
    demonstrating functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Creating our first script – unix_converter.py
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our first script will perform a common timestamp conversion that will prove
    useful throughout this book. Named `unix_converter.py`, this script converts Unix
    timestamps into a human readable date and time value. Unix timestamps are generally
    formatted as an integer representing the number of seconds since `1970-01-01 00:00:00`.
  prefs: []
  type: TYPE_NORMAL
- en: 'On line one, we provide a brief description of our script to the users, allowing
    them to quickly understand the intentions and uses of the script. Following this
    are import statements on lines two through four. These imports likely look familiar,
    providing support (in order) for printing information in Python 2 and 3, interpreting
    timestamp data, and accessing information about the version of Python used. The
    `sys` library is then used on lines 6 through 12 to check what version of Python
    was used to call the script to properly handle accepting user input. Python 2
    uses the `raw_input` function to accept data at the Terminal for the user, while
    Python 3 implements the `input` function. This `if`/`elif`/`else` statement is
    then concluded with `NotImplementedError` for other (future) versions of Python
    not specified. To make things easier, we built this conditional in a manner that
    you can easily plug into your code. See the following for the described code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: After an omitted license statement (please see the source code for the MIT license
    information), we provide additional script information for reference by the user
    and to standardize our script implementation. We then move to the `main()` function,
    which prompts the user for a timestamp to convert and then prints the results
    of the transformed timestamp from our `Unix_converter()` function. To break apart
    line 49 a little more, let's start at the innermost component, the `get_input()`
    function call. This function is supplied with a string that will be displayed
    to the user in front of the buffer allowing user input. This `get_input()` function
    returns a string value of the data entered into the console by the user, although
    we need to convert this value into an integer. We use the `int` class to initialize
    an integer value that we then store in the `unix_ts` variable.
  prefs: []
  type: TYPE_NORMAL
- en: Applying concepts
  prefs: []
  type: TYPE_NORMAL
- en: How could we redesign line 49 to better handle the user input and any exceptions
    that may arise when accepting this data?
  prefs: []
  type: TYPE_NORMAL
- en: Hint
  prefs: []
  type: TYPE_NORMAL
- en: It may take more than one line.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'On line 50 in the previous code block, we call the `unix_converter()` function,
    providing the integer input from the user. This function then, as defined on line
    53 in the following code, calls the `datetime` module and uses the `utcfromtimestamp()`
    method to read the integer as a `datetime` object. We are using the `utcfromtimestamp()`
    method here instead of the similarly named `fromtimestamp()` method, as the `utcfromtimestamp()`
    version does not apply time zone modifications to the provided data and leaves
    the timestamp in the original time zone. This returned `datetime` object is then
    converted into a human-readable string using the `strftime()` method and the resulting
    string is returned to the calling function, which ultimately prints this value
    to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Our script is concluded with two lines of code, as shown in the following snippet,
    which will become very frequent in the conclusions of our scripts. The first of
    these lines, on line 57, is a conditional that''s used to check whether the script
    was executed as a script instead of imported as a module. This allows us to change
    the functionality of our code based on how it is used. In an example, a console
    version of our code should, generally, accept command-line arguments while a version
    used as a library will not need to prompt the user for those details as the calling
    script may only use a subset of functions within this code. This means that line
    58 is the only logic we want to execute if this code is called at the command
    line, which starts the `main()` function. If this script is imported as a module
    to another script, nothing will occur as we have no further logic to run on import.
    If it is imported, we will be able to use the functions without worrying about
    other calls occurring on import:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now execute this script by calling `unix_converter.py` at the command
    line. This script ran, as shown in the following screenshot, until it required
    input from the user. Once the value was entered, the script continued execution
    and printed the converted timestamp to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9a19d5dc-c394-4e33-930c-487382ce4ca0.png)'
  prefs: []
  type: TYPE_IMG
- en: User input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Allowing user input enhances the dynamic nature of a program. It is a good practice
    to query the user for file paths or values rather than explicitly writing this
    information into the code file. Therefore, if the user wants to use the same program
    on a separate file, they can simply provide a different path, rather than editing
    the source code. In most programs, users supply input and output locations or
    identify which optional features or modules should be used at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: User input can be supplied when the program is first called or during runtime
    as an argument. For most projects, it is recommended to use command-line arguments
    because asking the user for input during runtime halts the program execution while
    waiting for the input.
  prefs: []
  type: TYPE_NORMAL
- en: Using the raw input method and the system module – user_input.py
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Both `input()` and `sys.argv` represent basic methods of obtaining input from
    users. Be cognizant of the fact that both of these methods return string objects,
    as previously discussed for the Python 2 `raw_input()` and Python 3 `input()`
    functions. We can simply convert the string into the required data type using
    the appropriate class constructor.
  prefs: []
  type: TYPE_NORMAL
- en: The `input()` function is similar to asking someone a question and waiting for
    their reply. During this time, the program's execution thread halts until a reply
    is received. We define a function later that queries the user for a number and
    returns the squared value. As seen in our first script, when converting Unix timestamps,
    we have to wait for the user to provide a value before the script can continue.
    While this wasn't an issue in that very short script, larger code bases or long-running
    scripts should avoid this delay.
  prefs: []
  type: TYPE_NORMAL
- en: Arguments supplied at the command line are stored in the `sys.argv` list. As
    with any list, these arguments can be accessed with an index, which starts at
    zero. The first element is the name of the script, while any element after that
    represents a space-separated user-supplied input. We need to import the `sys`
    module to access this list.
  prefs: []
  type: TYPE_NORMAL
- en: 'On line 39, we copy the arguments from the `sys.argv` list into a temporary
    list variable named `args`. This is preferred because, on line 41, we remove the
    first element after printing it. For the remaining items in the `args` list, we
    use a `for` loop and wrap our list with the built-in `enumerate()` function. This
    gives us a counter for our loop, `i`, to count the number of loop iterations or
    arguments used in this case. On lines 43 and 44, we print out each argument and
    its position and data type. We have the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: After saving this file as `user_input.py`, we can call it at the command line
    and pass in our arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see in the following example, arguments are space delimited, therefore
    an argument with spaces needs to be wrapped with quotes. It is also clear in the
    following example that all argument values from `sys.argv` are stored as string
    values. The `input()` function also interprets all input as string values:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/11dcec26-1ede-4643-9c05-8daa53de02c5.png)'
  prefs: []
  type: TYPE_IMG
- en: For smaller programs that do not have many command-line options, the `sys.argv`
    list is a quick and easy way to obtain user input without blocking script execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'File paths that contain a space should be double-quoted. For example, `sys.argv`
    would split `C:/Users/LPF/misc/my books` into `C:/Users/LPF/misc/my` and `books`.
    This would result in an `IOError` exception when trying to interact with this
    directory in a script. Additionally, watch for file paths containing the backslash
    character `\`; we need to escape this character to prevent our command line Terminal
    and our code from misunderstanding the input. This character is escaped by using
    a second backslash, like so: `\\`.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Argparse – argument_parser.py
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Argparse is a module in the standard library and will be used throughout this
    book as a means of obtaining user input. Argparse can help develop more complicated
    command-line interfaces. By default, `argparse` creates a `-h` switch or a help
    switch to display help and usage information for the scripts. In this section,
    we will build a sample `argparse` implementation that has required, optional,
    and default arguments.
  prefs: []
  type: TYPE_NORMAL
- en: We import the `argparse` module, following our usual `print_function` and script
    description. We then specify our usual script header details as `__author__`,
    `__date__`, and `__description__` as we will be using all three in our `argparse`
    implementation. On line 38, we then define an overly simple `main()` function
    to print the parsed argument information, as we don't have any plans for this
    script other than to show off some neat user argument handling. To accomplish
    that goal, we first need to initiate our `ArgumentParser` class instance, as shown
    on lines 43 through 48\. Notice how we only implement this if the script is called
    from the command line with the conditional on line 42.
  prefs: []
  type: TYPE_NORMAL
- en: 'On line 43, we initialize `ArgumentParser` with three optional arguments. The
    first is the description of the script, which we will read in from the `__description__`
    variable that was previously set. The second argument is the epilog or details
    provided at the end of the help section. This can be any arbitrary text, as can
    the description field, though we chose to use this to provide authorship and version
    information. For getting started, using date values as a version number is helpful
    for user reference and prevents complications with numbering schemes. The last
    optional argument is a formatter specification, instructing our argument parser
    to display any default values set by the script so that the user can know whether
    options will be set if they do not modify them through an argument. It is highly
    recommended to include this as a force of habit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We can now leverage our newly instantiated parser object to add an argument
    specification. To start, let's discuss some healthy practices for required and
    optional arguments. Argparse, by default, uses the presence of one or two dashes
    prior to an argument name to note whether the argument should be considered optional
    or not. If the argument specification has a leading dash, it will be considered
    both optional and non-positional; the inverse, a lack of a leading dash, will
    instruct argparse to interpret an argument as required and positional.
  prefs: []
  type: TYPE_NORMAL
- en: Use the following as an example; in this script, the `timezone` and `input_file`
    arguments are required and must be provided in that order. Additionally, the arguments
    for these two items do not require an argument specifier; instead, `argparse`
    will look for an unpaired value to assign to the `timezone` argument and then
    look for a second unpaired value to assign to the `input_file` argument. Inversely,
    the `--source`, `--file-type`, `-h` (or `--help`), and `-l` (or `--log`) arguments
    are non-positional and can be provided in any order as long as the appropriate
    value is immediately following, that is, paired with, with the argument specifier.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make things a little more complex, but more customizable, we can require
    non-positional arguments. This has an advantage, as we can now allow the user
    to enter the arguments in an arbitrary order, though as a disadvantage it requires
    additional typing for fields that are required for the script to operate. You''ll
    notice in the following code that the `--source` argument on the second line does
    not have square brackets surrounding the value. This is argparse''s (subtle) way
    of indicating that this is a required non-positional argument. It can be tricky
    for a user to understand this at first glance, though argparse will halt the execution
    of the script and alert the user if the argument is missing from the provided
    arguments. You may want to use non-positional required arguments in your scripts
    or avoid them all together—it is up to you as the developer to find the most comfortable
    and fitting interface for your users:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Mini-tangent aside, let''s start adding arguments to the parser object we initiated.
    We will start with one of the positional arguments we previously discussed. The
    `timezone` argument is defined using the `add_argument()` method, allowing us
    to provide a string representing the argument name and optional parameters for
    additional detail. On line 51, we simply offer helpful information to provide
    context to how this argument should be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The next argument we add, on line 54, is the non-positional required argument
    previously discussed. Notice how we use the `required=True` statement to indicate
    that, regardless of the leading dashes, this argument is required for execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We now add our first non-positional and optional argument for the log file.
    Here, we are providing two options for how the user can specify the argument,
    `-l` or `--log.` This is recommended for common arguments, as it provides the
    frequent user shorthand and the novice user context for argument use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Not all arguments need to accept a value; in some instances, we just need a
    Boolean answer from the argument. Additionally, we may want to allow the argument
    to be specified multiple times or have custom functionality when called. To support
    this, the `argparse` library allows for the use of actions. The actions we will
    commonly use in this book are demonstrated as follows.
  prefs: []
  type: TYPE_NORMAL
- en: The first action that is handy is `store_true` and is the opposite of `store_false`.
    These are handy for getting information on enabling or disabling functionality
    in your script. As shown in the following code block on lines 61 through 64, we
    can see the action parameter being used to specify whether `True` or `False` should
    be stored as a result of the argument. In this case, this is duplicative, and
    one of these two arguments could be used to determine whether the email in this
    example should be sent. Additional actions are available, such as `append`, as
    shown on line 66 and 67, where each instance of an email address, in this example,
    will be added to a list that we can iterate through and use.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last action example in the following code is used to count the number of
    times an argument is called. We see this implementation primarily for increasing
    verbosity or debugging messages, though it can be used elsewhere in the same fashion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The `default` keyword dictates the default value of an argument. We can also
    use the `type` keyword to store our argument as a certain object. Instead of being
    stuck with strings as our only input, we can now store the input directly as the
    desired object, such as an integer, and remove the need for user input conversions
    from our scripts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Argparse can be used to directly open a file for reading or writing. On line
    76, we open the required argument, `input_file`, in reading mode. By passing this
    file object into our main script, we can immediately begin to process our data
    of interest. This is repeated on the next line to handle opening a file for writing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The last keyword we will discuss is `choices`, which takes a list of case-sensitive
    options that the user can select from. When the user calls this argument, they
    must then provide one of the valid options. For example, `--file-type RAW` would
    set the `file-type` argument to the RAW choice, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, once we have added all of our desired arguments to our `parser`, we
    can parse the arguments. On line 84, we call the `parse_args()` function, which
    creates a `Namespace` object. To access, for example, the length argument that
    we created on line 72, we need to call the `Namespace` object such as `arguments.length`.
    On line 85, we pass our arguments into our `main()` function, which prints out
    all of the arguments in the `Namespace` object. We have the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: These `Namespace` objects may be reassigned to variables for easier recall.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the basics of the `argparse` module behind us, we can now build simple
    and more advanced command-line arguments for our scripts. Therefore, this module
    is used extensively to provide command-line arguments for most of the code we
    will build. When running the following code with the `--help` switch, we should
    see our series of required and optional arguments for the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/10198d66-121b-4449-a597-a10870d68445.png)'
  prefs: []
  type: TYPE_IMG
- en: Forensic scripting best practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Forensic best practices play a big part in what we do and, traditionally, refer
    to handling or acquiring evidence. However, we''ve designated some forensic best
    practices of our own when it comes to programming, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Do not modify the original data you're working with
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Work on copies of the original data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comment code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validate your program's results (and other application results)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maintain extensive logging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Return output in an easy-to-analyze format (your users will thank you)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The golden rule of forensics is: strongly avoid modification of the original
    data. Work on a verified forensic copy whenever possible. However, this may not
    be an option for other disciplines, such as for incident responders where the
    parameters and scope varies. As always, this varies on the case and circumstances,
    but please keep in mind the ramifications of working on live systems or with original
    data.'
  prefs: []
  type: TYPE_NORMAL
- en: In these cases, it is important to consider what the code does and how it might
    interact with the system at runtime. What kind of footprint does the code leave
    behind? Could it inadvertently destroy artifacts or references to them? Has the
    program been validated in similar conditions to ensure that it operates properly?
    These are the kinds of considerations that are necessary when it comes to running
    a program on a live system.
  prefs: []
  type: TYPE_NORMAL
- en: We've touched on commenting code before, but it cannot hurt to overstate its
    value. Soon, we will create our first forensic script, `usb_lookup.py`, which
    is a little over 90 lines of code. Imagine being handed the code without any explanation
    or comments. It might take a few minutes to read and understand what it does exactly,
    even for an experienced developer. Now, imagine a large project's source code
    that has thousands of lines of code—it should be apparent how valuable comments
    are, not just for the developer but also those who examine the code afterwards.
  prefs: []
  type: TYPE_NORMAL
- en: Validation essentially comes down to knowing the code's behavior. Obviously,
    bugs are going to be discovered and addressed. However, bugs have a way of frequently
    turning up and are ultimately unavoidable as it is impossible to test against
    all possible situations during development. Instead, what can be established is
    an understanding of the behavior of the code in a variety of environments and
    situations. Mastering the behavior of your code is important, not only to be able
    to determine if the code is up for the task at hand but also when asked to explain
    its function and inner workings in a courtroom.
  prefs: []
  type: TYPE_NORMAL
- en: Logging can help keep track of any potential errors during runtime and act as
    an audit-chain of sorts for what the program did and when. Python supplies a robust
    logging module in the standard library, unsurprisingly named `logging`. We will
    use this module and its various options throughout this book.
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of our scripts is to automate some of the tedious repetitive tasks
    in forensics and supply analysts with actionable knowledge. Oftentimes, the latter
    refers to storing data in a format that is easily manipulated. In most cases,
    a CSV file is the simplest way to achieve this so that it can be opened with a
    variety of different text or workbook editors. We will use the `csv` module in
    many of our programs.
  prefs: []
  type: TYPE_NORMAL
- en: Developing our first forensic script – usb_lookup.py
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we've gotten our feet wet writing our first Python script, let's write
    our first forensic script. During forensic investigations, it is not uncommon
    to see references to external devices by their **vendor identifier** (**VID**)
    and **product identifier** (**PID**) values; these values are represented by four
    hexadecimal characters. In cases where the vendor and product name are not identified,
    the examiner must look up this information. One such location for this information
    is the following web page: [http://linux-usb.org/usb.ids](http://linux-usb.org/usb.ids).
    For example, on this web page, we can see that a Kingston DataTraveler G3 has
    a VID of 0951 and a PID of 1643\. We will use this data source when attempting
    to identify vendor and product names by using the defined identifiers.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s look at the data source we''re going to be parsing. A hypothetical
    sample illustrating the structure of our data source is mentioned later. There
    are USB vendors and, for each vendor, a set of USB products. Each vendor or product
    has four-digit hexadecimal characters and a name. What separates vendor and product
    lines are tabs because products are tabbed over once under their parent vendor.
    As a forensic developer, you will come to love patterns and data structures, as
    it is a happy day when data follows a strict set of rules. Because of this, we
    will be able to preserve the relationship between the vendor and its products
    in a simple manner. Here is the afore-mentioned hypothetical sample:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'This script, named `usb_lookup.py`, takes a `VID` and `PID` that''s supplied
    by the user and returns the appropriate vendor and product names. Our program
    uses the `urlopen` method from the `urllib` module to download the `usb.ids` database
    to memory and create a dictionary of VIDs and their products. Since this is one
    of the libraries that changed between versions 2 and 3 of Python, we have introduced
    some logic in a `try` and `except` block to ensure we are able to call the `urlopen`
    method without issue, as shown in the following code. We also import the `argparse`
    module to allow us to accept `VID` and `PID` information from the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: If a vendor and product combination is not found, error handling will inform
    the user of any partial results and exit the program gracefully.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `main()` function contains the logic to download the `usb.ids` file, store
    it in memory, and create the USB dictionary. The structure of the USB dictionary
    is somewhat complex and involves mapping a `VID` to a list, containing the name
    of the vendor as the first element, and a product dictionary as the second element.
    This product dictionary maps PIDs to their names. The following is an example
    of the USB dictionary containing two vendors, `VendorId_1` and `VendorId_2`, each
    mapped to a list containing the vendor name, and a dictionary for any product
    ID and name pairs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: It may be tempting to just search for `VID` and `PID` in the lines and return
    the names rather than creating this dictionary that links vendors to their products.
    However, products can share the same ID across different vendors, which could
    result in mistakenly returning a product from a different vendor. With our previous
    data structure, we can be sure that the product belongs to the associated vendor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the USB dictionary has been created, the `search_key()` function is responsible
    for querying the dictionary for a match. It first assigns the user-supplied two
    arguments, `VID` and `PID`, before continuing with the execution of the script.
    Next, it searches for a `VID` match in the outermost dictionary. If `VID` is found,
    the innermost dictionary is searched for the responsive `PID`. If both are found,
    the resolved names are printed to the console. Lastly, starting at line 81, we
    define our arguments for the user to provide the `VID` and `PID` values before
    calling the `main()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'For larger scripts, such as this, it is helpful to view a diagram that illustrates
    how these functions are connected together. Fortunately, a library named `code2flow`,
    available on GitHub ([https://github.com/scottrogowski/code2flow.git](https://github.com/scottrogowski/code2flow.git)),
    exists to automate this process for us. The following schematic illustrates the
    flow from the `main()` function to the `search_key()` function. There are other
    libraries that can create similar flow charts. However, this library does a great
    job of creating a simple and easy to understand flowchart:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2ed8a4fd-93ec-4620-a007-9ef795ebbab2.png)'
  prefs: []
  type: TYPE_IMG
- en: Understanding the main() function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start by examining the `main()` function, which is called on line 90,
    as seen in the previous code block. This function, on line 42, requires the `vid`
    and `pid` information supplied by the user''s arguments for resolution in the
    `usb.ids` database. On lines 43 through 46, we create our initial variables. The `url` variable
    stores the URL containing the USB data source. We use the `urlopen()` function
    from the `urllib` module to create a list of strings from our online source. We
    will use a lot of string operations, such as `startswith()`, `isalnum()`, `islower()`,
    and `count()`, to parse the `usb.ids` file structure and store the parsed data
    in the `usbs` dictionary. The `curr_id` variable, defined as an empty string on
    line 46, will be used to keep track of which vendor we are currently processing
    in our script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'An important concept in Python string manipulation is encoding. This is one
    of the most common issues when writing Python 2 and Python 3 compatible code.
    The following `for` loop on line 48 starts iterating over each line in the file,
    providing the line for review. For Python 3 support, we have to check whether
    the line variable is an instance of bytes, a raw data type that (in this case)
    is holding encoded string data. If this is the case, we must decode it using the
    `decode()` method and provide the proper encoding—`latin-1` in this instance,
    as seen on line 50\. Python 2 reads data from files as strings and therefore will
    not enter this conditional, so we can move forward with parsing the line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Our next conditional checks for commented lines in the `usb.ids` file, skipping
    any blank lines (only containing a newline or tab character) and any comment lines
    starting with a pound character. To check for comment lines, we can use the `startswith()` string
    method to check whether the provided string, of one or more characters, is the
    same as the line we are checking. To simplify our code, we also leveraged the
    `in` statement, which allows us to handle an `or`-like comparison of equality
    for the line. This is a handy shortcut you will see in a variety of scripts. If
    either of these conditions is true, we will use the continue statement as seen
    on line 52 to step into the next loop iteration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The second half of our conditional handles additional validation of the line
    format. We want to confirm that the line we are inspecting matches the format
    of a vendor line, so we can include our vendor-related parsing code within it.
    To do this, we check to make sure the line does not start with a tab character
    and the first character is alphanumeric with the `isalnum()` call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Knowing that the line passed our check for confirming it is a vendor informational
    line, we can start extracting the needed values and fill out our data structure.
    On line 55, we extract our two values from the line, `uid` and `name`, by stripping
    the line and using the `split()` method. The `split()` method is using two parameters
    here, one for the character to split on and the second for the number of times
    to split. In this case, we are splitting on a space character and only splitting
    after finding the first space.
  prefs: []
  type: TYPE_NORMAL
- en: This is useful, as our vendor name may contain a space in it and we want to
    keep those details together. Since we anticipate two values returning, we can
    use the assignment seen on line 55 to simultaneously populate the `uid` and `name`
    variables with the correct values, though this can lead to errors if the `split()`
    method only returns one object. In this instance, we know our data source and
    have validated that this should always return two values, though this is a great
    spot to add a try-except block in your version of the code to handle any errors
    that may arise.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then assign the `uid` variable to the `curr_id` value for use while parsing
    `PID` details on line 56\. Finally, on line 57, we add this information to our
    data structure, `usbs`. Since the `usbs` structure is a dictionary, we assign
    the VID''s `uid` value as the key and set up our list with the `VID` common name
    as the first element and an empty dictionary for product details as a second.
    On line 57, we ensure that the vendor name does not have any unwanted whitespace
    characters on it by calling the `strip()` method on the string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have processed the vendor data pattern, let''s turn our attention
    to the product data pattern. First, we will use an `elif` conditional to check
    that the line does start with a tab character and, using the `count()` method,
    ensure that it is the only tab character in the line. On line 59, we make a familiar
    call to strip and split the line into our required values. On line 60, we then
    add the product information to our data structure. As a quick refresher, `usbs`
    is a dictionary, where the keys are VIDs. Within a VID''s value is a list where
    element zero is the vendor name and element one is the dictionary to store PID
    details. As expected, we will use the `uid` value as the key for the product details
    and assign the product name to the `PID` key. Notice how we use the `curr_id`
    value from the prior vendor line to ensure we are correlating the VIDs and PIDs
    properly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The previous lines then repeat in a `for` loop until the end of the file is
    reached, parsing out the vendor and product details and adding them into the `usbs`
    dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are almost there—the last part of our `main()` function is a call to the
    `search_key()` function, which takes the user-supplied `vid` and `pid` information,
    along with our newly built `usbs` dictionary for lookup. Notice how this call
    is indented with four spaces, placing it outside of the `for` loop and allowing
    us to only call this method one time, once the `usbs` lookup dictionary is complete:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: This takes care of the logic in the `main()` function. Now, let's take a look
    at the `search_key()` function to determine how we will lookup our VID and PID
    values.
  prefs: []
  type: TYPE_NORMAL
- en: Interpreting the search_key() function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `search_key()` function, originally called on line 62 of the `main()` function,
    is where we search for the user-supplied vendor and product IDs, and display the
    resolved results to the user. In addition, all of our error handling logic is
    contained within this function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s practice accessing nested lists or dictionaries. We discussed this in
    the `main()` function; however, it pays to actually practice rather than take
    our word for it. Accessing nested structures requires us to use multiple indices
    rather than just one. For example, let''s create a list and map that to `key_1`
    in a dictionary. To access elements from the nested list, we will need to supply
    `key_1` to access the list and then a numerical index to access elements of the
    list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's switch gears, back to the task at hand, and leverage our new skills
    to search our dictionary to find vendor and product IDs. The `search_key()` function
    is defined on line 65 and takes the user-supplied VID and PID along with our parsed
    out `usb_dict` dictionary. We then start by querying `usb_dict` for the `vendor_key`
    value, using the `get()` method of a dictionary to attempt to get the requested
    key's value or return `None`, as specified on line 66, if the key is not found.
  prefs: []
  type: TYPE_NORMAL
- en: 'Please note that the data returned by the `get()` call, if successful, is the
    entire value for that key, or in this case a list, where element zero is the vendor
    name and element one is the dictionary of product details. We can then check,
    on line 67, to see whether the key was found; if it was unavailable, we print
    this to the user and exit on lines 68 and 69, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then repeat this logic for looking up the product information, though
    we first have to navigate to the product information. On line 71, we access element
    one of the vendor list, containing the product details dictionary, and perform
    the same `get()` method call to look up any name resolution for the PID. In the
    same manner, we check to see if the lookup failed and provide any available details
    to the user; in case it fails, we can at least give the vendor information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'If everything resolves successfully, we can print the output to the user and
    the script will complete! Notice how, on line 77, in the format statement, we
    have to call the first element of the vendor variable since the value of the VID
    key lookup was a list, whereas the value of the PID key lookup is just the product''s
    name. This is where things can get a little confusing, though feel free to reference
    the earlier sample data structure and add as many intermediate print statements
    to help with comprehension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Running our first forensic script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `usb_lookup.py` script requires two arguments—vendor and product IDs for
    the USB of interest. We can find this information by looking at a suspect `HKLM\SYSTEM\%CurrentControlSet%\Enum\USB`
    registry key. For example, supplying the vendor, `0951`, and product, `1643`,
    from the sub-key `VID_0951&PID_1643`, results in our script identifying the device
    as a Kingston DataTraveler G3:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9cf95fc4-970a-4d46-86ab-3025ec84fbbc.png)'
  prefs: []
  type: TYPE_IMG
- en: Our data source is not an all-inclusive list, and if you supply a vendor or
    a product ID that does not exist in the data source, our script will print that
    the ID was not found. The full code for this and all of our scripts can be downloaded
    from [https://packtpub.com/books/content/support](https://packtpub.com/books/content/support).
  prefs: []
  type: TYPE_NORMAL
- en: Troubleshooting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At some point in your development career—probably by the time you write your
    first script—you will have encountered a Python error and received a **Traceback**
    message. A Traceback provides the context of the error and pinpoints the line
    that caused the issue. The issue itself is described as an exception, and usually
    provides a human-friendly message of the error.
  prefs: []
  type: TYPE_NORMAL
- en: Python has a number of built-in exceptions, the purpose of which is to help
    the developer in diagnosing errors in their code. A full listing of built-in exceptions
    can be found at [https://docs.python.org/3/library/exceptions.html](https://docs.python.org/3/library/exceptions.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at a simple example of an exception, `AttributeError`, and what
    the Traceback looks like in this case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The Traceback indicates the file in which the error occurred, in this case,
    `stdin` or standard input, because this code was written in the interactive prompt.
    When working on larger projects or with a single script, the file will be the
    name of the script causing the error rather than `stdin`. The `in <module>` bit
    will be the name of the function that contains the faulty line of code, or `<module>`
    if the code is outside of a function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s look at a slightly more complicated issue. To do this, let''s use
    the data structure from our prior script. In the following code block, we are
    not accessing the VID data with the `get()` call, but instead hoping that it exists.
    Temporarily replace line 66 of the `usb_lookup.py` script with the following for
    this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if you run this updated code with a valid vendor key, you will get an
    expected result, though use a key such as `ffff` and see what occurs. Check if
    it looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The traceback here has three traces in the stack. The last trace at the bottom
    is where our error occurred. In this case, on line 66 of the `usb_lookup.py` file,
    the `search_key()` function generated a `KeyError` exception. Looking up what
    a `KeyError` exception is in the Python documentation would indicate that this
    is due to the key not existing in the dictionary. Most of the time, we will need
    to address the error at that specific error causing line. In our case, we employed
    the `get()` method of a dictionary to safely access key elements. Please revert
    the line back to its prior state at this time to prevent this error from occurring
    in the future!
  prefs: []
  type: TYPE_NORMAL
- en: Challenge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We recommend experimenting with the code to learn how it works or try to improve
    its functionality. For example, how can we further validate the VID and PID input
    to ensure they are valid? Can we perform this same check on the returned UID values
    on lines 55 and 59?
  prefs: []
  type: TYPE_NORMAL
- en: Another extension to our first script is to consider offline environments. How
    can we modify this code to allow someone to run in an air-gapped environment?
    What arguments can be used to change the behavior depending on the user's need
    for offline access?
  prefs: []
  type: TYPE_NORMAL
- en: Programs are constantly evolving and are never truly finished products. There
    are plenty of other improvements that can be made here and we invite you to create
    and share the modifications to this and all of your other forensic Python scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter continued from where we left off in previous chapter, and helped
    us build a solid Python foundation for later chapters. We covered advanced data
    types and object-oriented programming, developed our first scripts, and dived
    into traceback messages. At this point, you should start to become comfortable
    with Python, though repeat these two chapters and manually type out the code to
    help strengthen your comfort level as needed. We highly recommend to practice
    and experiment by either testing out ideas in the interactive prompt or modifying
    the scripts we developed. The code for this project can be downloaded from GitHub
    or Packt, as described in the *Preface*.
  prefs: []
  type: TYPE_NORMAL
- en: As we move away from theory and look into the core part of this book, we will
    start with simple scripts and work toward increasingly more complicated programs.
    This should allow a natural development of understanding programming and skills.
    In the next chapter, you will learn how to parse the `setupapi.dev.log` file on
    Windows systems to identify USB installation times.
  prefs: []
  type: TYPE_NORMAL
