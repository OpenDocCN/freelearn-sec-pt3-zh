["```\n; Put this in the beginning of 'platform.inc'\n\ntype_dll       equ 0\ntype_obj       equ 1\n\nplatform_w32   equ 2\nplatform_w64   equ 4\nplatform_l32   equ 8\nplatform_l64   equ 16\n\nTARGET_W32_DLL equ platform_w32 or type_dll\nTARGET_W32_OBJ equ platform_w32 or type_obj\nTARGET_W64_DLL equ platform_w64 or type_dll\nTARGET_W64_OBJ equ platform_w64 or type_obj\nTARGET_L32_O   equ platform_l32 or type_obj\nTARGET_L64_O   equ platform_l64 or type_obj\n```", "```\nmacro set_output_format\n{\n   if ACTIVE_TARGET = TARGET_W32_DLL\n      include 'win32a.inc'\n      format PE DLL\n      entry DllMain\n\n   else if ACTIVE_TARGET = TARGET_W32_OBJ\n      format MS COFF\n\n   else if ACTIVE_TARGET = TARGET_W64_DLL\n      include 'win64a.inc'\n      format PE64 DLL\n      entry DllMain\n\n   else if ACTIVE_TARGET = TARGET_W64_OBJ\n      format MS64 COFF\n\n   else if ACTIVE_TARGET = TARGET_L32_O\n      format ELF\n\n   else if ACTIVE_TARGET = TARGET_L64_O\n      format ELF64\n   end if\n}\n```", "```\nformat MS64 COFF\n```", "```\nmacro begin_code_section\n{\n   if ACTIVE_TARGET = TARGET_W32_DLL\n      section '.text' code readable executable\n    *; This is not obligatory, but nice to have - the DllMain procedure*\n    DllMain:\n      xor eax, eax\n      inc eax\n      ret 4 * 3\n\n   else if ACTIVE_TARGET = TARGET_W32_OBJ\n      section '.text' code readable executable\n\n   else if ACTIVE_TARGET = TARGET_W64_DLL\n      section '.text' code readable executable\n    *; DllMain procedure for 64-bit Windows DLL*\n    DllMain:\n      xor rax, rax\n      inc eax\n      ret\n\n   else if ACTIVE_TARGET = TARGET_W64_OBJ\n      section '.text' code readable executable\n\n   else if ACTIVE_TARGET = TARGET_L32_O\n      section '.text' executable\n\n   else if ACTIVE_TARGET = TARGET_L64_O\n      section '.text' executable\n\n   end if\n}\n```", "```\nmacro begin_data_section\n{\n   if ACTIVE_TARGET = TARGET_W32_DLL\n      section '.data' data readable writeable\n\n   else if ACTIVE_TARGET = TARGET_W32_OBJ\n      section '.data' data readable writeable\n\n   else if ACTIVE_TARGET = TARGET_W64_DLL\n      section '.data' data readable writeable\n\n   else if ACTIVE_TARGET = TARGET_W64_OBJ\n      section '.data' data readable writeable align 16\n\n   else if ACTIVE_TARGET = TARGET_L32_O\n      section '.data' writeable\n\n   else if ACTIVE_TARGET = TARGET_L64_O\n      section '.data' writeable\n\n   end if\n}\n```", "```\n*; In this specific case, when the macro would be called* \n*; at the end of the source, we may replace the*\n*; \"macro finalize\" declaration with the \"postpone\" directive.*\nmacro finalize\n{\n   if ACTIVE_TARGET = TARGET_W32_DLL\n      section '.edata' export data readable\n         export 'MA_CRYPTO.DLL',\\\n            GetPointers, 'GetPointers'\n\n   else if ACTIVE_TARGET = TARGET_W32_OBJ\n      public GetPointers as '_GetPointers'\n\n   else if ACTIVE_TARGET = TARGET_W64_DLL\n      section '.edata' export data readable\n         export 'MA_CRYPTO.DLL',\\\n            GetPointers, 'GetPointers'\n\n   else if ACTIVE_TARGET = TARGET_W64_OBJ\n      public GetPointers as 'GetPointers'\n\n   else if ACTIVE_TARGET = TARGET_L32_O\n      public GetPointers as 'GetPointers' \n\n   else if ACTIVE_TARGET = TARGET_L64_O\n      public GetPointers as 'GetPointers'\n\n   end if\n}\n```", "```\n*; First of all we need to include all that we have written this far*\ninclude 'platform.inc'\n\n*; The following variable and macro are used in compile time \n; only for generation of* *pseudorandom sequences, where \n; count specifies the amount of pseudorandom bytes to* *generate*\nseed = %t\nmacro fill_random count\n{\n   local a, b\n   a = 0\n   while a < count\n      seed = ((seed shr 11) xor (seed * 12543)) and 0xffffffff\n      b = seed and 0xff\n      db   b\n      a = a + 1\n   end while\n}\n\n*; ACTIVE_TARGET variable may be set to any of the \n; TARGET* constants*\nACTIVE_TARGET = TARGET_W32_DLL\n\n*; Tell the compiler which type of output is expected \n; depending on the value of* *the ACTIVE_TARGET variable*\nset_output_format\n\n*; Create code section depending on selected target*\nbegin_code_section\n\n*; We will insert our code here*\n\n*; Create appropriate declaration of the data section*\nbegin_data_section\n\n   *; Tell the compiler whether we are expecting 32-bit \n   ; or 64-bit output*\n   if(ACTIVE_TARGET = TARGET_W32_OBJ) |\\ \n     (ACTIVE_TARGET = TARGET_W32_DLL) |\\ \n     (ACTIVE_TARGET = TARGET_L32_O)\n      use32\n   else if(ACTIVE_TARGET = TARGET_W64_OBJ) |\\ \n          (ACTIVE_TARGET = TARGET_W64_DLL) |\\ \n          (ACTIVE_TARGET = TARGET_L64_O)\n      use64\n   end if\n\n   *; This, in fact, is a structure which would be populated with \n   ; addresses of our procedures*\n   pointers:\n   fill_random 4 * 8\n\n   *; Here the core stores the address of the data to be processed*\n   data_pointer:\n   fill_random 8\n\n   *; And here the core stores its length in bytes*\n   data_length:\n   fill_random 8\n\n   *; Pseudorandom encryption key*\n   key:\n   fill_random 2\n\n*; The following line may be omitted if we used the postpone*\n*; directive instead of \"macro finalize\"*\nfinalize\n```", "```\nf_encrypt:\n   *; The if statement below, when the condition is TRUE, forces the assembler to produce*\n *; 32-bit code*\n   if (ACTIVE_TARGET = TARGET_W32_OBJ) |\\\n      (ACTIVE_TARGET = TARGET_W32_DLL) |\\\n      (ACTIVE_TARGET = TARGET_L32_O)\n      push eax ebx esi edi ecx\n      lea esi, [data_pointer]\n      mov esi, [esi]\n      mov edi, esi\n      lea ebx, [data_length]\n      mov ebx, [ebx]\n      lea ecx, [key]\n      mov cx, [ecx]\n      and cl, 0x07\n\n   *; Encryption loop*\n   @@:\n      lodsb\n      rol al, cl\n      xor al, ch\n      stosb\n      dec ebx\n      or ebx, 0\n      jnz @b\n\n      pop ecx edi esi ebx eax\n      ret\n\n*; In general, we could have omitted the \"if\" statement here,\n; but the assembler*\n*; should not generate any code at all, if \n; the value of ACTIVE_TARGET is not valid.*\n*; In either case, the following block is processed only\n; when we are expecting* *a 64-bit output*\n   else if (ACTIVE_TARGET = TARGET_W64_OBJ) |\\\n           (ACTIVE_TARGET = TARGET_W64_DLL) |\\\n           (ACTIVE_TARGET = TARGET_L64_O)\n      push rax rbx rsi rdi rcx\n      lea rsi, [data_pointer]\n      mov rsi, [rsi]\n      mov rdi, rsi\n      lea rbx, [data_length]\n      mov ebx, [rbx]\n      lea rcx, [key]\n      mov cx, [rcx]\n      and cl, 0x07\n\n   @@:\n      lodsb\n      rol al, cl\n      xor al, ch\n      stosb\n      dec rbx\n      or rbx, 0\n      jnz @b\n\n      pop rcx rdi rsi rbx rax\n      ret\n\n   end if \n```", "```\n*; Encryption loop*\n   @@:\n      lodsb\n      rol al, cl\n      xor al, ch\n      stosb\n      dec ebx\n      or ebx, 0\n      jnz @b\n```", "```\n@@:\n      lodsb\n      rol al, cl\n      xor al, ch\n      stosb\n      dec rbx\n      or rbx, 0\n      jnz @b\n```", "```\nxor al, ch\nror al, cl\n```", "```\nf_set_data_pointer:\n   if (ACTIVE_TARGET = TARGET_W32_OBJ) |\\\n      (ACTIVE_TARGET = TARGET_W32_DLL) |\\\n      (ACTIVE_TARGET = TARGET_L32_O)\n      push eax\n      lea eax, [esp + 8]\n      push dword [eax]\n      pop dword [data_pointer]\n      pop eax\n      ret\n\n   else if (ACTIVE_TARGET = TARGET_W64_OBJ) |\\\n           (ACTIVE_TARGET = TARGET_W64_DLL)\n      push rax\n      lea rax, [data_pointer]\n      mov [rax], rcx\n      pop rax\n      ret\n\n   else if (ACTIVE_TARGET = TARGET_L64_O)\n      push rax\n      lea rax, [data_pointer]\n      mov [rax], rdi\n      pop rax\n      ret\n\n   end if \n```", "```\nGetPointers:\n\n   if (ACTIVE_TARGET = TARGET_W32_OBJ) |\\\n      (ACTIVE_TARGET = TARGET_W32_DLL) |\\\n      (ACTIVE_TARGET = TARGET_L32_O)\n\n      push dword pointers\n      pop eax\n      mov [eax], dword f_set_data_pointer\n      mov [eax + 4], dword f_set_data_length\n      mov [eax + 8], dword f_encrypt\n      mov [eax + 12], dword f_decrypt\n      ret\n\n   else if (ACTIVE_TARGET = TARGET_W64_OBJ) |\\\n           (ACTIVE_TARGET = TARGET_W64_DLL) |\\\n           (ACTIVE_TARGET = TARGET_L64_O)\n\n      push rbx\n      mov rbx, pointers\n      mov rax, rbx\n      mov rbx, f_set_data_pointer\n      mov [rax], rbx\n      mov rbx, f_set_data_length\n      mov [rax + 8], rbx\n      mov rbx, f_encrypt\n      mov [rax + 16], rbx\n      mov rbx, f_decrypt\n      mov [rax + 24], rbx\n      pop rbx\n      ret\n\n   end if \n```", "```\n#ifdef WIN32                   *// For Windows platforms (MSVC)*\n#pragma pack(push, 1)          *// set structure member alignment to 1*\n#define PACKED                 \n#else                          *// Do the same for Unix based platforms* (GCC)\n#define PACKED  __attribute__((packed, aligned(1)))  \n#endif\n```", "```\n#ifdef WIN32                   *// For Windows platforms*\n#pragma pack(pop)              *// Restore previous alignment settings*\n#endif\n```", "```\n}crypto_functions_t, *pcrypto_functions_t;\n```", "```\n}PACKED crypto_functions_t, *pcrypto_functions_t;\n```", "```\ngcc -o test32 main.c crypto_32.o gcc -o test64 main.c crypto_64.o -m64\n```", "```\ngcc -o test32 main.c crypto_32.o -m32\n```", "```\n\ngcc -o test64 main.c crypto_64.o\n```", "```\n*# For 64-bit output on 64-bit machine*\ngcc -shared crypto_64.o -o libcrypto_64.so\n\n*# For 64-bit output on 32-bit machine*\ngcc -shared crypto_64.o -o libcrypto_64.so -m64\n\n*# For 32-bit output on 64-bit machine*\ngcc -shared crypto_32.o -o libcrypto_32.so -m32\n\n*# For 32-bit output on 32-bit machine*\ngcc -shared crypto_32.o -o libcrypto_32.so\n```", "```\n*// First of all, we tell the compiler how members of the*\n*//struct are stored in memory and alignment thereof*\n[StructLayout(LayoutKind.Sequential, Pack=1)]\n\n*// Then we implement the structure itself*\ninternal struct Funcs\n{\n   internal IntPtr f_set_data_pointer;\n   internal IntPtr f_set_data_length;\n   internal IntPtr f_encrypt;\n   internal IntPtr f_decrypt;\n}\n```", "```\ninternal class Crypto\n{\n   Funcs  functions;\n   IntPtr buffer;\n   byte[] data;\n\n   *// The following two lines make up the properties of the class*\n   internal byte[] Data { get { return data; } }\n   internal int Length { get { return data.Length; } }\n\n   *// Declare binding for GetPointers()*\n *// The following line is written for 64-bit targets, you should* \n *// change the file name to crypto_32.so when building for*\n *// 32-bit systems.\n   // Change the name to crypto_wXX.dll when on Windows, where XX* \n *// stands for 32 or 64.*\n   [DllImport(\"crypto_64.so\", CallingConvention = CallingConvention.Cdecl)]\n   internal static extern IntPtr GetPointers();\n\n   *// Declare delegates (our function pointers)*\n   [UnmanagedFunctionPointer(CallingConvention.Cdecl)]\n   internal delegate void dSetDataPointer(IntPtr p);\n\n   [UnmanagedFunctionPointer(CallingConvention.Cdecl)]\n   internal delegate void dSetDataSize(int s);\n\n   [UnmanagedFunctionPointer(CallingConvention.Cdecl)]\n   internal delegate void dEncrypt();\n\n   [UnmanagedFunctionPointer(CallingConvention.Cdecl)]\n   internal delegate void dDecrypt();\n\n   *// Constructor*\n   internal Crypto()\n   {\n      *// Luckily when we get a pointer to structure by calling* \n *// GetPointers() we do not have to do more than just let* \n *// the framework convert native structure to managed one*\n      functions = (Funcs)Marshal.PtrToStructure(\n         GetPointers(), \n         typeof(Funcs));\n\n      *// Set initial buffer ptr*\n      buffer = IntPtr.Zero;\n   }\n\n   *// SetDataPointer() method is the most complex one in our class,* \n *// as it includes invocation of SetDataLength()*\n   internal void SetDataPointer(byte[] p)\n   {\n      *// If an unmanaged buffer has been previously allocated,*\n *// then we need to free it first.*\n      if(IntPtr.Zero != buffer)\n         Marshal.FreeHGlobal(buffer);\n      buffer = Marshal.AllocHGlobal(p.Length);\n\n      *// Copy data to both the local storage and unmanaged buffer*\n      data = new byte[p.Length];\n      Array.Copy(p, data, p.Length);\n      Marshal.Copy(p, 0, buffer, p.Length);\n\n      *// Call f_set_data_pointer with a pointer to unmanaged buffer*\n      ((dSetDataPointer) Marshal.GetDelegateFromFunctionPointer(\n         functions.f_set_data_pointer, \n         typeof(dSetDataPointer)))(buffer);\n\n      *// Tell the core what the length of the data buffer is*\n      ((dSetDataSize) Marshal.GetDelegateFromFunctionPointer(\n         functions.f_set_data_length, \n         typeof(dSetDataSize)))(p.Length);\n   }\n\n   *// The remaining two methods are more than simple*\n   internal void Encrypt()\n   {\n      // Encrypt the data in the unmanaged buffer and copy it \n      // to local storage\n      ((dEncrypt)Marshal.GetDelegateFromFunctionPointer(\n         functions.f_encrypt, \n         typeof(dEncrypt)))();\n      Marshal.Copy(buffer, data, 0, data.Length);\n   }\n\n   internal void Decrypt()\n   {\n      // Decrypt the data in the unmanaged buffer and copy it\n      // to local storage\n      ((dDecrypt)Marshal.GetDelegateFromFunctionPointer(\n         functions.f_decrypt, \n         typeof(dDecrypt)))();\n      Marshal.Copy(buffer, data, 0, data.Length);\n   }\n}\n```", "```\nCrypto c = new Crypto();\nstring message = \"This program uses \\\"Crypto Engine\\\" written in Assembly language.\";\nc.SetDataPointer(ASCIIEncoding.ASCII.GetBytes(message);\nc.Encrypt();\nc.Decrypt();\n```"]