<html><head></head><body><div class="chapter" title="Chapter&#xA0;12.&#xA0;Network Forensics"><div class="titlepage"><div><div><h1 class="title"><a id="ch12"/>Chapter 12. Network Forensics</h1></div></div></div><p>Network forensics is a separate large area of Computer Forensics. It also includes various fields. Under network forensics, we should understand forensics where the main evidence is researched digital network traffic logs of network equipment, network applications, such as proxies, firewalls, servers, and so on.</p><p>Together with a conventional host-based network, forensics allows us to resolve the incident more efficiently. Information from the network layer provides a complete picture of what happened. Moreover, in some cases the analyst does not have access to these compromised machines because attackers use encryption, delete files, or use other techniques to hide information.</p><p>In cases of complex targeted attacks, initial network intrusion is only the first stage of an attack. The next steps for the promotion of the network, the development of the attack, the collection of information, and data exfiltration occur with the use of the network.</p><p>Network traffic data relates to the volatility, therefore, to collect network traffic that is necessary to perform a series of preparatory measures for the collection of data.</p><div class="section" title="Network data collection"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec74"/>Network data collection</h1></div></div></div><p>All data that can be retrieved from the network traffic can be divided into several levels:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Full Packet Capture 100%</li><li class="listitem" style="list-style-type: disc">Packet String Data 4%</li><li class="listitem" style="list-style-type: disc">Sessions 0.1%</li><li class="listitem" style="list-style-type: disc">Statistics</li><li class="listitem" style="list-style-type: disc">Logs</li></ul></div><p>It is obvious that, from the point of view of a forensics analyst, the most preferred method is to collect full traffic, as in this case, we obtain the most complete dataset.</p><p>However, along with the obvious advantages, this approach has a number of drawbacks. A large amount of data for storage and subsequent analysis requires a lot of time and resources.</p><p>At the same time, other forms of data, such as NetFlow, in many cases is a reasonable alternative, and it requires fewer resources for the collection and storage and to process.</p><p>Compared to other forms of full traffic, data altogether constitutes only a few percent. It require less space for storage and, therefore, can be stored for a longer time period.</p><p>For clarity, consider the following example. Let's suppose an organization has a daily volume of network traffic in a 1 TB per day on weekdays and 100 GB over the weekend, while the weekly storage data volume requires 5.2 TB.</p><p>The data in other formats require <span class="emphasis"><em>5200 * 0.041 = 213.2 MB</em></span> per week. Thus, the total amount required for data storage is the weekly amount 5.4 TB or an average of approximately 770 MB per day.</p><p>If we talk about the need to ensure a minimum of three months storage, it will require 69 TB space on the disc. In addition to the processing of such large amounts of data, it requires a lot of time and power equipment.</p><p>However, this problem can be solved by a combined approach to the collection and analysis of network data. Namely, it is possible to store a complete traffic only for a week and the rest of the data for the year.</p><p>Thus, the storage network data for the year 5200 will need <span class="emphasis"><em>0.041 + 5200 * / 7 * 365 = 16.32 TB</em></span>.</p><p>As mentioned earlier, the Full Packet Capture data collection and NetFlow prerequire arrangements to collect the data before the incident. Unfortunately, often at the time of the incident, it appears that the organization has no Full Packet Capture, no NetFlow data. In this case, our only hope is that the processes of logging has been enabled on the server and networking equipment.</p><p>Next, consider the work with different data types, as often forensics analysts work with data that is available at the moment of working on the incident.</p></div></div>
<div class="section" title="Exploring logs"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec75"/>Exploring logs</h1></div></div></div><p>The most ubiquitous connectivity options of the corporate network to the Internet is to use a proxy server. Moreover, all protocols except HTTP and HTTPS are blocked by a firewall. Therefore, we consider this particular scheme. A proxy server is a server that is an intermediary between the client and server. Proxies can be used for almost any network protocol, but they are most often used for the web traffic for HTTP and HTTPS.</p><p>In this case, a forensics analyst usually has a data proxy server. Proxy logs are invaluable in analyzing what URL is accessing the corporate network machines. Analysis of the logs of the proxy server allows you to quickly identify which workstations are exposed to a malicious resource. This is done much faster than in the analysis of each client machine.</p><p>Typically, proxy logs include not only the time and IP address of the client and the URL, but they also include the status of the HTTP response and the username:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Unix timestamp (<code class="literal">sec.ms</code>)</li><li class="listitem" style="list-style-type: disc">Response time (<code class="literal">ms</code>)</li><li class="listitem" style="list-style-type: disc">Requestor IP/name</li><li class="listitem" style="list-style-type: disc">Cache status and HTTP status code</li><li class="listitem" style="list-style-type: disc">Reply size (bytes)</li><li class="listitem" style="list-style-type: disc">Request method (GET, POST, and so on)</li><li class="listitem" style="list-style-type: disc">URL requested</li><li class="listitem" style="list-style-type: disc">Username (if available)</li><li class="listitem" style="list-style-type: disc">Squid hierarchy status and Server IP / peer name</li><li class="listitem" style="list-style-type: disc">MIME type</li></ul></div><p>Also, caching the proxy server allows you to store additional copies of all the requested objects. In some cases, this is the only way to obtain the necessary files and perform the analysis.</p><p>Today there are many different proxies, both commercial and free. However, probably the most popular at the moment is Squid. Among the free servers, NGINX can also be noted.</p><p>There are also a number of commercial solutions both hardware and in software form. Among commercial proxies, one of the most popular is the BlueCoat proxy. Among its advantages is its ability to proxy SSL traffic.</p><p>Other popular solutions in the corporate environment are ForeFront Threat Managment Gateway (formerly, Microsoft ISA Server) and the decision of the Barracuda Network.</p><p>All of them have their own formats of log files, and we will not consider all of these decisions. We will focus on a detailed examination of Squid.</p><p>As noted earlier, Squid is one of the most popular and free solutions formed around a large community of users. This decision can be found in both small networks and large enterprises. Squid has great potential, and it is relatively easy to install.</p><p>An experienced administrator can configure Squid as a caching server with different filtering rules for different file types and a large number of additional options. All these settings are in the Squid configuration file, and they must be copied for analysis along with the log files. The default configuration file is located in <code class="literal">/etc/squid/squid.conf</code>. This file is well documented and explains many settings in the configuration file, specified as the location of the log files and cache.</p><p>Log files contain information about all client requests made via the HTTP protocol. The cache directory contains responses from web servers to clients. During the investigation, the analyst can get all the files and analyze them.</p><p>By default, Squid provides a lot of information about every request it receives from customers. Thus, during the investigation, the analyst can get all objects from HTTP traffic passing through the proxy. Attackers often use the HTTP protocol to deliver malicious software as well as as a means of communication to communicate with the C &amp; C servers, so proxy is a good place to collect information about such activity.</p><p>Usually entry in the log file of the proxy server Squid (<code class="literal">access.log</code>) is as follows:</p><pre class="programlisting">
<span class="strong"><strong>|12345678910.134|534|129.134.21.51|TCP MISS/200|1345|GET|http://www.123.cc|-|DIRECT/134.41.65.13|text/htm|</strong></span>
</pre><p>It is worth noting that the query string is logged and does not default. To remedy this situation, it is necessary to make a corresponding change in the configuration file, namely this line:</p><pre class="programlisting">
<span class="strong"><strong>strip_query_terms off</strong></span>
</pre><p>Besides this, it is also useful to include logging the following information:</p><pre class="programlisting">
<span class="strong"><strong>User_Agent</strong></span>
<span class="strong"><strong> Referer</strong></span>
</pre><p>These options can be particularly useful in investigations. Also, since the Squid 2.6 version, you now have the opportunity to ask your own log format via the <code class="literal">logformat</code> option in the configuration file.</p><p>Thus, the administrator can specify an alternate log file and format string.</p><p>Let's take the following example:</p><pre class="programlisting">
<span class="strong"><strong>logformat customlogformat %tl %a&gt; "%rm %ru HTTP/%rv"
    %&gt;Hs %&lt;st "%{Referer}&gt;h""%{User-Agent}&gt;h" %Ss:%Sh</strong></span>
<span class="strong"><strong>access_log /var/log/squid/access.log customlogformat</strong></span>
</pre><p>As the Squid log file is simply a text file, it is easy to automate using scripting languages and command-line utilities. There is also a large number of different log file analyzers in Squid. Here are some of them:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Squidview: <a class="ulink" href="http://www.rillion.net/squidview/">http://www.rillion.net/squidview/</a></li><li class="listitem" style="list-style-type: disc">Calamaris: <a class="ulink" href="http://cord.de/calamaris-english">http://cord.de/calamaris-english</a></li><li class="listitem" style="list-style-type: disc">SARG: <a class="ulink" href="http://sourceforge.net/projects/sarg/">http://sourceforge.net/projects/sarg/</a></li></ul></div><p>Each has its advantages and disadvantages, so you need to choose the most appropriate:</p><pre class="programlisting">
<span class="strong"><strong>Full Packet Capture</strong></span>
</pre><p>Consider the case when the disposal of such, analysts have a full dump of the network traffic. In some cases, recording network traffic is included in the investigation of the incident after the incident and detection. Even in this situation, network traffic analysis can greatly enhance the effectiveness of the investigation.</p><p>To capture network traffic, the most often used format is the PCAP format. This format is supported by most of the tools for data collection, analysis, and detection.</p><p>Most of the popular utilities are built on the <code class="literal">libpcap</code> library, including <code class="literal">tcpdump</code> and <code class="literal">wireshark</code>, and they have similar functionality.</p></div>
<div class="section" title="Using tcpdump"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec76"/>Using tcpdump</h1></div></div></div><p>The <code class="literal">tcpdump</code> tool is used to collect and analyze network packets. It is ideal for the analysis of individual packages and for their consistency. In the case of automatic processing, <code class="literal">tcpdump</code> has several advantages.</p><p>To read a previously recorded <code class="literal">pcap</code> file, you can use the following command:</p><pre class="programlisting">
<span class="strong"><strong>tcpdump -nnr dump.pcap</strong></span>
</pre><p>The default <code class="literal">tcpdump</code> displays information about each packet, while the output format is protocol-dependent:</p><pre class="programlisting">
<span class="strong"><strong>TCP:
</strong></span>
<span class="strong"><strong>[Timestamp] [Layer 3 Protocol] [Source IP].
    [Source Port]&gt; [Destination IP]. [Destination Port]:
    [TCP Flags], [TCP Sequence Number],
    [TCP Acknowledgement Number], [TCP Windows Size] ,
    [Data Length]
</strong></span>
<span class="strong"><strong>UDP:
</strong></span>
<span class="strong"><strong>[Timestamp] [Layer 3 Protocol] [Source IP].
    [Source Port]&gt; [Destination IP]. [Destination Port]:
    [Layer 4 Protocol], [Data Length]</strong></span>
</pre><p>In addition to make the output more informative, <code class="literal">-v -vvv</code> can be used, as in the following example:</p><pre class="programlisting">
<span class="strong"><strong>tcpdump -nnvvvr dump.pcap</strong></span>
</pre><p>With the <code class="literal">-x</code> option, you can make <code class="literal">tcpdump</code> output packets in the <code class="literal">heh</code> format or into ASCII using<code class="literal">-A</code> or <code class="literal">-X</code>, and <code class="literal">tcpdump</code> allows you to output in two formats simultaneously.</p><p>In many cases, especially when handling large <code class="literal">pcap</code> files, the ability to use filters to discard unnecessary data is particularly useful. The <code class="literal">tcpdump</code> tools allows BPF filters. For example, to filter only TCP packets to port <code class="literal">80</code>, you can use the following command:</p><pre class="programlisting">
<span class="strong"><strong>tcpdump -nnr dump.pcap tcp dst port 80</strong></span>
</pre><p>To write the filtered data to a file you must use the <code class="literal">-w</code> option, as follows:</p><pre class="programlisting">
<span class="strong"><strong>tcpdump - nnr dump.pcap 'tcp dst port 80' -w 80_tcp_dump.pcap</strong></span>
</pre><p>Sometimes, it is necessary to use a set of filters, and in this case, it is more convenient to write the filter set in the file and, thus, to use a file with the <code class="literal">-F</code> optional filters:</p><pre class="programlisting">
<span class="strong"><strong>tcpdump -nnr dump.pcap -F filter.bpf</strong></span>
</pre><p>For more information on the various keys to use <code class="literal">tcpdump</code>, use the <code class="literal">man tcpdump</code> command.</p></div>
<div class="section" title="Using tshark"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec77"/>Using tshark</h1></div></div></div><p>Another useful tool for the analysis of <code class="literal">pcap</code> files is <code class="literal">tshark.</code></p><p>The <code class="literal">tshark</code> tool is a console version WireShark. <code class="literal">tshark</code> has virtually the same functionality as <code class="literal">tcpdump,</code> but it adds the possibility of a WireShark protocol analyzer and uses syntax to filter.</p><p>To read a previously recorded <code class="literal">pcap</code> file the <code class="literal">-r</code> option is also used. The output format depends on the protocol. Thus, <code class="literal">tshark</code> shows application-level information.</p><p>To obtain additional information, use the <code class="literal">-V</code> option. To display packets in hex and ASCII formats, use the <code class="literal">-x</code> option.</p><p>Tshark allows the use of filters capture when using syntax that is similar to tcpdump's BPF, and display filters can be used when the built-in protocol analyzers.</p><p>For the use of, filters should be used with the <code class="literal">-f</code> option and the <code class="literal">-R</code> recording and read option. So to read <code class="literal">pcap</code> file of DNS traffic, you can use the following command:</p><pre class="programlisting">
<span class="strong"><strong>tshark -r dump.pcap -R 'udp &amp;&amp; dst.port == 53'</strong></span>
</pre><p>Another useful feature is the ability to generate tshark statistics from the analyzed traffic. To do this, use the <code class="literal">-z</code> option. A full list of the available statistics are available through the man pages on tshark.</p><p>For example, to view statistics on http traffic, you can use the following command:</p><pre class="programlisting">
<span class="strong"><strong>tshark -r dump.pcap -z http, tree</strong></span>
</pre><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>IO</strong></span>,<span class="strong"><strong>phs</strong></span>: This displays the results in a <code class="literal">pcap</code> file protocols</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>HTTP</strong></span>,<span class="strong"><strong>tree</strong></span>: This displays statistics from HTTP requests and responses</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>SMB</strong></span>,<span class="strong"><strong>srt</strong></span>: This displays statistics relating to the SMB commands</li></ul></div><p>However, even so, despite the fact that in some cases command-line utilities are well suited for the analysis of packets at a fundamental level, it is better to use GUI tools such as WireShark for some tasks.</p></div>
<div class="section" title="Using WireShark"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec78"/>Using WireShark</h1></div></div></div><p>WireShark is used to address various issues that are related to the functioning of the network by network administrators, but it also plays an invaluable role in cases of network traffic analysis in investigations of incidents.</p><p>The WireShark interface can be divided into three main parts.</p><p>The upper part displays the list of packages. Each package information is available. By default, the packet number, timestamp, source, and destination address, protocol, packet length, and special protocols for different information.</p><p>The middle section displays detailed information about the package, which is selected in the upper part.</p><p>The bottom window displays the individual bytes package to hex and ASCII formats such as conclusions team tcpdump, <code class="literal">-X</code>.</p><p>The data in all windows are connected to each other; thus, when we choose data in one window, associated data is highlighted in the other windows.</p><p>Wireshark has a lot of possibilities to analyze network packets. Therefore, to describe them in a single chapter is almost impossible. There are several good books that reveal these features in detail, namely <span class="emphasis"><em>Practical Packet Analysis</em></span> and <span class="emphasis"><em>Wireshark Network Analysis</em></span>.</p><p>In some cases, the timestamps are the only binding element in the investigation. For example, sometimes the analyst knows only the approximate time of the incident and that they have to filter traffic for a certain period of time. The default WireShark displays the timestamps of packets in seconds from the start of the recording of traffic in the <code class="literal">pcap</code> file. Changing the display format of this can be done through the menu, as follows: <span class="strong"><strong>View</strong></span> |<span class="strong"><strong>Time Display Format</strong></span> |<span class="strong"><strong>Date and Time of Day</strong></span>.</p><p>In order not have to perform this action every time, you can change these settings in Wireshark, as follows: <span class="strong"><strong>Edit</strong></span> |<span class="strong"><strong>Preferences</strong></span></p><p>In some cases, it is important to get a general idea of the analyzed traffic.</p><p>You can use the <span class="strong"><strong>Statistics</strong></span> menu item. This displays a wealth of information and statistics on the traffic collected.</p><p>For example, Protocol Hierarchy provides a list of all identified in the traffic reports and statistics on them. Very often, this helps identify anomalies in the traffic, for example, in the case of tunneling via DNS or ICMP.</p><p>In addition to this, WireShark allows you to group the traffic on the traffic between the different hosts. Thus, it is possible to determine the amount of transferred data between different machines. Statistics on the machines can be viewed via <span class="strong"><strong>Statistic</strong></span> | <span class="strong"><strong>Endpoints</strong></span>, and various conversations can be viewed through <span class="strong"><strong>Statistics</strong></span> | <span class="strong"><strong>Conversations</strong></span>.</p><p>In some cases, there are situations when it is necessary to analyze the data exchanged between two specific hosts. You can use the <code class="literal">Following TCPStream</code> option. WireShark allows you to perform such actions for UDP, HTTP, and SSL.</p><p>Another useful WireShark option that should be mentioned is the extraction of the responses from the network traffic. WireShark allows you to extract objects from the HTTP, SMB, and DICOM streams. To do this, use navigate to <span class="strong"><strong>File</strong></span> |<span class="strong"><strong>Export</strong></span> |<span class="strong"><strong>Objects</strong></span> |<span class="strong"><strong>HTTP</strong></span>.</p><p>Then, select a file from the displayed list of files, and use the <span class="strong"><strong>Save As</strong></span> to save the file. It should be noted that the need to extract the file, all packets of network traffic in the case of at least one <code class="literal">otsutviya</code> package relating to the transfer of the file to get it will not succeed.</p><p>Note that you can extract files from traffic using a number of other utilities, such as NetworkMiner or Bro. We discuss On Bro in more details later in this chapter.</p><p>The default setting displays a specific list of columns in WireShark with the data about the packets, as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The batch number</li><li class="listitem" style="list-style-type: disc">The timestamp</li><li class="listitem" style="list-style-type: disc">The source address</li><li class="listitem" style="list-style-type: disc">The location receiver</li><li class="listitem" style="list-style-type: disc">Protocol</li><li class="listitem" style="list-style-type: disc">The length of the packet</li></ul></div><div class="section" title="Fields with more information"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec110"/>Fields with more information</h2></div></div></div><p>In some cases, this may require additional information, such as port numbers of the receiver and the source or method of the HTTP request.</p><p>Consider the following steps that must be completed in order to add a new column with the data on the method that is used by HTTP:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Start with the WireShark <code class="literal">pcap</code> traffic test.</li><li class="listitem">Find the HTTP packet containing the HTTP request method, such as GET or POST. This can be done manually or by entering the <code class="literal">http.request</code> filter.</li><li class="listitem">Select the HTTP packet in the window with packets, then expand the HTTP header, and find a site with the <span class="strong"><strong>Method Request</strong></span> field.</li><li class="listitem">Select the field, and right-click on it to select <span class="strong"><strong>Â«Apply as ColumnÂ»</strong></span>.</li></ol></div><p>After these actions a new column should appear. You can later change the name and other attributes of the column.</p><p>Often, WireShark plays an invaluable role in the analysis of network traffic that is required to handle large quantities of data and rich filtering. To filter data using Wireshark BPF filters. BPF filters are the most common method of filtering network utilities, including Wireshark, tcpdump, tshark, and so on.</p><p>BPF filters can be used both during the traffic data collection and the analysis data. Consider the structure BPF filter, and a folder created by the BPF, which is called expression syntax. The expression includes one or more primitives that can be combined by operators. The primitives, in turn, are made up of qualifiers and the following values.</p><p>There are three types of qualifier, as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Type:</strong></span><code class="literal">host</code>, <code class="literal">net</code>, and <code class="literal">port</code></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Dir:</strong></span><code class="literal">src</code> and <code class="literal">dst</code></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Proto:</strong></span><code class="literal">ether</code>, <code class="literal">fddi</code>, <code class="literal">ip</code>, <code class="literal">arp</code>, <code class="literal">rarp</code>, <code class="literal">decnet</code>, <code class="literal">lat</code>, <code class="literal">sca</code>, <code class="literal">moprc</code>, <code class="literal">mopdl</code>, <code class="literal">tcp</code>, and <code class="literal">udp</code>.</li></ul></div><p>Here is an example with several primitives:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">dst host host</li><li class="listitem" style="list-style-type: disc">src host host</li><li class="listitem" style="list-style-type: disc">host host</li><li class="listitem" style="list-style-type: disc">ether src ehost</li><li class="listitem" style="list-style-type: disc">gateway host</li></ul></div><p>A full list of primitives can be found in the main pages for the <code class="literal">tcpdump</code> utility.</p><p>Primitives are grouped and can be combined using the following operators:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Negation (<code class="literal">!</code> Or <code class="literal">not</code>)</li><li class="listitem" style="list-style-type: disc">Concatenation (<code class="literal">&amp;&amp;</code> or <code class="literal">and</code>)</li><li class="listitem" style="list-style-type: disc">Alternation (<code class="literal">||</code> or <code class="literal">or</code>)</li></ul></div><p>More information about the BPF syntax can be found on the main page.</p></div></div>
<div class="section" title="Knowing Bro"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec79"/>Knowing Bro</h1></div></div></div><p>Another tool to analyze network traffic is Bro. Bro is a very powerful tool, which is often positioned as an IDS, but the possibilities are much wider with Bro. Discussing all of them in a single chapter is almost impossible, so we will consider only some of them. One of the many advantages of Bro is the ability to use ready-made parsers different protocols.</p><p>For example, the following are some of them:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">DHCP</li><li class="listitem" style="list-style-type: disc">DNS</li><li class="listitem" style="list-style-type: disc">FTP</li><li class="listitem" style="list-style-type: disc">HTTP</li><li class="listitem" style="list-style-type: disc">POP3</li><li class="listitem" style="list-style-type: disc">SMTP</li><li class="listitem" style="list-style-type: disc">SSH</li></ul></div><p>The list of these protocols is constantly expanding.</p><p>By default, Bro applies the protocol analyzers to traffic, and it records the results in the log files that correspond to different protocols.</p><p>Bro also allows you to write your own handlers in a language called Bro. For each event that occurs during the processing of the event may be caused by its handler.</p><p>For example, consider the following simple event handler discovery file:</p><pre class="programlisting">event file_new (f: fa_file) { 
local fname = fmt ("% s", f $ id) 
Files :: add_analyzer (f, Files :: ANALYZER_EXTRACT, [$ extract_filename = fname]) 
} 
</pre><p>Next, remove all files from the traffic to keep this code in a file, run the <code class="literal">getfiles.bro</code> command:</p><pre class="programlisting">
<span class="strong"><strong>bro -C -r traffic.pcap getfiles.bro</strong></span>
</pre><p>The following is the output of the preceding command:</p><div class="mediaobject"><img src="graphics/image_12_001.jpg" alt="Knowing Bro"/></div><p>After running this command, the catalog files are created, as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">conn.log</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">files.log</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">http.log</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">ssl.log</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">ftp.log</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">dns.log</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">weird.log</code></li></ul></div><p>These files contain information about the network traffic for certain protocols. For example, <code class="literal">http.log</code> contains the following fields.</p><p>In addition to the log files in the startup directory that is created by Bro, <code class="literal">extract_files</code> lists which files are extracted from the traffic. For each file in this directory, you can find the corresponding entry in the <code class="literal">files.log</code> file. This entry contains a number of attributes, which are useful.</p><p>To analyze the contents of these log files in the distribution utility has Bro <code class="literal">bro-cut</code>. The input to this utility is passed through the pipe contents of the log file, and it specifies the list of fields to be filtered.</p><p>For example, to list the types of files extracted from the traffic, you can use the following command:</p><pre class="programlisting">
<span class="strong"><strong>cat files.log | bro-cut mime_type | sort | uniq</strong></span>
</pre><p>The following is the output of the preceding command:</p><div class="mediaobject"><img src="graphics/image_12_002.jpg" alt="Knowing Bro"/></div><p>Let's assume that we are investigating an incident of a viral infection, in which case the most interesting types of files are as follows:</p><pre class="programlisting">
<span class="strong"><strong>application / jar</strong></span>
<span class="strong"><strong>application / x-dosexec</strong></span>
</pre><p>These are executable files on MS Windows files and the Java virtual machine.</p><p>Then, we learn more about the following files of interest:</p><pre class="programlisting">
<span class="strong"><strong>cat files.log | bro-cut -u ts, rx_hosts, tx_hosts,
    source, mime_type, total_bytes, fuid | grep -iE "{jar |
    x-dosexec}"</strong></span>
</pre><p>The following is the output of the preceding command:</p><div class="mediaobject"><img src="graphics/image_12_003.jpg" alt="Knowing Bro"/></div><p>These results allow the team to set time, download the resource files, and download the protocol by which to transfer these files. You can then find these files in the <code class="literal">extract_files</code> directory and analyze them.</p><p>For more information about the resource files, go to the IP address <code class="literal">85.17.137.151 92,123,155,154</code>, and you can use the data from the <code class="literal">dns.log</code> file.</p><p>The <code class="literal">dns.log</code> file is the result of Bro, and it describes the events, permits, and changes domain names into IP addresses and vice versa. The request to the DNS server is represented by a query attribute. The server's response attribute is <code class="literal">answer</code>, and <code class="literal">ts</code> is the timestamp request:</p><pre class="programlisting">
<span class="strong"><strong>cat dns.log | bro-cut -u ts, query, answer | grep -iE
    "85.17.137.151 | 92.123.155.154 "</strong></span>
</pre><p>The following is the output of the preceding command:</p><div class="mediaobject"><img src="graphics/image_12_004.jpg" alt="Knowing Bro"/></div><p>The result is that the IP address <code class="literal">85.17.137.151</code> resolves to domains <code class="literal">finansial.gov</code> and <code class="literal">w282d1wb.athleticsdrycleaner.pw</code>.</p><p>The IP address <code class="literal">92.123.155.154</code> belongs to <code class="literal">microsoft.com</code>, which greatly reduces the likelihood that the downloaded file is malicious.</p><p>On the basis of the allocated domain names of the <code class="literal">http.log</code> file can obtain the following information:</p><pre class="programlisting">
<span class="strong"><strong>cat http.log | bro-cut -u ts, id.orig_h, method, uri,
    response_body_len, resp_fuid, host | grep -iE
    "finansial.gov $"</strong></span>
</pre><p>The following is the output of the preceding command:</p><div class="mediaobject"><img src="graphics/image_12_005.jpg" alt="Knowing Bro"/></div><p>This suggests that the user downloaded a file from the resource <code class="literal">finansial.gov utisl.jar</code> protocol HTTP (the previously mentioned <code class="literal">FUJlhk2BEJTsb8tozk.jar.jar</code> file). Then, from the same resource, the <code class="literal">'2' (Fy9phB2NNXKNHKuyHb.exe)</code> file was downloaded:</p><div class="mediaobject"><img src="graphics/image_12_006.jpg" alt="Knowing Bro"/></div><p>Additionally, you must pay attention to suspicious HTTP-POST <code class="literal">gate.php</code> requests.</p><p>The <code class="literal">resp_fuids</code> attribute identifies a response from the Web server, and this indicates any appropriate entry in the <code class="literal">files.log</code> file. Thus, the <code class="literal">FI ... Ug</code> identifier can get the <code class="literal">finansial.gov</code> server's response in the GET request:</p><div class="mediaobject"><img src="graphics/image_12_007.jpg" alt="Knowing Bro"/></div><p>From the replies provided, it is clear that <code class="literal">utisl.jar</code> is a java-applet. The client opens a page in a frame of the legal site, <code class="literal">www.efinancialnews.com</code>.</p><p>This small example is a clear demonstration of how it is possible to investigate with only file traffic using Bro.</p><p>However, the example shows only a small part of all possibilities of Bro. To learn about Bro's other capabilities, you can visit <a class="ulink" href="https://www.bro.org/">https://www.bro.org/</a>, where you can find a lot of additional material.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec80"/>Summary</h1></div></div></div><p>In this chapter, we discussed some topics on network forensics. We learned what kind of data we could collect from a network and how to analyze logs from a proxy server. Also from this chapter, we learned how to collect <code class="literal">pcap</code> files and how to analyze them with WireShark and Bro.</p><p>In the following chapter, you will learn how to build a forensic environment. We will describe two approaches; one of them is virtualization, and another one uses distributed systems. We will describe GRR as an example of a distributed system.</p></div></body></html>