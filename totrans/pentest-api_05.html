<html><head></head><body>
		<div><h1 id="_idParaDest-76" class="chapter-number"><a id="_idTextAnchor078"/>5</h1>
			<h1 id="_idParaDest-77"><a id="_idTextAnchor079"/>Injection Attacks and Validation Testing</h1>
			<p>We are starting a new part of the book. So far, you have had an introduction to API security, how we can acquire more data about the target – with the important reconnaissance and information gathering chapter – and learned ways to test both authentication and authorization mechanisms most APIs implement nowadays. Now, it’s time to dive deeper into the waters of attacks. This part starts with injection and validation (or the lack of it) testing.</p>
			<p>These kinds of attacks are not new at all, but it’s impressive how often they show up in media <a id="_idIndexMarker392"/>headlines around the world, affecting pretty much all kinds and sizes of companies. Hopefully, you already know they are not limited to <strong class="bold">Structured Query Language</strong> (<strong class="bold">SQL</strong>), but if you don’t, that’s perfectly fine, as you will learn about them.</p>
			<p>In this chapter, we start with an introduction of what exactly injection attacks are and which kinds of vulnerabilities can arise from a lack of attention to them. We then do some practical exercises with both SQL-related and NoSQL-related attacks, and we finish the chapter with a discussion about user input and the importance of validating it and sanitizing it.</p>
			<p>In this chapter, we’re going to cover the following main topics:</p>
			<ul>
				<li>Understanding injection vulnerabilities</li>
				<li>Testing for SQL injection</li>
				<li>Testing for NoSQL injection</li>
				<li>Validating and sanitizing user input</li>
			</ul>
			<h1 id="_idParaDest-78"><a id="_idTextAnchor080"/>Technical requirements</h1>
			<p>We’ll leverage the same environment as the one pointed out in <a href="B19657_03.xhtml#_idTextAnchor042"><em class="italic">Chapter 3</em></a>. In summary, you’ll <a id="_idIndexMarker393"/>need a type 2 hypervisor, such as VirtualBox, and the same tools we used before – especially the <strong class="bold">Completely Ridiculous API</strong> (<strong class="bold">crAPI</strong>) project.</p>
			<h1 id="_idParaDest-79"><a id="_idTextAnchor081"/>Understanding injection vulnerabilities</h1>
			<p>Injection attacks are pretty easy to understand and sometimes to execute as well. They simply consist of inserting unexpected data, usually crafted commands or keywords, inside an input <a id="_idIndexMarker394"/>that should only contain specific data, such as a username and/or a corresponding password. By leveraging different formats, such as another encoding, or by adding commands to the input, a badly implemented API’s backend would inadvertently execute those commands or try to interpret the exceptional encoding, which could cause general failure and possible data leakage.</p>
			<p>The possibly most famous variation of this attack affects SQL databases, and they are frequently <a id="_idIndexMarker395"/>called <strong class="bold">SQLi</strong> (“<strong class="bold">i</strong>” for <strong class="bold">injection</strong>) attacks. This happens because many publicly available applications and API endpoints interact with relational databases on their backend’s infrastructure. On the other hand, some other applications make use of unstructured data, which makes them candidates for NoSQL databases. But even so, the latter ones are also susceptible to the threat.</p>
			<p>You can inject code or spurious data either by building a request you’ll send to an API endpoint or by filling fields on a form that expects you, for example, to provide a comment on some product or service you recently acquired. Imagine for a moment that among your comments with satisfaction on buying that new video game, you add something such as “<em class="italic">DROP DATABASE products;</em>”. When the API endpoint code reads that comment, instead of returning it as an answer to a request, it will instead execute it and erase the entire <code>products</code> database.</p>
			<p>There are other types of injection attacks besides SQL and NoSQL, such as the following:</p>
			<ul>
				<li><strong class="bold">Lightweight Directory Access Protocol (LDAP) injection</strong>: This attack targets <a id="_idIndexMarker396"/>LDAP servers used for authentication and authorization. If an API endpoint interacts with LDAP for user login, an attacker could inject malicious code into username or password fields. This code could exploit vulnerabilities in how the API constructs LDAP queries, potentially allowing the attacker to bypass authentication, steal user credentials from the directory server, or disrupt directory services, impacting user access to various systems. Mitigating <a id="_idIndexMarker397"/>LDAP injection requires ensuring proper input validation and escaping <a id="_idIndexMarker398"/>of special characters within user-supplied credentials before constructing LDAP queries.</li>
				<li><strong class="bold">GraphQL injection</strong>: With the growing popularity of GraphQL APIs, attackers are <a id="_idIndexMarker399"/>devising ways to exploit vulnerabilities in how these APIs <a id="_idIndexMarker400"/>handle user input. Malicious queries can exploit weaknesses in query validation to gain unauthorized <a id="_idIndexMarker401"/>access to data, manipulate data returned by the API, or even trigger <strong class="bold">denial-of-service</strong> (<strong class="bold">DoS</strong>) attacks by crafting complex and resource-intensive queries. Preventing GraphQL injection requires implementing robust input validation techniques for all user-supplied data within GraphQL queries and enforcing query complexity limitations to prevent resource exhaustion attacks.</li>
			</ul>
			<p>Over the last few years, there have been several reports covering injection attacks and their damage <a id="_idIndexMarker402"/>to companies and their customers. In 2017, the Equifax data breach, one of the largest data breaches in history, was caused by a vulnerability in an Apache Struts application. Struts is a web application framework used in several applications on the internet. This vulnerability allowed attackers to execute SQL injection attacks and steal the personal information of over 147 million individuals. In <em class="italic">Figure 5</em><em class="italic">.1</em>, you see a small, compiled list of some news covering injection attacks:</p>
			<div><div><img src="img/B19657_05_01.jpg" alt="Figure 5.1 – News about injection attacks"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.1 – News about injection attacks</p>
			<p>Injection can <a id="_idIndexMarker403"/>also happen in <strong class="bold">graphical user interface</strong> (<strong class="bold">GUI</strong>) scenarios. Another vulnerability affecting Apache Struts was discovered in 2018. This vulnerability allowed attackers to execute remote code injection attacks through the Struts REST API. Recorded under <em class="italic">CVE-2018-11776</em>, it affected millions of web applications worldwide and underscored the importance of securing <a id="_idIndexMarker404"/>API endpoints against injection attacks.</p>
			<p><strong class="bold">XML External Entity</strong> (<strong class="bold">XXE</strong>) injection is another injection attack vector that targets APIs parsing XML input. In 2019, Atlassian, the player behind some widely used applications such as Jira suite, Confluence, and Bitbucket, was affected by a vulnerability that targeted <a id="_idIndexMarker405"/>its Jira Service Management Data Center and Jira Service Management Server solutions. Detailed on <em class="italic">CVE-2019-13990</em>, this vulnerability allowed authenticated users to initiate XXE attacks through job descriptions. The vulnerable code was located on a specific third-party component: Terracotta Quartz Scheduler.</p>
			<p>NoSQL injection targets NoSQL databases by crafting especially prepared queries to aim sometimes undiscovered and sometimes widely known vulnerabilities in query parsing and execution. In 2020, a security researcher discovered a NoSQL injection vulnerability in a popular <strong class="bold">mobile backend-as-a-service</strong> (<strong class="bold">MBaaS</strong>) platform, Firebase. During an Android <a id="_idIndexMarker406"/>analysis as part of a bug bounty program, they discovered how attackers could bypass authentication and access sensitive user data stored in Firebase databases.</p>
			<p>Beyond traditional injection attacks, command injection (and its counterpart, OS command injection) vulnerabilities in API endpoints can also lead to severe security breaches, and not even cyber security players are safe from this way of intruding into a system. Fortinet <a id="_idIndexMarker407"/>got caught with <em class="italic">CVE-2023-36553</em> when its FortiSIEM (<strong class="bold">security information and event management</strong>, or <strong class="bold">SIEM</strong>) platform had a vulnerability that allowed attackers to inject commands in API requests. In the same year, it was Palo Alto’s turn. One of its firewalls was discovered to be vulnerable to an API command injection vulnerability, allowing authenticated API users to inject commands on the device’s operating system, PAN-OS.</p>
			<p>API injection <a id="_idIndexMarker408"/>attacks highlight the importance of implementing robust input validation and sanitization mechanisms in API endpoints. By validating and sanitizing user input, developers can prevent injection attacks and mitigate the risk of data breaches and unauthorized access. Additionally, organizations should regularly perform security assessments and penetration testing to identify and remediate vulnerabilities in their API infrastructure.</p>
			<p>Time for practice! Let’s see how injection works in practical terms.</p>
			<h1 id="_idParaDest-80"><a id="_idTextAnchor082"/>Testing for SQL injection</h1>
			<p>OK – now that you know the major types of injection attacks, let’s explore the one that is possibly <a id="_idIndexMarker409"/>the oldest while, at the same time, the most applied nowadays: injection on SQL databases. This kind of attack can vary from a very simple <code>OR</code> clause as part of user input to the complexity and sophistication of union and hidden union attacks, where multiple SQL statements can be combined to form an <em class="italic">explosive</em> payload. The first step, though, is not to attack the database behind the API endpoint but to fingerprint it. This can substantially reduce your effort in selecting techniques. By trying with some random input, you can force an unprepared API to return useful database error messages. Some engines reveal themselves in such error messages.</p>
			<p>The following snippet shows a typical error message from Microsoft SQL Server:</p>
			<pre class="console">
Connection failed:
SQLState: '08001'
SQL Server Error: 21
[Microsoft][SQL Server Native Client 11.0]Client unable to establish connection</pre>			<p>Likewise, the following snippet contains an error message from MariaDB or its “cousin” MySQL:</p>
			<pre class="source-code">
java.sql.SQLSyntaxErrorException: You have an error in your SQL syntax; check the manual that corresponds to your MariaDB server version for the right syntax to use near 'form category' at line 1</pre>			<p>This is an <a id="_idIndexMarker410"/>error message from an Oracle Database server. This product throws codes starting with <code>ORA</code>:</p>
			<pre class="source-code">
ORA-04021: timeout occurred while waiting to lock object SYS.&lt;package like UTL_FILE</pre>			<p>Finally, this is an example of a message displayed by PostgreSQL when something goes wrong:</p>
			<pre class="source-code">
Warning: pg_query(): Query failed: ERROR: syntax error at or near "20131418" LINE 1: 20131418 ^ in /var/www/html/view_project.php on line 13
Warning: pg_num_rows() expects parameter 1 to be resource, boolean given in /var/www/html/view_project.php on line 14</pre>			<p>Next, we will cover the most prevalent types of SQL injection attacks.</p>
			<h2 id="_idParaDest-81"><a id="_idTextAnchor083"/>Classic SQL injection</h2>
			<p>Pretty much <a id="_idIndexMarker411"/>all attempts to insert commands <a id="_idIndexMarker412"/>into SQL instructions will happen with the <code>SELECT</code> directive. This is because one of the main objectives is to exfiltrate data from the database. You either want the whole user list with their passwords (hashed or not) or the details about its internal structures, such as the number of tables, the database schema, an order list with their values and delivery addresses, and so on and so forth.</p>
			<p>Imagine an online store where you can search for items. This search feature might have a security weakness. When you type in your search term, the system builds a special message (such as a coded instruction) to ask the database to find matching products. This particular way of building the message could be vulnerable to manipulation. Let’s take a closer look at an example of such a message:</p>
			<pre class="source-code">
SELECT * FROM products WHERE name = '$user_input';</pre>			<p>The <code>$user_input</code> variable represents what the user typed in a form field on the frontend component of this web application. It could be data sent to an API endpoint via a <code>POST</code> or <code>PUT</code> request as well. Without doing the required validation or sanitization, an injection can easily happen. Instead of providing some search text, the user could send the following:</p>
			<pre class="source-code">
' OR 1=1 --</pre>			<p>This will make the final query the following:</p>
			<pre class="source-code">
SELECT * FROM products WHERE name = '' OR 1=1 -- ';</pre>			<p>With a logical <code>OR</code> operator whose second operand always evaluates as <code>true</code>, it doesn’t matter <a id="_idIndexMarker413"/>what the first part of the query (the user verification) is. The <code>–</code> part is understood as a comment, which means the SQL engine will <a id="_idIndexMarker414"/>ignore everything else after it. Some database engines use <code>/*</code> as the sequence to start a comment. In logical terms, it would be something like this:</p>
			<pre class="source-code">
If name = '' OR 1=1 then
    SELECT * FROM products;
EndIf</pre>			<p>With this simple joke, you would get the entire <code>products</code> database. If the API endpoint or application leverages the same input to carry out some other tasks, such as updating another database or deleting items, the damage can be even worse.</p>
			<h2 id="_idParaDest-82"><a id="_idTextAnchor084"/>Stacked SQL injection</h2>
			<p>Instead <a id="_idIndexMarker415"/>of classic SQL injection attacks, attackers can use a more advanced <a id="_idIndexMarker416"/>technique called stacked (or chained) SQL injection. This is like giving multiple orders at once in a restaurant. With stacked attacks, attackers trick the API endpoint into running several database instructions at the same time. This lets them achieve more complex goals, such as manipulating data or gaining more access within the system. These attacks are especially risky because they allow you to perform powerful actions on the database and potentially become a more powerful user within the endpoint.</p>
			<p>Let’s leverage the same command of the previous section. Suppose the target API endpoint sends the following query to the backend database:</p>
			<pre class="source-code">
SELECT * FROM products WHERE name = '$user_input';</pre>			<p>Now, let’s <a id="_idIndexMarker417"/>spice this up just a little with this as the <code>$</code><code>user_input</code> variable:</p>
			<pre class="source-code">
'; INSERT INTO users (username, password) VALUES ('a', 'b') --</pre>			<p>This will <a id="_idIndexMarker418"/>make the final query the following:</p>
			<pre class="source-code">
SELECT * FROM products WHERE name = ''; INSERT INTO users (username, password) VALUES ('a', 'b') --';</pre>			<p>An SQL engine that receives such a query will interpret the semicolon sign as the end of the command and will execute the subsequent command, which inserts a new username and password into the <code>users</code> table. Should you be successful, you now have a credential pair to access the API endpoint and dive deeper into your pentesting activities…</p>
			<h2 id="_idParaDest-83"><a id="_idTextAnchor085"/>Union SQL injection</h2>
			<p>Union SQL injection attacks are a sophisticated exploitation technique that manipulates the structure <a id="_idIndexMarker419"/>of SQL queries to extract additional information from a database. This type of attack leverages the SQL <code>UNION</code> operator to combine the results of <a id="_idIndexMarker420"/>two or more <code>SELECT</code> queries into a single result set, allowing you to retrieve data from database tables they would not typically have access to. Union SQL injection attacks are particularly dangerous as they can lead to unauthorized data access, data leakage, and even full database compromise if not properly mitigated.</p>
			<p>Suppose your target API endpoint accepts <code>GET</code> requests. To request details about a product, for example, the request could be something like this:</p>
			<pre class="source-code">
GET /api/show_product?prod_id=$id</pre>			<p>Here, <code>$id</code> could be some numeric or alphanumeric value. Behind the scenes, the endpoint would craft a corresponding <code>SELECT</code> statement to pass it over to the database, such as the ones you’ve seen in the preceding sections. Now, let’s replace the content of <code>$id</code> with an especially crafted sequence:</p>
			<pre class="source-code">
50 UNION ALL SELECT * FROM ORDERS;</pre>			<p>This would result in the following <code>GET</code> request:</p>
			<pre class="source-code">
GET /api/show_product?prod_id=50 UNION ALL SELECT * FROM ORDERS;</pre>			<p>Without proper validation, the endpoint would be deceived into building the expected <code>SELECT</code> statement with <code>$prod_id</code> equals <code>50</code>, but also sending a second unpredicted <code>SELECT</code> statement that would retrieve all items from the <code>orders</code> table. This happens because the <a id="_idIndexMarker421"/>endpoint is simply picking the value of <code>$prod_id</code> and passing <a id="_idIndexMarker422"/>it to the <code>SELECT</code> command without even validating if it is in an expected shape. The <code>ALL</code> keyword plays an important role here. Some applications may use the <code>DISTINCT</code> keyword when selecting items from a database. This is, first, to avoid excessive network communication between endpoint and database, and second, to not retrieve duplicate items. When preceded by <code>ALL</code>, a <code>SELECT</code> statement will retrieve all items regardless of <code>DISTINCT</code>.</p>
			<h2 id="_idParaDest-84"><a id="_idTextAnchor086"/>Hidden union SQL injection</h2>
			<p>Union SQL injection vulnerabilities present a substantial risk to the security of APIs. However, when <a id="_idIndexMarker423"/>attackers conceal their malicious intent within <a id="_idIndexMarker424"/>seemingly innocuous user input, the threat becomes even more insidious. This is where hidden union SQL injection emerges as a significant concern. Hidden union SQL injection extends the principles of conventional union attacks. You can exploit weaknesses in API endpoints but elevate the level of deceit. By meticulously devising malicious payloads that camouflage your final intention within the guise of legitimate user input, you can complicate detection and mitigation efforts.</p>
			<p>The malevolent code seems benign when embedded within user input, rendering it challenging <a id="_idIndexMarker425"/>to spot during cursory examination. As a matter of fact, a poorly configured <strong class="bold">web application firewall</strong> (<strong class="bold">WAF</strong>) may ignore this attack. Moreover, extracted confidential data is frequently discreetly embedded within the API response, possibly melding with genuine information. This deceptive strategy complicates the detection of dubious activities and necessitates careful examination of API queries and responses.</p>
			<p>Suppose our target API endpoint accepts <code>POST</code> requests and responds with product data retrieved from the backend database. One possible scenario would be the following structure passed as a parameter to the endpoint:</p>
			<pre class="source-code">
{
  'category': 'clothing',
  'max_num_items': '10'
}</pre>			<p>This would <a id="_idIndexMarker426"/>become a legit <code>SQL SELECT</code> statement to bring 10 <a id="_idIndexMarker427"/>clothing products at most. With a hidden union attack, we would change this structure to look something like this:</p>
			<pre class="source-code">
{
  'category': "clothing (SELECT 'admin', version() FROM information_schema.tables LIMIT 1);--",
  'max_num_items': '10'
}</pre>			<p>Observe the first change was to replace single quotes with double quotes for the value of <code>category</code>. This is to allow single quotes further on. The attack is then embedded between the parentheses. By sending this <code>SELECT</code> statement, we are requesting to receive information about both the admin user and the database engine version from a special table called <code>information_schema.tables</code>. And again, the <code>--</code> part has the same effect as the previous examples. The <code>version()</code> function returns details about the database engine, and the <code>LIMIT</code> keyword limits the answer to one row, to avoid the response being blocked by some rate-limiting/throttling mechanism.</p>
			<h2 id="_idParaDest-85"><a id="_idTextAnchor087"/>Boolean SQL injection</h2>
			<p>This technique <a id="_idIndexMarker428"/>is very useful when, while <a id="_idIndexMarker429"/>exploiting an SQL database backing an API endpoint, the returned error messages are too generic. For example, when asking for some non-existing product or user, the endpoint simply returns a 404 error code and no further information. By sending some simple queries whose answers could be only <code>true</code> or <code>false</code>, you can check if the database is vulnerable to SQL injection and then create more directed attacks on it. Consider the following endpoint that accepts <code>GET</code> requests:</p>
			<pre class="source-code">
GET /api/products?id=100</pre>			<p>By slightly changing it to the following, you can check what would be the answer:</p>
			<pre class="source-code">
GET /api/products?id=100 AND 1=2;</pre>			<p>This would obviously never work. The point here is not to get access to data on the very first attempt. We are fingerprinting how the database serving the API endpoint behaves. Now, you switch the second part of the statement to a valid value:</p>
			<pre class="source-code">
GET /api/products?id=100 AND 1=1;</pre>			<p>I didn’t say <a id="_idIndexMarker430"/>this before since it’s too obvious, but you need to capture <a id="_idIndexMarker431"/>all output that’s sent by the endpoint as the responses to your requests. Everything is important since a small piece of data can constitute a vital part of understanding the target. If the answer to the previous query (<code>1=1</code>) is different from the other query (<code>1=2</code>), you will conclude the database is vulnerable to SQL injection. In other words, the endpoint is not correctly sanitizing the input before sending it to the database. Some administrators simply configure their endpoints or web applications to provide generic error messages hoping that by obscuring them this way, they are protecting their environments. Big mistake…</p>
			<p>You can power up this technique by making use of some functions that are common to several database engines. The following functions are your friends:</p>
			<ul>
				<li><code>ASCII(character)</code>: Returns <a id="_idIndexMarker432"/>an integer value (the ASCII code) corresponding to the provided character.</li>
				<li><code>LENGTH(string)</code>: Returns <a id="_idIndexMarker433"/>the length of the provided string in bytes.</li>
				<li><code>SUBSTRING(string, initial character, number of characters)</code>: Returns the partial string captured from the provided string, beginning <a id="_idIndexMarker434"/>on the initial character position with a total length of the number of characters. Consider 0 as the position of the initial character.</li>
			</ul>
			<p>Let your imagination fly. The query we sent before can be boosted with some discovery attempts. Consider you want to retrieve all usernames whose lengths are less than or equal to 10. You can craft a query such as this:</p>
			<pre class="source-code">
GET /api/products?id=100 OR UNION SELECT username FROM users WHERE LENGTH(username) &lt;= 10;</pre>			<p>You can <a id="_idIndexMarker435"/>automate this by mixing and matching these functions, such <a id="_idIndexMarker436"/>as trying to guess the admin’s username. Do you realize the potential of this technique? By combining patience, imagination, and a vulnerable API endpoint, you can extract lots of data. In the next section, we will exploit SQL injection on crAPI.</p>
			<h2 id="_idParaDest-86"><a id="_idTextAnchor088"/>Exploiting SQL injection on a vulnerable API</h2>
			<p>For this exercise, we will leverage a lightweight and effective Python application embedded <a id="_idIndexMarker437"/>with some vulnerabilities, including <a id="_idIndexMarker438"/>SQL injection: <code>python vAPI.py -p &lt;port&gt;</code>. Just <a id="_idIndexMarker439"/>select a port not used by other tools, such as Burp Suite, <strong class="bold">Open Worldwide Application Security Project Zed Attack Proxy</strong> (<strong class="bold">OWASP ZAP</strong>), or WebGoat.</p>
			<p>Let’s also use our other friends, Burp Suite and Postman, to help us with this quest. Launch Burp Suite and start a new project with the defaults. Also, start Postman. You will need to either configure your operating system to use Burp as the proxy or configure Postman itself to do it. I recommend going with the second option for the sake of avoiding breaking other tests you may be doing in your system. In Postman, click <strong class="bold">File</strong> | <strong class="bold">Settings</strong> and choose <strong class="bold">Proxy</strong>. Then, make sure <strong class="bold">Use system proxy</strong> is disabled and enable <strong class="bold">Use custom proxy configuration</strong>. Select at least the <strong class="bold">HTTP</strong> proxy type and provide the hostname and port where Burp is listening for requests.</p>
			<p>vAPI has documentation written using the OpenAPI format. It’s represented by the <code>openapi/vAPI.yaml</code> path. Since it’s a small application, it’s OK to directly open and read this document. On the other hand, if you’d prefer to read it as an HTML file, there’s a very convenient Python code that can convert it for you. The utility can be found here: <a href="https://gist.github.com/oseiskar/dbd51a3727fc96dcf5ed189fca491fb3">https://gist.github.com/oseiskar/dbd51a3727fc96dcf5ed189fca491fb3</a>. You will verify there are a couple of endpoints accepting both <code>GET</code> and <code>POST</code> requests. After analyzing the available endpoints, it seems we start with the <code>/tokens</code> endpoint, and by providing a valid credential pair, you can receive a valid token. Start the application using some free port, such as <code>8000</code>:</p>
			<pre class="console">
$ python vAPI.py -p 8000
 * Serving Flask app 'vAPI'
 * Debug mode: on</pre>			<p>As we <a id="_idIndexMarker440"/>have no idea of what the usernames and passwords are, let’s use a creative combination of such by crafting a request with Postman:</p>
			<div><div><img src="img/B19657_05_02.jpg" alt="Figure 5.2 – Sending a POST request to vAPI’s /tokens endpoint"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.2 – Sending a POST request to vAPI’s /tokens endpoint</p>
			<p>We obviously received an error message. Now, go to Burp Suite to check the HTTP connection history. Locate the request to <code>/tokens</code>, right-click on it (still on the <code>§</code>. This will be used to instruct the tool about which <a id="_idIndexMarker441"/>portions of subsequent requests will change during the attack:</p>
			<pre class="source-code">
{
  "username":"§pentest§",
  "password":"§MyPassword§"
}</pre>			<p>Set <strong class="bold">Attack type</strong> as <strong class="bold">Sniper</strong>. Now, move to the <strong class="bold">Payloads</strong> subsection. Set <strong class="bold">Payload type</strong> as <strong class="bold">Simple list</strong> and click on the <strong class="bold">Load…</strong> button on the block that says <strong class="bold">Payload settings [Simple list]</strong>. You can load multiple files at once. Do this if you have more than one list. Deselect the last checkmark that says <strong class="bold">URL encode these characters</strong>. This will avoid unnecessary encoding when submitting the payloads to the target. Finally, click on <strong class="bold">Start Attack</strong>. In real life, if your target is protected by some rate-limiting or anti-DoS control, you may receive some blocks.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">If you are using the Community Edition of Burp Suite, this may take a while since the Intruder functionality has been reduced in features and attacks are locally time throttled. You may realize an interval of around 5 seconds between each payload.</p>
			<p>Hopefully, with some patience and luck, you will be successful in this. Actually, after some time, we managed to find a valid username. When analyzing Intruder’s outputs, look for the ones with the <code>200 code</code>. We had lots of this kind of code in our practical example. In <em class="italic">Figure 5</em><em class="italic">.3</em>, you can spot the success of our SQL injection attack against crAPI. We discovered a valid user ID and username:</p>
			<div><div><img src="img/B19657_05_03.jpg" alt="Figure 5.3 – vAPI vulnerable to SQL injection and reveals a valid credential pair"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.3 – vAPI vulnerable to SQL injection and reveals a valid credential pair</p>
			<p>A token <a id="_idIndexMarker442"/>is provided as part of the response. You can leverage it, for example, to change the user’s password through the <code>/user</code> endpoint. Let’s use this same endpoint to obtain the user’s password, using the token extracted in our attack:</p>
			<div><div><img src="img/B19657_05_04.jpg" alt="Figure 5.4 – Obtaining the user’s password after gaining access to a valid token"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.4 – Obtaining the user’s password after gaining access to a valid token</p>
			<p>You can <a id="_idIndexMarker443"/>explore this application more and possibly get more data with further injection attacks. In the next section, let’s learn some NoSQL injection.</p>
			<h1 id="_idParaDest-87"><a id="_idTextAnchor089"/>Testing for NoSQL injection</h1>
			<p>We have covered a reasonable ground of SQL injection attacks, but the fact is there is a considerable <a id="_idIndexMarker444"/>number of applications (and API endpoints) on the internet that need to handle unstructured data, such as documents, emails, social media posts, images, and audio and video files. For these use cases, relational databases are not the best choice since not all elements inside such databases have direct relationships, which would cause its management an unfair task. Carlo Strozzi introduced <a id="_idIndexMarker445"/>the concept of NoSQL databases in 1998 with his Strozzi NoSQL <strong class="bold">open source software</strong> (<strong class="bold">OSS</strong>) proposal. Since then, we’ve seen the release of many awesome products out there, such as MongoDB, Apache Cassandra, and Neo4j, just to name a few.</p>
			<p>As these databases, as their type implies, are not SQL ones, they do not use SQL for making queries or responding to them. Hence, our SQL injection techniques do not work here. We need <a id="_idIndexMarker446"/>to approach them in another way. In this scenario, there are basically three types <a id="_idIndexMarker447"/>of attacks <a id="_idIndexMarker448"/>that we can leverage <a id="_idIndexMarker449"/>to achieve success: <strong class="bold">syntax injection</strong>, <strong class="bold">object injection</strong>, and <strong class="bold">operator injection</strong>. Let’s separately cover each of them.</p>
			<h2 id="_idParaDest-88"><a id="_idTextAnchor090"/>Syntax injection</h2>
			<p>Syntax injection stands out as the prevalent form of NoSQL injection. In this type of attack, the <a id="_idIndexMarker450"/>pentester embeds harmful code within user input, which the API then integrates into a NoSQL query. This injected code has the <a id="_idIndexMarker451"/>potential to disrupt the syntax of the query, evade filters, or even trigger the execution of unauthorized commands within the database.</p>
			<p>The core concept of a NoSQL syntax injection attack revolves around manipulating user input. The pentester crafts malicious code and injects it into parameters that are then incorporated into the NoSQL query by the vulnerable API. One common scenario where NoSQL syntax injection attacks occur is in API endpoints that handle user authentication. For instance, an API might have a login endpoint where users submit their credentials for authentication. If the API uses a NoSQL database to store user data and does not properly sanitize user input, attackers can inject malicious code into the login credentials to bypass authentication checks or gain unauthorized access to user accounts.</p>
			<p>In a NoSQL syntax injection attack, you as a pentester can leverage various techniques to evade detection and achieve your objectives. For example, you might use wildcard characters, regular expressions, or other syntax manipulation techniques to craft payloads that disrupt the query’s structure or evade input validation mechanisms. By carefully constructing their payloads, you can exploit vulnerabilities in the API endpoint and compromise the integrity and confidentiality of the database.</p>
			<p>Here’s how it works. Consider an API endpoint that does user authentication with the help of a NoSQL database. The endpoint accepts <code>GET</code> requests in the following format:</p>
			<pre class="source-code">
GET /api/login?username=$username&amp;password=$password</pre>			<p>Internally, the API endpoint translates the request into a NoSQL query like this:</p>
			<pre class="source-code">
db.users.find({ username: '$username', password: '$password' })</pre>			<p>Observe that there was absolutely no validation or filtering of the input provided by the requester, neither on the username nor on the password fields. We have a candidate for a NoSQL syntax injection attack! We could slightly change this request to something like the following:</p>
			<pre class="source-code">
GET /api/login?username[$regex]=.*&amp;password[$regex]=.*</pre>			<p>We just <a id="_idIndexMarker452"/>manipulated the query to use a regular expression that represents <a id="_idIndexMarker453"/>any username and any password (<code>.</code> matches any character and <code>*</code> matches 0 or more occurrences of the preceding character). We just bypassed the authentication control of the endpoint…</p>
			<h2 id="_idParaDest-89"><a id="_idTextAnchor091"/>Object injection</h2>
			<p>NoSQL object injection attacks pose a distinct threat to APIs that interact with these types of <a id="_idIndexMarker454"/>databases. Unlike traditional NoSQL attacks that target the raw query itself, object injection attacks exploit weaknesses in how APIs handle user-provided data.</p>
			<p>Imagine an <a id="_idIndexMarker455"/>API uses a secret language (serialization) to convert user data into a format the NoSQL database understands. You as a pentester can exploit vulnerabilities in this translation process. You could craft malicious data that, when <em class="italic">translated</em> (deserialized) by the API, manipulates internal object structures. This can lead to unexpected consequences, potentially allowing you to run unauthorized code or access sensitive data you shouldn’t.</p>
			<p>A common scenario involves APIs that serialize user-supplied data (such as JSON) before storing it in the NoSQL database. If the API doesn’t check the data carefully before translation, a pentester can sneak in malicious objects that exploit weaknesses in the deserialization process. Think of it like tricking the translator into saying something completely different than what you intended. This allows you to gain an unfair advantage within the system.</p>
			<p>As an example, we can consider an API endpoint that allows users to filter products based on price and category. The following JavaScript code shows a possible query that this endpoint could build to send to the database:</p>
			<pre class="source-code">
const filterObject = { 
    price: { 
        $gt: req.query.minPrice 
    }, 
    category: req.query.category 
};
db.products.find(filterObject);</pre>			<p>The <code>filterObject</code> constant receives data directly provided by the requester (<code>minPrice</code> and <code>category</code>). This is then used on the <code>db.products.find</code> query. Continuing with our example, a valid <code>GET</code> request to select products with a minimum price of 100 and belonging to the <code>furniture</code> category would be the following:</p>
			<pre class="source-code">
GET /products?minPrice=100&amp;category=furniture</pre>			<p>It doesn’t matter if it’s a <code>GET</code> or <code>POST</code> request. The same approach can be used for pretty much any verb here. How can we transform this into an object injection attack? Simple. We <a id="_idIndexMarker456"/>insert an initially unexpected object as part <a id="_idIndexMarker457"/>of the query. With this, the endpoint will grant us admin access besides checking the original product’s category. Look at the following example:</p>
			<pre class="source-code">
GET /products?minPrice=100&amp;category={"$and": [{category: "furniture"}, {"isAdmin": true}]}</pre>			<p>If the endpoint is not correctly configured to sanitize this input, admin access to the database could be granted, and then other stages of the attack could happen. The <code>isAdmin</code> object was not intended to be part of a legitimate query, but because I previously knew that this database would accept it as a possible parameter (of course, after doing my enumeration/fingerprinting tasks), I’m a bit safer to assume it will work. The success of a NoSQL object injection attack largely depends on how the API handles user-supplied objects and incorporates them into its operations. Nevertheless, the fundamental concept of altering object structure to achieve unauthorized access or tamper with data holds true across different NoSQL database platforms.</p>
			<h2 id="_idParaDest-90"><a id="_idTextAnchor092"/>Operator injection</h2>
			<p>At this stage, you <a id="_idIndexMarker458"/>may have already deduced we are talking about <a id="_idIndexMarker459"/>inserting NoSQL operators as part of this sort of attack. Yeah – I was quite a Captain Obvious here, but consider this an attempt to give you some relaxation after this massive reading. Fortunately, you already have access to a small yet useful table with some operators that could be leveraged here.</p>
			<p>NoSQL databases offer a tempting combination of power and flexibility, but they also introduce new security challenges. NoSQL operator injection attacks lurk in the shadows, waiting to exploit APIs that interact with these databases. These attacks target vulnerabilities in APIs that build queries “on the fly” based on user input. Devious attackers can then inject specially crafted data to manipulate how the database interprets the query. This attack has some similarities with syntax injection; however, this one is not breaking the initially predicted syntax of a query but just twisting it.</p>
			<p>Imagine an <a id="_idIndexMarker460"/>API that allows users to search for products based on various filters, such as price or category, as we’ve previously seen. The API might construct <a id="_idIndexMarker461"/>a NoSQL query that dynamically incorporates user-supplied values. Here’s the problem: if the API doesn’t carefully check this user input, you can sneak in malicious operators. These operators, which are normally used for legitimate filtering, can be twisted to alter the query’s logic entirely. Think of it like someone manipulating the search bar on a library website to return unexpected results. Sounds familiar?</p>
			<p>Let’s keep with our example of a website that provides products that in turn are organized into categories. An endpoint to show all products belonging to the <code>tools</code> category could be something like the following:</p>
			<pre class="source-code">
GET /api/products?category=tools</pre>			<p>This translates into the following NoSQL query:</p>
			<pre class="source-code">
db.products.find({ category: '$category' })</pre>			<p>Simple, yet powerful. Now, suppose the user I’m using to interact with this endpoint does not have access to see products belonging to other categories, but the endpoint is not fully applying this control. So, how could I bypass it? Take a look:</p>
			<pre class="source-code">
GET /api/products?category[$ne]=tools</pre>			<p>The <code>$ne</code> part corresponds to a NoSQL operator that means “not equal.” So, we are asking the API endpoint to show all products whose categories are not <code>tools</code>. Fantastic, isn’t it?! I’ve provided a list of MongoDB operators for your convenience. Observe not all NoSQL databases follow the same rule, so you can either try to fingerprint the backend database or combine operators from different database engines:</p>
			<table id="table001-2" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Operator</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Meaning</strong></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>$</code><code>eq</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Matches values that are equal to a specified value</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>$</code><code>ne</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Matches all values that are not equal to a specified value</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>$</code><code>gt</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Matches values that are greater than a specified value</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>$</code><code>gte</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Matches values that are greater than or equal to a specified value</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>$</code><code>in</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Matches any of the values specified in an array</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>$</code><code>lt</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Matches values that are less than a specified value</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>$</code><code>lte</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Matches values that are less than or equal to a specified value</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>$</code><code>nin</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Matches none of the values specified in an array</p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 5.1 – MongoDB comparison operators (Source: MongoDB official documentation)</p>
			<p>Now, let’s <a id="_idIndexMarker462"/>take a look at this in practice <a id="_idIndexMarker463"/>with an exercise.</p>
			<h2 id="_idParaDest-91"><a id="_idTextAnchor093"/>Exploiting NoSQL injection on crAPI</h2>
			<p>It’s time to get back to our old friend, crAPI. We well know it exposes a considerable number <a id="_idIndexMarker464"/>of endpoints, so let’s verify if there’s one we can pick to exercise this. Start your crAPI instance. Let’s also use our other friend, Burp Suite, to help us with this quest. Launch Burp Suite and start a new project with the defaults. You will need to use Burp’s browser in your lab since all services are listening locally (<code>localhost</code>). Access crAPI. If you still don’t have an account, create one by following the straightforward process. After logging in, go to the <strong class="bold">Shop</strong> area, as shown in <em class="italic">Figure 5</em><em class="italic">.5</em>:</p>
			<div><div><img src="img/B19657_05_05.jpg" alt="Figure 5.5 – crAPI’s Shop area"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.5 – crAPI’s Shop area</p>
			<p>Observe <a id="_idIndexMarker465"/>our initial balance: $100. Our objective here is to buy an item for less than what it really costs or increase our balance. If we have a coupon, we can add its code using the corresponding button. The point is, we don’t have any code – yet… Click on the <strong class="bold">Add Coupons</strong> button and type anything. You will receive an error message:</p>
			<div><div><img src="img/B19657_05_06.jpg" alt="Figure 5.6 – Invalid coupon code"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.6 – Invalid coupon code</p>
			<p>This part of crAPI uses a NoSQL database (MongoDB, to be more precise) to store the coupons. Now, go to Burp Suite to check the HTTP connection history. The last item will show you which endpoint crAPI is using to check this code. You will realize it is <code>/community/api/v2/coupon/validate-coupon</code>. We also confirm the endpoint returns a 500 error code with an empty JSON structure. Now, let’s use another resource of Burp to help us discover crAPI’s coupons. <em class="italic">Figure 5</em><em class="italic">.7</em> shows an example of sending a request to the coupon validation endpoint:</p>
			<div><div><img src="img/B19657_05_07.jpg" alt="Figure 5.7 – crAPI’s coupon validation endpoint"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.7 – crAPI’s coupon validation endpoint</p>
			<p>We’ll do <a id="_idIndexMarker466"/>something similar to what we did with the vAPI Python application in the SQL injection section. Right-click on this coupon validation request (still on the <strong class="bold">HTTP history</strong> tab) and select <strong class="bold">Send to Intruder</strong>, then move to this section of the tool. The first subsection you’ll see is <strong class="bold">Positions</strong>. Observe the request structure is a simple JSON structure with a single key and value:</p>
			<pre class="source-code">
{
  "coupon_code": "blabla"
}</pre>			<p>We want to fuzz the <code>"blabla"</code> part with lots of junk that will be pulled from the payload list. Select this whole <code>"blabla"</code> text, <em class="italic">including the double quotes</em>, and click on the <code>§</code>. Set <strong class="bold">Attack type</strong> as <strong class="bold">Sniper</strong>. Now, move to the <strong class="bold">Payloads</strong> subsection. Set <strong class="bold">Payload type</strong> as <strong class="bold">Simple</strong> and click on the <strong class="bold">Load…</strong> button on the block that says <strong class="bold">Payload settings [Simple list]</strong>. You can load multiple files at once. Do this if you have more than one. Deselect the last checkmark that says <strong class="bold">URL encode these characters</strong>. This will avoid unnecessary encoding when submitting the payloads to the target. Finally, click on <strong class="bold">Start Attack</strong>. Remember – Burp Community may take more time as the Intruder feature has intentionally received some delays between sent payloads.</p>
			<p>Again, switch to the <code>200 code</code>, like the one on the following screenshot, which will disclose a coupon code to you. The <code>TRAC075</code> code means $75:</p>
			<div><div><img src="img/B19657_05_08.jpg" alt="Figure 5.8 – crAPI disclosing a coupon code after ﻿a NoSQL injection attack"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.8 – crAPI disclosing a coupon code after a NoSQL injection attack</p>
			<p>Pick this <a id="_idIndexMarker467"/>coupon and add it to the corresponding area of the website. It will be accepted, and your balance will increase, as shown in <em class="italic">Figure 5</em><em class="italic">.9</em>. Lucky, lucky!</p>
			<div><div><img src="img/B19657_05_09.jpg" alt="Figure 5.9 – Valid coupon code added"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.9 – Valid coupon code added</p>
			<p>You can see your balance has increased by $75, as shown in <em class="italic">Figure </em><em class="italic">5</em><em class="italic">.10</em>. Rich!</p>
			<div><div><img src="img/B19657_05_10.jpg" alt="Figure 5.10 – Balance increase after the coupon code was added"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.10 – Balance increase after the coupon code was added</p>
			<p>Congratulations! You will never have to spend more for a single product on crAPI’s shop. Sorry – just another terrible icebreaker. The list of payloads I used for this attack can be easily found in the references that I put in the <em class="italic">Further reading</em> section. Do not forget to check them <a id="_idIndexMarker468"/>as there is a vast amount of material that you can use in your pentesting endeavors. Next, we will learn about user input validation and sanitization.</p>
			<h1 id="_idParaDest-92"><a id="_idTextAnchor094"/>Validating and sanitizing user input</h1>
			<p>At this stage, I’m sure you are more than aware that the core success of injection attacks lies <a id="_idIndexMarker469"/>in the reduced (or lack of) sanitizing of what a user provides <a id="_idIndexMarker470"/>to an API endpoint or web application. When building secure APIs, validating and sanitizing user input is paramount for thwarting attacks. As a penetration tester, understanding these techniques is crucial for identifying vulnerabilities.</p>
			<p>When users sign up, input validation acts as a vigilant gatekeeper, guaranteeing the information they provide adheres to specific guidelines and is suitable for processing. It meticulously examines the format, length, and content of crucial fields such as usernames, email addresses, and passwords. Open source powerhouses such as OWASP <strong class="bold">Enterprise Security API</strong> (<strong class="bold">ESAPI</strong>) offer <a id="_idIndexMarker471"/>dependable validation tools for diverse user input types. Imagine wielding ESAPI’s validation functions to ensure usernames are composed solely of letters and numbers, adhering to a predefined length limit. Similarly, you can verify email addresses conform to a legitimate format and that passwords satisfy complexity mandates, such as minimum length and the inclusion of special characters. This robust approach safeguards a system from potentially harmful or nonsensical data.</p>
			<p>There are at least five points that deserve attention from any API developer. You as a pentester should obviously check the absence of any of them:</p>
			<ul>
				<li><code>@</code> and <code>.</code>), and usernames free of special characters that might disrupt the system. However, these safeguards can sometimes be flawed. Tools such as OWASP ZAP and Burp Suite empower pentesters to become stealthy middlemen, intercepting and dissecting communication (HTTP requests) between the user and the API.</li>
				<li><strong class="bold">Sanitizing query parameters for search queries</strong>: APIs that empower users to unearth products by name or category require careful attention to sanitizing query parameters. This crucial step involves purging or transforming special characters that could potentially be exploited to manipulate the database <a id="_idIndexMarker472"/>query lurking beneath the surface. Tools such as <a id="_idIndexMarker473"/>SQLMap and NoSQLMap act as digital probes to reveal vulnerabilities in these queries. These tools can be employed to test for weaknesses susceptible to SQL and NoSQL injection attacks. By implementing robust input sanitization, such attacks can become ineffective and safeguard the integrity of the underlying database.</li>
				<li><strong class="bold">Validating file uploads</strong>: Imagine an API that welcomes user-uploaded files, perhaps images or essential documents. However, lurking within this seemingly harmless functionality lies the potential for malicious activity. To fortify this API, robust input validation is paramount. It should act as a vigilant inspector, scrutinizing file types to ensure only permitted formats (such as images) are allowed. Additionally, size limitations must be enforced to prevent DoS attacks through massive file uploads. Malware detection mechanisms should be employed to identify and reject any malicious files that might attempt to infiltrate the system.<p class="list-inset">Furthermore, filenames themselves require sanitization. This crucial step thwarts “directory traversal attacks” – a technique where pentesters exploit vulnerabilities in file naming conventions to access unauthorized parts of the system. Tools such as OWASP ZAP and Nikto act as invaluable allies for security professionals, enabling them to simulate attacks and pinpoint weaknesses in the file upload functionality, especially those arising from inadequate input validation.</p></li>
				<li><code>validator.js</code> for JavaScript or Django’s built-in form validation for Python offer invaluable assistance in implementing robust input validation for numeric input. These tools empower developers to establish clear guidelines <a id="_idIndexMarker476"/>for acceptable numerical ranges, preventing <strong class="bold">out-of-bounds</strong> (<strong class="bold">OOB</strong>) errors and maintaining data integrity within the API.</li>
				<li><strong class="bold">Sanitizing HTML input to prevent cross-site scripting (XSS) attacks</strong>: Certain APIs allow users to contribute HTML content, such as comments or product descriptions. This seemingly innocuous functionality can be weaponized by attackers if proper safeguards are not in place. Malicious actors might attempt to inject malevolent scripts (XSS attacks) within the HTML, potentially hijacking user sessions, stealing data, or redirecting users to malicious websites. To thwart these attacks, sanitization is a critical defense mechanism.<p class="list-inset">This process involves either transforming (escaping) or entirely removing potentially harmful HTML tags and attributes, rendering them inert and incapable of executing malicious code. Fortunately, open source libraries such as DOMPurify for JavaScript and Bleach for Python come to the rescue. These tools empower developers to effectively sanitize HTML input, neutralizing XSS vulnerabilities and safeguarding the integrity of the API and its users.</p></li>
			</ul>
			<p>Let’s take a closer look at each of these use cases.</p>
			<h2 id="_idParaDest-93"><a id="_idTextAnchor095"/>Input validation for user registration</h2>
			<p>During user registration, input validation acts as a vigilant security checkpoint, guaranteeing the information users provide adheres to predefined standards and is suitable <a id="_idIndexMarker477"/>for processing without compromising system security. This meticulous process involves examining the format, length, and content of crucial fields such as usernames, email addresses, and passwords. Powerful tools such <a id="_idIndexMarker478"/>as OWASP ESAPI offer an arsenal of validation functions. Think of them as skilled guards, each with a specific expertise.  One guard ensures usernames are built solely with letters and numbers, adhering to a length restriction. Another verifies email addresses following a legitimate format, while a third enforces password complexity, demanding a minimum length and the inclusion of special characters. By implementing these rigorous checks, you effectively filter out nonsensical or potentially malicious data that could be used by attackers to exploit vulnerabilities. Thorough input validation is the cornerstone of secure user registration.  It builds a fortified wall around your system, safeguarding it from a multitude of security threats and ensuring the smooth operation of your kingdom (API and application).</p>
			<p>Even nowadays, Java is a prominent programming language, and it’s not difficult to find web applications and API endpoints built upon it. Let’s consider the following excerpt of Java code that shows an example of OWASP ESAPI in action:</p>
			<pre class="source-code">
import org.owasp.esapi.ESAPI;
import org.owasp.esapi.errors.ValidationException;
public class UserRegistrationValidator {
    public boolean isValidUsername(String username) {
        try {
            ESAPI.validator().isValidInput("Username", username, "Username", 50, false);
            return true;
        } catch (ValidationException e) {
            return false;
        }
    }
}</pre>			<p>In this code, two classes, <code>ESAPI</code> itself and <code>ValidationException</code> from the <code>errors</code> package, are leveraged. Observe that a username is only considered valid when the <code>ESAPI.validator()</code> function states so.</p>
			<h2 id="_idParaDest-94"><a id="_idTextAnchor096"/>Sanitizing query parameters</h2>
			<p>Sanitizing query parameters is a critical defense mechanism for APIs that interact with databases. Without proper sanitization, attackers can exploit vulnerabilities known as SQL injection <a id="_idIndexMarker479"/>to manipulate database queries. These malicious actors might use tools such as SQLMap to automate the process, sending a barrage of crafted strings (payloads) through query parameters. These payloads can potentially trick the database into executing unintended actions, such as stealing sensitive data or disrupting operations.</p>
			<p>Fortunately, we have powerful tools at our disposal to combat this threat. Input sanitization techniques, such as parameterized queries, act as a shield against such attacks. Parameterized queries separate the data (user input) from the actual SQL statement, preventing malicious code from being injected. Frameworks such as Flask in Python offer built-in support for parameterized queries. By embracing this approach, you can confidently execute SQL queries without exposing your application to the dangers of SQL injection, safeguarding the integrity of your database and user information.</p>
			<p>The following code portion contains a Flask application interacting with an SQLite3 database. Instead of directly passing the input to the database, it first hardcodes the table name into the SQL statement and applies the <code>?</code> symbol:</p>
			<pre class="source-code">
from flask import request
import sqlite3
@app.route('/search')
def search():
    query = request.args.get('q')
    conn = sqlite3.connect('database.db')
    cursor = conn.cursor()
    cursor.execute("SELECT * FROM items WHERE name LIKE ?", ('%' + query + '%',))
    results = cursor.fetchall()
    conn.close()
    return jsonify(results)</pre>			<p>In this example, the <code>q</code> query parameter is sanitized by using parameterized queries (<code>?</code>), ensuring that any malicious input provided by the user is properly escaped and doesn’t interfere with the SQL query execution.</p>
			<h2 id="_idParaDest-95"><a id="_idTextAnchor097"/>Validating file uploads</h2>
			<p>File uploads offer a convenient functionality for users, but they can also be a gateway for attackers. Malicious actors might attempt to upload files disguised as harmless images or <a id="_idIndexMarker480"/>documents, but in reality, these files could be malicious scripts or executables capable of compromising the entire server. To prevent such attacks, robust input validation is essential. This process meticulously examines uploaded files, ensuring they adhere to predefined security standards.</p>
			<p>Validation focuses on two key aspects: file type and size. Only authorized file types, such as images or documents, should be allowed. Open source libraries such as <strong class="bold">Apache Commons FileUpload</strong> for Java come to the rescue, offering a suite of tools for validating uploads. These tools can check file extensions against a whitelist, verify content types to ensure they match the expected format, and enforce size limitations to prevent DoS attacks through massive uploads. By implementing these safeguards, you can effectively disarm these “digital bombs” disguised as file uploads, safeguarding your server and user data.</p>
			<p>The following Java code exemplifies how files sent as input to an API endpoint can be correctly validated before being effectively processed by the backend, including an eventual database:</p>
			<pre class="source-code">
import org.apache.commons.fileupload.FileItem;
import org.apache.commons.fileupload.disk.DiskFileItemFactory;
import org.apache.commons.fileupload.servlet.ServletFileUpload;
List&lt;FileItem&gt; items = new ServletFileUpload(new DiskFileItemFactory()).parseRequest(request);
for (FileItem item : items) {
    if (!item.isFormField()) {
        String fileName = new File(item.getName()).getName();
        String contentType = item.getContentType();
        // Validates fileName, contentType, and file size
    }
}</pre>			<p>In this <a id="_idIndexMarker481"/>code snippet, Apache Commons FileUpload is used to parse the file upload request, and then validation checks can be performed on the filename, content type, and size to ensure that only safe files are accepted for upload.</p>
			<h2 id="_idParaDest-96"><a id="_idTextAnchor098"/>Input validation for numeric input</h2>
			<p>When dealing with numeric input from users, ensuring the data adheres to the expected format <a id="_idIndexMarker482"/>and remains within acceptable boundaries is critical. Unchecked numeric input can introduce vulnerabilities such as buffer overflows or arithmetic overflows, potentially leading to unexpected program behavior, crashes, or even system compromise.</p>
			<p>Open source libraries such as Apache Commons Validator for Java come to the rescue by offering a powerful arsenal for validating numeric input. These libraries provide functions specifically designed to handle different numeric data types – integers, floats, and more. Developers can leverage these functions to define clear constraints, such as minimum and maximum values, for acceptable user input. By implementing such validation, we can effectively “tame” numeric input, preventing errors and safeguarding the API endpoint from vulnerabilities that could be exploited by malicious actors. This ensures the endpoint processes data as intended and maintains its overall stability and security.</p>
			<p>Look at how Apache Commons Validator for Java can be applied to sanitize user input:</p>
			<pre class="source-code">
import org.apache.commons.validator.routines.FloatValidator;
public class NumericInputValidator {
    public boolean isValidFloat(String input) {
        FloatValidator validator = FloatValidator.getInstance();
        return validator.isValid(input, Locale.US);
    // Using US locale for decimal separator
    // You can do the same for integers and other numeric types.
    }
}</pre>			<p>In this code snippet, Apache Commons Validator’s <code>FloatValidator</code> class is used to validate a float input against the <code>US</code> locale, ensuring that the input string represents a valid floating-point number.</p>
			<h2 id="_idParaDest-97"><a id="_idTextAnchor099"/>Sanitizing HTML input to prevent XSS attacks</h2>
			<p>Imagine a scenario where untamed user input is directly inserted into a web page. This seemingly <a id="_idIndexMarker483"/>harmless practice creates a vulnerability known as XSS. Malicious actors can exploit XSS to plant hidden “<em class="italic">bombs</em>” within their input – malicious scripts disguised as regular text. Once the page renders, these scripts can detonate, stealing sensitive user information (such as session cookies) or performing unauthorized actions on the user’s behalf.</p>
			<p>To prevent such attacks, we rely on a technique called HTML escaping. This process involves encoding special characters within user input before displaying them on the web page. By encoding these characters, we effectively disarm the bombs and render them harmless. Open source libraries such as <strong class="bold">OWASP Java Encoder</strong> provide valuable utilities for HTML escaping. By leveraging these tools, developers can effectively sanitize user input, closing the door on XSS vulnerabilities and safeguarding user data and the API endpoint functionality.</p>
			<p>The following code portion shows an example of how HTML input can be sanitized with the use of OWASP Java Encoder:</p>
			<pre class="source-code">
import org.owasp.encoder.Encode;
public class HtmlSanitizer {
    public String sanitizeHtml(String input) {
        return Encode.forHtml(input);
    }
}</pre>			<p>In this example, OWASP Java Encode’s <code>Encode.forHtml</code> method is used to sanitize HTML input by encoding special characters such as <code>&lt;</code>, <code>&gt;</code>, and <code>&amp;</code>, thus preventing them from being interpreted as HTML tags or script elements by the browser.</p>
			<h1 id="_idParaDest-98"><a id="_idTextAnchor100"/>Summary</h1>
			<p>In this chapter, we talked about injection attacks for both worlds, SQL and NoSQL, how they can be perpetrated, and the types of damage they can cause on an end system serving an API endpoint. We learned the different types of injection attacks, and we did two exercises, one with crAPI and another with a vulnerable Python application, each one showing how both types of databases can be hit by injecting commands or spurious/unpredicted data. We finished the chapter with a discussion about validating and sanitizing user input, which intends to either remove or at least reduce the success ratio of injection attacks. Code excerpts were also provided so that you could have a taste of how this works on real applications out there.</p>
			<p>In the next chapter, we’ll talk about error handling and exception testing. This content is as important as anything else since we’ll see that a badly treated exception or error can disclose valuable information about the API or the application behind it.</p>
			<h1 id="_idParaDest-99"><a id="_idTextAnchor101"/>Further reading</h1>
			<ul>
				<li>The Equifax data breach: <a href="https://consumer.ftc.gov/consumer-alerts/2019/07/equifax-data-breach-settlement-what-you-should-know">https://consumer.ftc.gov/consumer-alerts/2019/07/equifax-data-breach-settlement-what-you-should-know</a></li>
				<li>Firebase NoSQL vulnerability: <a href="https://blog.securitybreached.org/2020/02/04/exploiting-insecure-firebase-database-bugbounty/">https://blog.securitybreached.org/2020/02/04/exploiting-insecure-firebase-database-bugbounty/</a></li>
				<li><strong class="bold">Common Vulnerabilities and Exposures</strong> (<strong class="bold">CVE</strong>) reporting the Apache Structs vulnerability: <a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-11776">https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-11776</a></li>
				<li>Atlassian XXE vulnerability: <a href="https://confluence.atlassian.com/security/cve-2019-13990-xxe-xml-external-entity-injection-vulnerability-in-jira-service-management-data-center-and-jira-service-management-server-1295385959.html">https://confluence.atlassian.com/security/cve-2019-13990-xxe-xml-external-entity-injection-vulnerability-in-jira-service-management-data-center-and-jira-service-management-server-1295385959.html</a></li>
				<li>FortiSIEM <em class="italic">CVE-2023-36553</em> MITRE record: <a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-36553">https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-36553</a></li>
				<li>FortiSIEM <em class="italic">CVE-2023-36553</em> <strong class="bold">National Institute of Standards and Technology</strong> (<strong class="bold">NIST</strong>) notice: <a href="https://nvd.nist.gov/vuln/detail/CVE-2023-36553">https://nvd.nist.gov/vuln/detail/CVE-2023-36553</a></li>
				<li>Palo Alto OS command injection vulnerability – <a href="https://security.paloaltonetworks.com/CVE-2023-6792">https://security.paloaltonetworks.com/CVE-2023-6792</a></li>
				<li><em class="italic">BleepingComputer</em> – <em class="italic">Hackers steal data of 2 million in SQL injection, XSS </em><em class="italic">attacks</em>: <a href="https://www.bleepingcomputer.com/news/security/hackers-steal-data-of-2-million-in-sql-injection-xss-attacks/">https://www.bleepingcomputer.com/news/security/hackers-steal-data-of-2-million-in-sql-injection-xss-attacks/</a></li>
				<li><em class="italic">PortSwigger</em> – <em class="italic">Car companies massively exposed to web </em><em class="italic">vulnerabilities</em>: <a href="https://portswigger.net/daily-swig/car-companies-massively-exposed-to-web-vulnerabilities">https://portswigger.net/daily-swig/car-companies-massively-exposed-to-web-vulnerabilities</a></li>
				<li><em class="italic">The Hacker News</em> – <em class="italic">New Hacker Group ‘GambleForce’ Targeting APAC Firms Using SQL Injection </em><em class="italic">Attacks</em>: <a href="https://thehackernews.com/2023/12/new-hacker-group-gambleforce-tageting.html">https://thehackernews.com/2023/12/new-hacker-group-gambleforce-tageting.html</a></li>
				<li><em class="italic">PayloadsAllTheThings</em> (massive list of injection payloads): <a href="https://github.com/swisskyrepo/PayloadsAllTheThings">https://github.com/swisskyrepo/PayloadsAllTheThings</a></li>
				<li>SQL injection payload list: <a href="https://github.com/payloadbox/sql-injection-payload-list">https://github.com/payloadbox/sql-injection-payload-list</a></li>
				<li>All-in-one fuzzing wordlist for SQL injection: <a href="https://github.com/PenTestical/sqli">https://github.com/PenTestical/sqli</a></li>
				<li>vAPI Python application: <a href="https://github.com/michealkeines/Vulnerable-API">https://github.com/michealkeines/Vulnerable-API</a></li>
				<li><em class="italic">An Exploration of Finding Aid Technologies and NoSQL Databases</em> – scientific article with an introduction to NoSQL databases: <a href="https://ojs.library.ubc.ca/index.php/seealso/article/view/186333">https://ojs.library.ubc.ca/index.php/seealso/article/view/186333</a></li>
				<li>MongoDB query operators: <a href="https://www.mongodb.com/docs/manual/reference/operator/query/">https://www.mongodb.com/docs/manual/reference/operator/query/</a></li>
				<li>OWASP ESAPI, a library that provides secure methods for sanitizing user input: <a href="https://owasp.org/www-project-enterprise-security-api/">https://owasp.org/www-project-enterprise-security-api/</a></li>
				<li>SQLMap, a tool to automate pentesting on relational databases: <a href="https://sqlmap.org/">https://sqlmap.org/</a></li>
				<li>NoSQLMap – The SQLMap cousin, dedicated to automating pentesting and auditing on non-relational databases: <a href="https://github.com/codingo/NoSQLMap">https://github.com/codingo/NoSQLMap</a></li>
				<li>Nikto, a useful utility to discover vulnerabilities in web servers, including outdated software and misconfigured interfaces: <a href="https://github.com/sullo/nikto">https://github.com/sullo/nikto</a></li>
				<li><code>validator.js</code> for JavaScript, which validates and sanitizes string inputs: <a href="https://www.npmjs.com/package/validator">https://www.npmjs.com/package/validator</a></li>
				<li>DOMPurify for JavaScript, a tool for sanitizing <strong class="bold">Document Object Model</strong> (<strong class="bold">DOM</strong>) HTML forms: <a href="https://github.com/cure53/DOMPurify">https://github.com/cure53/DOMPurify</a></li>
				<li>Apache Commons FileUpload Validator for Java, a library to sanitize files before considering them valid inputs: <a href="https://commons.apache.org/proper/commons-fileupload/">https://commons.apache.org/proper/commons-fileupload/</a></li>
				<li>OWASP Java Encoder, a class that can be leveraged to encode HTML input and reduce chances of XSS attacks: <a href="https://owasp.org/www-project-java-encoder/">https://owasp.org/www-project-java-encoder/</a></li>
				<li>OWASP ESAPI: <a href="https://owasp.org/www-project-enterprise-security-api/">https://owasp.org/www-project-enterprise-security-api/</a></li>
			</ul>
		</div>
	</body></html>