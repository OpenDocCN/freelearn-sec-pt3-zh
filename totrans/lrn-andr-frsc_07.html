<html><head></head><body><div><h1 class="header-title">Forensic Analysis of Android Applications</h1>
                
            
            
                
<p>This chapter will cover application analysis. This chapter will focus on analyzing the data that would be recovered using any of the logical or physical techniques detailed in <a href="b5ab11df-1911-4deb-accd-f92c74650e6d.xhtml" target="_blank">Chapter 4</a>, <em>Extracting Data Logically from Android Devices</em>, and <a href="a910938e-1c0b-4f19-baae-509ccaa36c09.xhtml" target="_blank">Chapter 5</a>,  <em>Extracting Data Physically from Android Devices</em>. It will also rely heavily on the storage methods discussed in <a href="b81853c6-388b-4e15-b8dd-deb5c1b5b36d.xhtml" target="_blank">Chapter 2</a>, <em>Setting Up the Android Forensic Environment</em>; we will see numerous SQLite databases, XML files, and other file types from various locations within the file hierarchy described in that chapter. By the end of this chapter, the reader should be familiar with the following:</p>
<ul>
<li>Application analysis overview</li>
<li>Why do app analysis?</li>
<li>Third-party applications and various methods used by popular applications to store and obfuscate data</li>
</ul>


            

            
        
    </div>



  
<div><h1 class="header-title">Application analysis overview</h1>
                
            
            
                
<p>Forensically analyzing an application is as much of an art as it is a science. There are myriad ways an application can store, or obfuscate, its data. Different versions of the same application may even store the same data differently. Developers are really only limited by their imagination (and Android platform restrictions) when it comes to choosing how to store their data. Because of these factors, application analysis is a moving target; methods an examiner uses one day may be completely irrelevant the next.</p>
<p>The end goal of forensically analyzing an application is consistently the same: to understand what the app was used for, and to find user data.</p>
<p class="mce-root"/>
<p>In this chapter, we will look at the current version of many common applications. Because apps can, and do, change how they store data through updates, nothing in this chapter is a definitive guide for how to analyze that application. Instead, we will look at a broad range of applications to show a variety of different methods used by applications to store their data. For the most part, we will be looking at very common applications (millions of downloads from Google Play), except for cases where looking at an obscure app can reveal interesting new ways of storing data.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Why do app analysis?</h1>
                
            
            
                
<p>For starters, even standard phone functions such as contacts, calls, and SMS are done through applications on Android devices, so even acquiring basic data requires analyzing an application. Secondly, a person's app usage can tell you a lot about them: where they've been (and when they were there), who they've communicated with, and even what they may be planning in the future.</p>
<p>Many phones come with more than 20 pre-installed applications. An examiner has no real way of knowing which of these apps could contain information useful for an investigation, and therefore they must all be analyzed. An examiner may be tempted to skip over certain apps that would appear to have little useful data, such as games. This would be a bad idea, though; many popular games have a built-in chat feature, which could yield useful information. Our analysis will focus heavily on messaging applications, as our experience shows that these tend to be the most valuable in a forensic analysis.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Layout of this chapter</h1>
                
            
            
                
<p class="mce-root">For each application we examine, we will provide a package name and files of interest. All apps store their data in the <kbd>/data/data</kbd> or <kbd>/data/user_de/0</kbd> (newer devices) directory by default; apps can also use the SD card if they ask for this permission when the app is installed. The package name is the name of the directory for the application in one of these directories. The paths in the <em>Files of interest</em> section are from the root of the package name. Paths to data on the SD card are shown beginning with <kbd>/sdcard</kbd>. Do not expect to find data paths beginning with <kbd>/sdcard</kbd> in the <kbd>/data/data</kbd> or <kbd>/data/user_de/0</kbd> directory of the application!</p>
<p>We will begin by looking at some of Google's applications, because these are pre-installed on the majority of devices (though they do not have to be). Then we will look at third-party applications that can be found on Google Play.</p>
<p class="mce-root"/>


            

            
        
    </div>



  
<div><h1 class="header-title">Determining which apps are installed</h1>
                
            
            
                
<p>To see what applications are on the device, an examiner could navigate to /data/data and run the <kbd>ls</kbd> command. But that doesn't provide well-formatted data that will look good in a forensic report. We suggest pulling the <kbd>/data/system/packages.list</kbd> file; this file lists the package name for every app on the device and path to its data (if this file does not exist on the device, the <kbd>adb shell pm list packages –f</kbd> command is a good alternative). For example, here is an entry for Google Chrome (the full file on our test device contained 120 entries):</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-745 image-border" src="img/1ea28b32-b1f2-4bab-8af2-fdbb49237cb0.png" style="width:53.17em;height:1.58em;" width="638" height="19"/></p>
<div><p>This is data storage method 1: plaintext. Often we will see apps store data in plaintext, even including data you wouldn't expect (such as passwords).</p>
</div>
<p>Perhaps of greater interest is the <kbd>/data/system/package-usage.list</kbd> file, which shows the last time that package (or application) was used. It's not perfect; the times shown in the file did not correlate exactly with the last time we used the app. It appears that the app updating or receiving notifications (even if the user does not view them) may affect the time, however it is good for a general indication of the last apps the user accessed:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-746 image-border" src="img/435f777d-2b28-4ccf-aee7-429d4f6ba2c0.png" style="width:23.17em;height:1.42em;" width="278" height="17"/></p>
<p class="NormalPACKT">If you're wondering where to find the time in that line, it's in a format known as Unix epoch time.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Understanding Unix epoch time</h1>
                
            
            
                
<p><strong>Unix epoch time</strong>, also known as Unix time or Posix time, is stored as the number of seconds (or milliseconds) since midnight on January 1st, 1970 UTC. A 10-digit value indicates it is in seconds, while a 13-digit value is indicative of a millisecond value (at least for times likely to be found on a smartphone, as 9-digit second and 12-digit millisecond values haven't occurred since 2001). In our example, the value is <kbd>1422206858650</kbd>; Google Chrome was last used 1 billion, 422 million, 206 thousand, 858 seconds, and 650 milliseconds since midnight on January 1st, 1970! Don't worry, we don't know what date/time that is either. There are many scripts and tools available for download that can convert this into a human-readable format; we like DCode, a free tool that can be found here: <a href="http://www.digital-detective.net/digital-forensic-software/free-tools/">http://www.digital-detective.net/digital-forensic-software/free-tools/</a>.</p>
<p class="mce-root"/>
<p>In DCode, simply select <strong>Unix: Millisecond Value</strong> from the dropdown list, type in the value in the <strong>Value to Decode</strong> field, and click <strong>Decode</strong>:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-747 image-border" src="img/b95ad1ed-254a-4333-8452-0f63c2e89168.png" style="width:45.25em;height:23.67em;" width="543" height="284"/></p>
<p>The <strong>Add Bias</strong> field can be selected to convert the time into the desired timezone.</p>
<p>Alternatively, there is also a very useful online epoch calculator at <a href="http://www.epochconverter.com/">http://www.epochconverter.com/</a>.</p>
<p>Using either method, we can see that Google Chrome was actually last used on January 25th, 2015 at 17:27:38.650 UTC. Unix epoch time is frequently used on Android devices to store date/time values, and will come up repeatedly in our application analysis.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Wi-Fi analysis</h1>
                
            
            
                
<p>Wi-Fi is not technically an application, but it is an invaluable source of data that should be examined, so we'll briefly discuss it here. Wi-Fi connection data is found in <kbd>/data/misc/wifi/wpa_supplicant.conf</kbd>. The <kbd>wpa_supplicant.conf</kbd> file contains a list of access points that the user has chosen to connect to automatically (this is set by default when a new access point is connected to). Access points that the user has <em>forgotten</em> through the device settings will not be shown. If the access point requires a password, that is also stored in the file in plaintext. In the following example, the <kbd>NETGEAR60</kbd> access point required a password (<kbd>ancientshoe601</kbd>), while <kbd>hhonors</kbd> did not:</p>
<p class="mce-root"/>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-748 image-border" src="img/e15e3ab6-fe01-40aa-91f5-20e22f364d00.png" style="width:16.75em;height:16.00em;" width="201" height="192"/></p>
<p>The presence of an SSID in this file does NOT mean that this device connected to that access point. These settings are saved to a user's Google account, and added to the device when that account is set up. An examiner can only conclude that the user connected to these access points from some Android device, not necessarily the device being examined.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Contacts/Call analysis</h1>
                
            
            
                
<p>Contact and call logs are stored in the same database. Contacts do not have to be added explicitly by the user, they may be autofilled when an email is sent through Gmail, a person is added on Google+, or many other ways.</p>
<p><strong>Package name</strong>: <kbd>com.android.providers.contacts</kbd></p>
<p><strong>Files of interest</strong>:</p>
<ul>
<li><kbd>/files/</kbd>:
<ul>
<li><kbd>photos/</kbd></li>
<li><kbd>profile/</kbd></li>
</ul>
</li>
<li><kbd>/databases/</kbd>:
<ul>
<li><kbd>contacts2.db</kbd></li>
<li><kbd>calllog.db</kbd></li>
</ul>
</li>
</ul>
<p>The <kbd>files</kbd> directory contains photos for the user's contacts in the <kbd>photos</kbd> directory, and the user's profile photo in the <kbd>profile</kbd> directory.</p>
<p class="mce-root"/>
<p>The <kbd>contacts2.db</kbd> database contains all of the information about all contacts in the user's Google account:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td>
<p><strong>Table</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>accounts</kbd></p>
</td>
<td>
<p>Shows accounts on the device that have access to the contacts list. At least one of the accounts will show the user's Google account email address. This list may include third-party apps installed that have permission to access the contacts list (we will see this in the Tango, Viber, and WhatsApp sections).</p>
</td>
</tr>
<tr>
<td>
<p><kbd>contacts</kbd></p>
</td>
<td>
<p>Contains partial information for contacts (more data can be found in the <kbd>raw_contacts</kbd> table). The <kbd>name_raw_contact_id</kbd> value corresponds to the <kbd>_id</kbd> value in the <kbd>raw_contacts</kbd> table. The <kbd>photo_file_id</kbd> value corresponds to the filename found in the <kbd>/files/photos</kbd> directory. <kbd>times_contacted</kbd> and <kbd>last_time_contacted</kbd> show the number of times that contact was called from or made a call to the device, and the time of the last call in Unix epoch format.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>data</kbd></p>
</td>
<td>
<p>This table contains all of the information for each contact, such as email address and phone numbers. The <kbd>raw_contact_id</kbd> column is a unique value for each contact that can be correlated with the <kbd>_id</kbd> value in the <kbd>raw_contact_id</kbd> to identify the contact. Note that each contact may have several rows, as seen by the identical <kbd>raw_contact_id</kbd> values. There are 15 data columns (<kbd>data1</kbd>-<kbd>data15</kbd>) that contains some information about the contact, but there are no discernible patterns. The same column may contain the contact name, an email address, a Google+ profile, and so on. The value in the <kbd>data14</kbd> column correlates to the file names of the images in the <kbd>files/profiles</kbd> path. The <kbd>data15</kbd> column contains a thumbnail of the contact's profile photo.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>deleted_contacts</kbd></p>
</td>
<td>
<p>Contains a <kbd>contact_id</kbd> value and <kbd>deleted_contact_timestamp</kbd> in Unix epoch format. However, this cannot be correlated back to any other tables to identify the name of the contact that was deleted. It may be possible to use the deleted data-recovery techniques in <a href="ef5e768c-313d-4637-8784-15067dbf51dc.xhtml" target="_blank">Chapter 6</a>, <em>Recovering Deleted Data from an Android Device</em>, to recover the contact names, though. The <kbd>contact_id</kbd> value corresponds to the <kbd>contact_id</kbd> column in the <kbd>raw_contacts</kbd> table.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>groups</kbd></p>
</td>
<td>
<p>Shows groups in the contact list, either automatically generated or created by the user. The title of the group is the name of the group. There does not appear to be a way to identify users in each group.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>raw_contacts</kbd></p>
</td>
<td>
<p>Contains all information for every contact in the contact list. The <kbd>display_name</kbd> shows the contact's name, if it is available. To determine the contact's phone number, email address, or other information, the <kbd>_id</kbd> column value must be matched back to the <kbd>raw_contact_id</kbd> value in the data table. The <kbd>sync3</kbd> column shows a timestamp, but based on our testing, this cannot be assumed to be when the contact was added; we had contacts several years old that were synced this month. The <kbd>times_contacted</kbd> and <kbd>last_time_contacted</kbd> columns only apply for phone calls; sending an email or SMS to a contact did not increment these values.</p>
<p>We were unable to identify any means to determine whether a contact was added through the phone interface, added as a friend on Google+, or added through other methods.</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p><kbd>calllog.db</kbd> contains all of the information about incoming, outgoing, and missed calls:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td>
<p><strong>Table</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>calls</kbd></p>
</td>
<td>
<p>Contains information regarding all calls to and from the device. The number column shows the remote user's phone number and whether the call was sent or received. The <kbd>date</kbd> column is the date/time of the call, stored in Unix epoch format. The <kbd>duration</kbd> column is the length of the call in seconds. The <kbd>type</kbd> column indicates the type of call:</p>
<ul>
<li>Incoming</li>
<li>Outgoing</li>
<li>Missed</li>
</ul>
<p>The <kbd>name</kbd> column shows the remote user's name, if the number was stored in the contact list. <kbd>geocoded_location</kbd> shows the location of the phone number, based on the area code (for US numbers) or country code.</p>
</td>
</tr>
</tbody>
</table>


            

            
        
    </div>



  
<div><h1 class="header-title">SMS/MMS analysis</h1>
                
            
            
                
<p>SMS and MMS messages are stored in the same database. In our experience, this database is also used regardless of what application is used to send the SMS/MMS (that is, sending an SMS through Google Hangouts will populate this database, not the Hangouts database examined here), although third-party apps may also record the data in their own databases.</p>
<p><strong>Package name</strong>: <kbd>com.android.providers.telephony</kbd></p>
<p><strong>Files of interest</strong>:</p>
<ul>
<li><kbd>/files</kbd></li>
<li><kbd>/databases/</kbd>:
<ul>
<li><kbd>mmssms.db</kbd></li>
<li><kbd>telephony.db</kbd></li>
</ul>
</li>
</ul>
<p>The <kbd>files</kbd> directory contains attachments sent as an MMS, both sent and received.</p>
<p>The <kbd>telephony.db</kbd> database is small, but contains one potentially useful source of information:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td>
<p><strong>Table</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>siminfo</kbd></p>
</td>
<td>
<p>Contains historical data for all SIMs that have been used in the device, including the ICCID, phone number (if it was stored on the SIM), and the MCC/MNC, which can be used to identify the network provider.</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>The <kbd>mmssms.db</kbd> database contains all information regarding SMS and MMS messages:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td>
<p><strong>Table</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>part</kbd></p>
</td>
<td>
<p>Contains information about files attached to an MMS. Each message will have at least two parts: an SMIL header and the attachment—this can be seen in the <kbd>mid</kbd> and <kbd>ct</kbd> columns, as well as the file type attached. The <kbd>_data</kbd> column provides the path to find the file on the device.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>pdu</kbd></p>
</td>
<td>
<p>Contains metadata about each MMS. The <kbd>date</kbd> column identifies when the message was sent or received, in Linux epoch format. The <kbd>_id</kbd> column appears to correspond to the mid value in the <kbd>part</kbd> column; correlating these values will show the time a specific image was sent. The <kbd>msg_box</kbd> column shows the direction of the message (<kbd>1</kbd> = received and <kbd>2</kbd>=sent).</p>
</td>
</tr>
<tr>
<td>
<p><kbd>sms</kbd></p>
</td>
<td>
<p>Contains metadata about each SMS (does not include MMS information). The address column shows the phone number of the remote user, regardless of whether it was a sent or received message. The <kbd>person</kbd> column contains a value that can be looked up in the <kbd>contacts2.db</kbd> database, and corresponds with <kbd>raw_contact_id</kbd> in the <kbd>data</kbd> table. The <kbd>person</kbd> column will be blank if it was a sent message, or if the remote user is not in the contacts list. The <kbd>date</kbd> column shows the timestamp a message was sent in Linux epoch format. The <kbd>type</kbd> column shows the direction of the message (<kbd>1</kbd> = received and <kbd>2</kbd> = sent). The <kbd>body</kbd> column displays the content of the message. The seen column indicates whether the message was read (<kbd>0</kbd> = unread and <kbd>1</kbd> = read); all sent messages will be marked as unread.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>words</kbd>, <kbd>words_content</kbd>, <kbd>words_segdir</kbd></p>
</td>
<td>
<p>Appears to contain duplicate content of messages; the exact purpose of this table is unclear.</p>
</td>
</tr>
</tbody>
</table>


            

            
        
    </div>



  
<div><h1 class="header-title">User dictionary analysis</h1>
                
            
            
                
<p>The user dictionary is an incredible source of data for an examiner. The user dictionary is populated any time the user types a word that isn't recognized and chooses to save the word to avoid it being flagged by autocorrect. Interestingly, our test device contained dozens of words that we never typed or saved on the device; this data appears to sync with a user's Google account and persists across multiple devices. Words synced from the account were added in alphabetical order at the top of the database, while words added manually afterwards were populated in the order they were added at the bottom.</p>
<p><strong>Package name</strong>: <kbd>com.android.providers.userdictionary</kbd></p>
<p><strong>Files of interest</strong>:</p>
<ul>
<li><kbd>/databases/user_dict.db</kbd></li>
</ul>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td>
<p><strong>Table</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>words</kbd></p>
</td>
<td>
<p>The <kbd>word</kbd> column contains the word that was added to the dictionary. The frequency column should likely be ignored; it displayed the same value (250) regardless of the number of times we used the word.</p>
</td>
</tr>
</tbody>
</table>
<p class="mce-root"/>
<p>Here are sample entries from a user dictionary:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-749 image-border" src="img/c49f7f3e-39c9-4d3c-a9ab-9bed56a79507.png" style="width:40.08em;height:9.33em;" width="481" height="112"/></p>


            

            
        
    </div>



  
<div><h1 class="header-title">Gmail analysis</h1>
                
            
            
                
<p>Gmail is an email service provided by Google. A Gmail account is often asked for, though is not required, when the device is being set up for the first time.</p>
<p><strong>Package name</strong>: <kbd>com.google.android.gm</kbd></p>
<p><strong>Files of interest</strong>:</p>
<ul>
<li><kbd>/cache</kbd></li>
<li><kbd>/databases/</kbd>:
<ul>
<li><kbd>mailstore.&lt;username&gt;@gmail.com.db</kbd></li>
<li><kbd>databases/suggestions.db</kbd></li>
</ul>
</li>
<li><kbd>/shared_prefs/</kbd>:
<ul>
<li><kbd>MailAppProvider.xml</kbd></li>
<li><kbd>Gmail.xml</kbd></li>
<li><kbd>UnifiedEmail.xml</kbd></li>
</ul>
</li>
</ul>
<p>The <kbd>/cache</kbd> directory within the application folder contains recent files that were attached to emails, both sent and received. These attachments are saved here even if they are not explicitly downloaded by the user.</p>
<p>The <kbd>mailstore.&lt;username&gt;@gmail.com.db</kbd> file contains a variety of useful information. Interesting tables within the database include:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td>
<p><strong>Table</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>attachments</kbd></p>
</td>
<td>
<p>Information about attachments, including their size and file path on the device (the <kbd>/cache</kbd> directory mentioned above). Each row also contains a <kbd>messages_conversation</kbd> value; this value can be compared with the conversations table to correlate an attachment with the email it was included within. The <kbd>filename</kbd> column identifies the path on the device where the file is located.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>conversations</kbd></p>
</td>
<td>
<p>In older versions, entire email conversations could be recovered. In the current version, Google no longer stores the entire conversation on the device, likely assuming that the user will have a data connection to download the full conversation. Instead, only the subject line and a snippet can be recovered. The snippet is roughly the amount of text that would appear in the notification bar or inbox screen of the app. The <kbd>fromCompact</kbd> column identifies the sender and any other recipients.</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>The <kbd>suggestions.db</kbd> database contains terms that were searched within the application.</p>
<p>The XML files within the <kbd>shared_prefs</kbd> directory can confirm the account(s) that were used with the application. <kbd>Gmail.xml</kbd> contained another account that was linked with our test account, but never used with the application. <kbd>UnifiedEmail.xml</kbd> contained a partial list of senders who emailed the account, but with no discernible rationale; many senders were on the list, but far from all, and they appeared in no particular order. <kbd>Gmail.xml</kbd> also contained the last time that the application was synced, in the Unix epoch format.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Google Chrome analysis</h1>
                
            
            
                
<p>Google Chrome is a web browser, and is the default browser on many devices. Chrome data on the device is somewhat unique in that it contains data not just from the device, but from all devices on which the user has logged into Chrome. This means that it is entirely possible (even very likely) that data from the user browsing on their desktop computer will be found in the databases on their phone. However, this also leads to huge amounts of data for an examiner to sort through, but that's a good problem to have.</p>
<p><strong> </strong></p>
<p class="mce-root"/>
<p><strong>Package name</strong>: <kbd>com.android.chrome</kbd></p>
<p><strong>Files of interest</strong>:</p>
<ul>
<li><kbd>/app_chrome/Default/</kbd>:
<ul>
<li><kbd>Sync Data/SyncData.sqlite3</kbd></li>
<li><kbd>Bookmarks</kbd></li>
<li><kbd>Cookies</kbd></li>
<li><kbd>Google Profile Picture.png</kbd></li>
<li><kbd>History</kbd></li>
<li><kbd>Login Data</kbd></li>
<li><kbd>Preferences</kbd></li>
<li><kbd>Top Sites</kbd></li>
<li><kbd>Web Data</kbd></li>
</ul>
</li>
<li><kbd>/app_ChromeDocumentActivity/</kbd></li>
</ul>
<p>All of the files listed in the <kbd>/app_chrome/Default</kbd> folder, except for the one PNG file, <kbd>Bookmarks</kbd>, and <kbd>Preferences</kbd>, are SQLite databases despite the lack of a file extension.</p>
<p>The <kbd>SyncData.sqlite3</kbd> database is interesting because it appears to contain a list of data that has been synced from the user's account on the device back to Google's servers. Our database, with a very active Chrome account, contained over 2,700 entries, and included browsing history, autofill form information, passwords, and bookmarks. As an example, we were able to find a term one of the authors had searched for from 2012, seen in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-750 image-border" src="img/d129000c-f8a7-4666-87d7-8d831ce7c253.png" style="width:52.83em;height:6.33em;" width="634" height="76"/></p>
<p> </p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td>
<p><strong>Table</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>metas</kbd></p>
</td>
<td>
<p>There are many columns in the database that contain timestamps, and in our database they all appear to only seconds apart for each entry. It is unclear which time corresponds to the exact time an entry was added, but all of the times roughly correspond with the time of the activity in the user's account. The columns with timestamps are <kbd>mtime</kbd>, <kbd>server_mtime</kbd>, <kbd>ctime</kbd>, <kbd>server_ctime</kbd>, <kbd>base_version</kbd>, and <kbd>server_version</kbd>.</p>
<p>The <kbd>non_unique_name</kbd> and <kbd>server_non_unique_name</kbd> columns show the content that was synced. For example, one of our entries shows:</p>
<p><kbd>autofill_entry|LNAME|Tindall</kbd></p>
<p>Other entries in these columns include URLs visited, passwords, and even devices that the account has used.</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>The <kbd>Bookmarks</kbd> file is a plaintext file, containing information about bookmarks synced with the account. It includes the name of each site that is bookmarked, the URL, and the date/time it was bookmarked, which is stored in a format we have not come across yet: Webkit format. To decode the values, see the <em>Decoding the Webkit time format</em> section.</p>
<div><p>This is data storage method 3: Webkit time format.</p>
</div>
<p>The <kbd>Cookies</kbd> database stores cookie information for sites visited (depending on the site and Chrome settings), including the name of the site, the date the cookie was saved, and the last time the cookie was accessed, in Webkit time format.</p>
<p>The <kbd>Google Profile Picture.PNG</kbd> file is the user's profile picture.</p>
<p>The <kbd>History</kbd> database contains the user's web history.</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td>
<p><strong>Table</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>keyword_search_terms</kbd></p>
</td>
<td>
<p>Contains a list of terms that were searched for using Google within Chrome. The term column shows what was searched, while the <kbd>url_id</kbd> can be correlated with the URLs table to see the time of the search.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>segments</kbd></p>
</td>
<td>
<p>This table contains some URLs that were visited, but not all. It is not clear what causes data to be entered into this table.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>urls</kbd></p>
</td>
<td>
<p>Contains browsing history for the Google account across all devices, not just the device the database was pulled from. Our history went back approximately 3 months and contained 494 entries, although the Google account is much older than that and we have certainly visited more than 494 pages in that time. It is unclear exactly what causes this discrepancy or determines the cutoff date for the history.</p>
<p>The <kbd>id</kbd> column is a unique value for each row in the table. The <kbd>url</kbd> and <kbd>title</kbd> columns contain the URL visited and the name of the page. The <kbd>visit_count</kbd> column appears to be an accurate count of how many times the URL was visited. <kbd>typed_count</kbd> is always equal to or lesser than <kbd>visit_count</kbd>, but we do not know exactly what it indicates. For some sites, the discrepancy can be accounted for by factoring in the number of times the site was visited through a bookmark rather than typing the URL, but this does not hold true for all cases. <kbd>last_visit_time</kbd> is the last time the URL was visited, in Webkit time format.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>visits</kbd></p>
</td>
<td>
<p>Contains a row for each visit to the URLs in the <kbd>urls</kbd> table; the number of entries in this table for a URL corresponds to the value in the <kbd>visit_count</kbd> column of the <kbd>url</kbd> table. The <kbd>url</kbd> column value correlates to the value in the id column of the <kbd>url</kbd> table. The time of each visit can be found in the <kbd>visit_time</kbd> column, again in Webkit time format.</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>The <kbd>Login Data</kbd> database contains login information saved in Chrome, and is synced across all devices that use the Google account:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td>
<p><strong>Table</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>logins</kbd></p>
</td>
<td>
<p><kbd>origin_url</kbd> is the site the user visited initially, <kbd>action_url</kbd> is the URL of the login page if the user is redirected to one; if the first page visited is the login page, both URLs are the same. The <kbd>username_value</kbd> and <kbd>password_value</kbd> columns show the username and password stored for that URL in plaintext; and no, we're not going to include a screenshot of our database! <kbd>date_created</kbd> is the date/time that login information was first saved, in Webkit time format. The <kbd>date_synced</kbd> column is the date/time that login data was synced locally to the device, again in Webkit time format. The <kbd>times_used</kbd> column shows the number of times that login information was autofilled by Chrome after it was saved (excluding the first login, so some values may be 0).</p>
</td>
</tr>
</tbody>
</table>
<ul>
<li>The <kbd>Preferences</kbd> file is a text file, and contains the Google account(s) the user has signed into Chrome with.</li>
<li>The <kbd>Top Sites</kbd> database contains the sites that are most frequently visited, as these are shown by default when Chrome opens.</li>
<li>The <kbd>Web Data</kbd> database contains information the user has saved in order to automatically fill in forms on websites.</li>
</ul>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td>
<p><strong>Table</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>autofill</kbd></p>
</td>
<td>
<p>Contains a list of fields on web-based forms and the value the user typed. The <kbd>name</kbd> column shows the name of the field that was typed in, while the <kbd>value</kbd> column shows what the user typed. <kbd>date_created</kbd> and <kbd>date_last_used</kbd> are self-explanatory, and are stored in Linux epoch format.</p>
<p>Note that while this is potentially very valuable information (for example, our database contained a few usernames not stored elsewhere), there is also very little context available. The URL where the information is not stored, and may not be determinable.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>autofill_profile_emails</kbd></p>
</td>
<td>
<p>Contains all values the user has saved to autofill the <kbd>email</kbd> field on a web form.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>autofill_profile_names</kbd></p>
</td>
<td>
<p>Contains all values the user has saved to autofill the <strong>First</strong>, <strong>Middle</strong>, <strong>Last</strong>, and <strong>Full Name</strong> fields on a web form.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>autofill_profile_phonwa</kbd></p>
</td>
<td>
<p>Contains all values the user has saved to autofill the <strong>Phone Number</strong> field on a web form.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>autofill_profiles</kbd></p>
</td>
<td>
<p>Contains all values the user has saved to autofill address information fields on a web form.</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>The <kbd>/app_ChromeDocumentActivity/</kbd> directory contains files with history for recent tabs that were open on the device. URLs can be recovered from these files for sites that were visited.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Decoding the Webkit time format</h1>
                
            
            
                
<p>Here is a sample Webkit time value: 13066077007826684.</p>
<p>At first glance, it appears to be very similar to Unix epoch time, just slightly longer (perhaps it is storing nanoseconds?). An examiner who attempts to decode this as epoch time will get a date in May 2011, which may seem accurate, but is in fact several years off from the correct date!</p>
<p>Webkit time <em>is</em> an epoch time, it is just based on a different starting point than Unix epoch time. Webkit epoch time is the number of microseconds since midnight on January 1st, 1601. Yes, we said the year 1601. Once we know where the epoch begins, converting to a recognizable format simply becomes a math problem. But, once again, we'd rather use DCode.</p>
<p>This time in DCode, choose Google Chrome Value in the <strong>Decode Format</strong> dropdown selection, and click <strong>Decode</strong>:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-751 image-border" src="img/03e81ce5-4f46-4ef6-b02f-5b90f73c9872.png" style="width:45.08em;height:23.58em;" width="541" height="283"/></p>
<p>The actual value of our example is November 2nd, 2014 at 18:04:33 UTC; significantly different than the value we would have come up with if we'd thought it was a Unix epoch time!</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Google Maps analysis</h1>
                
            
            
                
<p>Maps is a map/navigation application provided by Google.</p>
<p><strong>Package name</strong>: <kbd>com.google.android.apps.maps</kbd></p>
<p><strong>Files of interest</strong>:</p>
<ul>
<li><kbd>/cache/http/</kbd></li>
<li><kbd>/databases/</kbd>:
<ul>
<li><kbd>gmm_myplaces.db</kbd></li>
<li><kbd>gmm_storage.db</kbd></li>
</ul>
</li>
</ul>
<p>The <kbd>/cache/http</kbd> folder contains many files, with <kbd>.0</kbd> and <kbd>.1</kbd> file extensions. The <kbd>.0</kbd> files are web requests for the corresponding <kbd>.1</kbd> file. The <kbd>.1</kbd> files are predominantly images, and can be viewed by changing their extension appropriately; on our test device, they were either <kbd>.jpg</kbd> or <kbd>.png</kbd> files. These files were predominantly locations near the user, not necessarily locations the user specifically searched for.</p>
<div><p>This is data storage method 4: misnamed file extensions</p>
<p>Always verify the header of a file that can't be opened, or use automated tools, such as EnCase, to detect the mismatched header/file extension. A good resource to verify a file's signature is <a href="http://www.garykessler.net/library/file_sigs.html">http://www.garykessler.net/library/file_sigs.html</a>.</p>
</div>
<p>The <kbd>gmm_myplaces.db</kbd> database contains locations saved by the user. This file syncs with the user's Google account, so these locations were not necessarily saved using the application.</p>
<p><kbd>gmm_storage.db</kbd> contains search hits and locations that were navigated to:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td>
<p><strong> Table</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>gmm_storage_table</kbd></p>
</td>
<td>
<p>The <kbd>_key_pri</kbd> column appears to identify the type of the location, bundled appears to be a hit that came up on a search, while <kbd>ArrivedAtPlacemark</kbd> identifies locations that were actually navigated to. The <kbd>_data</kbd> column contains the address for the location.</p>
</td>
</tr>
</tbody>
</table>


            

            
        
    </div>



  
<div><h1 class="header-title">Google Hangouts analysis</h1>
                
            
            
                
<p>Hangouts is a chat/SMS application provided by Google. Hangouts is the default SMS client on Android devices.</p>
<p><strong>Package name</strong>: <kbd>com.google.android.talk</kbd></p>
<p class="mce-root"/>
<p class="mce-root"/>
<p><strong>Files of interest</strong>:</p>
<ul>
<li><kbd>/cache/volleyCache/</kbd></li>
<li><kbd>/databases/babel#.db</kbd> (our device had <kbd>babel0.db</kbd> and <kbd>babel1.db</kbd>)</li>
<li><kbd>/shared_prefs/accounts.xml</kbd></li>
</ul>
<p>The <kbd>cache</kbd> directory contains .0 files, as discussed in the Google Maps example. The files contain a URL to fetch the profile pictures of contacts, as well as a JPG embedded within the file. Visiting the URL or carving the JPG from the file will recover the contact's picture.</p>
<p>The <kbd>babel#.db</kbd> file contains all messaging data. On our test device, <kbd>babel0.db</kbd> was blank and <kbd>babel1.db</kbd> had all of the data for the active account. There are many tables within this database worth looking at:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td>
<p><strong>Table</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>conversations</kbd></p>
</td>
<td>
<p>Contains conversation data. There is a unique <kbd>conversation_id</kbd> for each chat. <kbd>latest_message_timestamp</kbd> is the time of the most recent chat, in Linux epoch format. The <kbd>generated_name</kbd> column has a list of all participants in the chat, minus the account on the device. The <kbd>snippet_text</kbd> column is the content of the most recent message; like Gmail, the entire chat is not stored on the device. The <kbd>latest_message_author_full_name</kbd> and <kbd>latest_message_author_first_name</kbd> columns identify the author of the <kbd>snippet_text</kbd> column. The <kbd>inviter_full_name</kbd> and <kbd>inviter_first_name</kbd> columns identify which person initiated the conversation.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>dismissed_contacts</kbd></p>
</td>
<td>
<p>Has a list of names of former contacts that had been messaged. These are labelled as a <strong>Hidden Contact</strong> within the app.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>messages</kbd></p>
</td>
<td>
<p>As expected, contains a detailed message history for each conversation. Text contains the content of the message, and the timestamp column is the date/time in Linux epoch format. The <kbd>remote_url</kbd> column is, once again, a URL to retrieve images shared in the message. Again, it can be accessed publicly. <kbd>author_chat_id</kbd> is a value that can be correlated with the participants table to identify the author of each message.</p>
</td>
</tr>
<tr>
<td>
<p>p<kbd>a</kbd>rticipants</p>
</td>
<td>
<p>Contains a list of people chatted with. Includes full names, profile picture URLs, and a <kbd>chat_id</kbd> to identify the person in the messages table.</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>The <kbd>accounts.xml</kbd> file has a <kbd>phone_verification</kbd> field that contains the phone number associated with the Google account when Hangouts is configured to send SMS. This could be highly useful, because it is frequently difficult to obtain the device's phone number as it is often not stored on the device.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Google Keep analysis</h1>
                
            
            
                
<p>Keep is a note-taking application provided by Google. It can also be used to set reminders, either at a certain date/time or when the user is at a specified location.</p>
<p><strong>Package name</strong>: <kbd>com.google.android.keep</kbd></p>
<p><strong>Files of interest</strong>:</p>
<ul>
<li><kbd>/databases/keep.db</kbd></li>
<li><kbd>/files/1/image/original</kbd></li>
</ul>
<p>The <kbd>files/1/image/original</kbd> directory contains photos taken using the app. Notes and reminders can both be associated with an image.</p>
<p><kbd>Keep.db</kbd> contains all of the information about notes and reminders. There are, once again, several tables of interest:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td>
<p><strong>Table</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>alert</kbd></p>
</td>
<td>
<p>Contains information about location-based reminders. <kbd>reminder_id</kbd> can be correlated with entries in the reminder table. The <kbd>reminder_detail</kbd> table contains the latitude and longitude set for the reminder. <kbd>scheduled_time</kbd> is the date/time the reminder was set, in Linux epoch time.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>blob</kbd></p>
</td>
<td>
<p>Contains metadata about images in the <kbd>/files</kbd> directory, including the filename and size. <kbd>blob_id</kbd> can be correlated with the <kbd>_id</kbd> column in the <kbd>blob_node</kbd> table.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>blob_node</kbd></p>
</td>
<td>
<p>Contains the time created value for the images in the <kbd>/files</kbd> directory, in Linux epoch time.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>list_item</kbd></p>
</td>
<td>
<p>Stores data for each note on the device. The text column contains the full text of each note. The <kbd>list_parent_id</kbd> column is a unique value for each note; if multiple rows have the same value, it means they were created as a list within the same note. The <kbd>time_created</kbd> and <kbd>time_last_updated</kbd> columns are the time the note was created, and the time it was last synced with the Google servers, in Linux epoch time.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>reminder</kbd></p>
</td>
<td>
<p>Contains data about each reminder set within the app. If the reminder is time-based, the <kbd>julian_date</kbd> and <kbd>time_of_day</kbd> columns will be populated.</p>
</td>
</tr>
</tbody>
</table>
<p> </p>


            

            
        
    </div>



  
<div><h1 class="header-title">Converting a Julian date</h1>
                
            
            
                
<p>Julian dates are similar to the Linux epoch format, simply starting from a different date. The Julian date system counts the number of days since noon on January 1st, 4713 BC. The United States Naval Observatory has an excellent Julian date calculator: <a href="http://aa.usno.navy.mil/data/docs/JulianDate.php">http://aa.usno.navy.mil/data/docs/JulianDate.php</a>. To obtain the Julian date from the database, simply combine the two columns with a decimal in between, for example:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-752 image-border" src="img/b3403864-ed38-4447-b41a-b109e10bb0cf.png" style="width:17.17em;height:7.25em;" width="206" height="87"/></p>
<p>This would correspond to the Julian date <kbd>2457042.46800000</kbd>. When this value is input to the website, we find out the date the reminder is set for is January 19 2015 at 23:13:55.2 UT. The <kbd>location_name</kbd>, <kbd>latitude</kbd>, <kbd>longitude</kbd>, and <kbd>location_address</kbd> columns will be populated if a reminder is set as location-based. Finally, the <kbd>time_created</kbd> and t<kbd>ime_last_updated</kbd> columns are the time the note was created, and the time it was last synced with the Google servers, in Linux epoch time.</p>
<div><p>Data storage method 5: Julian date</p>
</div>


            

            
        
    </div>



  
<div><h1 class="header-title">Recovering video messages from Skype</h1>
                
            
            
                
<p>As noted, video messages are not stored on the device. Luckily for us, they can be accessed via the internet. The first step is to verify that a video message was sent, by looking in the Messages table in the <kbd>body_xml</kbd> column. Next, note the <kbd>convo_id</kbd> field for the message:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-755 image-border" src="img/f5db9d12-4c94-4810-a676-7b559636dcdc.png" style="width:33.17em;height:4.25em;" width="398" height="51"/></p>
<p>Our video message is in <kbd>convo_id</kbd> <kbd>257</kbd>.</p>
<p>Then, look in the Chats table for that <kbd>convo_id</kbd> in the <kbd>conv_dbid</kbd> column, and find the <kbd>dbpath</kbd> value. This will be the name of the conversation's backup file:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-756 image-border" src="img/5e05131a-7f75-4b61-9efb-fd56e96a56e8.png" style="width:17.00em;height:4.33em;" width="204" height="52"/></p>
<p>To find the backup file, look in <kbd>files/&lt;username&gt;/chatsync</kbd>. There will be a folder for each conversation, the name of the folder is the first two digits of the backup name. Our backup will be in folder <kbd>28</kbd>.</p>
<p>Open the backup file in a hex editor, and search for <kbd>videomessage</kbd>. You should find a URL and a code to access the video:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-757 image-border" src="img/d5be7bdf-9ff6-4a69-9862-c265f38f342e.png" style="width:32.50em;height:10.92em;" width="390" height="131"/></p>
<div><p>Actually accessing the URL may require an additional warrant or legal permission, depending on your local jurisdiction. As this data is not on the device, and is private, viewing it without legal guidance could invalidate any evidence found in the video.</p>
</div>
<p class="mce-root"/>


            

            
        
    </div>



  
<div><h1 class="header-title">Google Plus analysis</h1>
                
            
            
                
<p>Google Plus is the Google-based social network. It allows the sharing of text/videos/images, adding friends, following people, and messaging. Google Plus may also, depending on the user's settings, automatically upload all pictures taken on the user's device.</p>
<p><strong>Package name</strong>: <kbd>com.google.android.apps.plus</kbd></p>
<p><strong>Files of interest</strong>:</p>
<ul>
<li><kbd>/databases/es0.db</kbd></li>
</ul>
<p> </p>
<p><kbd>Es0.db</kbd> contains all the information an examiner would expect to find from a social media account:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td>
<p><strong>Table</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>all_photos</kbd></p>
</td>
<td>
<p>Contains a URL to download images shared by and with the user,  as well as the creation date/time in Linux epoch format</p>
</td>
</tr>
<tr>
<td>
<p><kbd>activities</kbd></p>
</td>
<td>
<p>Data displayed in the user's stream (that is, their news feed). The created and modified time for each post is, once again, stored in Linux epoch time. The title and comment columns will contain the post title and at least some of the comments from it. The permalink column contains a URL that can be followed to view the post, if it was shared publicly. If the post is shared privately, the content can still be recovered from the embed table. The related table contains the hashtags automatically generated for the post by Google, this will also populate even if the post is private.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>activity_contacts</kbd></p>
</td>
<td>
<p>Contains a list of names for people whose posts are in the activities table.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>all_photos</kbd></p>
</td>
<td>
<p>Contains a list of ALL photos the user has backed up to Google Plus, whether they were shared or not. <kbd>image_url</kbd> can be used to download any of the user's photos, and is publicly available. Removing the <kbd>-d</kbd> on the end of the URL will allow you to view the image without downloading. The timestamp column is the date/time the image was <em>taken</em>, based on the image metadata; it does not indicate when the image was uploaded.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>all_tiles</kbd></p>
</td>
<td>
<p>Contains an unknown subset of <kbd>all_photos</kbd>, but also includes images shared with the user.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>circle_contact</kbd></p>
</td>
<td>
<p>Contains a list of people the user has added to their circles. Does not include names, but some of the <kbd>link_person_id</kbd> values include email addresses. The <kbd>link_circle_id</kbd> value can be correlated with the circles table to identify the name of each circle. <kbd>link_person_id</kbd> can then be correlated with the contacts table to identify which user is in which circle.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>circles</kbd></p>
</td>
<td>
<p>Has all circles the user has created, as well as a count of the number of users in each one.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>contacts</kbd></p>
</td>
<td>
<p>A list of all contacts in the user's circles.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>events</kbd></p>
</td>
<td>
<p>A listing of all events the user has been invited to, whether they attended or not. The name column is the title of the event. <kbd>creator_gaia_id</kbd> can be correlated with the <kbd>gaia_id</kbd> column in the contacts table to identify the event creator. The <kbd>start_time</kbd> and <kbd>end_time</kbd> columns are the time of the event, in Linux epoch format. The <kbd>event_data</kbd> column has the description of the event entered by the creator, as well as information about the location if added. It also lists all other users who were invited to the event.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>squares</kbd></p>
</td>
<td>
<p>A list of groups the user has joined.</p>
</td>
</tr>
</tbody>
</table>


            

            
        
    </div>



  
<div><h1 class="header-title">Facebook analysis</h1>
                
            
            
                
<p>Facebook is a social media application with more than 1,000,000,000 downloads from Google Play.</p>
<p><strong>Package name</strong>: <kbd>com.facebook.katana</kbd></p>
<p><strong>Files of interest</strong>:</p>
<ul>
<li><kbd>/files/video-cache/</kbd></li>
<li><kbd>/cache/images/</kbd></li>
<li><kbd>/databases/</kbd>
<ul>
<li><kbd>bookmarks_db2</kbd></li>
<li><kbd>contacts_db2</kbd></li>
<li><kbd>nearbytiles_db</kbd></li>
<li><kbd>newsfeed_db</kbd></li>
<li><kbd>notifications_db</kbd></li>
<li><kbd>prefs_db</kbd></li>
<li><kbd>threads_db2</kbd></li>
</ul>
</li>
</ul>
<p>The <kbd>/files/video-cache</kbd> directory contains videos from the user's newsfeed, though there does not appear to be a way to correlate them with the user who posted them.</p>
<p>The <kbd>/cache/images</kbd> directory contains images from the user's newsfeed, as well as profile photos of contacts. The directory contains a multitude of other directories (65 on our test phone), and each directory can contain multiple <kbd>.cnt</kbd> files. The <kbd>.cnt</kbd> files are typically JPG files or other image formats.</p>
<p>The <kbd>bookmarks_db2</kbd> database is a list of items that appear on the side of the user's newsfeed, such as groups and applications. Many of these bookmarks are automatically generated by Facebook, but may also be created by the user.</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td>
<p><strong>Table</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p>bookmarks</p>
</td>
<td>
<p>Contains all of the info within the database. The <kbd>bookmark_name</kbd> column is the name of the bookmark displayed to the user. The <kbd>bookmark_pic</kbd> column has a publicly-accessible URL to view the bookmark icon displayed to the user. The <kbd>bookmark_type</kbd> column identifies the type of the group; our testing showed <kbd>profile</kbd>, <kbd>group</kbd>, <kbd>app</kbd>, <kbd>friend_list</kbd>, <kbd>page</kbd>, and <kbd>interest_list</kbd>. Finally, the <kbd>bookmark_unread_count</kbd> column shows how many messages in the group have not been read by the user.</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>The <kbd>contacts_db2</kbd> database, predictably, contains information about all of the user's contacts:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td>
<p><strong>Table</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>contacts</kbd></p>
</td>
<td>
<p>Contains all information about the user's contacts. The <kbd>fbid</kbd> column is a unique ID that is used to identify the contact in other databases. The <kbd>first_name</kbd>, <kbd>last_name</kbd>, and <kbd>display_name</kbd> columns show the contact's name. <kbd>small_picture_url</kbd>, <kbd>big_picture_url</kbd>, and <kbd>huge_picture_url</kbd> contain public links to the contact's profile picture. <kbd>communication_rank</kbd> appears to be a number identifying how often the contact communicates with the user (taking into account messages, comments, and possibly other factors); a higher number indicates more communication with that contact. <kbd>added_time_ms</kbd> shows the time (in Linux epoch format) the contact was added as a friend. The <kbd>bday_day</kbd> and <kbd>bday_month</kbd> columns show the contact's birthdate, but not the year. The data column contains a duplicate of all the rest of the data in the database, but also contains the contact's location, which is not found elsewhere in the database.</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p><kbd>nearbytiles_db</kbd> is a database that contains locations near the user that may interest them; this is apparently populated constantly, even if the user does not view the locations. It is interesting because, while it isn't a fine location (most of our tests showed locations within 6-10 miles of our location), it is a rough idea of places a user has been:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td>
<p><strong>Table</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>nearby_tiles</kbd></p>
</td>
<td>
<p>Contains latitude and longitude values for locations near the user, as well as the time the location was retrieved from the Facebook servers in Linux epoch format.</p>
</td>
</tr>
</tbody>
</table>
<p class="mce-root"/>
<p><kbd>newsfeed_db</kbd> contains data shown to the user in their newsfeed. Depending on the usage of the app, it can be a very large file:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td>
<p><strong>Table</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>home_stories</kbd></p>
</td>
<td>
<p>The <kbd>fetched_at</kbd> column shows the time the story was pulled from the Facebook servers, and likely corresponds closely with the time the user was using the application or saw the story. The <kbd>story_data</kbd> column contains the story, stored as a blob of data. When viewed in a hex or text editor, the username of the person posting the story can be found. The content of the post can also be found in plaintext, and is often preceded by a tag that says <kbd>text</kbd>. An example of this is shown here:</p>
</td>
</tr>
</tbody>
</table>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-753 image-border" src="img/391c6707-f4f6-44a6-b3cc-9b6faa6b72d5.png" style="width:73.50em;height:11.50em;" width="882" height="138"/></p>
<div><p>Note that the actual content of this one cell in the <kbd>story_data</kbd> column contained over 10,000 bytes of data, though the actual message is only around 50 bytes.</p>
</div>
<p>The <kbd>notifications_db</kbd> contains notifications sent to the user:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td>
<p><strong>Table</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>gql_notifications</kbd></p>
</td>
<td>
<p>The <kbd>seen_state</kbd> column shows whether the notification has been seen and read. The updated column contains the time the notification was updated (that is, sent if it is unread, or the time it was read) in Linux epoch format. The <kbd>gql_payload</kbd> column contains the content of the notification as well as the sender, similar to the <kbd>story_data</kbd> column in <kbd>newsfeed_db</kbd>. The message content again is frequently preceded by the <kbd>text</kbd> flag. A much smaller amount of data, which shows the text of the notification, can be found in the <kbd>summary_graphql_text_with_entities</kbd> and <kbd>short_summary_graphql_text_with_entities</kbd> columns. <kbd>profile_picture_uri</kbd> contains a public URL to view the sender's profile picture, and the <kbd>icon_url</kbd> column has a link to view the icon associated with the notification.</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The <kbd>prefs_db</kbd> database contains application preferences:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td>
<p><strong>Table</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>preferences</kbd></p>
</td>
<td>
<p>The <kbd>/auth/user_data/fb_username</kbd> row shows the user's Facebook username. The <kbd>/config/gk/last_fetch_time_ms</kbd> value is the timestamp of the app's last communication with Facebook servers, but may not be an exact time of the user's last interaction with the app. <kbd>/fb_android/last_login_time</kbd> shows the last time the user logged in through the app. The database contains many other timestamps that, when put together, can be used to build a decent profile of the app's usage. The <kbd>/auth/user_data/fb_me_user</kbd> contains data about the user, including their name, email address, and phone number.</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>The <kbd>threads_db</kbd> database contains messaging information:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td>
<p><strong>Table</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>messages</kbd></p>
</td>
<td>
<p>Each message has a unique ID in the <kbd>msg_id</kbd> column. The text column contains the message in plaintext. The sender column identifies the Facebook ID and name of the message sender. The <kbd>timestamp_ms</kbd> column is the time the message was sent, in Linux epoch format. The attachments column contains a public URL to retrieve attached images. The coordinates column will have the sender's latitude and longitude if they have opted to show their location. The source column identifies whether the message was sent via the website or app.</p>
</td>
</tr>
</tbody>
</table>


            

            
        
    </div>



  
<div><h1 class="header-title">Facebook Messenger analysis</h1>
                
            
            
                
<p>Facebook Messenger is messaging app, separate from the main Facebook application. It has over 500,000,000 downloads in the Play Store.</p>
<p><strong>Package name</strong>: <kbd>com.facebook.orca</kbd></p>
<p><strong>Files of interest</strong>:</p>
<ul>
<li><kbd>/cache/</kbd>
<ul>
<li><kbd>audio/</kbd></li>
<li><kbd>fb_temp/</kbd></li>
<li><kbd>image/</kbd></li>
</ul>
</li>
<li><kbd>/sdcard/com.facebook.orca</kbd></li>
<li><kbd><kbd>/files/ rti.mqtt.analytics.xml</kbd></kbd></li>
<li><kbd>/databases/</kbd>
<ul>
<li><kbd>call_log.sqlite</kbd></li>
<li><kbd>contacts_db2</kbd></li>
<li><kbd>prefs_db</kbd></li>
<li><kbd>threads_db2</kbd></li>
</ul>
</li>
</ul>
<p>The <kbd>/cache/audio</kbd> directory contains audio messages sent through the application. The files have a <kbd>.cnt</kbd> file extension, but are actually RIFF files that can be played with Windows Media Player, VLC media player, and other programs.</p>
<p>The <kbd>/cache/fb_temp</kbd> path contains temp files for images and video sent through the application. It is unclear how long these files will remain; in our testing, we sent and received a total of five files, and all five were still in the temp folder one week later.</p>
<p>The <kbd>/cache/image</kbd> directory contains a multitude of other directories (33 on our test phone), and each directory can contain multiple <kbd>.cnt</kbd> files. The file header should be verified on each file, as some were video files and some were images. Several of the files from the <kbd>fb_temp</kbd> folder were found, as well as the profile pictures of some contacts.</p>
<p>The <kbd>fb_temp</kbd> folder on the SD card contains sent images and video only.</p>
<p>The application also includes an option (disabled by default) to download all received images/video to the device's Gallery. If this option is selected, all received images/video would be found on the SD card.</p>
<p>The <kbd>/files/rti.mqtt.analytics.xml</kbd> file has the user's Facebook UID.</p>
<p>The <kbd>call_log.sqlite</kbd> database contains a log of calls made through the application. The <kbd>person_summary</kbd> table contains the relevant data:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td>
<p><strong>Table</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>person_summary</kbd></p>
</td>
<td>
<p>The <kbd>user_id</kbd> column contains the Facebook ID of the remote user; this can be correlated with the <kbd>fbid</kbd> column in <kbd>contacts_db2</kbd> to determine the user's name. The <kbd>last_call_time</kbd> column contains the time of the previous call in Linux epoch format. This table does not contain information about the direction of the call (sent or received).</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>The <kbd>contacts_db2</kbd> file is a SQLite database, despite the lack of a file extension. Useful tables within this database include:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td>
<p><strong>Table</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>contacts</kbd></p>
</td>
<td>
<p>This table includes contacts the user has added, as well as contacts that were scraped from the user's phonebook (if the phonebook contact uses Facebook Messenger). It contains the first and last name of each contact, as well as that contact's Facebook ID (as discussed in the <kbd>call_log.sqlite</kbd> table). <kbd>added_time_ms</kbd> shows the time each user was added into the app. This can give some insight into whether the contact was added manually or automatically; a large group of contacts added within milliseconds of each other were likely created automatically when the app was installed. The <kbd>small_picture_url</kbd>, <kbd>big_picture_url</kbd>, and <kbd>huge_picture_url</kbd> columns contain public links to the contact's profile picture. A contact's phone number can be found in the blob of information within the data column.</p>
<p> </p>
<p>It should be noted that we have no idea where some of the contacts in this database came from. They were not Facebook friends with our account, and were not contacts in our device's phonebook, but were added at the same time that the phonebook was scraped. Our best guess is that some contacts in our phone have phone numbers that Facebook associated with other users.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>favorite_contacts</kbd></p>
</td>
<td>
<p>The <kbd>favorite_contacts</kbd> table shows contacts that have been added as a favorite by the user. They are identified by the <kbd>fbid</kbd> column, which can be correlated back to the contacts table.</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>The <kbd>prefs_db</kbd> database contains useful metadata about the app and the account:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td>
<p><strong>Table</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>preferences</kbd></p>
</td>
<td>
<p>The <kbd>/messenger/first_install_time</kbd> value indicates the time the application was installed, in Linux epoch time. The <kbd>/auth/user_data/fb_username</kbd> value shows the username associated with the application. The <kbd>/config/neue/validated_phonenumbe</kbd>r value shows the phone number associated with the application. The user's first and last name can be found in the <kbd>/auth/user_data/fb_me_user</kbd> value.</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>Finally, the <kbd>threads_db2</kbd> database contains data about messages:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td>
<p><strong>Table</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>group_clusters</kbd></p>
</td>
<td>
<p>Shows folders the user has created.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>group_conversations</kbd></p>
</td>
<td>
<p>Contains the <kbd>thread_key</kbd> value for each group chat; this can be correlated with the messages table.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>messages</kbd></p>
</td>
<td>
<p>The <kbd>thread_key</kbd> is a unique ID generated for each chat session. The text column has the contents of each text message sent and received. This also identifies voice calls using the phrases <kbd>You called Facebook User.</kbd>, <kbd>Facebook User called you.</kbd>, and <kbd>You missed a call from Facebook User</kbd>. The sender column identifies which user sent each message (or made each call). The <kbd>timestamp_ms</kbd> column shows the time each message was sent, in Linux epoch format. The attachments column will show data for each sent or received attachment, the file type is also visible in the data. <kbd>pending_send_media_attachment</kbd> shows the path on the device to recover sent attachments. Finding received attachments directly does not appear possible, although they were recovered in the <kbd>/cache/images</kbd> directory, there was no way to correlate them with a specific message or sender.</p>
</td>
</tr>
</tbody>
</table>


            

            
        
    </div>



  
<div><h1 class="header-title">Skype analysis</h1>
                
            
            
                
<p>Skype is a voice/video calling app, as well as a messaging app owned by Microsoft. It has over 100,000,000 installs on Google Play.</p>
<p><strong>Package name</strong>: <kbd>com.skype.raider</kbd></p>
<p><strong>Files of interest</strong>:</p>
<ul>
<li><kbd>/cache/skype-4228/DbTemp</kbd></li>
<li><kbd>/sdcard/Android/data/com.skype.raider/cache/</kbd></li>
<li><kbd>/files/</kbd>
<ul>
<li><kbd>shared.xml</kbd></li>
<li><kbd>&lt;username&gt;/thumbnails/</kbd></li>
<li><kbd>&lt;username&gt;/main.db</kbd></li>
<li><kbd>&lt;username&gt;/chatsync</kbd></li>
</ul>
</li>
</ul>
<p>The <kbd>/cache/skype-4228/DbTemp</kbd> directory contained multiple files with no extension. One of these files (<kbd>temp-5cu4tRPdDuQ3ckPQG7wQRFgU</kbd> on our device) was actually a SQLite database that contained the SSID and MAC of wireless access points it had been connected to.</p>
<p>The SD card path will contain any images or files received in a chat. If a file is downloaded, it will be in the Downloads folder in the root of the SD.</p>
<p>The <kbd>shared.xml</kbd> file listed the account's username, as well as the last IP address that connected to Skype:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-754 image-border" src="img/545e70f4-bb0c-4979-8d4e-fe86fc76d4b3.png" style="width:38.83em;height:8.83em;" width="466" height="106"/></p>
<p>The <kbd>&lt;username&gt;/thumbnails</kbd> directory contained the user's profile picture.</p>
<p>The <kbd>main.db</kbd> database, like it sounds, contains all of the app usage history. Here are some important tables:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td>
<p><strong>Table</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>Accounts</kbd></p>
</td>
<td>
<p>Shows the accounts used on the device, and the associated email addresses.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>CallMembers</kbd></p>
</td>
<td>
<p>Call logs from the app. The duration table is the duration of the call, and <kbd>start_timestamp</kbd> is the start time in Linux epoch format; neither of these columns is populated if the call is not answered. <kbd>creation_timestamp</kbd> is the actual beginning of the call; it is populated as soon as the call is initiated within the app, so even unanswered calls are shown in this column. The <kbd>ip_address</kbd> column shows the IP address of the user for connected calls.  The type column indicates whether the call was outgoing or incoming (1 = incoming, 2 = outgoing). The <kbd>guid</kbd> column also shows the direction of the call, listing each participant from left to right, with the user on the left being the one who initiated the call. The <kbd>call_db_id</kbd> column can be correlated with the calls table to find further information about the call.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>Calls</kbd></p>
</td>
<td>
<p>Very similar to <kbd>CallMembers</kbd>, but with less information. It is worth noting that the <kbd>begin_timestamp</kbd> column in this table is identical to <kbd>creation_timestamp</kbd> in <kbd>CallMembers</kbd>. There is an <kbd>is_incoming</kbd> column to show the direction of the call: 0 indicates outgoing, 1 indicates incoming. Finally, it should be noted that the duration of some calls did NOT match the <kbd>CallMembers</kbd> table. One of the durations was a second longer than the other table indicated. It appears that the <kbd>CallMembers</kbd> table calculates duration based on <kbd>start_timestamp</kbd>, while the Calls table calculates duration based on <kbd>begin_timestamp</kbd>. The difference in duration is likely caused by the amount of time it took the user to accept the call.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>ChatMembers</kbd></p>
</td>
<td>
<p>Shows the users in each chat. The adder column lists the user that initiated the chat.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>Chats</kbd></p>
</td>
<td>
<p>Lists each unique chat session. The timestamp column is the date/time the conversation began, in Linux epoch format. The dialog_partner column shows users in the chat, excluding the account on the device. The posters table shows every user that has made a comment in the chat, and includes the account on the device if it has posted. The participants column is similar to the <kbd>dialog_partner</kbd> column, but includes the user's account. Finally, the <kbd>dbpath</kbd> column contains the name of the chat backup file found in the <kbd>&lt;username&gt;/chatsync</kbd> directory. This will become important further in this analysis.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>Contacts</kbd></p>
</td>
<td>
<p>This is actually a very misleading table. In our test, we added two users to our contact list; the contacts table has 233 entries! The <kbd>is_permanent</kbd> column indicates the status of the users listed in this table; if it is 1, the user is added as an actual contact within the application. The other 231 entries appear to be names that came up in results when we searched for contacts, but we never communicated with or added them.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>Conversations</kbd></p>
</td>
<td>
<p>We have no idea what the difference between Conversations and Chats is. They contain much of the same information, and in fact appear to be referencing the same chat sessions.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>Messages</kbd></p>
</td>
<td>
<p>Contains every individual message from chats/conversations. The <kbd>convo_id</kbd> column has a unique value for each conversation; any messages with the same <kbd>convo_id</kbd> value are from the same conversation. The author and <kbd>from_dispname</kbd> columns show who wrote each message. The timestamp column, once again, shows the date/time of the message in Linux epoch format. The type column indicates the type of message that was sent; here are the values from our testing:</p>
<ul>
<li><strong>50</strong>: Friend request</li>
<li><strong>51</strong>: Request accepted</li>
<li><strong>61</strong>: Plaintext message</li>
<li><strong>68</strong>: File transfer</li>
<li><strong>30</strong>: Call begin (voice or video)</li>
<li><strong>39</strong>: Call end (voice or video)</li>
<li><strong>70</strong>: Video message</li>
</ul>
<p>The <kbd>body_xml</kbd> column has the content of the message. For plaintext messages and friend requests, the content is simply what the message said. File transfers show the size and name of the file. Video messages say that they are a video message, but provide no other information. Calls show the duration if it was connected, and no duration if they were missed/ignored. The identities column shows who sent each message, but may be blank if it was sent by the user account on the device. The reason column appears to be for calls, and shows either <kbd>no_answer</kbd> or <kbd>busy</kbd> to explain why a call was not connected.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>Participants</kbd></p>
</td>
<td>
<p>Similar to <kbd>ChatMembers</kbd>, shows each user involved with a chat/conversation.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>SMSes</kbd></p>
</td>
<td>
<p>Our testing did not include SMS messaging; however, each column in this table is self-explanatory.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>Transfers</kbd></p>
</td>
<td>
<p>Shows information about files transferred. Includes the file name, size, and path on the device. The <kbd>partner_dispname</kbd> column identifies which user began the file transfer.</p>
<p> </p>
</td>
</tr>
<tr>
<td>
<p><kbd>VideoMessages</kbd></p>
</td>
<td>
<p>Shows the author and creation timestamp of video messages. Note that video messages are NOT stored on the device; accessing them will be covered in a separate section below.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>VoiceMails</kbd></p>
</td>
<td>
<p>Our testing did not include voicemails; however, each column in this table appears self-explanatory.</p>
</td>
</tr>
</tbody>
</table>


            

            
        
    </div>



  
<div><h1 class="header-title">Snapchat analysis</h1>
                
            
            
                
<p>Snapchat is an image-sharing and text-messaging service with over 100,000,000 downloads. Its signature feature is that images and videos sent will "self-destruct" after a time limit set by the sender, from 1-10 seconds. Furthermore, if a user takes a screenshot of the image, the sender is notified.Text chats do not have an expiration timer.</p>
<p><strong>Package name</strong>: <kbd>com.snapchat.android</kbd></p>
<p><strong>Files of interest</strong>:</p>
<ul>
<li><kbd>/cache/stories/received/thumbnail/</kbd></li>
<li><kbd>/sdcard/Android/data/com.snapchat.android/cache/my_media/</kbd></li>
<li><kbd>/shared_prefs/com.snapchat.android_preferences.xml</kbd></li>
<li><kbd>/databases/tcspahn.db</kbd></li>
</ul>
<p><kbd>/cache/stories/received/thumbnail</kbd> contains thumbnails of pictures taken by the user on the device. The <kbd>/sdcard</kbd> path contains the full-sized images. These remain even after the time limit has expired and the recipient can no longer access them. The files in both of these locations may not have proper file extensions.</p>
<p>The <kbd>com.snapchat.android_preferences.xml</kbd> file contains the email address used to create an account, and the phone number of the device registered with the account.</p>
<p>The <kbd>tcspahn.db</kbd> database contains all other information about the app's usage:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td>
<p><strong>Table</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>Chat</kbd></p>
</td>
<td>
<p>Lists all text chats. Shows the sender, recipient, timestamp in Linux epoch time, and the text of the message.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>ContactsOnSnapchat</kbd></p>
</td>
<td>
<p>Shows all users in the user's phonebook who also have Snapchat installed. The <kbd>isAddedAsFriend</kbd> column will show a 1 if the user has actually been added as a contact.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>Conversation</kbd></p>
</td>
<td>
<p>Has information about each open conversation. Includes the sender and recipient, and the timestamp of the last sent and received snaps in Linux epoch format.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>Friends</kbd></p>
</td>
<td>
<p>Similar to <kbd>ContactsOnSnapchat</kbd>, but only includes users who have been added as a friend. Includes the timestamp that each user added the other.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>ReceivedSnaps</kbd></p>
</td>
<td>
<p>Metadata about received images and videos. Once the image/video is viewed, it appears to be removed from this table at some point. Contains a timestamp for each message, a status, whether or not a snap was screenshot, and the sender.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>SentSnaps</kbd></p>
</td>
<td>
<p>Metadata about sent images and videos. Once the image/video is viewed, it appears to be removed from this table at some point. Contains a timestamp for each message, a status, and the recipient.</p>
</td>
</tr>
</tbody>
</table>


            

            
        
    </div>



  
<div><h1 class="header-title">Viber analysis</h1>
                
            
            
                
<p>Viber is a messaging and voice/video calling app with over 100,000,000 downloads.</p>
<p><strong>Package Name</strong>: <kbd>com.viber.voip</kbd></p>
<p><strong>Files of interest</strong>:</p>
<ul>
<li><kbd>/files/preferences/</kbd>
<ul>
<li><kbd>activated_sim_serial</kbd></li>
<li><kbd>display_name</kbd></li>
<li><kbd>reg_viber_phone_num</kbd></li>
</ul>
</li>
<li><kbd>/sdcard/viber/media/</kbd>
<ul>
<li><kbd>/User Photos/</kbd></li>
<li><kbd>/Viber Images/</kbd></li>
<li><kbd>/Viber Videos/</kbd></li>
</ul>
</li>
<li><kbd>/databases/</kbd>
<ul>
<li><kbd>viber_data</kbd></li>
<li><kbd>viber_messages</kbd></li>
</ul>
</li>
</ul>
<p>The files in <kbd>/files/preferences</kbd> contain the SIM card's ICCID, the name the user displays in the app, and the phone number used to register with the app.</p>
<p>The files in the <kbd>/sdcard/viber/media</kbd> path are the profile photos of people in the user's contact list who use Viber (regardless of whether they have been added as friends in the app), and all images and videos sent through the app.</p>
<p>The <kbd>viber_data</kbd> file is a database, even though it does not have the <kbd>.db</kbd> file extension. It contains information about the user's contacts:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td>
<p><strong>Table</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>calls</kbd></p>
</td>
<td>
<p>This table did not populate, even though we made calls from within the app.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>phonebookcontact</kbd></p>
</td>
<td>
<p>This table could be extremely valuable from a forensic standpoint. When Viber is first opened, it scrapes the user's phonebook and adds all the entries it finds to this database. This means it may contain historical data about the user's contacts; if they later delete an entry from the phonebook, it may still be recovered in this database. This table only includes names of contacts in the phonebook.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>phonebookdata</kbd></p>
</td>
<td>
<p>Similar to a phonebook contact, except it includes email addresses and phone numbers for contacts in the device's phone book.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>vibernumbers</kbd></p>
</td>
<td>
<p>Shows the Viber phone number for each contact in the device's phonebook that uses the app. The value in the <kbd>actual_photo</kbd> corresponds with the filenames in the <kbd>/sdcard/viber/media/User/ Photos</kbd> directory.</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>The <kbd>viber_messages</kbd> file is a database, even though it does not have the <kbd>.db</kbd> file extension. It contains information about the app's usage:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td>
<p><strong>Table</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>conversations</kbd></p>
</td>
<td>
<p>Contains a unique ID, the recipient, and date for each unique conversation.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>messages</kbd></p>
</td>
<td>
<p>Contains each individual message from all conversations. The address is the phone number of the remote party in the conversation. The date column is in Unix epoch format. The type column corresponds to incoming or outgoing: 1 is an outgoing message, 0 is incoming. The <kbd>location_lat</kbd> and <kbd>location_lng</kbd> columns will be populated if a location is shared. Shared files can be sent with text to describe them; this is found in the description column.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>messages_calls</kbd></p>
</td>
<td>
<p>This table did not populate, even though we made calls from within the app.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>participants_info</kbd></p>
</td>
<td>
<p>Has profile information for each account that has been in a conversation with the user.</p>
</td>
</tr>
</tbody>
</table>


            

            
        
    </div>



  
<div><h1 class="header-title">Tango analysis</h1>
                
            
            
                
<p>Tango is a voice/text/video messaging application. It has over 100,000,000 downloads in the Play Store.</p>
<p><strong>Package name</strong>: <kbd>com.sgiggle.production</kbd></p>
<div><p>This package name is seemingly innocuous, and could be overlooked by an examiner thinking it was a game. This is an example of why every application should be analyzed.</p>
</div>
<p><strong>Files of interest</strong>:</p>
<ul>
<li><kbd>/sdcard/Android/data/com.sgiggle.production/files/storage/appdata/</kbd>
<ul>
<li><kbd>TCStorageManagerMediaCache_v2/</kbd></li>
<li><kbd>conv_msg_tab_snapshots/</kbd></li>
</ul>
</li>
<li><kbd>/files/</kbd>
<ul>
<li><kbd>tc.db</kbd></li>
<li><kbd>userinfo.xml.db</kbd></li>
</ul>
</li>
</ul>
<p>The <kbd>/TCStorageManagerMediaCache_v2</kbd> path on the SD card contains images that were sent and received with the application, as well as profile pictures of contacts. However, it also contains many images that were never seen or used in the application; they appear to either be images for ads or stock emoji type images that can be attached to conversations. The filenames found here can be correlated with <kbd>tc.db</kbd> to find the exact image that was used in a conversation.</p>
<p>The <kbd>conv_msg_tab_snapshots</kbd> path on the SD card contains files with a <kbd>.dat</kbd> extension. When viewed in a hex editor, we were able to find snippets of conversations in plaintext, as well as paths and URLs to images sent and received in conversations. It is unclear what causes these files to exist, but it may be possible to retrieve content from these files that may have been deleted in <kbd>tc.db</kbd>.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The <kbd>tc.db</kbd> database is what Tango uses to store all message information:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td>
<p><strong>Table</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>conversations</kbd></p>
</td>
<td>
<p>Contains a unique ID in the <kbd>conv_id</kbd> column for each conversation.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>messages</kbd></p>
</td>
<td>
<p>Contains messages sent and received through the app. The <kbd>msg_id</kbd> column is a unique identifier for each message, and the <kbd>conv_id</kbd> column identifies which conversation the message is from. The <kbd>send_time</kbd> column identifies the time a message was sent, or when it was received, depending on the direction. The direction column shows the direction of the message: 1 = sent and 2 = received. The type column identifies the type of the message; based on our testing, they are as follows:</p>
<ul>
<li><strong>0</strong>: Plaintext message</li>
<li><strong>1</strong>: Video message</li>
<li><strong>2</strong>: Audio message</li>
<li><strong>3</strong>: Image</li>
<li><strong>4</strong>: Location/coordinates</li>
<li><strong>35</strong>: Voice call</li>
<li><strong>36</strong>: Attempted voice call (missed by either party)</li>
<li><strong>58</strong>: Attached stock image, such as the emojis found in the <kbd>TCStorageManagerMediaCache_v2</kbd> path</li>
</ul>
<p>Finally, the payload column contains the content of the message… sort of. The data is Base64-encoded, which will be discussed in detail below.</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>The <kbd>user_info_xml.db</kbd> contains metadata about the account, such as the user's name and phone number. However, its data is entirely Base64-encoded, like the messages in <kbd>tc.db</kbd>.</p>
<div><p>Data storage method 6: Base64</p>
</div>


            

            
        
    </div>



  
<div><h1 class="header-title">Decoding Tango messages</h1>
                
            
            
                
<p>Base64 is an encoding scheme that is commonly used for data transport; it is not considered encryption because it has a known method for decoding, and does not require a unique key to decode the data. Base64 contains ASCII-printable characters, but the underlying data is binary (which will make our output somewhat messy!). An example from the payload column in the messages table of tc.db looks like this:</p>
<pre><strong>EhZtQzVtUFVQWmgxWnNRUDJ6aE44cy1nGAAiQldlbGNvbWUgdG8gVGFuZ28hIEhlcmUncyBob3cgdG8gY29ubmVjdCwgZ2V0IHNvY2lhbCwgYW5kIGhhdmUgZnVuIYABAKoBOwoFVGFuZ28SABoWbUM1bVBVUFpoMVpzUVAyemhOOHMtZyILCgcKABIBMRoAEgAqADD///////////8BsAHYioX1rym4AYKAgAjAAQHQAQDoAdC40ELIAgTQAgDqAgc4MDgwODg5yAMA2AMA2AXTHw==</strong></pre>
<div><p>Note the equal signs on the end of our message; this is a strong indicator that data is Base64-encoded. The input that will be encoded needs to be divisible by 3 for the math behind Base64 to work properly. If the input is not divisible by 3, it will be padded, resulting in the equal signs seen in the output.</p>
</div>
<p>For example, consider the following table:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td>
<p><strong>Input string</strong></p>
</td>
<td>
<p><strong>Number of characters/bytes</strong></p>
</td>
<td>
<p><strong>Output</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>Hello, World</kbd></p>
</td>
<td>
<p><kbd>12</kbd></p>
</td>
<td>
<p><kbd>SGVsbG8sIFdvcmxk</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>Hello, World!</kbd></p>
</td>
<td>
<p><kbd>13</kbd></p>
</td>
<td>
<p><kbd>SGVsbG8sIFdvcmxkIQ==</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>Hello, World!!</kbd></p>
</td>
<td>
<p><kbd>14</kbd></p>
</td>
<td>
<p><kbd>SGVsbG8sIFdvcmxkISE=</kbd></p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>You can see that the 12-byte input (divisible by 3) has no padding, while the other two input do have padding because they are not divisible by 3. This is important because it shows that while the equal signs are a strong indicator of Base64, the lack of an equal sign does not mean it isn't Base64!</p>
<p>Now that we understand a little about Base64, and recognize that our payload column is very likely encoded in Base64, we need to decode it. There are websites that will allow the user to paste in encoded data, and it will be decrypted (such as <a href="http://www.base64decode.org">www.base64decode.org</a>), but this is inconvenient for large amounts of data as each message must be input individually (and putting evidentiary data on the internet is also frowned upon in most cases). Likewise, it can be decoded on the command line of Linux-based systems, but is equally inconvenient for large amounts of data. Our solution was to build a Python script that pulls the Base64 data from the database, decodes it, and writes it back out to a new file:</p>
<pre class="mce-root">import sqlite3<br/>import base64<br/>conn = sqlite3.connect('tc.db')<br/>c = conn.cursor()<br/>c.execute('SELECT msg_id, payload FROM messages')<br/>message_tuples = c.fetchall()<br/>with open('tcdb_out.txt', 'w') as f:<br/>   for message_id, message in message_tuples:<br/>         f.write(str(message_id) + '\x09')<br/>         f.write(str(base64.b64decode(message)) + '\r\n')</pre>
<p>To run the code, simply paste this code into a new file, named <kbd>tcdb.py</kbd>, place the script in the same directory as <kbd>tc.db</kbd>, and on the command line navigate to that directory and run the following:</p>
<pre><strong>python tcdb.py</strong></pre>
<p>The script will make a file named <kbd>tcdb_out.txt</kbd> in the same directory. Opening the file in a text editor (or importing it into Excel as a tab-delimited file) will show the <kbd>msg_id</kbd> value so that the examiner can correlate the message back to the messages table, and the decoded payload shows a plaintext message (noted as type 0 in the database):</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-758 image-border" src="img/6e2ee03c-aed9-43cf-9e53-1dc65c120b30.png" style="width:66.42em;height:7.58em;" width="797" height="91"/></p>
<div><p>Note that the message content is now visible in plaintext, and is preceded by the conversation ID. There is also a ton of binary data cluttering up our output; this is likely metadata or other information used by Tango. If the message was received, the user's name will also be in the output (here it is Tango).</p>
</div>
<p>There are other messages types worth looking at. Here is a decoded payload entry for a video message:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-759 image-border" src="img/7de46304-7f2f-4f6f-ab43-f16845e24548.png" style="width:73.75em;height:13.42em;" width="885" height="161"/></p>
<p>Note that with the video message, we can see two URLs. They are both public, meaning anyone with the link can access them. The URL ending in thumbnail is a thumbnail of the video, while the other URL will download the complete video in MP4 format. The path to the SD card and filename for the image is also shown.</p>
<p>Image and audio messages are stored in a very similar format, and contain URLs to either view or download the file, as well as the path to the file on the SD card.</p>
<p>Here is a sample location message:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-760 image-border" src="img/591003d2-6f67-436a-afbb-9c6885fc5ee0.png" style="width:73.00em;height:10.50em;" width="876" height="126"/></p>
<p>This time, we can see the exact coordinates the user was at, as well as the address. Again, a path on the SD card is also present, and will show the map view of the location. As with the other message types, a received message would also show the sender's name.</p>
<p>Finally, let's take a look at the <kbd>userinfo.xml.db</kbd> database. Here is what it looks like before being decoded properly:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-761 image-border" src="img/7c5925fe-2196-4cbb-9242-5f64f7a9c9a7.png" style="width:32.92em;height:35.58em;" width="451" height="488"/></p>
<p>We wrote another script very similar to the first to parse the <kbd>userinfo.xml.db</kbd> database:</p>
<pre>import sqlite3<br/>import base64<br/>conn = sqlite3.connect('userinfo.xml.db')<br/>c = conn.cursor()<br/>c.execute('SELECT key, value FROM profiles')<br/>key_tuples = c.fetchall()<br/>with open('userinfo_out.txt', 'w') as f:<br/>   for key, value in key_tuples:<br/>         if value == None:<br/>               value = 'Tm9uZQ=='<br/>         f.write(str(base64.b64decode(key)) + '\x09')<br/>         f.write(str(base64.b64decode(value)) + '\r\n')</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The only difference in the code is that the filenames, table names, and values changed, and this time both of the columns in the database are base64-encoded. Again, it can be run by placing it in the same location as <kbd>userinfo.xml.db</kbd> and running it with the following:</p>
<pre>python userinfo.py</pre>
<p>Here is the relevant portion of the resulting output file, showing the personal data the user used to register the account:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-762 image-border" src="img/1303398c-f8bf-43d8-bbbb-86fc1b6df47c.png" style="width:41.08em;height:14.92em;" width="586" height="213"/></p>
<p>Further down in the output, there is also a list of all of the user's contacts who use Tango, and it includes the contacts' names and phone numbers.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">WhatsApp analysis</h1>
                
            
            
                
<p>WhatsApp is a popular chat/video messaging service with over 500,000,000 downloads in Google Play.</p>
<p><strong>Package name</strong>: <kbd>com.whatsapp</kbd></p>
<p><strong>Files of interest</strong>:</p>
<ul>
<li><kbd>/files/</kbd>
<ul>
<li><kbd>Avatars/</kbd></li>
<li><kbd>me</kbd></li>
<li><kbd>me.jpeg</kbd></li>
</ul>
</li>
<li><kbd>/shared_prefs/</kbd>
<ul>
<li><kbd>RegisterPhone.xml</kbd></li>
<li><kbd><kbd>VerifySMS.xml</kbd></kbd></li>
</ul>
</li>
<li><kbd>/databases/</kbd>
<ul>
<li><kbd>msgstore.db</kbd></li>
<li><kbd>wa.db</kbd></li>
</ul>
</li>
<li><kbd>/sdcard/WhatsApp/</kbd>
<ul>
<li><kbd>Media/</kbd></li>
<li><kbd>Databases/</kbd></li>
</ul>
</li>
</ul>
<p>The <kbd>/files/avatars</kbd> directory contains thumbnails of the profile pictures of contacts that use the app, and <kbd>me.jpg</kbd> is a full-size version of the user's profile picture. The me file contains the phone number associated with the account.</p>
<p>The phone number associated with the account can also be recovered in <kbd>/shared_prefs/RegisterPhone.xml</kbd>. The <kbd>/shared_prefs/VerifySMS.xml</kbd> file shows the time that the account was verified (in Unix epoch format, of course), indicating when the user first began using the app.</p>
<p>The <kbd>msgstore.db</kbd> database, like it sounds, contains messaging data:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td>
<p><strong>Table</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>chat_list</kbd></p>
</td>
<td>
<p>The <kbd>key_remote_jid</kbd> column shows each account the user has communicated with; the value in the table is the remote user's phone number. For example, if the value is <kbd>13218675309@s.whatsapp.net</kbd>, the remote user's number is <kbd>1-321-867-5309</kbd>.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>group_participants</kbd></p>
</td>
<td>
<p>Contains metadata about group chats.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>messages</kbd></p>
</td>
<td>
<p>Shows all message data. Once again, the <kbd>key_remote_jid</kbd> field identifies the remote sender. The <kbd>key_from_me</kbd> value indicates the direction of the message (0=received, 1=sent). The data column contains the text of messages, and timestamp is the sent or received time in Linux epoch format.</p>
<p>For attachments, <kbd>media_mime_type</kbd> identifies the file format; the <kbd>media_size</kbd> and <kbd>media_name</kbd> columns should be self-explanatory. If the attachment had a caption, the text would be shown in the <kbd>media_caption</kbd> column. If the attachment was a location, the latitude and longitude columns will be populated appropriately. The <kbd>thumb_image</kbd> column has a lot of useless data in it, but also contains the path of the attachment on the device. The <kbd>raw_data</kbd> column contains thumbnails for images and videos.</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>The <kbd>wa.db</kbd> database is used to store contact information:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td>
<p><strong>Table</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>wa_contacts</kbd></p>
</td>
<td>
<p>Like other apps, WhatsApp scrapes and stores the user's entire phonebook, and stores the information in its own database. It contains the contact's name and phone number, as well as a status if that contact is a WhatsApp user.</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>The SD card is a treasure trove of WhatsApp data. The <kbd>/sdcard/WhatsApp/Media</kbd> folder contains a folder for each type of media (Audio, Calls, Images, Video, and Voice Notes), and stores all attachments of that type in the folder. Sent media is stored in a directory called, unimaginatively, Sent. Received media is simply stored in the root of the folder.</p>
<p>The Databases directory is an even greater source of information. WhatsApp makes a backup of <kbd>msgstore.db</kbd> nightly, and stores the backups here. This allows an examiner to see historical data that may have been deleted; if I delete a chat today, but you look at a backup from yesterday, you'll be able to access the data I deleted. The app is even kind enough to put the date in the filename, for example: <kbd>msgstore-2018-12-12.1.db.crypt12</kbd>. The only catch is that these backups are encrypted!</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Decrypting WhatsApp backups</h1>
                
            
            
                
<p>Luckily, there is a tool available to decrypt the backups. It can be found here, along with detailed instructions: <a href="https://andreas-mausch.de/whatsapp-viewer/">https://andreas-mausch.de/whatsapp-viewer/</a>. WhatsApp Viewer can be used to decrypt different versions of encrypted WhatsApp databases. In this example, we are going to decrypt its latest version, <kbd>.crypt12</kbd>:</p>
<ol>
<li>Go to File | Decrypt .crypt12….</li>
<li>Choose encrypted database file and key file (can be found in the <kbd>/files</kbd> directory):</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-763 image-border" src="img/618d37b8-0d88-4452-b46a-bedc01ea32e1.png" style="width:40.50em;height:20.08em;" width="486" height="241"/></p>
<ol start="3">
<li>Click the Decrypt… button and choose the location of the decrypted database file.</li>
</ol>
<div><p>Data storage method 7: Encrypted files</p>
</div>


            

            
        
    </div>



  
<div><h1 class="header-title">Kik analysis</h1>
                
            
            
                
<p>Kik is a messaging app with over 100,000,000 downloads from the Play Store.</p>
<p><strong>Package name</strong>: <kbd>kik.android</kbd></p>
<p><strong>Files of interest</strong>:</p>
<ul>
<li><kbd>/cache/</kbd>
<ul>
<li><kbd>chatPicsBig/</kbd></li>
<li><kbd>contentpics/</kbd></li>
<li><kbd>profPics/</kbd></li>
</ul>
</li>
<li><kbd>/files/staging/thumbs</kbd></li>
<li><kbd>/shared_prefs/KikPreferences.xml</kbd></li>
<li><kbd>/sdcard/Kik/</kbd></li>
<li><kbd>/databases/kikDatabase.db</kbd></li>
</ul>
<p>The <kbd>chatPicsBig</kbd> and <kbd>contentpics</kbd> directories in <kbd>/cache</kbd> contain images that were sent and received within the application. The files in <kbd>contentpics</kbd> contain what appears to be <kbd>Kik</kbd> metadata embedded before the image; the JPG has to be carved out of these files. In our testing, all of the files in <kbd>contentpics</kbd> were also stored in <kbd>chatPicsBig</kbd>, though this may change with more extensive app usage. The user's profile picture is found in /the <kbd>/profPics</kbd> directory.</p>
<div><p>Data storage method 8: Basic steganography; a file is stored within a larger file.</p>
</div>
<p>The <kbd>/files/staging/thumbs</kbd> directory contains thumbnails of images sent and received with the application; our testing found the same images in this location as the <kbd>/cache</kbd> directories, but again it is possible this would vary with more extensive application usage.</p>
<p>The <kbd>KikPreferences.xml</kbd> file in <kbd>/shared_prefs</kbd> shows the user's username and email address used with the application. Interestingly, it also contains an unsalted SHA1 hash of the user's password.</p>
<p>The <kbd>/sdcard/Kik</kbd> directory contains full-sized images that were sent and received in the application. The filenames can be correlated with <kbd>kikDatabase.db messagesTable</kbd> to identify which message contained the image.</p>
<p>The <kbd>kikDatabase.db</kbd> database contains all of the messaging data from the application:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td>
<p><strong>Table</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>KIKContentTable</kbd></p>
</td>
<td>
<p>This table contains metadata about sent and received images. Each message is assigned a unique <kbd>content_id</kbd> value that corresponds to the filenames in the <kbd>sdcard/Kik</kbd> directory. The preview and icon values for each image correspond to the filenames found at <kbd>/files/staging/thumbs</kbd>. Each image also contains a <kbd>file-url</kbd> value; this is a public URL that can be accessed to view the file.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>KIKcontactsTable</kbd></p>
</td>
<td>
<p>This table shows <kbd>user_name</kbd> and <kbd>display_name</kbd> for each contact. The <kbd>in_roster</kbd> value appears to be set for contacts the user has specifically added (if it is set to <kbd>1</kbd>); contacts with an <kbd>in_roster</kbd> value of 0 appear to be added automatically. The <kbd>jid</kbd> column is a unique value for each contact.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>messagesTable</kbd></p>
</td>
<td>
<p>This table contains all data for messages sent and received with the app. The body column shows the text data sent in a message. The <kbd>partner_jid</kbd> value can be correlated back to the <kbd>jid</kbd> column in <kbd>KIKcontactTable</kbd> to identify the remote user. The <kbd>was_me</kbd> column is used to indicate the direction of the message (<kbd>0</kbd> = sent, <kbd>1</kbd> = received). The <kbd>read_state</kbd> column shows whether the message has been read (<kbd>500</kbd> = read and <kbd>400</kbd> = unread). The timestamp, yet again, is in Linux epoch format. The <kbd>content_id</kbd> column is populated with message attachments, and can be correlated to <kbd>KIKContentTable</kbd> for more information.</p>
</td>
</tr>
</tbody>
</table>


            

            
        
    </div>



  
<div><h1 class="header-title">WeChat analysis</h1>
                
            
            
                
<p>WeChat is a messaging app with over 100,000,000 downloads in the Play Store.</p>
<p><strong>Package name</strong>: <kbd>com.tencent.mm</kbd></p>
<div><p>Note that some of these paths contain an asterisk (*). This is used to indicate a unique string that will differ for each account. Our device had <kbd>7f804fdbf79ba9e34e5359fc5df7f1eb</kbd> in place of the asterisk.</p>
</div>
<p><strong>Files of interest</strong>:</p>
<ul>
<li><kbd>/files/host/*.getdns2</kbd></li>
<li><kbd>/shared_prefs/</kbd>
<ul>
<li><kbd>com.tencent.mm_preferences.xml</kbd></li>
<li><kbd>system_config_prefs.xml</kbd></li>
</ul>
</li>
<li><kbd>/sdcard/tencent/MicroMsg/</kbd>
<ul>
<li><kbd>diskcache/</kbd></li>
<li><kbd>WeChat/</kbd></li>
</ul>
</li>
<li><kbd>/sdcard/tencent/MicroMsg/*/</kbd>
<ul>
<li><kbd>image2/</kbd></li>
<li><kbd>video/</kbd></li>
<li><kbd>voice2/</kbd></li>
</ul>
</li>
<li><kbd>/MicroMsg/</kbd>
<ul>
<li><kbd>CompatibleInfo.cfg</kbd></li>
<li><kbd>*/EnMicroMsg.db</kbd></li>
</ul>
</li>
</ul>
<p>The <kbd>*.getdns2</kbd> files found in <kbd>/files/host</kbd> can be opened as text files or in a hex editor. There is a section called <kbd>[clientip]</kbd> that shows the IP address from which the user connected, as well as the time of the connection in Linux epoch format. Our device contained three of these files to show three different connections, though increased application usage may generate more than three of these files.</p>
<p>The <kbd>com.tencent.mm_preferences.xml</kbd> file in <kbd>/shared_prefs</kbd> records the device's phone number in the <kbd>login_user_name</kbd> field. The <kbd>system_config_prefs.xml</kbd> file contains the path to the user's profile picture on the device, as well as a <kbd>default_uin</kbd> value that will be needed later.</p>
<p>The SD card contains a wealth of WeChat data. The <kbd>/tencent/MicroMsg/diskcache</kbd> directory contained an image that was never used with the application; we think it was put there when attaching a different image, as WeChat loads a view of many images from the device's gallery. The <kbd>/WeChat</kbd> directory within <kbd>/sdcard/tencent/MicroMsg</kbd> contained images sent from the device.</p>
<p>The <kbd>/video</kbd>, <kbd>/voice</kbd>, and <kbd>/voice2</kbd> folders within <kbd>/sdcard/tencent/MicroMsg/*</kbd> contain exactly what they say: video and voice files sent using the app.</p>
<p>WeChat is fairly unique in that it does not utilize a <kbd>/databases</kbd> directory within the app's directory structure; <kbd>MicroMsg</kbd> is its equivalent. <kbd>CompatibleInfo.cfg</kbd> contains the device's IMEI, which will be useful later.</p>
<p>The <kbd>*</kbd> directory within <kbd>/MicroMsg</kbd> contains the <kbd>EnMicroMsg.db</kbd> database. There's only one problem: the database is encrypted using SQLCipher! SQLCipher is an open source extension for SQLite that encrypts the entire database. Luckily, like other apps that use encryption, the key to decrypting the file is on the device.</p>
<div><p>Data storage method 9: SQLCipher, full database encryption</p>
</div>


            

            
        
    </div>



  
<div><h1 class="header-title">Decrypting the WeChat EnMicroMsg.db</h1>
                
            
            
                
<p>Fortunately for us, Forensic Focus has an excellent article on doing exactly this: <a href="http://articles.forensicfocus.com/2014/10/01/decrypt-wechat-enmicromsgdb-database/">http://articles.forensicfocus.com/2014/10/01/decrypt-wechat-enmicromsgdb-database/</a>.</p>
<p>They even provide a Python script to do the work for us: <a href="https://gist.github.com/fauzimd/8cb0ca85ecaa923df828/download#">https://gist.github.com/fauzimd/8cb0ca85ecaa923df828/download#</a>.</p>
<p class="mce-root"/>
<p>To run the Python script, simply put the <kbd>EnMicroMsg.db</kbd> file and the <kbd>system_config_prefs.xml</kbd> files in the same directory as the script and, in the command line, type the following:</p>
<pre><strong>python fmd_wechatdecipher.py</strong></pre>
<p>The script will then prompt you for the IMEI of the device. This can be found in the <kbd>/MicroMsg/CompatibleInfo.cfg</kbd> file, printed somewhere on the device (behind the battery, on the SIM card tray, or etched onto the back of the device are common locations), or typing <kbd>*#06#</kbd> in the keypad.</p>
<p>The script should run, and place a file called <kbd>EnMicroMsg-decrypted.db</kbd> in the directory.</p>
<p>We can now examine <kbd>EnMicroMsg-decrypted.db</kbd>:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td>
<p><strong>Table</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>ImgInfo2</kbd></p>
</td>
<td>
<p>Contains path information for sent and received images. The <kbd>bigImgPath</kbd> column contains the filename for the image; this can be searched on the SD card to find the picture. Alternatively, images are stored in the <kbd>/sdcard/tencent/MicroMsg/*/image2</kbd> directory in folders that correspond to the filename. For example, the <kbd>3b9edb119e04869ecd7d1b21a10aa59f.jpg</kbd> file can be found in the <kbd>image2</kbd> directory in the <kbd>/3b/9e</kbd> path. The folders are broken down by the first two bytes of the name, then the second two bytes of the name. <kbd>thumbImgPath</kbd> contains the name of thumbnails for the images.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>message</kbd></p>
</td>
<td>
<p>Contains all message information for the app. The <kbd>isSend</kbd> column indicates the message direction (<kbd>0</kbd> = received, <kbd>1</kbd> = sent). The <kbd>createTime</kbd> table is the timestamp of the message, in Linux epoch format. The talker column contains a unique ID for the remote user, this can be correlated with the <kbd>rcontact</kbd> table to identify the remote user. The content column shows the data of messages sent as text, and identifies video calls as <kbd>voip_content_voice</kbd>. <kbd>imgPath</kbd> contains the path to image thumbnails, which can be correlated with the <kbd>ImgInfo2</kbd> table to locate the full-sized images. It also includes file names for audio files, which can be searched for or located in the <kbd>/sdcard/tencent/MicroMsg/*/voice2</kbd> directory.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>rcontact</kbd></p>
</td>
<td>
<p>Contains a list of contacts, and includes many that are added by default by the app. The username can be correlated with the talker column in the message table. The nickname column shows the user's name. The type column is an indicator of whether the contact was added manually or automatically (<kbd>1</kbd> = device user, <kbd>3</kbd> = added by user, <kbd>33</kbd> = added by app). The exception to this is the <kbd>weixin</kbd> user, which is automatically added, but has a type value of 3.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>userinfo</kbd></p>
</td>
<td>
<p>This table contains info about the user, including name and phone number.</p>
</td>
</tr>
</tbody>
</table>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    </div>



  
<div><h1 class="header-title">Summary</h1>
                
            
            
                
<p>This chapter has been an in-depth study of specific Android applications, and how/where they store their data. We looked at 19 specific applications, and discovered 9 different methods of storing and obfuscating data. Knowing that applications store their data in a variety of ways should help an examiner have a better understanding of the data that they are examining, and hopefully push them to look harder when they can't find data they expect an app to have. An examiner has to be able to adapt to the changing world of application analysis; since applications constantly update, an examiner has to be able to update their own methods and abilities in order to keep up.</p>
<p>The next chapter will take a look at several free/open source and commercial tools to image and analyze Android devices.</p>


            

            
        
    </div>



  </body></html>