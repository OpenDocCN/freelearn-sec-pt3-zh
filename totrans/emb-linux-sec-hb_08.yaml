- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Boot, BIOS, and Firmware Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have covered TPM and LUKS disk encryption to protect the data. This
    chapter will push you to reflect deeper into the basest of hardware functions
    and your boot system itself. I’m going to warn you upfront. The settings we will
    review here are truly a double-edged sword, and by that, I mean simply that they
    can protect the system but also, they can make supporting the same system at a
    customer site painfully difficult.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding how to best lock down and protect your BIOS (short for Basic Input
    Output System), its firmware, and your operating systems’ ability to boot securely
    will ensure that your customers are rewarded with a more resilient product and
    your team has reduced your company’s exposure to risks.
  prefs: []
  type: TYPE_NORMAL
- en: Locking down your BIOS and boot options, albeit a great idea, does have support
    implications that I feel compelled to highlight. We’ll cover some of these in
    greater detail.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Deep dive into various booting system components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding boot-level security using examples
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Possible threats in firmware
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deep dive into various booting system components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ever wonder what happens when you turn on a Linux system? Let’s take a quick
    look at what really goes on.
  prefs: []
  type: TYPE_NORMAL
- en: First, we’ll dive into your system’s BIOS. Virtually all modern x86_64 platforms
    leverage a Unified Extensible Firmware Interface (UEFI) BIOS, which is basically
    a firmware interface that serves as a gateway from your operating system to the
    hardware it controls. Older platforms have vendor-specific or legacy BIOS types
    that follow limited standards from one system to another. For ease of understanding
    the differences between legacy BIOS and the new standard UEFI BIOS, I’ve created
    a table here to contrast their features or functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Concern** | **Legacy BIOS** | **UEFI BIOS** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Standardization | Each vendor has its own feature/functionality | Industry-standard
    functionality regardless of vendor |'
  prefs: []
  type: TYPE_TB
- en: '| Digital signatures | None | Secure Boot |'
  prefs: []
  type: TYPE_TB
- en: '| Partition table support | MBR partition table only | GUID partition table
    support added |'
  prefs: []
  type: TYPE_TB
- en: '| Platform | Limited | x86, X86_64, ARM, ARM64, PowerPC, and others |'
  prefs: []
  type: TYPE_TB
- en: '| Modularity | None | Modular – vendors can add additional support (i.e., networking,
    storage, etc.) |'
  prefs: []
  type: TYPE_TB
- en: Table 8.1 – Contrast of the two BIOS types
  prefs: []
  type: TYPE_NORMAL
- en: It all starts with the pushing of the Power On button. A modern marvel of chain
    reactions begins. The system’s firmware BIOS/UEFI kicks into action. It initiates
    a POST (short for Power-On Self-Test). Once it’s completed checking itself, it
    searches for and initiates a Master Boot Record (MBR).
  prefs: []
  type: TYPE_NORMAL
- en: The MBR kicks off the bootloader, which, in our example, is GRUB2\. GRUB2 then
    loads the defined kernel executable. The Initramfs then kicks into gear and takes
    care of tasks such as decryption, software RAID, and filesystem loaders.
  prefs: []
  type: TYPE_NORMAL
- en: Once all of that orchestration has concluded and the root filesystem is loaded,
    systemd gets started. Systemd loads all the other filesystems and starts up all
    enabled network functions and application services. And there you have it… a functional
    Linux system.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1 – Booting up](img/B22104_08_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.1 – Booting up
  prefs: []
  type: TYPE_NORMAL
- en: None of this goodness happens without your firmware UEFI BIOS. Locking down
    what can be accessed and how boot devices can be used is crucial. Without such
    precautions, it will be impossible to protect the system from massive changes
    like having an alternative boot source becoming available, which would enable
    anyone with direct access to the hardware not only to boot from a non-approved
    device but possibly introduce malicious code into your system or, even worse,
    erase your entire system’s drives.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s move on to some security examples in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding boot-level security using examples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we’ll look at how to access the UEFI configuration and then
    we’ll walk through some of the key security settings that you need to be aware
    of. We’ll also review some of the pros and cons of such configurations.
  prefs: []
  type: TYPE_NORMAL
- en: Depending upon the distribution (and version of said distribution) of Linux
    you choose to deploy, the tooling available to you and the complexities around
    using such are as varied as the weather. Again, I will reiterate that choosing
    an enterprise-supported version of Linux will ultimately provide a better outcome.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, the newer your hardware platform is, the more likely you are to
    have the latest security enhancements in your firmware, CPU, and, of course, your
    BIOS. Let’s now move on to how one can access those security settings.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing the UEFI configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let me begin by addressing the key step in securing the UEFI configuration.
    This requires that you have physical access to the machine’s console.
  prefs: []
  type: TYPE_NORMAL
- en: How does one access the UEFI BIOS interface on their machine? There are a few
    paths that all lead to the same destination.
  prefs: []
  type: TYPE_NORMAL
- en: First, one can interrupt the boot sequence; usually, this is done by pressing
    a function key before GRUB kicks in on its part of the boot process. The specific
    key to be pressed is often different between vendors and models of systems. This
    step is a true interruption of the POST process and is the easiest way of getting
    to the BIOS, in my opinion.
  prefs: []
  type: TYPE_NORMAL
- en: Second, one can use GRUB2’s menu. Often, there is an entry that can allow you
    to enter the UEFI configuration, but this may not be present on all systems or
    distributions. Some platforms may also make editing UEFI firmware settings a manual
    transaction separate from the bootloader.
  prefs: []
  type: TYPE_NORMAL
- en: 'Third, from within the OS… Well, not exactly. The OS can be rebooted into the
    firmware setup without prompting you. Here’s a quick but exact example of how
    to tell your system to directly reboot and enter the UEFI configuration utility.
    Like all administrative functions, this one must be run as root:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The above command has no output, per se, but will immediately reboot into the
    UEFI configuration screen.
  prefs: []
  type: TYPE_NORMAL
- en: Well, since we’re talking about boot processes, let’s mention the password that
    can be present (or set) here. The UEFI admin password setting, in my professional
    opinion, is a double-edged sword. For the exact same reasons, I feel the same
    way about also setting a bootloader (i.e., GRUB2) password. This is quite similar
    in effect to the issues I have highlighted in leveraging things like LUKS without
    TPM automation, as mentioned in *Chapters 6* and *7*.
  prefs: []
  type: TYPE_NORMAL
- en: Assume you elect to set a password for either of these settings. Let’s review
    the implications for your end-users. Granted, for the UEFI admin password, it’s
    a 1-in-100,000 odds situation where the end-user would have a legitimate excuse
    for accessing it. It may never be an issue. Sadly, this is not the case in setting
    a bootloader (i.e., GRUB2) password. Every boot/reboot would force the user to
    manually enter the password on the console for the appliance to boot. For appliances
    with no keyboard perpetually attached, this is impossible besides impractical.
    For appliances with a keyboard, the result of this is that a lazy end-user tapes
    a note with the password to boot the system directly on it, and that eliminates
    any benefit of having the password to begin with.
  prefs: []
  type: TYPE_NORMAL
- en: So, you might be asking yourself why this is an issue. My response is human
    nature and bad behaviors. It’s generally safe to assume that all people most often
    will take the path of least resistance. This will obviously be the case in something
    that is required at every boot cycle. The end-customer would absolutely require
    access to this password.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of the UEFI admin password, let’s assume that it’s a support issue
    that forces your company to give that information to a customer. In both cases,
    the security such passwords are implied to carry is devalued by an end-user not
    only having them, but the probability that they will be shared outside your customers’
    organizations is the greatest threat to be mentioned.
  prefs: []
  type: TYPE_NORMAL
- en: I urge caution in leveraging either unless each individual appliance has unique
    passwords assigned and your support team has a database of them. Even then, once
    shared with the end-customer, they are to be considered compromised, negating
    the protections they were designed to provide.
  prefs: []
  type: TYPE_NORMAL
- en: What is Secure Boot?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Long answer short, **Secure Boot** is an excellent way of establishing with
    your users that your operating system is running on a kernel and binaries that
    your company personally has tested and signed with a key.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are some key variables at play, as shown in *Table 8.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Credential/Variable** | **Purpose** | **Creating Entity** |'
  prefs: []
  type: TYPE_TB
- en: '| Platform Key (PK) | Root Key | Platform Manufacturer |'
  prefs: []
  type: TYPE_TB
- en: '| Key Exchange Key (KEK) | List of certificate owners | OS Partner or OEM |'
  prefs: []
  type: TYPE_TB
- en: '| Authorized Database (db) | List of allowed driver or app | OS Partner or
    CA |'
  prefs: []
  type: TYPE_TB
- en: '| Exclusion Database (dbx) | List of revoked signers | Signing Authority |'
  prefs: []
  type: TYPE_TB
- en: '| SetupMode | 1 = Setup Mode, 0 = Secure Boot Enabled |  |'
  prefs: []
  type: TYPE_TB
- en: '| SecureBoot | 1 = Secure Boot is enforced, 0 = Secure Boot is disabled |  |'
  prefs: []
  type: TYPE_TB
- en: Table 8.2 – Key variables and their roles in Secure Boot
  prefs: []
  type: TYPE_NORMAL
- en: Before we start getting our hands dirty with exercises, let’s look at the differences
    in the boot process without and then with Secure Boot enabled. Here’s a graphical
    representation of the boot process without Secure Boot in place.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2 – Non-secure boot chain](img/B22104_08_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.2 – Non-secure boot chain
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from the preceding graphic, anything could be loaded without
    any checks or balances. Generally, that’s a bad idea when building a product.
    So let’s work toward guaranteeing to our customer base that what they are running
    is verified, true, and secure. Here’s a graphic that describes the Secure Boot
    process.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.3 – Leveraging Secure Boot and keys](img/B22104_08_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.3 – Leveraging Secure Boot and keys
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Secure Boot in Linux just got harder for most people trying to leverage
    their own keys. As of the writing of this book, the primary tool for achieving
    this functionality was a package called **efitools**. This extensive toolbox provided
    for the backup and recovery of keys, directly setting keys in the UEFI firmware,
    and much more. Sadly, as happens in open source from time to time, a critical
    tool is abandoned without its replacement being ready for primetime.
  prefs: []
  type: TYPE_NORMAL
- en: The planned replacement, from what best information I have seen, is a new tool
    called **sbctl**. There is limited information regarding this tool as of now.
    I am hopeful that it may find its way into Fedora 42 and other distributions very
    soon. Here’s a link to the project’s GitHub – [https://github.com/Foxboron/sbctl](https://github.com/Foxboron/sbctl)
    – where you will find some interesting information on this exciting project.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, this does create a temporary quandary for those of us wanting to use our
    own keys for Secure Boot in our appliances. There are a few options. This is where
    you must make your own judgement call until the new tooling gets itself into the
    mainstream Linux distributions. It’s difficult for me to advise in any direction
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Option 1**: You could rely solely on your Linux distribution’s keys themselves
    for the enablement of Secure Boot. This may or may not work depending on whether
    or not your solution requires custom kernel modules, which may or may not contain
    the correct signatures or even one at all.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Option 2**: Forgo the usage of Secure Boot temporarily until you can run
    it on your own terms and with your own keys in the driver’s seat. There’s no timeline
    for when you may be able to veer away from this course yet unless you consider
    exploring one of the other options. As a close friend pointed out to me, this
    also lacks a disclaimer that notifies you that you may be exposed to malware risks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Option 3**: Albeit the immediate path to using your own keys and truly using
    Secure Boot with only your own keys, you could download an existing *efitools*
    package for your distribution or compile it yourself from source code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Option 4**: If you’re feeling daring, you could attempt to use an early-release
    version of *sbctl* by getting it from the project’s GitHub and building it yourself.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You are not without choices on this Secure Boot issue, but that is just one
    issue you’ll need to consider. Let’s move on to other issues that can impact your
    firmware.
  prefs: []
  type: TYPE_NORMAL
- en: Possible threats in firmware
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Malicious code infecting firmware, such as a BIOS rootkit, seems to be the newest
    attack vector on a global scale. It is also a difficult-to-detect issue for security
    teams. This problem is industry-wide and, by that statement, it impacts virtually
    all hardware vendors creating solutions for the x86_64 platform family. One high-profile
    example of such evil comes through the appropriately named LogoFAIL attack.
  prefs: []
  type: TYPE_NORMAL
- en: LogoFAIL exploits a feature within all manufacturers’ UEFI BIOS, which enables
    them to create a custom splash screen at boot, hence displaying their company
    logo. It has found a way of injecting malicious code into the process, which enables
    the execution of code without the users’ knowledge with severe security implications.
  prefs: []
  type: TYPE_NORMAL
- en: In the past couple of years, two dozen high-severity CVEs have been created
    for vulnerabilities that impact millions of systems globally – network hardware,
    storage systems, servers, industrial controllers, edge devices, and laptops. Virtually
    all global manufacturers have been forced to make emergency updates to battle
    these possible attack vectors. As of today, when I’m writing this page (September
    2024), when I search in NIST’s National Vulnerability Database, the query returns
    over 4,500 results for firmware CVEs alone. To me, that quantity is grievously
    staggering to think about. The only good news I can offer in this situation is
    that the vast majority of those are already reported as resolved.
  prefs: []
  type: TYPE_NORMAL
- en: Some of these vulnerabilities stem from hardcoded credentials for support access
    being compromised, others from their very own bytecode having massive security
    gaps. The worst cases involve situations where actual malicious code has been
    installed without the end-user even knowing. Regardless of what the inception
    of the vulnerability is, its impact can be devastating. These are ticking time
    bombs, as bad actors can compromise a system and simply wait before leveraging
    the exploit.
  prefs: []
  type: TYPE_NORMAL
- en: For a product manager, these CVEs must be noted, tracked, and fixed. Your key
    takeaway from these firmware horror stories is twofold. First, ensure that the
    firmware on your appliances is at the version recommended by your hardware vendor.
    Second, ensure your firmware supply chain itself is secure. Accept updates only
    from credible sources or the vendors themselves. Do not assume that the firmware
    your systems arrived with should be the version that your team will ship. Again,
    trust but verify. Double check. Triple check.
  prefs: []
  type: TYPE_NORMAL
- en: Virus scanners cannot help with detection. They look at dissected files, not
    firmware. They have their place, but they are only a part of an overall assessment
    of security, not totality.
  prefs: []
  type: TYPE_NORMAL
- en: A new generation of tools has been created to help administrators detect, report,
    and update vulnerable firmware and BIOS modules. Open source has greatly assisted
    in this effort. Hardware vendors can openly share their updates with the community
    via tools such as a firmware update manager (aka the Linux Vendor Firmware Service).
    Vendors can choose to either share information regarding the versioning of specific
    firmware or to also provide updates to the ecosystem. With this new service in
    Linux, administrators can be easily made aware of available updates and/or automatically
    install them on their appliances. This is also a great way of sending updates
    to an appliance in the field.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I hope you have taken this chapter to heart. We have covered a topic here that
    is often referred to as a dark art in security circles due to the complexities
    it creates. By that, I mean securing firmware and the boot process along with
    the digital signatures of your stack. I trust that this chapter has instilled
    a higher degree of understanding of how to configure boot-level securities. Finally,
    we have also touched upon the unseen and often untalked-about vulnerabilities
    that can exist in firmware. Through services like those now provided by Linux
    or via the NIST database, you can stay informed about threats as they are reported.
    Knowing is half the battle. In our next chapter, we’ll explore a new way of deploying
    a Linux appliance through immutable images.
  prefs: []
  type: TYPE_NORMAL
