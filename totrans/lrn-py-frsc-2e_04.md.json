["```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<root>\n  <authors>Preston Miller &amp; Chapin Bryce</authors>\n  <chapters>\n   <element>\n     <chapterNumber>1</chapterNumber>\n     <chapterTitle>Now for Something Completely Different</chapterTitle>\n     <pageCount>30</pageCount>\n   </element>\n   <element>\n     <chapterNumber>2</chapterNumber>\n     <chapterTitle>Python Fundamentals</chapterTitle>\n     <pageCount>25</pageCount>\n   </element>\n  </chapters>\n  <numberOfChapters>13</numberOfChapters>\n  <pageCount>500</pageCount>\n  <publisher>Packt Publishing</publisher>\n  <title>Learning Python for Forensics</title>\n</root> \n```", "```\n>>> import xml.etree.ElementTree as ET\n>>> tree = ET.parse('book.xml')\n>>> root = tree.getroot() \n```", "```\n<chapter number=2, title=\"Python Fundamentals\", count=20 /> \n```", "```\n>>> print(root.find('authors').text)\nPreston Miller & Chapin Bryce\n>>> for element in root.findall('chapters/element'):\n... print('Chapter #{}'.format(element[0].text))\n... print('Chapter Title: {}'.format(element[1].text))\n...\nChapter #1\nChapter Title: Now for Something Completely Different\nChapter #2\nChapter Title: Python Fundamentals \n```", "```\n{\n  \"title\": \"Learning Python Forensics\",\n  \"authors\": \"Preston Miller & Chapin Bryce\",\n  \"publisher\": \"Packt Publishing\",\n  \"pageCount\": 500,\n  \"numberOfChapters\": 13,\n  \"chapters\":\n  [\n   {\n    \"chapterNumber\": 1,\n    \"chapterTitle\": \"Now for Something Completely Different\",\n    \"pageCount\": 30\n   },\n   {\n    \"chapterNumber\": 2,\n    \"chapterTitle\": \"Python Fundamentals\",\n    \"pageCount\": 25\n   }\n  ]\n}\n```", "```\n>>> import json\n>>> jsonfile = open('book.json', 'r')\n>>> decoded_data = json.loads(jsonfile.read())\n>>> print(type(decoded_data))\n<class'dict'>\n>>> print(decoded_data.keys())\ndict_keys(['title', 'authors', 'publisher', 'pageCount', 'numberOfChapters', 'chapters'])\n```", "```\n>>> for chapter in decoded_data['chapters']:\n... number = chapter['chapterNumber']\n... title = chapter['chapterTitle']\n... pages = chapter['pageCount']\n... print('Chapter {}, {}, is {} pages.'.format(number, title, pages))\n... \nChapter 1, Now For Something Completely Different, is 30 pages.\nChapter 2, Python Fundamentals, is 25 pages. \n```", "```\nhttps://blockchain.info/address/%btc_address%?format=json \n```", "```\n{\n \"hash160\":\"0be34924c8147535c5d5a077d6f398e2d3f20e2c\",\n \"address\":\"125riCXE2MtxHbNZkRtExPGAfbv7LsY3Wa\",\n \"n_tx\":25,\n \"total_received\":80000000,\n \"total_sent\":80000000,\n \"final_balance\":0,\n \"txs\":\n  [\n   ...\n  ]\n} \n```", "```\n\"txs\":[{\n  \"lock_time\":0,\n  \"result\":0,\n  \"ver\":1,\n  \"size\":225,\n  \"inputs\":[\n   {\n     \"sequence\":4294967295,\n     \"prev_out\":{\n      \"spent\":true,\n      \"tx_index\":103263818,\n      \"type\":0,\n      \"addr\":\"125riCXE2MtxHbNZkRtExPGAfbv7LsY3Wa\",\n      \"value\":51498513,\n      \"n\":1,\n        \"script\":\"76a9140be34924c8147535c5d5a077d6f398e2d3f20e2c88ac\"\n    },\n  \"script\":\"4730440220673b8c6485b263fa15c75adc5de55c902cf80451c3c54f8e49df4357ecd1a3ae022047aff8f9fb960f0f5b0313869b8042c7a81356e4cd23c9934ed1490110911ce9012103e92a19202a543d7da710af28c956807c13f31832a18c1893954f905b339034fb\"\n  }],\n  \"time\":1442766495,\n  \"tx_index\":103276852,\n  \"vin_sz\":1,\n    \"hash\":\"f00febdc80e67c72d9c4d50ae2aa43eec2684725b566ec2a9fa9e8dbfc449827\",\n  \"vout_sz\":2,\n  \"relayed_by\":\"127.0.0.1\",\n  \"out\":[\n   {\n     \"spent\":false,\n     \"tx_index\":103276852,\n     \"type\":0,\n     \"addr\":\"12ytXWtNpxaEYW6ZvM564hVnsiFn4QnhAT\",\n     \"value\":100000,\n     \"n\":0,\n     \"script\":\"76a91415ba6e75f51b0071e33152e5d34c2f6bca7998e888ac\"\n   }\n```", "```\n001 \"\"\"First iteration of the Bitcoin JSON transaction parser.\"\"\"\n002 import argparse\n003 import json\n004 import urllib.request\n005 import unix_converter as unix\n006 import sys\n...\n036 __authors__ = [\"Chapin Bryce\", \"Preston Miller\"]\n037 __date__ = 20181027\n038 __description__ = \"\"\"This scripts downloads address transactions\n039     using blockchain.info public APIs\"\"\"\n```", "```\n042 def main():\n...\n053 def get_address():\n...\n070 def print_transactions():\n...\n098 def print_header():\n...\n116 def get_inputs():\n```", "```\n128 if __name__ == '__main__':\n129     # Run this code if the script is run from the command line.\n130     parser = argparse.ArgumentParser(\n131         description=__description__,\n132         epilog='Built by {}. Version {}'.format(\n133             \", \".join(__authors__), __date__),\n134         formatter_class=argparse.ArgumentDefaultsHelpFormatter\n135     )\n136     parser.add_argument('ADDR', help='Bitcoin Address')\n137     args = parser.parse_args()\n138 \n139     # Print Script Information\n140     print('{:=^22}'.format(''))\n141     print('{}'.format('Bitcoin Address Lookup'))\n142     print('{:=^22} \\n'.format(''))\n143 \n144     # Run main program\n145     main(args.ADDR)\n```", "```\n042 def main(address):\n043     \"\"\"\n044     The main function handles coordinating logic\n045     :param address: The Bitcoin Address to lookup\n046     :return: Nothing\n047     \"\"\"\n048     raw_account = get_address(address)\n049     account = json.loads(raw_account.read())\n050     print_transactions(account)\n```", "```\n053 def get_address(address):\n054     \"\"\"\n055     The get_address function uses the blockchain.info Data API\n056     to pull pull down account information and transactions for\n057     address of interest\n058     :param address: The Bitcoin Address to lookup\n059     :return: The response of the url request\n060     \"\"\"\n```", "```\n061     url = 'https://blockchain.info/address/{}?format=json'\n062     formatted_url = url.format(address)\n063     try:\n064         return urllib.request.urlopen(formatted_url)\n065     except urllib.error.URLError:\n066         print('Received URL Error for {}'.format(formatted_url))\n067         sys.exit(1)\n```", "```\n>>> print(account['txs'][0].keys())\ndict_keys(['ver', 'inputs', 'weight', 'block_height', 'relayed_by',\n 'out', 'lock_time', 'result', 'size', 'time', 'tx_index', 'vin_sz',\n 'hash', 'vout_sz'])\n```", "```\n>>> print(account['txs'][0]['out'][0].keys())\ndict_keys(['spent', 'tx_index', 'type', 'addr', 'value', 'n',\n 'script'])\n```", "```\n070 def print_transactions(account):\n071     \"\"\"\n072     The print_transaction function is responsible for presenting\n073     transaction details to end user.\n074     :param account: The JSON decoded account and transaction data\n075     :return:\n076     \"\"\"\n077     print_header(account)\n078     print('Transactions')\n079     for i, tx in enumerate(account['txs']):\n```", "```\n080         print('Transaction #{}'.format(i))\n081         print('Transaction Hash:', tx['hash'])\n082         print('Transaction Date: {}'.format(\n083             unix.unix_converter(tx['time'])))\n```", "```\n084         for outputs in tx['out']:\n```", "```\n085              inputs = get_inputs(tx)\n```", "```\n086             if len(inputs) > 1:\n087                 print('{} --> {} ({:.8f} BTC)'.format(\n088                     ' & '.join(inputs), output['addr'],\n089                     outputs['value'] * 10**-8))\n090             else:\n091                 print('{} --> {} ({:.8f} BTC)'.format(\n092                     ''.join(inputs), outputs['addr'],\n093                     outputs['value'] * 10**-8))\n094 \n095         print('{:=^22}\\n'.format(''))\n```", "```\n098 def print_header(account):\n099     \"\"\"\n100     The print_header function prints overall header information\n101     containing basic address information.\n102     :param account: The JSON decoded account and transaction data\n103     :return: Nothing\n104     \"\"\"\n```", "```\n105     print('Address:', account['address'])\n106     print('Current Balance: {:.8f} BTC'.format(\n107         account['final_balance'] * 10**-8))\n108     print('Total Sent: {:.8f} BTC'.format(\n109         account['total_sent'] * 10**-8))\n110     print('Total Received: {:.8f} BTC'.format(\n111         account['total_received'] * 10**-8))\n112     print('Number of Transactions:', account['n_tx'])\n113     print('{:=^22}\\n'.format(''))\n```", "```\n116 def get_inputs(tx):\n117     \"\"\"\n118     The get_inputs function is a small helper function that returns\n119     input addresses for a given transaction\n120     :param tx: A single instance of a Bitcoin transaction\n121     :return: inputs, a list of inputs\n122     \"\"\"\n123     inputs = []\n```", "```\n124     for input_addr in tx['inputs']:\n125         inputs.append(input_addr['prev_out']['addr'])\n126     return inputs\n```", "```\n001 \"\"\"Second iteration of the Bitcoin JSON transaction parser.\"\"\"\n002 import argparse\n003 import json\n004 import logging\n005 import sys\n006 import os\n007 import urllib.request\n008 import unix_converter as unix\n...\n038 __authors__ = [\"Chapin Bryce\", \"Preston Miller\"]\n039 __date__ = 20181027\n040 __description__ = \"\"\"This scripts downloads address transactions\n041     using blockchain.info public APIs\"\"\"\n```", "```\n044 def main():\n...\n059 def get_address():\n...\n081 def print_transactions():\n...\n116 def print_header():\n...\n134 def get_inputs():\n```", "```\n146 if __name__ == '__main__':\n147     # Run this code if the script is run from the command line.\n148     parser = argparse.ArgumentParser(\n149     description=__description__,\n150     epilog='Built by {}. Version {}'.format(\n151         \", \".join(__authors__), __date__),\n152     formatter_class=argparse.ArgumentDefaultsHelpFormatter\n153     )\n154     parser.add_argument('ADDR', help='Bitcoin Address')\n155     parser.add_argument('-l', help=\"\"\"Specify log directory.\n156         Defaults to current working directory.\"\"\")\n157     args = parser.parse_args()\n```", "```\n159     # Set up Log\n160     if args.l:\n161         if not os.path.exists(args.l):\n162             os.makedirs(args.l)\n163         log_path = os.path.join(args.l, 'btc_addr_lookup.log')\n164     else:\n165         log_path = 'btc_addr_lookup.log'\n```", "```\n165     logging.basicConfig(\n166         filename=log_path, level=logging.DEBUG,\n167         format='%(asctime)s | %(levelname)s | %(message)s',\n168         filemode='w')\n```", "```\ntime | level | message \n```", "```\nlogging.error(\"Blah Blah function has generated an error from the following input: xyz123.\")  \n```", "```\n2015-11-06 19:51:47,446 | ERROR | Blah Blah function has generated an error from the following input: xyz123. \n```", "```\n171     logging.info('Starting Bitcoin Lookup v. {}'.format(__date__))\n172     logging.debug('System ' + sys.platform)\n173     logging.debug('Version ' + sys.version.replace(\"\\n\", \" \"))\n174 \n175     # Print Script Information\n176     print('{:=^22}'.format(''))\n177     print('{}'.format('Bitcoin Address Lookup'))\n178     print('{:=^22} \\n'.format(''))\n179 \n180     # Run main program\n181     main(args.ADDR)\n```", "```\n044 def main(address):\n045     \"\"\"\n046     The main function handles coordinating logic\n047     :param address: The Bitcoin Address to lookup\n048     :return: Nothing\n049     \"\"\"\n050     logging.info('Initiated program for {} address'.format(\n051         address))\n052     logging.info(\n053         'Obtaining JSON structured data from blockchain.info')\n054     raw_account = get_address(address)\n055     account = json.loads(raw_account.read())\n056     print_transactions(account)\n```", "```\n059 def get_address(address):\n060     \"\"\"\n061     The get_address function uses the blockchain.info Data API\n062     to pull pull down account information and transactions for\n063     address of interest\n064     :param address: The Bitcoin Address to lookup\n065     :return: The response of the url request\n066     \"\"\"\n```", "```\n067     url = 'https://blockchain.info/address/{}?format=json'\n068     formatted_url = url.format(address)\n069     try:\n070         return urllib.request.urlopen(formatted_url)\n071     except urllib.error.URLError as e:\n072         logging.error('URL Error for {}'.format(formatted_url))\n073         if hasattr(e, 'code') and hasattr(e, 'headers'):\n074             logging.debug('{}: {}'.format(e.code, e.reason))\n075             logging.debug('{}'.format(e.headers))\n076         print('Received URL Error for {}'.format(formatted_url))\n077         logging.info('Program exiting...')\n078         sys.exit(1)\n```", "```\n081 def print_transactions(account):\n082     \"\"\"\n083     The print_transaction function is responsible for presenting\n084     transaction details to end user.\n085     :param account: The JSON decoded account and transaction data\n086     :return: Nothing\n087     \"\"\"\n088     logging.info(\n089         'Printing account and transaction data to console.')\n090     print_header(account)\n091     print('Transactions')\n092     for i, tx in enumerate(account['txs']):\n093         print('Transaction #{}'.format(i))\n094         print('Transaction Hash:', tx['hash'])\n095         print('Transaction Date: {}'.format(\n096             unix.unix_converter(tx['time'])))\n```", "```\n097         for output in tx['out']:\n098             inputs = get_inputs(tx)\n099             if len(inputs) > 1:\n100                 print('{} --> {} ({:.8f} BTC)'.format(\n101                     ' & '.join(inputs), output['addr'],\n102                     output['value'] * 10**-8))\n103             elif len(inputs) == 1:\n104                 print('{} --> {} ({:.8f} BTC)'.format(\n105                     ''.join(inputs), output['addr'],\n106                     output['value'] * 10**-8))\n107             else:\n108                 logging.warn(\n109                     'Detected 0 inputs for transaction {}').format(\n110                         tx['hash'])\n111                 print('Detected 0 inputs for transaction.')\n112 \n113         print('{:=^22}\\n'.format(''))\n```", "```\n001 \"\"\"Final iteration of the Bitcoin JSON transaction parser.\"\"\"\n002 from __future__ import print_function\n003 import argparse\n004 import csv\n005 import json\n006 import logging\n007 import sys\n008 import os\n009 if sys.version_info[0] == 2:\n010     from urllib2 import urlopen\n011     from urllib2 import URLError\n012 elif sys.version_info[0] == 3:\n013     from urllib.request import urlopen\n014     from urllib.error import URLError\n015 else:\n016     print(\"Unsupported Python version. Exiting..\")\n017     sys.exit(1)\n018 import unix_converter as unix\n...\n048 __authors__ = [\"Chapin Bryce\", \"Preston Miller\"]\n049 __date__ = 20181027\n050 __description__ = \"\"\"This scripts downloads address transactions\n051     using blockchain.info public APIs\"\"\"\n```", "```\n>>> import csv\n>>> headers = ['Date', 'Name', 'Description'] \n```", "```\n>>> with open('test.csv', 'wb') as csvfile:\n...     writer = csv.writer(csvfile) \n```", "```\n...     writer.writerow(headers) \n```", "```\n...     csvfile.flush()\n...     csvfile.close() \n```", "```\n053 def main():\n...\n070 def get_address():\n...\n091 def parse_transactions():\n...\n123 def print_header():\n...\n142 def get_inputs():\n...\n159 def csv_writer():\n```", "```\n195 if __name__ == '__main__':\n196     # Run this code if the script is run from the command line.\n197     parser = argparse.ArgumentParser(\n198     description=__description__,\n199     epilog='Built by {}. Version {}'.format(\n200         \", \".join(__authors__), __date__),\n201     formatter_class=argparse.ArgumentDefaultsHelpFormatter\n202     )\n203 \n204     parser.add_argument('ADDR', help='Bitcoin Address')\n205     parser.add_argument('OUTPUT', help='Output CSV file')\n206     parser.add_argument('-l', help=\"\"\"Specify log directory.\n207         Defaults to current working directory.\"\"\")\n208 \n209     args = parser.parse_args()\n210 \n211     # Set up Log\n212     if args.l:\n213         if not os.path.exists(args.l):\n214             os.makedirs(args.l) # create log directory path\n215         log_path = os.path.join(args.l, 'btc_addr_lookup.log')\n216     else:\n217         log_path = 'btc_addr_lookup.log'\n218     logging.basicConfig(\n219         filename=log_path, level=logging.DEBUG,\n220         format='%(asctime)s | %(levelname)s | %(message)s',\n221         filemode='w')\n222 \n223     logging.info('Starting Bitcoid Lookup v. {}'.format(__date__))\n224     logging.debug('System ' + sys.platform)\n225     logging.debug('Version ' + sys.version.replace(\"\\n\", \" \"))\n226 \n227     # Print Script Information\n228     print('{:=^22}'.format(''))\n229     print('{}'.format('Bitcoin Address Lookup'))\n230     print('{:=^22} \\n'.format(''))\n231 \n232     # Run main program\n233     main(args.ADDR, args.OUTPUT)\n```", "```\n091 def parse_transactions(account, output_dir):\n092     \"\"\"\n093     The parse_transactions function appends transaction data into a\n094     nested list structure so it can be successfully used by the\n095     csv_writer function.\n096     :param account: The JSON decoded account and transaction data\n097     :param output_dir: The output directory to write the CSV\n098     results\n099     :return: Nothing\n100     \"\"\"\n```", "```\n101     msg = 'Parsing transactions...'\n102     logging.info(msg)\n103     print(msg)\n104     transactions = []\n105     for i, tx in enumerate(account['txs']):\n106         transaction = []\n```", "```\n107         outputs = {}\n108         inputs = get_inputs(tx)\n109         transaction.append(i)\n110         transaction.append(unix.unix_converter(tx['time']))\n111         transaction.append(tx['hash'])\n112         transaction.append(inputs)\n113         for output in tx['out']:\n114             outputs[output['addr']] = output['value'] * 10**-8\n115         transaction.append('\\n'.join(outputs.keys()))\n116         transaction.append(\n117             '\\n'.join(str(v) for v in outputs.values()))\n```", "```\n118         transaction.append('{:.8f}'.format(sum(outputs.values())))\n```", "```\n119         transactions.append(transaction)\n120     csv_writer(transactions, output_dir)\n```", "```\n159 def csv_writer(data, output_dir):\n160     \"\"\"\n161     The csv_writer function writes transaction data into a CSV file\n162     :param data: The parsed transaction data in nested list\n163     :param output_dir: The output directory to write the CSV\n164     results\n165     :return: Nothing\n166     \"\"\"\n167     logging.info('Writing output to {}'.format(output_dir))\n168     print('Writing output.')\n169     headers = ['Index', 'Date', 'Transaction Hash',\n170         'Inputs', 'Outputs', 'Values', 'Total']\n```", "```\n171     try:\n172         if sys.version_info[0] == 2:\n173             csvfile = open(output_dir, 'wb')\n174         else:\n175             csvfile = open(output_dir, 'w', newline='')\n176        with csvfile:\n177            writer = csv.writer(csvfile)\n178            writer.writerow(headers)\n179            for transaction in data:\n180                writer.writerow(transaction)\n181            csvfile.flush()\n182            csvfile.close()\n```", "```\n183     except IOError as e:\n184         logging.error(\"\"\"Error writing output to {}.\n185         \\nGenerated message: {}.\"\"\".format(e.filename,\n186         e.strerror))\n187         print(\"\"\"Error writing to CSV file.\n188         Please check output argument {}\"\"\".format(e.filename))\n189         logging.info('Program exiting.')\n190         sys.exit(1)\n191     logging.info('Program exiting.')\n192     print('Program exiting.')\n193     sys.exit(0)\n```"]