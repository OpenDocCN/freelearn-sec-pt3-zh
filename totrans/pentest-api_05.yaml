- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Injection Attacks and Validation Testing
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注入攻击和验证测试
- en: We are starting a new part of the book. So far, you have had an introduction
    to API security, how we can acquire more data about the target – with the important
    reconnaissance and information gathering chapter – and learned ways to test both
    authentication and authorization mechanisms most APIs implement nowadays. Now,
    it’s time to dive deeper into the waters of attacks. This part starts with injection
    and validation (or the lack of it) testing.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们即将开始书中的新部分。到目前为止，你已经了解了 API 安全的介绍，如何收集更多目标数据——通过重要的侦察与信息收集章节——并学习了测试大多数现代
    API 所实施的认证与授权机制的方法。现在，是时候深入探讨攻击领域了。本部分从注入攻击和验证（或缺乏验证）测试开始。
- en: These kinds of attacks are not new at all, but it’s impressive how often they
    show up in media headlines around the world, affecting pretty much all kinds and
    sizes of companies. Hopefully, you already know they are not limited to **Structured
    Query Language** (**SQL**), but if you don’t, that’s perfectly fine, as you will
    learn about them.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这类攻击并不新鲜，但它们在全球媒体头条中出现的频率令人印象深刻，几乎影响到各类公司。希望你已经知道，这些攻击不限于**结构化查询语言**（**SQL**），但如果你还不清楚，也没关系，因为你将在本书中学到这些内容。
- en: In this chapter, we start with an introduction of what exactly injection attacks
    are and which kinds of vulnerabilities can arise from a lack of attention to them.
    We then do some practical exercises with both SQL-related and NoSQL-related attacks,
    and we finish the chapter with a discussion about user input and the importance
    of validating it and sanitizing it.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先介绍什么是注入攻击，以及缺乏对其关注可能导致哪些漏洞。接下来，我们会进行一些实际操作，涉及 SQL 相关和 NoSQL 相关的攻击，最后我们将讨论用户输入及其验证和清理的重要性。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要内容：
- en: Understanding injection vulnerabilities
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解注入漏洞
- en: Testing for SQL injection
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试 SQL 注入
- en: Testing for NoSQL injection
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试 NoSQL 注入
- en: Validating and sanitizing user input
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证和清理用户输入
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: We’ll leverage the same environment as the one pointed out in [*Chapter 3*](B19657_03.xhtml#_idTextAnchor042).
    In summary, you’ll need a type 2 hypervisor, such as VirtualBox, and the same
    tools we used before – especially the **Completely Ridiculous API** (**crAPI**)
    project.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用与[**第 3 章**](B19657_03.xhtml#_idTextAnchor042)相同的环境。总结来说，你将需要一个类型 2 的虚拟化管理程序，如
    VirtualBox，以及我们之前使用的相同工具——尤其是**完全荒谬的 API**（**crAPI**）项目。
- en: Understanding injection vulnerabilities
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解注入漏洞
- en: Injection attacks are pretty easy to understand and sometimes to execute as
    well. They simply consist of inserting unexpected data, usually crafted commands
    or keywords, inside an input that should only contain specific data, such as a
    username and/or a corresponding password. By leveraging different formats, such
    as another encoding, or by adding commands to the input, a badly implemented API’s
    backend would inadvertently execute those commands or try to interpret the exceptional
    encoding, which could cause general failure and possible data leakage.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 注入攻击相对容易理解，有时也很容易执行。它们仅仅是将意外的数据（通常是精心构造的命令或关键字）插入到本应只包含特定数据（如用户名和/或相应密码）的输入中。通过利用不同的格式，如另一种编码方式，或通过在输入中添加命令，错误实现的
    API 后端可能会不小心执行这些命令，或尝试解释异常的编码，这可能导致系统故障以及可能的数据泄露。
- en: The possibly most famous variation of this attack affects SQL databases, and
    they are frequently called **SQLi** (“**i**” for **injection**) attacks. This
    happens because many publicly available applications and API endpoints interact
    with relational databases on their backend’s infrastructure. On the other hand,
    some other applications make use of unstructured data, which makes them candidates
    for NoSQL databases. But even so, the latter ones are also susceptible to the
    threat.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 可能最著名的这种攻击变种影响的是 SQL 数据库，它们通常被称为**SQLi**（“**i**”代表**注入**）攻击。这是因为许多公开可用的应用程序和
    API 接口与后端基础设施上的关系型数据库进行交互。另一方面，某些其他应用程序则使用非结构化数据，这使它们成为 NoSQL 数据库的候选者。即便如此，后者同样也容易受到此类威胁。
- en: You can inject code or spurious data either by building a request you’ll send
    to an API endpoint or by filling fields on a form that expects you, for example,
    to provide a comment on some product or service you recently acquired. Imagine
    for a moment that among your comments with satisfaction on buying that new video
    game, you add something such as “*DROP DATABASE products;*”. When the API endpoint
    code reads that comment, instead of returning it as an answer to a request, it
    will instead execute it and erase the entire `products` database.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: 'There are other types of injection attacks besides SQL and NoSQL, such as the
    following:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '**Lightweight Directory Access Protocol (LDAP) injection**: This attack targets
    LDAP servers used for authentication and authorization. If an API endpoint interacts
    with LDAP for user login, an attacker could inject malicious code into username
    or password fields. This code could exploit vulnerabilities in how the API constructs
    LDAP queries, potentially allowing the attacker to bypass authentication, steal
    user credentials from the directory server, or disrupt directory services, impacting
    user access to various systems. Mitigating LDAP injection requires ensuring proper
    input validation and escaping of special characters within user-supplied credentials
    before constructing LDAP queries.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GraphQL injection**: With the growing popularity of GraphQL APIs, attackers
    are devising ways to exploit vulnerabilities in how these APIs handle user input.
    Malicious queries can exploit weaknesses in query validation to gain unauthorized
    access to data, manipulate data returned by the API, or even trigger **denial-of-service**
    (**DoS**) attacks by crafting complex and resource-intensive queries. Preventing
    GraphQL injection requires implementing robust input validation techniques for
    all user-supplied data within GraphQL queries and enforcing query complexity limitations
    to prevent resource exhaustion attacks.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Over the last few years, there have been several reports covering injection
    attacks and their damage to companies and their customers. In 2017, the Equifax
    data breach, one of the largest data breaches in history, was caused by a vulnerability
    in an Apache Struts application. Struts is a web application framework used in
    several applications on the internet. This vulnerability allowed attackers to
    execute SQL injection attacks and steal the personal information of over 147 million
    individuals. In *Figure 5**.1*, you see a small, compiled list of some news covering
    injection attacks:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – News about injection attacks](img/B19657_05_01.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
- en: Figure 5.1 – News about injection attacks
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Injection can also happen in **graphical user interface** (**GUI**) scenarios.
    Another vulnerability affecting Apache Struts was discovered in 2018\. This vulnerability
    allowed attackers to execute remote code injection attacks through the Struts
    REST API. Recorded under *CVE-2018-11776*, it affected millions of web applications
    worldwide and underscored the importance of securing API endpoints against injection
    attacks.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '**XML External Entity** (**XXE**) injection is another injection attack vector
    that targets APIs parsing XML input. In 2019, Atlassian, the player behind some
    widely used applications such as Jira suite, Confluence, and Bitbucket, was affected
    by a vulnerability that targeted its Jira Service Management Data Center and Jira
    Service Management Server solutions. Detailed on *CVE-2019-13990*, this vulnerability
    allowed authenticated users to initiate XXE attacks through job descriptions.
    The vulnerable code was located on a specific third-party component: Terracotta
    Quartz Scheduler.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: NoSQL injection targets NoSQL databases by crafting especially prepared queries
    to aim sometimes undiscovered and sometimes widely known vulnerabilities in query
    parsing and execution. In 2020, a security researcher discovered a NoSQL injection
    vulnerability in a popular **mobile backend-as-a-service** (**MBaaS**) platform,
    Firebase. During an Android analysis as part of a bug bounty program, they discovered
    how attackers could bypass authentication and access sensitive user data stored
    in Firebase databases.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Beyond traditional injection attacks, command injection (and its counterpart,
    OS command injection) vulnerabilities in API endpoints can also lead to severe
    security breaches, and not even cyber security players are safe from this way
    of intruding into a system. Fortinet got caught with *CVE-2023-36553* when its
    FortiSIEM (**security information and event management**, or **SIEM**) platform
    had a vulnerability that allowed attackers to inject commands in API requests.
    In the same year, it was Palo Alto’s turn. One of its firewalls was discovered
    to be vulnerable to an API command injection vulnerability, allowing authenticated
    API users to inject commands on the device’s operating system, PAN-OS.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: API injection attacks highlight the importance of implementing robust input
    validation and sanitization mechanisms in API endpoints. By validating and sanitizing
    user input, developers can prevent injection attacks and mitigate the risk of
    data breaches and unauthorized access. Additionally, organizations should regularly
    perform security assessments and penetration testing to identify and remediate
    vulnerabilities in their API infrastructure.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: Time for practice! Let’s see how injection works in practical terms.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Testing for SQL injection
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'OK – now that you know the major types of injection attacks, let’s explore
    the one that is possibly the oldest while, at the same time, the most applied
    nowadays: injection on SQL databases. This kind of attack can vary from a very
    simple `OR` clause as part of user input to the complexity and sophistication
    of union and hidden union attacks, where multiple SQL statements can be combined
    to form an *explosive* payload. The first step, though, is not to attack the database
    behind the API endpoint but to fingerprint it. This can substantially reduce your
    effort in selecting techniques. By trying with some random input, you can force
    an unprepared API to return useful database error messages. Some engines reveal
    themselves in such error messages.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在你已经了解了主要的注入攻击类型，让我们来探讨一种可能是最古老但如今仍最常见的攻击方式：SQL 数据库上的注入攻击。这种攻击可以从简单的 `OR`
    子句开始，作为用户输入的一部分，到联合攻击和隐藏联合攻击的复杂性和精密度，其中多个 SQL 语句可以结合形成 *爆炸性* 负载。然而，第一步并不是直接攻击
    API 端点背后的数据库，而是进行指纹识别。这可以大大减少选择技术时的工作量。通过尝试一些随机输入，你可以迫使一个没有准备好的 API 返回有用的数据库错误消息。一些数据库引擎在这些错误消息中会暴露自身信息。
- en: 'The following snippet shows a typical error message from Microsoft SQL Server:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码段显示了来自 Microsoft SQL Server 的典型错误消息：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Likewise, the following snippet contains an error message from MariaDB or its
    “cousin” MySQL:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，以下代码段包含来自 MariaDB 或其“亲戚”MySQL 的错误消息：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This is an error message from an Oracle Database server. This product throws
    codes starting with `ORA`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这是来自 Oracle 数据库服务器的错误消息。这个产品抛出的代码以 `ORA` 开头：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Finally, this is an example of a message displayed by PostgreSQL when something
    goes wrong:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这是 PostgreSQL 出现问题时显示的消息示例：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Next, we will cover the most prevalent types of SQL injection attacks.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将介绍最常见的 SQL 注入攻击类型。
- en: Classic SQL injection
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 经典 SQL 注入
- en: Pretty much all attempts to insert commands into SQL instructions will happen
    with the `SELECT` directive. This is because one of the main objectives is to
    exfiltrate data from the database. You either want the whole user list with their
    passwords (hashed or not) or the details about its internal structures, such as
    the number of tables, the database schema, an order list with their values and
    delivery addresses, and so on and so forth.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有尝试将命令插入 SQL 指令的操作都会使用 `SELECT` 指令。这是因为其中一个主要目标是从数据库中提取数据。你可能想要获取完整的用户列表及其密码（无论是否加密），或有关其内部结构的详细信息，如表的数量、数据库架构、包含其值和配送地址的订单列表等。
- en: 'Imagine an online store where you can search for items. This search feature
    might have a security weakness. When you type in your search term, the system
    builds a special message (such as a coded instruction) to ask the database to
    find matching products. This particular way of building the message could be vulnerable
    to manipulation. Let’s take a closer look at an example of such a message:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个在线商店，你可以在其中搜索商品。这个搜索功能可能存在安全弱点。当你输入搜索词时，系统会构建一条特殊消息（如编码指令）来请求数据库查找匹配的商品。构建消息的这种方式可能容易受到操控。让我们仔细看看这样一条消息的例子：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `$user_input` variable represents what the user typed in a form field on
    the frontend component of this web application. It could be data sent to an API
    endpoint via a `POST` or `PUT` request as well. Without doing the required validation
    or sanitization, an injection can easily happen. Instead of providing some search
    text, the user could send the following:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`$user_input` 变量代表用户在此 web 应用程序的前端组件中表单字段中输入的内容。它也可以是通过 `POST` 或 `PUT` 请求发送到
    API 端点的数据。如果没有进行必要的验证或清理，注入攻击很容易发生。用户可能会发送以下内容，而不是提供某些搜索文本：'
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This will make the final query the following:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使最终的查询变为以下内容：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'With a logical `OR` operator whose second operand always evaluates as `true`,
    it doesn’t matter what the first part of the query (the user verification) is.
    The `–` part is understood as a comment, which means the SQL engine will ignore
    everything else after it. Some database engines use `/*` as the sequence to start
    a comment. In logical terms, it would be something like this:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 使用逻辑 `OR` 运算符，其第二个操作数总是求值为 `true`，无论查询的第一部分（用户验证）是什么，都没有关系。`–` 部分被理解为注释，这意味着
    SQL 引擎会忽略它之后的所有内容。一些数据库引擎使用 `/*` 作为注释的起始标记。从逻辑角度看，它大致相当于这样：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: With this simple joke, you would get the entire `products` database. If the
    API endpoint or application leverages the same input to carry out some other tasks,
    such as updating another database or deleting items, the damage can be even worse.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个简单的笑话，你可以获取整个`products`数据库。如果 API 端点或应用程序利用相同的输入执行其他任务，比如更新另一个数据库或删除项目，损害可能会更加严重。
- en: Stacked SQL injection
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 嵌套 SQL 注入
- en: Instead of classic SQL injection attacks, attackers can use a more advanced
    technique called stacked (or chained) SQL injection. This is like giving multiple
    orders at once in a restaurant. With stacked attacks, attackers trick the API
    endpoint into running several database instructions at the same time. This lets
    them achieve more complex goals, such as manipulating data or gaining more access
    within the system. These attacks are especially risky because they allow you to
    perform powerful actions on the database and potentially become a more powerful
    user within the endpoint.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者可以使用比经典 SQL 注入攻击更先进的技术，称为堆叠（或链式）SQL 注入。这就像在餐厅一次性给出多个订单一样。通过堆叠攻击，攻击者欺骗 API
    端点同时执行多个数据库指令，这让他们能够实现更复杂的目标，如篡改数据或在系统内获得更多权限。这些攻击尤其危险，因为它们允许你对数据库执行强有力的操作，并可能成为端点内更强大的用户。
- en: 'Let’s leverage the same command of the previous section. Suppose the target
    API endpoint sends the following query to the backend database:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们利用上一节中的相同命令。假设目标 API 端点向后台数据库发送以下查询：
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, let’s spice this up just a little with this as the `$``user_input` variable:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们稍微加点料，把它作为 `$``user_input` 变量：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This will make the final query the following:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使最终的查询变成如下：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: An SQL engine that receives such a query will interpret the semicolon sign as
    the end of the command and will execute the subsequent command, which inserts
    a new username and password into the `users` table. Should you be successful,
    you now have a credential pair to access the API endpoint and dive deeper into
    your pentesting activities…
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 接收到此类查询的 SQL 引擎将把分号符号解释为命令的结束，并执行随后的命令，该命令会将一个新的用户名和密码插入到 `users` 表中。如果成功的话，你现在就有了一对凭据，可以访问
    API 端点，并深入进行渗透测试活动……
- en: Union SQL injection
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 联合 SQL 注入
- en: Union SQL injection attacks are a sophisticated exploitation technique that
    manipulates the structure of SQL queries to extract additional information from
    a database. This type of attack leverages the SQL `UNION` operator to combine
    the results of two or more `SELECT` queries into a single result set, allowing
    you to retrieve data from database tables they would not typically have access
    to. Union SQL injection attacks are particularly dangerous as they can lead to
    unauthorized data access, data leakage, and even full database compromise if not
    properly mitigated.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 联合 SQL 注入攻击是一种复杂的利用技术，它操控 SQL 查询的结构，以从数据库中提取额外的信息。这种类型的攻击利用 SQL `UNION` 操作符，将两个或多个
    `SELECT` 查询的结果合并成一个单一的结果集，从而使你能够从通常没有权限访问的数据库表中检索数据。联合 SQL 注入攻击尤其危险，因为它们可能导致未经授权的数据访问、数据泄露，甚至如果没有正确缓解，可能会完全破坏数据库。
- en: 'Suppose your target API endpoint accepts `GET` requests. To request details
    about a product, for example, the request could be something like this:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你的目标 API 端点接受 `GET` 请求。例如，要请求某个产品的详细信息，请求可能是这样的：
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here, `$id` could be some numeric or alphanumeric value. Behind the scenes,
    the endpoint would craft a corresponding `SELECT` statement to pass it over to
    the database, such as the ones you’ve seen in the preceding sections. Now, let’s
    replace the content of `$id` with an especially crafted sequence:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`$id` 可能是某个数字或字母数字值。在后台，端点会构造一个相应的 `SELECT` 语句并将其传递给数据库，像你在前面部分看到的那样。现在，让我们将
    `$id` 的内容替换为一个特别设计的序列：
- en: '[PRE12]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This would result in the following `GET` request:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致以下 `GET` 请求：
- en: '[PRE13]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Without proper validation, the endpoint would be deceived into building the
    expected `SELECT` statement with `$prod_id` equals `50`, but also sending a second
    unpredicted `SELECT` statement that would retrieve all items from the `orders`
    table. This happens because the endpoint is simply picking the value of `$prod_id`
    and passing it to the `SELECT` command without even validating if it is in an
    expected shape. The `ALL` keyword plays an important role here. Some applications
    may use the `DISTINCT` keyword when selecting items from a database. This is,
    first, to avoid excessive network communication between endpoint and database,
    and second, to not retrieve duplicate items. When preceded by `ALL`, a `SELECT`
    statement will retrieve all items regardless of `DISTINCT`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有适当的验证，端点将被欺骗构建出预期的 `SELECT` 语句，其中 `$prod_id` 等于 `50`，但同时发送一个第二个未预测到的 `SELECT`
    语句，检索 `orders` 表中的所有项。这是因为端点只是选择了 `$prod_id` 的值，并将其传递给 `SELECT` 命令，而没有验证它是否符合预期格式。`ALL`
    关键字在这里起到了重要作用。有些应用在从数据库中选择项时可能会使用 `DISTINCT` 关键字。首先，这是为了避免端点与数据库之间的过多网络通信；其次，是为了避免检索重复的项目。当
    `ALL` 位于前面时，`SELECT` 语句将检索所有项目，而不管是否有 `DISTINCT`。
- en: Hidden union SQL injection
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 隐藏联合 SQL 注入
- en: Union SQL injection vulnerabilities present a substantial risk to the security
    of APIs. However, when attackers conceal their malicious intent within seemingly
    innocuous user input, the threat becomes even more insidious. This is where hidden
    union SQL injection emerges as a significant concern. Hidden union SQL injection
    extends the principles of conventional union attacks. You can exploit weaknesses
    in API endpoints but elevate the level of deceit. By meticulously devising malicious
    payloads that camouflage your final intention within the guise of legitimate user
    input, you can complicate detection and mitigation efforts.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 联合 SQL 注入漏洞对 API 安全构成了重大风险。然而，当攻击者将恶意意图隐藏在看似无害的用户输入中时，威胁就变得更加隐蔽。这就是隐藏联合 SQL
    注入成为一个重要关注点的原因。隐藏联合 SQL 注入延伸了传统联合攻击的原理。你可以利用 API 端点的弱点，但提升欺骗的层级。通过精心设计恶意有效载荷，将最终意图伪装成合法的用户输入，你可以使得检测和缓解工作变得更加复杂。
- en: The malevolent code seems benign when embedded within user input, rendering
    it challenging to spot during cursory examination. As a matter of fact, a poorly
    configured **web application firewall** (**WAF**) may ignore this attack. Moreover,
    extracted confidential data is frequently discreetly embedded within the API response,
    possibly melding with genuine information. This deceptive strategy complicates
    the detection of dubious activities and necessitates careful examination of API
    queries and responses.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意代码嵌入在用户输入中时看似无害，使得在粗略检查时难以发现。事实上，一个配置不当的**Web 应用防火墙**（**WAF**）可能会忽略这种攻击。此外，提取的机密数据通常会悄悄嵌入
    API 响应中，可能与真实信息混合在一起。这种欺骗性策略使得检测可疑活动变得更加困难，必须仔细检查 API 查询和响应。
- en: 'Suppose our target API endpoint accepts `POST` requests and responds with product
    data retrieved from the backend database. One possible scenario would be the following
    structure passed as a parameter to the endpoint:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们的目标 API 端点接受 `POST` 请求并响应从后台数据库检索到的产品数据。一个可能的场景是将以下结构作为参数传递给端点：
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This would become a legit `SQL SELECT` statement to bring 10 clothing products
    at most. With a hidden union attack, we would change this structure to look something
    like this:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这将成为一个合法的 `SQL SELECT` 语句，最多返回 10 件服装产品。通过隐藏联合攻击，我们可以将这个结构改为类似如下的形式：
- en: '[PRE15]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Observe the first change was to replace single quotes with double quotes for
    the value of `category`. This is to allow single quotes further on. The attack
    is then embedded between the parentheses. By sending this `SELECT` statement,
    we are requesting to receive information about both the admin user and the database
    engine version from a special table called `information_schema.tables`. And again,
    the `--` part has the same effect as the previous examples. The `version()` function
    returns details about the database engine, and the `LIMIT` keyword limits the
    answer to one row, to avoid the response being blocked by some rate-limiting/throttling
    mechanism.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 观察到第一个变化是将 `category` 的值中的单引号替换为双引号。这是为了允许后续使用单引号。攻击代码随后嵌入括号中。通过发送这个 `SELECT`
    语句，我们请求从一个名为 `information_schema.tables` 的特殊表中获取关于管理员用户和数据库引擎版本的信息。再一次，`--` 部分和之前的例子一样起到了注释作用。`version()`
    函数返回关于数据库引擎的详细信息，而 `LIMIT` 关键字将回答限制为一行，以避免响应被某些速率限制/节流机制拦截。
- en: Boolean SQL injection
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 布尔型 SQL 注入
- en: 'This technique is very useful when, while exploiting an SQL database backing
    an API endpoint, the returned error messages are too generic. For example, when
    asking for some non-existing product or user, the endpoint simply returns a 404
    error code and no further information. By sending some simple queries whose answers
    could be only `true` or `false`, you can check if the database is vulnerable to
    SQL injection and then create more directed attacks on it. Consider the following
    endpoint that accepts `GET` requests:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在利用 SQL 数据库支持 API 端点时，如果返回的错误信息过于通用，这个技巧非常有用。例如，当请求某个不存在的产品或用户时，端点仅返回 404
    错误代码，而没有更多信息。通过发送一些简单的查询，返回值仅可能是 `true` 或 `false`，你可以检查数据库是否容易受到 SQL 注入攻击，然后对其进行更有针对性的攻击。考虑以下接受
    `GET` 请求的端点：
- en: '[PRE16]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'By slightly changing it to the following, you can check what would be the answer:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 通过稍微修改为以下内容，你可以检查将会得到什么样的答案：
- en: '[PRE17]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This would obviously never work. The point here is not to get access to data
    on the very first attempt. We are fingerprinting how the database serving the
    API endpoint behaves. Now, you switch the second part of the statement to a valid
    value:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这显然永远不会成功。这里的重点不是在第一次尝试时就获得数据。我们的目的是识别支持 API 端点的数据库如何响应。现在，你将语句的第二部分更改为一个有效的值：
- en: '[PRE18]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: I didn’t say this before since it’s too obvious, but you need to capture all
    output that’s sent by the endpoint as the responses to your requests. Everything
    is important since a small piece of data can constitute a vital part of understanding
    the target. If the answer to the previous query (`1=1`) is different from the
    other query (`1=2`), you will conclude the database is vulnerable to SQL injection.
    In other words, the endpoint is not correctly sanitizing the input before sending
    it to the database. Some administrators simply configure their endpoints or web
    applications to provide generic error messages hoping that by obscuring them this
    way, they are protecting their environments. Big mistake…
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前没有说这个，因为它太显而易见了，但你需要捕获由端点发送的所有输出作为你请求的响应。每一部分数据都很重要，因为一个小片段的数据可能构成理解目标的关键部分。如果前一个查询（`1=1`）的答案与另一个查询（`1=2`）不同，你将得出数据库容易受到
    SQL 注入攻击的结论。换句话说，端点在将输入发送到数据库之前没有正确清理。某些管理员只是配置他们的端点或 Web 应用程序提供通用的错误信息，认为通过这种方式模糊化错误信息，可以保护他们的环境。大错特错……
- en: 'You can power up this technique by making use of some functions that are common
    to several database engines. The following functions are your friends:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过利用一些多个数据库引擎常见的函数来增强这一技术。以下函数是你的朋友：
- en: '`ASCII(character)`: Returns an integer value (the ASCII code) corresponding
    to the provided character.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ASCII(character)`：返回提供的字符对应的整数值（ASCII 码）。'
- en: '`LENGTH(string)`: Returns the length of the provided string in bytes.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LENGTH(string)`：返回提供的字符串的字节长度。'
- en: '`SUBSTRING(string, initial character, number of characters)`: Returns the partial
    string captured from the provided string, beginning on the initial character position
    with a total length of the number of characters. Consider 0 as the position of
    the initial character.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SUBSTRING(string, initial character, number of characters)`：返回从提供的字符串中截取的部分字符串，从初始字符位置开始，总长度为指定字符数。考虑
    0 为初始字符的位置。'
- en: 'Let your imagination fly. The query we sent before can be boosted with some
    discovery attempts. Consider you want to retrieve all usernames whose lengths
    are less than or equal to 10\. You can craft a query such as this:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: You can automate this by mixing and matching these functions, such as trying
    to guess the admin’s username. Do you realize the potential of this technique?
    By combining patience, imagination, and a vulnerable API endpoint, you can extract
    lots of data. In the next section, we will exploit SQL injection on crAPI.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: Exploiting SQL injection on a vulnerable API
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this exercise, we will leverage a lightweight and effective Python application
    embedded with some vulnerabilities, including SQL injection: `python vAPI.py -p
    <port>`. Just select a port not used by other tools, such as Burp Suite, **Open
    Worldwide Application Security Project Zed Attack Proxy** (**OWASP ZAP**), or
    WebGoat.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: Let’s also use our other friends, Burp Suite and Postman, to help us with this
    quest. Launch Burp Suite and start a new project with the defaults. Also, start
    Postman. You will need to either configure your operating system to use Burp as
    the proxy or configure Postman itself to do it. I recommend going with the second
    option for the sake of avoiding breaking other tests you may be doing in your
    system. In Postman, click **File** | **Settings** and choose **Proxy**. Then,
    make sure **Use system proxy** is disabled and enable **Use custom proxy configuration**.
    Select at least the **HTTP** proxy type and provide the hostname and port where
    Burp is listening for requests.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: 'vAPI has documentation written using the OpenAPI format. It’s represented by
    the `openapi/vAPI.yaml` path. Since it’s a small application, it’s OK to directly
    open and read this document. On the other hand, if you’d prefer to read it as
    an HTML file, there’s a very convenient Python code that can convert it for you.
    The utility can be found here: [https://gist.github.com/oseiskar/dbd51a3727fc96dcf5ed189fca491fb3](https://gist.github.com/oseiskar/dbd51a3727fc96dcf5ed189fca491fb3).
    You will verify there are a couple of endpoints accepting both `GET` and `POST`
    requests. After analyzing the available endpoints, it seems we start with the
    `/tokens` endpoint, and by providing a valid credential pair, you can receive
    a valid token. Start the application using some free port, such as `8000`:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'As we have no idea of what the usernames and passwords are, let’s use a creative
    combination of such by crafting a request with Postman:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2 – Sending a POST request to vAPI’s /tokens endpoint](img/B19657_05_02.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
- en: Figure 5.2 – Sending a POST request to vAPI’s /tokens endpoint
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: 'We obviously received an error message. Now, go to Burp Suite to check the
    HTTP connection history. Locate the request to `/tokens`, right-click on it (still
    on the `§`. This will be used to instruct the tool about which portions of subsequent
    requests will change during the attack:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Set **Attack type** as **Sniper**. Now, move to the **Payloads** subsection.
    Set **Payload type** as **Simple list** and click on the **Load…** button on the
    block that says **Payload settings [Simple list]**. You can load multiple files
    at once. Do this if you have more than one list. Deselect the last checkmark that
    says **URL encode these characters**. This will avoid unnecessary encoding when
    submitting the payloads to the target. Finally, click on **Start Attack**. In
    real life, if your target is protected by some rate-limiting or anti-DoS control,
    you may receive some blocks.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: If you are using the Community Edition of Burp Suite, this may take a while
    since the Intruder functionality has been reduced in features and attacks are
    locally time throttled. You may realize an interval of around 5 seconds between
    each payload.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: 'Hopefully, with some patience and luck, you will be successful in this. Actually,
    after some time, we managed to find a valid username. When analyzing Intruder’s
    outputs, look for the ones with the `200 code`. We had lots of this kind of code
    in our practical example. In *Figure 5**.3*, you can spot the success of our SQL
    injection attack against crAPI. We discovered a valid user ID and username:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3 – vAPI vulnerable to SQL injection and reveals a valid credential
    pair](img/B19657_05_03.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
- en: Figure 5.3 – vAPI vulnerable to SQL injection and reveals a valid credential
    pair
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: 'A token is provided as part of the response. You can leverage it, for example,
    to change the user’s password through the `/user` endpoint. Let’s use this same
    endpoint to obtain the user’s password, using the token extracted in our attack:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.4 – Obtaining the user’s password after gaining access to a valid
    token](img/B19657_05_04.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
- en: Figure 5.4 – Obtaining the user’s password after gaining access to a valid token
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: You can explore this application more and possibly get more data with further
    injection attacks. In the next section, let’s learn some NoSQL injection.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Testing for NoSQL injection
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have covered a reasonable ground of SQL injection attacks, but the fact is
    there is a considerable number of applications (and API endpoints) on the internet
    that need to handle unstructured data, such as documents, emails, social media
    posts, images, and audio and video files. For these use cases, relational databases
    are not the best choice since not all elements inside such databases have direct
    relationships, which would cause its management an unfair task. Carlo Strozzi
    introduced the concept of NoSQL databases in 1998 with his Strozzi NoSQL **open
    source software** (**OSS**) proposal. Since then, we’ve seen the release of many
    awesome products out there, such as MongoDB, Apache Cassandra, and Neo4j, just
    to name a few.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: 'As these databases, as their type implies, are not SQL ones, they do not use
    SQL for making queries or responding to them. Hence, our SQL injection techniques
    do not work here. We need to approach them in another way. In this scenario, there
    are basically three types of attacks that we can leverage to achieve success:
    **syntax injection**, **object injection**, and **operator injection**. Let’s
    separately cover each of them.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Syntax injection
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Syntax injection stands out as the prevalent form of NoSQL injection. In this
    type of attack, the pentester embeds harmful code within user input, which the
    API then integrates into a NoSQL query. This injected code has the potential to
    disrupt the syntax of the query, evade filters, or even trigger the execution
    of unauthorized commands within the database.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: The core concept of a NoSQL syntax injection attack revolves around manipulating
    user input. The pentester crafts malicious code and injects it into parameters
    that are then incorporated into the NoSQL query by the vulnerable API. One common
    scenario where NoSQL syntax injection attacks occur is in API endpoints that handle
    user authentication. For instance, an API might have a login endpoint where users
    submit their credentials for authentication. If the API uses a NoSQL database
    to store user data and does not properly sanitize user input, attackers can inject
    malicious code into the login credentials to bypass authentication checks or gain
    unauthorized access to user accounts.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: In a NoSQL syntax injection attack, you as a pentester can leverage various
    techniques to evade detection and achieve your objectives. For example, you might
    use wildcard characters, regular expressions, or other syntax manipulation techniques
    to craft payloads that disrupt the query’s structure or evade input validation
    mechanisms. By carefully constructing their payloads, you can exploit vulnerabilities
    in the API endpoint and compromise the integrity and confidentiality of the database.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how it works. Consider an API endpoint that does user authentication
    with the help of a NoSQL database. The endpoint accepts `GET` requests in the
    following format:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Internally, the API endpoint translates the request into a NoSQL query like
    this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Observe that there was absolutely no validation or filtering of the input provided
    by the requester, neither on the username nor on the password fields. We have
    a candidate for a NoSQL syntax injection attack! We could slightly change this
    request to something like the following:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We just manipulated the query to use a regular expression that represents any
    username and any password (`.` matches any character and `*` matches 0 or more
    occurrences of the preceding character). We just bypassed the authentication control
    of the endpoint…
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Object injection
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: NoSQL object injection attacks pose a distinct threat to APIs that interact
    with these types of databases. Unlike traditional NoSQL attacks that target the
    raw query itself, object injection attacks exploit weaknesses in how APIs handle
    user-provided data.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Imagine an API uses a secret language (serialization) to convert user data into
    a format the NoSQL database understands. You as a pentester can exploit vulnerabilities
    in this translation process. You could craft malicious data that, when *translated*
    (deserialized) by the API, manipulates internal object structures. This can lead
    to unexpected consequences, potentially allowing you to run unauthorized code
    or access sensitive data you shouldn’t.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: A common scenario involves APIs that serialize user-supplied data (such as JSON)
    before storing it in the NoSQL database. If the API doesn’t check the data carefully
    before translation, a pentester can sneak in malicious objects that exploit weaknesses
    in the deserialization process. Think of it like tricking the translator into
    saying something completely different than what you intended. This allows you
    to gain an unfair advantage within the system.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, we can consider an API endpoint that allows users to filter
    products based on price and category. The following JavaScript code shows a possible
    query that this endpoint could build to send to the database:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `filterObject` constant receives data directly provided by the requester
    (`minPrice` and `category`). This is then used on the `db.products.find` query.
    Continuing with our example, a valid `GET` request to select products with a minimum
    price of 100 and belonging to the `furniture` category would be the following:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'It doesn’t matter if it’s a `GET` or `POST` request. The same approach can
    be used for pretty much any verb here. How can we transform this into an object
    injection attack? Simple. We insert an initially unexpected object as part of
    the query. With this, the endpoint will grant us admin access besides checking
    the original product’s category. Look at the following example:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: If the endpoint is not correctly configured to sanitize this input, admin access
    to the database could be granted, and then other stages of the attack could happen.
    The `isAdmin` object was not intended to be part of a legitimate query, but because
    I previously knew that this database would accept it as a possible parameter (of
    course, after doing my enumeration/fingerprinting tasks), I’m a bit safer to assume
    it will work. The success of a NoSQL object injection attack largely depends on
    how the API handles user-supplied objects and incorporates them into its operations.
    Nevertheless, the fundamental concept of altering object structure to achieve
    unauthorized access or tamper with data holds true across different NoSQL database
    platforms.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Operator injection
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At this stage, you may have already deduced we are talking about inserting NoSQL
    operators as part of this sort of attack. Yeah – I was quite a Captain Obvious
    here, but consider this an attempt to give you some relaxation after this massive
    reading. Fortunately, you already have access to a small yet useful table with
    some operators that could be leveraged here.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: NoSQL databases offer a tempting combination of power and flexibility, but they
    also introduce new security challenges. NoSQL operator injection attacks lurk
    in the shadows, waiting to exploit APIs that interact with these databases. These
    attacks target vulnerabilities in APIs that build queries “on the fly” based on
    user input. Devious attackers can then inject specially crafted data to manipulate
    how the database interprets the query. This attack has some similarities with
    syntax injection; however, this one is not breaking the initially predicted syntax
    of a query but just twisting it.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine an API that allows users to search for products based on various filters,
    such as price or category, as we’ve previously seen. The API might construct a
    NoSQL query that dynamically incorporates user-supplied values. Here’s the problem:
    if the API doesn’t carefully check this user input, you can sneak in malicious
    operators. These operators, which are normally used for legitimate filtering,
    can be twisted to alter the query’s logic entirely. Think of it like someone manipulating
    the search bar on a library website to return unexpected results. Sounds familiar?'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s keep with our example of a website that provides products that in turn
    are organized into categories. An endpoint to show all products belonging to the
    `tools` category could be something like the following:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This translates into the following NoSQL query:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Simple, yet powerful. Now, suppose the user I’m using to interact with this
    endpoint does not have access to see products belonging to other categories, but
    the endpoint is not fully applying this control. So, how could I bypass it? Take
    a look:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `$ne` part corresponds to a NoSQL operator that means “not equal.” So,
    we are asking the API endpoint to show all products whose categories are not `tools`.
    Fantastic, isn’t it?! I’ve provided a list of MongoDB operators for your convenience.
    Observe not all NoSQL databases follow the same rule, so you can either try to
    fingerprint the backend database or combine operators from different database
    engines:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operator** | **Meaning** |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
- en: '| `$``eq` | Matches values that are equal to a specified value |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
- en: '| `$``ne` | Matches all values that are not equal to a specified value |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
- en: '| `$``gt` | Matches values that are greater than a specified value |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
- en: '| `$``gte` | Matches values that are greater than or equal to a specified value
    |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
- en: '| `$``in` | Matches any of the values specified in an array |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
- en: '| `$``lt` | Matches values that are less than a specified value |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
- en: '| `$``lte` | Matches values that are less than or equal to a specified value
    |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
- en: '| `$``nin` | Matches none of the values specified in an array |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
- en: 'Table 5.1 – MongoDB comparison operators (Source: MongoDB official documentation)'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s take a look at this in practice with an exercise.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Exploiting NoSQL injection on crAPI
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It’s time to get back to our old friend, crAPI. We well know it exposes a considerable
    number of endpoints, so let’s verify if there’s one we can pick to exercise this.
    Start your crAPI instance. Let’s also use our other friend, Burp Suite, to help
    us with this quest. Launch Burp Suite and start a new project with the defaults.
    You will need to use Burp’s browser in your lab since all services are listening
    locally (`localhost`). Access crAPI. If you still don’t have an account, create
    one by following the straightforward process. After logging in, go to the **Shop**
    area, as shown in *Figure 5**.5*:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.5 – crAPI’s Shop area](img/B19657_05_05.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
- en: Figure 5.5 – crAPI’s Shop area
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: 'Observe our initial balance: $100\. Our objective here is to buy an item for
    less than what it really costs or increase our balance. If we have a coupon, we
    can add its code using the corresponding button. The point is, we don’t have any
    code – yet… Click on the **Add Coupons** button and type anything. You will receive
    an error message:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.6 – Invalid coupon code](img/B19657_05_06.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
- en: Figure 5.6 – Invalid coupon code
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: 'This part of crAPI uses a NoSQL database (MongoDB, to be more precise) to store
    the coupons. Now, go to Burp Suite to check the HTTP connection history. The last
    item will show you which endpoint crAPI is using to check this code. You will
    realize it is `/community/api/v2/coupon/validate-coupon`. We also confirm the
    endpoint returns a 500 error code with an empty JSON structure. Now, let’s use
    another resource of Burp to help us discover crAPI’s coupons. *Figure 5**.7* shows
    an example of sending a request to the coupon validation endpoint:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.7 – crAPI’s coupon validation endpoint](img/B19657_05_07.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
- en: Figure 5.7 – crAPI’s coupon validation endpoint
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll do something similar to what we did with the vAPI Python application
    in the SQL injection section. Right-click on this coupon validation request (still
    on the **HTTP history** tab) and select **Send to Intruder**, then move to this
    section of the tool. The first subsection you’ll see is **Positions**. Observe
    the request structure is a simple JSON structure with a single key and value:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We want to fuzz the `"blabla"` part with lots of junk that will be pulled from
    the payload list. Select this whole `"blabla"` text, *including the double quotes*,
    and click on the `§`. Set **Attack type** as **Sniper**. Now, move to the **Payloads**
    subsection. Set **Payload type** as **Simple** and click on the **Load…** button
    on the block that says **Payload settings [Simple list]**. You can load multiple
    files at once. Do this if you have more than one. Deselect the last checkmark
    that says **URL encode these characters**. This will avoid unnecessary encoding
    when submitting the payloads to the target. Finally, click on **Start Attack**.
    Remember – Burp Community may take more time as the Intruder feature has intentionally
    received some delays between sent payloads.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, switch to the `200 code`, like the one on the following screenshot,
    which will disclose a coupon code to you. The `TRAC075` code means $75:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 5.8 – crAPI disclosing a coupon code after \uFEFFa NoSQL injection\
    \ attack](img/B19657_05_08.jpg)"
  id: totrans-172
  prefs: []
  type: TYPE_IMG
- en: Figure 5.8 – crAPI disclosing a coupon code after a NoSQL injection attack
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: Pick this coupon and add it to the corresponding area of the website. It will
    be accepted, and your balance will increase, as shown in *Figure 5**.9*. Lucky,
    lucky!
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.9 – Valid coupon code added](img/B19657_05_09.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
- en: Figure 5.9 – Valid coupon code added
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: You can see your balance has increased by $75, as shown in *Figure* *5**.10*.
    Rich!
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.10 – Balance increase after the coupon code was added](img/B19657_05_10.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
- en: Figure 5.10 – Balance increase after the coupon code was added
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You will never have to spend more for a single product on crAPI’s
    shop. Sorry – just another terrible icebreaker. The list of payloads I used for
    this attack can be easily found in the references that I put in the *Further reading*
    section. Do not forget to check them as there is a vast amount of material that
    you can use in your pentesting endeavors. Next, we will learn about user input
    validation and sanitization.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Validating and sanitizing user input
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this stage, I’m sure you are more than aware that the core success of injection
    attacks lies in the reduced (or lack of) sanitizing of what a user provides to
    an API endpoint or web application. When building secure APIs, validating and
    sanitizing user input is paramount for thwarting attacks. As a penetration tester,
    understanding these techniques is crucial for identifying vulnerabilities.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: When users sign up, input validation acts as a vigilant gatekeeper, guaranteeing
    the information they provide adheres to specific guidelines and is suitable for
    processing. It meticulously examines the format, length, and content of crucial
    fields such as usernames, email addresses, and passwords. Open source powerhouses
    such as OWASP **Enterprise Security API** (**ESAPI**) offer dependable validation
    tools for diverse user input types. Imagine wielding ESAPI’s validation functions
    to ensure usernames are composed solely of letters and numbers, adhering to a
    predefined length limit. Similarly, you can verify email addresses conform to
    a legitimate format and that passwords satisfy complexity mandates, such as minimum
    length and the inclusion of special characters. This robust approach safeguards
    a system from potentially harmful or nonsensical data.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: 'There are at least five points that deserve attention from any API developer.
    You as a pentester should obviously check the absence of any of them:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '`@` and `.`), and usernames free of special characters that might disrupt the
    system. However, these safeguards can sometimes be flawed. Tools such as OWASP
    ZAP and Burp Suite empower pentesters to become stealthy middlemen, intercepting
    and dissecting communication (HTTP requests) between the user and the API.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sanitizing query parameters for search queries**: APIs that empower users
    to unearth products by name or category require careful attention to sanitizing
    query parameters. This crucial step involves purging or transforming special characters
    that could potentially be exploited to manipulate the database query lurking beneath
    the surface. Tools such as SQLMap and NoSQLMap act as digital probes to reveal
    vulnerabilities in these queries. These tools can be employed to test for weaknesses
    susceptible to SQL and NoSQL injection attacks. By implementing robust input sanitization,
    such attacks can become ineffective and safeguard the integrity of the underlying
    database.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Validating file uploads**: Imagine an API that welcomes user-uploaded files,
    perhaps images or essential documents. However, lurking within this seemingly
    harmless functionality lies the potential for malicious activity. To fortify this
    API, robust input validation is paramount. It should act as a vigilant inspector,
    scrutinizing file types to ensure only permitted formats (such as images) are
    allowed. Additionally, size limitations must be enforced to prevent DoS attacks
    through massive file uploads. Malware detection mechanisms should be employed
    to identify and reject any malicious files that might attempt to infiltrate the
    system.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Furthermore, filenames themselves require sanitization. This crucial step thwarts
    “directory traversal attacks” – a technique where pentesters exploit vulnerabilities
    in file naming conventions to access unauthorized parts of the system. Tools such
    as OWASP ZAP and Nikto act as invaluable allies for security professionals, enabling
    them to simulate attacks and pinpoint weaknesses in the file upload functionality,
    especially those arising from inadequate input validation.
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`validator.js` for JavaScript or Django’s built-in form validation for Python
    offer invaluable assistance in implementing robust input validation for numeric
    input. These tools empower developers to establish clear guidelines for acceptable
    numerical ranges, preventing **out-of-bounds** (**OOB**) errors and maintaining
    data integrity within the API.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sanitizing HTML input to prevent cross-site scripting (XSS) attacks**: Certain
    APIs allow users to contribute HTML content, such as comments or product descriptions.
    This seemingly innocuous functionality can be weaponized by attackers if proper
    safeguards are not in place. Malicious actors might attempt to inject malevolent
    scripts (XSS attacks) within the HTML, potentially hijacking user sessions, stealing
    data, or redirecting users to malicious websites. To thwart these attacks, sanitization
    is a critical defense mechanism.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This process involves either transforming (escaping) or entirely removing potentially
    harmful HTML tags and attributes, rendering them inert and incapable of executing
    malicious code. Fortunately, open source libraries such as DOMPurify for JavaScript
    and Bleach for Python come to the rescue. These tools empower developers to effectively
    sanitize HTML input, neutralizing XSS vulnerabilities and safeguarding the integrity
    of the API and its users.
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Let’s take a closer look at each of these use cases.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Input validation for user registration
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: During user registration, input validation acts as a vigilant security checkpoint,
    guaranteeing the information users provide adheres to predefined standards and
    is suitable for processing without compromising system security. This meticulous
    process involves examining the format, length, and content of crucial fields such
    as usernames, email addresses, and passwords. Powerful tools such as OWASP ESAPI
    offer an arsenal of validation functions. Think of them as skilled guards, each
    with a specific expertise. One guard ensures usernames are built solely with letters
    and numbers, adhering to a length restriction. Another verifies email addresses
    following a legitimate format, while a third enforces password complexity, demanding
    a minimum length and the inclusion of special characters. By implementing these
    rigorous checks, you effectively filter out nonsensical or potentially malicious
    data that could be used by attackers to exploit vulnerabilities. Thorough input
    validation is the cornerstone of secure user registration. It builds a fortified
    wall around your system, safeguarding it from a multitude of security threats
    and ensuring the smooth operation of your kingdom (API and application).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: 'Even nowadays, Java is a prominent programming language, and it’s not difficult
    to find web applications and API endpoints built upon it. Let’s consider the following
    excerpt of Java code that shows an example of OWASP ESAPI in action:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In this code, two classes, `ESAPI` itself and `ValidationException` from the
    `errors` package, are leveraged. Observe that a username is only considered valid
    when the `ESAPI.validator()` function states so.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: Sanitizing query parameters
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sanitizing query parameters is a critical defense mechanism for APIs that interact
    with databases. Without proper sanitization, attackers can exploit vulnerabilities
    known as SQL injection to manipulate database queries. These malicious actors
    might use tools such as SQLMap to automate the process, sending a barrage of crafted
    strings (payloads) through query parameters. These payloads can potentially trick
    the database into executing unintended actions, such as stealing sensitive data
    or disrupting operations.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, we have powerful tools at our disposal to combat this threat. Input
    sanitization techniques, such as parameterized queries, act as a shield against
    such attacks. Parameterized queries separate the data (user input) from the actual
    SQL statement, preventing malicious code from being injected. Frameworks such
    as Flask in Python offer built-in support for parameterized queries. By embracing
    this approach, you can confidently execute SQL queries without exposing your application
    to the dangers of SQL injection, safeguarding the integrity of your database and
    user information.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code portion contains a Flask application interacting with an
    SQLite3 database. Instead of directly passing the input to the database, it first
    hardcodes the table name into the SQL statement and applies the `?` symbol:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In this example, the `q` query parameter is sanitized by using parameterized
    queries (`?`), ensuring that any malicious input provided by the user is properly
    escaped and doesn’t interfere with the SQL query execution.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Validating file uploads
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: File uploads offer a convenient functionality for users, but they can also be
    a gateway for attackers. Malicious actors might attempt to upload files disguised
    as harmless images or documents, but in reality, these files could be malicious
    scripts or executables capable of compromising the entire server. To prevent such
    attacks, robust input validation is essential. This process meticulously examines
    uploaded files, ensuring they adhere to predefined security standards.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: 'Validation focuses on two key aspects: file type and size. Only authorized
    file types, such as images or documents, should be allowed. Open source libraries
    such as **Apache Commons FileUpload** for Java come to the rescue, offering a
    suite of tools for validating uploads. These tools can check file extensions against
    a whitelist, verify content types to ensure they match the expected format, and
    enforce size limitations to prevent DoS attacks through massive uploads. By implementing
    these safeguards, you can effectively disarm these “digital bombs” disguised as
    file uploads, safeguarding your server and user data.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: 'The following Java code exemplifies how files sent as input to an API endpoint
    can be correctly validated before being effectively processed by the backend,
    including an eventual database:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In this code snippet, Apache Commons FileUpload is used to parse the file upload
    request, and then validation checks can be performed on the filename, content
    type, and size to ensure that only safe files are accepted for upload.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: Input validation for numeric input
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When dealing with numeric input from users, ensuring the data adheres to the
    expected format and remains within acceptable boundaries is critical. Unchecked
    numeric input can introduce vulnerabilities such as buffer overflows or arithmetic
    overflows, potentially leading to unexpected program behavior, crashes, or even
    system compromise.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: Open source libraries such as Apache Commons Validator for Java come to the
    rescue by offering a powerful arsenal for validating numeric input. These libraries
    provide functions specifically designed to handle different numeric data types
    – integers, floats, and more. Developers can leverage these functions to define
    clear constraints, such as minimum and maximum values, for acceptable user input.
    By implementing such validation, we can effectively “tame” numeric input, preventing
    errors and safeguarding the API endpoint from vulnerabilities that could be exploited
    by malicious actors. This ensures the endpoint processes data as intended and
    maintains its overall stability and security.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at how Apache Commons Validator for Java can be applied to sanitize user
    input:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In this code snippet, Apache Commons Validator’s `FloatValidator` class is used
    to validate a float input against the `US` locale, ensuring that the input string
    represents a valid floating-point number.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Sanitizing HTML input to prevent XSS attacks
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Imagine a scenario where untamed user input is directly inserted into a web
    page. This seemingly harmless practice creates a vulnerability known as XSS. Malicious
    actors can exploit XSS to plant hidden “*bombs*” within their input – malicious
    scripts disguised as regular text. Once the page renders, these scripts can detonate,
    stealing sensitive user information (such as session cookies) or performing unauthorized
    actions on the user’s behalf.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: To prevent such attacks, we rely on a technique called HTML escaping. This process
    involves encoding special characters within user input before displaying them
    on the web page. By encoding these characters, we effectively disarm the bombs
    and render them harmless. Open source libraries such as **OWASP Java Encoder**
    provide valuable utilities for HTML escaping. By leveraging these tools, developers
    can effectively sanitize user input, closing the door on XSS vulnerabilities and
    safeguarding user data and the API endpoint functionality.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code portion shows an example of how HTML input can be sanitized
    with the use of OWASP Java Encoder:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In this example, OWASP Java Encode’s `Encode.forHtml` method is used to sanitize
    HTML input by encoding special characters such as `<`, `>`, and `&`, thus preventing
    them from being interpreted as HTML tags or script elements by the browser.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we talked about injection attacks for both worlds, SQL and
    NoSQL, how they can be perpetrated, and the types of damage they can cause on
    an end system serving an API endpoint. We learned the different types of injection
    attacks, and we did two exercises, one with crAPI and another with a vulnerable
    Python application, each one showing how both types of databases can be hit by
    injecting commands or spurious/unpredicted data. We finished the chapter with
    a discussion about validating and sanitizing user input, which intends to either
    remove or at least reduce the success ratio of injection attacks. Code excerpts
    were also provided so that you could have a taste of how this works on real applications
    out there.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll talk about error handling and exception testing.
    This content is as important as anything else since we’ll see that a badly treated
    exception or error can disclose valuable information about the API or the application
    behind it.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Equifax data breach: [https://consumer.ftc.gov/consumer-alerts/2019/07/equifax-data-breach-settlement-what-you-should-know](https://consumer.ftc.gov/consumer-alerts/2019/07/equifax-data-breach-settlement-what-you-should-know)'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Firebase NoSQL vulnerability: [https://blog.securitybreached.org/2020/02/04/exploiting-insecure-firebase-database-bugbounty/](https://blog.securitybreached.org/2020/02/04/exploiting-insecure-firebase-database-bugbounty/)'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Common Vulnerabilities and Exposures** (**CVE**) reporting the Apache Structs
    vulnerability: [https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-11776](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-11776)'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Atlassian XXE vulnerability: [https://confluence.atlassian.com/security/cve-2019-13990-xxe-xml-external-entity-injection-vulnerability-in-jira-service-management-data-center-and-jira-service-management-server-1295385959.html](https://confluence.atlassian.com/security/cve-2019-13990-xxe-xml-external-entity-injection-vulnerability-in-jira-service-management-data-center-and-jira-service-management-server-1295385959.html)'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'FortiSIEM *CVE-2023-36553* MITRE record: [https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-36553](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-36553)'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'FortiSIEM *CVE-2023-36553* **National Institute of Standards and Technology**
    (**NIST**) notice: [https://nvd.nist.gov/vuln/detail/CVE-2023-36553](https://nvd.nist.gov/vuln/detail/CVE-2023-36553)'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Palo Alto OS command injection vulnerability – [https://security.paloaltonetworks.com/CVE-2023-6792](https://security.paloaltonetworks.com/CVE-2023-6792)
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*BleepingComputer* – *Hackers steal data of 2 million in SQL injection, XSS*
    *attacks*: [https://www.bleepingcomputer.com/news/security/hackers-steal-data-of-2-million-in-sql-injection-xss-attacks/](https://www.bleepingcomputer.com/news/security/hackers-steal-data-of-2-million-in-sql-injection-xss-attacks/)'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*PortSwigger* – *Car companies massively exposed to web* *vulnerabilities*:
    [https://portswigger.net/daily-swig/car-companies-massively-exposed-to-web-vulnerabilities](https://portswigger.net/daily-swig/car-companies-massively-exposed-to-web-vulnerabilities)'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The Hacker News* – *New Hacker Group ‘GambleForce’ Targeting APAC Firms Using
    SQL Injection* *Attacks*: [https://thehackernews.com/2023/12/new-hacker-group-gambleforce-tageting.html](https://thehackernews.com/2023/12/new-hacker-group-gambleforce-tageting.html)'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*PayloadsAllTheThings* (massive list of injection payloads): [https://github.com/swisskyrepo/PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings)'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'SQL injection payload list: [https://github.com/payloadbox/sql-injection-payload-list](https://github.com/payloadbox/sql-injection-payload-list)'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All-in-one fuzzing wordlist for SQL injection: [https://github.com/PenTestical/sqli](https://github.com/PenTestical/sqli)'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'vAPI Python application: [https://github.com/michealkeines/Vulnerable-API](https://github.com/michealkeines/Vulnerable-API)'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*An Exploration of Finding Aid Technologies and NoSQL Databases* – scientific
    article with an introduction to NoSQL databases: [https://ojs.library.ubc.ca/index.php/seealso/article/view/186333](https://ojs.library.ubc.ca/index.php/seealso/article/view/186333)'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'MongoDB query operators: [https://www.mongodb.com/docs/manual/reference/operator/query/](https://www.mongodb.com/docs/manual/reference/operator/query/)'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'OWASP ESAPI, a library that provides secure methods for sanitizing user input:
    [https://owasp.org/www-project-enterprise-security-api/](https://owasp.org/www-project-enterprise-security-api/)'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'SQLMap, a tool to automate pentesting on relational databases: [https://sqlmap.org/](https://sqlmap.org/)'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'NoSQLMap – The SQLMap cousin, dedicated to automating pentesting and auditing
    on non-relational databases: [https://github.com/codingo/NoSQLMap](https://github.com/codingo/NoSQLMap)'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Nikto, a useful utility to discover vulnerabilities in web servers, including
    outdated software and misconfigured interfaces: [https://github.com/sullo/nikto](https://github.com/sullo/nikto)'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`validator.js` for JavaScript, which validates and sanitizes string inputs:
    [https://www.npmjs.com/package/validator](https://www.npmjs.com/package/validator)'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'DOMPurify for JavaScript, a tool for sanitizing **Document Object Model** (**DOM**)
    HTML forms: [https://github.com/cure53/DOMPurify](https://github.com/cure53/DOMPurify)'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Apache Commons FileUpload Validator for Java, a library to sanitize files before
    considering them valid inputs: [https://commons.apache.org/proper/commons-fileupload/](https://commons.apache.org/proper/commons-fileupload/)'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'OWASP Java Encoder, a class that can be leveraged to encode HTML input and
    reduce chances of XSS attacks: [https://owasp.org/www-project-java-encoder/](https://owasp.org/www-project-java-encoder/)'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'OWASP ESAPI: [https://owasp.org/www-project-enterprise-security-api/](https://owasp.org/www-project-enterprise-security-api/)'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
