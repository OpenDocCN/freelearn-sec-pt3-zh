- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Injection Attacks and Validation Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are starting a new part of the book. So far, you have had an introduction
    to API security, how we can acquire more data about the target – with the important
    reconnaissance and information gathering chapter – and learned ways to test both
    authentication and authorization mechanisms most APIs implement nowadays. Now,
    it’s time to dive deeper into the waters of attacks. This part starts with injection
    and validation (or the lack of it) testing.
  prefs: []
  type: TYPE_NORMAL
- en: These kinds of attacks are not new at all, but it’s impressive how often they
    show up in media headlines around the world, affecting pretty much all kinds and
    sizes of companies. Hopefully, you already know they are not limited to **Structured
    Query Language** (**SQL**), but if you don’t, that’s perfectly fine, as you will
    learn about them.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we start with an introduction of what exactly injection attacks
    are and which kinds of vulnerabilities can arise from a lack of attention to them.
    We then do some practical exercises with both SQL-related and NoSQL-related attacks,
    and we finish the chapter with a discussion about user input and the importance
    of validating it and sanitizing it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding injection vulnerabilities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing for SQL injection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing for NoSQL injection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validating and sanitizing user input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ll leverage the same environment as the one pointed out in [*Chapter 3*](B19657_03.xhtml#_idTextAnchor042).
    In summary, you’ll need a type 2 hypervisor, such as VirtualBox, and the same
    tools we used before – especially the **Completely Ridiculous API** (**crAPI**)
    project.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding injection vulnerabilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Injection attacks are pretty easy to understand and sometimes to execute as
    well. They simply consist of inserting unexpected data, usually crafted commands
    or keywords, inside an input that should only contain specific data, such as a
    username and/or a corresponding password. By leveraging different formats, such
    as another encoding, or by adding commands to the input, a badly implemented API’s
    backend would inadvertently execute those commands or try to interpret the exceptional
    encoding, which could cause general failure and possible data leakage.
  prefs: []
  type: TYPE_NORMAL
- en: The possibly most famous variation of this attack affects SQL databases, and
    they are frequently called **SQLi** (“**i**” for **injection**) attacks. This
    happens because many publicly available applications and API endpoints interact
    with relational databases on their backend’s infrastructure. On the other hand,
    some other applications make use of unstructured data, which makes them candidates
    for NoSQL databases. But even so, the latter ones are also susceptible to the
    threat.
  prefs: []
  type: TYPE_NORMAL
- en: You can inject code or spurious data either by building a request you’ll send
    to an API endpoint or by filling fields on a form that expects you, for example,
    to provide a comment on some product or service you recently acquired. Imagine
    for a moment that among your comments with satisfaction on buying that new video
    game, you add something such as “*DROP DATABASE products;*”. When the API endpoint
    code reads that comment, instead of returning it as an answer to a request, it
    will instead execute it and erase the entire `products` database.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are other types of injection attacks besides SQL and NoSQL, such as the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Lightweight Directory Access Protocol (LDAP) injection**: This attack targets
    LDAP servers used for authentication and authorization. If an API endpoint interacts
    with LDAP for user login, an attacker could inject malicious code into username
    or password fields. This code could exploit vulnerabilities in how the API constructs
    LDAP queries, potentially allowing the attacker to bypass authentication, steal
    user credentials from the directory server, or disrupt directory services, impacting
    user access to various systems. Mitigating LDAP injection requires ensuring proper
    input validation and escaping of special characters within user-supplied credentials
    before constructing LDAP queries.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GraphQL injection**: With the growing popularity of GraphQL APIs, attackers
    are devising ways to exploit vulnerabilities in how these APIs handle user input.
    Malicious queries can exploit weaknesses in query validation to gain unauthorized
    access to data, manipulate data returned by the API, or even trigger **denial-of-service**
    (**DoS**) attacks by crafting complex and resource-intensive queries. Preventing
    GraphQL injection requires implementing robust input validation techniques for
    all user-supplied data within GraphQL queries and enforcing query complexity limitations
    to prevent resource exhaustion attacks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Over the last few years, there have been several reports covering injection
    attacks and their damage to companies and their customers. In 2017, the Equifax
    data breach, one of the largest data breaches in history, was caused by a vulnerability
    in an Apache Struts application. Struts is a web application framework used in
    several applications on the internet. This vulnerability allowed attackers to
    execute SQL injection attacks and steal the personal information of over 147 million
    individuals. In *Figure 5**.1*, you see a small, compiled list of some news covering
    injection attacks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – News about injection attacks](img/B19657_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.1 – News about injection attacks
  prefs: []
  type: TYPE_NORMAL
- en: Injection can also happen in **graphical user interface** (**GUI**) scenarios.
    Another vulnerability affecting Apache Struts was discovered in 2018\. This vulnerability
    allowed attackers to execute remote code injection attacks through the Struts
    REST API. Recorded under *CVE-2018-11776*, it affected millions of web applications
    worldwide and underscored the importance of securing API endpoints against injection
    attacks.
  prefs: []
  type: TYPE_NORMAL
- en: '**XML External Entity** (**XXE**) injection is another injection attack vector
    that targets APIs parsing XML input. In 2019, Atlassian, the player behind some
    widely used applications such as Jira suite, Confluence, and Bitbucket, was affected
    by a vulnerability that targeted its Jira Service Management Data Center and Jira
    Service Management Server solutions. Detailed on *CVE-2019-13990*, this vulnerability
    allowed authenticated users to initiate XXE attacks through job descriptions.
    The vulnerable code was located on a specific third-party component: Terracotta
    Quartz Scheduler.'
  prefs: []
  type: TYPE_NORMAL
- en: NoSQL injection targets NoSQL databases by crafting especially prepared queries
    to aim sometimes undiscovered and sometimes widely known vulnerabilities in query
    parsing and execution. In 2020, a security researcher discovered a NoSQL injection
    vulnerability in a popular **mobile backend-as-a-service** (**MBaaS**) platform,
    Firebase. During an Android analysis as part of a bug bounty program, they discovered
    how attackers could bypass authentication and access sensitive user data stored
    in Firebase databases.
  prefs: []
  type: TYPE_NORMAL
- en: Beyond traditional injection attacks, command injection (and its counterpart,
    OS command injection) vulnerabilities in API endpoints can also lead to severe
    security breaches, and not even cyber security players are safe from this way
    of intruding into a system. Fortinet got caught with *CVE-2023-36553* when its
    FortiSIEM (**security information and event management**, or **SIEM**) platform
    had a vulnerability that allowed attackers to inject commands in API requests.
    In the same year, it was Palo Alto’s turn. One of its firewalls was discovered
    to be vulnerable to an API command injection vulnerability, allowing authenticated
    API users to inject commands on the device’s operating system, PAN-OS.
  prefs: []
  type: TYPE_NORMAL
- en: API injection attacks highlight the importance of implementing robust input
    validation and sanitization mechanisms in API endpoints. By validating and sanitizing
    user input, developers can prevent injection attacks and mitigate the risk of
    data breaches and unauthorized access. Additionally, organizations should regularly
    perform security assessments and penetration testing to identify and remediate
    vulnerabilities in their API infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: Time for practice! Let’s see how injection works in practical terms.
  prefs: []
  type: TYPE_NORMAL
- en: Testing for SQL injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'OK – now that you know the major types of injection attacks, let’s explore
    the one that is possibly the oldest while, at the same time, the most applied
    nowadays: injection on SQL databases. This kind of attack can vary from a very
    simple `OR` clause as part of user input to the complexity and sophistication
    of union and hidden union attacks, where multiple SQL statements can be combined
    to form an *explosive* payload. The first step, though, is not to attack the database
    behind the API endpoint but to fingerprint it. This can substantially reduce your
    effort in selecting techniques. By trying with some random input, you can force
    an unprepared API to return useful database error messages. Some engines reveal
    themselves in such error messages.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following snippet shows a typical error message from Microsoft SQL Server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Likewise, the following snippet contains an error message from MariaDB or its
    “cousin” MySQL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This is an error message from an Oracle Database server. This product throws
    codes starting with `ORA`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, this is an example of a message displayed by PostgreSQL when something
    goes wrong:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Next, we will cover the most prevalent types of SQL injection attacks.
  prefs: []
  type: TYPE_NORMAL
- en: Classic SQL injection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Pretty much all attempts to insert commands into SQL instructions will happen
    with the `SELECT` directive. This is because one of the main objectives is to
    exfiltrate data from the database. You either want the whole user list with their
    passwords (hashed or not) or the details about its internal structures, such as
    the number of tables, the database schema, an order list with their values and
    delivery addresses, and so on and so forth.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine an online store where you can search for items. This search feature
    might have a security weakness. When you type in your search term, the system
    builds a special message (such as a coded instruction) to ask the database to
    find matching products. This particular way of building the message could be vulnerable
    to manipulation. Let’s take a closer look at an example of such a message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The `$user_input` variable represents what the user typed in a form field on
    the frontend component of this web application. It could be data sent to an API
    endpoint via a `POST` or `PUT` request as well. Without doing the required validation
    or sanitization, an injection can easily happen. Instead of providing some search
    text, the user could send the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This will make the final query the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'With a logical `OR` operator whose second operand always evaluates as `true`,
    it doesn’t matter what the first part of the query (the user verification) is.
    The `–` part is understood as a comment, which means the SQL engine will ignore
    everything else after it. Some database engines use `/*` as the sequence to start
    a comment. In logical terms, it would be something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: With this simple joke, you would get the entire `products` database. If the
    API endpoint or application leverages the same input to carry out some other tasks,
    such as updating another database or deleting items, the damage can be even worse.
  prefs: []
  type: TYPE_NORMAL
- en: Stacked SQL injection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Instead of classic SQL injection attacks, attackers can use a more advanced
    technique called stacked (or chained) SQL injection. This is like giving multiple
    orders at once in a restaurant. With stacked attacks, attackers trick the API
    endpoint into running several database instructions at the same time. This lets
    them achieve more complex goals, such as manipulating data or gaining more access
    within the system. These attacks are especially risky because they allow you to
    perform powerful actions on the database and potentially become a more powerful
    user within the endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s leverage the same command of the previous section. Suppose the target
    API endpoint sends the following query to the backend database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s spice this up just a little with this as the `$``user_input` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This will make the final query the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: An SQL engine that receives such a query will interpret the semicolon sign as
    the end of the command and will execute the subsequent command, which inserts
    a new username and password into the `users` table. Should you be successful,
    you now have a credential pair to access the API endpoint and dive deeper into
    your pentesting activities…
  prefs: []
  type: TYPE_NORMAL
- en: Union SQL injection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Union SQL injection attacks are a sophisticated exploitation technique that
    manipulates the structure of SQL queries to extract additional information from
    a database. This type of attack leverages the SQL `UNION` operator to combine
    the results of two or more `SELECT` queries into a single result set, allowing
    you to retrieve data from database tables they would not typically have access
    to. Union SQL injection attacks are particularly dangerous as they can lead to
    unauthorized data access, data leakage, and even full database compromise if not
    properly mitigated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose your target API endpoint accepts `GET` requests. To request details
    about a product, for example, the request could be something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `$id` could be some numeric or alphanumeric value. Behind the scenes,
    the endpoint would craft a corresponding `SELECT` statement to pass it over to
    the database, such as the ones you’ve seen in the preceding sections. Now, let’s
    replace the content of `$id` with an especially crafted sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This would result in the following `GET` request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Without proper validation, the endpoint would be deceived into building the
    expected `SELECT` statement with `$prod_id` equals `50`, but also sending a second
    unpredicted `SELECT` statement that would retrieve all items from the `orders`
    table. This happens because the endpoint is simply picking the value of `$prod_id`
    and passing it to the `SELECT` command without even validating if it is in an
    expected shape. The `ALL` keyword plays an important role here. Some applications
    may use the `DISTINCT` keyword when selecting items from a database. This is,
    first, to avoid excessive network communication between endpoint and database,
    and second, to not retrieve duplicate items. When preceded by `ALL`, a `SELECT`
    statement will retrieve all items regardless of `DISTINCT`.
  prefs: []
  type: TYPE_NORMAL
- en: Hidden union SQL injection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Union SQL injection vulnerabilities present a substantial risk to the security
    of APIs. However, when attackers conceal their malicious intent within seemingly
    innocuous user input, the threat becomes even more insidious. This is where hidden
    union SQL injection emerges as a significant concern. Hidden union SQL injection
    extends the principles of conventional union attacks. You can exploit weaknesses
    in API endpoints but elevate the level of deceit. By meticulously devising malicious
    payloads that camouflage your final intention within the guise of legitimate user
    input, you can complicate detection and mitigation efforts.
  prefs: []
  type: TYPE_NORMAL
- en: The malevolent code seems benign when embedded within user input, rendering
    it challenging to spot during cursory examination. As a matter of fact, a poorly
    configured **web application firewall** (**WAF**) may ignore this attack. Moreover,
    extracted confidential data is frequently discreetly embedded within the API response,
    possibly melding with genuine information. This deceptive strategy complicates
    the detection of dubious activities and necessitates careful examination of API
    queries and responses.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose our target API endpoint accepts `POST` requests and responds with product
    data retrieved from the backend database. One possible scenario would be the following
    structure passed as a parameter to the endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This would become a legit `SQL SELECT` statement to bring 10 clothing products
    at most. With a hidden union attack, we would change this structure to look something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Observe the first change was to replace single quotes with double quotes for
    the value of `category`. This is to allow single quotes further on. The attack
    is then embedded between the parentheses. By sending this `SELECT` statement,
    we are requesting to receive information about both the admin user and the database
    engine version from a special table called `information_schema.tables`. And again,
    the `--` part has the same effect as the previous examples. The `version()` function
    returns details about the database engine, and the `LIMIT` keyword limits the
    answer to one row, to avoid the response being blocked by some rate-limiting/throttling
    mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: Boolean SQL injection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This technique is very useful when, while exploiting an SQL database backing
    an API endpoint, the returned error messages are too generic. For example, when
    asking for some non-existing product or user, the endpoint simply returns a 404
    error code and no further information. By sending some simple queries whose answers
    could be only `true` or `false`, you can check if the database is vulnerable to
    SQL injection and then create more directed attacks on it. Consider the following
    endpoint that accepts `GET` requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'By slightly changing it to the following, you can check what would be the answer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This would obviously never work. The point here is not to get access to data
    on the very first attempt. We are fingerprinting how the database serving the
    API endpoint behaves. Now, you switch the second part of the statement to a valid
    value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: I didn’t say this before since it’s too obvious, but you need to capture all
    output that’s sent by the endpoint as the responses to your requests. Everything
    is important since a small piece of data can constitute a vital part of understanding
    the target. If the answer to the previous query (`1=1`) is different from the
    other query (`1=2`), you will conclude the database is vulnerable to SQL injection.
    In other words, the endpoint is not correctly sanitizing the input before sending
    it to the database. Some administrators simply configure their endpoints or web
    applications to provide generic error messages hoping that by obscuring them this
    way, they are protecting their environments. Big mistake…
  prefs: []
  type: TYPE_NORMAL
- en: 'You can power up this technique by making use of some functions that are common
    to several database engines. The following functions are your friends:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ASCII(character)`: Returns an integer value (the ASCII code) corresponding
    to the provided character.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LENGTH(string)`: Returns the length of the provided string in bytes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SUBSTRING(string, initial character, number of characters)`: Returns the partial
    string captured from the provided string, beginning on the initial character position
    with a total length of the number of characters. Consider 0 as the position of
    the initial character.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let your imagination fly. The query we sent before can be boosted with some
    discovery attempts. Consider you want to retrieve all usernames whose lengths
    are less than or equal to 10\. You can craft a query such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: You can automate this by mixing and matching these functions, such as trying
    to guess the admin’s username. Do you realize the potential of this technique?
    By combining patience, imagination, and a vulnerable API endpoint, you can extract
    lots of data. In the next section, we will exploit SQL injection on crAPI.
  prefs: []
  type: TYPE_NORMAL
- en: Exploiting SQL injection on a vulnerable API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this exercise, we will leverage a lightweight and effective Python application
    embedded with some vulnerabilities, including SQL injection: `python vAPI.py -p
    <port>`. Just select a port not used by other tools, such as Burp Suite, **Open
    Worldwide Application Security Project Zed Attack Proxy** (**OWASP ZAP**), or
    WebGoat.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s also use our other friends, Burp Suite and Postman, to help us with this
    quest. Launch Burp Suite and start a new project with the defaults. Also, start
    Postman. You will need to either configure your operating system to use Burp as
    the proxy or configure Postman itself to do it. I recommend going with the second
    option for the sake of avoiding breaking other tests you may be doing in your
    system. In Postman, click **File** | **Settings** and choose **Proxy**. Then,
    make sure **Use system proxy** is disabled and enable **Use custom proxy configuration**.
    Select at least the **HTTP** proxy type and provide the hostname and port where
    Burp is listening for requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'vAPI has documentation written using the OpenAPI format. It’s represented by
    the `openapi/vAPI.yaml` path. Since it’s a small application, it’s OK to directly
    open and read this document. On the other hand, if you’d prefer to read it as
    an HTML file, there’s a very convenient Python code that can convert it for you.
    The utility can be found here: [https://gist.github.com/oseiskar/dbd51a3727fc96dcf5ed189fca491fb3](https://gist.github.com/oseiskar/dbd51a3727fc96dcf5ed189fca491fb3).
    You will verify there are a couple of endpoints accepting both `GET` and `POST`
    requests. After analyzing the available endpoints, it seems we start with the
    `/tokens` endpoint, and by providing a valid credential pair, you can receive
    a valid token. Start the application using some free port, such as `8000`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'As we have no idea of what the usernames and passwords are, let’s use a creative
    combination of such by crafting a request with Postman:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2 – Sending a POST request to vAPI’s /tokens endpoint](img/B19657_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.2 – Sending a POST request to vAPI’s /tokens endpoint
  prefs: []
  type: TYPE_NORMAL
- en: 'We obviously received an error message. Now, go to Burp Suite to check the
    HTTP connection history. Locate the request to `/tokens`, right-click on it (still
    on the `§`. This will be used to instruct the tool about which portions of subsequent
    requests will change during the attack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Set **Attack type** as **Sniper**. Now, move to the **Payloads** subsection.
    Set **Payload type** as **Simple list** and click on the **Load…** button on the
    block that says **Payload settings [Simple list]**. You can load multiple files
    at once. Do this if you have more than one list. Deselect the last checkmark that
    says **URL encode these characters**. This will avoid unnecessary encoding when
    submitting the payloads to the target. Finally, click on **Start Attack**. In
    real life, if your target is protected by some rate-limiting or anti-DoS control,
    you may receive some blocks.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you are using the Community Edition of Burp Suite, this may take a while
    since the Intruder functionality has been reduced in features and attacks are
    locally time throttled. You may realize an interval of around 5 seconds between
    each payload.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hopefully, with some patience and luck, you will be successful in this. Actually,
    after some time, we managed to find a valid username. When analyzing Intruder’s
    outputs, look for the ones with the `200 code`. We had lots of this kind of code
    in our practical example. In *Figure 5**.3*, you can spot the success of our SQL
    injection attack against crAPI. We discovered a valid user ID and username:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3 – vAPI vulnerable to SQL injection and reveals a valid credential
    pair](img/B19657_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.3 – vAPI vulnerable to SQL injection and reveals a valid credential
    pair
  prefs: []
  type: TYPE_NORMAL
- en: 'A token is provided as part of the response. You can leverage it, for example,
    to change the user’s password through the `/user` endpoint. Let’s use this same
    endpoint to obtain the user’s password, using the token extracted in our attack:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.4 – Obtaining the user’s password after gaining access to a valid
    token](img/B19657_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.4 – Obtaining the user’s password after gaining access to a valid token
  prefs: []
  type: TYPE_NORMAL
- en: You can explore this application more and possibly get more data with further
    injection attacks. In the next section, let’s learn some NoSQL injection.
  prefs: []
  type: TYPE_NORMAL
- en: Testing for NoSQL injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have covered a reasonable ground of SQL injection attacks, but the fact is
    there is a considerable number of applications (and API endpoints) on the internet
    that need to handle unstructured data, such as documents, emails, social media
    posts, images, and audio and video files. For these use cases, relational databases
    are not the best choice since not all elements inside such databases have direct
    relationships, which would cause its management an unfair task. Carlo Strozzi
    introduced the concept of NoSQL databases in 1998 with his Strozzi NoSQL **open
    source software** (**OSS**) proposal. Since then, we’ve seen the release of many
    awesome products out there, such as MongoDB, Apache Cassandra, and Neo4j, just
    to name a few.
  prefs: []
  type: TYPE_NORMAL
- en: 'As these databases, as their type implies, are not SQL ones, they do not use
    SQL for making queries or responding to them. Hence, our SQL injection techniques
    do not work here. We need to approach them in another way. In this scenario, there
    are basically three types of attacks that we can leverage to achieve success:
    **syntax injection**, **object injection**, and **operator injection**. Let’s
    separately cover each of them.'
  prefs: []
  type: TYPE_NORMAL
- en: Syntax injection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Syntax injection stands out as the prevalent form of NoSQL injection. In this
    type of attack, the pentester embeds harmful code within user input, which the
    API then integrates into a NoSQL query. This injected code has the potential to
    disrupt the syntax of the query, evade filters, or even trigger the execution
    of unauthorized commands within the database.
  prefs: []
  type: TYPE_NORMAL
- en: The core concept of a NoSQL syntax injection attack revolves around manipulating
    user input. The pentester crafts malicious code and injects it into parameters
    that are then incorporated into the NoSQL query by the vulnerable API. One common
    scenario where NoSQL syntax injection attacks occur is in API endpoints that handle
    user authentication. For instance, an API might have a login endpoint where users
    submit their credentials for authentication. If the API uses a NoSQL database
    to store user data and does not properly sanitize user input, attackers can inject
    malicious code into the login credentials to bypass authentication checks or gain
    unauthorized access to user accounts.
  prefs: []
  type: TYPE_NORMAL
- en: In a NoSQL syntax injection attack, you as a pentester can leverage various
    techniques to evade detection and achieve your objectives. For example, you might
    use wildcard characters, regular expressions, or other syntax manipulation techniques
    to craft payloads that disrupt the query’s structure or evade input validation
    mechanisms. By carefully constructing their payloads, you can exploit vulnerabilities
    in the API endpoint and compromise the integrity and confidentiality of the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how it works. Consider an API endpoint that does user authentication
    with the help of a NoSQL database. The endpoint accepts `GET` requests in the
    following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Internally, the API endpoint translates the request into a NoSQL query like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Observe that there was absolutely no validation or filtering of the input provided
    by the requester, neither on the username nor on the password fields. We have
    a candidate for a NoSQL syntax injection attack! We could slightly change this
    request to something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We just manipulated the query to use a regular expression that represents any
    username and any password (`.` matches any character and `*` matches 0 or more
    occurrences of the preceding character). We just bypassed the authentication control
    of the endpoint…
  prefs: []
  type: TYPE_NORMAL
- en: Object injection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: NoSQL object injection attacks pose a distinct threat to APIs that interact
    with these types of databases. Unlike traditional NoSQL attacks that target the
    raw query itself, object injection attacks exploit weaknesses in how APIs handle
    user-provided data.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine an API uses a secret language (serialization) to convert user data into
    a format the NoSQL database understands. You as a pentester can exploit vulnerabilities
    in this translation process. You could craft malicious data that, when *translated*
    (deserialized) by the API, manipulates internal object structures. This can lead
    to unexpected consequences, potentially allowing you to run unauthorized code
    or access sensitive data you shouldn’t.
  prefs: []
  type: TYPE_NORMAL
- en: A common scenario involves APIs that serialize user-supplied data (such as JSON)
    before storing it in the NoSQL database. If the API doesn’t check the data carefully
    before translation, a pentester can sneak in malicious objects that exploit weaknesses
    in the deserialization process. Think of it like tricking the translator into
    saying something completely different than what you intended. This allows you
    to gain an unfair advantage within the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, we can consider an API endpoint that allows users to filter
    products based on price and category. The following JavaScript code shows a possible
    query that this endpoint could build to send to the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The `filterObject` constant receives data directly provided by the requester
    (`minPrice` and `category`). This is then used on the `db.products.find` query.
    Continuing with our example, a valid `GET` request to select products with a minimum
    price of 100 and belonging to the `furniture` category would be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'It doesn’t matter if it’s a `GET` or `POST` request. The same approach can
    be used for pretty much any verb here. How can we transform this into an object
    injection attack? Simple. We insert an initially unexpected object as part of
    the query. With this, the endpoint will grant us admin access besides checking
    the original product’s category. Look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: If the endpoint is not correctly configured to sanitize this input, admin access
    to the database could be granted, and then other stages of the attack could happen.
    The `isAdmin` object was not intended to be part of a legitimate query, but because
    I previously knew that this database would accept it as a possible parameter (of
    course, after doing my enumeration/fingerprinting tasks), I’m a bit safer to assume
    it will work. The success of a NoSQL object injection attack largely depends on
    how the API handles user-supplied objects and incorporates them into its operations.
    Nevertheless, the fundamental concept of altering object structure to achieve
    unauthorized access or tamper with data holds true across different NoSQL database
    platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Operator injection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At this stage, you may have already deduced we are talking about inserting NoSQL
    operators as part of this sort of attack. Yeah – I was quite a Captain Obvious
    here, but consider this an attempt to give you some relaxation after this massive
    reading. Fortunately, you already have access to a small yet useful table with
    some operators that could be leveraged here.
  prefs: []
  type: TYPE_NORMAL
- en: NoSQL databases offer a tempting combination of power and flexibility, but they
    also introduce new security challenges. NoSQL operator injection attacks lurk
    in the shadows, waiting to exploit APIs that interact with these databases. These
    attacks target vulnerabilities in APIs that build queries “on the fly” based on
    user input. Devious attackers can then inject specially crafted data to manipulate
    how the database interprets the query. This attack has some similarities with
    syntax injection; however, this one is not breaking the initially predicted syntax
    of a query but just twisting it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine an API that allows users to search for products based on various filters,
    such as price or category, as we’ve previously seen. The API might construct a
    NoSQL query that dynamically incorporates user-supplied values. Here’s the problem:
    if the API doesn’t carefully check this user input, you can sneak in malicious
    operators. These operators, which are normally used for legitimate filtering,
    can be twisted to alter the query’s logic entirely. Think of it like someone manipulating
    the search bar on a library website to return unexpected results. Sounds familiar?'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s keep with our example of a website that provides products that in turn
    are organized into categories. An endpoint to show all products belonging to the
    `tools` category could be something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This translates into the following NoSQL query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Simple, yet powerful. Now, suppose the user I’m using to interact with this
    endpoint does not have access to see products belonging to other categories, but
    the endpoint is not fully applying this control. So, how could I bypass it? Take
    a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The `$ne` part corresponds to a NoSQL operator that means “not equal.” So,
    we are asking the API endpoint to show all products whose categories are not `tools`.
    Fantastic, isn’t it?! I’ve provided a list of MongoDB operators for your convenience.
    Observe not all NoSQL databases follow the same rule, so you can either try to
    fingerprint the backend database or combine operators from different database
    engines:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operator** | **Meaning** |'
  prefs: []
  type: TYPE_TB
- en: '| `$``eq` | Matches values that are equal to a specified value |'
  prefs: []
  type: TYPE_TB
- en: '| `$``ne` | Matches all values that are not equal to a specified value |'
  prefs: []
  type: TYPE_TB
- en: '| `$``gt` | Matches values that are greater than a specified value |'
  prefs: []
  type: TYPE_TB
- en: '| `$``gte` | Matches values that are greater than or equal to a specified value
    |'
  prefs: []
  type: TYPE_TB
- en: '| `$``in` | Matches any of the values specified in an array |'
  prefs: []
  type: TYPE_TB
- en: '| `$``lt` | Matches values that are less than a specified value |'
  prefs: []
  type: TYPE_TB
- en: '| `$``lte` | Matches values that are less than or equal to a specified value
    |'
  prefs: []
  type: TYPE_TB
- en: '| `$``nin` | Matches none of the values specified in an array |'
  prefs: []
  type: TYPE_TB
- en: 'Table 5.1 – MongoDB comparison operators (Source: MongoDB official documentation)'
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s take a look at this in practice with an exercise.
  prefs: []
  type: TYPE_NORMAL
- en: Exploiting NoSQL injection on crAPI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It’s time to get back to our old friend, crAPI. We well know it exposes a considerable
    number of endpoints, so let’s verify if there’s one we can pick to exercise this.
    Start your crAPI instance. Let’s also use our other friend, Burp Suite, to help
    us with this quest. Launch Burp Suite and start a new project with the defaults.
    You will need to use Burp’s browser in your lab since all services are listening
    locally (`localhost`). Access crAPI. If you still don’t have an account, create
    one by following the straightforward process. After logging in, go to the **Shop**
    area, as shown in *Figure 5**.5*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.5 – crAPI’s Shop area](img/B19657_05_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.5 – crAPI’s Shop area
  prefs: []
  type: TYPE_NORMAL
- en: 'Observe our initial balance: $100\. Our objective here is to buy an item for
    less than what it really costs or increase our balance. If we have a coupon, we
    can add its code using the corresponding button. The point is, we don’t have any
    code – yet… Click on the **Add Coupons** button and type anything. You will receive
    an error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.6 – Invalid coupon code](img/B19657_05_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.6 – Invalid coupon code
  prefs: []
  type: TYPE_NORMAL
- en: 'This part of crAPI uses a NoSQL database (MongoDB, to be more precise) to store
    the coupons. Now, go to Burp Suite to check the HTTP connection history. The last
    item will show you which endpoint crAPI is using to check this code. You will
    realize it is `/community/api/v2/coupon/validate-coupon`. We also confirm the
    endpoint returns a 500 error code with an empty JSON structure. Now, let’s use
    another resource of Burp to help us discover crAPI’s coupons. *Figure 5**.7* shows
    an example of sending a request to the coupon validation endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.7 – crAPI’s coupon validation endpoint](img/B19657_05_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.7 – crAPI’s coupon validation endpoint
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll do something similar to what we did with the vAPI Python application
    in the SQL injection section. Right-click on this coupon validation request (still
    on the **HTTP history** tab) and select **Send to Intruder**, then move to this
    section of the tool. The first subsection you’ll see is **Positions**. Observe
    the request structure is a simple JSON structure with a single key and value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: We want to fuzz the `"blabla"` part with lots of junk that will be pulled from
    the payload list. Select this whole `"blabla"` text, *including the double quotes*,
    and click on the `§`. Set **Attack type** as **Sniper**. Now, move to the **Payloads**
    subsection. Set **Payload type** as **Simple** and click on the **Load…** button
    on the block that says **Payload settings [Simple list]**. You can load multiple
    files at once. Do this if you have more than one. Deselect the last checkmark
    that says **URL encode these characters**. This will avoid unnecessary encoding
    when submitting the payloads to the target. Finally, click on **Start Attack**.
    Remember – Burp Community may take more time as the Intruder feature has intentionally
    received some delays between sent payloads.
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, switch to the `200 code`, like the one on the following screenshot,
    which will disclose a coupon code to you. The `TRAC075` code means $75:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 5.8 – crAPI disclosing a coupon code after \uFEFFa NoSQL injection\
    \ attack](img/B19657_05_08.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 5.8 – crAPI disclosing a coupon code after a NoSQL injection attack
  prefs: []
  type: TYPE_NORMAL
- en: Pick this coupon and add it to the corresponding area of the website. It will
    be accepted, and your balance will increase, as shown in *Figure 5**.9*. Lucky,
    lucky!
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.9 – Valid coupon code added](img/B19657_05_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.9 – Valid coupon code added
  prefs: []
  type: TYPE_NORMAL
- en: You can see your balance has increased by $75, as shown in *Figure* *5**.10*.
    Rich!
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.10 – Balance increase after the coupon code was added](img/B19657_05_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.10 – Balance increase after the coupon code was added
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You will never have to spend more for a single product on crAPI’s
    shop. Sorry – just another terrible icebreaker. The list of payloads I used for
    this attack can be easily found in the references that I put in the *Further reading*
    section. Do not forget to check them as there is a vast amount of material that
    you can use in your pentesting endeavors. Next, we will learn about user input
    validation and sanitization.
  prefs: []
  type: TYPE_NORMAL
- en: Validating and sanitizing user input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this stage, I’m sure you are more than aware that the core success of injection
    attacks lies in the reduced (or lack of) sanitizing of what a user provides to
    an API endpoint or web application. When building secure APIs, validating and
    sanitizing user input is paramount for thwarting attacks. As a penetration tester,
    understanding these techniques is crucial for identifying vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: When users sign up, input validation acts as a vigilant gatekeeper, guaranteeing
    the information they provide adheres to specific guidelines and is suitable for
    processing. It meticulously examines the format, length, and content of crucial
    fields such as usernames, email addresses, and passwords. Open source powerhouses
    such as OWASP **Enterprise Security API** (**ESAPI**) offer dependable validation
    tools for diverse user input types. Imagine wielding ESAPI’s validation functions
    to ensure usernames are composed solely of letters and numbers, adhering to a
    predefined length limit. Similarly, you can verify email addresses conform to
    a legitimate format and that passwords satisfy complexity mandates, such as minimum
    length and the inclusion of special characters. This robust approach safeguards
    a system from potentially harmful or nonsensical data.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are at least five points that deserve attention from any API developer.
    You as a pentester should obviously check the absence of any of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@` and `.`), and usernames free of special characters that might disrupt the
    system. However, these safeguards can sometimes be flawed. Tools such as OWASP
    ZAP and Burp Suite empower pentesters to become stealthy middlemen, intercepting
    and dissecting communication (HTTP requests) between the user and the API.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sanitizing query parameters for search queries**: APIs that empower users
    to unearth products by name or category require careful attention to sanitizing
    query parameters. This crucial step involves purging or transforming special characters
    that could potentially be exploited to manipulate the database query lurking beneath
    the surface. Tools such as SQLMap and NoSQLMap act as digital probes to reveal
    vulnerabilities in these queries. These tools can be employed to test for weaknesses
    susceptible to SQL and NoSQL injection attacks. By implementing robust input sanitization,
    such attacks can become ineffective and safeguard the integrity of the underlying
    database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Validating file uploads**: Imagine an API that welcomes user-uploaded files,
    perhaps images or essential documents. However, lurking within this seemingly
    harmless functionality lies the potential for malicious activity. To fortify this
    API, robust input validation is paramount. It should act as a vigilant inspector,
    scrutinizing file types to ensure only permitted formats (such as images) are
    allowed. Additionally, size limitations must be enforced to prevent DoS attacks
    through massive file uploads. Malware detection mechanisms should be employed
    to identify and reject any malicious files that might attempt to infiltrate the
    system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Furthermore, filenames themselves require sanitization. This crucial step thwarts
    “directory traversal attacks” – a technique where pentesters exploit vulnerabilities
    in file naming conventions to access unauthorized parts of the system. Tools such
    as OWASP ZAP and Nikto act as invaluable allies for security professionals, enabling
    them to simulate attacks and pinpoint weaknesses in the file upload functionality,
    especially those arising from inadequate input validation.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`validator.js` for JavaScript or Django’s built-in form validation for Python
    offer invaluable assistance in implementing robust input validation for numeric
    input. These tools empower developers to establish clear guidelines for acceptable
    numerical ranges, preventing **out-of-bounds** (**OOB**) errors and maintaining
    data integrity within the API.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sanitizing HTML input to prevent cross-site scripting (XSS) attacks**: Certain
    APIs allow users to contribute HTML content, such as comments or product descriptions.
    This seemingly innocuous functionality can be weaponized by attackers if proper
    safeguards are not in place. Malicious actors might attempt to inject malevolent
    scripts (XSS attacks) within the HTML, potentially hijacking user sessions, stealing
    data, or redirecting users to malicious websites. To thwart these attacks, sanitization
    is a critical defense mechanism.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This process involves either transforming (escaping) or entirely removing potentially
    harmful HTML tags and attributes, rendering them inert and incapable of executing
    malicious code. Fortunately, open source libraries such as DOMPurify for JavaScript
    and Bleach for Python come to the rescue. These tools empower developers to effectively
    sanitize HTML input, neutralizing XSS vulnerabilities and safeguarding the integrity
    of the API and its users.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Let’s take a closer look at each of these use cases.
  prefs: []
  type: TYPE_NORMAL
- en: Input validation for user registration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: During user registration, input validation acts as a vigilant security checkpoint,
    guaranteeing the information users provide adheres to predefined standards and
    is suitable for processing without compromising system security. This meticulous
    process involves examining the format, length, and content of crucial fields such
    as usernames, email addresses, and passwords. Powerful tools such as OWASP ESAPI
    offer an arsenal of validation functions. Think of them as skilled guards, each
    with a specific expertise. One guard ensures usernames are built solely with letters
    and numbers, adhering to a length restriction. Another verifies email addresses
    following a legitimate format, while a third enforces password complexity, demanding
    a minimum length and the inclusion of special characters. By implementing these
    rigorous checks, you effectively filter out nonsensical or potentially malicious
    data that could be used by attackers to exploit vulnerabilities. Thorough input
    validation is the cornerstone of secure user registration. It builds a fortified
    wall around your system, safeguarding it from a multitude of security threats
    and ensuring the smooth operation of your kingdom (API and application).
  prefs: []
  type: TYPE_NORMAL
- en: 'Even nowadays, Java is a prominent programming language, and it’s not difficult
    to find web applications and API endpoints built upon it. Let’s consider the following
    excerpt of Java code that shows an example of OWASP ESAPI in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In this code, two classes, `ESAPI` itself and `ValidationException` from the
    `errors` package, are leveraged. Observe that a username is only considered valid
    when the `ESAPI.validator()` function states so.
  prefs: []
  type: TYPE_NORMAL
- en: Sanitizing query parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sanitizing query parameters is a critical defense mechanism for APIs that interact
    with databases. Without proper sanitization, attackers can exploit vulnerabilities
    known as SQL injection to manipulate database queries. These malicious actors
    might use tools such as SQLMap to automate the process, sending a barrage of crafted
    strings (payloads) through query parameters. These payloads can potentially trick
    the database into executing unintended actions, such as stealing sensitive data
    or disrupting operations.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, we have powerful tools at our disposal to combat this threat. Input
    sanitization techniques, such as parameterized queries, act as a shield against
    such attacks. Parameterized queries separate the data (user input) from the actual
    SQL statement, preventing malicious code from being injected. Frameworks such
    as Flask in Python offer built-in support for parameterized queries. By embracing
    this approach, you can confidently execute SQL queries without exposing your application
    to the dangers of SQL injection, safeguarding the integrity of your database and
    user information.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code portion contains a Flask application interacting with an
    SQLite3 database. Instead of directly passing the input to the database, it first
    hardcodes the table name into the SQL statement and applies the `?` symbol:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `q` query parameter is sanitized by using parameterized
    queries (`?`), ensuring that any malicious input provided by the user is properly
    escaped and doesn’t interfere with the SQL query execution.
  prefs: []
  type: TYPE_NORMAL
- en: Validating file uploads
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: File uploads offer a convenient functionality for users, but they can also be
    a gateway for attackers. Malicious actors might attempt to upload files disguised
    as harmless images or documents, but in reality, these files could be malicious
    scripts or executables capable of compromising the entire server. To prevent such
    attacks, robust input validation is essential. This process meticulously examines
    uploaded files, ensuring they adhere to predefined security standards.
  prefs: []
  type: TYPE_NORMAL
- en: 'Validation focuses on two key aspects: file type and size. Only authorized
    file types, such as images or documents, should be allowed. Open source libraries
    such as **Apache Commons FileUpload** for Java come to the rescue, offering a
    suite of tools for validating uploads. These tools can check file extensions against
    a whitelist, verify content types to ensure they match the expected format, and
    enforce size limitations to prevent DoS attacks through massive uploads. By implementing
    these safeguards, you can effectively disarm these “digital bombs” disguised as
    file uploads, safeguarding your server and user data.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following Java code exemplifies how files sent as input to an API endpoint
    can be correctly validated before being effectively processed by the backend,
    including an eventual database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In this code snippet, Apache Commons FileUpload is used to parse the file upload
    request, and then validation checks can be performed on the filename, content
    type, and size to ensure that only safe files are accepted for upload.
  prefs: []
  type: TYPE_NORMAL
- en: Input validation for numeric input
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When dealing with numeric input from users, ensuring the data adheres to the
    expected format and remains within acceptable boundaries is critical. Unchecked
    numeric input can introduce vulnerabilities such as buffer overflows or arithmetic
    overflows, potentially leading to unexpected program behavior, crashes, or even
    system compromise.
  prefs: []
  type: TYPE_NORMAL
- en: Open source libraries such as Apache Commons Validator for Java come to the
    rescue by offering a powerful arsenal for validating numeric input. These libraries
    provide functions specifically designed to handle different numeric data types
    – integers, floats, and more. Developers can leverage these functions to define
    clear constraints, such as minimum and maximum values, for acceptable user input.
    By implementing such validation, we can effectively “tame” numeric input, preventing
    errors and safeguarding the API endpoint from vulnerabilities that could be exploited
    by malicious actors. This ensures the endpoint processes data as intended and
    maintains its overall stability and security.
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at how Apache Commons Validator for Java can be applied to sanitize user
    input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: In this code snippet, Apache Commons Validator’s `FloatValidator` class is used
    to validate a float input against the `US` locale, ensuring that the input string
    represents a valid floating-point number.
  prefs: []
  type: TYPE_NORMAL
- en: Sanitizing HTML input to prevent XSS attacks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Imagine a scenario where untamed user input is directly inserted into a web
    page. This seemingly harmless practice creates a vulnerability known as XSS. Malicious
    actors can exploit XSS to plant hidden “*bombs*” within their input – malicious
    scripts disguised as regular text. Once the page renders, these scripts can detonate,
    stealing sensitive user information (such as session cookies) or performing unauthorized
    actions on the user’s behalf.
  prefs: []
  type: TYPE_NORMAL
- en: To prevent such attacks, we rely on a technique called HTML escaping. This process
    involves encoding special characters within user input before displaying them
    on the web page. By encoding these characters, we effectively disarm the bombs
    and render them harmless. Open source libraries such as **OWASP Java Encoder**
    provide valuable utilities for HTML escaping. By leveraging these tools, developers
    can effectively sanitize user input, closing the door on XSS vulnerabilities and
    safeguarding user data and the API endpoint functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code portion shows an example of how HTML input can be sanitized
    with the use of OWASP Java Encoder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: In this example, OWASP Java Encode’s `Encode.forHtml` method is used to sanitize
    HTML input by encoding special characters such as `<`, `>`, and `&`, thus preventing
    them from being interpreted as HTML tags or script elements by the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we talked about injection attacks for both worlds, SQL and
    NoSQL, how they can be perpetrated, and the types of damage they can cause on
    an end system serving an API endpoint. We learned the different types of injection
    attacks, and we did two exercises, one with crAPI and another with a vulnerable
    Python application, each one showing how both types of databases can be hit by
    injecting commands or spurious/unpredicted data. We finished the chapter with
    a discussion about validating and sanitizing user input, which intends to either
    remove or at least reduce the success ratio of injection attacks. Code excerpts
    were also provided so that you could have a taste of how this works on real applications
    out there.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll talk about error handling and exception testing.
    This content is as important as anything else since we’ll see that a badly treated
    exception or error can disclose valuable information about the API or the application
    behind it.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Equifax data breach: [https://consumer.ftc.gov/consumer-alerts/2019/07/equifax-data-breach-settlement-what-you-should-know](https://consumer.ftc.gov/consumer-alerts/2019/07/equifax-data-breach-settlement-what-you-should-know)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Firebase NoSQL vulnerability: [https://blog.securitybreached.org/2020/02/04/exploiting-insecure-firebase-database-bugbounty/](https://blog.securitybreached.org/2020/02/04/exploiting-insecure-firebase-database-bugbounty/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Common Vulnerabilities and Exposures** (**CVE**) reporting the Apache Structs
    vulnerability: [https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-11776](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-11776)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Atlassian XXE vulnerability: [https://confluence.atlassian.com/security/cve-2019-13990-xxe-xml-external-entity-injection-vulnerability-in-jira-service-management-data-center-and-jira-service-management-server-1295385959.html](https://confluence.atlassian.com/security/cve-2019-13990-xxe-xml-external-entity-injection-vulnerability-in-jira-service-management-data-center-and-jira-service-management-server-1295385959.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'FortiSIEM *CVE-2023-36553* MITRE record: [https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-36553](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-36553)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'FortiSIEM *CVE-2023-36553* **National Institute of Standards and Technology**
    (**NIST**) notice: [https://nvd.nist.gov/vuln/detail/CVE-2023-36553](https://nvd.nist.gov/vuln/detail/CVE-2023-36553)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Palo Alto OS command injection vulnerability – [https://security.paloaltonetworks.com/CVE-2023-6792](https://security.paloaltonetworks.com/CVE-2023-6792)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*BleepingComputer* – *Hackers steal data of 2 million in SQL injection, XSS*
    *attacks*: [https://www.bleepingcomputer.com/news/security/hackers-steal-data-of-2-million-in-sql-injection-xss-attacks/](https://www.bleepingcomputer.com/news/security/hackers-steal-data-of-2-million-in-sql-injection-xss-attacks/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*PortSwigger* – *Car companies massively exposed to web* *vulnerabilities*:
    [https://portswigger.net/daily-swig/car-companies-massively-exposed-to-web-vulnerabilities](https://portswigger.net/daily-swig/car-companies-massively-exposed-to-web-vulnerabilities)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The Hacker News* – *New Hacker Group ‘GambleForce’ Targeting APAC Firms Using
    SQL Injection* *Attacks*: [https://thehackernews.com/2023/12/new-hacker-group-gambleforce-tageting.html](https://thehackernews.com/2023/12/new-hacker-group-gambleforce-tageting.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*PayloadsAllTheThings* (massive list of injection payloads): [https://github.com/swisskyrepo/PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'SQL injection payload list: [https://github.com/payloadbox/sql-injection-payload-list](https://github.com/payloadbox/sql-injection-payload-list)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All-in-one fuzzing wordlist for SQL injection: [https://github.com/PenTestical/sqli](https://github.com/PenTestical/sqli)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'vAPI Python application: [https://github.com/michealkeines/Vulnerable-API](https://github.com/michealkeines/Vulnerable-API)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*An Exploration of Finding Aid Technologies and NoSQL Databases* – scientific
    article with an introduction to NoSQL databases: [https://ojs.library.ubc.ca/index.php/seealso/article/view/186333](https://ojs.library.ubc.ca/index.php/seealso/article/view/186333)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'MongoDB query operators: [https://www.mongodb.com/docs/manual/reference/operator/query/](https://www.mongodb.com/docs/manual/reference/operator/query/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'OWASP ESAPI, a library that provides secure methods for sanitizing user input:
    [https://owasp.org/www-project-enterprise-security-api/](https://owasp.org/www-project-enterprise-security-api/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'SQLMap, a tool to automate pentesting on relational databases: [https://sqlmap.org/](https://sqlmap.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'NoSQLMap – The SQLMap cousin, dedicated to automating pentesting and auditing
    on non-relational databases: [https://github.com/codingo/NoSQLMap](https://github.com/codingo/NoSQLMap)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Nikto, a useful utility to discover vulnerabilities in web servers, including
    outdated software and misconfigured interfaces: [https://github.com/sullo/nikto](https://github.com/sullo/nikto)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`validator.js` for JavaScript, which validates and sanitizes string inputs:
    [https://www.npmjs.com/package/validator](https://www.npmjs.com/package/validator)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'DOMPurify for JavaScript, a tool for sanitizing **Document Object Model** (**DOM**)
    HTML forms: [https://github.com/cure53/DOMPurify](https://github.com/cure53/DOMPurify)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Apache Commons FileUpload Validator for Java, a library to sanitize files before
    considering them valid inputs: [https://commons.apache.org/proper/commons-fileupload/](https://commons.apache.org/proper/commons-fileupload/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'OWASP Java Encoder, a class that can be leveraged to encode HTML input and
    reduce chances of XSS attacks: [https://owasp.org/www-project-java-encoder/](https://owasp.org/www-project-java-encoder/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'OWASP ESAPI: [https://owasp.org/www-project-enterprise-security-api/](https://owasp.org/www-project-enterprise-security-api/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
