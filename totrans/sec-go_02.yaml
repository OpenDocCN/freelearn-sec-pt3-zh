- en: The Go Programming Language
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before diving into the more complex examples of using Go for security, it is
    important to have a solid foundation. This chapter provides an overview of the
    Go programming language so that you have the knowledge necessary to follow the
    subsequent examples.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter is not an exhaustive treatise of the Go programming language, but
    will give you a solid overview of the major features. The goal of this chapter
    is to provide you with the information you need to understand and follow the source
    code if you have never used Go before. If you are already familiar with Go, this
    chapter should be a quick and easy review of things you already know, but perhaps
    you will learn a new piece of information.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter specifically covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The Go language specification
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Go playground
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A tour of Go
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keywords
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Notes about source code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Control structures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Goroutines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting help and documentation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Go language specification
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The entire Go language specification can be found online at [https://golang.org/ref/spec](https://golang.org/ref/spec).
    Much of the information in this chapter comes from the specification, as this
    is the one true documentation of the language. The rest of the information here
    is short examples, tips, best practices, and other things that I have learned
    during my time with Go.
  prefs: []
  type: TYPE_NORMAL
- en: The Go playground
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Go playground is a website where you can write and execute Go code without
    having to install anything. In the playground, [https://play.golang.org](https://play.golang.org),
    you can test pieces of code to explore the language and fiddle with things to
    understand how the language works. It also allows you to share your snippet by
    creating a unique URL that stores your snippet. Sharing code through the playground
    can be much more helpful than a plaintext snippet, since it allows the reader
    to actually execute the code and tinker with the source if they have any questions
    about how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d5514c8a-7253-4641-8b61-3e02ebcac15e.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding screenshot shows a simple program being run in the playground.
    There are buttons at the top to run, format, add import statements, and share
    the code with others.
  prefs: []
  type: TYPE_NORMAL
- en: A tour of Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another resource provided by the Go team is *A Tour of Go*. This website, [https://tour.golang.org](https://tour.golang.org),
    is built on top of the playground mentioned in the previous section. The tour
    was my first introduction to the language, and when I completed it, I felt well-equipped
    to start tackling projects in Go. It walks you through the language step by step
    along with working code examples so that you can run and modify the code to get
    familiar with the language. It is a practical way to introduce a newcomer to Go.
    If you have never used Go at all, I encourage you to check it out.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/155646d8-315b-4b13-aa31-c7be08feb713.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding screenshot shows the first page of the tour. On the right-hand
    side, you will have a small embedded playground with the code sample relevant
    to the short lesson shown on the left-hand side. Each lesson comes with a short
    code example that you can run and tinker with.
  prefs: []
  type: TYPE_NORMAL
- en: Keywords
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To emphasize how simple Go is, here is a breakdown of all its 25 keywords. You
    probably already know most of them if you are familiar with other programming
    languages. The keywords are grouped together to examine them according to their
    use.
  prefs: []
  type: TYPE_NORMAL
- en: '**Data types**:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `var` | This defines a new variable |'
  prefs: []
  type: TYPE_TB
- en: '| `const` | This defines a constant value that does not change |'
  prefs: []
  type: TYPE_TB
- en: '| `type` | This defines a new data type |'
  prefs: []
  type: TYPE_TB
- en: '| `struct` | This defines a new structured data type that contains multiple
    variables |'
  prefs: []
  type: TYPE_TB
- en: '| `map` | This defines a new map or hash variable |'
  prefs: []
  type: TYPE_TB
- en: '| `interface` | This defines a new interface |'
  prefs: []
  type: TYPE_TB
- en: '**Functions**:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `func` | This defines a new function |'
  prefs: []
  type: TYPE_TB
- en: '| `return` | This exits a function, optionally returning values |'
  prefs: []
  type: TYPE_TB
- en: '**Packages**:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `import`  | This imports an external package in the current package |'
  prefs: []
  type: TYPE_TB
- en: '| `package` | This specifies what package a file belongs to |'
  prefs: []
  type: TYPE_TB
- en: '**Program flow**:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `if` | This is used for branch execution based on a condition that is true
    |'
  prefs: []
  type: TYPE_TB
- en: '| `else` | This is used for a branch if a condition is not true |'
  prefs: []
  type: TYPE_TB
- en: '| `goto` | This is used to jump directly to a label; it is rarely used and
    not encouraged |'
  prefs: []
  type: TYPE_TB
- en: '**Switch statements**:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `switch` | This is used to branch based off of a condition |'
  prefs: []
  type: TYPE_TB
- en: '| `case` | This defines the condition for the `switch` statement |'
  prefs: []
  type: TYPE_TB
- en: '| `default` | This defines default execution when no case is matched |'
  prefs: []
  type: TYPE_TB
- en: '| `fallthrough` | This is used to continue executing the next case |'
  prefs: []
  type: TYPE_TB
- en: '**Iteration**:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `for` | The `for` loop can be used like in C, where you provide three expressions:
    the initializer, the condition, and the incrementer. In Go, there is no `while`
    loop and the `for` keyword takes on the role of both `for` and `while`. A `for`
    loop can be used just like a `while` loop if one expression, the condition, is
    passed. |'
  prefs: []
  type: TYPE_TB
- en: '| `range` | The `range` keyword is used with a `for` loop to iterate over a
    map or slice. |'
  prefs: []
  type: TYPE_TB
- en: '| `continue` | The `continue` keyword will skip any execution left in the current
    loop and jump directly to the next iteration. |'
  prefs: []
  type: TYPE_TB
- en: '| `break` | The `break` keyword will immediately exit the `for` loop completely,
    skipping any remaining iterations. |'
  prefs: []
  type: TYPE_TB
- en: '**Concurrency**:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `go` | Goroutines are lightweight threads built in to the language. You simply
    put the `go` keyword in front of a call to a function and Go will execute that
    function call in a separate thread. |'
  prefs: []
  type: TYPE_TB
- en: '| `chan` | To communicate between threads, channels are used. Channels are
    used to send and receive specific data types. They are blocking by default. |'
  prefs: []
  type: TYPE_TB
- en: '| `select` | The `select` statements allow channels to be used in a nonblocking
    fashion. |'
  prefs: []
  type: TYPE_TB
- en: '**Convenience**:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `defer` | The `defer` keyword is a relatively unique keyword that I have
    not previously encountered in other languages. It allows you to specify a function
    to be called later when the surrounding function returns. It is useful when you
    want to ensure some type of cleanup action whenever the current function ends,
    but you are not sure when or where it might return. A common use case is to defer
    a file closure. |'
  prefs: []
  type: TYPE_TB
- en: Notes about source code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Go source code files should have the `.go` extension. The source code of Go
    files is encoded in UTF-8 Unicode. This means that you can use any Unicode characters
    in your code, like hardcoding Japanese characters in a string.
  prefs: []
  type: TYPE_NORMAL
- en: Semicolons are optional at the end of a line and typically omitted. Semicolons
    are only required when separating multiple statements or expressions on a single
    line.
  prefs: []
  type: TYPE_NORMAL
- en: Go does have a code formatting standard which can easily be adhered to by running
    `go fmt` on source code files. The code formatting should be followed, but it
    is not strictly enforced by the compiler the way Python requires exact formatting
    to execute properly.
  prefs: []
  type: TYPE_NORMAL
- en: Comments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Comments follow a C++ style allowing the double slash and the slash-asterisk
    wrapped style:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The built-in data types are named intuitively enough. Go comes with a set of
    integer and unsigned integer types with varying bit lengths. There are also floating
    point numbers, Booleans, and strings, which should come as no surprise.
  prefs: []
  type: TYPE_NORMAL
- en: There are a few types like runes that are not common in other languages. This
    section covers all of the different types.
  prefs: []
  type: TYPE_NORMAL
- en: Boolean
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Boolean type represents a true or false value. Some languages don''t provide
    a `bool` type, and you have to use an integer or define your own enumeration,
    but Go conveniently comes with a predeclared `bool` type. The `true` and `false`
    constants are also predefined and used in all lowercase. Here is an example of
    creating a Boolean:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `bool` type is not unique to Go by any means, but one interesting piece
    of trivia about the Boolean type is that it's the only type named after a person.
    George Boole lived from 1815 to 1864 and wrote *The Laws of Thought*, where he
    described Boolean algebra, which is what all digital logic is based upon. The
    `bool` type is very simple in Go, but the history behind the name is very rich.
  prefs: []
  type: TYPE_NORMAL
- en: Numeric
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The primary numeric data types are integers and floating point numbers. Go also
    offers a complex number type, a byte type, and a rune. Here are the numeric data
    types available in Go.
  prefs: []
  type: TYPE_NORMAL
- en: Generic numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: These generic types can be used when you don't particularly care about whether
    a number is 32- or 64-bits. The largest available size will automatically be used,
    but will be compatible with 32- and 64-bit processors.
  prefs: []
  type: TYPE_NORMAL
- en: '`uint`: This is an unsigned integer of either 32 or 64 bits'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int`: This is a signed integer with the same size as `uint`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`uintptr`: This is an unsigned integer to store a pointer value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specific numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: These numeric types specify the bit length and whether it has a sign bit to
    determine positive or negative values. The bit length will determine the maximum
    range. Signed integers have the range reduced by one bit because the last bit
    is reserved for the sign.
  prefs: []
  type: TYPE_NORMAL
- en: Unsigned integers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using `uint` without a number generally chooses the largest size for your system,
    typically 64 bits. You can also specify one of the four specific `uint` sizes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`uint8`: Unsigned 8-bit integer (0 to 255)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`uint16`: Unsigned 16-bit integer (0 to 65535)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`uint32` : Unsigned 32-bit integer (0 to 4294967295)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`uint64`: Unsigned 64-bit integer (0 to 18446744073709551615)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Signed integers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Like unsigned integers, you can use `int` by itself to choose the best default
    size, or specify one of these four specific `int` sizes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`int8`: 8-bit integer (-128 to 127)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int16`: 16-bit integer (-32768 to 32767)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int32`: 32-bit integer (-2147483648 to 2147483647)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int64`: 64-bit integer (-9223372036854775808 to 9223372036854775807)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Floating point numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The floating point type does not have a generic type, and must be one of these
    two options:'
  prefs: []
  type: TYPE_NORMAL
- en: '`float32`: IEEE-754 32-bit floating-point number'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`float64`: IEEE-754 64-bit floating-point number'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other numeric types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Go also provides a complex number for advanced mathematical applications, and
    a few aliases for conveniences:'
  prefs: []
  type: TYPE_NORMAL
- en: '`complex64`: Complex number with `float32` real and imaginary parts'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`complex128`: Complex number with `float64` real and imaginary parts'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`byte`: Alias for `uint8`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rune`: Alias for `int32`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can define numbers in the decimal, octal, or hexadecimal format. Decimal
    or base-ten numbers need no prefix. Octal or base-eight numbers should be prefixed
    with a zero. Hexadecimal or base-sixteen numbers should be prefixed with a zero
    and an x.
  prefs: []
  type: TYPE_NORMAL
- en: You can read more about the octal numeral system at [https://en.wikipedia.org/wiki/Octal](https://en.wikipedia.org/wiki/Octal),
    decimal at [https://en.wikipedia.org/wiki/Decimal](https://en.wikipedia.org/wiki/Decimal),
    and hexadecimal at [https://en.wikipedia.org/wiki/Hexadecimal](https://en.wikipedia.org/wiki/Hexadecimal).
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that numbers are stored as integers, and there are no differences between
    them except for how they are formatted in the source code for the human. Octal
    and hexadecimal can be useful when working with binary data. Here is a short example
    of how to define integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: String
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Go comes with a `string` type as well as a `strings` package with a suite of
    useful functions such as `Contains()`, `Join()`, `Replace()`, `Split()`, `Trim()`,
    and `ToUpper()`. There is additionally a `strconv` package dedicated to converting
    various data types to and from strings. You can read more about the `strings`
    package at [https://golang.org/pkg/strings/](https://golang.org/pkg/strings/),
    and the `strconv` package at [https://golang.org/pkg/strconv/](https://golang.org/pkg/strconv/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Double quotes are used for strings. Single quotes are used only for an individual
    character or runes, not strings. Strings can be defined using the long form or
    short form with the declare-and-assign operator. You can also use the `` ` `` (backticks) symbol
    to encapsulate strings that span multiple lines. Here is a short example of string
    usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Array
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Arrays are made up of sequenced elements of a specific type. An array can be
    created for any data type. The length of an array cannot be changed and must be
    specified at the time of declaration. Arrays are seldom used directly, but are
    used mostly through the slice type covered in the next section. Arrays are always
    one-dimensional, but you can create an array of arrays to create multidimensional
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create an array of 128 bytes, this syntax can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Individual elements of an array can be accessed by its 0-based numeric index.
    For example, to get the fifth element from the byte array, the syntax is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Slice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Slices use arrays as the underlying data type. The main advantage is that slices
    can be resized, unlike arrays. Think of slices as a viewing window in to an underlying
    array. The **capacity** refers to the size of the underlying array, and the maximum
    possible length of a slice. The **length** of a slice refers to its current length
    which can be resized.
  prefs: []
  type: TYPE_NORMAL
- en: 'Slices are created using the `make()` function. The `make()` function will
    create a slice of a certain type with a certain length and capacity. The `make()`
    function can be used two ways when creating a slice. With only two parameters,
    the length and capacity are the same. With three parameters, you can specify a
    maximum capacity larger than the length. Here are two of the `make()` function
    declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'A nil slice can be created with a capacity and length of 0\. There is no underlying
    array associated with a nil slice. Here is a short example program demonstrating
    how to create and inspect a slice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: You can also append to a slice using the built-in `append()` function.
  prefs: []
  type: TYPE_NORMAL
- en: Append can add one or more elements at a time. The underlying array will be
    resized if necessary. This means that the maximum capacity of a slice can be increased.
    When a slice increases its underlying capacity, creating a larger underlying array,
    it will create the array with some extra space. This means that if you surpass
    a slice's capacity by one, it might increase the array size by four. This is done
    so that the underlying array has room to grow to reduce the number of times the
    underlying array has to be resized, which may require moving memory around to
    accommodate the larger array. It could be expensive to resize an array every time
    just to add a single element. The slice mechanics will automatically determine
    the best size for resizing.
  prefs: []
  type: TYPE_NORMAL
- en: 'This code sample provides various examples of working with slices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Struct
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Go, a struct or data structure is a collection of variables. The variables
    can be of different types. We will look at an example of creating a custom struct
    type.
  prefs: []
  type: TYPE_NORMAL
- en: Go uses case-based scoping to declare a variable either `public` or `private`.
    Variables and methods that are capitalized are exported and accessible from other
    packages. Lowercase values are private and only accessible within the same package.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example creates a simple struct named `Person` and one named
    `Hacker`. The `Hacker` type has a `Person` type embedded within it. An instance
    of each type is then created and the information about them is printed to standard
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: You can create *private* variables by starting their name with a lowercase letter.
    I use quotation marks because private variables work slightly different than in
    other languages. The privacy works at the package level and not at the *class*
    or type level.
  prefs: []
  type: TYPE_NORMAL
- en: Pointer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Go provides a pointer type that stores the memory location where data of a specific
    type is stored. Pointers can be used to pass a struct to a function by reference
    without creating a copy. This also allows a function to modify an object in-place.
  prefs: []
  type: TYPE_NORMAL
- en: There is no pointer arithmetic allowed in Go. Pointers are considered *safe*
    because Go does not even define the addition operator on the pointer type. They
    can only be used to reference an existing object.
  prefs: []
  type: TYPE_NORMAL
- en: 'This example demonstrates basic pointer usage. It first creates an integer,
    and then creates a pointer to the integer. It then prints out the data type of
    the pointer, the address stored in the pointer, and then the value of data being
    pointed at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functions are defined with the `func` keyword. Functions can have multiple parameters.
    All parameters are positional and there are no named parameters. Go supports variadic
    parameters allowing for an unknown number of parameters. Functions are first-class
    citizens in Go, and can be used anonymously and returned as a variable. Go also
    supports multiple return values from a function. The underscore can be used to
    ignore a return variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'All of these examples are demonstrated in the following code source:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Interfaces are a special type that define a collection of function signatures.
    You can think of an interface as saying, "a type must implement function X and
    function Y to satisfy this interface." If you create any type and implement the
    functions needed to satisfy the interface, your type can be used anywhere that
    the interface is expected. You don't have to specify that you are trying to satisfy
    an interface, the compiler will determine if it satisfies the requirements.
  prefs: []
  type: TYPE_NORMAL
- en: You can add as many other functions as you want to your custom type. The interface
    defines the functions that are required, but it does not mean that your type is
    limited to implementing only those functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most commonly used interface is the `error` interface. The `error` interface
    only requires a single function to be implemented, a function named `Error()`
    that returns a string with the error message. Here is the interface definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This makes it very easy for you to implement your own error interfaces. This
    example creates a `customError` type and then implements the `Error()` function
    needed to satisfy the interface. Then, a sample function is created, which returns
    the custom error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Other frequently used interfaces are the `Reader` and `Writer` interfaces.
    Each one only requires one function to be implemented in order to satisfy the
    interface requirements. The big benefit here is that you can create your own custom
    types that reads and writes data in some arbitrary way. The implementation details
    are not important to the interface. The interface won''t care whether you are
    reading and writing to a hard disk, a network connection, storage in memory, or
    `/dev/null`. As long as you implement the function signatures that are required,
    you can use your type anywhere the interface is used. Here is the definition of
    the `Reader` and `Writer` interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Map
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A map is a hash table or dictionary that stores key and value pairs. The key
    and value can be any data types, including maps themselves, creating multiple
    dimensions.
  prefs: []
  type: TYPE_NORMAL
- en: The order is not guaranteed. You can iterate over a map multiple times and it
    might be different. Additionally, maps are not concurrent safe. If you must share
    a map between threads, use a mutex.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some example map usages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Channel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Channels are used to communicate between threads. Channels are **first-in, first-out**
    (**FIFO**) queues. You can push objects on to the queue and pull from the front
    asynchronously. Each channel can only support one data type. Channels are blocking
    by default, but can be made nonblocking with a `select` statement. Like slices
    and maps, channels must be initialized before use with the `make()` function.
  prefs: []
  type: TYPE_NORMAL
- en: The saying in Go is *Do not communicate by sharing memory; instead, share memory
    by communicating*. Read more about this philosophy at [https://blog.golang.org/share-memory-by-communicating](https://blog.golang.org/share-memory-by-communicating).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example program that demonstrates basic channel usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Control structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Control structures are used to control the flow of program execution. The most
    common forms are the `if` statements, `for` loops, and `switch` statements. Go
    also supports the `goto` statement, but should be reserved for cases of extreme
    performance and not used regularly. Let's look briefly at each of these to understand
    the syntax.
  prefs: []
  type: TYPE_NORMAL
- en: if
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `if` statement comes with the `if`, `else if`, and `else` clauses, just
    like most other languages. The one interesting feature that Go has is the ability
    to put a statement before the condition, creating temporary variables that are
    discarded after the `if` statement has completed.
  prefs: []
  type: TYPE_NORMAL
- en: 'This example demonstrates the various ways to use an `if` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: for
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `for` loop has three components, and can be used just like a `for` loop
    in C or Java. Go has no `while` loop because the `for` loop serves the same purpose
    when used with a single condition. Refer to the following example for more clarity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: range
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `range` keyword is used to iterate over a slice, map, or other data structure.
    The `range` keyword is used in combination with the `for` loop, to operate on
    an iterable data structure. The `range` keyword returns the key and value variables.
    Here are some basic examples of using the `range` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: switch, case, fallthrough, and default
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `switch` statement allows you to branch execution based on the state of
    a variable. It is similar to the `switch` statement in C and other languages.
  prefs: []
  type: TYPE_NORMAL
- en: There is no `fallthrough` by default. This means once the end of a case is reached,
    the code exits the `switch` statement completely unless an explicit `fallthrough`
    command is provided. A `default` case can be provided if none of the cases are
    matched.
  prefs: []
  type: TYPE_NORMAL
- en: You can put a statement in front of the variable to be switched, such as the
    `if` statement. This creates a variable whose scope is limited to the `switch`
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'This example demonstrates two `switch` statements. The first one uses hardcoded
    values and includes a `default` case. The second `switch` statement uses an alternate
    syntax that allows for a statement in the first line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: goto
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Go does have a `goto` statement, but it is very rarely used. Create a label
    with a name and a colon, then *go to* it using the `goto` keyword. Here is a basic
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Defer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By deferring a function, it will run whenever the current function is exited.
    This is a convenient way to ensure that a function will get executed before exiting,
    which is useful for cleaning up or closing files. It is convenient because a deferred
    function will get executed no matter where the surrounding function exits if there
    are multiple return locations.
  prefs: []
  type: TYPE_NORMAL
- en: Common use cases are deferring calls to close a file or database connection.
    Right after opening a file, you can defer a call to close. This will ensure that
    a file is closed whenever the function is exited, even if there are multiple return
    statements and you can't be sure about when and where the current function will
    exit.
  prefs: []
  type: TYPE_NORMAL
- en: 'This example demonstrates a simple use case for the `defer` keyword. It creates
    a file and then defers a call to `file.Close()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Be sure to properly check and handle errors. The `defer` call will panic if
    using a nil pointer.
  prefs: []
  type: TYPE_NORMAL
- en: It is also important to understand that deferred functions are run when the
    surrounding function is exited. If you put a `defer` call inside a `for` loop,
    it will not get called at the end of each `for` loop iteration.
  prefs: []
  type: TYPE_NORMAL
- en: Packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Packages are just directories. Every directory is its own package. Creating
    subdirectories creates a new package. Having no subpackages leads to a flat hierarchy.
    Subdirectories are used just for organizing code.
  prefs: []
  type: TYPE_NORMAL
- en: Packages should be stored in the `src` folder of your `$GOPATH` variable.
  prefs: []
  type: TYPE_NORMAL
- en: A package name should match the folder name or be named `main`. A `main` package
    means that it is not intended to be imported into another application, but meant
    to compile and run as a program. Packages are imported using the `import` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can import packages individually:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can import multiple packages at once by wrapping them with
    parenthesis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Go technically does not have classes, but there are only a few subtle distinctions
    that keep it from being called an object-oriented language. Conceptually, I do
    consider it an object-oriented programming language, though it only supports the
    most basic features of an object-oriented language. It does not come with all
    of the features many people have come to associate with object-oriented programming,
    such as inheritance and polymorphism, which are replaced with other features such
    as embedded types and interfaces. Perhaps you could call it a *microclass* system,
    because it is a minimalistic implementation with none of the extra features or
    baggage, depending on your perspective.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this book, the terms *object* and *class* may be used to illustrate
    a point using familiar terms, but be aware that these are not formal terms in
    Go. A type definition in combination with the functions that operate on that type
    are like the class, and the object is an instance of a type.
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is no inheritance in Go, but you can embed types. Here is an example
    of a `Person` and `Doctor` types, which embeds the `Person` type. Instead of inheriting
    the behavior of `Person` directly, it stores the `Person` object as a variable,
    which brings with it all of its expected `Person` methods and attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Polymorphism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is no polymorphism in Go, but you can use interfaces to create common
    abstraction that can be used by multiple types. Interfaces define one or more
    method declarations that must be satisfied to be compatible with the interface.
    Interfaces were covered earlier in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Constructors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are no constructors in Go, but there are `New()` functions that act like
    factories initializing an object. You simply have to create a function named `New()`
    that returns your data type. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: There are no deconstructors in Go, since everything is garbage collected and
    you do not manually destroy objects. Defer is the closest you can get by deferring
    a function call to perform some cleanup when the current function ends.
  prefs: []
  type: TYPE_NORMAL
- en: Methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Methods are functions that belong to a specific type, and are called using
    the dot notation, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The dot notation is widely used in C++ and other object-oriented languages.
    The dot notation and the class system stemmed from a common pattern that was used
    in C. The common pattern is to define a set of functions that all operate on a
    specific data type. All of the related functions have the same first parameter,
    which is the data to be operated on. Since this is such a common pattern, Go built
    it into the language. Instead of passing the object to be manipulated as the first
    argument, there is a special place to designate the receiver in a Go function
    definition. The receiver is specified between a set of parenthesis before the
    function name. The next example demonstrates how to use function receivers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a large set of functions that all took a pointer as their
    first parameter, you can write functions that have a special *receiver*. The receiver
    can either be a type or a pointer to a type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In Go, you do not encapsulate all of the variables and methods inside a monolithic
    pair of braces. You define a type, and then define methods that operate on that
    type. This allows you to define all of your structs and data types in one place,
    and define the methods elsewhere in your package. You also have the option of
    defining a type and the methods right next to each other. It's pretty simple and
    straightforward, and it creates a slightly clearer distinction between the state
    (data) and the logic.
  prefs: []
  type: TYPE_NORMAL
- en: Operator overloading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is no operator overloading in Go, so you can't add to structs together
    with the `+` sign, but you can easily define an `Add()` function on the type and
    then call something like `dataSet1.Add(dataSet2)`. By omitting operator overloading
    from the language, we can confidently use the operators without worrying about
    unexpected behavior due to operator behavior being overloaded somewhere else in
    code without realizing it.
  prefs: []
  type: TYPE_NORMAL
- en: Goroutines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Goroutines are lightweight threads built into the language. You simply have
    to put the word `go` in front of a function call to have the function execute
    in a thread. Goroutines may also be referred to as threads in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Go does provide mutexes, but they are avoidable in most cases and will not be
    covered in this book. You can read more about mutexes in the `sync` package documentation
    at [https://golang.org/pkg/sync/](https://golang.org/pkg/sync/). Channels should
    be used instead for sharing data and communicating between threads. Channels were
    covered earlier in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the `log` package is safe to use concurrently, but the `fmt` package
    is not. Here is a short example of using goroutines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Getting help and documentation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Go has both online and offline help documentation. The offline documentation
    is built-in for Go and is the same documentation that is hosted online. These
    next sections will walk you through accessing both forms of documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Online Go documentation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The online documentation is available at [https://golang.org/](https://golang.org/),
    and has all the formal documentation, specifications, and help files. Language
    documentation specifically is at [https://golang.org/doc/](https://golang.org/doc/),
    and information about the standard library is at [https://golang.org/pkg/](https://golang.org/pkg/).
  prefs: []
  type: TYPE_NORMAL
- en: Offline Go documentation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Go also comes with offline documentation with the `godoc` command-line tool.
    You can use it on the command line, or have it run a web server where it serves
    the same website that [https://golang.org/](https://golang.org/) hosts. It is
    quite handy to have the full website documentation available locally. Here are
    a few examples that get documentation for the `fmt` package. Replace `fmt` with
    whatever package you are interested in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The HTTP option serves the same documentation that is available on [https://golang.org/](https://golang.org/).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After reading this chapter you should have a basic understanding of Go fundamentals
    such as what the keywords are, what they do, and what basic data types are available.
    You should also feel comfortable creating functions and custom data types.
  prefs: []
  type: TYPE_NORMAL
- en: The goal is not to memorize all of the preceding information, but to be aware
    of what tools are available in the language. Use this chapter as a reference if
    necessary. You can find more information about the Go language specification at
    [https://golang.org/ref/spec](https://golang.org/ref/spec).
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at working with files in Go. We will cover
    basics such as getting file information, seeing whether a file exists, truncating
    files, checking permissions, and creating new files. We will also cover the reader
    and writer interfaces, as well as a number of ways to read and write data. In
    addition to this, we will cover things such as archiving to ZIP or TAR files and
    compressing files with GZIP.
  prefs: []
  type: TYPE_NORMAL
