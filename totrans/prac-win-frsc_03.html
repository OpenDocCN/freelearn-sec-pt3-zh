<html><head></head><body><div class="chapter" title="Chapter&#xA0;3.&#xA0;Volatile Data Collection"><div class="titlepage"><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Volatile Data Collection</h1></div></div></div><p>This chapter is dedicated to some issues that are related to the acquisition of data, which has changed very fast. Due to its nature, it reflects the state of the system at a certain time because the collection of data takes place on a live system.</p><p>The <span class="strong"><strong>Request for Comments RFC </strong></span>3227 document provides a list of digital evidence and the order in which it should be collected. The main principle that should guide this is that the most rapidly changing data should be collected first.</p><p>The list of evidence from RFC comprises the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Registers and cache CPU</li><li class="listitem" style="list-style-type: disc">Routing table, ARP cache, process table, kernel statistics, and memory</li><li class="listitem" style="list-style-type: disc">Temporary filesystems</li><li class="listitem" style="list-style-type: disc">Disk</li><li class="listitem" style="list-style-type: disc">Remote logging and monitoring data that is relevant to the system's media</li><li class="listitem" style="list-style-type: disc">Physical configuration and network topology</li><li class="listitem" style="list-style-type: disc">Archival media</li></ul></div><p>According to this list, the volatile data which should be collected first are memory and network related data.</p><div class="section" title="Memory acquisition"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec18"/>Memory acquisition</h1></div></div></div><p>For many years, the main technique for conducting digital forensics was analysis of hard disk images. Certainly, if a hard disk image is available, we have a good chance of getting a lot of data to resolve the incident. However, this approach has some disadvantages.</p><p>Modern hard drives have a huge size, or sometimes we have to deal with RAID arrays, so analysis of such large amounts of data will require a long time. Also, Full Disk Encryption technology could be implemented and without encryption keys it will be not possible to get access to the files on the disk. Moreover, analysis of hard disk content does not always give the whole picture of what was happened at a particular point in time. Also, today there is a lot of bodiless malware; in this case, malicious code is not presented in the filesystem as a file.</p><p>All these listed facts force a forensics specialist to seek new alternative ways to solve forensics tasks. So, researchers look at the RAM as an alternative source of information.</p><p>As well-known and modern PCs are built on the von Neumann architecture, any piece of code which is executed on the computer should appear somewhere in the memory. The memory could be a useful source of evidence. Another advantage of using memory is its small size. Despite the fact that nowadays a user's workstation has more and more RAM, it still has a far smaller size than modern hard drives. However, for a long time analysis of memory was not widely used. The process of memory analysis was just scanning dump memory to search some strings. This situation changed when tools such as Volatility Framework appeared.</p><p>So today, memory forensics is no longer optional but is a compulsory step for a professional investigation. However, before memory analysis, we should first get to the dump of the memory, and we should do it in the right way. Otherwise, even with powerful tools, such as Volatility, the analysis of memory will be unsuccessful.</p><p>There are a lot of tools which allow creating memory dumps for any operating system—MS Windows, Linux, or Mac OS X. Some of them are very simple, and all you need to do is just push the button. However, the professional should understand how it works and be ready to fix problems in case they happen.</p><div class="section" title="Issues related to memory access"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec34"/>Issues related to memory access</h2></div></div></div><p>Now, let's discuss some of the issues that are related to memory access on MS Windows. In MS Windows, there is a <code class="literal">\Device\PhysicalMemory</code> kernel object, which presents direct access to the physical memory of the system. To get the contents of the memory, we should read this file. Before Windows Server 2003 SP2, a given file was accessible from the user's space. However, starting from this update and in all later versions of MS Windows, this object is accessible from kernel space only. User space applications can read this file, but to open and edit it, the kernel space code or driver is required. Moreover, any manipulation of this object is a dangerous operation. The device memory is part of the physical memory, which is mapped to other devices in the system. This is the area of memory for devices, such as graphics cards, mapped to this part of physical memory in such way that the operating system could send data to such devices. Some particular blocks of memory are reserved for these devices and data that is written to these addresses are sent to the device. Thus, the writing or the request for access to this area of memory that is reserved for the device is translated into a request, which is sent to a real device.</p><p>How the request will be handled by a device depends on the device. Also, it could cause the system to hang or crash and destroy evidence. So, the software and the hardware that are used to dump memory should exclude these areas of memory from the process. We suggest testing all tools before using them. Besides the problem just described, there are malware which could change the behavior of tools and change the result of memory dumps.</p><p>Although we have never faced such malware in real life, there are a few PoC written by some researchers which could prove this threat. So, if the process of memory acquisition fails, this could make the system crash and cause a loss of data as well.</p><div class="section" title="Choosing a tool"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec0"/>Choosing a tool</h3></div></div></div><p>To choose a tool we need to answer the following questions:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">What is the supported OS version?</li><li class="listitem" style="list-style-type: disc">What is the supported hardware architecture (x32, x64)?</li><li class="listitem" style="list-style-type: disc">What is the required privilege level?</li><li class="listitem" style="list-style-type: disc">Where are the results stored?</li></ul></div><p>Today, there are a lot free and commercial tools on the market that support all versions of MS Windows that we could use to dump memory:</p><div class="informaltable"><table border="1"><colgroup><col/><col/></colgroup><tbody><tr><td>
<p><span class="strong"><strong>Free tools</strong></span></p>
</td><td>
<p><span class="strong"><strong>Commercial tools</strong></span></p>
</td></tr><tr><td>
<p>DumpIt</p>
</td><td>
<p>F-Response</p>
</td></tr><tr><td>
<p>WinPMEM (rekall)</p>
</td><td>
<p>Guidance Winen</p>
</td></tr><tr><td>
<p>FTKImager</p>
</td><td>
<p>HBGary Fastdump PRO</p>
</td></tr><tr><td>
<p>BelkaSoft Live RAM Capturer</p>
</td><td>
</td></tr></tbody></table></div><p>We need to note that the commercial tools are not always better. Which tool we should use depends on the case of usage, experience, and qualification of responder, and on other factors.</p><p>Despite all the possible options, the principles that we suggest for you to follow are the same:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Minimize impact to the system.</li><li class="listitem">Run the tool from a safe environment.</li><li class="listitem">Store results outside the system.</li></ol></div><p>We will divide all use cases into three groups with two approaches, hardware and software:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Locally</li><li class="listitem" style="list-style-type: disc">Remotely</li><li class="listitem" style="list-style-type: disc">Post mortem</li></ul></div><p>Each of them has their own advantages and disadvantages. For example, let's take a look at the hardware approach. In this case, administrator privileges are not required, but you should have local physical access to the PC under investigation. The given approach is based on <span class="strong"><strong>Direct Memory Access</strong></span> (<span class="strong"><strong>DMA</strong></span>) and some technologies, such as Fireware, Thunderbolt, ExpressCard, or PCI. The disadvantage of this approach is that you need to install some hardware and software into the system before you can use it. Also, this action requires a reboot of the system. So, doing this could destroy some evidence. Another disadvantage is the limitation of the 4 GB memory size, which we can dump using the FireWare technology. However, solutions based on PCI are rare and expensive.</p><p>As we mentioned earlier, there are a lot of variants of use cases. Therefore, it is impossible to observe every one of them in a single chapter.</p><p>The most simple and prevalent case is the local software approach. In this approach, we can use a number of utilities, and we will look at some of them now.</p></div><div class="section" title="DumpIt"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec1"/>DumpIt</h3></div></div></div><p>In cases where the system has no more than 4 GB of RAM, the DumpIt utility is a good choice. DumpIt has a very simple command-line interface, and it is easy to use even for an inexperienced person. To dump the whole system memory, you should copy it to some removable device with enough space to store the memory dump. Then, plug this device in to the system and run it from the drive. After running this, DumpIt will create a file that contains the memory dump of the system in the same path from where DumpIt was executed:</p><div class="mediaobject"><img src="graphics/image_03_001.jpg" alt="DumpIt"/></div><p>Unfortunately, the free version of DumpIt doesn't work correctly with memory more than 4 GB.</p><p>If you have 8 GB of memory or more, we suggest using Belkasoft Live RAM Capturer. This software also has a simple graphical interface. It works on both architectures: x32 and x64 bits:</p><div class="mediaobject"><img src="graphics/image_03_002.jpg" alt="DumpIt"/></div></div><div class="section" title="FTK Imager"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec2"/>FTK Imager</h3></div></div></div><p>One more popular utility for memory dump is FTK Imager. It is also free. There are two versions of it. We suggest using the FTK Imager Lite version. It does not require installation, has an easy-to-use interface, and has a lot of useful features:</p><div class="mediaobject"><img src="graphics/image_03_003.jpg" alt="FTK Imager"/></div></div></div><div class="section" title="Acquiring memory from a remote computer using iSCSI"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec35"/>Acquiring memory from a remote computer using iSCSI</h2></div></div></div><p>Another common scenario is the acquisition of memory from a remote computer. Consider the case when we need to dump memory from a remote Windows workstation using different operating systems including MS Windows, Mac OS X, and Linux. To do this, we can use the <span class="strong"><strong>iSCSI</strong></span> protocol. Internet Small Computer System Interface protocol was developed in 1998 by IBM and CISCO. This protocol allows clients (named initiator) to send SCSI (CDBs) to SCSI storage devices (named target), which are located on remote servers.</p><p>Initiator is an iSCSI client and it works as an SCSI adapter except that it uses the IP network rather than physical bus. The iSCSI target is a server that provides a network interface to a storage device. Thus, we should install the iSCSI target on workstation of investigator where we will store the memory dump. There are a few free implementations of iSCSI for Microsoft and StarWind. Also, F-Response provides features to access a remote PC by iSCSI. Most operating systems have a free built-in initiator client software, including MS Windows 2000 SP4 and higher.</p><p>So, in our use case, we will use our own written iSCSI target software, <span class="strong"><strong>KFA</strong></span> (<span class="strong"><strong>Kaspersky Forensics Agent</strong></span>), and the <code class="literal">iscsiadm</code> utility as initiator on a Linux station.</p><p>To dump memory using Kaspersky Forensics Agent, run the utility on the target system with the <code class="literal">-mountphysmem</code> option:</p><div class="mediaobject"><img src="graphics/image_03_004.jpg" alt="Acquiring memory from a remote computer using iSCSI"/></div><p>To provide access with authorization, we can use the <code class="literal">chaplogin</code> and <code class="literal">chapsecret</code> options:</p><div class="mediaobject"><img src="graphics/image_03_005.jpg" alt="Acquiring memory from a remote computer using iSCSI"/></div><p>It is now possible to connect to the selected media using any iSCSI initiator:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Now, we test the connection:<pre class="programlisting">
<span class="strong"><strong>sudo iscsiadm -m discovery -t st -p TargetAddress</strong></span>
</pre></li><li class="listitem">Having verified that the iSCSI connection is in working order, we establish a full connection:<pre class="programlisting">
<span class="strong"><strong>sudo iscsiadm -m node --login</strong></span>
</pre></li><li class="listitem">Make sure that the memory is visible in the Ubuntu environment as a new device.</li><li class="listitem">Now, you can dump it with the <code class="literal">dd</code> utility as usual.</li></ol></div><p>Now, you have a memory dump, and you are ready to analyze it!</p></div><div class="section" title="Using the Sleuth Kit"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec36"/>Using the Sleuth Kit</h2></div></div></div><p>We want to discuss one more use case. It is possible that an investigator has only a hard disk image and no opportunity to dump memory from the system of interest. In this case, we still have the ability to receive some kind of system memory information. MS Windows saves the contents of memory in the <code class="literal">hiberfil.sys</code> file when the system goes to hibernate. So, if we have a disk image, we can extract <code class="literal">hiberfil.sys</code> from the disk.</p><p>To do this, we need to use the Sleuth Kit. Let's take a look at how we can do this:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">To obtain information about partitions on the disk, use the following command:<pre class="programlisting">
<span class="strong"><strong>mmls image</strong></span>
</pre><p>The output will be as follows:</p><div class="mediaobject"><img src="graphics/image_03_006.jpg" alt="Using the Sleuth Kit"/></div></li><li class="listitem">Then, use <code class="literal">fls</code> to list files on the root directory of the NTFS partition:<pre class="programlisting">
<span class="strong"><strong>fls -o 2048 image.dd | grep hiberfil.sys</strong></span>
<span class="strong"><strong>r/r 32342-128-1: hiberfil.sys</strong></span>
</pre></li><li class="listitem">Finally, extract <code class="literal">hiberfil.sys</code>:<pre class="programlisting">
<span class="strong"><strong>icat -o 2048 image.dd 32342 &gt; hiberfil.sys</strong></span>
</pre></li></ol></div><p>Now, you can analyze <code class="literal">hiberfil.sys</code> with an analysis tool, such as Volatility.</p></div></div></div>
<div class="section" title="Network-based data collection"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec19"/>Network-based data collection</h1></div></div></div><p>Nowadays, it is difficult enough to find computers that don't have any network connections. This is almost impossible in the enterprise environment. Network connections reflect the interaction of computers with the outer world. Also, the network is the main source of threats. Today, the Internet is a very aggressive environment. Threats of various levels from spam to APT often penetrate computers via networks.</p><p>So, in almost every incident, computers have network activities that are related to the incident. There are a lot of examples of such events from receiving e-mails with malicious attachments and visits of a malicious URL. However, sometimes to have only host-based evidence to get a whole picture about an incident is not enough. In such cases, network-based evidence can help a lot.</p><p>Network forensics is a vast topic. We won't cover all the issues. In this chapter, we just want to look at this as an additional source of evidence. There is a lot of network-based evidence, but we will focus on network traffic acquisition.</p><p>Forensics investigators can capture the network traffic from physical media, such as cables or air and network devices, such as switches or hubs.</p><p>Now, we will give a short introduction to this topic to understand how we can collect network traffic.</p><div class="section" title="Hubs"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec37"/>Hubs</h2></div></div></div><p>These are a simple network devices that allow connecting all devices from a local subnet. Hubs don't have any functionality beside the physical connection of all devices.</p><p>When such a device receives the network frame, it transfers packets on other ports. Thus, every device that is connected to the hub will receive all traffic that is dedicated for other devices. In the case of a hub-based network, it is simple enough to capture traffic from a given segment of a network. We should note that sometimes some manufactures designate some devices which are in reality switches as hubs.</p><p>The most reliable way to figure out what kind of device you are dealing with is to connect the station to the device, turn the network interface to promiscuous mode, and capture the traffic using the tcpdump utility or a similar utility. If you only have a broadcast and packets are dedicated to this station, this means that you have a <span class="strong"><strong>switch device</strong></span>. If the traffic contains packets for other stations, you have a <span class="strong"><strong>hub</strong></span>.</p><p>Investigators should be careful when they use hubs to capture traffic. In this case, investigators could see all traffic, but it could also be everybody from a local network. A compromised system could work as a passive sniffer and eavesdrop on all transferred data. Any investigator activities and data in the network could be intercepted. So, it's a good idea to use an already installed hub, but the installation of a new one to capture the network traffic will bring new risks.</p></div><div class="section" title="Switches"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec38"/>Switches</h2></div></div></div><p>Switches are the most prevalent network devices used to build local networks. They also serve as hubs serve to connect network devices into the network. However, unlike hubs, they use software to keep track of the stations connected to the ports of the switch. This information will be kept in the CAM table. When the switch receives a new packet, it will forward this packet only to a certain port according to the CAM table. So, each station receives only its traffic.</p><p>Investigators can often capture the network traffic on switch devices because most of them have the functionality of replicating traffic from one or a few ports to other ports for aggregation and analysis. Various vendors use different terms for this, the most widely used is <span class="strong"><strong>SPAN</strong></span> (<span class="strong"><strong>Switched Port Analyzer</strong></span>) or <span class="strong"><strong>RSPAN</strong></span> (<span class="strong"><strong>Remote SPAN</strong></span>). Sometimes, the term port mirroring is used. Also, switches have various hardware capacities. Port mirroring is limited by the physical capacity of a device. Consider this example, we have a 100 Mbps switch, and we want to mirror four ports to another one. With an average load of 50 Mbps for every port, the load for mirror ports will be 200 Mbps, which is far from the capacity of every port. Thus, some packets will be dropped in the process.</p><p>We should note that the approach with the SPAN port can change the collected traffic. However, there is one more method to capture the traffic. This is a network tap.</p><p>Network taps are placed between stations and switches and can look at and capture all traffic for this host. Network taps duplicate all traffic, including corrupted and any other packets. So, this approach is more suitable for forensics.</p><p>After we finally choose the method that we will use to capture the traffic, we need some software. A common solution for this is the <code class="literal">libpcap</code> library and software based on it, including <code class="literal">tcpdump</code>, Wireshark, and so on.</p><p>There are two main approaches to using such software to capture the traffic. They are filtering in capturing, and capturing all data and filtering it later.</p><p>In some cases, filtering during collection is a good idea if you have limited storage space to keep the traffic. From other side, libpcap has a very powerful filtering capability called <span class="strong"><strong>Berkley Packet Filter</strong></span> (<span class="strong"><strong>BPF</strong></span>). Using BPF filters, we can control what traffic we will capture and what we will drop. If you know exactly what you want to capture, this approach can save a lot of time and resources for you. BPF can filter traffic based on a comparison of fields in the protocols at second, third, and fourth levels. Also, the BPF language has some built-in primitives: <code class="literal">host id</code>, <code class="literal">dst host id</code>, <code class="literal">src host id</code>, <code class="literal">net id</code>, <code class="literal">dst net id</code>, <code class="literal">src net id</code>, <code class="literal">ether id</code>, <code class="literal">dst ether id</code>, <code class="literal">src ether id</code>, <code class="literal">port id</code>, <code class="literal">dst port id</code>, <code class="literal">src port id</code>, <code class="literal">gateway id</code>, <code class="literal">ip proto id</code>, <code class="literal">ether proto id</code>, <code class="literal">tcp</code>, <code class="literal">udp</code>, <code class="literal">icmp</code>, and <code class="literal">arp</code>. You could find more in manual documentation on <code class="literal">pcap-filter</code>.</p></div><div class="section" title="Tcpdump"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec39"/>Tcpdump</h2></div></div></div><p><code class="literal">tcpdump</code> is a tool to capture, filter, and analyze network traffic. The main purpose of this tool is to capture the traffic and print it out or store it in a file. <code class="literal">tcpdump</code> captures the traffic in bit-to-bit as it is transferred via media. We can use <code class="literal">tcpdump</code> to analyze traffic for troubleshooting in the network. In this case, you will use BPF to prefilter. However, usually this approach is a good fit for the initial triage only:</p><div class="mediaobject"><img src="graphics/image_03_007.jpg" alt="Tcpdump"/></div><p>In forensics practice, other approaches are more prevalent. Tcpdump is used to capture traffic during long periods of time and to store it in a file on disk with further analysis and correlation with other data.</p><p>The <code class="literal">tcpdump</code> is a high-fidelity tool, but the quality of captured traffic depends on resources available on the host where <code class="literal">tcpdump</code> is running. For instance, the performance of <code class="literal">tcpdump</code> will depend on the power of the CPU. The capturing of packets is a CPU-intensive activity, and if CPU is overloaded, <code class="literal">tcpdump</code> will fail and drop packets. In forensics cases, we want to capture all packets and this issue could be critical. In the case of high-loaded networks, the storage space for traffic is also an important question. As we mentioned earlier, you can use filtration of traffic and keep only useful information.</p><p>Despite the fact that filtration will save resources, such as CPU, disk space, and capacity, it should be implemented carefully because excessive filtration could cause a loss of evidence.</p></div><div class="section" title="Wireshark"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec40"/>Wireshark</h2></div></div></div><p>One more popular utility for capture and traffic analysis is Wireshark:</p><div class="mediaobject"><img src="graphics/image_03_008.jpg" alt="Wireshark"/></div><p>Wireshark is a tool with an easy to use graphical user interface. So it can be a good tool for beginners in network forensics. It also has a lot of features for filtration, decryption, and analysis of network traffic. Therefore, this makes Wireshark a must-have tool for any network investigator. Wireshark allows capturing traffic from any interface on the system if you have the necessary permissions, displaying it in real time, and storing it in a file on disk.</p><p>Moreover, there are a few useful command-line tools, which are distributed together with Wireshark.</p></div><div class="section" title="Tshark"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec41"/>Tshark</h2></div></div></div><p>Tshark is the CLI version of Wireshark. It has almost the same functionality and works with the same file formats:</p><div class="mediaobject"><img src="graphics/image_03_009.jpg" alt="Tshark"/></div></div><div class="section" title="Dumpcap"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec42"/>Dumpcap</h2></div></div></div><p>One more useful tool from the Wireshark kit is Dumpcap. It is dedicated to capturing network packets. Therefore, it is optimized for good performance in capture and will spend less system resources. If you plan to capture the traffic and analyze it with Wireshark, then the Dumpcap utility will be a good tool to capture the network traffic:</p><div class="mediaobject"><img src="graphics/image_03_009.jpg" alt="Dumpcap"/></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec20"/>Summary</h1></div></div></div><p>In this chapter, we covered issues that are related to volatile data collection. We discussed different tools and approaches to how to collect memory and network traffic.</p><p>In the next chapter, we will discuss issues that are related to non-volatile data collection. We will discuss how to duplicate hard drives and how to use standalone tools such as IR CD for this.</p></div></body></html>