<html><head></head><body><div class="chapter" title="Chapter&#xA0;2.&#xA0;Forensic Algorithms"><div class="titlepage"><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Forensic Algorithms</h1></div></div></div><p>Forensic algorithms are the building blocks for a forensic investigator. Independent from any specific implementation, these algorithms describe the details of the forensic procedures. In the first section of this chapter, we will introduce the different algorithms that are used in forensic investigations, including their advantages and disadvantages.</p><div class="section" title="Algorithms"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec11"/>Algorithms</h1></div></div></div><p>In this section, we <a id="id37" class="indexterm"/>describe the main differences between <span class="strong"><strong>MD5</strong></span>, <span class="strong"><strong>SHA256</strong></span>, and <span class="strong"><strong>SSDEEP</strong></span>—the most common algorithms used in the forensic investigations. We will explain the use cases as well as the limitations and threats behind these three<a id="id38" class="indexterm"/> algorithms. This should help you understand why using SHA256 is<a id="id39" class="indexterm"/> better than using MD5 and in which cases SSDEEP can help you in the<a id="id40" class="indexterm"/> investigation.</p><p>Before we dive into the different hash functions, we will give a short summary of what a cryptographic hash function is.</p><p>A <span class="strong"><strong>hash function</strong></span><a id="id41" class="indexterm"/> is a function that maps an <span class="emphasis"><em>arbitrarily large</em></span> amount of data to a value of a <span class="emphasis"><em>fixed length</em></span>. The hash function ensures that the same input always results in the same output, called the hash sum. Consequently, a hash sum is a characteristic of a specific piece of data.</p><p>A <span class="strong"><strong>cryptographic hash function</strong></span> is a hash function that is considered practically impossible to<a id="id42" class="indexterm"/> invert. This means that it is not possible to create the input data while having a pre-defined hash sum value by any other means than trying all the possible input values, that is <span class="emphasis"><em>brute force</em></span>. Therefore, this class of algorithms is known as <span class="emphasis"><em>one-way</em></span> cryptographic algorithm.</p><p>The ideal cryptographic<a id="id43" class="indexterm"/> hash function has four main properties, as follows:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">It must be easy to compute the hash value for any given input.</li><li class="listitem">It must be infeasible to generate the original input from its hash.</li><li class="listitem">It must be infeasible to modify the input without changing the hash.</li><li class="listitem">It must be infeasible to find two different inputs with the same hash (<span class="strong"><strong>collision-resistant</strong></span>).</li></ol></div><p>In the ideal case, if<a id="id44" class="indexterm"/> you create a hash of the given input and change only one bit of this input, the newly calculated hash will look totally different, as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user@lab:~$ echo -n This is a test message | md5sum</strong></span>
<span class="strong"><strong>fafb00f5732ab283681e124bf8747ed1</strong></span>

<span class="strong"><strong>user@lab:~$ echo -n This is A test message | md5sum</strong></span>
<span class="strong"><strong>aafb38820e0a3788eb41e9f5805e088e</strong></span>
</pre></div><p>If all of the previously mentioned properties are fulfilled, the algorithm is a cryptographically correct hash function and can be used to compare, for example, files with each other to prove that they haven't been tampered with during analysis or by an attacker.</p><div class="section" title="MD5"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec12"/>MD5</h2></div></div></div><p>The MD5 message-digest algorithm was the most commonly used (and is still a widely used) cryptographic <a id="id45" class="indexterm"/>hash function that produces a 128-bit (16-byte) hash value, typically <a id="id46" class="indexterm"/>expressed in the text format as a 32-digit hexadecimal number (as shown in the previous example). This message digest has been utilized in a wide variety of cryptographic applications and is commonly used to verify data integrity in forensic investigations. This algorithm was designed by Ronald Rivest in 1991 and has been heavily used since then.</p><p>A big advantage of MD5 is that it calculates faster and produces small hashes. The small hashes are a major point of interest when you need to store thousands of these hashes in a forensic investigation. Just imagine how many files a common PC will have on its hard drive. If you need to calculate a hash of each of these files and store them in a database, it would make a huge difference if each of the calculated hash has 16 byte or 32 byte of size.</p><p>Nowadays, the major disadvantage of MD5 is the fact that it is no longer considered to be collision-resistant. This means that it is possible to calculate the same hash from two different inputs. Keeping this in mind, it is not possible anymore to guarantee that a file hasn't been modified just by comparing its MD5 hash at two different stages of an investigation. At the moment it is possible to create a collision very fast, (refer to <a class="ulink" href="http://www.win.tue.nl/hashclash/On%20Collisions%20for%20MD5%20-%20M.M.J.%20Stevens.pdf">http://www.win.tue.nl/hashclash/On%20Collisions%20for%20MD5%20-%20M.M.J.%20Stevens.pdf</a>) but it is still difficult to modify a file in a way, which is now a malicious version of that benign file, and keep the MD5 hash of the original file.</p><p>The very famous cryptographer, Bruce Schneier, once wrote that (<a class="ulink" href="https://www.schneier.com/blog/archives/2008/12/forging_ssl_cer.html">https://www.schneier.com/blog/archives/2008/12/forging_ssl_cer.html</a>):</p><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>"We already knew that MD5 is a broken hash function" and that "no one should be using MD5 anymore".</em></span></p></blockquote></div><p>We would not<a id="id47" class="indexterm"/> go that far (especially because a lot of tools and services still use MD5), but <a id="id48" class="indexterm"/>you should try switching to SHA256 or at least double-check your results with the help of different hash functions in cases where it is critical. Whenever the chain of custody is crucial, we recommend using multiple hash algorithms to prove the integrity of your data.</p></div><div class="section" title="SHA256"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec13"/>SHA256</h2></div></div></div><p>SHA-2 is a set<a id="id49" class="indexterm"/> of cryptographic hash functions designed by the NSA (U.S. National Security Agency) and stands for Secure Hash Algorithm 2nd Generation. It has<a id="id50" class="indexterm"/> been published in 2001 by the NIST as a U.S. federal standard (FIPS). The SHA-2 family consists of several hash functions with digests (hash values) that are between 224 bits and 512 bits. The cryptographic functions SHA256 and SHA512 are the most common versions of SHA-2 hash functions computed with 32-bit and 64-bit words.</p><p>Despite the fact that these algorithms calculate slower and that the calculated hashes are larger in size (compared to MD5), they should be the preferred algorithms that are used for integrity checks during the forensic investigations. Nowadays, SHA256 is a widely used cryptographic hash function that is still collision-resistant and entirely trustworthy.</p></div><div class="section" title="SSDEEP"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec14"/>SSDEEP</h2></div></div></div><p>The biggest<a id="id51" class="indexterm"/> difference between <span class="strong"><strong>MD5</strong></span>, <span class="strong"><strong>SHA256</strong></span>, and <span class="strong"><strong>SSDEEP</strong></span> is the<a id="id52" class="indexterm"/> fact that <span class="strong"><strong>SSDEEP</strong></span> is not considered to be a <span class="strong"><strong>cryptographic hash function</strong></span> as it only changes slightly when the input is changed by one bit. For example:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user@lab:~$ echo -n This is a test message | ssdeep</strong></span>
<span class="strong"><strong>ssdeep,1.1--blocksize:hash:hash,filename</strong></span>
<span class="strong"><strong>3:hMCEpFzA:hurs,"stdin"</strong></span>

<span class="strong"><strong>user@lab:~$ echo -n This is A test message | ssdeep</strong></span>
<span class="strong"><strong>ssdeep,1.1--blocksize:hash:hash,filename</strong></span>
<span class="strong"><strong>3:hMCkrzA:hOrs,"stdin"</strong></span>
</pre></div><p>The SSDEEP packages <a id="id53" class="indexterm"/>can be downloaded and installed as described in the following URL: <a class="ulink" href="http://ssdeep.sourceforge.net/usage.html#install">http://ssdeep.sourceforge.net/usage.html#install</a>
</p><p>This behavior is not a weakness of SSDEEP, it is a major advantage of this function. In reality, SSDEEP is a<a id="id54" class="indexterm"/> program to compute and match the <span class="strong"><strong>Context Triggered Piecewise Hashing</strong></span> (<span class="strong"><strong>CTPH</strong></span>) values. CTPH is a technique that is also known as <span class="strong"><strong>Fuzzy Hashing</strong></span> and is able to match inputs that have <a id="id55" class="indexterm"/>homologies. Inputs with homologies have sequences of identical bytes in a given order with totally different bytes in between. These bytes in between can differ in content and length. CTPH, originally based on the work of <span class="emphasis"><em>Dr. Andrew Tridgell</em></span>, was adapted by <span class="emphasis"><em>Jesse Kornblum</em></span> and published at the DFRWS conference in 2006 in a paper called <span class="emphasis"><em>Identifying Almost Identical Files Using Context Triggered Piecewise Hashing</em></span>; refer to <a class="ulink" href="http://dfrws.org/2006/proceedings/12-Kornblum.pdf">http://dfrws.org/2006/proceedings/12-Kornblum.pdf</a>.</p><p>SSDEEP can be <a id="id56" class="indexterm"/>used to check how similar the two files are and in which part <a id="id57" class="indexterm"/>of the file the difference is located. This feature is often used to check if two different applications on the mobile devices have a common code base, as shown in the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user@lab:~$ ssdeep -b malware-sample01.apk &gt; signature.txt</strong></span>

<span class="strong"><strong>user@lab:~$ cat signature.txt</strong></span>
<span class="strong"><strong>Ssdeep,1.1--blocksize:hash:hash,filename</strong></span>
<span class="strong"><strong>49152:FTqSf4xGvFowvJxThCwSoVpzPb03++4zlpBFrnInZWk:JqSU4ldVVpDIcz3BFr8Z7,"malware-sample01.apk"</strong></span>

<span class="strong"><strong>user@lab:~$ ssdeep –mb signature.txt malware-sample02.apk</strong></span>
<span class="strong"><strong>malware-sample02.apk matches malware-sample01.apk (75)</strong></span>
</pre></div><p>In the previous example, you can see that the second sample matches the first one with a very high likelihood. These matches indicate the potential source code reuse or at least a large number of files inside the apk file are identical. A manual examination of the files in question is required to tell exactly which parts of the code or files are identical; however, we now know that both the files are similar to each other.</p></div></div></div>
<div class="section" title="Supporting the chain of custody"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec12"/>Supporting the chain of custody</h1></div></div></div><p>The outcomes of forensic investigations can have a severe impact on organizations and individuals. Depending on your field of work, your investigation can become evidence in the court.</p><p>Consequently, the<a id="id58" class="indexterm"/> integrity of forensic evidence has to be ensured not just when collecting the evidence, but also throughout the entire handling and analysis. Usually, the very first step in a forensic investigation is gathering the evidence. Normally, this is done using a bitwise copy of the original media. All the subsequent analysis is performed on this forensic copy.</p><div class="section" title="Creating hash sums of full disk images"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec15"/>Creating hash sums of full disk images</h2></div></div></div><p>To ensure that a forensic copy is actually identical to the original media, hash sums of the media and<a id="id59" class="indexterm"/> from the forensic copy are made. These<a id="id60" class="indexterm"/> hash sums must match to prove that the<a id="id61" class="indexterm"/> copy is exactly like the original data. Nowadays, it has become common to use at least two different cryptographic hash algorithms to minimize the risk of hash collisions and harden the overall process against hash collision attacks.</p><p>With Linux, one can easily create MD5 and SHA256 hashes from a drive or multiple files. In the following example, we will calculate MD5 sums and SHA256 sums for two files to provide a proof of identical content:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user@lab:~$ md5sum /path/to/originalfile /path/to/forensic_copy_of_sdb.img</strong></span>

<span class="strong"><strong>user@lab:~$ sha256sum /path/to/originalfile /path/to/forensic_copy_of_sdb.img</strong></span>
</pre></div><p>This proof of identical content is required to support the chain of custody, that is, to show that the analyzed data is<a id="id62" class="indexterm"/> identical to the raw data on the disk. The term <span class="strong"><strong>sdb</strong></span> refers to a drive attached to the forensic workstation (in Linux, the <span class="strong"><strong>second hard drive</strong></span> is called <span class="strong"><strong>sdb</strong></span>). To further support the chain of custody, it is highly recommended to use a write-block device between the evidence and forensic workstation to avoid any accidental change of the evidence. The second argument represents the location of a bitwise copy of the evidence. The commands output the hash sums for the original drive and the copy. The copy can be considered forensically sound if both the MD5 sums match and both the SHA256 sums match.</p><p>While the method shown in the previous example works, it has a big disadvantage, the evidence and its copy have to be read twice to calculate the hash sums. If the disk is a 1 TB hard drive, it can slow down the overall process by several hours.</p><p>The following Python code reads the data only once and feeds it into two hash calculations. Therefore, this Python script is almost twice as fast as running <code class="literal">md5sum</code> followed by <code class="literal">sha256sum</code> and produces exactly the same hash sums as these tools:</p><div class="informalexample"><pre class="programlisting">#!/usr/bin/env python

import hashlib
import sys

def multi_hash(filename):
    """Calculates the md5 and sha256 hashes
       of the specified file and returns a list
       containing the hash sums as hex strings."""

    md5 = hashlib.md5()
    sha256 = hashlib.sha256()

    with open(filename, 'rb') as f:
        while True:
            buf = f.read(2**20)
            if not buf:
                break
            md5.update(buf)
            sha256.update(buf)

    return [md5.hexdigest(), sha256.hexdigest()]


if __name__ == '__main__':
    hashes = []
    print '---------- MD5 sums ----------'
    for filename in sys.argv[1:]:
        h = multi_hash(filename)
        hashes.append(h)
        print '%s  %s' % (h[0], filename)
        
    print '---------- SHA256 sums ----------'
    for i in range(len(hashes)):
        print '%s  %s' % (hashes[i][1], sys.argv[i+1])</pre></div><p>In the<a id="id63" class="indexterm"/> following call of the script, we calculate the<a id="id64" class="indexterm"/> hash sums of some of the common <a id="id65" class="indexterm"/>Linux tools:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user@lab:~$ python multihash.py /bin/{bash,ls,sh}</strong></span>
<span class="strong"><strong>---------- MD5 sums ----------</strong></span>
<span class="strong"><strong>d79a947d06958e7826d15a5c78bfaa05  /bin/bash</strong></span>
<span class="strong"><strong>fa97c59cc414e42d4e0e853ddf5b4745  /bin/ls</strong></span>
<span class="strong"><strong>c01bc66da867d3e840814ec96a137aef  /bin/sh</strong></span>
<span class="strong"><strong>---------- SHA256 sums ----------</strong></span>
<span class="strong"><strong>cdbcb2ef76ae464ed0b22be346977355c650c5ccf61fef638308b8da60780bdd  /bin/bash</strong></span>
<span class="strong"><strong>846ac0d6c40d942300de825dbb5d517130d8a0803d22115561dcd85efee9c26b  /bin/ls</strong></span>
<span class="strong"><strong>e9a7e1fd86f5aadc23c459cb05067f49cd43038f06da0c1d9f67fbcd627d622c  /bin/sh</strong></span>
</pre></div><p>It is crucial to document the hash sums of the original data and the forensic copy in the forensic report. An independent party can then read the same piece of evidence and confirm<a id="id66" class="indexterm"/> that<a id="id67" class="indexterm"/> the <a id="id68" class="indexterm"/>data that you analyzed is exactly the data of the evidence.</p></div><div class="section" title="Creating hash sums of directory trees"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec16"/>Creating hash sums of directory trees</h2></div></div></div><p>Once the full image is copied, its contents should be indexed and the hash sums should be created for <a id="id69" class="indexterm"/>every file. With the support of the previously <a id="id70" class="indexterm"/>defined <code class="literal">multi_hash</code> function and Python<a id="id71" class="indexterm"/> standard libraries, a report template containing a list of all file names, sizes, and hash values can be created, as shown in the following:</p><div class="informalexample"><pre class="programlisting">#!/usr/bin/env python

from datetime import datetime
import os
from os.path import join, getsize
import sys
from multihash import multi_hash

def dir_report(base_path, reportfilename):
    """Creates a report containing file integrity information.

    base_path -- The directory with the files to index
    reportfilename -- The file to write the output to"""

    with open(reportfilename, 'w') as out:
        out.write("File integrity information\n\n")
        out.write("Base path:      %s\n" % base_path)
        out.write("Report created: %s\n\n" % datetime.now().isoformat())
        out.write('"SHA-256","MD5","FileName","FileSize"')
        out.write("\n")

        for root, dirs, files in os.walk(base_path):
            write_dir_stats(out, root, files)

        out.write("\n\n--- END OF REPORT ---\n")

def write_dir_stats(out, directory, files):
    """Writes status information on all specified files to the report.

    out -- open file handle of the report file
    directory -- the currently analyzed directory
    files -- list of files in that directory"""

    for name in files:
        fullname = join(directory, name)
        hashes = multi_hash(fullname)
        size = getsize(fullname)
        out.write('"%s","%s","%s",%d' % (hashes[1], hashes[0], fullname, size))
        out.write("\n")


if __name__ == '__main__':
    if len(sys.argv) &lt; 3:
        print "Usage: %s reportfile basepath\n" % sys.argv[0]
        sys.exit(1)

    dir_report(sys.argv[2], sys.argv[1])</pre></div><p>This Python<a id="id72" class="indexterm"/> script is all it takes to generate the integrity<a id="id73" class="indexterm"/> information of a directory tree that includes<a id="id74" class="indexterm"/> file sizes, file names, and hash sums (SHA256, MD5). The following is an example call on our scripting directory:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user@lab:/home/user/dirhash $ python dirhash.py report.txt .</strong></span>
<span class="strong"><strong>user@lab:/home/user/dirhash $ cat report.txt</strong></span>
<span class="strong"><strong>File integrity information</strong></span>

<span class="strong"><strong>Base path:      .</strong></span>
<span class="strong"><strong>Report created: 2015-08-23T21:50:45.460940</strong></span>

<span class="strong"><strong>"SHA-256","MD5","FileName","FileSize"</strong></span>
<span class="strong"><strong>"a14f7e644d76e2e232e94fd720d35e59707a2543f01af4123abc46e8c10330cd","9c0d1f70fffe5c59a7700b2b9bfd50cc","./multihash.py",879</strong></span>
<span class="strong"><strong>"a4168e4cc7f8db611b339f4f8a949fbb57ad893f02b9a65759c793d2c8b9b4aa","bcf5a41a403bb45974dd0ee331b1a0aa","./dirhash.py",1494</strong></span>
<span class="strong"><strong>"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855","d41d8cd98f00b204e9800998ecf8427e","./report.txt",0</strong></span>
<span class="strong"><strong>"03047d8a202b03dfc5a310a81fd8358f37c8ba97e2fff8a0e7822cf7f36b5c83","416699861031e0b0d7b6d24b3de946ef","./multihash.pyc",1131</strong></span>


<span class="strong"><strong>--- END OF REPORT ---</strong></span>
</pre></div><p>However, the resulting report file itself does not have any integrity protection. It is recommended to sign the <a id="id75" class="indexterm"/>resulting report, for example, using <span class="strong"><strong>GnuPG</strong></span>, as shown in the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user@lab:~$ gpg --clearsign report.txt</strong></span>
</pre></div><p>If you have never used <code class="literal">gpg</code> before, you need to generate a private key before you can sign the documents. This can be done with the <code class="literal">gpg --gen-key</code> command. Consult <a class="ulink" href="https://www.gnupg.org/documentation">https://www.gnupg.org/documentation</a> for <a id="id76" class="indexterm"/>more details about GnuPG and its use. This creates an additional <code class="literal">report.txt.asc</code> file containing the original report and a digital signature. Any<a id="id77" class="indexterm"/> subsequent modification <a id="id78" class="indexterm"/>of that file invalidates the <a id="id79" class="indexterm"/>digital signature.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note02"/>Note</h3><p>The techniques described here are merely the examples of how to support the chain of custody. If the forensic analysis is to be used in the court, it is highly recommended to seek legal advice about the chain-of-custody requirements in your legislation.</p></div></div></div></div>
<div class="section" title="Real-world scenarios"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec13"/>Real-world scenarios</h1></div></div></div><p>This<a id="id80" class="indexterm"/> section will demonstrate some use cases where the<a id="id81" class="indexterm"/> preceding algorithms and techniques are used to support the investigator. For this chapter, we use two very common <a id="id82" class="indexterm"/>and interesting examples, <span class="strong"><strong>Mobile Malware</strong></span> and the<a id="id83" class="indexterm"/> <span class="strong"><strong>National Software Reference Library</strong></span> (<span class="strong"><strong>NSRL</strong></span>).</p><div class="section" title="Mobile Malware"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec17"/>Mobile Malware</h2></div></div></div><p>In this example, we will check the installed applications on an Android smartphone against an online analysis system, <span class="strong"><strong>Mobile-Sandbox</strong></span>. Mobile-Sandbox is a website that provides free <a id="id84" class="indexterm"/>Android files checking for viruses or suspicious behavior, <a class="ulink" href="http://www.mobilesandbox.org">http://www.mobilesandbox.org</a>. It is connected to <span class="strong"><strong>VirusTotal</strong></span>, which uses up to <a id="id85" class="indexterm"/>56 different antivirus products and scan engines to check for <a id="id86" class="indexterm"/>viruses that the user's antivirus solution may have missed or verify against any false positives. Additionally, Mobile-Sandbox uses custom <a id="id87" class="indexterm"/>techniques to detect applications that act potentially malicious. Antivirus software vendors, developers, and researchers behind Mobile-Sandbox can receive copies of the files to help in improving their software and techniques.</p><p>In the example, we will use two steps to successfully compare the installed applications with the already tested apps on the Mobile-Sandbox web service.</p><p>The first step is to get the hash sums of the installed applications on the device. This is very important as these values can help to identify the apps and check them against the online services. For this example, we <a id="id88" class="indexterm"/>will use an application from Google Play, <span class="strong"><strong>AppExtract</strong></span> (<a class="ulink" href="https://play.google.com/store/apps/details?id=de.mspreitz.appextract">https://play.google.com/store/apps/details?id=de.mspreitz.appextract</a>). The forensically more correct way of<a id="id89" class="indexterm"/> getting <a id="id90" class="indexterm"/>these values can be found in <a class="link" href="ch06.html" title="Chapter 6. Using Python for Mobile Forensics">Chapter 6</a>, <span class="emphasis"><em>Using Python for Mobile Forensics</em></span>.</p><div class="mediaobject"><img src="graphics/2087_02_01.jpg" alt="Mobile Malware"/></div><p>AppExtract for Android generates a list of installed and running apps with a large amount of metadata that can help in identifying unwanted or even malicious applications. This metadata contains the SHA256 hash sum of the application packages, an indicator whether the app has been installed by the user or the system itself, and a lot of additional data that can help in identifying if the app is benign or not. These lists can be transferred via your favorite email app for further analysis. Once you receive the plain-text email with the generated lists, you just need to copy the list that contains all the installed applications to a CSV file. This file can be used for an automated analysis or opened with <span class="strong"><strong>LibreOffice Calc</strong></span> in <a id="id91" class="indexterm"/>the lab environment. You can see the metadata of the current version of the Chrome Browser for Android in the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Type;App_Name;md5;TargetSdkVersion;Package_Name;Process_Name;APK_Location;Version_Code;Version_Name;Certificate_Info;Certificate_SN;InstallTime;LastModified</strong></span>

<span class="strong"><strong>SystemApp;Chrome;4e4c56a8a7d8d6b1ec3e0149b3918656;21;com.android.chrome;com.android.chrome;/data/app/com.android.chrome-2.apk;2311109;42.0.2311.109;CN=Android, OU=Android, O=Google Inc., L=Mountain View, ST=California, C=US;14042372374541250701;unknown;unknown</strong></span>
</pre></div><p>The second step is to compare the hash sums from the device (third column in our CSV file) with the Mobile-Sandbox database. This can be done with the help of the following script that <a id="id92" class="indexterm"/>we will save as <code class="literal">get_infos_mobilesandbox.py</code>:</p><div class="informalexample"><pre class="programlisting">#!/usr/bin/env python

import sys, requests

# Authentication Parameters
# if you need an API key and user name please contact @m_spreitz
API_FORMAT = 'json'
API_USER = ''
API_KEY = ''

# parsing input parameters
if (len(sys.argv) &lt; 3):
    print "Get infos to a specific Android app from the Mobile-Sandbox."
    print "Usage: %s requests [type (md5,sha256)] [value]" % sys.argv[0]
    sys.exit(0)

# building the payload
payload = {'format':API_FORMAT,
           'username':API_USER,
           'api_key':API_KEY,
           'searchType':str(sys.argv[1]),   # has to be md5 or sha256
           'searchValue':str(sys.argv[2])}

# submitting sample hash and getting meta data
print "--------------------------------"
r = requests.get("http://mobilesandbox.org/api/bot/queue/get_info/", params=payload)

# printing result and writing report file to disk
if not r.status_code == requests.codes.ok:
    print "query result: \033[91m" + r.text + "\033[0m"
else:
    for key, value in r.json().iteritems():
        print key + ": \033[94m" + str(value) + "\033[0m"
print "--------------------------------"</pre></div><p>The script can be used as shown in the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>(labenv)user@lab:~$ ./get_infos_mobilesandbox.py md5 4e4c56a8a7d8d6b1ec3e0149b3918656</strong></span>

<span class="strong"><strong>--------------------------------</strong></span>
<span class="strong"><strong>status: done</strong></span>
<span class="strong"><strong>min_sdk_version: 0</strong></span>
<span class="strong"><strong>package_name: com.android.chrome</strong></span>
<span class="strong"><strong>apk_name: Chrome.apk</strong></span>
<span class="strong"><strong>AV_detection_rate: 0 / 56</strong></span>
<span class="strong"><strong>drebin_score: benign (1.38173)</strong></span>
<span class="strong"><strong>sample_origin: user upload</strong></span>
<span class="strong"><strong>android_build_version: Android 1.0</strong></span>
<span class="strong"><strong>ssdeep: 196608:ddkkKqfC+ca8eE/jXQewwn5ux1aDn9PpvPBic6aQmAHQXPOo:dBKZaJYXQE5u3ajtpvpeaQm1</strong></span>
<span class="strong"><strong>sha256: 79de1dc6af66e6830960d6f991cc3e416fd3ce63fb786db6954a3ccaa7f7323c</strong></span>
<span class="strong"><strong>malware_family: ---</strong></span>
<span class="strong"><strong>md5: 4e4c56a8a7d8d6b1ec3e0149b3918656</strong></span>
<span class="strong"><strong>--------------------------------</strong></span>
</pre></div><p>With the help <a id="id93" class="indexterm"/>of these three tools, it is possible to quickly check if an application on a mobile device is potentially infected (see the highlighted parts in the response) or at least where to start with the manual investigation if an application hasn't been tested before.</p></div><div class="section" title="NSRLquery"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec18"/>NSRLquery</h2></div></div></div><p>To increase <a id="id94" class="indexterm"/>efficiency in the forensic analysis, it is crucial to <a id="id95" class="indexterm"/>sort out any files that belong to known software and have not been modified. The <span class="strong"><strong>National Software Reference Library</strong></span> (<span class="strong"><strong>NSRL</strong></span>) maintains <a id="id96" class="indexterm"/>multiple lists of hash sums for the known content. NSRL is a project of the U.S. Department of Homeland Security, further details are available on <a class="ulink" href="http://www.nsrl.nist.gov/">http://www.nsrl.nist.gov/</a>. It is important to understand that these lists of hash sums merely indicate<a id="id97" class="indexterm"/> that a file was not modified as compared to the version that was submitted to the NSRL. Consequently, it is normal that a lot of files, which are to be analysed during a forensic investigation, are not listed in NSRL. On the other hand, even the listed files can be used and deployed by an attacker as a tool. For example, a tool such as <code class="literal">psexec.exe</code> is a program provided by Microsoft for remote administration and listed in NSRL. Nevertheless, an attacker may have deployed it for his malicious purposes.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip03"/>Tip</h3><p>
<span class="strong"><strong>Which NSRL list should be used?</strong></span>
</p><p>NSRL consists of several hash sets. It is highly recommended to begin with the <span class="emphasis"><em>minimal set</em></span>. This set only contains one hash sum per file, which means only one file version is known.</p></div></div><p>The minimal <a id="id98" class="indexterm"/>set is offered free of charge to download on the NIST homepage. The download consists of a single ZIP file with the hash list and a list <a id="id99" class="indexterm"/>of supported software products as the most prominent contents.</p><p>The hashes are stored in the <code class="literal">NSRLFile.txt</code> file that holds one file hash per line, for example:</p><div class="informalexample"><pre class="programlisting">"3CACD2048DB88F4F2E863B6DE3B1FD197922B3F2","0BEA3F79A36B1F67B2CE0F595524C77C","C39B9F35","TWAIN.DLL",94784,14965,"358",""</pre></div><p>The fields of this record are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The hash sum of the file that is calculated with SHA-1, a predecessor to the SHA-256 algorithm described earlier.</li><li class="listitem" style="list-style-type: disc">The hash sum of the file that is calculated with MD5.</li><li class="listitem" style="list-style-type: disc">The CRC32 checksum of the file.</li><li class="listitem" style="list-style-type: disc">The file name.</li><li class="listitem" style="list-style-type: disc">The file size in bytes.</li><li class="listitem" style="list-style-type: disc">A product code denoting the software product this file belongs to. The <code class="literal">NSRLProd.txt</code> file contains a list of all products and can be used to look up the product code. In the previous example, the code <code class="literal">14965</code> denotes Microsoft Picture It!.</li><li class="listitem" style="list-style-type: disc">The operating system where this file is to be expected. The list of operating system codes can be found in <code class="literal">NSRLOS.txt</code>.</li><li class="listitem" style="list-style-type: disc">An indicator whether this file is to be considered normal (""), a malicious file ("N"), or special ("S"). While this flag is part of the specification, all the files of the current NSRL minimal set are set to be normal.</li></ul></div><p>More details about the file specifications can be found at <a class="ulink" href="http://www.nsrl.nist.gov/Documents/Data-Formats-of-the-NSRL-Reference-Data-Set-16.pdf">http://www.nsrl.nist.gov/Documents/Data-Formats-of-the-NSRL-Reference-Data-Set-16.pdf</a>.</p><div class="section" title="Downloading and installing nsrlsvr"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec01"/>Downloading and installing nsrlsvr</h3></div></div></div><p>Currently, the <a id="id100" class="indexterm"/>NSRL database contains more than 40 million <a id="id101" class="indexterm"/>distinct hashes in the minimal set. A text-based <a id="id102" class="indexterm"/>search <a id="id103" class="indexterm"/>would take minutes, even on an up-to-date workstation. Therefore, it is important to make efficient lookups to that database. Rob Hanson's tool <span class="strong"><strong>nsrlsvr</strong></span> provides a server that supports efficient lookups. It is<a id="id104" class="indexterm"/> available at <a class="ulink" href="https://rjhansen.github.io/nsrlsvr/">https://rjhansen.github.io/nsrlsvr/</a>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note03"/>Note</h3><p>There are also public NSRL servers on the Internet that you can use. These are usually provided on an <span class="emphasis"><em>as is</em></span> basis. However, to test smaller sets of hashes, you may use Robert Hanson's public server <code class="literal">nsrllookup.com</code> and continue reading with the next section.</p></div></div><p>To compile the software on a Linux system, the automake, autoconf, and c++ compiler tools must be installed. The detailed installation instructions including all the requirements are provided in the <code class="literal">INSTALL</code> file.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip04"/>Tip</h3><p>
<span class="strong"><strong>Installing nsrlsvr in a non-default directory</strong></span>
</p><p>The <a id="id105" class="indexterm"/>installation directory of nsrlsvr can be changed by calling the <code class="literal">configure</code> script with the <code class="literal">--prefix</code> parameter. The parameter value denotes the target directory. If a user-writable directory is specified, the installation does not require root privileges and can be completely removed by removing the installation directory.</p></div></div><p>The nsrlsrv maintains its own copy of all the MD5 hash sums of the NSRL database. Therefore, it is required to initialize the hash database. The required nsrlupdate tool is provided with nsrlsrv.</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user@lab:~$ nsrlupdate your/path/to/NSRLFile.txt</strong></span>
</pre></div><p>After the database is fully populated, the server can be started by simply calling:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user@lab:~$ nsrlsvr</strong></span>
</pre></div><p>If everything is installed correctly, this command returns without providing any output and the server starts listening to the TCP port 9120 for requests.</p></div><div class="section" title="Writing a client for nsrlsvr in Python"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec02"/>Writing a client for nsrlsvr in Python</h3></div></div></div><p>There is also<a id="id106" class="indexterm"/> a client tool for using nsrlsvr called <span class="strong"><strong>nsrllookup</strong></span>. The<a id="id107" class="indexterm"/> client is written in C++ and available at <a class="ulink" href="https://rjhansen.github.io/nsrllookup/">https://rjhansen.github.io/nsrllookup/</a>. However, a client for interacting with nsrlsvr can <a id="id108" class="indexterm"/>easily be implemented in native Python. This section explains the protocol and shows a sample implementation of such a client.</p><p>The nsrlsvr implements a text-oriented protocol on its network port 9120. Every command consists of one line of text followed by a newline (CR LF). The following commands<a id="id109" class="indexterm"/> are supported:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>version: 2.0</strong></span>: The version command is used for the initial handshake between the nsrl client and nsrlsvr. The client is supposed to provide its version after the colon. The server will always respond with <code class="literal">OK</code> followed by a line break.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>query</strong></span> <span class="strong"><strong>5CB360EF546633691912089DB24A82EE 908A54EB629F410C647A573F91E80775 BFDD76C4DD6F8C0C2474215AD5E193CF</strong></span>: The query command is used for actually querying the NSRL database from the server. The keyword <span class="strong"><strong>query</strong></span> is followed by one or multiple MD5 hash sums. The server will respond with <code class="literal">OK</code> followed by a sequence of zeroes and ones. A <code class="literal">1</code> indicates that the MD5 hash sum was found in the database and a <code class="literal">0</code> indicates that there was no match. For example, the query shown previously would lead to the following answer:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>OK 101</strong></span>
</pre></div><p>This means that the first and the last MD5 hashes were found in NSRL, but the middle hash sum could not be found.</p></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>BYE</strong></span>: The bye command terminates the connection to the nsrlsvr.</li></ul></div><p>Consequently, the following Python routine is sufficient to efficiently query the NSRL database:</p><div class="informalexample"><pre class="programlisting">#!/usr/bin/env python

import socket

NSRL_SERVER='127.0.0.1'
NSRL_PORT=9120

def nsrlquery(md5hashes):
    """Query the NSRL server and return a list of booleans.

    Arguments:
    md5hashes -- The list of MD5 hashes for the query.
    """

    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((NSRL_SERVER, NSRL_PORT))

    try:
        f = s.makefile('r')
        s.sendall("version: 2.0\r\n")
        response = f.readline();
        if response.strip() != 'OK':
            raise RuntimeError('NSRL handshake error')

        query = 'query ' + ' '.join(md5hashes) + "\r\n"
        s.sendall(query)
        response = f.readline();

        if response[:2] != 'OK':
            raise RuntimeError('NSRL query error')

        return [c=='1' for c in response[3:].strip()]
    finally:
        s.close()</pre></div><p>Using this <a id="id110" class="indexterm"/>module is as easy as shown here:</p><div class="informalexample"><pre class="programlisting">import nsrlquery
hashes = ['86d3d86902b09d963afc08ea0002a746',
          '3dcfe9688ca733a76f82d03d7ef4a21f',
          '976fe1fe512945e390ba10f6964565bf']
nsrlquery.nsrlquery(hashes)</pre></div><p>This code queries the NSRL server and returns a list of booleans, each indicating whether the corresponding MD5 hash has been found in the NSRL file list.</p></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec14"/>Summary</h1></div></div></div><p>This chapter provided an overview of the domains of the forensic and example algorithms for each of these domains. We also showed you how to compare applications installed on an Android device with web services such as <span class="strong"><strong>Mobile-Sandbox</strong></span>. In the second real-world example, we demonstrated how to sort out benign and known files from a Windows system to reduce the amount of data that is to be analyzed manually. With <span class="strong"><strong>NSRLquery</strong></span>, the forensic investigations can focus on new or modified content and do not need to waste time on the widely known content of standard applications.</p><p>In the following chapters, these algorithms will be applied to a selection of device types, operating systems, and applications for use during forensic investigation.</p></div></body></html>