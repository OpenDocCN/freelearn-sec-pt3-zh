- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Threat Hunting with Wazuh
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Approximately 80% of threats can be mitigated with the assistance of tier 1
    and 2 **security operations center** (**SOC**) analysts and automated security
    tools; the remaining 20% requires your attention. Threat hunting is an important
    proactive security method for finding threats and holes in security that are hard
    to spot with regular security measures. Threat hunting uses advanced analytics,
    threat intelligence, and human expertise to go beyond automated detection and
    actively seek, find, and fix any security holes or threats that might be hiding
    in an organization’s network. By being proactive, security teams can spot and
    stop complex threats before they happen. This reduces the time that attackers
    can stay on the network and stops possible breaches. In this chapter, we will
    learn how Wazuh can help security teams to proactively detect advanced threats.
    Wazuh offers an extensive overview of an organization’s security features by analyzing
    large amounts of logs, along with offering real-time monitoring, custom advanced
    rulesets, threat intelligence, MITRE ATT&CK mapping, and much more.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Proactive threat hunting with Wazuh
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Log data analysis for threat hunting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MITRE ATT&CK mapping on Wazuh
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Threat hunting using Osquery
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Command monitoring
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Proactive threat hunting with Wazuh
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Organizations can use Wazuh for proactive threat hunting, a security practice
    that helps them find and report possible security threats before they become significant
    threats. This can take the form, for example, of analyzing network traffic patterns
    to detect anomalous behavior that may indicate a potential cyber threat. By contrast,
    the main goal of reactive cybersecurity defenses is to react to threats once they
    are identified or after an incident has taken place. As an example, antivirus
    software detects and eradicates known malware, and firewalls prevent malicious
    traffic from entering the network based on predefined rules by the security team.
  prefs: []
  type: TYPE_NORMAL
- en: When you do proactive threat hunting, you look for possible risks or weaknesses
    in a network before any damage can be caused. Instead of waiting for alerts or
    known signatures, we can use Wazuh to conduct threat hunting by performing real-time
    log analysis across multiple platforms, correlating events to detect potential
    security issues, along with integrating third-party tools to enhance our event
    visibility and detection capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Threat-hunting methodologies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Threat-hunting steps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use Wazuh for proactive threat hunting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Threat-hunting methodologies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When threat hunters look into a system, they assume that attackers are already
    there and look for strange behavior that could indicate that bad things are happening.
    While conducting proactive threat hunting, the first step of looking for a threat
    usually falls into three main categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Hypothesis-based investigation**: Threat hunters often start hypothesis-based
    investigations when they find a new threat within the pool of attack information.
    This gives them information about the newest **tactics, techniques, and procedures**
    (**TTPs**) that attackers are using. Once threat hunters have found a new TTP,
    they check whether the attacker’s unique behaviors are common in their own area.
    For this, our Wazuh platform needs the following configured:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: File integrity monitoring rules to detect any unauthorized changes
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Enabling rootkits behavior detection
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Log collection from different security solutions such as Antivirus, **Endpoint
    Detection and Response** (**EDR**), and email security
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Vulnerability detection
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Command monitoring
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Intelligence-based hunting**: Intelligence-based hunting is a way to actively
    look for threats in response to different sources of intelligence. IOCs, IP addresses,
    hash values, and domain names are some of the threat intelligence sources that
    you can exploit. In order to accomplish this, Wazuh should be integrated with
    the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Third-party threat intelligence tools such as VirusTotal or AbuseIPDB
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: MISP
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: OpenCTI
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Host or network artifacts from **computer emergency response teams** (**CERTs**)
    or **information sharing and analysis centers** (**ISACs**) allow you to export
    automated warnings or communicate crucial information about fresh threats in other
    businesses. These are mostly paid services, but they do offer highly curated information.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Investigation using **indicators of attack** (**IOA**): This is one of the
    most popular and widely used methods for threat hunting. The idea is simple: “Not
    every threat group is after you” or even if they are, why you should prioritize
    them. The first step is to identify the threat group based on its target location,
    industry, and software by using a free detection playbook called **ATT&CK Navigator**.
    This online platform is built by MITRE, a not-for-profit organization that operates
    **Federally Funded Research and Development Centers** (**FFRDCs**) in the United
    States.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Threat-hunting steps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A proactive threat-hunting method consists of three stages: the *initial trigger
    phase*, the *investigation phase*, and the *resolution phase* (or, in some situations,
    an escalation to other teams as part of a communications or action plan). Let’s
    examine these three steps of the threat-hunting process in more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Choosing the** **right trigger**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Threat hunting is usually an in-depth effort. The threat hunter gathers data
    about the environment and formulates hypotheses on potential threats.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, the threat hunter selects a trigger for further investigation. This might
    be a specific system, an area of the network, a hypothesis brought on by a disclosed
    vulnerability or patch, knowledge of a zero-day exploit, an abnormality seen in
    the security dataset, or a request coming from another department within the company.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Investigation**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After a trigger has been identified, the hunt continues to focus on proactively
    looking for anomalies that support or contradict the theoretical threat.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The threat hunter works with the assumption that “*My network is compromised
    by a new malware or exploit*” and conducts reverse engineering to prove the assumption.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Threat hunters employ a variety of tools to help them analyze logs from multiple
    devices and security controls including server logs, Sysmon, antivirus logs, and
    spam filter logs.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resolution** **and reporting**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'During the investigative phase, threat hunters gather crucial information and
    provide answers to the following questions:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Who?* – i.e., perhaps an insider threat was involved'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*What?* – A timeline of incidents in chronological order'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Where?* – Details of the affected system including computers and servers'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Why?* – A lack of security controls, poor planning, human error, an external
    attack, and so on'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: This information is circulated to other teams and tools during the resolution
    phase so that they may respond, prioritize, analyze, or retain the data for future
    use.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Proactive threat hunting with Wazuh
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Proactive threat hunting with Wazuh entails an ongoing and methodical search
    for indicators of potential security threats in the environment of your organization.
    To conduct threat hunting, Wazuh can be leveraged by security teams for comprehensive
    log data analysis, seamless integration with MITRE ATT&CK, and the utilization
    of Osquery (an endpoint analytics tool) and regular monitoring. Let’s cover each
    of these Wazuh capabilities in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Log data analysis**: Threat detection is significantly more effective when
    log data generated by various devices and systems within an organization is analyzed.
    Wazuh functions as a centralized platform for log management and analysis, receiving
    and examining data from a wide range of origins, including endpoints, servers,
    and network devices. In order to conduct a log analysis of each of the devices
    in your network, you need to have decoders for each of them. Wazuh extracts meaningful
    information from log data obtained from various sources using decoders.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**MITRE ATT&CK mapping**: The internationally acclaimed MITRE **Adversarial
    Tactics, Techniques, and Common Knowledge** (**ATT&CK**) framework offers a thorough,
    current knowledge base on adversary tactics and techniques. Wazuh uses MITRE ATT&CK
    to map observed security events to certain ATT&CK approaches, improving threat-hunting
    capabilities. Security teams can gain a better understanding of prospective adversaries’
    strategies by using this mapping.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Osquery integration**: An open-source, cross-platform endpoint security framework
    called Osquery enables organizations to communicate with and query their endpoint
    devices to obtain important data for threat hunting. Wazuh and Osquery combine
    to give an organization’s endpoints a comprehensive picture with endpoint visibility
    and live querying.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Command monitoring**: You can use Wazuh’s command tracking feature to track
    the output of certain commands and treat that output as log content. Command monitoring
    can be used for threat hunting to monitor many system properties, such as disk
    space usage, load averages, changes in network listeners, and the state of processes
    that are already running.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s get some deeper and more practical knowledge of Wazuh’s log data analysis
    functionality. This capability of Wazuh helps us to perform manual threat hunting
    by analyzing tons of log information.
  prefs: []
  type: TYPE_NORMAL
- en: Log data analysis for threat hunting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Log data analysis** is a critical component of threat hunting. It involves
    inspecting and retrieving useful information from log files generated by various
    systems, applications, and devices. Traditional security methods may miss suspicious
    patterns or events, but threat hunters can detect them through constant monitoring
    and analysis of logs. Threat hunters examine log data in search of certain **Indicators
    of Compromise** (**IOCs**). These IOCs could be domain names, IP addresses, file
    hashes, or other identifiers linked to known security risks. The problem is that
    not all logs are the same. Depending on the source of the logs you want to gather,
    you may need to create a tailored Wazuh decoder. In this section, we will review
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Wazuh decoders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building decoders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Log collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Log data analysis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wazuh decoders
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **Wazuh decoder** is a component that interprets and extracts useful information
    from raw log data. It collects data from log files or events created by many sources,
    such as operating systems, applications, and network devices, and converts it
    into a standardized format that can easily be analyzed and related. We don’t have
    to create decoders every time we onboard a new endpoint as Wazuh has a selection
    of prebuilt decoders for sources such as Linux, Windows, and macOS.
  prefs: []
  type: TYPE_NORMAL
- en: Wazuh decoders are normally provided as XML files and stored at `/var/ossec/etc/decoders`.
    Each decoder is tailored to a certain log source such as `0025-apache_decoders.xml`
    for Apache, `0100-fortigate_decoders.xml` for FortiGate firewalls, and so on.
    These decoders specify how to parse log data, extract pertinent information (such
    as timestamps, IP addresses, user IDs, and so on), and transform it into a structured
    format suitable for security analysis and threat hunting. Wazuh decoders are extremely
    customizable, allowing users to create custom decoders for specific log sources
    as needed.
  prefs: []
  type: TYPE_NORMAL
- en: Building decoders
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Creating a custom Wazuh decoder begins with the creation of an XML file that
    explains how to decode and parse log data from a given source. If you want to
    build a custom decoder, you need to first take a look at an example event from
    the source. For example, let’s take a Check Point Firewall log from the decoder
    file available on GitHub at [https://github.com/wazuh/wazuh-ruleset/blob/master/decoders/0050-checkpoint_decoders.xml](https://github.com/wazuh/wazuh-ruleset/blob/master/decoders/0050-checkpoint_decoders.xml):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have the log, pay close attention to its format. Divide your log into
    two parts: *prematch* and *custom match*. `Jan 21 15:15:45 myCP Checkpoint: 21Jan2019
    15:15:45`. Second, the **custom match** section varies every time. We can also
    call these the *parent decoder* and *child decoder* respectively. Let’s begin
    by writing the prematch decoder first.'
  prefs: []
  type: TYPE_NORMAL
- en: Parent decoder
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When creating a Wazuh decoder, it is a good practice to create a parent decoder
    and then a child decoder to simplify and organize the decoder rules in a file.
    The parent decoder usually consists of the date, time, and device name, and the
    child decoder consists of a specific pattern match. To extract the relevant information
    from the logs, we need to use a regular expression. A regular expression is a
    sequence of characters defining a search. The parent decoder is defined using
    the following `<``prematch>` tags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding regular expression, we can see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The `\d` operator is used to denote numeric characters from 0 to 9 for the time
    field.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `\s` operator is used to represent alphabetical characters from `a` to `z`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Child decoder
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following decoder rule already exists in the Wazuh decoder ruleset with
    the filename `0050-checkpoint_decoders.xml`. To extract further information from
    the Check Point firewall log, multiple decoder rules have to be created. These
    are used to extract items such as the source IP address, destination IP address,
    source port, destination port, and service. All the rules must start with the
    parent decoder “`checkpoint-syslog`”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'While you are building your decoder, you can get help from the Wazuh built-in
    decoder validator module by running `/var/ossec/bin/wazuh-logtest`. You can also
    perform this test on the Wazuh dashboard by navigating to **Ruleset Test** under
    the **Tools** section. Once you execute the module, you need to enter your original
    Check Point log:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1 – Executing Wazuh’s decoder validator](img/B19549_6_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.1 – Executing Wazuh’s decoder validator
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding screenshot, we can see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The phase 1 output shows the pre-decoding, which simply takes the log and processes
    it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The phase 2 and phase 3 output shows that the decoder name `checkpoint-syslog-ids`
    has been detected properly and we receive information such as `srcip`, `dstip`,
    protocol, and `extra_data`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After creating both the parent and child decoders, we need to create a Wazuh
    rule to trigger an alert once there is a match.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Wazuh rules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Wazuh rules examine the extracted decoder fields to determine the type of message
    received. The final rule that is matched determines whether an alert is created,
    as well as its level and category groups. For any event that triggers the Check
    Point FW decoders, the following grouping rule will issue an alert:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, `<decoded_as>` represents the name of the decoder.
  prefs: []
  type: TYPE_NORMAL
- en: Alright, we have learned to create a decoder and the corresponding Wazuh rule,
    taking a Check Point firewall log as an example. Once you have a decoder, you
    can then create a Wazuh rule. If there is a match against any of the events received
    by the Wazuh manager, it will generate a security alert on the dashboard. To conduct
    a comprehensive threat-hunting program, all types of events have to be available
    on the Wazuh platform and hence, building a custom decoder should also be part
    of this process. In the next section, we will learn how Wazuh collects and categorizes
    different types of log data.
  prefs: []
  type: TYPE_NORMAL
- en: Log data collection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Log data collection** means getting logs from different network sources and
    putting them all together. It is critical for threat hunters to access all types
    of logs from across endpoints, servers, security devices, and so on. The Wazuh
    indexer is responsible for log analysis as it stores and indexes alerts generated
    by the Wazuh server. By default, Wazuh will give you alerts that are triggered
    by Wazuh rules. However, we need access to all the events for better threat-hunting
    practice. We will learn to pull out all the events and archive them on the Wazuh
    server. Let’s first discuss the different indices used to store our event types.'
  prefs: []
  type: TYPE_NORMAL
- en: wazuh-alerts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is the default index that stores the alerts generated by the Wazuh server.
    When normal events get triggered by a rule with high priority, we see the alert
    and it gets stored in the `wazuh-alerts` index.
  prefs: []
  type: TYPE_NORMAL
- en: All the information in the `wazuh-alerts` index. To see the `wazuh-alerts` index,
    navigate to the `wazuh-alerts` index will be selected.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2 – wazuh-alerts index](img/B19549_6_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.2 – wazuh-alerts index
  prefs: []
  type: TYPE_NORMAL
- en: wazuh-archives
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This index keeps track of all events that come in from the Wazuh server, even
    if they don’t set off alerts. The `wazuh-archives` index stores logs and allows
    queries that give more information about what’s happening on monitored endpoints.
    `wazuh-archives` is disabled by default to save space on the Wazuh server. Remember,
    to run an effective threat-hunting program, it is crucial to enable this index.
    Please follow these steps to turn it on, and once it is configured, two new files
    will be created to store all the events, `/var/ossec/logs/archives/archives.log`
    and `/var/ossec/logs/archives/archives.log`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/var/ossec/etc/ossec.conf` file, set the value of `<logall>` and `<logall_json>`
    to `yes`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Restart the Wazuh manager**: In order for the Wazuh manager to put into effect
    your changes, you are required to restart it with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: wazuh-archives index, go to Stack management > index patterns and click on Create
    index pattern.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 6.3 – Create index pattern](img/B19549_6_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.3 – Create index pattern
  prefs: []
  type: TYPE_NORMAL
- en: '`wazuh-archives-*` index pattern to match all available indices, as shown in
    the following screenshot, and click on **Next step**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.4 – Define index pattern](img/B19549_6_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.4 – Define index pattern
  prefs: []
  type: TYPE_NORMAL
- en: '`timestamp` in the **Time** **field** box.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.5 – Set primary time field](img/B19549_6_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.5 – Set primary time field
  prefs: []
  type: TYPE_NORMAL
- en: '**View the dashboard**: Now, to view the events on the dashboard, navigate
    to **Discover** under **OpenSearch Dashboards**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.6 – Discover under the OpenSearch Dashboards menu](img/B19549_6_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.6 – Discover under the OpenSearch Dashboards menu
  prefs: []
  type: TYPE_NORMAL
- en: Make sure you select the **wazuh-archives** index and finally, we get all the
    events.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.7 – Select wazuh-archives](img/B19549_6_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.7 – Select wazuh-archives
  prefs: []
  type: TYPE_NORMAL
- en: wazuh-monitoring
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This index keeps track of information about the state of Wazuh agents over time.
    The Wazuh agent’s state could be *Pending*, *Active*, *Disconnected*, or *Never
    Connected*. This information is very helpful for finding Wazuh agents that aren’t
    reporting to the dashboard for a number of reasons that need to be looked into.
    If you want to see all the events from the `wazuh-monitoring` index, navigate
    to **Discover** and then change the index to **wazuh-monitoring**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.8 – Select wazuh-monitoring](img/B19549_6_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.8 – Select wazuh-monitoring
  prefs: []
  type: TYPE_NORMAL
- en: Everything you see under the **Agents** tab comes from the wazuh-monitoring
    index.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.9 – Wazuh Agents tab](img/B19549_6_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.9 – Wazuh Agents tab
  prefs: []
  type: TYPE_NORMAL
- en: wazuh-statistics
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This index holds information about the Wazuh server’s overall performance. This
    information is very important for making sure that the Wazuh server uses its computing
    resources in the best way possible.
  prefs: []
  type: TYPE_NORMAL
- en: Log data analysis
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Log data analysis is a critical component of threat hunting because it gives
    you a lot of information about the activities of systems, and networks. This information
    helps you find security threats early, spot unusual activity and also helps you
    find IOCs. Also note that log collection and log analysis are also important in
    incident response, forensic investigations, security compliance, and many more
    areas. Let’s do some live testing with our `wazuh-archives` log events. We will
    run some notable MITRE ATT&CK techniques on Windows Server 2012 Server using APT
    Simulator and then we will conduct some log data analysis. Let’s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Prerequisites
  prefs: []
  type: TYPE_NORMAL
- en: You will need Windows Server 2012 or higher.
  prefs: []
  type: TYPE_NORMAL
- en: '**Sysmon installation**: In this first step, we need to install Sysmon and
    integrate it with Wazuh. Please refer to [*Chapter 2*](B19549_02.xhtml#_idTextAnchor042)*,
    Malware Detection Using Wazuh*, the *Integrating Sysmon to detect fileless malware*
    section in particular, as it covers the step-by-step process to install Sysmon
    on Windows machines.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`APTSimulator-0.9.4` folder, and execute the `APTSimulator.bat` file.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type `0`. This will run every test including collection, command and control,
    credential access, defense evasion, discovery, execution, lateral movement, persistence,
    and privilege escalation.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`agent.id`. In my case, `agent.id` is `002`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.10 – Visualizing APT alerts](img/B19549_6_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.10 – Visualizing APT alerts
  prefs: []
  type: TYPE_NORMAL
- en: We have learned to create custom decoders, covered the different Wazuh log data
    indices, and analyzed the log data. In the next section, we will explore the MITRE
    ATT&CK framework and how Wazuh maps the MITRE ATT&CK tactics and techniques.
  prefs: []
  type: TYPE_NORMAL
- en: MITRE ATT&CK mapping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We cannot begin threat hunting by assuming everyone in the world is after us.
    We need a targeted threat actor or threat campaign-based approach. This is where
    both Wazuh and MITRE ATT&CK become helpful. Wazuh can collect and trigger any
    alerts, but for threat hunting, we need to focus on relevant and high-priority
    threats to our business and need to map this to our Wazuh rules. The MITRE ATT&CK
    framework helps threat hunters to focus on these kinds of threats and Wazuh allows
    us to map each of the techniques of those threat actors to Wazuh rules. As a result,
    threat hunters can hone their focus and save tremendous amounts of time. In this
    section, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What is MITRE ATT&CK?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ATT&CK framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prioritizing the adversary’s techniques
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MITRE ATT&CK mapping
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is MITRE ATT&CK?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **MITRE ATT&CK** framework was developed by the MITRE Corporation to provide
    a uniform taxonomy for analyzing and categorizing cyber threats. It provides a
    common language that both defensive and offensive teams in security operations
    can utilize to improve their capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Tactics, techniques, and procedures (TTPs)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The **MITRE ATT&CK framework** is used to categorize and comprehend cyber attackers’
    **tactics, methods, and procedures** (**TTPs**) during security operations. TTPs
    are used for organizing threat intelligence, threat detection, building an effective
    incident response, conducting a security gap analysis, and threat hunting. Let’s
    first understand what the TTP concept involves:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Tactics**: These are the main modes of action that attackers use to reach
    their targets. Consider tactics as the “*what*” of an attack, such as gaining
    initial access or causing damage.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Techniques**: Techniques are precise ways or acts that attackers use to carry
    out their tactics. They are the “*how*” of an attack, outlining the processes
    or tools utilized to achieve an objective.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Procedures**: Procedures involve greater levels of specificity and detail
    in comparison to techniques. Procedures are like “*step-by-step instructions*”
    for carrying out an attack.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ATT&CK framework
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'MITRE ATT&CK is made up of several critical components that work together to
    provide a thorough understanding of adversary TTPs:'
  prefs: []
  type: TYPE_NORMAL
- en: Matrices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tactics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Techniques
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Procedures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Groups
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Software
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Matrices
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The ATT&CK framework has three matrices: *Enterprise*, *Mobile*, and *Cloud*.
    The Enterprise Matrix is the most widely used matrix in the ATT&CK framework.
    Let’s understand some of the technologies covered under each of these matrices
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.11 – MITRE ATT&CK matrices](img/B19549_6_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.11 – MITRE ATT&CK matrices
  prefs: []
  type: TYPE_NORMAL
- en: The Enterprise Matrix contains information about platforms such as Windows,
    macOS, Azure, Office 365, SaaS, IaaS, network, and cloud
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Mobile Matrix covers techniques used by adversaries related to Android or
    iOS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ICS covers industrial control system-related tactics and techniques
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Throughout this chapter, our primary focus will be on the Enterprise Matrix.
  prefs: []
  type: TYPE_NORMAL
- en: Tactics
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: MITRE ATT&CK provides 14 **tactics** that consist of several sets of techniques.
    In the following screenshot, you can see at the top of each column all of the
    tactics, and under each tactic column, you can find several techniques.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.12 – MITRE ATT&CK Tactics](img/B19549_6_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.12 – MITRE ATT&CK Tactics
  prefs: []
  type: TYPE_NORMAL
- en: Techniques
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Techniques** are specific means or procedures used by opponents to carry
    out tactics. For example, under the *Execution tactic*, you might find techniques
    such as *Command-Line Interface* or *Scripting*. Visit [attack.mitre.org](http://attack.mitre.org)
    and click on any technique to display a list of sub-techniques. As an example,
    I selected the **Reconnaissance** tactic, then under that I clicked on the **Gather
    Victim Network Information** technique, and as a result, I got six sub-techniques:
    **Domain Properties**, **DNS**, **Network Trust Dependencies**, **Network Topology**,
    **IP Addresses**, and **Network Security Appliances** as shown in the following
    screenshot.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.13 – MITRE ATT&CK techniques](img/B19549_6_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.13 – MITRE ATT&CK techniques
  prefs: []
  type: TYPE_NORMAL
- en: Procedures
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Procedures** describe step by step and in detail how adversaries perform
    various techniques. In our preceding example, we got six sub-techniques. Click
    on any of those sub-techniques and you will land on a page with a list of example
    procedures.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.14 – MITRE ATT&CK procedures](img/B19549_6_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.14 – MITRE ATT&CK procedures
  prefs: []
  type: TYPE_NORMAL
- en: Groups
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Groups** are sets of threat actors or cybercriminal organizations that are
    known to use specific TTPs. You can refer to a list of all threat actors documented
    by MITRE ATT&CK at [https://attack.mitre.org/groups/](https://attack.mitre.org/groups/).'
  prefs: []
  type: TYPE_NORMAL
- en: Software
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Software** lists the exact pieces of malware, tools, and software that attackers
    use to carry out their objectives. This helps threat hunters to identify the threat
    group based on the tools they use.'
  prefs: []
  type: TYPE_NORMAL
- en: Prioritizing the adversary’s techniques
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'ATT&CK Navigator is a powerful analytical tool developed by MITRE as a part
    of the MITRE ATT&CK framework. It provides a web-based interactive interface,
    helping threat hunters and security professionals to explore, visualize, and prioritize
    techniques used by threat actors. ATT&CK Navigator also helps in aligning security
    controls against known adversary techniques. You can access the tool at [https://mitre-attack.github.io/attack-navigator/](https://mitre-attack.github.io/attack-navigator/):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.15 – ATT&CK Navigator](img/B19549_6_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.15 – ATT&CK Navigator
  prefs: []
  type: TYPE_NORMAL
- en: 'The numbers in the preceding screenshot refer to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**1** is **layer**, used to create multiple ATT&CK framework layers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**2** is **section controls**, which gives the following options:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selection behavior
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A search button for selecting techniques, threat groups, software, campaigns,
    data sources, and more
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The option to deselect all techniques
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**3** is **layer controls**, which have the following options:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The option to add metadata information to each layer, including a name, description,
    and other custom metadata
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Download the layer in JSON format
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Export the layer in XML format
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Download the layer in SVG format
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A filter option to display techniques based on Linux, macOS, Windows, containers,
    and so on
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Sorting the techniques based on AI
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Color setup: You can choose a specific color for certain tactics on the interface'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**4** is **technique controls**, which is useful to mark specific techniques
    with a color and score. We will use this feature when we combine multiple layers
    to identify overlapping techniques of multiple threat actors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Practical use case using MITRE ATT&CK
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let me take you through a practical use case to perform threat hunting using
    MITRE ATT&CK. Imagine yourself as a threat hunter working for a financial services
    organization based in the United States. After doing some research on the **Groups**
    page ([https://attack.mitre.org/groups/](https://attack.mitre.org/groups/)) of
    the MITRE ATT&CK official website, you settled on two relevant threat actors that
    target financial services organizations based in the United States. These are
    APT19 and APT38\. (Remember, this is only an example – I suggest you do your research
    based on your specific industry, software, target countries, and so on.) To discover
    the priority techniques, we need to find common techniques used by both APT19
    and APT38\. To do this, we need to customize the ATT&CK Navigator layers as explained
    in the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open ATT&CK Navigator, click **Create New Layer**, and then select **Enterprise**
    as shown in the following screenshot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.16 – Create a new layer in ATT&CK Navigator](img/B19549_6_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.16 – Create a new layer in ATT&CK Navigator
  prefs: []
  type: TYPE_NORMAL
- en: Click the search button under **section controls** and search for **APT19**
    under **Threat Groups**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.17 – Select APT19 from Threat Groups](img/B19549_6_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.17 – Select APT19 from Threat Groups
  prefs: []
  type: TYPE_NORMAL
- en: Next, click the layer information button under `APT19` with the description
    `TTPs of APT19 - Initial` `threat analysis`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.18 – Enter basic information about the layer](img/B19549_6_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.18 – Enter basic information about the layer
  prefs: []
  type: TYPE_NORMAL
- en: Next, set the color of the APT19 techniques to red. To do this, click on the
    background color button under **technique controls**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.19 – Apply a color to the APT19 techniques](img/B19549_6_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.19 – Apply a color to the APT19 techniques
  prefs: []
  type: TYPE_NORMAL
- en: Next, click on scoring under `1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.20 – Set a score for the APT19 techniques](img/B19549_6_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.20 – Set a score for the APT19 techniques
  prefs: []
  type: TYPE_NORMAL
- en: 'Repeat the same steps for APT38 with the following details:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new layer.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the search button under `APT38` with the description `TTPs of APT38 -
    Initial` `threat analysis`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the color of the APT38 techniques to green by clicking on the background
    color button under `2`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The final APT38 layer will look like the following.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 6.21 – APT38 layer](img/B19549_6_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.21 – APT38 layer
  prefs: []
  type: TYPE_NORMAL
- en: Now, merge both layers to get the common techniques used by both APT19 and APT38\.
    This will help us to prioritize the adversary’s techniques. Click on **Create
    New Layer** and then click on **Create Layer from** **other layers**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.22 – Create Layer from other layers](img/B19549_6_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.22 – Create Layer from other layers
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the following information:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Enterprise` `ATT&CK v13`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`a+b`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can leave everything else blank, then click on the **Create** button at
    the bottom.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.23 – Provide the domain and set expression](img/B19549_6_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.23 – Provide the domain and set expression
  prefs: []
  type: TYPE_NORMAL
- en: Once you click on **Create**, you will find a new layer with red techniques
    from APT19, yellow techniques from APT38, and green techniques that are common
    to both APT groups, as shown in the following screenshot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.24 – Layers showing techniques from APT19 and APT38](img/B19549_6_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.24 – Layers showing techniques from APT19 and APT38
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on the final layers, there are four common techniques. The threat hunter
    could now start their hunting process by focusing on these four techniques:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Drive-by Compromise** with technique ID T1189 under the **Initial** **Access**
    tactic'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Modify Registry** with technique ID T1112 under the **Defense** **Evasion**
    tactic'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**System Information Discovery** with technique ID T1082 under the **Discovery**
    tactic'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**System Owner/User Discovery** with technique ID T1033 under the **Discovery**
    tactic'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wazuh MITRE ATT&CK mapping
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Wazuh maps the security events in the environment to the MITRE ATT&CK framework’s
    TTPs. Wazuh helps security teams by matching them with known threat groups’ TTPs.
    In order to map a MITRE ATT&CK technique ID to a specific Wazuh event, you need
    to add the `<mitre>` tag under the given rule. For example, if you want to create
    a Wazuh rule to associate SSH brute-force attacks with MITRE technique ID T1110,
    you will use the following rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: You can also verify all the security events related to MITRE ID T1110 by going
    to the MITRE ATT&CK module in Wazuh and searching for **T1110** under **Techniques**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.25 – MITRE ATT&CK visualization in Wazuh](img/B19549_6_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.25 – MITRE ATT&CK visualization in Wazuh
  prefs: []
  type: TYPE_NORMAL
- en: Once you click on **T1110**, you will see all the security events associated
    with this MITRE ID, as shown in the following screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.26 – Security events related to MITRE ATT&CK technique ID T1110](img/B19549_6_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.26 – Security events related to MITRE ATT&CK technique ID T1110
  prefs: []
  type: TYPE_NORMAL
- en: We have learned to prioritize techniques using ATT&CK Navigator and created
    a Wazuh rule mapped to a MITRE ATT&CK technique ID. This helps security teams
    and threat hunters to discover triggers to start their investigations. In the
    next section, we will learn to utilize the Osquery tool to conduct comprehensive
    threat hunting.
  prefs: []
  type: TYPE_NORMAL
- en: Threat hunting using Osquery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When it comes to threat hunting, we need in-depth visibility of endpoint activities
    and the ability to run queries to allow the threat hunter to retrieve IOCs, suspicious
    activities, and vulnerabilities in a given endpoint. **Osquery** is the ideal
    tool for this purpose. It helps threat hunters treat their entire IT infrastructure,
    including endpoints, as a structured database that can be queried using SQL-like
    commands. You can get real-time, detailed information about your systems with
    Osquery and keep an eye on them for signs of compromise. In this section, we will
    cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What is Osquery?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing Osquery
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating Osquery with Wazuh
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Threat hunting with Osquery and Wazuh
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is Osquery?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Osquery** is an open-source tool built by Facebook in 2014\. It converts
    the target operating system into a relational database and allows us to ask questions
    from the table using SQL queries containing things such as information about the
    state of remote machines, running processes, active user accounts, active network
    connections, and much more. Osquery can be installed on Windows, Linux, macOS,
    and FreeBSD.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Osquery is heavily used by security analysts, **digital forensic and incident
    response** (**DFIR**) analysts, and threat hunters. Before we discuss how threat
    hunters can utilize Osquery with Wazuh, let me first share with you some simple
    use cases of Osquery:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Use case #1 – query for the top 10 largest processes by resident** **memory
    size**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To get the list of the top 10 largest processes by memory size, use this query:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 6.27 – Result of top 10 largest processes by memory size](img/B19549_6_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.27 – Result of top 10 largest processes by memory size
  prefs: []
  type: TYPE_NORMAL
- en: '**Use case #2 – query the list of the top 10 most active processes with** **process
    counts**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this use case, we will utilize Osquery to retrieve from the system the top
    10 active processes based on their frequency and process count. The query is as
    follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Once the query is executed, you will get the result in the form of a table with
    the process names and corresponding frequencies. The output is shown in the following
    screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.28 – Result of the top 10 most active processes with process counts](img/B19549_6_28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.28 – Result of the top 10 most active processes with process counts
  prefs: []
  type: TYPE_NORMAL
- en: Before we integrate Osquery with Wazuh, we need to install Osquery in each of
    the individual Wazuh agents.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Osquery
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The process of installing Osquery is different for each platform. In this section,
    we will cover the installation of Osquery on an Ubuntu machine and a Windows machine.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Osquery on Ubuntu Server/Desktop
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Installation of Osquery on the Ubuntu Server requires the OSQUERY KEY and downloading
    the official Osquery package, explained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`OSQUERY_KEY` to store the GPG key used to validate the Osquery package’s authenticity.
    This key is required to confirm that the packages you download are from a reliable
    source:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: apt-key adv --keyserver keyserver.ubuntu.com --recv-keys $OSQUERY_KEY
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Add the Osquery repository and update** **the package**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, you must add the Osquery repository to the list of software sources on
    your system. The Osquery package will be installed from this repository:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: apt-get install osquery
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Installing Osquery on Windows
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Installing Osquery on Windows desktops is pretty simple. Please visit the official
    website of Osquery and download the packages. The website is [https://www.osquery.io/](https://www.osquery.io/).
  prefs: []
  type: TYPE_NORMAL
- en: Integrating Osquery with Wazuh
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The good news is that Wazuh is already integrated with Osquery. We just need
    to enable it and make some minor changes to the Osquery configuration file. Follow
    these steps to complete the installation:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ossec.conf` file in the Wazuh agent and change the `<disabled>` tag value
    to `no` under <`wodle name="osquery"`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the preceding code, we can see the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`<log_path>` represents the location of the Osquery logs'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<config_path>` shows the location of the Osquery configuration file'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/opt/osquery/share/osquery/osquery.example.conf`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let’s copy the file to `/etc/osquery/osquery.conf` using the `cp` command:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '"packs": {'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"osquery-monitoring": "/opt/osquery/share/osquery/packs/osquery-monitoring.conf",'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"incident-response": "/opt/osquery/share/osquery/packs/incident-response.conf",'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"it-compliance": "/opt/osquery/share/osquery/packs/it-compliance.conf",'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"vuln-management": "/opt/osquery/share/osquery/packs/vuln-management.conf",'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"hardware-monitoring": "/opt/osquery/share/osquery/packs/hardware-monitoring.conf",'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"ossec-rootkit": "/opt/osquery/share/osquery/packs/ossec-rootkit.conf"'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Restart Osquery**: Now, you need to restart Osquery for your changes to take
    effect:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Threat hunting with Osquery
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Osquery gives you a SQL-like way to query requests and get real-time information
    about how a system is running. This lets security teams do proactive investigations
    and find threats. Threat hunting with Osquery involves actively searching for
    system information such as suspicious processes, unwanted software or modules,
    abnormal network connections, registry settings, file integrity, and more. For
    testing purposes, we will write some Osquery queries based on popular MITRE ATT&CK
    techniques.
  prefs: []
  type: TYPE_NORMAL
- en: It is sufficient to run the queries on a single endpoint for testing purposes
    and to demonstrate the information retrievable by Osquery. However, keep in mind
    that the true power of Osquery presents itself when it is widely deployed and
    administered centrally by the Wazuh manager. Let’s focus on discovering persistence
    tactics in our environment by utilizing a few of its associated techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Local Job Scheduling (MITRE ATT&CK ID T1168)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Adversaries utilize local job scheduling to schedule and execute tasks or jobs
    on a hacked system. It is covered by MITRE ATT&CK framework under *technique ID
    1168*. On Linux-based systems, adversaries can schedule their multi-step attack
    jobs by abusing the Cron service. They may set up new Cron jobs to run harmful
    scripts or commands on a regular basis. You can use the following query to retrieve
    information about local Cron jobs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Once this query is executed, you will see the result in the form of a table
    with the command and corresponding path, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.29 – Resulting list of local Cron jobs](img/B19549_6_29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.29 – Resulting list of local Cron jobs
  prefs: []
  type: TYPE_NORMAL
- en: Kernel Modules and Extensions (MITRE ATT&CK ID T1215)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Adversaries can ensure that their code runs each time the system reboots by
    installing a malicious kernel module or extension at startup or during system
    initialization. This makes it difficult to identify and uninstall. This is described
    under MITRE ATT&CK technique *ID T1215*. Kernel modules are pieces of code that
    can be dynamically loaded and unloaded from an operating system’s kernel. The
    query to retrieve the kernel modules is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Once this query is executed, you will get a list of all the kernel modules as
    shown in the following screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.30 – Result of list of kernel modules](img/B19549_6_30.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.30 – Result of list of kernel modules
  prefs: []
  type: TYPE_NORMAL
- en: Redundant Access (MITRE ATT&CK ID T1108)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**Redundant access** is a strategy in which adversaries create several paths
    or techniques for accessing and manipulating a victim machine. This works like
    a “plan B” for threat actors. To detect redundant access, we need to retrieve
    information about all the running processes on the endpoint. To get this information,
    we can run the following query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Once this query is executed, we will get the result in a table containing details
    on the process ID (`pid`), process name (`name`), `username`, `path`, and command
    line (`cmdline`) of the running processes, as shown in the following screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.31 – Result of all running processes and their corresponding paths](img/B19549_6_31.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.31 – Result of all running processes and their corresponding paths
  prefs: []
  type: TYPE_NORMAL
- en: Writing and organizing queries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are two ways you can create queries. You can either write a query directly
    under the `schedule` block of the `/etc/osquery/osquery.conf` file or you can
    organize them in the form of packs. When you have tons of queries to run, it’s
    always better to create a separate Osquery pack. In our scenario, we will add
    the following queries to a pack with the name `custom-pack-1.conf`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: You need to add all the queries under the `queries` field. Each Osquery query
    can have multiple items of metadata including `query`, `interval`, `description`,
    and `snapshot`. The following screenshot shows a query pack containing three queries.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.32 – Custom Osquery pack](img/B19549_6_32.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.32 – Custom Osquery pack
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding screenshot, we can see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SELECT * FROM services WHERE start_type=''DEMAND_START'' OR start_type=''AUTO_START`:
    This query retrieves all rows from the `services` table where `start_type` is
    either `''DEMAND_START''` or `''AUTO_START''`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SELECT * FROM services`: This query retrieves all rows from the `services`
    table'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SELECT name, display_name, status, start_type, path, module_path FROM services`:
    This query retrieves specific columns (`name`, `display_name`, `status`, `start_type`,
    `path`, `module_path`) from the `services` table'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can save the file and call this under the `/etc/osquery/osquery.conf` Osquery
    file.
  prefs: []
  type: TYPE_NORMAL
- en: To visualize Osquery events on the Wazuh dashboard, navigate to **Wazuh Modules**>**Osquery**>
    **Events**. You should see all the query results as shown in the following screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.33 – Visualizing Osquery events](img/B19549_6_33.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.33 – Visualizing Osquery events
  prefs: []
  type: TYPE_NORMAL
- en: We’ve learned to create custom Osquery queries and visualize the events on the
    Wazuh dashboard. In the next section, we will learn about command monitoring on
    Wazuh.
  prefs: []
  type: TYPE_NORMAL
- en: Command monitoring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The most effective way to collect information about an endpoint is to run specific
    commands on the given endpoint, such as `netstat` (for network connections on
    Windows), `ps` (to collect process information from Linux machines), and so on.
    This information plays a vital role in collecting IOCs and running a successful
    threat-hunting program. The good news is that Wazuh has a built-in feature to
    monitor the output of specific Windows/Linux commands and show that output as
    log content. In this section, we will learn the following:'
  prefs: []
  type: TYPE_NORMAL
- en: How does command monitoring work?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitoring Linux commands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: List of Linux commands for threat hunting and security Investigations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How does command monitoring work?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Wazuh runs commands on the endpoints using the *Command* and *Logcollector*
    modules, and then sends the results to the Wazuh server for examination. The following
    steps describe the process of command monitoring.
  prefs: []
  type: TYPE_NORMAL
- en: Step 1 – configuration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The process starts when a user chooses to monitor how a particular command is
    being executed on a system. This can be accomplished locally by adding the necessary
    command to the local agent configuration file (`/var/ossec/etc/ossec.conf`) or
    remotely through the `agent.conf` file hosted on the Wazuh server. Wazuh has two
    modules that let you monitor the results of system commands that are running on
    an endpoint. The Command and Logcollector modules run and watch commands or executables
    on Windows, Linux, and macOS targets on a regular basis.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Command module
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Wazuh recommends using the Command module as it has checksum verification, allows
    encrypted communication, and helps in scheduling execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of the Command module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `PowerShell.exe C:\\tasklist.bat` value in the `<command>` tag is
    the command to be executed by the Command module. The PowerShell program executes
    the `C:\activetasks.bat` script.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Logcollector module
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Text files, Windows event logs, and straight syslog messages can all send logs
    to the Logcollector module. It is easy to use and also allows us to format fields
    such as `timestamp`, `hostname`, and `program_name`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what a simple Logcollector module setup block looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we can see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<command>` reads the output of the command executed by the Wazuh agent.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<log_format>` can be set to either `full_command` or `command`. `full_command`
    reads the output as a single-line entry and `command` reads the output as multiple
    entries.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Step 2 – execution by the Wazuh agent
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Following the configuration of the required command, the endpoint runs the command
    on a regular basis according to the predetermined frequency or interval.
  prefs: []
  type: TYPE_NORMAL
- en: Under the Command module, we define the `<interval>` tag to execute the command
    at a specified interval.
  prefs: []
  type: TYPE_NORMAL
- en: Step 3 – monitoring and data forwarding
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Wazuh agent monitors how the configured command is being executed. It records
    the result of the command along with any associated data, including the timestamp,
    execution details, and user that started the command. The agent sends this data
    to the Wazuh server for further analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Step 4 – Wazuh server analysis and alert generation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The data is processed by the Wazuh server after it is received from the Wazuh
    agent. A number of crucial tasks are carried out by the server, such as pre-decoding,
    decoding, and matching the received logs against preset rules, explained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Pre-decoding and decoding**: The raw data is converted into a readable format
    using a Wazuh decoder. So, yes, we need to write a decoder rule too.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Matching rules**: The Wazuh server matches the decoded logs to predefined
    Wazuh rules. These rules identify suspicious or malicious command-related activity
    using patterns and criteria. If a match is identified, the server alerts security.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/var/ossec/logs/alerts/alerts.log and /var/ossec/logs/alerts/alerts.json`
    file on the Wazuh server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have understood how command monitoring works, let’s take a simple
    use case of monitoring the output of the `netstat` command on a Linux machine.
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring the output of the netstat command on Linux
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`netstat` is a tool for looking at connection information and can be used to
    find connections that seem suspicious or unusual. As a threat hunter, you may
    need to focus on a certain endpoint in the context of any unusual network connections.
    In order to monitor the output of the `netstat` command, follow these next steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '`net-tools` package is installed on all the monitored Linux endpoints:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`netstat` command in the Wazuh agent’s `ossec.conf` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`<command>netstat -tulpn</command>`: This indicates the command to be executed.
    In this case, the `netstat -tulpn` command is used to display active network connections,
    listening ports, and other related information.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`<frequency>360</frequency>`: This represents the frequency at which the preceding
    command will be executed. It is set to execute every 360 seconds (i.e., every
    6 minutes).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Restart and test**: Now, restart the Wazuh agent using the following command
    and check the Wazuh manager for the alert:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Visualizing the alert**: To visualize the alerts, navigate to the **Security
    alert** module on the Wazuh manager and find the alert related to **Listened port
    status (netstat)** as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.34 – Wazuh alert about netstat listened ports status having changed](img/B19549_6_34.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.34 – Wazuh alert about netstat listened ports status having changed
  prefs: []
  type: TYPE_NORMAL
- en: 'You will notice that we didn’t even create any Wazuh decoder or rule, but we
    got the alert. It was possible because Wazuh has a built-in ruleset named `0015-ossec_rule.xml`,
    containing a rule for netstat listening, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'And if you look at the parent rule, you will find the decoder named `ossec`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: List of Linux commands for threat hunting and security investigations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we bring this chapter to a close, let’s quickly review some essential Linux
    commands for threat hunting and security investigations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ss`: This is a tool used to dump socket statistics and provide information
    about network connections. The `ss` command is useful to identify open ports,
    check established connections, and gather network information. It is slightly
    more advanced than `netstat`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ps`: Using the `ps` command, you can see which processes are active on your
    system. Examining active processes might assist you in locating unauthorized or
    suspicious software.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`top` and `htop`: These commands provide up-to-date details on programs that
    are currently executing, and the number of system resources being consumed. They
    can also be used to spot any unexpected or resource-intensive activity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lsof`: You can find open files and network connections with the `lsof` (for
    *list open files*) command, which can help you keep an eye on behavior that might
    be suspicious.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tcpdump`: This is a very powerful packet capture tool that can be used to
    detect network-based threats.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covered important aspects of modern intelligence and threat-hunting
    tactics. It started with Wazuh’s contribution to proactive threat hunting, then
    moved on to the importance of analyzing log data, and finally looked at how MITRE
    ATT&CK mapping improves our understanding of threats. We learned how to use Osquery
    in Wazuh to effectively perform threat hunting and also learned how to use command
    monitoring in Wazuh to discover suspicious activities.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about the Vulnerability detection and SCA
    modules of the Wazuh platform. We will learn how to leverage these modules to
    meet regulatory compliance including PCI DSS, NIST 800-53, and HIPPA.
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 3: Compliance Management'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This part of this book focuses on compliance management using Wazuh and explores
    vulnerability detection and security configuration assessment modules of the Wazuh
    platform. You will learn to fulfill some specific requirements of regulatory compliance
    such as PCI DSS, HIPPA, and NIST 800-53 controls.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part includes the following chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 7*](B19549_07.xhtml#_idTextAnchor191), Vulnerability and Configuration
    Assessment'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
