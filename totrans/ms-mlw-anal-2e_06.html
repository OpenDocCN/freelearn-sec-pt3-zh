<html><head></head><body>
		<div><h1 id="_idParaDest-189" class="chapter-number"><a id="_idTextAnchor554"/>6</h1>
			<h1 id="_idParaDest-190"><a id="_idTextAnchor555"/>Bypassing Anti-Reverse Engineering Techniques</h1>
			<p>In this chapter, we will cover various anti-reverse engineering techniques that malware authors use to protect their code against unauthorized analysts who want to understand its functionality. We will familiarize ourselves with various approaches, from detecting the debugger and other analysis tools to breakpoint detection, <strong class="bold">virtual machine</strong> (<strong class="bold">VM</strong>) detection, and even attacking anti-malware tools and products.</p>
			<p>Additionally, we will cover the VM and sandbox-detection techniques that malware authors use to avoid spam detection, along with automatic malware-detection techniques that are implemented in various enterprises. As these anti-reverse engineering techniques are widely used by malware authors, it’s very important to understand how to detect and bypass them to be able to analyze complex or highly obfuscated malware.</p>
			<p>This chapter is divided into the following sections: </p>
			<ul>
				<li>Exploring debugger detection</li>
				<li>Handling the evasion of debugger breakpoints</li>
				<li>Escaping the debugger</li>
				<li>Understanding obfuscation and anti-disassemblers</li>
				<li>Detecting and evading behavioral analysis tools </li>
				<li>Detecting sandboxes and VMs</li>
			</ul>
			<h1 id="_idParaDest-191"><a id="_idTextAnchor556"/><a id="_idTextAnchor557"/><a id="_idTextAnchor558"/>Exploring debugger detection</h1>
			<p>For malware<a id="_idIndexMarker828"/> authors to keep their operations going without being interrupted by antivirus products or any takedown operations, they have to fight back and equip their tools with various anti-reverse engineering techniques. Debuggers are the most common tools that malware analysts use to dissect malware and reveal its functionality. Therefore, malware authors implement various anti-debugging tricks to <a id="_idIndexMarker829"/>complicate the analysis and keep their functionality and configuration details (mainly <strong class="bold">Command &amp; Control servers</strong> or <strong class="bold">C&amp;Cs</strong>) hidden.</p>
			<h2 id="_idParaDest-192"><a id="_idTextAnchor559"/>Using PEB information</h2>
			<p>Windows<a id="_idIndexMarker830"/> provides lots <a id="_idIndexMarker831"/>of ways to identify the presence of a debugger; many of them rely on the information stored in the <code>BeingDebugged</code> is set to <em class="italic">True</em> when the process is running under a debugger. To access this flag, malware can execute the following instructions:</p>
			<pre class="source-code">
mov  eax, dword ptr fs:[30h]     ; PEB
cmp  byte ptr [eax+2], 1 ; PEB.BeingDebugged
jz  &lt;debugger_detected&gt;</pre>
			<p>As you can see here, the pointer to PEB was found using the <code>fs:[30h]</code> technique. There are many other ways in which malware can get it:</p>
			<ul>
				<li>By using <code>fs:[18h]</code> to get a pointer to the TEB structure and, from there, using offset 0x30 to find the PEB.</li>
				<li>By using the <code>NtQueryInformationProcess</code> API with a <code>ProcessBasicInformation</code> argument. It returns the <code>PROCESS_BASIC_INFORMATION</code> structure, the second field of which, <code>PebBaseAddress</code>, will contain the PEB address.</li>
			</ul>
			<p>An <code>IsDebuggerPresent</code> API can be used instead to perform exactly the same check.</p>
			<p><code>NtGlobalFlag</code> is another field located at offset 0x68 of the PEB on 32-bit systems and 0xBC on 64-bit systems, which can be used for debugger detection. During normal execution, this flag is set to zero, but when a debugger is attached to the process, this flag is set with the following three values:</p>
			<ul>
				<li><code>FLG_HEAP_ENABLE_TAIL_CHECK (0x10)</code></li>
				<li><code>FLG_HEAP_ENABLE_FREE_CHECK (0x20) </code></li>
				<li><code>FLG_HEAP_VALIDATE_PARAMETERS (0x40)</code></li>
			</ul>
			<p>Malware can check for the presence of a debugger using these flags by executing the following instructions:</p>
			<pre class="source-code">
mov eax, fs:[30h] ; Process Environment Block
mov al, [eax+68h] ; NtGlobalFlag
and al, 70h ; Other flags can also be checked this way 
cmp al, 70h ; 0x10 | 0x20 | 0x40
je &lt;debugger_detected&gt;</pre>
			<p>Here, malware<a id="_idIndexMarker833"/> prefers to check for the presence of all of these flags together by <a id="_idIndexMarker834"/>combining them into the value of 0x70 (the result of using bitwise OR against them).</p>
			<p>The following logic can be used to detect the debugger in the 64-bit environment:</p>
			<pre class="source-code">
push 60h
pop rsi
gs:lodsq ; Process Environment Block
mov al, [rsi*2+rax-14h] ; NtGlobalFlag 
and al, 70h
cmp al, 70h
je &lt;debugger_detected&gt;</pre>
			<p>This example is trickier, as we should keep in mind that the <code>lodsq</code> instruction will increase the value of the <code>rsi</code> register by 8 (the size of QWORD). So, as a result, we will get an offset of (0x60 + 0x8)*2 – 0x14 = 0xBC, as mentioned earlier.</p>
			<p>Finally, to detect the debugger, malware can also use the <code>ProcessHeap</code> structure stored in PEB (offset 0x18 for 32-bit, 0x30 for 64-bit, and 0x1030 for WoW64 compatibility levels). This structure has two fields of interest:</p>
			<ul>
				<li><code>Flags</code> (32-bit: offset 0x0c on XP, 0x40 on Vista+; 64-bit: offset 0x14 on XP, 0x70 on Vista+): Generally, malware can either check for the presence of 0x40000062 bits revealing the debugger or do the opposite – check whether the value is the default one (2).</li>
				<li><code>ForceFlags</code> (32-bit: offset 0x10 on XP, 0x44 on Vista+; 64-bit: offset 0x18 on XP, 0x74 on Vista+): Here, malware can check for 0x40000060 bits set when the debugger is present or 0 otherwise.</li>
			</ul>
			<p>Apart from the<a id="_idIndexMarker835"/> direct access, the pointer to the <code>ProcessHeap</code> structure can be found using the <code>GetProcessHeap</code> and <code>RtlGetProcessHeaps</code> APIs. The value of the <code>Flags</code> field in the <code>ProcessHeap</code> structure can be read using the <code>RtlQueryProcessHeapInformation</code> and <code>RtlQueryProcessDebugInformation</code> APIs.</p>
			<p>Finally, the reason why<a id="_idIndexMarker836"/> these flags are set is that when the debugger is attached, heap tail checking will be enabled, and the system will be appending the <em class="italic">0xABABABAB</em> signature at the end of the allocated blocks. So, the malware could allocate a heap block and check whether this signature is present there and, in this way, identify the presence of the debugger:</p>
			<div><div><img src="img/Figure_6.1_B18500.jpg" alt="Figure 6.1 – Detecting the presence of the debugger because of heap tail checking&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.1 – Detecting the presence of the debugger because of heap tail checking</p>
			<p>The common way <a id="_idIndexMarker837"/>to bypass these checks is by overwriting them with <code>NOP</code> instructions<a id="_idIndexMarker838"/> or by setting a breakpoint at the start of them to jump over the check. In addition, dedicated debugger plugins can be used to change the values of the PEB structure in memory.</p>
			<h2 id="_idParaDest-193"><a id="_idTextAnchor560"/>Using EPROCESS information</h2>
			<p><code>EPROCESS</code> is another <a id="_idIndexMarker839"/>system structure<a id="_idIndexMarker840"/> containing information about the process that can reveal the presence of the debugger:</p>
			<ul>
				<li>The <code>DebugPort</code> field is nonzero if the process is debugged using a remote debugger.</li>
				<li>The <code>Flags</code> field contains the <code>NoDebugInherit</code> flag, which is set to 1 if the debugger is present.</li>
			</ul>
			<p>Unlike PEB, this structure is located in kernel mode and, therefore, not directly readable by usual processes. However, malware can use dedicated APIs to read its values:</p>
			<ul>
				<li><code>CheckRemoteDebuggerPresent</code>: This checks the <code>DebugPort</code> field of the <code>EPROCESS</code> structure.</li>
				<li><code>NtQueryInformationProcess</code>: This depends on the following arguments:<ul><li>With the <code>ProcessDebugPort</code> (7) argument, it checks the <code>DebugPort</code> field and returns -1 if the process is being debugged.</li><li>With <code>ProcessDebugFlags</code> (0x1F), it <a id="_idIndexMarker841"/>returns an inverse <code>NoDebugInherit</code> value.</li></ul></li>
			</ul>
			<h2 id="_idParaDest-194"><a id="_idTextAnchor561"/>Using DebugObject</h2>
			<p>When the <a id="_idIndexMarker842"/>debugger is present, the system creates a <a id="_idIndexMarker843"/>dedicated <code>DebugObject</code>. While the malware, in this case, can’t say whether it is its sample that is being debugged or maybe something else, for some malware writers, it is a red flag anyway. They could use the following APIs to check for its presence:</p>
			<ul>
				<li><code>NtQueryInformationProcess</code>: With the <code>ProcessDebugObjectHandle</code> (0x1E) argument, it returns the handle to <code>DebugObject</code> if it exists.</li>
				<li><code>NtQueryObject</code>: With the <code>ObjectAllTypesInformation</code> argument, it can be <a id="_idIndexMarker844"/>used to find <code>DebugObject</code> by <a id="_idIndexMarker845"/>its name.</li>
			</ul>
			<h2 id="_idParaDest-195"><a id="_idTextAnchor562"/>Using handles</h2>
			<p>Here, malware could <a id="_idIndexMarker846"/>use the differences in the handle <a id="_idIndexMarker847"/>management behavior with and without the debugger attached. For example, the <code>CloseHandle</code> (or <code>NtClose</code>) API can be used to attempt to close an invalid handle. If the debugger is attached, the <code>EXCEPTION_INVALID_HANDLE</code> (0xC0000008) exception will be raised, revealing its presence.</p>
			<p>Another less reliable option is to use <code>CreateFile</code> to open the malware’s own file with exclusive access. As some debuggers keep the handle of the analyzed file open, this action could fail under the debugger and, in this way, reveal it.</p>
			<h2 id="_idParaDest-196"><a id="_idTextAnchor563"/>Using exceptions</h2>
			<p>Debuggers are designed to <a id="_idIndexMarker848"/>intercept various types of exceptions <a id="_idIndexMarker849"/>to be able to perform all their functions. Malware can intentionally raise certain exceptions and detect the <a id="_idIndexMarker850"/>presence of the debugger if its exception handler (more information about <strong class="bold">Structured Exception Handling</strong> or <strong class="bold">SEH</strong> is discussed next) doesn’t receive control. Examples of this approach can involve the following APIs:</p>
			<ul>
				<li><code>RaiseException</code>/<code>RtlRaiseException</code>/<code>NtRaiseException</code> can be used to raise debugger-related exceptions such as <code>DBG_CONTROL_C</code>, <code>DBG_CONTROL_BREAK</code>, or <code>DBG_RIPEVENT</code>.</li>
				<li><code>GenerateConsoleCtrlEvent</code> with the <code>CTRL_C_EVENT</code> or <code>CTRL_BREAK_EVENT</code> arguments can be used to generate <em class="italic">Ctrl</em> + <em class="italic">C</em> or <em class="italic">Ctrl</em> +<em class="italic"> Break</em> events. If the <code>BeingDebugged</code> flag is set (when the debugger is attached), the system would generate a <code>DBG_CONTROL_C</code> exception (or a <code>DBG_CONTROL_BREAK</code> exception, respectively) that malware might attempt to intercept.</li>
				<li><code>SetUnhandledExceptionFilter</code> can be used to set a custom function to process unhandled <a id="_idIndexMarker851"/>exceptions. If the debugger is<a id="_idIndexMarker852"/> attached, it won’t be executed as the control will be passed t<a id="_idTextAnchor564"/><a id="_idTextAnchor565"/><a id="_idTextAnchor566"/>o the debugger instead.</li>
			</ul>
			<h2 id="_idParaDest-197"><a id="_idTextAnchor567"/>Using parent processes</h2>
			<p>One last <a id="_idIndexMarker853"/>technique worth mentioning<a id="_idIndexMarker854"/> is that processes can detect whether they were created by a debugger by checking the parent process’s name. The Windows operating system sets the process ID and the parent process ID in the process information. Using the parent process ID, you can check whether it was created normally (for example, by using <code>explorer.exe</code>) or whether it was created by a debugger (for example, by detecting the presence of the <em class="italic">dbg</em> substring in its name).</p>
			<p>There are two common techniques for malware to get the parent process ID, which are listed as follows:</p>
			<ul>
				<li>Looping through the list of running processes using <code>CreateToolhelp32Snapshot</code>, <code>Process32First</code>, and <code>Process32Next</code> (as we saw in <a href="B18500_05.xhtml#_idTextAnchor446"><em class="italic">Chapter 5</em></a>, <em class="italic">Inspecting Process Injection and API Hooking</em>, with process injection). These APIs not only return the process name and ID but also more information, such as the parent process ID that the malware is looking for.</li>
				<li>Using the <code>NtQueryInformationProcess</code> API. Given <code>ProcessBasicInformation</code> or <code>SystemProcessInformation</code> as an argument, this API will return structures containing the parent process ID in the <code>InheritedFromUniqueProcessId</code> field, as shown in the following screenshot:</li>
			</ul>
			<div><div><img src="img/Figure_6.2_B18500.jpg" alt="Figure 6.2 – Using NtQueryInfomationProcess to get the parent process&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.2 – Using NtQueryInfomationProcess t<a id="_idTextAnchor568"/>o get the parent process</p>
			<p>After getting the parent process ID, the next step is to get the process name or the filename to check whether it’s the name of a common debugger or whether it includes any <em class="italic">dbg</em> or <em class="italic">debug</em> substrings in its name. There are two common ways to get the process name from its ID, as shown in the following list:</p>
			<ul>
				<li>Looping through the processes in the same way to get the parent process ID, but this time, the attackers get the process name by providing the parent process ID that they got earlier.</li>
				<li>Using the <code>GetProcessImageFileNameA</code> API to get the filename of a process given its handle. To get a valid handle, malware would use the <code>OpenProcess</code> API with <code>PROCESS_QUERY_INFORMATION</code> as a required argument.</li>
			</ul>
			<p>This API returns the <a id="_idIndexMarker855"/>process filename, which can b<a id="_idTextAnchor569"/>e checked later <a id="_idIndexMarker856"/>to detect whether it’s a debugger or not.</p>
			<p>Another common way in which the debugging process can be detected by malware is breakpoint detection, so let’s cover this top<a id="_idTextAnchor570"/>ic in greater detail next.</p>
			<h1 id="_idParaDest-198"><a id="_idTextAnchor571"/>Handling the evasion of debugger breakpoints</h1>
			<p>Another way to detect <a id="_idIndexMarker857"/>debuggers or evade them is to detect their breakpoints. Whether they are software breakpoints (such as <code>INT3</code>), hardware breakpoints, single-step breakpoints (trap flag), or memory breakpoints, malware can detect them <a id="_idTextAnchor572"/>and possibly remove them to escap<a id="_idTextAnchor573"/>e reverse engineer control.</p>
			<h2 id="_idParaDest-199"><a id="_idTextAnchor574"/>Detecting software breakpoints (INT3)</h2>
			<p>This type of breakpoint is <a id="_idIndexMarker858"/>the easiest to use and the easiest to detect. As we stated in <a href="B18500_02.xhtml#_idTextAnchor043"><em class="italic">Chapter 2</em></a>, <em class="italic">A Crash Course in Assembly and Programming Basics</em>, this breakpoint modifies the instruction bytes by replacing the first byte with 0xCC (the <code>INT3</code> instruction), which creates an exception (an error) that gets delivere<a id="_idTextAnchor575"/>d to the debugger to handle.</p>
			<p>Since it modifies the code in memory, it’s easy to scan the code section in memory for the <code>INT3</code> byte. A simple scan will look like this:</p>
			<div><div><img src="img/Figure_6.3_B18500.jpg" alt="Figure 6.3 – A simple INT3 scan&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.3 – A simple INT3 scan</p>
			<p>The only drawback of this approach is that some C++ compilers write <code>INT3</code> instructions after the end of each function as filler bytes. An <code>INT3</code> byte (0xCC) can also be found inside some instructions as part of an address or a value, so searching for this byte through the code might not be an effective solution and could return lots of false positives.</p>
			<p>There are two <a id="_idIndexMarker859"/>other techniques that are commonly used by malware to scan for an <code>INT3</code> breakpoint, as shown in the following list:</p>
			<ul>
				<li>Pre-calculating a checksum of any kind for the entire code section and recalculating it again in execution mode. If the value has changed, then it means that there are some bytes that have been changed, either by patching or by setting an <code>INT3</code> breakpoint. Here is an example of how it can be implemented using the <code>rol</code> instruction:<pre>mov esi,&lt;CodeStart&gt;
mov ecx,&lt;CodeSize&gt;
xor eax,eax
ChecksumLoop:
movzx edx,byte [esi]
add eax,edx
rol eax,1
inc esi
loop .checksum_loop
cmp eax, &lt;Correct_Checksu<a id="_idTextAnchor576"/>m&gt;
jne &lt;breakpoint_detected&gt;</pre></li>
				<li>Reading the <a id="_idIndexMarker860"/>malware sample file and comparing the code section from the file to the memory version of it. If there are any differences between them, this means that the malware has been patched in memory or there is a software breakpoint (<code>INT3</code>) that has been added to the code. This technique is not widely used, as it’s not effective if the malware sample has its relocation table populated (check <a href="B18500_03.xhtml#_idTextAnchor084"><em class="italic">Chapter 3</em></a>, <em class="italic">Basic Static and Dynamic Analysis for x86/x64</em>, for more information).</li>
			</ul>
			<p>The best solution to circumvent software breakpoint detection is to use hardware breakpoints, single-stepping (code tracing), or setting access breakpoints in different places in the code section for any memory read. Once a memory breakpoint on access gets a hit, you can find the checksum calculating code and deal with it by patching the checksum code itself, as you can see in the following screenshot:</p>
			<div><div><img src="img/Figure_6.4_B18500.jpg" alt="Figure 6.4 – A breakpoint on memory access for the code section to detect an INT3 scanning/checksum calculating loop&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.4 – A breakpoint on memory access for the code section to detect an INT3 scanni<a id="_idTextAnchor577"/>ng/checksum calculating loop</p>
			<p>In the preceding <a id="_idIndexMarker861"/>screenshot, we have set a breakpoint, <code>INT3</code> scan loop or the checksum calculating loop.</p>
			<p>By patching the check at the end of the checksum calculato<a id="_idTextAnchor578"/>r or <code>jz/jnz</code> with the opposite check, you can <a id="_idTextAnchor579"/>easily bypass this technique.</p>
			<h2 id="_idParaDest-200"><a id="_idTextAnchor580"/>Detecting single-stepping breakpoints using a trap flag</h2>
			<p>Another type of <a id="_idIndexMarker862"/>breakpoint detection <a id="_idIndexMarker863"/>technique that is widely used is trap flag detection. When you trace over the instructions one by one, checking the changes they make in memory and on the registers’ values, your debugger sets the trap flag bit (TF) in the EFLAGS register, which is responsible for stopping on the next instruction and returning control back to the debugger.</p>
			<p>This flag is not trivial to catch because EFLAGS is not directly readable. It’s only readable through the <code>pushf</code> instruction, which saves this register value in the stack. Since this flag is always set to <em class="italic">False</em> after returning to the debugger, it’s hard to check the value of this flag and detect a single-step breakpoint. However, there is a way it can be done.</p>
			<p>In the x86 architecture, there are multiple registers that are not widely used nowadays. These registers were used in DOS operating systems before virtual memory in the way we know it was introduced, particularly the segment registers. Apart from the FS register (which you already know about), there are other segment registers, such as CS, which was used to point to the code segment; DS, which was used to point to the data segment; and SS, which was used<a id="_idTextAnchor581"/> to point to the stack segment.</p>
			<p>The <code>pop SS</code> instruction is quite special. This instruction is used to get a value from the stack and change the stack segment (or address) according to this value. So, if there’s any exception happening while executing this instruction, it could lead to confusion (for instance, which stack would be used to store the exception information?). Therefore, no exceptions or interrupts are allowed while executing this instruction, including any breakpoints or trap flags.</p>
			<p>If you are tracing over this instruction, your debugger will move the cursor, skip the next instruction, and jump directly to the instruction after it. That doesn’t mean this skipped instruction wasn’t executed; it was executed but not interrupted by the debugger.</p>
			<p>For example, in the following code, your debugger cursor will move from <code>POP SS</code> to <code>MOV EAX, 1</code>, skipping the <code>PUSHFD</code> instruction, even if it was executed:</p>
			<pre class="source-code">
PUSH SS
POP SS
PUSHFD ; your debugger wouldn't stop on this instruction
MOV EAX, 1 ; your debugger will automatically stop on this instruction.</pre>
			<p>The trick here is <a id="_idIndexMarker864"/>that, in the previous example, the<a id="_idIndexMarker865"/> trap flag will remain set while executing the <code>pushfd</code> instruction, but it won’t be allowed to return to the debugger. So, the <code>pushfd</code> instruction will push the EFLAGS register to the stack, including the actual value of the trap flag (if it was set, it will show in the EFLAGS register). Then, it’s easy for malware to check whether the trap flag is set and detect the debugger. An example of this is shown in the following screenshot:</p>
			<div><div><img src="img/Figure_6.5_B18500.jpg" alt="Figure 6.5 – Trap ﬂag detection using the SS register&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.5 – Trap ﬂag detection using the SS register</p>
			<p>It is worth <a id="_idIndexMarker866"/>mentioning that some debuggers, such <a id="_idIndexMarker867"/>as new versions of x64dbg, are aware of this technique and don’t expose the TF bit in this way.</p>
			<p>This is a direct way of checking for code tracing or single-stepping. Another way to detect it is by monitoring the time that passed while executing an instruction or a group of instructions, which is what we wi<a id="_idTextAnchor582"/><a id="_idTextAnchor583"/><a id="_idTextAnchor584"/>ll talk about in the next section.</p>
			<h2 id="_idParaDest-201"><a id="_idTextAnchor585"/>Detecting single-stepping using timing techniques</h2>
			<p>There are <a id="_idIndexMarker868"/>multiple ways to get the exact time with <a id="_idIndexMarker869"/>millisecond accuracy, from the moment the system is on to the execution of the current instruction. There is an x86 instruction called <code>rdtsc</code> that returns the time in EDX:EAX registers. By calculating the difference between the time before and after executing a certain instruction, any delay will be clearly shown, which represents reverse-engineering tracing through the code. An example of this is shown in the following screenshot:</p>
			<div><div><img src="img/Figure_6.6_B18500.jpg" alt="Figure 6.6 – The rdtsc instruction to detect single-stepping&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.6 – The rdtsc instruction to detect single-stepping</p>
			<p>This instruction is not the only way to get the time at any given moment. There are multiple APIs supported by Windows that help programmers get the exact time, which are listed as follows:</p>
			<ul>
				<li><code>GetLocalTime</code>/<code>GetSystemTime</code></li>
				<li><code>GetTickCount</code></li>
				<li><code>QueryPerformanceCounter</code></li>
				<li><code>timeGetTime</code>/<code>timeGetSystemTime</code></li>
			</ul>
			<p>This technique is<a id="_idIndexMarker870"/> widely used and more common<a id="_idIndexMarker871"/> than the SS segment register trick. The best solution is to patch the instructions. It’s easy to detect it if you are already stepping through the instructions; you can patch the code or just set the instruction pointer (EIP/RIP) to make <a id="_idTextAnchor586"/><a id="_idTextAnchor587"/><a id="_idTextAnchor588"/>it point to the code after the check.</p>
			<h2 id="_idParaDest-202"><a id="_idTextAnchor589"/>Evading hardware breakpoints</h2>
			<p>Hardware<a id="_idIndexMarker872"/> breakpoints are based on registers that are not accessible in user mode. Therefore, it’s not easy for malware to check these registers and clear them to remove these breakpoints.</p>
			<p>For malware to be able to access them, it needs to have them pushed to the stack and pulled out from it again. To do th<a id="_idTextAnchor590"/>at, many malware families rely on SEH.</p>
			<h3>What is SEH?</h3>
			<p>For any program to handle exceptions, Windows provides a mechanism called <a id="_idIndexMarker873"/>SEH. This is based on setting a callback function to handle the exception and then resume execution. If this callback failed to handle the exception, it can pass this exception to the previous callback that was set. If the last callback was unable to handle the exception, the operating system terminates the process and informs the user about the unhandled exception, and it often suggests that they send it to the developer company.</p>
			<p>A pointer to the first callback to be called is stored in the <strong class="bold">thread environment block</strong> (<strong class="bold">TEB</strong>) and <a id="_idIndexMarker874"/>can be accessed via FS:[0x00]. The structure is a linked list, which means that each item in this list contains the address of the callback function and follows the address of the previous item in the list (the previous callback). In the stack, the linked list looks like this:</p>
			<div><div><img src="img/Figure_6.7_B18500.jpg" alt="Figure 6.7 – The SEH linked list in the stack&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure<a id="_idTextAnchor591"/> 6.7 – The SEH linked list in the stack</p>
			<p>The setup of the SEH callback generally looks like this:</p>
			<pre class="source-code">
PUSH &lt;callback_func&gt; // Address of the callback function
PUSH FS:[0] // Address of the previous callback item in the list
MOV FS:[0],ESP // Install the new EXCEPTION_REGISTRATION</pre>
			<p>As you can see, the<a id="_idIndexMarker875"/> SEH linked list is mostly saved in the stack. Each item points to the previous one. When an exception occurs, the operating system executes this callback function and passes the necessary information about the exception and the thread state to it (the registers, the instruction pointer, and more). This callback has the ability to modify the registers, the instruction pointer, and the whole thread context. Once the callback returns, the operating system takes the modified thread’s state and registers (which is called the context) and resumes execution based on it. The callback function looks like this:</p>
			<pre class="source-code">
_cdecl _except_handler( 
   struct _EXCEPTION_RECORD *ExceptionRecord, 
   void * EstablisherFrame, 
   struct _CONTEXT *ContextRecord, 
   void * DispatcherContext 
);</pre>
			<p>The important arguments are the following:</p>
			<ul>
				<li><code>ExceptionRecord</code>: This contains information related to the exception or the error that has been generated. It contains the exception code number, the address, and other information.</li>
				<li><code>ContextRecord</code>: This is a structure that represents the state of that thread at the time of the exception. It’s a long structure that contains all the registers and other information. A snippet of this structure would look as follows:<pre>struct CONTEXT { 
DWORD ContextFlags;
DWORD DR[7];
FLOATING_SAVE_AREA FloatSave;
DWORD SegGs;
DWORD SegFs;
DWORD SegEs;
DWORD SegDs;
DWORD Edi;
....
};</pre></li>
			</ul>
			<p>There are multiple ways to detect a debugger using SEH. One of them is by dete<a id="_idTextAnchor592"/><a id="_idTextAnchor593"/><a id="_idTextAnchor594"/>cting and removing hardware breakpoints.</p>
			<h3>Detecting hardware breakpoints</h3>
			<p>To detect or <a id="_idIndexMarker876"/>remove hardware breakpoints, malware can use SEH to get the thread context, check the values of the DR registers, and exit if a debugger has been detected. The code is as follows:</p>
			<pre class="source-code">
xor eax, eax
push offset except_callback
push d fs:[eax]
mov fs:[eax], esp
int 3 ; force an exception to occur
...
except_callback:
mov eax, [esp+0ch] ; get ContextRecord
mov ecx, [eax+4] ; Dr0
or ecx, [eax+8]  ; Dr1
or ecx, [eax+0ch] ; Dr2
or ecx, [eax+10h] ; Dr3
jne &lt;Debugger_Detected&gt;</pre>
			<p>Another way to <a id="_idIndexMarker877"/>detect hardware breakpoints is to use the <code>GetThreadContext</code> API to access the current thread (or another thread) context and check for the presence of hardware breakpoints or clear them using the <code>SetThreadContext</code> API.</p>
			<p>The best way to deal with these <a id="_idIndexMarker878"/>techniques is to set a breakpoint on <code>GetThreadContext</code>, <code>SetThreadContext</code>, or the exception call<a id="_idTextAnchor595"/>back function to make sure they don’t<a id="_idTextAnchor596"/> reset or detect your hardware breakpoints.</p>
			<h2 id="_idParaDest-203"><a id="_idTextAnchor597"/>Memory breakpoints</h2>
			<p>The last type of<a id="_idIndexMarker879"/> breakpoints we will talk about is memory breakpoints. It’s not very common to see techniques targeting them, but they are possible. Memory breakpoints can be easily detected by using the <code>ReadProcessMemory</code> API with the malware’s base as an argument and its image size as the size. <code>ReadProcessMemory</code> will return <em class="italic">False</em> if any page inside the malware is guarded (<code>PAGE_GUARD</code>) or <a id="_idTextAnchor598"/>set to no-access protection (<code>PAGE_NOACCESS</code>).</p>
			<p>For a malware sample to detect a memory breakpoint on write or execute, it can query any memory page protection flags using the <code>VirtualQuery</code> API. Alternatively, it can evade them by using <code>VirtualProtect</code> with the <code>PAGE_EXECUTE_READWRITE</code> argument to overwrite them.</p>
			<p>The best way to deal with these anti-debugging tricks is to set breakpoints on all of these APIs and force them to return the desired res<a id="_idTextAnchor599"/>ult to the malware in order to resume normal execution.</p>
			<p>Now, it’s time to talk about how m<a id="_idTextAnchor600"/>alware might attempt to escape the debugger.</p>
			<h1 id="_idParaDest-204"><a id="_idTextAnchor601"/>Escaping the debugger</h1>
			<p>Apart from <a id="_idIndexMarker880"/>detecting debuggers and removing their breakpoints, there are multiple tricks that malware uses to escape the whole debuggin<a id="_idTextAnchor602"/>g environment altogether<a id="_idTextAnchor603"/>. Let’s cover some of the most common tricks.</p>
			<h2 id="_idParaDest-205"><a id="_idTextAnchor604"/>Process injection</h2>
			<p>We talked about process injection<a id="_idIndexMarker881"/> before, in <a href="B18500_05.xhtml#_idTextAnchor446"><em class="italic">Chapter 5</em></a>, <em class="italic">Inspecting Process Injection and API Hooking</em>. Process injection is a very well-known technique, not only for man-in-the-browser attacks but also for escaping the debugged process into a process that is not currently debugged. By injecting code into another process, malware can get out of the debugger’s control and execute code before the debugger can attach to it.</p>
			<p>A commonly used solution to bypass this trick is to add an infinite loop instruction to the entry point of the injected code before it gets executed. Usually, this is in the injector code either before the <code>WriteProcessMemory</code> call when the code hasn’t been injected yet or before <code>CreateRemoteThread</code>, this time in another process’s memory.</p>
			<p>An infinite loop<a id="_idIndexMarker882"/> can be created by writing two bytes (0xEB 0xFE) that represent a <code>jmp</code> instruction to itself, as you can see in the following screenshot:</p>
			<div><div><img src="img/Figure_6.8_B18500.jpg" alt="Figure 6.8 – The injected JMP instruction to create an inﬁnite loop&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.8 – The injected JMP instruction to create an inﬁnite loop</p>
			<p>Next, we are going to talk about another popular technique using TLS callbacks. Read on!</p>
			<h2 id="_idParaDest-206"><a id="_idTextAnchor605"/>TLS callbacks</h2>
			<p>Many reverse engineers start the <a id="_idIndexMarker883"/>debugging phase from the entry point of the malware, which usually makes sense. However, some malicious code can start before the entry point. Some malware families <a id="_idIndexMarker884"/>use <strong class="bold">Thread Local Storage</strong> (<strong class="bold">TLS</strong>) to execute code that initializes every thread (which runs before the thread’s actual code starts). This gives the malware the ability to escape the debugging and do some preliminary checks, and maybe even run most of the malicious code this way while having benign code at the entry point.</p>
			<p>In the <em class="italic">data directory</em> block of the PE header, there is an entry for TLS. It is commonly stored in the <em class="italic">.tls</em> section, and its structure looks like this:</p>
			<div><div><img src="img/Figure_6.9_B18500.jpg" alt="Figure 6.9 – The TLS structure&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.9 – The TLS structure</p>
			<p>Here, <em class="italic">AddressOfCallBacks</em> points<a id="_idIndexMarker885"/> to a null-terminated array (the last element is zero) of callback functions, which are to be called after each other every time a thread has been created. Any malware can set its malicious code to start inside the <em class="italic">AddressOfCallBacks</em> array and ensure that this code is executed before the entry point.</p>
			<p>A solution for this trick is to check the PE header before debugging the malware and set a breakpoint on every callback function registered inside the <em class="italic">AddressOfCallBacks</em> field. In addition, <strong class="bold">IDA</strong> will display them together with the <a id="_idTextAnchor606"/><a id="_idTextAnchor607"/><a id="_idTextAnchor608"/>entry point and exported functions (if present).</p>
			<h2 id="_idParaDest-207"><a id="_idTextAnchor609"/>Windows events callbacks</h2>
			<p>Another trick used by malware <a id="_idIndexMarker886"/>authors to evade the reverse engineer’s single-stepping and breakpoints is by setting callbacks. Callbacks are each called for a specific event (such as a mouse click, keyboard keystroke, or a window moving to the front). If you are single-stepping over the malware instructions, the callback would still be executed without you noticing. In addition, if you are setting breakpoints based on the code flow, it will still bypass your breakpoints.</p>
			<p>There are so many ways to set callback functions. Therefore, we will just mention two of them here, as follows:</p>
			<ul>
				<li>Using the <code>RegisterClass</code> API: The <code>RegisterClass</code> API creates a window class that can be used to create a window. This API takes a structure called <code>WNDCLASSA</code> as an argument. The <code>WNDCLASSA</code> structure contains all the necessary information related to this window, including the icon, the cursor icon, the style, and most importantly the callback function to receive window events. The code looks as follows:<pre>MOV  DWORD PTR [WndCls.lpfnWndProc], &lt;WindowCallback&gt;
LEA  EAX, DWORD PTR SS:[WndCls]
PUSH EAX ; pWndClass
CALL &lt;JMP.&amp;user32.RegisterClassA&gt; ; RegisterClassA</pre></li>
				<li>Using <code>SetWindowLong</code>: Another way to set the window callback is to use <code>SetWindowLong</code>. If you have the window handle (from <code>EnumWindows</code>, <code>FindWindow</code>, or other APIs), you can call the <code>SetWindowLong</code> API to change the window callback function. Here is what this code looks like:<pre>PUSH &lt;WindowCallback&gt;
PUSH GWL_DlgProc
PUSH hWnd ; Window Handle
CALL SetWindowLongA</pre></li>
			</ul>
			<p>The best solution for this is<a id="_idIndexMarker887"/> to set breakpoints on all the APIs that register callbacks or their callback functions. You can check the malware’s import table, any calls to <code>GetProcAddress</code>, or other functions that dynamically resolve and call APIs.</p>
			<h2 id="_idParaDest-208"><a id="_idTextAnchor610"/>Attacking the debugger</h2>
			<p>In some cases, malware might <a id="_idIndexMarker888"/>attempt to attack the debugging session. For example, the <code>BlockInput</code> API can be used to block mouse and keyboard events making the attached debugger unusable. Another similar option is to use <code>SwitchDesktop</code> to hide mouse and keyboard events from the debugger.</p>
			<p>Speaking of threads, the <code>NtSetInformationThread</code> API with the <code>ThreadHideFromDebugger</code> (0x11) argument can be used to hide the thread from the debugger. Any exceptions taking place in the hidden thread including triggered breakpoints won’t be intercepted by <a id="_idIndexMarker889"/>the debugger making the program crash instead. Finally, the <code>SuspendThread</code>/<code>NtSuspendThread</code> API can be used by malware against the debugger’s thread itself.</p>
			<p>These are some of the most common ways how malware might attempt to affect the debugging process itself. <a id="_idTextAnchor611"/><a id="_idTextAnchor612"/><a id="_idTextAnchor613"/>Next, let’s talk about various types of obfuscation.</p>
			<h1 id="_idParaDest-209"><a id="_idTextAnchor614"/>Understanding obfuscation and anti-disassemblers</h1>
			<p>Dissemblers<a id="_idIndexMarker890"/> are one of the <a id="_idIndexMarker891"/>most common tools that are used in reverse engineering, and so they are<a id="_idIndexMarker892"/> actively targeted by malware authors. Now, we will take a look at the different techniques that are used in malware to obfuscate its code <a id="_idTextAnchor615"/>and make it harder for reverse engineers to analyze it.</p>
			<h2 id="_idParaDest-210"><a id="_idTextAnchor616"/>Encryption</h2>
			<p>Encryption<a id="_idIndexMarker893"/> is the most common technique as it also protects malware from static antivirus signatures. Malware can encrypt its own code and have a small piece of stub code to decrypt the malicious code before executing it. Additionally, the malware can encrypt its own data, such as strings including API names or the whole configuration block.</p>
			<p>Dealing with encryption is not always easy. One solution is to execute the malware and dump the memory after it has been decrypted. For example, many sandboxes can now make process dumps of the monitored processes, which could help you get the malware in the decrypted form.</p>
			<p>But for cases such as encrypting strings and decrypting each string on demand, you will need to reverse the encryption algorithm and write a script to go through all the calls to the decryption function and use its parameters to decrypt the strings. You can check out <a href="B18500_04.xhtml#_idTextAnchor238"><em class="italic">Chapter 4</em></a>, <em class="italic">Unpacking, Decryption, and Deobfuscation</em>, fo<a id="_idTextAnchor617"/>r more informa<a id="_idTextAnchor618"/>tion on how to handle encryption and write such scripts.</p>
			<h2 id="_idParaDest-211"><a id="_idTextAnchor619"/>Junk code</h2>
			<p>Another<a id="_idIndexMarker894"/> well-known technique that’s used in many samples and that became increasingly popular in the late 1990s and early 2000s is junk code insertion. With this technique, the malware author inserts lots of code that never gets executed. For example, the code can be placed after unconditional jumps, calls that never return, or conditional jumps with conditions that would never be met. The main goal of this code is to waste the reverse engineer’s time analyzing useless code or make <a id="_idTextAnchor620"/>the code graph look more complicated than it actually is.</p>
			<p>Another similar technique is to insert ineffective code. This ineffective code could be something such as <code>nop</code>, <code>push</code> and <code>pop,</code> <code>inc</code> and <code>dec</code>, or repetition of the same instruction. A combination of these instructions could look like real code; however, the same operation in reality would be encoded much simpler, as you can see in the following screenshot:</p>
			<div><div><img src="img/Figure_6.10_B18500.jpg" alt="Figure 6.10 – Pointless junk code&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.10 – Pointless junk code</p>
			<p>There are different forms of this junk code, including the expansion of an instruction; for example, <code>inc edx</code> becomes <code>add edx, 3</code> and <code>sub edx, 2</code>, and so on. This way, it is possible to obfuscate the actual values, such as 0x5a4D (<em class="italic">MZ</em>) or any other values that could represent specific functionality for this subroutine.</p>
			<p>This technique has been around since <a id="_idTextAnchor621"/>the 1990s in metamorphic engines, but it’s still used by some families to obfuscate their code.</p>
			<p>It is worth mentioning that while strings<a id="_idIndexMarker895"/> stored in local variables are more complicated to analyze, the following is <strong class="bold">not</strong> an example of such a technique but a legitimate compiler’s behavior:</p>
			<div><div><img src="img/Figure_6.11_B18500.jpg" alt="Figure 6.11 – A string stored in local variables&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.11 – A string stored in local variables</p>
			<p><a id="_idTextAnchor622"/>Now, let’s talk about the code transportation technique.</p>
			<h2 id="_idParaDest-212"><a id="_idTextAnchor623"/>Code transportation</h2>
			<p>Another trick that’s<a id="_idIndexMarker896"/> commonly used by malware authors is code transportation. This technique doesn’t insert junk code; instead, it rearranges the code inside each subroutine with lots of unconditional jumps, including <code>call</code> <a id="_idTextAnchor624"/>+ <code>pop</code> or conditional jumps that are always true or false.</p>
			<p>It makes the function graph look as though it is very complicated to analyze and wastes the reverse engineer’s time. An example of such code can be seen in the following screenshot:</p>
			<div><div><img src="img/Figure_6.12_B18500.jpg" alt="Figure 6.12 – Code transportation with unconditional jumps&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.12 – Code transportation with unconditional jumps</p>
			<p>There is a more complicated <a id="_idIndexMarker897"/>form of this where malware rearranges the code of each subroutine in the middle of the other subroutines. This form makes it harder for the disassembler to connect each subroutine, as it makes it miss the <code>ret</code> instruction at the end of the function and then not consider it as a function.</p>
			<p>Some other malware families don’t put a <code>ret</code> instruction at the end of the subroutine and, instead, substitute it with <code>pop</code> and <code>jmp</code> to h<a id="_idTextAnchor625"/>ide this subroutine from the disassembler. These are just some of the many forms o<a id="_idTextAnchor626"/>f code transportation and junk code insertion techniques.</p>
			<h2 id="_idParaDest-213"><a id="_idTextAnchor627"/>Dynamic API calling with checksum</h2>
			<p>Dynamic API calling is a<a id="_idIndexMarker898"/> famous anti-disassembling trick used by <a id="_idIndexMarker899"/>many malware families. The main reason behind using it is that, in this way, they hide API names from static analysis tools and make it harde<a id="_idTextAnchor628"/>r to understand what each function inside the malware does.</p>
			<p>For a malware author to implement this trick, they need to pre-calculate a checksum for this API name and push this value, as an argument, to a function that scans export tables of different libraries and searches for an API by this checksum. An example of this is shown in the following screenshot:</p>
			<div><div><img src="img/Figure_6.13_B18500.jpg" alt="Figure 6.13 – Library and API names’ checksums (hash)&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.13 – Library and API names’ checksums (hash)</p>
			<p>The code for resolving the function actually goes through the PE header of the library, loops through the export table, and calculates the checksum of each API to compare it with the given checksum (or hash) that’s provided as an argument.</p>
			<p>The solution to this <a id="_idIndexMarker900"/>approach could require scripting to loop through <a id="_idIndexMarker901"/>all known API names and calculate their checksums. Alternatively, it could<a id="_idTextAnchor629"/> require executing this function multiple times, giving each <a id="_idTextAnchor630"/>checksum as input and saving the equivalent API name for it.</p>
			<h2 id="_idParaDest-214"><a id="_idTextAnchor631"/>Proxy functions and proxy argument stacking</h2>
			<p>The Nymaim banking trojan took anti-disassembling to another level by adding additional techniques, such as proxy functions and proxy argument stacking.</p>
			<p>With the proxy functions<a id="_idIndexMarker902"/> technique, malware doesn’t directly call the required function; instead, it calls a proxy function that calculates the address of the required function and transfers the execution there. Nymaim<a id="_idIndexMarker903"/> included more than 100 different proxy functions with <a id="_idIndexMarker904"/>different algorithms (four or five algorithms in total). The proxy function call looks like this:</p>
			<div><div><img src="img/Figure_6.14_B18500.jpg" alt="Figure 6.14 – The proxy function arguments used to calculate the function address&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.14 – The p<a id="_idTextAnchor632"/>roxy function arguments used to calculate the function address</p>
			<p>The proxy function code itse<a id="_idTextAnchor633"/>lf looks like this:</p>
			<div><div><img src="img/Figure_6.15_B18500.jpg" alt="Figure 6.15 – The Nymaim proxy function&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.15 – The Nymaim proxy function</p>
			<p>For arguments, Nymaim <a id="_idIndexMarker905"/>uses a function to push arguments to the stack rather than<a id="_idIndexMarker906"/> just using the push instruction. This trick could prevent the disassembler from recognizing the arguments <a id="_idIndexMarker907"/>that were given to each function or API. An example of proxy argument stacking is as follows:</p>
			<div><div><img src="img/Figure_6.16_B18500.jpg" alt="Figure 6.16 – The proxy argument stacking technique in Nymaim&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.16 – The proxy argument stacking technique in Nymaim</p>
			<p>This malware included ma<a id="_idTextAnchor634"/>ny different forms of <a id="_idIndexMarker908"/>the techniques that we introduced in this section. So, as long as the main idea is clear, you should be able to understand all of them.</p>
			<h2 id="_idParaDest-215"><a id="_idTextAnchor635"/>Using the COM functionality</h2>
			<p>Instead of hiding APIs by<a id="_idIndexMarker909"/> dynamically resolving their names using hashes, malware might attempt to achieve the same result using different technologies. A good example would be using the <code>Wscript.Shell</code> COM object’s functionality to execute a program instead of calling APIs such as <code>CreateProcess</code>, <code>ShellExecute</code>, or <code>WinExec</code>, which would immediately draw the researcher’s attention. To create its object, malware can use the <code>CoCreateInstance</code> API specifying the required object’s class in the form of the IID, as you can see in the following screenshot:</p>
			<div><div><img src="img/Figure_6.17_B18500.jpg" alt="Figure 6.17 – Creating an instance of the Wscript.Shell object by its IID, F935DC21-1CF0-11d0-ADB9-00C04FD58A0B&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.17 – Creating an instance of the Wscript.Shell object by its IID, F935DC21-1CF0-11d0-ADB9-00C04FD58A0B</p>
			<p>After this, the<a id="_idIndexMarker910"/> actual method will be accessed by its offset. To figure out the method’s name by its offset, you can<a id="_idIndexMarker911"/> use the <strong class="bold">COMView</strong> tool:</p>
			<div><div><img src="img/Figure_6.18_B18500.jpg" alt="Figure 6.18 – Finding the name of the method of the COM object by its offset found in assembly&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.18 – Finding the name of the method of the COM object by its offset found in assembly</p>
			<p>As you can see here, the <code>Run</code> method of the <code>Wscript.Shell</code> class would be accessed by its offset of 36 (0x24).</p>
			<p>As we can see, obfuscation can take various forms, so the more examples you are aware of, the less time it will take to find the right approach to handle it. Now, it is time to l<a id="_idTextAnchor636"/>earn how behavioral analysis tools can be detected using malware.</p>
			<h1 id="_idParaDest-216"><a id="_idTextAnchor637"/>Detecting and evading behavioral analysis tools</h1>
			<p>There are <a id="_idIndexMarker912"/>multiple ways in which malware can detect and evade <a id="_idIndexMarker913"/>behavioral analysis tools, such as ProcMon, Wireshark, API Monitor, and more, even if they don’t directly debug the malware or interact <a id="_idTextAnchor638"/>with it. In this sec<a id="_idTextAnchor639"/>tion, we will talk about two common examples of how it can be done.</p>
			<h2 id="_idParaDest-217"><a id="_idTextAnchor640"/>Finding the tool process</h2>
			<p>One of the simplest and most<a id="_idIndexMarker914"/> common ways that malware can deal with malware-analysis tools (and antivirus tools, too) is to loop through all the running processes and detect any unwanted entries. Then, it is possible to either terminate or stop them to avoid further analysis.</p>
			<p>In <a href="B18500_05.xhtml#_idTextAnchor446"><em class="italic">Chapter 5</em></a>, <em class="italic">Inspecting Process Injection and API Hooking</em>, we covered how malware can loop through all running processes using the <code>CreateToolhelp32Snapshot</code>, <code>Process32First</code>, and <code>Process32Next</code> APIs. In this anti-reverse engineering trick, the malware uses these APIs in exactly the same way to check the process name against a list of unwanted process names or their hashes. If there’s a match, the malware terminates itself or uses an approach such as calling the <code>TerminateProcess</code> API to kill that process. The following screenshot shows an example of this trick being implemented in Gozi malware:</p>
			<div><div><img src="img/Figure_6.19_B18500.jpg" alt="Figure 6.19 – Gozi malware looping through all of the running processes&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Fig<a id="_idTextAnchor641"/>ure 6.19 – Gozi malware looping through all of the running processes</p>
			<p>The following screenshot <a id="_idIndexMarker915"/>shows an example of Gozi malware code using the <code>TerminateProcess</code> API to kill a process of its choice found by its name in a custom <code>ProcOpenProcessByNameW</code> routine:</p>
			<div><div><img src="img/Figure_6.20_B18500.jpg" alt="Figure 6.20 – Gozi malware terminating a process with the help of the ProcOpenProcessByNameW function&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.20 – Gozi malware terminating a process with the help of the ProcOpenProcessByNameW function</p>
			<p>This trick can be bypassed by renaming the tools you are using before executing them. This simple solution could hide your tools perfectly if you just avoid using any known ke<a id="_idTextAnchor642"/><a id="_idTextAnchor643"/>ywords in the newer names, such as <em class="italic">dbg</em>, <em class="italic">disassembler</em>, <em class="italic">AV</em>, and more.</p>
			<h2 id="_idParaDest-218"><a id="_idTextAnchor644"/>Searching for the tool window</h2>
			<p>Another trick would be not to<a id="_idIndexMarker916"/> search for the tool’s process name, but to search for its window name (the window’s title) instead. By searching for a program window name, malware can bypass any renaming that could be performed on the process name, which gives it an opportunity to detect new tools, too (for t<a id="_idTextAnchor645"/>he most part, window names are more descriptive than process names).</p>
			<p>This trick can be carried out in the following two ways:</p>
			<ul>
				<li>Using <code>FindWindow</code>: Malware can use either the full window title, such as <em class="italic">Microsoft network monitor</em>, or the window class name. The window class name is a name that was given to this window when it was created, and it’s different from the title that appears on the window. For example, the <code>OllyDbg</code> window class name is <code>OLLYDBG</code>, while the full title could change based on the process name of the malware under analysis. An example of this is as follows:<pre>push NULL
push .szWindowClassOllyDbg
call FindWindowA
test eax,eax
jnz &lt;debugger_found&gt;
push NULL
push .szWindowClassWinDbg
call FindWindowA
test eax,eax
jnz &lt;debugger_found&gt;
.szWindowClassOllyDbg db "OLLYDBG",0
.szWindowClassWinDbg db "WinDbgFrameClass",0</pre></li>
				<li>Using <code>EnumWindows</code>: Another<a id="_idIndexMarker917"/> way to avoid searching for the window class name or dealing with the change of window titles is to just go through all the window names that are accessible and scan their titles, searching for suspicious window names such as <em class="italic">Debugger</em>, <em class="italic">Wireshark</em>, <em class="italic">Disassembler</em>, and more. This is a more flexible way to deal with new tools or tools the malware author forgot to cover. With the <code>EnumWindows</code> API, you need to set a callback to receive all of the windows.</li>
			</ul>
			<p>For each top-level window, this callback will receive the handle of this window, from which it can get its name using the <code>GetWindowText</code> API. An example of this is as follows:</p>
			<div><div><img src="img/Figure_6.21_B18500.jpg" alt="Figure 6.21 – The FinFisher threat using EnumWindows to set its callback function&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.21 –<a id="_idTextAnchor646"/> The FinFisher threat using EnumWindows to set its callback function</p>
			<p>The callback function declaration looks like this:</p>
			<pre class="source-code">
BOOL CALLBACK EnumWindowsProc(
_In_ HWND hwnd,
_In_ LPARAM lParam);</pre>
			<p>The <em class="italic">hwnd</em> value is the handle of the window, while <em class="italic">lParam</em> is a user-defined argument (it’s passed by the user to the callback function). Malware can use the <code>GetWindowText</code> API with this handle (<em class="italic">hwnd</em>) to get the window title and scan it against a predefined list of keywords.</p>
			<p>It’s more complicated to <a id="_idIndexMarker918"/>modify window titles or classes than actually set breakpoints on these APIs and track the callback function to bypass them. There are plugins for popular tools, such as OllyDbg and IDA, that can help rename their title window to avoid detection (such as OllyAdvanced), which you can also use as a solution.</p>
			<p>Now we know how behavioral analys<a id="_idTextAnchor647"/><a id="_idTextAnchor648"/>is tools can be detected, let’s learn about sandbox and VM detection.</p>
			<h1 id="_idParaDest-219"><a id="_idTextAnchor649"/>Detecting sandboxes and VMs</h1>
			<p>Malware authors<a id="_idIndexMarker919"/> know that if their malware sample is running on a VM, then it’s<a id="_idIndexMarker920"/> probably being analyzed by a reverse engineer or it’s probably running under the analysis of an automated tool such as a sandbox. There are multiple ways in which m<a id="_idTextAnchor650"/>alwar<a id="_idTextAnchor651"/>e authors can detect VMs and sandboxes. Let’s go over some of them now.</p>
			<h2 id="_idParaDest-220"><a id="_idTextAnchor652"/>Different output between VMs and real machines</h2>
			<p>Malware authors could use certain unique characteristics of some assembly instructions when executed on VMs. Some examples of these are listed as follows:</p>
			<ul>
				<li><code>CPUID</code> instruction returns information about the CPU and provides a leaf/ID of<a id="_idIndexMarker921"/> this information in <code>eax</code>. For leaf 0x01 (<em class="italic">eax = 1</em>), the <code>CPUID</code> instruction sets bit 31 to 1, indicating that the operating system is running inside a VM or a hypervisor.</li>
				<li><code>CPUID</code> instruction, given <em class="italic">eax = 0x40000000</em>, it could return the name <a id="_idIndexMarker922"/>of the virtualization tool (if present) in the EBX, ECX, and EDX registers as if they comprised a single string. Examples of such name st<a id="_idTextAnchor653"/>rings include <em class="italic">VMwareVMware</em>, <em class="italic">Microsoft Hv</em>, <em class="italic">VBoxVBoxVBox</em>, and <em class="italic">XenVMMXenVMM</em>.</li>
				<li><strong class="bold">MMX registers</strong>: MMX registers<a id="_idIndexMarker923"/> are a set of registers that were introduced by Intel that help speed up graphics calculations. While rare, some virtualization tools don’<a id="_idTextAnchor654"/>t support them. Some malware or packers use them for unpacking in order to detect or avoid running on a VM.</li>
				<li><code>IN</code> instruction, when executed on the VMware VM with a port argument set to 0x5658 (which stands for <em class="italic">VX</em> in ASCII, a VMware hypervisor port) and with the<a id="_idIndexMarker924"/> EAX value equal to 0x564D5868 (the <em class="italic">VMXh</em> magic value), will return the same magi<a id="_idTextAnchor655"/>c value of <em class="italic">VMXh</em> in the EBX register, this way revealing the presence of the VM.</li>
			</ul>
			<h2 id="_idParaDest-221"><a id="_idTextAnchor656"/>Detecting virtualization processes and services</h2>
			<p>Virtualization software <a id="_idIndexMarker925"/>commonly installs some tools on the guest<a id="_idIndexMarker926"/> machine to enable clipboard synchronization, drag and drop, mouse synchronization, and other useful features. These tools can be easily detected by scanning for these processes using the <code>CreateToolhelp32Snapshot</code>, <code>Process32First</code>, and <code>Process32Next</code> APIs. Some of these processes are listed as follows:</p>
			<ul>
				<li><code>VMware</code>:<ul><li><code>vmacthlp.exe</code></li><li><code>VMwareUser.exe</code></li><li><code>VMwareService.exe</code></li><li><code>VMwareTray.exe</code></li></ul></li>
				<li><code>VirtualBox</code>:<ul><li><code>VBoxService.exe</code></li><li><code>VBoxTray.exe</code></li></ul></li>
			</ul>
			<p>The same <a id="_idIndexMarker927"/>approa<a id="_idTextAnchor657"/><a id="_idTextAnchor658"/>ch can be used to search for particular files or <a id="_idIndexMarker928"/>directories on the filesystem.</p>
			<h2 id="_idParaDest-222"><a id="_idTextAnchor659"/>Detecting virtualization through registry keys</h2>
			<p>There are <a id="_idIndexMarker929"/>multiple registry keys that can be <a id="_idIndexMarker930"/>used to detect virtualization environments. Some of them are related to the hard disk name (which is, usually, named after the virtualization software), the installed virtualization sync tools, or other settings in the virtualization process. Some of these registry entries are as follows:</p>
			<pre class="source-code">
HKEY_LOCAL_MACHINE\SOFTWARE\Vmware Inc.\Vmware Tools
HKEY_LOCAL_MACHINE\SOFT<a id="_idTextAnchor660"/><a id="_idTextAnchor661"/><a id="_idTextAnchor662"/>WARE\Oracle\VirtualBox Guest Additions
HKEY_LOCAL_MACHINE\HARDWARE\ACPI\DSDT\VBOX</pre>
			<h2 id="_idParaDest-223"><a id="_idTextAnchor663"/>Detecting VMs using WMI</h2>
			<p>It’s not <a id="_idIndexMarker931"/>just registry values that reveal lots of information<a id="_idIndexMarker932"/> about the virtualization software—Windows-managed information, which is accessible using, for example, PowerShell, can also be used, as shown in the following screenshot:</p>
			<div><div><img src="img/Figure_6.22_B18500.jpg" alt="Figure 6.22 – The PowerShell command to detect VMWare&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.22 – The PowerShell command to detect VMWare</p>
			<p>This information can be accessed through a WMI query, such as the following:</p>
			<pre>SELECT * FROM Win32_ComputerSystem WHERE Manufacturer LIKE "%VMware%" AND Model LIKE "%VMware Virtual Platform%"</pre>
			<p>For Microsoft Hyper-V, it would be as follows:</p>
			<pre>SELECT * FROM Win32_ComputerSystem WHERE Manufacturer LIKE "%Microsoft Corporation%" AND Model LIKE "%Virtual Machine%"</pre>
			<p>Th<a id="_idTextAnchor664"/>ese<a id="_idIndexMarker933"/> techniques make it harder to hide the fact that this malware is running inside <a id="_idIndexMarker934"/>virtualization software and not on a real machine.</p>
			<h2 id="_idParaDest-224"><a id="_idTextAnchor665"/>Other VM detection techniques</h2>
			<p>There are lots of other techniques that<a id="_idIndexMarker935"/> malware families can use to detect virtualized environments, such as the following:</p>
			<ul>
				<li>Named pipes and devices, for example, <em class="italic">\\.\pipe\VBoxTrayIPC</em></li>
				<li>Window titles or class names, such as <em class="italic">VBoxTrayToolWndClass</em> or <em class="italic">VBoxTrayToolWnd</em></li>
				<li>The first part of the MAC address on their network adapter:<ul><li>00:1C:14, 00:50:56, 00:05:69, 00:0C:29 – VMWare</li><li>08:00:27 – VirtualBox</li><li>00:03:FF – Hyper-V</li></ul></li>
			</ul>
			<p>The preceding list can be<a id="_idIndexMarker936"/> further expanded with many similar techniques and approaches for detecting a virtualized environment.</p>
			<h2 id="_idParaDest-225"><a id="_idTextAnchor666"/>Detecting sandboxes using default settings</h2>
			<p>Sandboxes <a id="_idIndexMarker937"/>can also be easy to detect. They have lots <a id="_idIndexMarker938"/>of default settings that malware authors can use to identify them:</p>
			<ul>
				<li>The usernames could be default values, such as <em class="italic">cuckoo</em> or <em class="italic">user</em>.</li>
				<li>The filesystem could include the same decoy files and the same structure of the files (if not, then the same number of files). Even the name of the sample itself can always be the same, such as <em class="italic">sample.exe</em>.</li>
			</ul>
			<p>These settings can be easily detected for commonly used sandboxes, without even looking at their known tools and processes.</p>
			<p>Apart from that, sandboxes are commonly detected by the following characteristics:</p>
			<ul>
				<li>Too weak system hardware (mainly disk space and RAM)</li>
				<li>Unusual system settings (very low screen resolution or no software installed)</li>
				<li>No user interaction (lack of mouse moves or recent file modifications)</li>
			</ul>
			<p>One more common way to evade sandboxes is to avoid performing malicious activities in their analysis time window. In many cases, sandboxes execute malware only for several seconds or minutes and then collect the necessary information before terminating the VM. Some malware families use APIs such as <code>Sleep</code> or perform long calculations to delay the execution for quite some time or run it after a machine restart. This trick can help malware evade sandboxes and ensure that they don’t collect important information, such as C&amp;C domains or malware-persistence techniques.</p>
			<p>These are some of the most common sandbox detection techniques. It is worth mentioning that malware developers keep inventing more and more novel approaches <a id="_idTextAnchor667"/>to achieve this goal, so staying on top of them requires constant learning and practice.</p>
			<h1 id="_idParaDest-226"><a id="_idTextAnchor668"/>Summary</h1>
			<p>In this chapter, we covered many tricks that malware authors use to detect and evade reverse engineering, from detecting the debugger and its breakpoints to detecting VMs and sandboxes, as well as incorporating obfuscation and debugger-escaping techniques. You should now be able to analyze more advanced malware equipped with multiple anti-debugging or anti-VM tricks. Additionally, you will be able to analyze a highly obfuscated malware implementing lots of anti-disassembling tricks.</p>
			<p>In <a href="B18500_07.xhtml#_idTextAnchor669"><em class="italic">Chapter 7</em></a>, <em class="italic">Understanding Kernel-Mode Rootkits</em>, we are going to enter the operating system’s core. We are going to cover the kernel mode and learn how each API call and operation works internally in the Windows operating system, as well as how rootkits can hook each of these steps to hide malicious activity from antivirus products and the user’s eyes.</p>
		</div>
		<div><div></div>
		</div>
	</body></html>