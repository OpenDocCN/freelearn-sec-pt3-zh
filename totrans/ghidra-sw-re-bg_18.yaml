- en: Assessments
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Chapter 1
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'No one reverse engineering framework is the ultimate. Each reverse engineering
    framework has its own strengths and weaknesses. We can mention some current Ghidra
    strengths when comparing Ghidra with most other reverse engineering frameworks:'
  id: totrans-2
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '- It is open source and free (including its decompiler).'
  id: totrans-3
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- It supports a lot of architectures (it may be the framework you are using
    is not supported yet).'
  id: totrans-4
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- It can load multiple binaries at the same time in a project. This feature
    allows you to easily apply operations over many related binaries (for example,
    an executable binary and its libraries).'
  id: totrans-5
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- It allows collaborative reverse engineering by design.'
  id: totrans-6
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- It supports big firmware images (1 GB +) without problems.'
  id: totrans-7
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- It has awesome documentation, which includes examples and courses.'
  id: totrans-8
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- It allows version tracking of binaries allowing the matching of functions
    and data and their markup between different versions of the binary.'
  id: totrans-9
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'But we can also mention an important weakness:'
  id: totrans-10
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- Ghidra Python scripting relies on Jython (a Java implementation of Python)
    and it currently doesn''t support Python 3\. Since Python 2.x is currently deprecated,
    this is a significant weakness of Ghidra.'
  id: totrans-11
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The bar located in the upper-right margin of the disassembly window allows you
    to customize the disassembly view:![Disassembly listing configuration
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/image_00_001.jpg)'
  id: totrans-13
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Disassembly listing configuration
  id: totrans-14
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'By right-clicking on the **PCode** field, PCode will appear in the disassembly
    listing:'
  id: totrans-15
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Enable the PCode field in disassembly'
  id: totrans-16
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/image_00_002.jpg)'
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Enable the PCode field in disassembly
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The following figure shows the resulting disassembly listing after enabling
    the **PCode** field:'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Disassembly listing with PCode enabled'
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/image_00_003.jpg)'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Disassembly listing with PCode enabled
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: As you can see in the screenshot, for each assembly instruction, one or more
    PCode instructions are generated.
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The disassembly view is a view of the instructions using the language of the
    processor while the decompiler view shows pseudo-C decompiled code:![Comparing
    disassembled with decompiled code
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/image_00_004.jpg)'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Comparing disassembled with decompiled code
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding screenshot, you can see a disassembly view in the left margin
    showing the same code as the decompiled view located in the right margin.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 2
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ghidra scripts are useful because they can be used to automatize reverse engineering
    tasks.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Some tasks that you can automatize using Ghidra scripts are the following:'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- Searching for strings and code patterns'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- Automatically deobfuscating code'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- Adding useful comments to enrich the dissasembly'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Scripts are organized by category, as shown on the left-hand side of the following
    screenshot:![Script Manager
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/image_00_005.jpg)'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Script Manager
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'When clicking on the checklist icon located in the upper-right margin, as shown
    in the preceding screenshot taken from the Script Manager window, the paths of
    script directories will be shown:'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Script Directories'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/image_00_006.jpg)'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Script Directories
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'But the organization of the scripts in the Script Manager is taken from the
    `@category` field located in the header of the script code, as shown in the following
    listing:'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: //TODO write a description for this script //@author **//@category Strings**
    //@keybinding //@menupath //@toolbar
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Notice that the previous script header is a Python header, but an analogous
    header is used when writing JavaScript for Ghidra.
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Ghidra is written in the Java language (of course, the decompiler is not; it
    is written in the C++ programming language), so the API of Ghidra is exposed in
    Java. It is the same in Python because the Python API consists of a Java bridge
    powered by Jython, a Java implementation of Python.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 3
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Yes. ZIP files containing the source code are attached to the same folder that
    the JAR file you want to debug exists in. To link the source code with the JAR
    file using the Eclipse IDE, right-click on the JAR file and then enter the ZIP
    file in the Workspace location field of the Java Source Attachment section as
    shown in the following screenshot:![Linking to Graph.jar file with its own source
    code
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/image_00_007.jpg)'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Linking to Graph.jar file with its own source code
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: After that, you will be able to expand the JAR file, showing included `*.class`
    files.
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Yes, it is possible, as demonstrated in the following blog post:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[https://reversing.technology/2019/11/18/ghidra-dev-pt1.html](https://reversing.technology/2019/11/18/ghidra-dev-pt1.html)'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: But remember that the Eclipse IDE is the only one officially supported by Ghidra.
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Some vulnerabilities were found in Ghidra but those and any other ones are probably
    not NSA backdoors into the program. The NSA has its own zero-day exploits to hack
    computers and, for sure, doesn't need to introduce backdoors into its own programs
    to hack the computers of people around the world. In fact, to do so would be a
    terrible move in terms of reputation.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 4
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Ghidra extension is code that extends Ghidra with new features while scripts
    are code for assisting the reverse engineering process by automating tasks.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since this task consists of analyzing the code and improving it, you will need
    to write or incorporate a new Ghidra Analyzer extension in order to extend the
    analysis capabilities of Ghidra.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As explained in the first question for this chapter, Ghidra scripts and Ghidra
    extensions have different purposes so use Ghidra scripts to automate reverse engineering
    tasks applied over the disassembly listing and use Ghidra extensions if you want
    to extend or improve Ghidra with new features.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 5
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imports leak the capabilities of malware taken from dynamic linking libraries,
    including operating system libraries, which enables communication for the malware
    with the outside. Sometimes the malware dynamically loads dynamic linking libraries
    (via the LoadLibrary API) and dynamically imports functions (via the `GetProcAddress`
    API), so you will not see the full set of imported libraries during a static analysis
    without further analysis than opening the binary with Ghidra and looking for the
    imports.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Yes. You can use a Ghidra analyzer to extract object-oriented information from
    the disassembly (for example, objects, methods, and so on) and improve the disassembly
    listing using this information. Or, use a Ghidra analyzer to enrich the disassembly
    listing with object-oriented information obtained from a third-party source.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'There are a lot of benefits to it:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '- Bypass firewall rules if the application the code is injected into has associated
    firewall rules that are less restrictive than the original process.'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- To be more stealthy, it is better to inject into a legitimate process than
    creating a new process.'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This list includes some general reasons but the whole list would be extensive.
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Chapter 6
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The appropriate Ghidra API function to set a byte at a given memory address
    is `setByte`.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'I followed these steps to reach this Ghidra Flat API function:'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 1\. I checked the Ghidra Flat API reference provided in [*Chapter 6*](B16207_06_Final_SK_ePub.xhtml#_idTextAnchor108),
    *Scripting Malware Analysis*.
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '2\. I located the set of Ghidra Flat API functions of interest: `setByte`.'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 4\. I checked the online documentation of the function to confirm that it was
    the function I was looking for:[https://ghidra.re/ghidra_docs/api/ghidra/program/database/mem/MemoryMapDB.html#setByte(ghidra.program.model.address.Address,byte](https://ghidra.re/ghidra_docs/api/ghidra/program/database/mem/MemoryMapDB.html#setByte(ghidra.program.model.address.Address,byte)).
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '5\. The description matched my needs: **Write byte at addr**. So, we can use
    it for that.'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Ghidra is written in the Java programming language and this is why this language
    is the most supported (of course, the decompiler is not; it is written in the
    C++ programming language) so the API of Ghidra is naturally exposed in Java.The
    Java API is better than the Python API because the Python API is a bridge to the
    Java API implemented by Jython, a Java implementation of Python.So, issues with
    Jython could happen, which doesn''t happen with Java. Let''s pick a random issue
    to demonstrate this: [https://github.com/NationalSecurityAgency/ghidra/issues/2369](https://github.com/NationalSecurityAgency/ghidra/issues/2369).'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Or look for Jython issues on your own following this link: [https://github.com/NationalSecurityAgency/ghidra/search?q=jython&type=issues](https://github.com/NationalSecurityAgency/ghidra/search?q=jython&type=issues).'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Yes. By using Ghidra scripts, you can compute values that are calculated at
    runtime and enrich the disassembly with it.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 7
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can execute headed scripts in headless mode only if those scripts don't
    make use of GUI APIs and vice versa. You can execute headless mode scripts in
    Ghidra headed mode only if those scripts don't make use of functions proper of
    headless, otherwise, an exception will be thrown.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ghidra headed mode is useful to perform a visual and mostly manual analysis
    of the binary by analyzing the graph, improving it, reading the disassembly listing,
    and so on. On the other hand, headless mode is adequate to perform automatic analysis
    or apply a script over a set of binaries.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The difference is that `grep` or `strings` will return any matching string found
    in the binary while Ghidra will return matching strings recognized by the analyzer.
    So, for instance, you will also be able to identify references to it in the disassembly
    listing and spurious strings won't will be taken into account by Ghidra.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 8
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'No, memory corruption is a type of software vulnerability but many more exist.
    For instance, race condition vulnerabilities:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '- `free()` twice on the same memory address, potentially leading to the modification
    of unexpected memory locations.'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: It is considered unsafe because the size of the destination buffer where the
    source buffer will be copied is not taken into account, so it can easily lead
    to a buffer overflow.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The three usual binary protection methods are as follows:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '- **Stack canaries**: In this method we put a precomputed value (the canary)
    before the return address such that the return address cannot be overwritten without
    overwriting that value first. The integrity of the canary can be checked after
    returning from the function.'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- **DEP (Data Execution Prevention) / NX (do not execute)**: Makes the stack
    non-executable, so the attacker cannot simply execute the shellcode on the stack.'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- **ASLR (Address Space Layout Randomization)/PIE (Position-Independent Executable)**:
    Randomizes the location where system executables are loaded into memory, so the
    attacker cannot easily know where exactly to redirect the flow of the program
    if hijacked.'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Yes, it is sometimes possible to bypass all the methods mentioned to achieve
    code execution.
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Chapter 9
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SLEIGH is a processor specification language that formally describes the translation
    from the bit encoding of machine instructions, for a particular processor, to
    human-readable assembly language and into PCode.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the other hand, PCode is an **intermediate representation** **(IR)** that
    can be translated into the assembly instructions of a specific processor. Being
    more precise, it is a **register transfer language** **(RTL)**. PCode is used
    to describe data flow at the register-transfer level of an architecture.
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: No, it isn't.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: PCode is useful because it can be translated into a large set of different assembly
    languages. In practice, if you develop a tool for Pcode, you automatically support
    a lot of architectures. Furthermore, PCode offers more granularity than assembly
    language (one assembly instruction is translated into one or more PCode instructions)
    so you can control side-effects better. This property is very useful when developing
    some kinds of tools.
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Chapter 10
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ghidra is mostly implemented in the Java language but, of course, the decompiler
    was implemented in the C++ language.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can use a Ghidra plugin for that. For instance, you can install the following
    available plugins, allowing debugging synchronization:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '- **GDBGhidra**: [https://github.com/Comsecuris/gdbghidra](https://github.com/Comsecuris/gdbghidra)'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- **ret-sync (Reverse-Engineering Tools SYNChronization)**: [https://github.com/bootleg/ret-sync](https://github.com/bootleg/ret-sync)'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: A provider is Java code implementing the Ghidra plugin **Graphical User Interface
    (GUI)**.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 11
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A raw binary is a file that contains unprocessed data, so it has no format in
    any way while formatted binaries are binary files following a format specification
    such that they can be parsed, for instance, by Ghidra.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the file being analyzed follows a format specification, it is much more comfortable
    to let the loader automatically define the bytes as code or strings, create symbols,
    and so on. When dealing with raw binaries you will need to manually process the
    data. Therefore, it is much more confortable for a reverse engineer to deal with
    formatted binaries when possible rather than raw binaries.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Old-style DOS executable is the format for MS-DOS executable binaries. The
    Ghidra loader for old-style DOS executable files is developed by the following
    pieces of software:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '- `DOSHeader.java`: A Java file implementing the old-style DOS executable parser.'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- `OldStyleExecutable.java`: A class that uses `FactoryBundledWithBinaryReader`
    to read data from a generic byte provider and passes it to the `DOSHeader` class
    in order to parse it. The `OldStyleExecutable` class exposes both via getter methods:
    `DOSHeader` and the underlying `FactoryBundledWithBinaryReader` object.'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Chapter 12
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A processor module adds support for a processor using the SLEIGH processor specification
    language while an analyzer module is Java code for extending Ghidra code analysis
    in order to identify functions, detect parameters when calling a function, and
    so on.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Yes. Tags indicating the possible start of a function or a code boundary are
    relative to the patterns being declared.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A language refers to a microprocessor architecture. Since a microprocessor architecture
    embraces a family of instruction set architectures, the term language variant
    means each one of those instruction set architectures belonging to the same microprocessor
    architecture.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 13
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'No. Ghidra is an open source project and you can join the community whenever
    you wish. You can join it by simply creating a Ghidra account and going to the
    following URL:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不行。Ghidra是一个开源项目，你可以随时加入社区。你只需要创建一个Ghidra账户并访问以下网址即可加入：
- en: '[https://github.com/NationalSecurityAgency/ghidra/](https://github.com/NationalSecurityAgency/ghidra/)'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://github.com/NationalSecurityAgency/ghidra/](https://github.com/NationalSecurityAgency/ghidra/)'
- en: 'You can interact with them, for instance, via GitHub by writing comments, proposing
    pull requests to Ghidra with your own code, and much more: [https://github.com/NationalSecurityAgency/ghidra/](https://github.com/NationalSecurityAgency/ghidra/).'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以通过GitHub与他们互动，例如，写评论、向Ghidra提出带有你自己代码的拉取请求，等等：[https://github.com/NationalSecurityAgency/ghidra/](https://github.com/NationalSecurityAgency/ghidra/)。
- en: 'There are several chat links you can follow to chat with other members:'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有几个聊天链接可以用来与其他成员交流：
- en: '- Telegram: [https://t.me/GhidraREandhttps://t.me/GhidraRE_dev](https://t.me/GhidraREandhttps://t.me/GhidraRE_dev)'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '- Telegram：[https://t.me/GhidraREandhttps://t.me/GhidraRE_dev](https://t.me/GhidraREandhttps://t.me/GhidraRE_dev)'
- en: '- Matrix: [https://riot.im/app/#/group/+ghidra:matrix.org](https://riot.im/app/#/group/+ghidra:matrix.org)'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '- 矩阵：[https://riot.im/app/#/group/+ghidra:matrix.org](https://riot.im/app/#/group/+ghidra:matrix.org)'
- en: '- Discord: [https://discord.com/invite/S4tQnUB](https://discord.com/invite/S4tQnUB)'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '- Discord：[https://discord.com/invite/S4tQnUB](https://discord.com/invite/S4tQnUB)'
- en: Chapter 14
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第14章
- en: Concrete execution means running a program using concrete values (for example,
    the `eax` register takes the value 5) while symbolic execution runs the program
    using symbolic values that can be expressed using `eax` register is a vector of
    32 bits whose value, at this moment, is less than 5).
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 具体执行意味着使用具体的值来运行程序（例如，`eax`寄存器的值为5），而符号执行则使用符号值运行程序，这些符号值可以通过`eax`寄存器表示，`eax`寄存器是一个32位的向量，其值此刻小于5。
- en: No, it can't. It is not possible to perform symbolic execution in an efficient
    way for general cases.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不行，它做不到。对于一般情况，无法以高效的方式执行符号执行。
- en: Yes. You can extend Ghidra to apply symbolic and/or concolic execution to binary
    files.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是的。你可以扩展Ghidra，将符号执行和/或合成执行应用于二进制文件。
