- en: Macro Instructions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using Assembly language for the implementation of your ideas is fun (I surely
    have said that already and, probably, even more than once). However, it may become
    quite annoying when it comes to certain operations, which have to be re-implemented
    in different parts of your program. One possible solution may be implementing
    those operations in the form of a procedure and calling it when needed. However,
    this may quickly become a nuisance as well, once you have a procedure; which receives
    more than zero parameters. While in high-level languages you simply "pass" the
    parameters to a function, in Assembly, you have to actually pass them to a procedure
    in accordance with the calling convention of your choice, which, in turn, may
    imply additional headache with management of registers (if parameters are passed
    via certain registers) or accessing the stack. Sometimes, this complication is
    worth it, but that is not always the case, especially when it comes to a short
    set of recurring instructions. This is exactly the case where macro instructions
    may save us from a lot of headaches and redundant efforts, not to mention the
    amount of CPU time spent on calls (parameter preparations and procedure prolog
    and epilog), tiny fractions of a millisecond which may, at the end, aggregate
    into quite substantial delays.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Macro instructions and the mechanisms behind them
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How macro instructions may be parameterized
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning variadic macro instructions and power thereof
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting acquainted with common calling conventions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examining additional assembler directives and conditional assembly
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of this is essential for our future work with this book, as the methods
    and algorithms we will explore would be too cumbersome otherwise.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: What are macro instructions?
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First of all, before we submerge into the world of macro instructions, we have
    to understand what they actually are. Putting it the simplest way, macro instructions
    are aliases for sequences of instructions. You may be familiar with the term from
    high-level languages ( we say "may be" because not all high-level languages implement
    this feature), but we'll still explain it here. Remember the following sequence
    from the previous chapter?
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This sequence loads all four singles of an XMM register (in this specific case,
    it was XMM3) with a single precision floating point value from memory pointed
    by `dpy`. We used such sequences several times in our code, so it would be natural
    to try and replace it with a single macro instruction. Thus, defining the following
    macro would make our code look more elegant and readable:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We use it in our code like this:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This would make the code look more elegant and much more readable.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: 'Parentheses are a great feature of FASM and are present neither in MASM nor
    in GAS. Instead, you would write the following code for MASM:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '`MACRO macro_name`'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '`; macro body`'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '`ENDM`'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: 'And the following code for GAS:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '`.macro macro_name`'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '`; macro_body`'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '`` `.endm` ``'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: How it works
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The logic behind macro instructions is quite simple. The preprocessor parses
    the code for the definitions of macro instructions and stores them, simply speaking,
    in the form of a dictionary, where the name of the macro instruction is the key
    and its content is the value. Of course, in reality, it is more complicated, as
    macro instructions may have (and most of the time, they do have) parameters, not
    to mention the fact that they may also be variadic (have an undefined number of
    parameters).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: 'When the assembler processes the code and encounters unknown instructions,
    it checks this dictionary for a macro instruction with the corresponding name.
    Once such an entry is found, the assembler replaces the macro instruction with
    its value--expands macro. Consider that the assembler sees the following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then, it refers to the collected macro instruction definitions and replaces
    this line with the actual code:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If the assembler finds no relevant macro definition, we are notified of this
    via the error reporting mechanism.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Macro instructions with parameters
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Although you definitely can define a macro instruction that receives no parameters
    at all, you would rarely need to do this. Most of the time, you would define macro
    instructions that need at least one parameter. Let us take, for example, a macro
    instruction that implements the procedure prolog:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `frameSize` property in the preceding macro instruction is a macro parameter
    which, in this case, is used to specify the size of the stack frame in bytes.
    The usage of such a macro instruction would be as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The preceding code is logically equivalent to (and is expanded by the preprocessor
    into) the following:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In addition, we may define the `return` macro, which would implement the destruction
    of the stack frame and return from the procedure:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This would make our procedure even shorter:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, the `return` macro is also a good example of parameterless macro instruction.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: Variadic macro instructions
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In certain cases, we do not know how many parameters would be passed to the
    same macro instruction used in different places in our code, and FASM provides
    a great and easy solution for such a problem--support for variadic macro instructions.
    The term *variadic* means that an operator, a procedure, or a macro can take a
    varying number of operands/parameters.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: 'Syntactically, variadic macro instructions are very simple. We begin with the
    macro keyword, then the name of the macro followed by a comma-separated list of
    parameters, if any. The variadic portion of the list of parameters is enclosed
    in square brackets. For example, should we have a macro instruction that expands
    to the `printf()` function or invokes it, and we want it to have a similar declaration,
    then the macro declaration would start like this:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here, `fmt` stands for the format argument of the `printf()` function and `args`
    represents all optional parameters.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider a very simple example of the reworked `prolog` macro, which,
    in addition to the size of a stack frame, receives the list of registers that
    need to be stored on the stack as they would be altered in the body of a procedure:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, you've definitely noticed the `common` and `forward` keywords, which are
    essential for the correctness of the expansion of this macro instruction. The
    interesting feature of variadic macro instructions is that the content thereof
    is expanded for each and every variadic parameter (parameters specified in square
    brackets). As the creation of the stack frame after each and every register (specified
    by the `regs` parameter) is pushed onto stack would look weird, we have to instruct
    the preprocessor to expand a specific portion of the macro instruction only once,
    and this is what the `common` keyword does.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: 'The `forward` keyword (and its counterpart, the `reverse` keyword) instructs
    the preprocessor about the order the variadic parameters should be processed in.
    The line `push regs` expands into the `push` instruction for each parameter specified
    in `regs` and the preceding `forward` keyword instructs the preprocessor to process
    parameters in exactly the order they were written in. For example, consider the
    following code:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This piece of code would expand to the following:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let''s apply proper fixes to the `return` macro instruction for the sake of
    completeness:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Here, for the sake of an example, we use the `reverse` keyword, as we specify
    registers that should be retrieved from stack in exactly the same order in which
    they were passed to the `prolog` macro instruction. The procedure would then look
    like this:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: An introduction to calling conventions
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When writing code in Assembly language, it's preferable to stick to certain
    calling conventions (the way parameters are passed to procedures) when invoking
    procedures because, first of all, this minimizes the occurrence of annoying and
    hard to find errors and, of course, help you link your Assembly modules to high-level
    languages. There are quite a few calling conventions for Intel Architecture, but
    we will only consider some of them, which we will use later in this book.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: We already know about procedures and we have even mentioned the term "calling
    convention" in the previous chapter, so you may wonder why it is now that we cover
    the mechanism itself. The answer is quite simple--invocation of a procedure is
    a process that requires certain preparations, and, as such preparations would
    logically be the same with every procedure call, it is obvious to implement these
    preparations in the form of macro instruction.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s see the calling conventions that we will cover in this part of
    the chapter:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ecf71298-a12a-4430-a2ad-7667c82a00a0.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
- en: cdecl (32-bit)
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `cdecl` calling convention is the standard convention in C and C++ high-level
    languages. Parameters are stored on a stack with the rightmost parameter pushed
    onto stack first and the leftmost parameter pushed onto stack last. It is the
    caller's responsibility to restore the stack once it regains control.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest macro that emulates the `cdecl` procedure invocation would be
    as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `if` clauses here are self-explanatory; however, you may simply ignore them
    for now as they will be covered a bit later in this chapter.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: stdcall (32-bit)
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `stdcall` calling convention is almost identical to `cdecl` in that parameters
    are passed on to the stack in the same manner--the rightmost is pushed first and
    leftmost is pushed last. The only difference is that the caller does not have
    to take care of stack cleanup:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Let''s consider a simple example that uses both the calling conventions:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'While all is clear with the `cdecl_proc` and `stdcall_proc` procedures, let''s
    take a closer look at what the `main` procedure expands to:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In the preceding example, the `stdcall` macro invocation also illustrates what
    happens when there is more than one parameter--the rightmost parameter is pushed
    first. Such mechanisms allow easier and more intuitive addressing of parameters
    within the function. Given the nature of a stack frame, we could access them as
    follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We are using an EBP register as the base pointer. The first (leftmost) parameter
    is located at offset `8` from the value stored in EBP, as the procedure''s return
    address and the previously pushed value of EBP register occupy exactly 8 bytes.
    The following table shows the content of the stack after the creation of the stack
    frame:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '| **Offset from EBP** | **Content** |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
- en: '| +12 | rightmost parameter (32) |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
- en: '| +8 | leftmost parameter (128) |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
- en: '| +4 | procedure return address |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
- en: '| EBP points here | previous value of EBP |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
- en: '| -4 | first stack frame variable |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
- en: '| .... | other stack frame variables |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
- en: '| .... | saved registers |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
- en: '| ESP points here | current stack position |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
- en: Microsoft x64 (64-bit)
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Microsoft uses its own calling convention in the 64-bit mode (long mode) using
    a mixed register/stack paradigm for passing procedure parameters. This means that
    only the first four parameters may be passed via registers and the rest (if any)
    should be pushed onto the stack. The following table illustrates which registers
    are used and in what manner:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '| **Parameter index** **(zero based)** | **Integer/pointer** | **Floating point**
    |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
- en: '| 0 | RCX | XMM0 |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
- en: '| 1 | RDX | XMM1 |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
- en: '| 2 | R8 | XMM2 |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
- en: '| 3 | R9 | XMM3 |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
- en: 'All of this looks quite clear, yet there are two things that we need to pay
    special attention to:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: The stack must be aligned on a 16-bytes boundary
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A 32-bytes shadow space on the stack is required--32 bytes between the last
    pushed stack parameter (if any) and the return address
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following macro instruction (`ms64_call`) is simplistic; it is a primitive
    implementation of this calling convention. This specific macro does not support
    stack parameters:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Consider an example of calling the procedure labeled `my_proc` in the 64-bit
    code, using Microsoft x64 calling convention:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Such a macro instruction would be expanded to the following:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: AMD64 (64-bit)
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The AMD64 calling convention is used on 64-bit Unix-like systems by default.
    The idea is very similar except that a different set of registers is used and
    there is no shadow space requirement. Another difference is that the AMD64 calling
    convention allows up to 6 integer parameters and up to 8 floating point values
    to be passed via registers:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '| **Parameter index** **(zero based)** | **Integer/pointer** | **Floating point**
    |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
- en: '| 0 | RDI | XMM0 |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
- en: '| 1 | RSI | XMM1 |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
- en: '| 2 | RDX | XMM2 |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
- en: '| 3 | RCX | XMM3 |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
- en: '| 4 | R8 | XMM4 |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
- en: '| 5 | R9 | XMM5 |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
- en: '| 6 | on stack | XMM6 |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
- en: '| 7 | on stack | XMM7 |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
- en: 'The following macro instruction is a primitive implementation of such a mechanism.
    Just as in the case of the Microsoft x64 example, this one does not handle stack
    parameters:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Using such a macro in 64-bit code intended to run on a Unix-like system for
    calling the procedure `my_proc` like this:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Would expand it into:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: A note on Flat Assembler's macro capabilities
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the huge advantages of Flat Assemblers over other assemblers for the
    Intel platform is its macro engine. In addition to being able to perform its original
    task--substituting macro instructions with their definitions--it is able to perform
    relatively complex computations, and I would dare to call it an additional programming
    language. The preceding examples only utilize a tiny fraction of what FASM''s
    macro processor is capable of. While we only used a set of `if` clauses and a
    variable, we may, in necessary cases, use loops (with `while` or `repeat` statements).
    For example, imagine a string of characters that you want to keep encrypted:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Here, `my_string_len` is the length of the string.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '`$` is a special symbol denoting the current address. Thus, `$-my_string` means
    the current address minus the address of `my_string`, which is the length of the
    string.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: 'A simplistic XOR encryption may be applied with just a four-line macro:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `%` symbol here denotes the current iteration and the `-1` value is needed
    because the count of iterations starts at 1.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: This is just a short and primitive example of what the macro engine of FASM
    is able to do, and there is a lot more. However, this book, though it uses FASM
    as a primary assembler, is dedicated to Intel Assembly language rather than to
    specific dialect, so this additional information goes beyond its scope. I strongly
    recommend that you refer to the FASM documentation available at [http://flatassembler.net](http://flatassembler.net).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: Macro instructions in MASM and GAS
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although the core idea behind the macro instruction mechanism is the same across
    all assemblers, the syntax of macro instructions and the capabilities of the engine
    vary. The following are two examples of simple macros for MASM and GAS.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft Macro Assembler
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Remember our test program for MASM in [Chapter 2](cb7ac242-8ebb-4d6a-946a-220133f96674.xhtml),
    *Setting Up a Development
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: 'Environment*? We can replace the code that invokes the `show_message` procedure
    with the following macro instruction:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This may make the code a bit more readable as we may then call the `show_message`
    procedure this way:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The GNU Assembler
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The macro engine of the GNU Assembler is quite similar to that of Microsoft's
    MASM, yet there are a few syntactic differences (not taking into account the overall
    syntax difference) that we have to pay attention to. Let us take the `output_message`
    procedure from the Linux test program in [Chapter 2](https://cdp.packtpub.com/mastering_assembly_programming/wp-admin/post.php?post=221&action=edit#post_52),
    *Setting Up a Development
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: Environment*, and replace the call to `printf()` with a simple macro for demonstration
    purposes.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Other assembler directives (FASM Specific)
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Up until now, we mostly considered macro instructions to be some sort of replacement
    for procedure calls, although I believe it would be correct to refer to them as
    convenience instruments for simplifying the writing and maintenance of the code.
    In this part of the chapter, we will see some so to say built-in macro instructions--assembler
    directives--which may virtually be divided into three categories:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Conditional assembly
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Repeat directives
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inclusion directives
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additional categories may be present depending on assembler implementation.
    You should refer to the documentation of the assembler you are using for more
    information.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: The conditional assembly
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes we may want a macro instruction or a code fragment to be assembled
    differently depending on certain conditions. Both MASM and GAS provide this functionality
    too, but let''s get back to FASM (as the most convenient one) and consider the
    following macro instruction:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: It may appear a bit complicated at first, but the purpose of the macro is rather
    simple. We extend an XOR instruction so that we may specify two memory locations
    as operands, which cannot be done with the original instruction. For simplicity,
    we only operate on double word values.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: In the beginning, we check whether both parameters are labels of memory locations
    and if they are, we load the value from one of them to a register and perform
    a XOR operation, as we would when the first operand is a memory location and the
    second operand is a register.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: If this condition is not true, we move to the second part of the macro instruction,
    where we perform a XOR operation appropriately depending on whether the first
    operand is a memory location or the second one, or whether they are both general
    purpose registers.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, let''s take two variables named `my_var1` and `my_var2` containing
    values `0xCAFECAFE` and `0x02010201`, respectively, and swap them with XOR:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Once processed, the preceding code would expand to this:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: As we see, the `exordd` macro instruction is expanded differently depending
    on its parameters.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Repeat directives
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There may be a need to repeat the same portion of code with minor differences
    or even without them. Assemblers have directives (sometimes referred to as built-in
    macro instructions) that allow us exactly this. There are three such statements
    common to all three assemblers--FASM, MASM and GAS:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '`rept count`: The `rept` directive followed by the `count` parameter simply
    makes `count` copies of the code defined in the block. In case of Flat Assembler,
    we may declare the second parameter, which will equal the number of the current
    iteration (1 based). For example, the following code:'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This would generate an array of hexadecimal characters named `hex_chars`, and
    is equivalent to:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '`irp arg, a, b, c, ...`: The `irp` directive is followed by an argument and
    a list of parameters. The argument (here `arg`) represents a single parameter
    during each iteration. For example, this code:'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Sequentially increments registers EAX, EBX then ECX.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '`**irps arg, a b c ...**`: The `irps` directive is the same as `irp`, except
    that parameters in the list are not separated with commas.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inclusion directives
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two directives that we have hardly touched upon in previous chapters,
    which appear to be very useful. These directives are:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '`include ''filename''`'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`file ''filename''`'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The include directive
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The syntax of the `include` directive is very simple. It is the directive itself
    followed by a quoted name of a source file we want to include. Logically, the
    operation is the same as of `#include` keyword in C or C++. Programming in Assembly
    is not always simple and it is a very good idea to split your code into several
    source files (for example, put all your definitions of macro instructions in a
    separate file), then combine them all by including them in the main source.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: File directive
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While syntactically `include` and `file` directives are similar and both cause
    a file to be included in source processing, logically they are very different.
    Unlike the `include` directive, the `file` directive does not cause any processing
    of a file being included. This allows inclusion of binary data into the data section
    or into any place you need.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have very briefly covered the numerous abilities of the
    macro instructions in Assembly language programming. Unfortunately, it may require
    an entire book to mention everything that may be done with macro instructions,
    especially when it comes to the Flat Assembler, which has an exceptional preprocessor.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: 'An example from my own practice: I once had to implement a heavily obfuscated
    version of the AES128 decryption algorithm, which took 2175 lines in total, having
    only a few procedures, and almost half of that (1064 lines) was occupied by the
    definition of different macro instructions. As you may safely assume, about 30%
    to 60% of each procedure contained the invocation thereof.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 一个来自我自身实践的例子：我曾经需要实现一个经过高度混淆的AES128解密算法版本，总共写了2175行，只有少数几个程序，而其中几乎一半（1064行）被不同宏指令的定义所占据。正如你可以合理推测的那样，约30%到60%的每个程序都包含了宏指令的调用。
- en: In the next chapter, we will continue to dive deeper into the preprocessor and
    deal with different data structures, and the creation and management thereof.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将继续深入探讨预处理器，并处理不同的数据结构，以及其创建和管理方法。
