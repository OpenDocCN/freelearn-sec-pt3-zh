<html><head></head><body><div class="chapter" title="Chapter&#xA0;5.&#xA0;Using Python for Virtualization Forensics"><div class="titlepage"><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Using Python for Virtualization Forensics</h1></div></div></div><p>Currently, virtualization is one of the most trending concepts of modern IT. For forensic analysis, it introduces new challenges as well as new techniques.</p><p>In this chapter, we will show how virtualization introduces the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">New attack vectors</li><li class="listitem" style="list-style-type: disc">New chances of gathering evidence</li><li class="listitem" style="list-style-type: disc">New targets for forensic analysis such as the virtualization layer</li><li class="listitem" style="list-style-type: disc">New sources for forensic data</li></ul></div><div class="section" title="Considering virtualization as a new attack surface"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec22"/>Considering virtualization as a new attack surface</h1></div></div></div><p>Before we <a id="id288" class="indexterm"/>start with a forensic analysis, it is important to understand what to look for. With virtualization, there are new attack vectors and scenarios that are introduced. In the following sections, we will describe some of the scenarios and how to look for the corresponding evidence.</p><div class="section" title="Virtualization as an additional layer of abstraction"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec27"/>Virtualization as an additional layer of abstraction</h2></div></div></div><p>Virtualization is<a id="id289" class="indexterm"/> the technique of emulating IT systems such as servers, workstations, networks, and storages. The component that is responsible for the emulation of virtual hardware is defined as <span class="strong"><strong>hypervisor</strong></span>. The <a id="id290" class="indexterm"/>following figure depicts the two main types of system virtualization that are used today:</p><div class="mediaobject"><img src="graphics/2087_05_01.jpg" alt="Virtualization as an additional layer of abstraction"/></div><p>The architecture <a id="id291" class="indexterm"/>on the left-hand side is<a id="id292" class="indexterm"/> called <span class="strong"><strong>bare-metal hypervisor</strong></span> architecture and is also known <a id="id293" class="indexterm"/>as a <span class="strong"><strong>Type 1</strong></span> hypervisor. In this architecture, the hypervisor replaces the operating system and runs directly on the bare metal hardware. Examples of Type I hypervisors are VMware ESXi and Microsoft Hyper-V.</p><p>The right-hand side<a id="id294" class="indexterm"/> of the image depicts an architecture that is usually referred to as <span class="strong"><strong>desktop virtualization</strong></span> or a <span class="strong"><strong>Type 2</strong></span> hypervisor. In this architecture, there is<a id="id295" class="indexterm"/> a standard operating system that is running on the hardware, for example, a standard Windows 8 or Linux Desktop system. The hypervisor runs among other native applications directly on this operating system. Some functionality of the hypervisor may directly interact with the underlying hardware, for example, by providing special drivers. For Type 2 hypervisors, the operating system that is <a id="id296" class="indexterm"/>running directly on the hardware is called <span class="strong"><strong>host OS</strong></span>, while the operating system running on a virtual machine is called <span class="strong"><strong>guest OS</strong></span>. Examples of Type 2 hypervisor <a id="id297" class="indexterm"/>architectures are Oracle VirtualBox and VMware Workstation. These hypervisors can be installed just like any other application on an existing operating system.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note13"/>Note</h3><p>While Hyper-V seems like Type 2, it actually converts the host OS into just another guest OS during the installation and establishes a Type 1 architecture.</p></div></div><p>A common feature of almost all virtualization environments is the ability to create <span class="strong"><strong>snapshots</strong></span>. A snapshot <a id="id298" class="indexterm"/>of a virtual system contains a frozen-in-time state of the system. All changes to the system that are happening after the snapshot creation can be undone by the hypervisor to roll back to the point in time when the snapshot was taken. Furthermore, most systems allow having multiple snapshots of a single system and rolling back and forward to arbitrary snapshots. Snapshots can be utilized as a source of forensic data, which we will demonstrate in the <span class="emphasis"><em>Using virtualization as source of evidence</em></span> section.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip09"/>Tip</h3><p>
<span class="strong"><strong>For forensics, snapshots are to be treated like independent machines!</strong></span>
</p><p>If a virtual system is subject to forensic analysis, always check whether this system is a virtual system and whether there are snapshots. If snapshots exist, the forensic analysis has to be repeated for every single snapshot as if this were an independent virtual machine. The rationale behind this requirement is that it is most likely unknown when the system was compromised, when the attacker tried to destroy evidence, and most importantly, what version of the machine was running during the attack.</p></div></div><p>Most <a id="id299" class="indexterm"/>virtualization environments consist of more than one hypervisor. To ease the management of multiple hypervisors and to enable additional features; for example, moving machines between hypervisors for fail over, load balancing, and save power; these environments provide a central management for all of hypervisors. In the case of VMware vSphere, this management component is <a id="id300" class="indexterm"/>called <span class="strong"><strong>vCenter Server</strong></span>, as follows:</p><div class="mediaobject"><img src="graphics/2087_05_02.jpg" alt="Virtualization as an additional layer of abstraction"/></div><p>If <span class="strong"><strong>vCenter Server</strong></span> is used, then all administrative tasks are supposed to be handled via this <span class="strong"><strong>vCenter Server</strong></span> instance.</p><p>How does this new hypervisor layer influence attack scenarios and forensics?</p><p>The introduction of the new hypervisor layer also introduces a new layer that can be used to manipulate virtual systems without detection and adds another new layer that can be subject to the attacks. In the following sections, we will provide some sample scenarios for attacks<a id="id301" class="indexterm"/> that are committed through the hypervisor.</p></div><div class="section" title="Creation of rogue machines"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec28"/>Creation of rogue machines</h2></div></div></div><p>If an attacker <a id="id302" class="indexterm"/>can get access to the hypervisor, he may just create new virtual resources. These resources can act as a bridgehead in the<a id="id303" class="indexterm"/> network or just steal memory and compute resources from the environment. Therefore, it is crucial to extract the creation and disposal of virtual resources during a forensic analysis of the hypervisor environment.</p><p>Fortunately, every widespread virtualization environment offers APIs and language bindings to enumerate the virtual machines and other virtual resources of the environment. In this chapter, we chose to use VMware vSphere as the prominent example of a virtualization environment.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note14"/>Note</h3><p>
<span class="strong"><strong>VMware vSphere</strong></span><a id="id304" class="indexterm"/> is one of the most used virtualization environments for on-premise virtualization. Its basic structure consists of one central management instance called vCenter Server and one or multiple <a id="id305" class="indexterm"/>systems that are actually hosting the virtual environment (hypervisors), called <span class="strong"><strong>ESXi</strong></span> servers. To programmatically control a vSphere<a id="id306" class="indexterm"/> environment with Python, pyVmomi is used. This Python SDK is<a id="id307" class="indexterm"/> available on Github at <a class="ulink" href="https://github.com/vmware/pyvmomi">https://github.com/vmware/pyvmomi</a>.</p></div></div><p>In the following, we will use <code class="literal">pyVmomi</code> to create a list of all virtual machines. It is recommended to run such inventory scan at regular intervals to compare the list of existing virtual assets with your local inventory database.</p><p>We recommend to install pyVmomi using <code class="literal">pip</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user@lab:~$ pip install --upgrade pyVmomi</strong></span>
</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip10"/>Tip</h3><p>
<span class="strong"><strong>Sample code for pyVmomi</strong></span>
</p><p>There is a project<a id="id308" class="indexterm"/> on GitHub about a community-provided sample code for <code class="literal">pyVmomi</code>. More information about these samples is available on <a class="ulink" href="https://vmware.github.io/pyvmomi-community-samples/">https://vmware.github.io/pyvmomi-community-samples/</a>.</p></div></div><p>Then, a script as shown in the following may be used to enumerate all systems of the vSphere environment:</p><div class="informalexample"><pre class="programlisting">#!/usr/bin/env python

from pyVim import connect
from pyVmomi import vmodl
import sys

def print_vm_info(vm):
    """
    Print the information for the given virtual machine.
    If vm is a folder, recurse into that folder.
    """

    # check if this a folder...
    if hasattr(vm, 'childEntity'):
        vms = vm.childEntity
        for child in vms:
            print_vm_info(child)

    vm_info = vm.summary

    print 'Name:      ', vm_info.config.name
    print 'State:     ', vm_info.runtime.powerState
    print 'Path:      ', vm_info.config.vmPathName
    print 'Guest:     ', vm_info.config.guestFullName
    print 'UUID:      ', vm_info.config.instanceUuid
    print 'Bios UUID: ', vm_info.config.uuid
    print "----------\n"


if __name__ == '__main__':
    if len(sys.argv) &lt; 5:
        print 'Usage: %s host user password port' % sys.argv[0]
        sys.exit(1)
    
    service = connect.SmartConnect(host=sys.argv[1],
                                   user=sys.argv[2],
                                   pwd=sys.argv[3],
                                   port=int(sys.argv[4]))

    # access the inventory
    content = service.RetrieveContent()
    children = content.rootFolder.childEntity
    
    # iterate over inventory
    for child in children:
        if hasattr(child, 'vmFolder'):
            dc = child
        else:
            # no folder containing virtual machines -&gt; ignore
            continue

        vm_folder = dc.vmFolder
        vm_list = vm_folder.childEntity
        for vm in vm_list:
            print_vm_info(vm)</pre></div><p>This<a id="id309" class="indexterm"/> script creates a connection to the vCenter Server<a id="id310" class="indexterm"/> platform. However, it can also be used to connect to a single ESXi hypervisor instance. This is possible because the API offered to the script is identical for both management variants.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note15"/>Note</h3><p>The API used <a id="id311" class="indexterm"/>by <code class="literal">pyVmomi</code> is the <span class="strong"><strong>vSphere Web Service API</strong></span>. A detailed description is available in the vSphere Web Services SDK<a id="id312" class="indexterm"/> via <a class="ulink" href="https://www.vmware.com/support/developer/vc-sdk/">https://www.vmware.com/support/developer/vc-sdk/</a>.</p></div></div><p>The highlighted lines show that the script uses recursion to enumerate all virtual machines. This is necessary because in VMware vSphere, virtual machines can be put into nested groups.</p><p>Here is a sample call of this script with the output of a single virtual machine:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user@lab:~$ python enumerateVMs.py 192.168.167.26 'readonly' 'mypwd' 443</strong></span>
<span class="strong"><strong>Name:     vCenterServer</strong></span>
<span class="strong"><strong>State:      poweredOff</strong></span>
<span class="strong"><strong>Path:      [datastore1] vCenterServer/vCenterServer.vmx</strong></span>
<span class="strong"><strong>Guest:     Microsoft Windows Server 2012 (64-bit)</strong></span>
<span class="strong"><strong>UUID:      522b96ec-7987-a974-98f1-ee8c4199dda4</strong></span>
<span class="strong"><strong>Bios UUID: 564d8ec9-1b42-d235-a67c-d978c5107179</strong></span>
<span class="strong"><strong>----------</strong></span>
</pre></div><p>The output lists the name of the virtual machine, its current state, the path of its configuration file, a hint for the guest operating system, and the unique IDs for the instance and the BIOS configuration. The path information is valuable, especially, because it shows where to find all the virtual machine's configuration and data file.</p></div><div class="section" title="Cloning of systems"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec29"/>Cloning of systems</h2></div></div></div><p>In the <a id="id313" class="indexterm"/>previous section, we used the API of the hypervisor to get the forensic data. In this section, we will look for traces of abuse of this API. Therefore, we will analyse the log information of the vSphere installation.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note110"/>Note</h3><p>
<span class="strong"><strong>Collect log information on a central log system</strong></span>
</p><p>In this section, we will assume that the log information is stored with the default settings<a id="id314" class="indexterm"/> of the vSphere installation. However, when setting up a system, we recommend to store the log information on a dedicated logging system. This makes it more difficult for an attacker to manipulate system logs as he requires access to not only his target system, but also to the central log collection system. Another advantage of many central log collection systems is the built-in log analysis function.</p></div></div><p>While a copy of all system logs is highly recommended for a forensically sound analysis, single events can also be reviewed using the event browser of VMware vSphere, as follows:</p><div class="mediaobject"><img src="graphics/2087_05_03.jpg" alt="Cloning of systems"/></div><p>The vSphere environment offers collecting and storing all log files in an archive. Perform the following steps to get an archive of all the available log data:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Use the Windows version of vSphere Web Client and log in to the <span class="strong"><strong>vCenter Server</strong></span>.</li><li class="listitem" style="list-style-type: disc">In the <span class="strong"><strong>Administration</strong></span> menu, select <span class="strong"><strong>Export System Logs</strong></span>.</li><li class="listitem" style="list-style-type: disc">Select one <a id="id315" class="indexterm"/>or multiple vCenter Servers to export the logs, as shown in the following:<div class="mediaobject"><img src="graphics/2087_05_04.jpg" alt="Cloning of systems"/></div></li><li class="listitem" style="list-style-type: disc">When asked to <span class="strong"><strong>Select System Logs</strong></span>, ensure that all log types are selected, as follows:<div class="mediaobject"><img src="graphics/2087_05_05.jpg" alt="Cloning of systems"/></div></li></ul></div><p>The<a id="id316" class="indexterm"/> log files are saved as compressed archives. One archive represents the log information of one system, that is, vCenter Server or ESXi host.</p><p>First, we will extract the collected log file using <code class="literal">tar</code> with a command as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user@lab:~$ tar xfz 192.168.167.26-vcsupport-2015-07-05@11-21-54.tgz</strong></span>
</pre></div><p>The filename of this archive follows the format Host/IP—<code class="literal">vcsupport</code> (for vCenter Server)—timestamp. The directory in this archive follows the vc-Hostname-Timestamp naming scheme, for example, <code class="literal">vc-winserver-2015-07-05--02.19</code>. The timestamps of the archive name and the contained directory usually do not match. This can be caused due to the clock drift and the time required to transmit and compress the logs.</p><p>In the following, we will use the vCenter Server logs to reconstruct events indicating the cloning of virtual machines. In this example, we will use the redundancy of the logs and use the log data from one of the core services of vCenter Server: <code class="literal">vpxd</code>, that is, the core vCenter daemon:</p><div class="informalexample"><pre class="programlisting">#!/usr/bin/env python

import gzip
import os
from os.path import join
import re
import sys


# used to map session IDs to users and source IPs
session2user_ip = {}

def _logopen(filename):
    """Helper to provide transparent decompressing of compressed logs,
       if indicated by the file name.
    """
    if re.match(r'.*\.gz', filename):
        return gzip.open(filename, 'r')

    return open(filename, 'r')

def collect_session_data(vpxlogdir):
    """Uses vpx performance logs to map the session ID to
       source user name and IP"""
    extract = re.compile(r'SessionStats/SessionPool/Session/Id=\'([^\']+)\'/Username=\'([^\']+)\'/ClientIP=\'([^\']+)\'')

    logfiles = os.listdir(vpxlogdir)
    logfiles = filter(lambda x: 'vpxd-profiler-' in x, logfiles)
    for fname in logfiles:
        fpath = join(vpxlogdir, fname)
        f = _logopen(fpath)
            
        for line in f:
            m = extract.search(line)
            if m:
                session2user_ip[m.group(1)] = (m.group(2), m.group(3))

        f.close()

def print_cloning_hints(basedir):
    """Print timestamp, user, and IP address for VM cloning without
       by reconstructing from vpxd logs instead of accessing
       the 'official' event logs"""
    vpxlogdir = join(basedir, 'ProgramData',
                              'vCenterServer',
                              'logs',
                              'vmware-vpx')
    collect_session_data(vpxlogdir)

    extract = re.compile(r'^([^ ]+).*BEGIN task-.*?vim\.VirtualMachine\.clone -- ([0-9a-f-]+).*')

    logfiles = os.listdir(vpxlogdir)
    logfiles = filter(lambda x: re.match('vpxd-[0-9]+.log(.gz)?', x), logfiles)
    logfiles.sort()

    for fname in logfiles:
        fpath = join(vpxlogdir, fname)
        f = _logopen(fpath)
            
        for line in f:
            m = extract.match(line)
            if m == None:
                continue
       
            timestamp = m.group(1)
            session = m.group(2)
            (user, ip) = session2user_ip.get(session, ('***UNKNOWN***', '***UNKNOWN***'))
            print 'Hint for cloning at %s by %s from %s' % (timestamp, user, ip)
            
if __name__ == '__main__':
    if len(sys.argv) &lt; 2:
        print 'Usage: %s vCenterLogDirectory' % sys.argv[0]
        sys.exit(1)

    print_cloning_hints(sys.argv[1])</pre></div><p>First, this <a id="id317" class="indexterm"/>script reads the so-called performance log of <code class="literal">vpxd</code>. This log contains data about client sessions and we use it to extract a mapping from the unique session identifier to the client username and the IP address that the client is connecting from. In the second step, the main log of <code class="literal">vpxd</code> is searched for the start of tasks of <code class="literal">vim.VirtualMachine.clone</code> type, that is, the cloning of virtual machines on the server side. The session information is then looked up in the mapping that is harvested from the performance log to retrieve the data about possible cloning events, as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user@lab:~$ python extractCloning.py vc-winserver-2015-07-05--02.19/</strong></span>
<span class="strong"><strong>Hint for cloning at 2015-07-05T01:30:01.071-07:00 by VSPHERE.LOCAL\Administrator from 192.168.167.26</strong></span>
</pre></div><p>In the <a id="id318" class="indexterm"/>example, the script revealed that the <code class="literal">Administrator</code> account was used to clone a virtual machine. This hint can be correlated with the event log of vCenter Server and it will show up there as well. If it does not, then this is a strong indicator of a compromised environment.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note16"/>Note</h3><p>Depending on your system environment, operations such as cloning and exporting virtual machines may be a part of daily operations. In that case, the previous script or its variants may be used to detect unusual users or source IPs that are performing these operations.</p></div></div><p>Similar searches and correlations can be used for other events of interest. Copying of files of the datastore or exporting virtual machines are promising candidates.</p></div></div></div>
<div class="section" title="Searching for misuse of virtual resources"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec23"/>Searching for misuse of virtual resources</h1></div></div></div><p>It is not just the motivated attacker that we are looking for. With virtualization, there is also the legitimate <a id="id319" class="indexterm"/>administrator of the virtual infrastructure who makes his life easier by bending some rules. Additionally, an attacker may use the power of virtualization to reshape the topology of the infrastructure according to his needs. In the following sections, we will show some scenarios and detection methods.</p><div class="section" title="Detecting rogue network interfaces"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec30"/>Detecting rogue network interfaces</h2></div></div></div><p>Network <a id="id320" class="indexterm"/>virtualization allows <a id="id321" class="indexterm"/>operations to create almost arbitrary network infrastructures in a static, physical network. This capability is sometimes referred to as <span class="strong"><strong>Data center as a Service</strong></span> (<span class="strong"><strong>DCaaS</strong></span>). DCaaS allows the customers to utilize a defined<a id="id322" class="indexterm"/> portion of a physical data center to define virtual data centers in software.</p><p>Due to malicious access to this capability or human error, the resulting network configuration may expose internal resources to the internet, bypass firewalls, or allow access to malicious services.</p><p>Therefore, we will show a simple way to programmatically get the network configuration of a vSphere environment using Python.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip12"/>Tip</h3><p>
<span class="strong"><strong>Visualize virtual networks</strong></span>
</p><p>Most virtualization environments have built-in capabilities to visualize the virtual<a id="id323" class="indexterm"/> network setup. For example, VMware vSphere can create an image of the network topology. In a forensic analysis, this may serve as the starting point and support focusing the next step on the most promising assets.</p></div></div><div class="mediaobject"><img src="graphics/2087_05_06.jpg" alt="Detecting rogue network interfaces"/></div><p>This <a id="id324" class="indexterm"/>image was generated with the <a id="id325" class="indexterm"/>Windows client software for VMware vCenter Server and it depicts our test setup. Obviously, <span class="strong"><strong>EvesMachine</strong></span> is not connected properly, that is, it can <a id="id326" class="indexterm"/>bypass the <span class="strong"><strong>Firewall</strong></span>.</p><p>The community sample scripts for <code class="literal">pyVmomi</code> already provide a script for iterating over all network interfaces, <a class="ulink" href="https://github.com/vmware/pyvmomi-community-samples/blob/master/samples/getvnicinfo.py">https://github.com/vmware/pyvmomi-community-samples/blob/master/samples/getvnicinfo.py</a>, and displaying the connections of virtual machines. Therefore, we modified this script to display only those virtual machines <a id="id327" class="indexterm"/>that have multiple network <a id="id328" class="indexterm"/>connections, as follows:</p><div class="informalexample"><pre class="programlisting">#!/usr/bin/env python

from pyVim import connect
from pyVmomi import vmodl
from pyVmomi import vim
import sys

def generate_portgroup_info(content):
    """Enumerates all hypervisors to get
       network infrastructure information"""
    host_view = content.viewManager.CreateContainerView(content.rootFolder,
                                        [vim.HostSystem],
                                        True)
    hostlist = [host for host in host_view.view]
    host_view.Destroy()

    hostPgDict = {}
    for host in hostlist:
        pgs = host.config.network.portgroup
        hostPgDict[host] = pgs

    return (hostlist, hostPgDict)

def get_vms(content, min_nics=1):
    vm_view = content.viewManager.CreateContainerView(content.rootFolder,
                                        [vim.VirtualMachine],
                                        True)
    vms = [vm for vm in vm_view.view]
    vm_view.Destroy()

    vm_with_nics = []
    for vm in vms:
        num_nics = 0
        for dev in vm.config.hardware.device:
            # ignore non-network devices
            if not isinstance(dev, vim.vm.device.VirtualEthernetCard):
                continue
            
            num_nics = num_nics + 1
            if num_nics &gt;= min_nics:
                vm_with_nics.append(vm)
                break

    return vm_with_nics

def print_vm_info(vm, hosts, host2portgroup, content):
    print "\n=== %s ===" % vm.name

    for dev in vm.config.hardware.device:
        if not isinstance(dev, vim.vm.device.VirtualEthernetCard):
            continue

        dev_backing = dev.backing
        if hasattr(dev_backing, 'port'):
            # NIC is connected to distributed vSwitch
            portGroupKey = dev.backing.port.portgroupKey
            dvsUuid = dev.backing.port.switchUuid
            try:
                dvs = content.dvSwitchManager.QueryDvsByUuid(dvsUuid)
            except:
                portGroup = 'ERROR: DVS not found!'
                vlanId = 'N/A'
                vSwitch = 'N/A'
            else:
                pgObj = dvs.LookupDvPortGroup(portGroupKey)
                portGroup = pgObj.config.name
                vlObj = pgObj.config.defaultPortConfig.vlan
                if hasattr(vlObj, 'pvlanId'):
                    vlanId = str(pgObj.config.defaultPortConfig.vlan.pvlanId)
                else:
                    vlanId = str(pgObj.config.defaultPortConfig.vlan.vlanId)
                vSwitch = str(dvs.name)
        else:
            # NIC is connected to simple vSwitch
            portGroup = dev.backing.network.name
            vmHost = vm.runtime.host
            
            # look up the port group from the
            # matching host
            host_pos = hosts.index(vmHost)
            viewHost = hosts[host_pos]
            pgs = host2portgroup[viewHost]

            for p in pgs:
                if portgroup in p.key:
                    vlanId = str(p.spec.vlanId)
                    vSwitch = str(p.spec.vswitchName)
        
        if portGroup is None:
            portGroup = 'N/A'

        print '%s -&gt; %s @ %s -&gt; %s (VLAN %s)' % (dev.deviceInfo.label,
                                                 dev.macAddress,
                                                 vSwitch,
                                                 portGroup,
                                                 vlanId)

def print_dual_homed_vms(service):
    """Lists all virtual machines with multiple
       NICs to different networks"""

    content = service.RetrieveContent()
    hosts, host2portgroup = generate_portgroup_info(content)
    vms = get_vms(content, min_nics=2)
    for vm in vms:
        print_vm_info(vm, hosts, host2portgroup, content)


if __name__ == '__main__':
    if len(sys.argv) &lt; 5:
        print 'Usage: %s host user password port' % sys.argv[0]
        sys.exit(1)
    
    service = connect.SmartConnect(host=sys.argv[1],
                                   user=sys.argv[2],
                                   pwd=sys.argv[3],
                                   port=int(sys.argv[4]))
    print_dual_homed_vms(service)</pre></div><p>First, this<a id="id329" class="indexterm"/> script iterates over <a id="id330" class="indexterm"/>all (hypervisor) hosts to collect information about the virtual switches that are present on each ESXi system. Then, it iterates over all virtual machines to collect those with more than one network card. Then the information about virtual network cards is combined with the information about virtual switches to derive the information about the connectivity.</p><p>Here is the sample output from our lab environment as depicted previously:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user@lab:~$ python listDualHomed.py 192.168.167.26 readonly 'mypwd' 443</strong></span>
<span class="strong"><strong>=== EvesMachine ===</strong></span>
<span class="strong"><strong>Network adapter 1 -&gt; 00:50:56:ab:04:38 @ dvSwitch -&gt; dvInternalNetwork (VLAN 8)</strong></span>
<span class="strong"><strong>Network adapter 2 -&gt; 00:50:56:ab:23:50 @ dvSwitch -&gt; dvDMZ (VLAN 0)</strong></span>

<span class="strong"><strong>=== Firewall ===</strong></span>
<span class="strong"><strong>Network adapter 1 -&gt; 00:50:56:ab:12:e6 @ dvSwitch -&gt; dvInternalNetwork (VLAN 8)</strong></span>
<span class="strong"><strong>Network adapter 2 -&gt; 00:50:56:ab:4b:62 @ dvSwitch -&gt; dvDMZ (VLAN 0)</strong></span>
</pre></div><p>Our script <a id="id331" class="indexterm"/>correctly identified the<a id="id332" class="indexterm"/> two systems, <code class="literal">EvesMachine</code> and <code class="literal">Firewall</code>, being simultaneously connected to different networks. In this particular case, both the systems can be used to connect <code class="literal">VLAN 0</code> with <code class="literal">VLAN 8</code> on the same virtual switch, <code class="literal">dvSwitch</code>.</p></div><div class="section" title="Detecting direct hardware access"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec31"/>Detecting direct hardware access</h2></div></div></div><p>It may <a id="id333" class="indexterm"/>sound like an oxymoron, but<a id="id334" class="indexterm"/> most virtualization techniques allow direct hardware access. The legitimate reasons to allow virtual systems to directly access a piece of hardware without having to use the services of the hypervisor are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Special hardware supposed to be connected to a virtual machine</strong></span>: Special hardware such as radio clocks for virtual time servers or dongles being part of a copy protection mechanism.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Temporary use of physical media on a virtual system</strong></span>: Sometimes, this capability is used to access media from physical systems from a virtual environment, for example, to restore backups from a physical media to a virtual system. In general, the network attached storage systems should be preferred over attaching physical media to a virtual system.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Permanent use of drives of a hypervisor from a virtual machine</strong></span>: This can be useful if the virtual system uses software that is provided on physical media and therefore, needs access to a real physical drive for installation and updates of the software. However, one should consider using downloaded versions or ISO images instead of granting direct access to the hardware of the hypervisor.<p>As you may guess, according to this list, direct hardware access is more the exception than the rule in a modern virtualized data center. Furthermore, direct access to the hypervisor hardware breaks one fundamental principle of virtualization.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note17"/>Note</h3><p>Direct hardware access bypasses the security mechanism of the virtualization environment, that is, all the virtual hardware is controlled by the hypervisor. Consequently, direct hardware access always poses the risk of manipulation of hypervisor resources, data leakage, and system instabilities.</p></div></div></li></ul></div><p>The following are some examples of the directly attached hardware that are most likely malicious:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Network devices (create network connections that are invisible to the hypervisor)</li><li class="listitem" style="list-style-type: disc">Keyboard, mouse, and so on (create console access that are invisible to the hypervisor)</li><li class="listitem" style="list-style-type: disc">Hypervisor disk partitions</li></ul></div><p>The <a id="id335" class="indexterm"/>latter is especially dangerous. If a<a id="id336" class="indexterm"/> virtual machine manages to get the raw disk access to the hypervisor, it can manipulate the virtualization environment. The consequences include the complete control over the virtualization environment along with the access to all virtual machines, all virtual networks, the capability to create new rogue resources and reshape the overall network topology.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note18"/>Note</h3><p>For VMware vSphere, the direct hardware access is stored in the configuration of the virtual machines. Consequently, importing a virtual machine from an unknown or untrusted source (in the native format of vSphere) can create rogue hardware access.</p></div></div><p>The following script connects to a VMware vSphere instance and lists all virtual machines with direct hardware access:</p><div class="informalexample"><pre class="programlisting">#!/usr/bin/env python

from pyVim import connect
from pyVmomi import vmodl
from pyVmomi import vim
import re
import sys


def get_vms(content):
    """Returns a list of all virtual machines."""
    vm_view = content.viewManager.CreateContainerView(content.rootFolder,
                                                      [vim.VirtualMachine],
                                                      True)
    vms = [vm for vm in vm_view.view]
    vm_view.Destroy()
    return vms

def print_vm_hardware_access(vm):
    findings = []
    
    for dev in vm.config.hardware.device:
        if isinstance(dev, vim.vm.device.VirtualUSB):
            findings.append('USB access to host device ' + dev.backing.deviceName)
        elif isinstance(dev, vim.vm.device.VirtualSerialPort):
            findings.append('Serial port access')
        elif isinstance(dev, vim.vm.device.VirtualCdrom):
            if not dev.backing is None:
                if 'vmfs/devices/cdrom' in dev.backing.deviceName:
                    findings.append('Access to CD/DVD drive')
        elif isinstance(dev, vim.vm.device.VirtualDisk):
            if dev.backing is None or \
               dev.backing.fileName is None or \
               re.match(r'.*\.vmdk', dev.backing.fileName) is None:
               findings.append('Suspicious HDD configuration')

    if len(findings) &gt; 0:
        print '=== %s hardware configuration findings ===' % vm.name
        for l in findings:
            print l
        print "\n"

def print_direct_hardware_access(content):
    vms = get_vms(content)
    for vm in vms:
        print_vm_hardware_access(vm)


if __name__ == '__main__':
    if len(sys.argv) &lt; 5:
        print 'Usage: %s host user password port' % sys.argv[0]
        sys.exit(1)
    
    service = connect.SmartConnect(host=sys.argv[1],
                                   user=sys.argv[2],
                                   pwd=sys.argv[3],
                                   port=int(sys.argv[4]))

    # access the inventory
    content = service.RetrieveContent()
    print_direct_hardware_access(content)</pre></div><p>This<a id="id337" class="indexterm"/> script is very eager, that is, it does not<a id="id338" class="indexterm"/> check whether the device is actually in a connected state or whether there is media accessible through the device. Nevertheless, an output similar to the following calls for deeper inspection:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user@lab:~$ python listHardwareAccess.py 192.168.167.26 readonly pwd 443</strong></span>
<span class="strong"><strong>=== EvesMachine hardware configuration findings ===</strong></span>
<span class="strong"><strong>Access to CD/DVD drive</strong></span>
<span class="strong"><strong>Serial port access</strong></span>
<span class="strong"><strong>USB access to host device path:2/0 version:2</strong></span>

<span class="strong"><strong>=== DeveloperBox hardware configuration findings ===</strong></span>
<span class="strong"><strong>Access to CD/DVD drive</strong></span>

<span class="strong"><strong>=== dmzBox hardware configuration findings ===</strong></span>
<span class="strong"><strong>Access to CD/DVD drive</strong></span>
</pre></div><p>
<code class="literal">EvesMachine</code> appears to have direct access to a USB device attached to its hypervisor system. Moreover, there seems to be a direct link to the serial port of the hypervisor. <code class="literal">Access to CD/DVD drive</code> of the hypervisor should not be granted in general. However, for a lot of installations, people tend to use the optical drive of the hypervisor to install or update a software.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip13"/>Tip</h3><p>
<span class="strong"><strong>Extract hardware configuration from the VMX file</strong></span>
</p><p>Using a <a id="id339" class="indexterm"/>script such as the previous one requires access to the virtual environment. Therefore, the main purpose of such scripts is to narrow the focus of the forensic investigation. For permanent evidence and record, the directory of the virtual machines should be copied from the datastore. There, the VMX file contains all VM specific configuration settings including the hardware access.</p></div></div><p>In this and the previous sections, virtualization is considered as an additional attack surface. In the following section, we will outline how virtualization techniques can actually support a forensic investigation.</p></div></div>
<div class="section" title="Using virtualization as a source of evidence"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec24"/>Using virtualization as a source of evidence</h1></div></div></div><p>Virtualization is <a id="id340" class="indexterm"/>not just dangerous and challenging when it comes to forensic investigations, there is also the potential to use virtualization as a tool for gathering forensic evidence. In the following sections, you will see various sources which can lead to the evidence.</p><div class="section" title="Creating forensic copies of RAM content"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec32"/>Creating forensic copies of RAM content</h2></div></div></div><p>Normally, creating a copy of a system's RAM contents requires access to the target system, a logon, installing the required tools, and copying away the RAM dump to an external <a id="id341" class="indexterm"/>media. All of these steps are <a id="id342" class="indexterm"/>intrusive, that is, changing the state of the system and being subject to detection by the attacker or his malware. Furthermore, an attacker with administrative privileges may hide portions of the system memory from the memory dumps, for example, by manipulating the memory allocation and protection algorithms.</p><p>To overcome the disadvantages of this method, the hypervisor layer can be utilized to get a complete, non-tampered copy of the memory of a virtual system. The following script can be used to create a snapshot including the RAM content of a virtual machine:</p><div class="informalexample"><pre class="programlisting">#!/usr/bin/env python

from pyVim import connect
from pyVmomi import vim
from datetime import datetime
import sys

def make_snapshot(service, vmname):
    """Creates a snapshot of all virtual machines with the given name"""
    
    snap_name = 'Memory_Snapshot'
    snap_desc = 'Snapshot for investigation taken at ' + datetime.now().isoformat()

    content = service.RetrieveContent()
    vm_view = content.viewManager.CreateContainerView(content.rootFolder,
                                                      [vim.VirtualMachine],
                                                      True)
    vms = [vm for vm in vm_view.view if vm.name==vmname]
    vm_view.Destroy()

    for vm in vms:
        print 'Taking snapshot from VM UUID=%s' % vm.summary.config.uuid
        vm.CreateSnapshot_Task(name = snap_name,
                               description = snap_desc,
<span class="strong"><strong>                               memory = True,</strong></span>
                               quiesce=False)
        print "Done.\n"


if __name__ == '__main__':
    if len(sys.argv) &lt; 6:
        print 'Usage: %s host user password port vmname' % sys.argv[0]
        sys.exit(1)
    
    service = connect.SmartConnect(host=sys.argv[1],
                                   user=sys.argv[2],
                                   pwd=sys.argv[3],
                                   port=int(sys.argv[4]))

    
    make_snapshot(service, sys.argv[5])</pre></div><p>This script<a id="id343" class="indexterm"/> searches for virtual machines <a id="id344" class="indexterm"/>with the specified name and creates a snapshot. The highlighted parameter causes vSphere to write the RAM contents of the virtual machine to the datastore along with the other snapshot data files.</p><p>These RAM dumps reside in the directory of the virtual machine. The enumeration script in this chapter shows the path to this directory. Additionally, the vSphere Client allows browsing and downloading the datastore of the virtual machine.</p><p>The RAM contents are stored in a file with the <code class="literal">.vmem</code> extension, for example, <code class="literal">EvesMachine-Snapshot2.vmem</code>.</p></div><div class="section" title="Using snapshots as disk images"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec33"/>Using snapshots as disk images</h2></div></div></div><p>For physical <a id="id345" class="indexterm"/>systems, creating a forensic disk image<a id="id346" class="indexterm"/> usually incorporates taking the system <a id="id347" class="indexterm"/>offline, shutting it down, removing the hard drive, and copying it. Obviously, the system is not operational during this procedure and as a consequence, business owners are very reluctant in granting these downtimes due to a vague suspicion of a possible compromise.</p><p>On the other hand, the creation of a snapshot of a virtual machine results in basically no downtime but the result is a forensically sound disk image of the virtual asset.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip14"/>Tip</h3><p>
<span class="strong"><strong>Always check whether a system is virtual!</strong></span>
</p><p>As the creation of forensic data is much easier for virtual systems than for physical systems, one of the very first steps in a forensic investigation should be checking whether the target system is virtual.</p></div></div><p>The creation of the snapshot is identical to the script in the previous section. For VMware vSphere 5, all the files have to be copied from the datastore directory of the hypervisor to get a complete dump of the hard drives. If the virtual system is still running, some files may not get <a id="id348" class="indexterm"/>copied as the hypervisor will<a id="id349" class="indexterm"/> not allow read access while these files are in <a id="id350" class="indexterm"/>use. Typically, this is not a problem as these files are only needed by the snapshot, that is, all the changes since the creation of the snapshot are stored in special snapshot files.</p><p>In VMware vSphere 6, the snapshot mechanism has been changed. Instead of writing disk changes in the snapshot files, the changes made after snapshot creation are directly written to the files that represent the virtual hard drives. The snapshot files are used to preserve the original contents of the disk drives (copy-on-write behavior).</p><p>Therefore, the files that are to be copied from a VMware vSphere 6 environment will contain all entries of the directory of the virtual machine.</p><p>For the forensic analysis, the captured disk images can be connected to a virtual forensic workstation. There, these images can be treated like any other physical hard drive. Of course, the original copies must remain intact in order to provide forensic soundness.</p></div><div class="section" title="Capturing network traffic"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec34"/>Capturing network traffic</h2></div></div></div><p>The <a id="id351" class="indexterm"/>virtualization environment not only represents <a id="id352" class="indexterm"/>virtual machines and <span class="strong"><strong>Network Interfaces Card</strong></span> (<span class="strong"><strong>NIC</strong></span>), but <a id="id353" class="indexterm"/>also the virtual network devices that are needed to interconnect these systems. This combination can be used to collect all the network traffic of a virtual network by adding a monitoring port to the virtual switch and connecting a system to it, which can capture all the network traffic.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note19"/>Note</h3><p>If a virtual system in VMware vSphere is allowed to switch a NIC into a promiscuous mode, then this will automatically turn the corresponding switch port into the monitoring mode.</p></div></div><p>Furthermore, the enterprise editions of VMware vSphere provide an advanced version of a virtual switch called <span class="strong"><strong>vSphere Distributed Switch</strong></span> (<span class="strong"><strong>VDS</strong></span>). This switch can act more like a physical <a id="id354" class="indexterm"/>switch and provide mirroring of selected ports to a defined port for the traffic analysis. In addition, this switch is also capable of providing NetFlow logs to a defined port.</p><p>For the<a id="id355" class="indexterm"/> standard virtual switch, the following steps<a id="id356" class="indexterm"/> are required in order to monitor the network traffic:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Create a new port group on this switch to monitor. While this is not strictly required, it is highly recommended. Without a dedicated port group to monitor, all virtual systems on the switch would be allowed to monitor all the traffic of the switch.</li><li class="listitem" style="list-style-type: disc">Modify the <span class="strong"><strong>Security</strong></span> settings of this port group and change the <span class="strong"><strong>Promiscuous mode</strong></span> to <span class="strong"><strong>Accept</strong></span>.</li><li class="listitem" style="list-style-type: disc">Configure the network card of the virtual capture system to the new port group. This system can now capture all the network traffic of this switch.</li></ul></div><p>The exact steps may differ between virtual switch types and their versions. Nevertheless, the core message is that virtualization environments can ease this task of network traffic capturing. Moreover, physical and virtual switches do have different behaviors, for example, they can react to configuration changes of the connected network cards.</p><p>In the next chapter, we will see how to generate and analyze this captured network traffic.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec25"/>Summary</h1></div></div></div><p>In this chapter, we outlined how virtualization changes the landscape not just for IT operations, but also for the attacker and forensic specialist. Systems can be created, reshaped, and copied for good and bad reasons.</p><p>We provided examples of how to detect possibly malicious behavior or configuration on the vSphere virtualization environment. Moreover, we demonstrated how virtualization can be beneficial in getting untampered RAM dumps from the systems that should be analyzed. In the next chapter, you will see examples on how to analyze these RAM dumps.</p><p>With this knowledge, you are now prepared to analyze and utilize virtual environments in your forensic analyses.</p></div></body></html>