<html><head></head><body>
        

                            
                    <h1 class="header-title">Oh, Almost Forgot</h1>
                
            
            
                
<p class="mce-root">Our journey approaches its end. However, it is important to make it clear that this book only covers the tip of the iceberg called Assembly programming and there is much more to learn ahead of you. The main idea of this book is to show you how powerful and easy it is to create software in Assembly language and how portable and convenient it may be.</p>
<p>There are a few topics that we have not touched over the course of the book, but which, nevertheless, deserve attention. One such topic is how we can keep our code protected from sneaky eyes. We will shortly see how some of the methods of protecting our code may be implemented by means of the Flat Assembler, without the need for third-party software.</p>
<p>Another topic, which in my eyes, is interesting and deserves some coverage, is how to write code that would be executed in kernel space. We will implement a small loadable kernel module for Linux.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Protecting the code</h1>
                
            
            
                
<p>There are numerous books, articles, and blog posts on how to better protect your code. Some of them are even useful and practical; however, most of them are dedicated to certain third-party tools or combinations thereof. We are not going to review any of those, neither books nor tools. Instead, we are about to see what we are able to do ourselves with the tools we already have.</p>
<p>First of all, we have to assimilate the fact that there is no such thing as 100% protection for our code. No matter what we do, the more valuable our code is, the higher is the possibility that it will be reverse engineered. We may use packers, protectors, and whatever other tools we may come up with, but at the end, they are all well known and will be bypassed one way or another. Thus, the final frontier is the code itself. To put it correctly, it is the way the code appears to a potential attacker. This is where the obfuscation comes into play.</p>
<p>The dictionary definition of the word <em>obfuscation</em> is the action of making something obscure, unclear, or unintelligible. It may be quite a powerful technique, whether in conjunction with other approaches or alone. I once had a chance to reverse engineer a program that used encryption extensively. This program was not protected with any third-party tool, instead there was a very nice and unclear (at first glance) game of bits and I have to admit--it was much more difficult to reverse engineer than it could have been if any tool like <strong>Themida</strong> was in place.</p>
<p>In this part of the chapter, we will see a primitive example of what obfuscation may look like by slightly enhancing the patch we made for our Windows-based executable with <kbd>gets()</kbd>. As obfuscation is not the primary topic of the book; we will not dive into much detail, but show how simple and tiny changes may make it a bit harder to understand the underlying logic of the code without dynamically watching it in a debugger.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The original code</h1>
                
            
            
                
<p>Let's begin by taking a quick look at the original code of the procedure we planted into the executable as part of our patch. The code is quite straightforward and, knowing what we already know, is easy to read:</p>
<pre><em>; First of all we tell the assembler</em><br/><em>; that this is a 32-bit code</em><br/>use32<br/><br/><em>; Tell the assembler that we are expecting</em><br/><em>; this code to appear at 0x41e000</em><br/>org 0x41e000<br/><br/><em>; Define labels for "external" procedures</em><br/><em>; we are about to use</em><br/>label fgets at 0x414bd8<br/>label __acrt_iob_func at 0x41b180<br/><br/><em>; Implement the procedure</em><br/>fgets_patch:<br/><br/><em>   ; We begin the procedure with the standard</em><br/><em>   ; prolog for cdecl calling convention</em><br/>   push  ebp<br/>   mov   ebp, esp<br/><br/><em>   ; As we need the pointer to the stdin stream</em><br/><em>   ; we call the __acrt_iob_func procedure</em><br/>   push  0                      <em>; This is the number of the stream</em><br/>   call  dword[__acrt_iob_func]<br/>   add   esp, 4                 <em>; Restore the stack pointer<br/><br/>   ; Forward the parameter (char*) and <br/>   ; invoke fgets()<br/>   </em>push  eax                    <em>; Contains pointer to the stdin stream</em><br/>   push  128                    <em>; Maximum input length</em><br/>   push  dword[ebp + 8]         <em>; Pointer to the receiving buffer</em><br/>   call  fgets<br/>   add   esp, 4 * 3             <em>; Restore the stack pointer<br/><br/>   ; Standard epilog for procedures using cdecl <br/>   ; calling convention<br/>   </em>mov   esp, ebp<br/>   pop   ebp<br/>   ret</pre>
<p>The code is rather simple and it is fairly difficult to find anything valuable to protect here. Since this is the situation, we will use this example to show how simply a <kbd>call</kbd> instruction may be implemented with other instructions in such a way that it would neither point to the callee nor resemble a procedure call at all.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The call</h1>
                
            
            
                
<p>There are several ways to replace the <kbd>call</kbd> instruction with a sequence of instructions that would perform exactly the same action but would be treated by decompilers in a different manner. For example, the following code would do exactly what the <kbd>call</kbd> instruction does:</p>
<pre><em>   ; Preceding code</em><br/>   push  .return_address   <em>; Push the return address on stack</em><br/>   push  .callee           <em>; Redirect the execution flow to</em><br/>   ret                     <em>; callee</em><br/>.return_address:<br/><em>   ; the rest of the code</em></pre>
<p>We may, as well, replace the following sequence:</p>
<pre>push  callee<br/>ret</pre>
<p>with, for example:</p>
<pre>lea  eax, [callee]<br/>jmp eax</pre>
<p>This would still yield the same result. However, we want our obfuscation to be a bit stronger; therefore, we proceed and create a macro.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The call obfuscation macro</h1>
                
            
            
                
<p>Prior to beginning with the obfuscation of the <kbd>call</kbd> instruction itself, we will define a utility macro called <kbd>random</kbd>:</p>
<pre><em>; The %t below stands for the current</em><br/><em>; timestamp (at the compile time)</em><br/>random_seed = %t<br/><br/><em>; This macro sets 'r' to current random_seed</em><br/>macro random r<br/>{<br/>   random_seed = ((random_seed *\<br/>                   214013 +\<br/>                   2531011) shr 16) and 0xffffffff<br/>   r = random_seed <br/>}</pre>
<p>The <kbd>random</kbd> macro generates a pseudo-random integer and returns it in the parameter variable. We will need this tiny portion of randomization in order to add some diversity to our <kbd>call</kbd> implementation occurrences. The macro itself (let us call it <kbd>f_call</kbd>) makes use of the EAX register; therefore, we would either take care of preserving this register before the <kbd>f_call</kbd> invocation or only use this macro with procedures returning a value in the EAX register as, otherwise, the value of the register would be lost. Also, it is only suitable for direct calls due to the way it handles the parameter.</p>
<p>At last, we come to the macro itself. As the best way to understand the code is to look at the code, let's peer into the macro:</p>
<pre><em>; This macro has a parameter - the label (address)</em><br/><em>; of the procedure to call</em><br/>macro  f_call callee <br/>{<br/><em>   ; First we declare a few local labels</em><br/><em>   ; We need them to be local as this macro may be</em><br/><em>   ; used more than once in a procedure</em><br/>   local .reference_addr,\<br/>         .out,\<br/>         .ret_addr,\<br/>         .z,\<br/>         .call<br/><br/><em>   ; Now we need to calculate the reference address</em><br/><em>   ; for all further address calculations</em><br/>   call  .call<br/>.call:<br/>   add   dword[esp], .reference_addr - .call<br/><em>   ; Now the address or the .reference_addr label</em><br/><em>   ; is at [esp]</em><br/><em>   ; Jump to the .reference_addr</em><br/>   ret<br/><br/><em>   ; Add some randomness</em><br/>   random .z<br/>   dd     .z<br/><br/><em>   ; The ret instruction above returns to this address</em><br/>.reference_addr:<br/>   <br/><em>   ; Calculate the address of the callee:</em><br/><em>   ; We load the previously generated random bytes into</em><br/><em>   ; the .z compile time variable</em><br/>   load .z dword from .reference_addr - 4<br/><br/>   mov  eax, [esp - 4]     <em>; EAX now contains the address</em><br/><em>                           ; of the .reference_addr label</em><br/>   mov  eax, [eax - 4]     <em>; And now it contains the four</em><br/><em>                           ; random bytes</em><br/>   xor  eax, callee xor .z <em>; EAX is set to the address of</em><br/><em>                           ; the callee</em><br/><br/>   <em>; We need to set up return address for the callee </em><br/><em>   ; before we jump to it</em><br/>   sub  esp, 4             <em>; This may be written as </em><br/><em>                           ; 'add esp, -4' for a bit of </em><br/><em>                           ; additional obfuscation</em><br/>   add  dword[esp], .ret_addr - .reference_addr<br/>   <em>; Now the value stored on stack is the address of</em><br/><em>   ; the .ret_addr label</em><br/><em>   ; At last - jump to the callee</em><br/>   jmp  eax<br/><br/>   <em>; Add even more randomness</em><br/>   random .z<br/>   dd     .z<br/>   random .z<br/>   dd     .z<br/><br/>   <em>; When the callee returns, it falls to this address</em><br/>.ret_addr:<br/>   <em>; However, we want to obfuscate further execution</em><br/><em>   ; flow, so we add the following code, which sets </em><br/><em>   ; the value still present on stack (address of the</em><br/><em>   ; .ret_addr) to the address of the .out label</em><br/>   sub  dword[esp - 4], -(.out - .ret_addr)<br/>   sub  esp, 4<br/>   ret<br/>   <em>; The above two lines are, in fact, an equivalent </em><br/><em>   ; of 'jmp dword[esp - 4]'</em><br/><br/><em>   ; Some more randomness</em><br/>   random .z<br/>   dd     .z<br/><br/>.out:<br/>}</pre>
<p>As we may see, there are no complex computations involved in this particular obfuscation attempt and, even more, the code is still readable and understandable, but let's replace the line <kbd>call fgets</kbd> in our <kbd>patch_section.asm</kbd> file with <kbd>f_call fgets</kbd>, recompile, and re-apply the patch to the executable.</p>
<p>The new patch is significantly bigger--86 bytes instead of 35 bytes:</p>
<div><img class="image-border" src="img/5f288012-fe33-4246-80c1-b705e8fb5fba.png"/></div>
<p>Copy these bytes and paste them into the <kbd>Legacy.exe</kbd> file at the <kbd>0x8e00</kbd> offset, as shown in the following screenshot:</p>
<div><img class="image-border" src="img/f337c9e8-c655-495c-b878-c236aa271c9a.png"/></div>
<p>Running the executable, we will obtain the same result as we did in the previous chapter, so no visible difference at this stage. However, let's take a look at what the code looks like in the disassembler:</p>
<div><img class="image-border" height="496" src="img/5d016d06-8da9-44af-b2cb-f9902cdd9762.png" width="623"/></div>
<p>We can't say that the code is heavily obfuscated here, but it should give you an idea of what may be done with the aid of relatively simple macros used with the Flat Assembler. The preceding example may still be read with a tiny effort, but the application of a few more obfuscation tricks would render it literally unreadable and almost irreversible without a debugger.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">A bit of kernel space</h1>
                
            
            
                
<p>Until this very moment, we were only working with user-space code, writing small applications. In this part of the chapter, however, we will implement a small and very simple <strong>loadable kernel module</strong> (<strong>LKM</strong>) for Linux.</p>
<p>A few years ago, I was engaged in an interesting project, where the objective was to spot the data processed by certain kernel module. The project was even more challenging due to the fact that, not only did I not have access to the kernel sources, I had no access to the kernel itself, not to mention that it was not an Intel platform. All I knew was the version of the kernel in question and the name and address of the target module.</p>
<p>I had to go a long and interesting way until I was able to build an LKM that was capable of doing the work I needed it to do. At the end, I was able to build an LKM written in C, but I would not have been myself if I did not try to write one in Assembly. It was an unforgettable experience, I have to admit. However, once the project was completed, I decided to try to implement a simple LKM on my development machine. Since the first module was written for a different platform and for a kernel of a different version and taking into account that I decided to pretend like I had no sources for my running kernel, I had to perform almost as much research and reverse engineering, even though I was writing a module for my own system.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">LKM structure</h1>
                
            
            
                
<p>Let me save you from going the same long way of digging for information, reversing the structure of other kernel modules and examining kernel sources in order to see how exactly a module is loaded. Instead, let us proceed directly to the structure of an LKM.</p>
<p>A loadable kernel module is, in fact, an ELF object file with a few additional sections and some information, which we neither meet in object files nor in executables created for user-space. We should point out at least five sections that we do not usually have in regular files:</p>
<ul>
<li><kbd>.init.text</kbd>: This section contains all the code required for module initialization. In terms of Windows, for example, the content of this section may be compared to the <kbd>DllMain()</kbd> function and all the functions that it references. In terms of Linux, it may be considered a section containing constructors (Windows executables may have that too).</li>
<li><kbd>.exit.text</kbd>: This section contains all the code needed to be executed before the module is unloaded.</li>
<li><kbd>.modinfo</kbd>: This section contains information about the module itself, the version of kernel it is written for, and so on.</li>
<li><kbd>.gnu.linkonce.this_module</kbd>: This section contains the <kbd>this_module</kbd> structure, which, in turn, contains the name of the module and pointers to module initialization and de-initialization procedures. While the structure itself is a bit obscure for us in this case, we are interested in certain offsets only, which, in case of lack of sources, may be found with a reverse engineering tool such as IDA Pro. We may, however, check for offsets of the <kbd>.init.text</kbd> and <kbd>.exit.text</kbd> pointers within the structure, by running the <kbd>readelf</kbd> command in the terminal, as follows:<br/>
<pre><strong>readelf- sr name_of_the_mofule.ko</strong></pre>
Then, we see the offsets in the output:
<div><img class="image-border" src="img/b736505f-a5ec-4439-b8dc-a5e258ad654b.png"/></div>
As we see, the pointer to <kbd>.init.text</kbd> is at the offset <kbd>0x150</kbd> and the pointer to <kbd>.exit.text</kbd> is at the offset <kbd>0x248</kbd> into the <kbd>this_module</kbd> structure.</li>
<li><kbd>__versions</kbd>: This section contains the names of external symbols prepended with their version numbers. This table is used by the kernel in order to verify compatibility of the module in question.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">LKM source</h1>
                
            
            
                
<p>The structure of an LKM is not a secret. It may be retrieved from Linux kernel sources, which are freely available and, therefore, we have no need to dig any deeper into it; instead, following Occam's Razor principle, let's move on to the implementation of the module.</p>
<p>As has been mentioned already, an LKM is an object file; therefore, we begin by creating a <kbd>lkm.asm</kbd> file and entering our code like this:</p>
<pre>format ELF64       <em>; 64-bit ELF object file</em><br/>extrn printk       <em>; We are going to use this symbol,</em><br/><em>                   ; exported by the kernel, in order to</em><br/><em>                   ; have an indication of the module being</em><br/><em>                   ; loaded without problems</em></pre>
<p>Right after this, we are free to begin creating sections of an LKM.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">.init.text</h1>
                
            
            
                
<p>This section contains the code required for successful initialization of an LKM. In our case, as we are not adding any functionality to the module, it could simply return, but as we need an indication of our LKM having loaded successfully, we will implement a tiny procedure, which will print a string into the system log:</p>
<pre>section '.init.text' executable <br/><br/>module_init:<br/>   push  rdi       <em>; We are going to use this register</em><br/>   <br/>   mov   rdi, str1 <em>; Load RDI with the address of the string</em><br/><em>                   ; we want to print to system log (we will</em><br/><em>                   ; add it to the data section in a few moments)</em><br/>   xor   eax, eax<br/>   call  printk    <em>; Write the string to the system log</em><br/><br/>   xor   eax, eax  <em>; Prepare return value</em><br/>   pop   rdi       <em>; Restore the RDI register</em><br/>   ret</pre>
<p>Rather simple, isn't it? We just print the string and return from this procedure.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">.exit.text</h1>
                
            
            
                
<p>The content of this section is going to be even simpler (in our specific case). We simply return from the procedure:</p>
<pre>section '.exit.text' executable<br/>module_cleanup:<br/>   xor   eax, eax<br/>   ret</pre>
<p>Since we did not allocate any resources nor load any modules or open any files, we simply return 0.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">.rodata.str1.1</h1>
                
            
            
                
<p>This is a read-only data section and the only thing we have to put in it, is the string we are going to write to the system log:</p>
<pre>section '.rodata.str1.1'<br/>   str1  db  '&lt;0&gt; Here I am, gentlemen!', 0x0a, 0</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">.modinfo</h1>
                
            
            
                
<p>In this section, we have to put certain information about the module of ours, such as license, dependencies, as well as the version of the kernel and supported options:</p>
<pre>section '.modinfo'<br/><em>   ; It is possible to specify another license here,</em><br/><em>   ; however, some kernel symbols would not be </em><br/><em>   ; available for license other than GPL</em><br/>   db  'license=GPL', 0<br/><br/>   <em>; Our LKM has no dependencies, therefore, we leave</em><br/><em>   ; this blank</em><br/>   db  'depends=', 0<br/><br/>   <em>; Version of the kernel and supported options</em><br/>   db  'vermagic=3.16.0-4-amd64 SMP mod_unload modversions ', 0</pre>
<p>If you are unsure about what to specify as <kbd>vermagic</kbd>, you may run the <kbd>modinfo</kbd> command on any of the modules found in the <kbd>/lib/modules/`uname -r`/</kbd> directory. For example, I run the following command on my system:</p>
<pre><strong>/sbin/modinfo /lib/modules/`uname -r`/kernel/arch/x86/crypto/aesni-intel.ko</strong></pre>
<p>The output will be as shown in the following screenshot:</p>
<div><img class="image-border" src="img/4ef6f57f-f460-49ef-9dfb-ddc8b2229480.png"/></div>
<p>Once you have this information, you may simply copy the <kbd>vermagic</kbd> string and paste it into your code.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">.gnu.linkonce.this_module</h1>
                
            
            
                
<p>There's nothing special to say here. This section contains only one structure--<kbd>this_module</kbd>, which is mostly filled with zeroes (as it is used by the LKM loader internally) except three fields:</p>
<ul>
<li>Name of the module</li>
<li>A pointer to the initialization procedure--<kbd>module_init</kbd></li>
<li>A pointer to the de-initialization procedure--<kbd>module_cleanup</kbd></li>
</ul>
<p>These fields, in the case of this kernel version and this Linux distro, are located at offsets <kbd>0x18</kbd>, <kbd>0x150</kbd>, and <kbd>0x248</kbd>, respectively; therefore, the code would be as follows:</p>
<pre>section '.gnu.linkonce.this_module' writeable<br/><br/>this_module:<br/><em>   ; Reserve 0x18 bytes</em><br/>   rb  0x18<br/><em>   ; String representation of the name of the module</em><br/>   db  'simple_module',0<br/><br/>   <em>; Reserve bytes till the offset 0x150</em><br/>   rb  0x150 - ($ - this_module)<br/>   <em>; The address of the module_init procedure</em><br/>   dq  module_init<br/><br/>   <em>; Reserve bytes till the offset 0x248</em><br/>   rb  0x248 - ($ - this_module)<br/>   <em>; The address of the module_cleanup procedure</em><br/>   dq  module_cleanup<br/>   dq  0</pre>
<p>This is all we had to take care of in this section.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">__versions</h1>
                
            
            
                
<p>The information in this section describes external symbols by version numbers and names thereof, and is used by the loader in order to ensure that the kernel and the LKM are using symbols of the same version, so there would not be any surprises. You may try to build a module without this section and it may even be loaded, but it is not suggested to do so. The loader refuses to load modules with invalid symbol versions, thus telling us that this information is not just for fun, but is used in order to prevent failures.</p>
<p>At the time, I could not find reliable information on where to obtain version numbers for certain symbols, but it may be a good workaround, which is definitely sufficient for our small LKM, to simply search for symbol names prepended with the 8-byte version value (4 bytes on 32-bit systems), as shown in the following screenshot:</p>
<div><img class="image-border" src="img/8e2f885d-d70b-41b9-8388-10e11570fe91.png"/></div>
<p>We only need two external symbols for our LKM, which are <kbd>module_layout</kbd> and <kbd>printk</kbd>. As you see in the preceding screenshot, the version of the <kbd>module_layout</kbd> symbol is <kbd>0x2AB9DBA5</kbd>. Taking the same approach for obtaining the version of the <kbd>printk</kbd> symbol, we get (so it is on my system, but it may differ on yours) <kbd>0x27E1A049</kbd>.</p>
<p>These entries are stored as an array of structures, where each structure contains two fields:</p>
<ul>
<li><kbd>version number</kbd>: This is the 8-byte version identifier (4 bytes on 32-bit systems)</li>
<li><kbd>symbol name</kbd>: This is the variable length string (up to 56 bytes) representing the name of the symbol</li>
</ul>
<p>Since we are talking about fixed-size fields here, it is natural to define a structure; however, since we do not want to name each and every structure for each and every symbol, we will use a macro:</p>
<pre>macro __version ver, name<br/>{<br/>   local .version, .name<br/>   .version  dq  ver<br/>   .name     db  name, 0<br/>   .name_len = $ - .name<br/>             rb  56 - .name_len<br/>}</pre>
<p>Having defined the <kbd>__version</kbd> macro, we are ready to conveniently implement the <kbd>__versions</kbd> section:</p>
<pre>section '__versions'<br/>   __version  0x2AB9DBA5, 'module_layout'<br/>   __version  0x27E1A049, 'printk'</pre>
<p>That is it. Save the file and let's try to compile it and load.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Testing the LKM</h1>
                
            
            
                
<p>Testing the module is much more simple than writing one. The compilation is not different from the usual; we simply compile it with the Flat Assembler:</p>
<pre><em># It is just the name of the output file that differs</em><br/><em># The extension would be 'ko' - <strong>k</strong>ernel <strong>o</strong>bject, instead</em><br/><em># of 'o' for regular <strong>o</strong>bject</em><br/><strong>fasm lkm.asm lkm.ko </strong></pre>
<p>Once our kernel module is compiled, we need to ensure that it has the executable attribute set by running the <kbd>chmod +x lkm.ko</kbd> command in the Terminal.</p>
<p>In order to load the LKM into the currently running kernel, we use the <kbd>insmode</kbd> command in the following way:</p>
<pre><strong>sudo /sbin/insmode ./lkm.ko</strong></pre>
<p>We will not be given any error unless there is a serious problem with the format of the LKM (for example, invalid symbol version(s)). If all went well, try to run the <kbd>dmesg</kbd> command in the terminal, like this:</p>
<pre><strong>dmesg | tail -n 10</strong></pre>
<p>You should see the <kbd>"&lt;0&gt; Here I am, gentlemen!"</kbd> string appearing at the end of the system log. If the string is not there, then, most likely, you have to reboot your system, but first try to unload the module by running the <kbd>rmmod</kbd> command in the Terminal, like this:</p>
<pre><strong>sudo /sbin/rmmod simple_module</strong></pre>
<p>If all went well, then we will now be able to create Linux LKMs using pure Assembly.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>We have gone a long way. Beginning with an overview of the Intel architecture, we went through the implementation of different algorithms, although mostly simplified for the sake of understandability, and we finished with the implementation of a loadable kernel module for Linux.</p>
<p>The intention behind this final chapter was to draw your interest toward a couple of topics that lie outside the scope of the book and therefore could not get enough attention, but are still important one way or another. Although the obfuscation given in the beginning of the chapter is rather simple, it should have given you the general idea of how more complicated obfuscation schemes may be brought up with the basic tool provided by the Flat Assembler, the macro engine.</p>
<p>We dedicated some time to kernel programming in the second part of the chapter and, although the kernel module we have implemented is, perhaps, the most basic one possible, we have shown that even such aspects of programming as kernel development, aspects that many people consider very complicated even when viewed from a high-level language perspective, include nothing to be afraid of even when viewed from the top of the solid rock called Assembly language.</p>
<p>By now, you should have a strong enough base to let you keep going on easily and improving your Assembly programming skills and abilities, and I would like to wish you good luck in doing this.</p>
<p>Thank you!</p>
<p> </p>


            

            
        
    </body></html>