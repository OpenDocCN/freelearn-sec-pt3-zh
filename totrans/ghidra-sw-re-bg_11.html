<html><head></head><body><div><p>&#13;
			<h1 id="_idParaDest-126"><em class="italic"><a id="_idTextAnchor155"/>Chapter 9</em>: Scripting Binary Audits</h1>&#13;
			<p><a id="_idTextAnchor156"/>Auditing binaries is a time-consuming task, so it is recommended to automate the process as much as possible. When auditing a software project, hunting some kind of vulnerabilities such as logical issues or architectural issues leading to vulnerabilities cannot be automated but, in some other cases, such as memory corruption vulnerabilities, they are generic and capable of being automated using, for instance, a Ghidra script developed for this purpose.</p>&#13;
			<p>In this chapter, you will learn how to automate the task of looking for vulnerabilities in executable binaries using Ghidra. You will analyze how a Ghidra script developed by Zero Day Initiative works by looking for vulnerable calls to <code>sscanf</code> (a C library that reads formatted data from a string) in order to automate the bug hunting process explained in the previous chapter.</p>&#13;
			<p><a id="_idTextAnchor157"/><a id="_idTextAnchor158"/>Finally, we will discuss PCode, Ghidra's intermediate language, allowing you to abstract your scripts from the processor's architecture.</p>&#13;
			<p>In this chapter, we're going to cover the following main topics:  </p>&#13;
			<ul>&#13;
				<li>Looking for vulnerable functions </li>&#13;
				<li>Looking for <code>sscanf</code> callers</li>&#13;
				<li>Analyzing the caller function using PCode</li>&#13;
			</ul>&#13;
			<h1 id="_idParaDest-127"><a id="_idTextAnchor159"/>Technical requirements </h1>&#13;
			<p>The requirements for this chapter are as follows:</p>&#13;
			<ul>&#13;
				<li>The GitHub repository containing all the necessary code for this chapter: <a href="https://github.com/PacktPublishing/Ghidra-Software-Reverse-Engineering-for-Beginners/tree/master/Chapter09">https://github.com/PacktPublishing/Ghidra-Software-Reverse-Engineering-for-Beginners/tree/master/Chapter09</a></li>&#13;
				<li><code>sscanf</code>: A Zero Day Initiative Ghidra script for automated bug hunting by modeling vulnerable code: <a href="https://github.com/thezdi/scripts/blob/master/sscanf/sscanf_ghidra.py">https://github.com/thezdi/scripts/blob/master/sscanf/sscanf_ghidra.py</a></li>&#13;
				<li>Mingw-w64: GCC compiler for Windows 64- and 32-bit architectures: <a href="http://mingw-w64.org/doku.php">http://mingw-w64.org/doku.php</a></li>&#13;
				<li>GNU ARM Embedded Toolchain: A suite of tools for compiling C, C++, and ASM targeting ARM architectures. It allows us to cross-compile our source code targeting the ARM platform: <a href="https://developer.arm.com/tools-and-software/open-source-software/developer-tools/gnu-toolchain/gnu-rm/downloads">https://developer.arm.com/tools-and-software/open-source-software/developer-tools/gnu-toolchain/gnu-rm/downloads</a></li>&#13;
				<li>If you want to learn more about toolchains, please, refer to the Packt book <em class="italic">Mastering Embedded Linux Programming - Second Edition</em>, <em class="italic">Chris Simmonds</em>, <em class="italic">June 2017</em>: <a href="https://subscription.packtpub.com/book/networking_and_servers/9781787283282">https://subscription.packtpub.com/book/networking_and_servers/9781787283282</a>.</li>&#13;
			</ul>&#13;
			<p>Check out the following video to see the Code in Action: <a href="https://bit.ly/2Io58y6">https://bit.ly/2Io58y6</a></p>&#13;
			<h1 id="_idParaDest-128"><a id="_idTextAnchor160"/>Looking for vulnerable functions</h1>&#13;
			<p>If you remember <a id="_idIndexMarker318"/>from the previous chapter, when looking for vulnerabilities, we started by looking for unsafe C/C++ functions listed in the symbols table. Unsafe C/C++ functions are likely to introduce vulnerabilities because it's up to the developer to check the parameters passed to the function. Therefore, they have the opportunity to commit a programming error with safety implications.</p>&#13;
			<p>In this case, we will analyze a script that looks for the use of variables expected to be initialized by <code>sscanf</code> without validating the proper initialization:</p>&#13;
			<pre>00  int main() {</pre>&#13;
			<pre>01 	char* data = "";</pre>&#13;
			<pre>02 	char name[20];</pre>&#13;
			<pre>03 	int age;</pre>&#13;
			<pre>04 	int return_value = sscanf(data, "%s %i", name, &amp;age);</pre>&#13;
			<pre>05 	printf("I'm %s.\n", name);</pre>&#13;
			<pre>06 	printf("I'm %i years old.", age);</pre>&#13;
			<pre>07 }</pre>&#13;
			<p>When compiling this code and executing it, the result is unpredictable. Since the <code>data</code> variable is initialized to an empty string in line <code>01</code>, when <code>sscanf</code> is called in line <code>04</code>, it is not able to read the <code>name</code> string and the <code>age</code> integer from the <code>data</code> buffer.</p>&#13;
			<p>Therefore, <code>name</code> and <code>age</code> contain some unpredictable values when retrieving their values on lines <code>05</code> and <code>06</code>, respectively. During an execution, in my case (it will probably be different for you), it produced the following unpredictable output:</p>&#13;
			<pre>C:\Users\virusito\vulns&gt; gcc.exe sscanf.c -o sscanf.exe</pre>&#13;
			<pre>C:\Users\virusito\vulns&gt; sscanf.exe</pre>&#13;
			<pre>I'm É§ã.</pre>&#13;
			<pre>I'm 9 years old.</pre>&#13;
			<p>To fix this vulnerability, you <a id="_idIndexMarker319"/>must check the return value of <code>sscanf</code> because, on success, this function returns the number of values successfully scanned from the given buffer. Only use the <code>age</code> and <code>name</code> variables in cases where both are successfully read:</p>&#13;
			<pre>05 	if(return_value == 2){</pre>&#13;
			<pre>06 		printf("I'm %s.\n", name);</pre>&#13;
			<pre>07 		printf("I'm %i years old.", age);</pre>&#13;
			<pre>08 	}else if(return_value == -1){</pre>&#13;
			<pre>09 		printf("ERROR: Unable to read the input data.\n");</pre>&#13;
			<pre>10 	}else{</pre>&#13;
			<pre>11 		printf("ERROR: 2 values expected, %d given.\n", return_value);</pre>&#13;
			<pre>12 	}</pre>&#13;
			<p>In the next section, you will learn how to look for the <code>sscanf</code> functions in the symbols table in order to hunt for the kinds of vulnerabilities covered in this section.</p>&#13;
			<h2 id="_idParaDest-129"><a id="_idTextAnchor161"/>Retrieving unsafe C/C++ functions from the symbols table</h2>&#13;
			<p>As you <a id="_idIndexMarker320"/>know from <a href="B16207_02_Final_SK_ePub.xhtml#_idTextAnchor031"><em class="italic">Chapter 2</em></a>, <em class="italic">Automating RE Tasks with Ghidra Scripts</em>, when <a id="_idIndexMarker321"/>developing a <code>GhidraScript</code> script to automate a task, the following states are available from scripting: </p>&#13;
			<ul>&#13;
				<li><code>currentProgram</code></li>&#13;
				<li><code>currentAddress</code></li>&#13;
				<li><code>currentLocation</code></li>&#13;
				<li><code>currentSelection</code></li>&#13;
				<li><code>currentHighlight</code></li>&#13;
			</ul>&#13;
			<p>To obtain a symbols table instance of the current program, the Zero Day Initiative script calls to the <code>getSymbolTable()</code> method from <code>currentProgram</code>:</p>&#13;
			<pre>symbolTable = currentProgram.getSymbolTable()</pre>&#13;
			<p>And to pick all symbols related to the <code>_sscanf</code> function, we call the <code>getSymbols()</code> method from the symbols table instance:</p>&#13;
			<pre>list_of_scanfs = list(symbolTable.getSymbols('_sscanf'))</pre>&#13;
			<p>Then, if there are no symbols in the <code>list_of_scanfs</code> list, our static analysis indicates that the program is not vulnerable to unsafe <code>_sscanf</code> calls, so we can return:</p>&#13;
			<pre>if len(sscanfs) == 0:</pre>&#13;
			<pre>    print("sscanf not found")</pre>&#13;
			<pre>    return</pre>&#13;
			<p>As you can see, it is straightforward to look for unsafe functions using Ghidra scripting; this kind of script can be easily implemented using the Ghidra API. Remember you have a quick reference to it in <a href="B16207_06_Final_SK_ePub.xhtml#_idTextAnchor108"><em class="italic">Chapter 6</em></a>, <em class="italic">Scripting Malware Analysis</em>.</p>&#13;
			<h2 id="_idParaDest-130"><a id="_idTextAnchor162"/>Decompiling the program using scripting</h2>&#13;
			<p>Decompiling allows <a id="_idIndexMarker322"/>you to retrieve the program's disassembly, which is the <a id="_idIndexMarker323"/>view of the program that we use when looking for vulnerabilities. The following Zero Day Initiative script code snippet is responsible for decompiling the program:</p>&#13;
			<pre>00 decompiler_options = DecompileOptions()</pre>&#13;
			<pre>01 tool_options = state.getTool().getService(</pre>&#13;
			<pre>02                                           OptionsService</pre>&#13;
			<pre>03                              ).getOptions(</pre>&#13;
			<pre>04                                           "Decompiler"</pre>&#13;
			<pre>05                              )</pre>&#13;
			<pre>06 decompiler_options.grabFromToolAndProgram(</pre>&#13;
			<pre>07                                           None,</pre>&#13;
			<pre>08                                           tool_options,</pre>&#13;
			<pre>09                                           currentProgram</pre>&#13;
			<pre>10                                          )</pre>&#13;
			<pre>11 decompiler = DecompInterface()</pre>&#13;
			<pre>12 decompiler.setOptions(decompiler_options)</pre>&#13;
			<pre>13 decompiler.toggleCCode(True)</pre>&#13;
			<pre>14 decompiler.toggleSyntaxTree(True)</pre>&#13;
			<pre>15 decompiler.setSimplificationStyle("decompile")</pre>&#13;
			<pre>16 If not decompiler.openProgram(program):</pre>&#13;
			<pre>17   print("Decompiler error")</pre>&#13;
			<pre>18   return</pre>&#13;
			<p>Let me explain the <a id="_idIndexMarker324"/>steps taken in the preceding <a id="_idIndexMarker325"/>code snippet in order to perform decompilation:</p>&#13;
			<ol>&#13;
				<li>Getting a <code>DecompilerOptions</code> instance: In order to decompile the program, we need to obtain a decompiler object for a single decompile process. We start by instantiating a <code>decompiler_options</code> object (line <code>00</code>).</li>&#13;
				<li>Retrieving options relevant to the decompiling process: To set the options, we use the <code>grabFromToolAndProgram()</code> API, passing to it the tool options specific to the decompiler and the target program, which is relevant to the decompiling process.<p>Ghidra classes implementing Ghidra's interface tools (<code>FrontEndTool</code>, <code>GhidraTool</code>, <code>ModalPluginTool</code>, <code>PluginTool</code>, <code>StandAlonePluginTool</code>, <code>TestFrontEndTool</code>, and <code>TestTool</code>) have associated options grouped by category.</p><p>So, to obtain the decompiler category options (options relevant to decompiling) of the current tool (which is <code>PluginTool</code>), the code snippet uses the option service to retrieve the relevant decompiling options (lines <code>01</code>–<code>05</code>).</p></li>&#13;
				<li>Setting values to the retrieved decompiling options: After retrieving the options relevant for decompiling, the code snippet gets the appropriate decompiler option values using the <code>grabFromToolAndProgram</code>() API, passing to it the tool options and the target program (lines <code>06</code>–<code>10</code>).<p>Next, the code snippet obtains an instance of the decompiler and sets the decompiler options to it (lines <code>11</code>–<code>15</code>). </p></li>&#13;
				<li>Setting values <a id="_idIndexMarker326"/>to the retrieved decompiling <a id="_idIndexMarker327"/>options: Finally, the code snippet checks whether it is able to decompile the program by calling to the <code>openProgram()</code> API (lines <code>16</code>–<code>18</code>).</li>&#13;
			</ol>&#13;
			<p>After obtaining a configured decompiler that is able to decompile the program, we can start looking for callers of the <code>_sscanf</code> unsafe function.</p>&#13;
			<h1 id="_idParaDest-131"><a id="_idTextAnchor163"/>Looking for sscanf callers</h1>&#13;
			<p>As you know, finding an <a id="_idIndexMarker328"/>unsafe function in the program does not necessarily mean that the program is vulnerable. To confirm if a function is vulnerable we need to analyze the caller functions and analyze the parameters passed to the unsafe function.</p>&#13;
			<h2 id="_idParaDest-132"><a id="_idTextAnchor164"/>Enumerating caller functions</h2>&#13;
			<p>The following code snippet <a id="_idIndexMarker329"/>can be used to identify the caller functions:</p>&#13;
			<pre>00 from ghidra.program.database.symbol import FunctionSymbol</pre>&#13;
			<pre>01 functionManager = program.getFunctionManager()</pre>&#13;
			<pre>02   for sscanf in list_of_sscanfs:</pre>&#13;
			<pre>03     if isinstance(sscanf, FunctionSymbol):</pre>&#13;
			<pre>04       for ref in sscanf.references:</pre>&#13;
			<pre>05         caller = functionManager.getFunctionContaining(</pre>&#13;
			<pre>06                                           ref.fromAddress</pre>&#13;
			<pre>07                  )</pre>&#13;
			<pre>08      caller_function_decompiled = </pre>&#13;
			<pre>09                           decompiler.decompileFunction(</pre>&#13;
			<pre>10                                                   caller,</pre>&#13;
			<pre>11                    decompiler.options.defaultTimeout,</pre>&#13;
			<pre>12                    None</pre>&#13;
			<pre>13      )</pre>&#13;
			<p>The preceding code snippet looks for caller functions making use of the function manager. It can be easily retrieved by calling to the <code>getFunctionManager()</code> function, as shown in line <code>01</code>.</p>&#13;
			<p>After that, we can iterate over the list of <code>_sscanf</code> symbols, checking whether those symbols are functions, because <a id="_idIndexMarker330"/>we are interested in <code>_sscanf</code> functions (lines <code>02</code> and <code>03</code>).</p>&#13;
			<p>For every <code>_sscanf</code> symbol function identified, we enumerate its references (line <code>04</code>).</p>&#13;
			<p>The function referencing <code>_sscanf</code> is the caller function, so we can use the <code>getFunctionContaining()</code> API to retrieve the caller function (lines <code>05</code>–<code>07</code>).</p>&#13;
			<p>Finally, we can decompile the caller by using the <code>decompileFunction()</code> Ghidra API (lines <code>08</code>–<code>13</code>).</p>&#13;
			<p>In the next section, we will analyze the resulting <code>caller_function_decompiled</code> object using PCode to determine whether it is or isn't vulnerable.</p>&#13;
			<h1 id="_idParaDest-133"><a id="_idTextAnchor165"/>Analyzing the caller function using PCode </h1>&#13;
			<p>Ghidra can work <a id="_idIndexMarker331"/>with both assembly language <a id="_idIndexMarker332"/>and PCode. PCode is an abstraction of the assembly level, meaning that if you develop a script using PCode, you are automatically supporting all the assembly languages that offer translation from PCode. (At the time of writing this book, the following processors are supported: 6502, 68000, 6805, 8048, 8051, 8085, AARCH64, ARM, Atmel, CP1600, CR16, DATA, Dalvik, HCS08, HCS12, JVM, MCS96, MIPS, PA-RISC, PIC, PowerPC, RISCV, Sparc, SuperH, SuperH4, TI_MSP430, Toy, V850, Z80, TriCore, and x86.) Really powerful, right?</p>&#13;
			<p class="callout-heading">PCode to assembly-level translation</p>&#13;
			<p class="callout">PCode assembly is generated with a processor specification language <a id="_idIndexMarker333"/>named SLEIGH: <a href="https://ghidra.re/courses/languages/html/sleigh.html">https://ghidra.re/courses/languages/html/sleigh.html</a>. You can check the current list of supported processors and their SLEIGH <a id="_idIndexMarker334"/>specifications here: <a href="https://github.com/NationalSecurityAgency/ghidra/tree/master/Ghidra/Processors">https://github.com/NationalSecurityAgency/ghidra/tree/master/Ghidra/Processors</a>.</p>&#13;
			<p>To understand PCode, you must be familiar with three key concepts:</p>&#13;
			<ul>&#13;
				<li><strong class="bold">Address space</strong>: A generalization <a id="_idIndexMarker335"/>of the indexed memory (RAM) that a typical processor has access to. The following screenshot shows a PCode code snippet highlighting address space references:<div><img src="img/B16207_09_001.jpg" alt="Figure 9.1 – Address space in PCode&#13;&#10;"/></p></li>&#13;
			</ul>&#13;
			<p class="figure-caption"> </p>&#13;
			<p class="figure-caption">Figure 9.1 – Address space in PCode</p>&#13;
			<ul>&#13;
				<li><strong class="bold">Varnode</strong>: The unit of data manipulated by PCode. A sequence of bytes in some address space is <a id="_idIndexMarker336"/>represented by the address and the number of bytes (constant values are also varnodes). The following screenshot shows a PCode code snippet highlighting varnodes:<div><img src="img/B16207_09_002.jpg" alt="Figure 9.2 – Varnodes in PCode&#13;&#10;"/></div></li>&#13;
			</ul>&#13;
			<p class="figure-caption"> </p>&#13;
			<p class="figure-caption">Figure 9.2 – Varnodes in PCode</p>&#13;
			<ul>&#13;
				<li><strong class="bold">Operation</strong>: One or many PCode operations enables to emulate a processor instruction. PCode operations <a id="_idIndexMarker337"/>allow arithmetic, data moving, branching, logical, Boolean, floating-point, integer comparison, extension/truncation, and managed code. The following screenshot shows a PCode code snippet highlighting operations:<div><img src="img/B16207_09_003.jpg" alt="Figure 9.3 – Operations in PCode&#13;&#10;"/></div></li>&#13;
			</ul>&#13;
			<p class="figure-caption"> </p>&#13;
			<p class="figure-caption">Figure 9.3 – Operations in PCode</p>&#13;
			<p>You can also learn PCode and how to distinguish between address space/varnode/operation <a id="_idIndexMarker338"/>in practice. To <a id="_idIndexMarker339"/>learn it this way, right-click on the instruction and choose <strong class="bold">Instruction Info…</strong> to see the details:</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B16207_09_004.jpg" alt="Figure 9.4 – Retrieving information of a PCode instruction&#13;&#10;"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption"> </p>&#13;
			<p class="figure-caption">Figure 9.4 – Retrieving information of a PCode instruction</p>&#13;
			<p>PCode mnemonics are self-explanatory. But for better understanding the PCode assembly listing, please check the PCode reference.</p>&#13;
			<p class="callout-heading">PCode reference</p>&#13;
			<p class="callout">The list of PCode operations are fully <a id="_idIndexMarker340"/>documented here: <a href="https://ghidra.re/courses/languages/html/pcodedescription.html">https://ghidra.re/courses/languages/html/pcodedescription.html</a>. You can also check out the <code>PcodeOp</code> Java autogenerated <a id="_idIndexMarker341"/>documentation: <a href="https://ghidra.re/ghidra_docs/api/ghidra/program/model/pcode/PcodeOp.html">https://ghidra.re/ghidra_docs/api/ghidra/program/model/pcode/PcodeOp.html</a>.</p>&#13;
			<p>Even though PCode is a powerful tool, it cannot act as a complete substitute for assembly language. Let's compare both to better understand this.</p>&#13;
			<h2 id="_idParaDest-134"><a id="_idTextAnchor166"/>PCode versus assembly language</h2>&#13;
			<p>When comparing <a id="_idIndexMarker342"/>assembly language with PCode, we can notice that assembly language is more human-readable because one assembly <a id="_idIndexMarker343"/>instruction is translated into one or more PCode operations (one-to-many translation) making it more verbose. On the other hand, PCode offers more granularity, allowing you to control every operation step by step instead of doing a lot of things using a single instruction (that is, move a value and update the flags at the same time).</p>&#13;
			<p>So, in conclusion, PCode is preferable for scripting development while assembly language is preferable when code is being analyzed by humans:</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B16207_09_005.jpg" alt="Figure 9.5 – Comparing both _sum disassembly listings: x86 assembly versus PCode&#13;&#10;"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption"> </p>&#13;
			<p class="figure-caption">Figure 9.5 – Comparing both _sum disassembly listings: x86 assembly versus PCode</p>&#13;
			<p>In the next section, we will use PCode to analyze the caller function stored in the <code>caller_function_decompiled</code> variable.</p>&#13;
			<h2 id="_idParaDest-135"><a id="_idTextAnchor167"/>Retrieving PCode and analyzing it</h2>&#13;
			<p>Let's start by <a id="_idIndexMarker344"/>retrieving the PCode decompilation from the <code>caller_function_decompiled</code> variable. To <a id="_idIndexMarker345"/>do so, we only need access to the <code>highFunction</code> property: </p>&#13;
			<pre>caller_pcode = caller_function_decompiled. highFunction</pre>&#13;
			<p>Every PCode basic block is constructed from PCode operations. We can access the PCode operations of <code>caller_pcode</code> as follows: </p>&#13;
			<pre>for pcode_operations in caller_pcode.pcodeOps:</pre>&#13;
			<p>We can also determine whether the operation is a <code>CALL</code> operation targeting <code>sscanf</code> by checking whether the PCode operation is <code>CALL</code> and whether its first operand is the address of <code>sscanf</code>: </p>&#13;
			<pre>if op.opcode == PcodeOp.CALL and op.inputs[0].offset == sscanf.address.offset:</pre>&#13;
			<p>The <code>CALL</code> operation on PCode will usually have the following three input values:</p>&#13;
			<ul>&#13;
				<li><code>input0</code>: The call target</li>&#13;
				<li><code>input1</code>: The destination</li>&#13;
				<li><code>input2</code>: The format string</li>&#13;
			</ul>&#13;
			<p>The rest of the parameters are variables where the values retrieved from the format string will be stored. So, we can calculate how many variables are given to <code>sscanf</code> using the following code:</p>&#13;
			<pre>num_variables = len(op.inputs) - 3</pre>&#13;
			<p>After calculating the number of variables given to <code>sscanf</code>, we can determine whether the output of <code>CALL</code> (the number of values read from the input buffer of <code>sscanf</code>) is checked in the right way – meaning, to see whether all variables (the counter is stored on the integer <code>num_variables</code>) were successfully read.</p>&#13;
			<p>It could be that the return value of <code>sscanf</code> is not ever checked, so the script that we are analyzing starts performing this check, reporting this vulnerability indicator if detected:</p>&#13;
			<pre>if op.output is None:</pre>&#13;
			<p>After that, the script checks the <strong class="bold">descendants</strong>. Ghidra uses <a id="_idIndexMarker346"/>the term descendants when referring to the subsequent uses of a variable:</p>&#13;
			<pre>for use in op.output.descendants:</pre>&#13;
			<p>It looks for integer equality comparisons containing the output of <code>sscanf</code> as operand and stores the value it is comparing with in the <code>comparand_var</code> variable:</p>&#13;
			<pre>if use.opcode == PcodeOp.INT_EQUAL:</pre>&#13;
			<pre>    if use.inputs[0].getDef() == op:</pre>&#13;
			<pre>        comparand_var = use.inputs[1]</pre>&#13;
			<pre>    elif use.inputs[1].getDef() == op:</pre>&#13;
			<pre>        comparand_var = use.inputs[0]</pre>&#13;
			<p>Finally, it checks whether the comparand value is a constant value, and if it is less than the number of variables passed to <code>sscanf</code>, the script reports it because some variable could be used without being properly initialized:</p>&#13;
			<pre>if comparand_var.isConstant():</pre>&#13;
			<pre>    comparand = comparand_var.offset</pre>&#13;
			<pre>    if comparand &lt; num_variables:</pre>&#13;
			<p>As you can guess, this <a id="_idIndexMarker347"/>script logic can be applied to detect multiple k<a id="_idIndexMarker348"/>inds of vulnerabilities; for instance, it can be easily adapted in order to detect use-after-free vulnerabilities. To do so, you can look for <code>free</code> function calls and determine whether the freed buffer is used after that.</p>&#13;
			<h2 id="_idParaDest-136"><a id="_idTextAnchor168"/>Using the same PCode-based script in multiple architectures</h2>&#13;
			<p>In this section, we <a id="_idIndexMarker349"/>will analyze the following vulnerable program but compiled in two flavors – ARM and x86. Thanks to PCode, we will code the script only once:</p>&#13;
			<pre>#include&lt;stdio.h&gt;</pre>&#13;
			<pre>int main() {</pre>&#13;
			<pre>	char* data = "";</pre>&#13;
			<pre>	char name[20];</pre>&#13;
			<pre>	int age;</pre>&#13;
			<pre>	int return_value = sscanf(data, "%s %i", name, &amp;age);</pre>&#13;
			<pre>	if(return_value==1){</pre>&#13;
			<pre>		printf("I'm %s.\n", name);</pre>&#13;
			<pre>		printf("I'm %i years old.", age);</pre>&#13;
			<pre>	}</pre>&#13;
			<pre>}</pre>&#13;
			<p>As you can see, the program is vulnerable because it checks whether <code>return_value</code> is equal to <code>1</code>, but there are two variables (<code>name</code> and <code>age</code>) given to the <code>sscanf</code> function.</p>&#13;
			<p>Now we can compile the program for both x86 and the ARM processor:</p>&#13;
			<ol>&#13;
				<li value="1">Use Ming-w64 to compile it for the x86 architecture (don't worry about whether it's 32 or 64 bits; it doesn't matter for this experiment) to produce an <code>sscanf_x 86.exe</code> executable binary file:<pre><strong class="bold">C:\Users\virusito\vulns&gt; gcc.exe sscanf.c -o sscanf_x86.exe</strong></pre></li>&#13;
				<li>Use GNU Arm Embedded Toolchain to compile it for ARM to produce an <code>sscanf_arm.exe</code> binary file:<pre><strong class="bold">C:\Users\virusito\vulns&gt; arm-none-eabi-gcc.exe sscanf.c -o sscanf_arm.exe -lc –lnosys</strong></pre></li>&#13;
			</ol>&#13;
			<p>We have to perform <a id="_idIndexMarker350"/>some minor changes in the <code>sscanf</code> script developed by Zero Day Initiative in order to make it also work for ARM. These modifications are not related to PCode. Modifications are necessary because Ghidra detects the <code>sscanf</code> symbol instead of <code>_sscanf</code> and it is also detected as <code>SymbolNameRecordIterator</code>:</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B16207_09_006.jpg" alt="Figure 9.6 – Symbol tree and type identification of sscanf in an ARM binary&#13;&#10;"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption"> </p>&#13;
			<p class="figure-caption">Figure 9.6 – Symbol tree and type identification of sscanf in an ARM binary</p>&#13;
			<p>So, we modify it to also include the <code>sscanf</code> symbol while calling the <code>next()</code> method to retrieve the first element (the function) of our given <code>SymbolNameRecordIterator</code>:</p>&#13;
			<pre>sscanfs = list(symbolTable.getSymbols('_sscanf'))</pre>&#13;
			<pre>sscanfs.append(symbolTable.getSymbols('sscanf').next())</pre>&#13;
			<p>As the last step, we execute the script after the analysis, setting the <code>postScript</code> option. We execute Ghidra in headless mode over the <code>vunls</code> directory containing both executable files – <code>sscanf_x86.exe</code> and <code>sscanf_arm.exe</code>:</p>&#13;
			<pre>analyzeHeadless.bat C:\Users\virusito\projects sscanf -postScript C:\Users\virusito\ghidra_scripts\sscanf_ghidra.py -import C:\Users\virusito\vulns\*.exe -overwrite</pre>&#13;
			<p>The <a id="_idIndexMarker351"/>result will look as follows:</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B16207_09_007.jpg" alt="Figure 9.7 – Running a single sscanf_ghidra.py script over the x86 and ARM binaries&#13;&#10;"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption"> </p>&#13;
			<p class="figure-caption">Figure 9.7 – Running a single sscanf_ghidra.py script over the x86 and ARM binaries</p>&#13;
			<p>As you can s<a id="_idTextAnchor169"/>ee, by using PCode, you can write a script once and support all architectures without worrying about it.</p>&#13;
			<p>On the other hand, PCode allows you to automate the bug hunting process, having fine-grained control due to the single assignment property accomplished by PCode.Fine-grained control can be very useful with bug hunting. For instance, for checking whether some program input exists that can reach a vulnerable function, it is easier to use PCode than assembly language, because assembly operations usually modify a lot of stuff (registers, memory, flags, and more) in a single operation.</p>&#13;
			<h1 id="_idParaDest-137"><a id="_idTextAnchor170"/>Summary</h1>&#13;
			<p>In this chapter, you learned how to use Ghidra to automatically audit program binaries to hunt for bugs on them. We started scripting to look for vulnerable functions in the symbols table, then we continued by looking for the callers of those functions, and, finally, we analyzed the caller functions to determine whether those functions are vulnerable or not.</p>&#13;
			<p>You learned how to script a binary auditing process using Ghidra and how to do so using PCode and its benefits. You also learned why PCode cannot entirely substitute for assembly language in manual analysis.</p>&#13;
			<p>In the next chapter of this book, we will cover how to extend Ghidra using plugins. We mentioned this in <a href="B16207_04_Final_SK_ePub.xhtml#_idTextAnchor063"><em class="italic">Chapter 4</em></a>, <em class="italic">Using Ghidra Extensions</em>, but this topic deserves special mention because it allows you to deeply extend Ghidra in a powerful way.</p>&#13;
			<h1 id="_idParaDest-138"><a id="_idTextAnchor171"/>Questions</h1>&#13;
			<ol>&#13;
				<li value="1">What is the difference between SLEIGH and PCode?</li>&#13;
				<li>Is PCode easier to read for humans than assembly language? Why is PCode useful?</li>&#13;
			</ol>&#13;
			<h1 id="_idParaDest-139"><a id="_idTextAnchor172"/>Further reading</h1>&#13;
			<p>You can refer to the following links for more information on the topics covered in this chapter:</p>&#13;
			<ul>&#13;
				<li>Mindshare: Automated bug hunting by modeling vulnerable code: <a href="https://www.thezdi.com/blog/2019/7/16/mindshare-automated-bug-hunting-by-modeling-vulnerable-code">https://www.thezdi.com/blog/2019/7/16/mindshare-automated-bug-hunting-by-modeling-vulnerable-code</a></li>&#13;
				<li>River Loop Security: Working with Ghidra's PCode to identify vulnerable function calls: <a href="https://www.riverloopsecurity.com/blog/2019/05/pcode/">https://www.riverloopsecurity.com/blog/2019/05/pcode/</a></li>&#13;
				<li><em class="italic">Three Heads Are Better Than One: Mastering NSA's Ghidra Reverse Engineering Tool</em>: <a href="https://github.com/0xAlexei/INFILTRATE2019/blob/master/INFILTRATE%20Ghidra%20Slides.pdf">https://github.com/0xAlexei/INFILTRATE2019/blob/master/INFILTRATE%20Ghidra%20Slides.pdf</a></li>&#13;
			</ul>&#13;
		</div>&#13;
	</div></body></html>