["```\nimport os, sys, subprocess, binascii, struct\nimport sqlite3 as lite\n\ndef get_sha1hash(backup_dir):\n\n    # dumping the password/pin from the device\n    print \"Dumping PIN/Password hash ...\"\n    password = subprocess.Popen(['adb', 'pull', '/data/system/password.key', backup_dir], \n        stdout=subprocess.PIPE, stdin=subprocess.PIPE, stderr=subprocess.PIPE)\n    password.wait()\n\n    # cutting the HASH within password.key\n    sha1hash = open(backup_dir + '/password.key', 'r').readline()[:40]\n    print \"HASH: \\033[0;32m\" + sha1hash + \"\\033[m\"\n\n    return sha1hash\n\ndef get_salt(backup_dir):\n\n    # dumping the system DB containing the SALT\n    print \"Dumping locksettings.db ...\"\n    saltdb = subprocess.Popen(['adb', 'pull', '/data/system/locksettings.db', backup_dir], \n        stdout=subprocess.PIPE, stdin=subprocess.PIPE, stderr=subprocess.PIPE)\n    saltdb.wait()\n    saltdb2 = subprocess.Popen(['adb', 'pull', '/data/system/locksettings.db-wal', backup_dir], \n        stdout=subprocess.PIPE, stdin=subprocess.PIPE, stderr=subprocess.PIPE)\n    saltdb2.wait()\n    saltdb3 = subprocess.Popen(['adb', 'pull', '/data/system/locksettings.db-shm', backup_dir], \n        stdout=subprocess.PIPE, stdin=subprocess.PIPE, stderr=subprocess.PIPE)\n    saltdb3.wait()\n\n    # extract the SALT\n    con = lite.connect(backup_dir + '/locksettings.db')\n    cur = con.cursor()    \n    cur.execute(\"SELECT value FROM locksettings WHERE name='lockscreen.password_salt'\")\n    salt = cur.fetchone()[0]\n    con.close()\n\n    # convert SALT to Hex\n    returnedsalt =  binascii.hexlify(struct.pack('>q', int(salt) ))\n    print \"SALT: \\033[0;32m\" + returnedsalt + \"\\033[m\"\n\n    return returnedsalt\n\ndef write_crack(salt, sha1hash, backup_dir):\n\n    crack = open(backup_dir + '/crack.hash', 'a+')\n\n    # write HASH and SALT to cracking file\n    hash_salt = sha1hash + ':' + salt\n    crack.write(hash_salt)\n    crack.close()\n\nif __name__ == '__main__':\n\n    # check if device is connected and adb is running as root\n    if subprocess.Popen(['adb', 'get-state'], stdout=subprocess.PIPE).communicate(0)[0].split(\"\\n\")[0] == \"unknown\":\n        print \"no device connected - exiting...\"\n        sys.exit(2)\n\n    # starting to create the output directory and the crack file used for hashcat\n    backup_dir = sys.argv[1]\n\n    try:\n        os.stat(backup_dir)\n    except:\n        os.mkdir(backup_dir)\n\n    sha1hash = get_sha1hash(backup_dir)\n    salt = get_salt(backup_dir)\n    write_crack(salt, sha1hash, backup_dir)\n```", "```\nuser@lab:~$ ./hashcat -a 3 -m 110 out/crack.hash -1 ?d ?1?1?1?1\nInitializing hashcat v0.50 with 4 threads and 32mb segment-size...\n\nAdded hashes from file crack.hash: 1 (1 salts)\nActivating quick-digest mode for single-hash with salt\n\nc87226fed37977772be870d722c449f915844922:256c05b54b73308b:0420\n\nAll hashes have been recovered\n\nInput.Mode: Mask (?1?1?1?1) [4]\nIndex.....: 0/1 (segment), 10000 (words), 0 (bytes)\nRecovered.: 1/1 hashes, 1/1 salts\nSpeed/sec.: - plains, 7.71k words\nProgress..: 7744/10000 (77.44%)\nRunning...: 00:00:00:01\nEstimated.: --:--:--:--\n\nStarted: Sat Jul 20 17:14:52 2015\nStopped: Sat Jul 20 17:14:53 2015\n\n```", "```\nimport hashlib, sqlite3, array, datetime\nfrom binascii import hexlify\n\nSQLITE_DB = \"GestureRainbowTable.db\"\n\ndef crack(backup_dir):\n\n    # dumping the system file containing the hash\n    print \"Dumping gesture.key ...\"\n\n    saltdb = subprocess.Popen(['adb', 'pull', '/data/system/gesture.key', backup_dir], \n        stdout=subprocess.PIPE, stdin=subprocess.PIPE, stderr=subprocess.PIPE)\n\n    gesturehash = open(backup_dir + \"/gesture.key\", \"rb\").readline()\n    lookuphash = hexlify(gesturehash).decode()\n    print \"HASH: \\033[0;32m\" + lookuphash + \"\\033[m\"\n\n    conn = sqlite3.connect(SQLITE_DB)\n    cur = conn.cursor()\n    cur.execute(\"SELECT pattern FROM RainbowTable WHERE hash = ?\", (lookuphash,))\n    gesture = cur.fetchone()[0]\n\n    return gesture\n\nif __name__ == '__main__':\n\n    # check if device is connected and adb is running as root\n    if subprocess.Popen(['adb', 'get-state'], stdout=subprocess.PIPE).communicate(0)[0].split(\"\\n\")[0] == \"unknown\":\n        print \"no device connected - exiting...\"\n        sys.exit(2)\n\n    # starting to create the output directory and the crack file used for hashcat\n    backup_dir = sys.argv[1]\n\n    try:\n        os.stat(backup_dir)\n    except:\n        os.mkdir(backup_dir)\n\n    gesture = crack(backup_dir)\n\n    print \"screenlock gesture: \\033[0;32m\" + gesture + \"\\033[m\"\"\n```", "```\nimport os, sys, subprocess, hashlib\n\ndef get_apps():\n\n    # dumping the list of installed apps from the device\n    print \"Dumping apps meta data ...\"\n\n    meta = subprocess.Popen(['adb', 'shell', 'ls', '-l', '/data/app'], \n        stdout=subprocess.PIPE, stdin=subprocess.PIPE, stderr=subprocess.PIPE)\n    meta.wait()\n\n    apps = []\n    while True:\n        line = meta.stdout.readline()\n        if line != '':\n            name = line.split(' ')[-1].rstrip()\n            date = line.split(' ')[-3]\n            time = line.split(' ')[-2]\n            if name.split('.')[-1] == 'apk':\n                app = [name, date, time]\n            else:\n                continue\n        else:\n            break\n        apps.append(app)\n\n    return apps\n\ndef dump_apps(apps, backup_dir):\n\n    # dumping the apps from the device\n    print \"Dumping the apps ...\"\n\n    for app in apps:\n        app = app[0]\n        subprocess.Popen(['adb', 'pull', '/data/app/' + app, backup_dir], \n            stdout=subprocess.PIPE, stdin=subprocess.PIPE, stderr=subprocess.PIPE)\n\ndef get_hashes(apps, backup_dir):\n\n    # calculating the hashes\n    print \"Calculating the sha256 hashes ...\"\n\n    meta = []\n    for app in apps:\n        sha256 = hashlib.sha256(open(backup_dir + '/' + app[0], 'rb').read()).hexdigest()\n        app.append(sha256)\n        meta.append(app)\n\n    return meta\n\nif __name__ == '__main__':\n\n    # check if device is connected and adb is running as root\n    if subprocess.Popen(['adb', 'get-state'], stdout=subprocess.PIPE).communicate(0)[0].split(\"\\n\")[0] == \"unknown\":\n        print \"no device connected - exiting...\"\n        sys.exit(2)\n\n    # starting to create the output directory\n    backup_dir = sys.argv[1]\n\n    try:\n        os.stat(backup_dir)\n    except:\n        os.mkdir(backup_dir)\n\n    apps = get_apps()\n    dump_apps(apps, backup_dir)\n    meta = get_hashes(apps, backup_dir)\n\n    # printing the list of installed apps\n    print 'Installed apps:'\n    for app in meta:\n        print \"\\033[0;32m\" + ' '.join(app) + \"\\033[m\"\n```", "```\nuser@lab:~$ ./get_installed_apps.py out\n\nDumping apps meta data ...\nDumping the apps ...\nCalculating the sha256 hashes ...\n\nInstalled apps:\ncom.android.SSLTrustKiller-1.apk 2015-05-18 17:11 52b4d6a1888a6514b62f6607cebf8c2c2aa4e4857319ec67b24be601db5243fb\ncom.android.chrome-2.apk 2015-06-16 20:50 191cd720626df38eaedf3301826e72330493cdeb8c45da4e309939cfe5633d61\ncom.android.vending-1.apk 2015-07-25 12:05 7be9f8f99e8c1a6c3be1edb01d84aba14619e3c67c14856755523413ba8e2d98\ncom.google.android.GoogleCamera-2.apk 2015-06-16 20:49 6936f3c17948c767550c206ff0ae0f44f1f4da0fcb85125da722e0c709787894\ncom.google.android.apps.authenticator2-1.apk 2015-06-05 10:14 11bcfcf1c853b1eb567c9453507c3413b09a1d70fd3085013f4a091719560ab6\n...\n\n```", "```\nimport sys, subprocess\n\ndef get_partition_info():\n\n    # dumping the list of installed apps from the device\n    print \"Dumping partition information ...\"\n\n    partitions = subprocess.Popen(['adb', 'shell', 'mount'], \n        stdout=subprocess.PIPE, stdin=subprocess.PIPE, stderr=subprocess.PIPE)\n    partitions.wait()\n\n    while True:\n        line = partitions.stdout.readline().rstrip()\n        if line != '':\n            print \"\\033[0;32m\" + line + \"\\033[m\"\n        else:\n            break\n\nif __name__ == '__main__':\n\n    # check if device is connected and adb is running as root\n    if subprocess.Popen(['adb', 'get-state'], stdout=subprocess.PIPE).communicate(0)[0].split(\"\\n\")[0] == \"unknown\":\n        print \"no device connected - exiting...\"\n        sys.exit(2)\n\n    get_partition_info()\n```", "```\nuser@lab:~$ ./get_partitions.py \n\nDumping partition information ...\nrootfs / rootfs rw,relatime 0 0\ntmpfs /dev tmpfs rw,seclabel,nosuid,relatime,mode=755 0 0\ndevpts /dev/pts devpts rw,seclabel,relatime,mode=600 0 0\nproc /proc proc rw,relatime 0 0\nsysfs /sys sysfs rw,seclabel,relatime 0 0\nselinuxfs /sys/fs/selinux selinuxfs rw,relatime 0 0\ndebugfs /sys/kernel/debug debugfs rw,relatime 0 0\nnone /acct cgroup rw,relatime,cpuacct 0 0\nnone /sys/fs/cgroup tmpfs rw,seclabel,relatime,mode=750,gid=1000 0 0\ntmpfs /mnt/asec tmpfs rw,seclabel,relatime,mode=755,gid=1000 0 0\ntmpfs /mnt/obb tmpfs rw,seclabel,relatime,mode=755,gid=1000 0 0\nnone /dev/cpuctl cgroup rw,relatime,cpu 0 0\n/dev/block/platform/msm_sdcc.1/by-name/system /system ext4 ro,seclabel,relatime,data=ordered 0 0\n/dev/block/platform/msm_sdcc.1/by-name/userdata /data ext4 rw,seclabel,nosuid,nodev,noatime,nomblk_io_submit,noauto_da_alloc,errors=panic,data=ordered 0 0\n/dev/block/platform/msm_sdcc.1/by-name/cache /cache ext4 rw,seclabel,nosuid,nodev,noatime,nomblk_io_submit,noauto_da_alloc,errors=panic,data=ordered 0 0\n/dev/block/platform/msm_sdcc.1/by-name/persist /persist ext4 rw,seclabel,nosuid,nodev,relatime,nomblk_io_submit,nodelalloc,errors=panic,data=ordered 0 0\n/dev/block/platform/msm_sdcc.1/by-name/modem /firmware vfat ro,relatime,uid=1000,gid=1000,fmask=0337,dmask=0227,codepage=cp437,iocharset=iso8859-1,shortname=lower,errors=remount-ro 0 0\n/dev/fuse /mnt/shell/emulated fuse rw,nosuid,nodev,relatime,user_id=1023,group_id=1023,default_permissions,allow_other 0 0\n\n```", "```\nimport os, sys, subprocess\nimport sqlite3 as lite\nfrom prettytable import from_db_cursor\n\ndef dump_database(backup_dir):\n\n    # dumping the password/pin from the device\n    print \"Dumping contacts database ...\"\n\n    contactsDB = subprocess.Popen(['adb', 'pull', '/data/data/com.android.providers.contacts/databases/contacts2.db', \n        backup_dir], stdout=subprocess.PIPE, stdin=subprocess.PIPE, stderr=subprocess.PIPE)\n    contactsDB.wait()\n\ndef get_content(backup_dir):\n\n    # getting the content from the contacts database\n    con = lite.connect(backup_dir + '/contacts2.db')\n    cur = con.cursor()    \n    cur.execute(\"SELECT contacts._id AS _id,contacts.custom_ringtone AS custom_ringtone, name_raw_contact.display_name_source AS display_name_source, name_raw_contact.display_name AS display_name, name_raw_contact.display_name_alt AS display_name_alt, name_raw_contact.phonetic_name AS phonetic_name, name_raw_contact.phonetic_name_style AS phonetic_name_style, name_raw_contact.sort_key AS sort_key, name_raw_contact.phonebook_label AS phonebook_label, name_raw_contact.phonebook_bucket AS phonebook_bucket, name_raw_contact.sort_key_alt AS sort_key_alt, name_raw_contact.phonebook_label_alt AS phonebook_label_alt, name_raw_contact.phonebook_bucket_alt AS phonebook_bucket_alt, has_phone_number, name_raw_contact_id, lookup, photo_id, photo_file_id, CAST(EXISTS (SELECT _id FROM visible_contacts WHERE contacts._id=visible_contacts._id) AS INTEGER) AS in_visible_group, status_update_id, contacts.contact_last_updated_timestamp, contacts.last_time_contacted AS last_time_contacted, contacts.send_to_voicemail AS send_to_voicemail, contacts.starred AS starred, contacts.pinned AS pinned, contacts.times_contacted AS times_contacted, (CASE WHEN photo_file_id IS NULL THEN (CASE WHEN photo_id IS NULL OR photo_id=0 THEN NULL ELSE 'content://com.android.contacts/contacts/'||contacts._id|| '/photo' END) ELSE 'content://com.android.contacts/display_photo/'||photo_file_id END) AS photo_uri, (CASE WHEN photo_id IS NULL OR photo_id=0 THEN NULL ELSE 'content://com.android.contacts/contacts/'||contacts._id|| '/photo' END) AS photo_thumb_uri, 0 AS is_user_profile FROM contacts JOIN raw_contacts AS name_raw_contact ON(name_raw_contact_id=name_raw_contact._id)\")\n    pt = from_db_cursor(cur)\n    con.close()\n\n    print pt    \n\nif __name__ == '__main__':\n\n    # check if device is connected and adb is running as root\n    if subprocess.Popen(['adb', 'get-state'], stdout=subprocess.PIPE).communicate(0)[0].split(\"\\n\")[0] == \"unknown\":\n        print \"no device connected - exiting...\"\n        sys.exit(2)\n\n    # starting to create the output directory\n    backup_dir = sys.argv[1]\n\n    try:\n        os.stat(backup_dir)\n    except:\n        os.mkdir(backup_dir)\n\n    dump_database(backup_dir)\n    get_content(backup_dir)\n```", "```\n<sms>\n  <db_name>mmssms.db</db_name>\n  <table_num>10</table_num>\n  <sms_entry_positions> \n    <id>0</id>\n    <thread_id>1</thread_id>\n    <address>2</address>\n    <person>3</person>\n    <date>4</date>\n    <read>7</read>\n    <type>9</type>\n    <subject>11</subject>\n    <body>12</body>\n  </sms_entry_positions>\n</sms>\n```", "```\nuser@lab:~$./adel.py -d nexus5 -l 4\n\n _____  ________  ___________.____\n /  _  \\ \\______ \\ \\_   _____/|    |\n /  /_\\  \\ |    |  \\ |    __)_ |    |\n /    |    \\|    `   \\|        \\|    |___\n \\____|__  /_______  /_______  /|_______ \\ \n \\/        \\/        \\/         \\/\n Android Data Extractor Lite v3.0\n\nADEL MAIN:     ----> starting script....\nADEL MAIN:     ----> Trying to connect to smartphone or emulator....\ndumpDBs:       ----> opening connection to device: 031c6277f0a6a117\ndumpDBs:       ----> evidence directory 2015-07-20__22-53-22__031c6277f0a6a117 created\nADEL MAIN:     ----> log file 2015-07-20__22-53-22__031c6277f0a6a117/log/adel.log created\nADEL MAIN:     ----> log level: 4\ndumpDBs:       ----> device is running Android OS 4.4.4\ndumpDBs:       ----> dumping all SQLite databases....\ndumpDBs:       ----> auto dict doesn't exist!\ndumpDBs:       ----> weather database doesn't exist!\ndumpDBs:       ----> weather widget doesn't exist!\ndumpDBs:       ----> Google-Maps navigation history doesn't exist!\ndumpDBs:       ----> Facebook database doesn't exist!\ndumpDBs:       ----> Cached geopositions within browser don't exist!\ndumpDBs:       ----> dumping pictures (internal_sdcard)....\ndumpDBs:       ----> dumping pictures (external_sdcard)....\ndumpDBs:       ----> dumping screen captures (internal_sdcard)....\ndumpDBs:       ----> dumping screen captures (internal_sdcard)....\ndumpDBs:       ----> all SQLite databases dumped\nScreenlock:    ----> Screenlock Hash: 6a062b9b3452e366407181a1bf92ea73e9ed4c48\nScreenlock:    ----> Screenlock Gesture: [0, 1, 2, 4, 6, 7, 8]\nLocationInfo:  ----> Location map 2015-07-20__22-53-22__031c6277f0a6a117/map.html created\nanalyzeDBs:    ----> starting to parse and analyze the databases....\nparseDBs:      ----> starting to parse smartphone info\nparseDBs:      ----> starting to parse calendar entries\nparseDBs:      ----> starting to parse SMS messages\nparseDBs:      ----> starting to parse call logs\nparseDBs:      ----> starting to parse address book entries\nanalyzeDBs:    ----> all databases parsed and analyzed....\ncreateReport:  ----> creating report....\nADEL MAIN:     ----> report 2015-07-20__22-53-22__031c6277f0a6a117/xml/report.xml created\ncompareHash:   ----> starting to compare calculated hash values\nADEL MAIN:     ----> stopping script....\n\n (c) m.spreitzenbarth & s.schmitt 2015\n\n```", "```\nimport os, sys, subprocess\n\ndef get_kc(ip, backup_dir):\n\n    # dumping the keychain\n    print \"Dumping the keychain ...\"\n\n    kc = subprocess.Popen(['scp', 'root@' + ip + ':/private/var/Keychains/keychain-2.db', backup_dir], \n        stdout=subprocess.PIPE, stdin=subprocess.PIPE, stderr=subprocess.PIPE)\n    kc.communicate()\n\ndef push_kcd(ip):\n\n    # dumping the keychain\n    print \"Pushing the Keychain Dumper to the device ...\"\n\n    kcd = subprocess.Popen(['scp', 'keychain_dumper' 'root@' + ip + ':~/'], \n        stdout=subprocess.PIPE, stdin=subprocess.PIPE, stderr=subprocess.PIPE)\n    kcd.communicate()\n\ndef exec_kcd(ip, backup_dir):\n    # pretty print keychain\n    kcc = subprocess.Popen(['ssh', 'root@' + ip, './keychain_dumper'], \n        stdout=subprocess.PIPE, stdin=subprocess.PIPE, stderr=subprocess.PIPE)\n    kcc.communicate()\n    kcc.stdout\n\nif __name__ == '__main__':\n\n    # starting to create the output directory\n    backup_dir = sys.argv[1]\n\n    try:\n        os.stat(backup_dir)\n    except:\n        os.mkdir(backup_dir)\n\n    # get the IP of the iDevice from user input\n    ip = sys.argv[2]\n\n    get_kc(ip, backup_dir)\n    push_kcd(ip)\n    exec_kcd(ip, backup_dir)\n```", "```\nGeneric Password\n----------------\nService: com.apple.account.AppleAccount.password\nAccount: 437C2D8F-****-****-****-************\nEntitlement Group: apple\nLabel: (null)\nGeneric Field: (null)\nKeychain Data: *************************\n\n```", "```\nimport os, sys, subprocess\n\ndef get_device_info():\n\n    # getting the udid of the connected device\n    udid = subprocess.Popen(['idevice_id', '-l'], stdout=subprocess.PIPE).stdout.readline().rstrip()\n\n    print \"connected device: \\033[0;32m\" + udid + \"\\033[m\"\n    return udid\n\ndef create_backup(backup_dir):\n\n    # creating a backup of the connected device\n    print \"creating backup (this can take some time) ...\"\n\n    backup = subprocess.Popen(['idevicebackup2', 'backup', backup_dir], stdout=subprocess.PIPE)\n    backup.communicate()\n\n    print \"backup successfully created in ./\" + backup_dir + \"/\"\n\ndef unback_backup(udid, backup_dir):\n\n    # unpacking the backup\n    print \"unpacking the backup ...\"\n\n    backup = subprocess.Popen(['idevicebackup2', '-u', udid, 'unback', backup_dir], stdout=subprocess.PIPE)\n    backup.communicate()\n\n    print \"backup successfully unpacked and ready for analysis\"\n\ndef get_content(backup_dir):\n\n    # printing content of the created backup\n    content = subprocess.Popen(['tree', backup_dir + '/_unback_/'], stdout=subprocess.PIPE).stdout.read()\n    f = open(backup_dir + '/filelist.txt', 'a+')\n    f.write(content)\n    f.close\n\n    print \"list of all files and folders of the backup are stored in ./\" + backup_dir + \"/filelist.txt\"\n\nif __name__ == '__main__':\n\n    # check if device is connected\n    if subprocess.Popen(['idevice_id', '-l'], stdout=subprocess.PIPE).communicate(0)[0].split(\"\\n\")[0] == \"\":\n        print \"no device connected - exiting...\"\n        sys.exit(2)\n\n    # starting to create the output directory\n    backup_dir = sys.argv[1]\n\n    try:\n        os.stat(backup_dir)\n    except:\n        os.mkdir(backup_dir)\n\n    udid = get_device_info()\n    create_backup(backup_dir)\n    unback_backup(udid, backup_dir)\n    get_content(backup_dir)\n```", "```\nuser@lab:~$ ./create_ios_backup.py out\n\nconnected device: 460683e351a265a7b9ea184b2802cf4fcd02526d\ncreating backup (this can take some time) ...\nbackup successfully created in ./out\nunpacking the backup ...\nbackup successfully unpacked and ready for analysis\nlist of all files and folders of the backup are stored in ./out/filelist.txt\n\n```"]