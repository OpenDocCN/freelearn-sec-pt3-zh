<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Combatting Tunneling and Encryption</h1>
                </header>
            
            <article>
                
<p>In the last few chapters, we saw how we can capture network packets and gain deep insights into them using various tools and techniques. However, what if the data traveling across the network using a DNS query is not carrying a DNS payload? Alternatively, what if the data makes no sense from the packets under observation? To answer these questions, we will have a look at various stepping stones in our journey of effectively conducting network forensics. The data is sometimes encrypted using TLS, SSL, custom encryption mechanisms, or WEP/ WPA2 in the wireless space. In this chapter, we will look at combating these hurdles and obtaining meaningful data behind the closed doors of encryption.</p>
<p>We will look at the following topics:</p>
<ul>
<li>Decrypting TLS using browsers</li>
<li>Decoding a malicious DNS tunnel</li>
<li>Decrypting 802.11 packets</li>
<li>Decoding keyboard captures</li>
</ul>
<p>This is the final chapter before we make a move into the hands-on network forensic exercises, where we will make use of strategies learned in the first five chapters to decode, decrypt, and solve the exercises in the last five chapters. So, let's get started.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>To complete exercises in this chapter, we will require the following:</p>
<ul>
<li>Kali Linux (<a href="https://www.kali.org/downloads/">https://www.kali.org/downloads/</a>)</li>
<li>Wireshark v2.6.6 (<a href="https://www.wireshark.org/download.html">https://www.wireshark.org/download.html</a>) installed on Windows 10 OS</li>
<li>Aircrack-ng Suite (already present in Kali Linux)</li>
<li>Scapy Python library (already a part of Kali Linux and can be installed by using <kbd>pip install scapy</kbd> command)</li>
<li>You can download the codes and PCAP files used in this chapter from <a href="https://github.com/nipunjaswal/networkforensics/tree/master/Ch5">https://github.com/nipunjaswal/networkforensics/tree/master/Ch5</a></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Decrypting TLS using browsers</h1>
                </header>
            
            <article>
                
<p>One of the hidden features of the popular Chrome browser is the support of logging the symmetric session key used while encrypting the traffic with TLS to a file of our choice. Let's see what happens when we try to capture a TLS-encrypted packet:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/f245a84f-6ec2-4b04-a69b-a6c3a7d9b1e4.png"/></div>
<p>We can see that the network traffic is encrypted using TLS and that the data in the bottom pane is not making much sense to us. Fortunately, browsers such as Chrome support storing the TLS key, which can help us decrypt the data that otherwise is not making sense. To set up logging, we need to export a user environment variable by browsing the Control Panel and opening system.</p>
<p>Next, we need to choose <strong>Advanced system settings</strong>. In the next step, we will choose the <strong>Environment Variables...</strong> option. In the <strong>User variable</strong> section, we will add the <kbd>SSLKEYLOGFILE</kbd> variable by clicking <strong>New</strong> and then set its value as any file of our choice:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/dc2158e7-958b-4734-8b5f-22a0beafa600.png" style="width:33.83em;height:11.17em;"/></div>
<p>Make sure you create an empty file with the name used in the variable value; in our case, it's <kbd>ssl.log</kbd>. Since we now have the setup ready, we can let the user browse the network. The preceding logging option will be helpful in cases of suspicion on a particular user can be confirmed by decrypting his TLS traffic and monitoring their activities.</p>
<div class="packt_tip">On a Linux system, the environment variable can be exported using export <kbd>SSLKEYLOGFILE=PATH_OF_FILE</kbd> command.</div>
<p>Network packets can be captured at the hub or mirror port, but to decrypt the TLS sessions, the log file will be required. Once this file is set up correctly, the administrators and network forensic experts have enough to decrypt the TLS sessions on a different system. Let's see what kind of data is generated in the log file:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/d70f1eeb-b9e3-4f9b-9b31-80cedcd0e0f5.png"/></div>
<p>We can see that the file contains session keys. Let's set up SSL/TLS decryption in Wireshark by navigating to <strong>Edit</strong> and choosing <strong>Preferences</strong>. Then scroll down to <strong>SSL</strong> / <strong>TLS</strong> (Wireshark version 3.0) from the <strong>Protocols</strong> section:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/d65b0fea-6898-4eab-9db2-baaf29273173.png" style="width:46.25em;height:32.08em;"/></div>
<p>Let's set the path of the log file in the <strong>(Pre)-Master-Secret log filename</strong> field and press <strong>OK</strong>:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/1ad0c2e1-3c33-4e37-97d2-c45c3bf3ad7c.png" style="width:48.75em;height:34.00em;"/></div>
<p>We will now have the TLS sessions decrypted:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/b303a773-3cef-48ab-9cd0-c7c4b545960b.png"/></div>
<p>We can see most of the TLS traffic data in plain HTTP format. It is quite obvious that I will not be giving out this PCAP and associated log file, for security and privacy concerns. To perform the preceding exercise, you need to set up your environment variable with the path to the log file and browse some TLS-enabled websites. You will have the log file with various session keys; use it to decrypt your TLS-enabled data.</p>
<div class="packt_tip">SSL has been replaced by TLS in version 3.0.0 of Wireshark.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Decoding a malicious DNS tunnel</h1>
                </header>
            
            <article>
                
<p>While preparing the content for this book, I stumbled upon a few of the excellent <strong>Capture the Flag</strong> (<strong>CTF</strong>) challenges, which demonstrate mind-boggling exercises. One of them is the one we are going to discuss next. We covered an exercise on the ICMP shell in the previous chapters, and ICMP tunneling works on the same principle, which is to pass TCP-related data through a series of ICMP requests. Similarly, DNS and SSH tunneling also work; they encapsulate normal TCP traffic within them and pass the common security practices. DNS and SSH tunneling are fairly popular for bypassing captive portal restrictions on airports, cafes, and so on. However, certain malware also makes use of DNS to perform command and control of the compromised machines. Let's see an example that demonstrates strange DNS requests and look at what can we do with them. The PCAP example is taken from HolidayHack 2015, and you can download the sample PCAP from <a href="https://github.com/ctfhacker/ctf-writeups/blob/master/holidayhack-2015/part1/gnome.pcap">https://github.com/ctfhacker/ctf-writeups/blob/master/holidayhack-2015/part1/gnome.pcap</a> thanks to Cory Duplantis, also known as <strong>ctfhacker</strong>.</p>
<div class="packt_tip">We will soon be requiring Kali Linux for this exercise and the version of Wireshark is 2.6.6 so download the PCAP to both Windows as well as Kali Linux machine.</div>
<p>Let's open up <kbd>gnome.pcap</kbd> in Wireshark:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/81a95332-c5aa-4bf4-a5f0-e17b630b6821.png" style="width:43.00em;height:25.67em;"/></div>
<p>We can see that we have a mix of Wireless 802.11 packets and DNS query responses in the PCAP file, which is quite strange, as there are no query requests, only query responses. Let's investigate the DNS packets a little further:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/dfc2ae6c-f161-4012-9d7f-28e04e634c7f.png"/></div>
<p>We can see that on filtering the DNS packets, we have many packets with a transaction ID of <kbd>0x1337</kbd> and with base64-like data incubated in them. Let's try to extract this data using <kbd>tshark</kbd>:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/27c0bb76-d0bd-49eb-84f4-fb3396d8fae5.png" style="width:36.75em;height:18.67em;"/></div>
<p>The preceding <kbd>tshark</kbd> command reads from GNOME. The PCAP file uses the <kbd>-r</kbd> switch and we have set a filter on the DNS transaction ID under observation using the <kbd>dns.id==0x1337</kbd> filter by using the <kbd>-R</kbd> switch.</p>
<p>Additionally, we chose only to print the DNS response length for all the packets by using the <kbd>-T</kbd> fields followed by <kbd>-e</kbd> to denote the field, and <kbd>dns.resp.len</kbd> to print the response lengths. However, we are more interested in harvesting the TXT record itself that looked like base64, and frankly, using the <kbd>dns.txt</kbd> instead of <kbd>dns.resp.len</kbd> does not help. Therefore, we need a mechanism to extract these entries.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using Scapy to extract packet data</h1>
                </header>
            
            <article>
                
<p><strong>Scapy</strong> is a packet manipulation tool for networks, written in Python. It can forge or decode packets, send them on the wire, capture them, and match requests and replies. We can use <kbd>scapy</kbd> to extract the TXT records as follows:</p>
<pre>From scapy.all import  * 
import base64 
 
network_packets = rdpcap('gnome.pcap') 
decoded_commands = [] 
decoded_data ="" 
for packet in network_packets: 
    if DNSQR in packet: 
        if packet[DNS].id == 0x1337: 
            decoded_data = base64.b64decode(str(packet[DNS].an.rdata)) 
        if 'FILE:' in decoded_data: 
                        continue 
        else: 
                decoded_commands.append(decoded_data) 
for command in decoded_commands: 
        if len(command)&gt;1: 
                print command.rstrip() </pre>
<p>By merely using 15 lines of code in Python, we can extract the data we want. The first two lines are header imports, which will give the python script the functionality from base64 and <kbd>scapy</kbd>. Next, we have the following:</p>
<pre>network_packets = rdpcap('gnome.pcap') 
decoded_commands = [] 
decoded_data =""</pre>
<p>In the preceding code segment, we are reading a PCAP file, <kbd>gnome.pcap</kbd>, from the current working directory and also declaring a list named <kbd>decoded_commands</kbd> and a string variable named <kbd>decoded_data</kbd>. Next, we have the following code:</p>
<pre>for packet in network_packets: 
    if DNSQR in packet: 
        if packet[DNS].id == 0x1337: 
            decoded_data = base64.b64decode(str(packet[DNS].an.rdata)) </pre>
<p>The <kbd>for</kbd> loop will traverse the packets one after the other, and if the packet is of the DNS type, it will check whether the packet ID matches <kbd>0x1337</kbd>. If it does, it pulls the TXT record data using <kbd>packet[DNS].an.rdata</kbd>, converts it into a string, and decodes it from base64 to normal text and in case the decoded data contains <kbd>FILE:</kbd> the execution should continue else the <kbd>decoded_data</kbd> is appended to <kbd>decoded_command</kbd>:</p>
<pre>if 'FILE:' in decoded_data:<br/>          continue<br/>else:        <br/>          decoded_commands.append(decoded_data) 
for command in decoded_commands: 
          if len(command)&gt;1: 
                  print command.rstrip() </pre>
<p>The preceding section appends the decoded data into the <kbd>decoded_command</kbd> list and loops over the list while printing all the elements of the list whose length is greater than 1 (to avoid empty lines). Running the script gives us the following output:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/c5387d5b-11cd-4045-9ba4-09143399ad65.png" style="width:32.25em;height:26.83em;"/></div>
<p>Well, this looks like output from the <kbd>iwlist</kbd> scan command. The output of a system command is not something to be expected in the DNS responses. This denotes that the system under observation was compromised and the attacker used DNS for command and control.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Decrypting 802.11 packets</h1>
                </header>
            
            <article>
                
<p>Sometimes, as a forensics investigator, you will receive PCAP files that contain WLAN packets, and to make sense out of them, you need the key. Obtaining the key should not be difficult in forensic scenarios where you have the authority, but as a forensic investigator, you must be prepared for all possible situations. In the next scenario, we have a PCAP file from <a href="https://github.com/ctfs/write-ups-2015/raw/master/codegate-ctf-2015/programming/good-crypto/file.xz">https://github.com/ctfs/write-ups-2015/raw/master/codegate-ctf-2015/programming/good-crypto/file.xz</a>, and as soon as we open it up in Wireshark, we have 802.11 packets right in front of us:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/7dcd3eca-7674-425d-ac3f-cc6ad06be609.png"/></div>
<p>We cannot figure out what activities were performed in the network unless we remove the 802.11 encapsulation. However, let's see what sort of statistics are available in Wireshark by navigating to the <strong>Wireless</strong> tab and choosing WLAN traffic:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/fe33f41d-4344-4f1c-8f82-19c9c7415cce.png"/></div>
<p>We can see that we have 100% packets in the Wireless segment and the <strong>SSID</strong> (name of the network) as <strong>cgnetwork</strong> running on channel number <strong>1</strong> and having multiple clients connected to it. To see the activities, we need to remove the 802.11 encapsulation, which can be done by providing the network key that we do not have. So, what do we do? Let's try to find the key using the <strong>Aircrack-ng</strong> suite, which is a popular wireless network-cracking tool (already available in Kali Linux).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Decrypting using Aircrack-ng</h1>
                </header>
            
            <article>
                
<p>Let's use Aircrack-ng to find the network key. We will type <kbd>aircrack-ng</kbd> followed by the PCAP file:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/736ca413-b17e-4c9f-aca7-1215c8fe239f.png"/></div>
<p>We can see that we got the WEP key with ease. We can use this key to decrypt packets in Wireshark:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/1a34e6ce-9004-4590-b2ed-128f8fb240e8.png" style="width:36.67em;height:29.75em;"/></div>
<p>We will navigate to <strong>Edit...</strong> and choose <strong>Preferences</strong>. Once the dialog box is open, we will choose protocols and scroll down to <strong>IEEE 802.11</strong>, as shown in the preceding screenshot. Next, we will select the <strong>Decryption Keys</strong> option and choose <strong>Edit</strong>, which will populate a separate dialog box, as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/e951dba8-edf0-4696-96a3-f049e2a252da.png" style="width:34.25em;height:14.83em;"/></div>
<p>We will click the <strong>+</strong> sign, add the key we found using Aircrack-ng, and press <strong>OK</strong>:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/34c4c113-6823-467d-8714-90ba0b66ec38.png"/></div>
<p>Wow! We can see that we successfully removed the Wireless encapsulation. Alternatively, we could have used <kbd>airdecap</kbd> from the <kbd>aircrack</kbd> suite to remove the encapsulation. We just saw how we could work with Wireless protocols and remove encapsulation by cracking the WEP keys. However, this may not apply to WPA and WPA2 standards. Let's see an example:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/f28a8e3f-2038-4e50-8ef7-476bb508a7d2.png" style="width:35.17em;height:15.17em;"/></div>
<p>We supplied a plaintext password for WPA2, and the PCAP was successfully decrypted:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/a70f969f-ea19-45dc-932a-b97c842e29ab.png"/></div>
<p>However, the password-cracking process is not as standardized as it was in the case of WEP. Let's see what happens when we try to crack PCAP in the <kbd>aircrack-ng</kbd> suite:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/88f8d855-8392-413e-b588-8f0f76e548a7.png" style="width:37.92em;height:18.00em;"/></div>
<p>We can see that the <kbd>aircrack-ng</kbd> suite asked us to specify a dictionary file that might contain a password, which means that the only way to obtain the key, in this case, is via brute force. Let's see how we can supply a dictionary file that contains a password list:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/17ea5108-be31-4b83-9ee2-7cadc73dfb3c.png" style="width:35.08em;height:13.58em;"/></div>
<div class="packt_tip">Dictionary files are available in Kali by default under <kbd>/usr/share/dict/words</kbd>.</div>
<p>We can see that we have supplied an example dictionary file using the <kbd>-w</kbd> switch, and now Aircrack-ng is trying to crack the passwords. So, at some point, we will get the following result:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/6992ce29-23f3-47b8-b852-eac72bc74189.png" style="width:38.83em;height:24.17em;"/></div>
<p>Yeah! We got the key. We already saw how we could apply this key in Wireshark and analyze it further. We will be discussing the 802.11 standards in the upcoming chapters, as we have one complete chapter dedicated to it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Decoding keyboard captures</h1>
                </header>
            
            <article>
                
<p>Another day and another interesting PCAP capture. Have you ever thought that USB keyboards could also reveal a lot of activity and user behavior? We will look at such scenarios in the upcoming chapters, but for now, let's prepare for it. I found an interesting packet-capture file from <a href="https://github.com/dbaser/CTF-Write-ups/blob/master/picoCTF-2017/for80-just_keyp_trying/data.pcap"><span class="URLPACKT">https://github.com/dbaser/CTF-Write-ups/blob/master/picoCTF-2017/for80-just_keyp_trying/data.pcap</span></a>. However, on downloading the PCAP file and loading it in Wireshark, I got the following:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/379a4d11-dc6b-4f35-a821-ff17ff3be129.png"/></div>
<p>Well, I have not seen anything like this, but we know that this is USB data. We can also see that the leftover column contains some bytes. This is the data of interest; let's use <kbd>tshark</kbd> to harvest this data by running the <kbd>tshark –r [path to the file]</kbd> as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/6e741e80-4f3f-4205-8542-8bdccccc2348.png" style="width:44.00em;height:40.17em;"/></div>
<p>Let's only print the leftover data, using the <kbd>usb.capdata</kbd> field:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/3a5ab07d-c5ff-46fb-b61c-90f4973ea6f6.png" style="width:35.00em;height:35.42em;"/></div>
<p>We can see that we have only one or two bytes per line, so in order to decode the USB keystrokes, we will require only bytes without zeros and separators. Let's remove the null and separators from the lines by running the <kbd>tshark -r Desktop/data.pcap -T fields -e usb.capdata | sed -e 's/00//g' -e 's/://g' -e 's/20//g' | grep .</kbd> command as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/58190a92-21d5-4d25-9705-fff62d24bf7e.png"/></div>
<p>When we remove the zeros and separators, we are left with the preceding data. The bytes from the preceding screenshot can be interpreted as keystrokes and can be mapped to the keys listed in page 53 from <a href="https://www.usb.org/sites/default/files/documents/hut1_12v2.pdf"><span class="URLPACKT">https://www.usb.org/sites/default/files/documents/hut1_12v2.pdf</span></a>. According to the documentation, <strong>09</strong> maps to <strong>f</strong>, <strong>0F</strong> maps to <strong>l</strong>, <strong>04</strong> maps to <strong>a</strong>, and <strong>0a</strong> to <strong>g</strong>, which means the first four typed-in characters are <strong>flag</strong>. Similarly, a parser for these bytes could allow us to view everything that a user typed from the PCAP capture itself. Let's also use a small Python-based script that makes use of Scapy to parse the entire PCAP itself:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/c98d4fe8-25a7-4255-9ec7-884d2f289701.png" style="width:25.17em;height:3.92em;"/></div>
<p>The preceding script can be obtained from <a href="https://github.com/dbaser/CTF-Write-ups/blob/master/picoCTF-2017/for80-just_keyp_trying/usbkeymap2.py"><span class="URLPACKT">https://github.com/dbaser/CTF-Write-ups/blob/master/picoCTF-2017/for80-just_keyp_trying/usbkeymap2.py</span></a> and is very similar to what we have done for the DNS queries.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we learned a lot. We started by making use of client-side SSL log files to decrypt SSL/TLS sessions. Then we looked at DNS malicious query responses that carry command and control data. We explored WEP and WPA2 decryption by decrypting the password through the Aircrack-ng suite and made use of decryption keys in Wireshark. We also went through a small snippet of code in Python to segregate and decode data. Finally, we looked at the USB keyboard capture file and decrypted the keystrokes pressed by the user at the time it was recorded in the PCAP file. This is the end of our preparation phase, and we will now jump into the hands-on side of things. We will be making use of the lessons and techniques learned in the first five chapters, and based on the knowledge we gained; we will try to solve the challenges in the upcoming chapters.</p>
<p>In the next chapter, we will look at live malware samples, and we will perform network forensics over them. We will develop strategies to unfold the root cause of the malware deployment, and find vital details, such as the first point of entry in the network.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Questions and exercises</h1>
                </header>
            
            <article>
                
<p>To gain the best out of this chapter, attempt the following:</p>
<ul>
<li>Do any other browsers exhibit similar behavior to chrome in storing SSL key logs? Find it out</li>
<li>Can you decrypt the wireless capture file? If yes find out the password for challenge file <kbd>wireless_decryption_challenge.pcap</kbd> hosted here <a href="https://github.com/nipunjaswal/networkforensics/tree/master/Challenges">https://github.com/nipunjaswal/networkforensics/tree/master/Challenges</a></li>
<li>Try attaching a keyboard to your laptop/ desktop and capture the USB data and decode the keys</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<p>Check out the <strong>Nailing the CTF challenge</strong><span>: </span><a href="https://subscription.packtpub.com/book/networking_and_servers/9781784393335/3/ch03lvl1sec26/nailing-the-ctf-challenge"><span class="URLPACKT">https://subscription.packtpub.com/book/networking_and_servers/9781784393335/3/ch03lvl1sec26/nailing-the-ctf-challenge</span></a> for more information on the topics covered in this chapter.</p>


            </article>

            
        </section>
    </body></html>