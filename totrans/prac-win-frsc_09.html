<html><head></head><body><div class="chapter" title="Chapter&#xA0;9.&#xA0;Windows Files"><div class="titlepage"><div><div><h1 class="title"><a id="ch09"/>Chapter 9. Windows Files</h1></div></div></div><p>In the previous chapter, we discussed the Windows log files and discussed how important they are for analysis. However, Windows logs aren't the only important artifact in Windows. In this chapter, we will discuss more important Windows files that are usually created in the normal Windows operations but may have evidential importance from our prospective of the case under investigation.</p><div class="section" title="Windows prefetch files"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec53"/>Windows prefetch files</h1></div></div></div><p>The Windows operating system uses what are called prefetch files to speed up the program starting process. It will store a list of all the files and DLLs used by the program when started in order to preload these files into the memory when the program starts to make it faster to start. Each executable has a prefetch file which contains the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The executable's name</li><li class="listitem" style="list-style-type: disc">The path to the executable</li><li class="listitem" style="list-style-type: disc">The number of times that the program ran within the system</li><li class="listitem" style="list-style-type: disc">The last run time</li><li class="listitem" style="list-style-type: disc">A list of DLLs used by the program</li></ul></div><p>The prefetch files are located at <code class="literal">%SystemRoot%\Prefetch</code>, and each file has a "pf" extension. The naming schema of these files consists of adding the executable name in capital letters, followed by -, and then an eight character hash of the application's start location, as shown in Figure1 for the <code class="literal">calc.exe</code> Windows native tool:</p><div class="mediaobject"><img src="graphics/image_09_001.jpg" alt="Windows prefetch files"/><div class="caption"><p>Figure 1: A prefetch file example</p></div></div><p>If you find two different pf files on the same executable, this means that either there are two executables with the same name, or the same executable ran from two different locations. Also, the user who ran this program won't store this in the prefetch information. However, this can be compensated by correlating the last run time and the pf modification timestamp in the filesystem with the security logging information to see which user ran this executable the last time.</p><p>The maximum number of prefetch files is 1,024 starting from Windows 8. From Windows XP to Windows 7, it was 128 files only. When the maximum number of files is reached, Windows will delete the oldest file in order to create a new one. This means that in case you found the maximum number of prefetch files in the prefetch folder, you can assume that there might be another pf file for any existing executable and it was overwritten before and recreated again, so the first run and last run of the program might not be the right times.</p><p>Windows prefetch can be used in speeding up the booting process of the applications' start time or both. This information will be written in the following registry key: <code class="literal">HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\Memory Management\PrefetchParameters</code>.</p><p>Under a <code class="literal">EnablerPrefetcher</code> registry value, you can find one of four data values:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">0: This means that prefetching is disabled.</li><li class="listitem" style="list-style-type: disc">1: This means enable applications prefetching only.</li><li class="listitem" style="list-style-type: disc">2: This means enable boot prefetching only.</li><li class="listitem" style="list-style-type: disc">3: This means enable both boot and applications prefetching:<div class="mediaobject"><img src="graphics/image_09_002.jpg" alt="Windows prefetch files"/><div class="caption"><p>Figure 2: Prefetch in Registry</p></div></div></li></ul></div><p>A piece of malware is a program as well. So, if the prefetch was configured to enable prefetching for applications, a prefetch file will be created for that malware in the <code class="literal">prefetch</code> folder. Finding a malware's prefetch file will add great evidential value as it will indicate all the files and DLLs that were used by the malware, which will give indications about its operations and a start point for the rest of the analysis.</p><p>Also, in some attacks, the kill chain requires running different tools on the local system to remotely control it by attackers. Ordering prefetch files by time and filtering the files by the incident time will give us the timely ordered tools which ran within the system and caused the infection. These facts will help us make better assumptions about an attack scenario and will help in the eradication and recovery phases of the incident response cycle.</p><p>Another file named <code class="literal">layout.ini</code> is located in the same <code class="literal">prefetch</code> folder as well. In this file, there are some paths to the files that are frequently used and loaded by the prefetching process. This file is used by the Windows Defragment process to move all the files that are opened frequently in a contiguous location physically in the system disk in order to load it quickly and reduce the time required to physically access these disk locations sequentially. This process's effect can be noticed in the HDD more than SSD, where the access to any physical location in the HDD requires mechanical motion.</p><div class="section" title="Prefetch file analysis"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec83"/>Prefetch file analysis</h2></div></div></div><p>It is worth mentioning that the structure of the prefetch file changes from one Windows version to another. To analyze the prefetch file, the investigator can open it manually with a hex-editor, for example, understand its structure, and start parsing the contents of the file and even create an automated tool to perform this function faster. Fortunately, there is a tool already created, and it supports the prefetch files up to Windows 10. The WinPrefetchView tool can be downloaded from <a class="ulink" href="http://nirsoft.com/">http://nirsoft.com/</a>.</p><p>WinPrefetchView automatically parses the location of the prefetch files in the live system and views it for further analysis. In order to parse prefetch files in a postmortem analysis on our Linux analysis machine, we can run the WinPrefetch program within the Wine environment and copy the <code class="literal">prefetch</code> folder from the mounted image.</p><p>The program interface consists of two small windows, one for the applications that are related to each prefetch file and another one to list all the files that are used by the selected program from the upper window. In Figure 3, we can see the ntosboot file, which refers to the boot process of the system and lists all the files that are opened during this operation. In Figure 3, the program is running from the Linux machine under the Wine environment:</p><div class="mediaobject"><img src="graphics/image_09_003.jpg" alt="Prefetch file analysis"/><div class="caption"><p>Figure 3: WinPrefetchView</p></div></div></div></div></div>
<div class="section" title="Windows tasks"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec54"/>Windows tasks</h1></div></div></div><p>Some programs need to perform specific events at a specific time in the Windows environment. To do this, Windows allows programs to create what is called a <span class="strong"><strong>scheduled task</strong></span>. Tasks are stored in <code class="literal">C:\Windows\System32\Tasks</code>. Each task is stored in the XML file format, which contains the user who created the task, the time or the trigger of the task to take place, and the path to the command or the program that will be executed, which is the task itself. Starting from Task Scheduler 2.0, which was first introduced with Windows Vista, the trigger can be calendar-based or an event, such as starting the task when a specific event is logged to the event log system. The actions can also be: running the program, sending an e-mail, or viewing a message to the user.</p><p>In the live system, the investigator can open the tasks using the usual <code class="literal">Task Scheduler</code>. From the forensic image, the investigator can extract the tasks from <code class="literal">C:\Windows\System32\Tasks</code>, where each file is a single task in the XML format. In Figure 4, we can see the task that is used by Google in the Windows operating system to update Google products in the system:</p><div class="mediaobject"><img src="graphics/image_09_004.jpg" alt="Windows tasks"/><div class="caption"><p>Figure 4: Google Update Task</p></div></div><p>A piece of malware can create a task to start itself after a specific trigger, such as running the malware executable each morning, or after a specific period of time. This is another way used by malware authors to ensure the existence of the malware on the infected machine besides adding its executable to the startup registry keys or as a service in the system.</p></div>
<div class="section" title="Windows Thumbs DB"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec55"/>Windows Thumbs DB</h1></div></div></div><p>When the user uses the <span class="strong"><strong>Thumbnails</strong></span> or <span class="strong"><strong>Filmstrip</strong></span> views from the <code class="literal">Windows</code> folder viewing options, a small thumbnail version of the pictures will be created and stored in a single file. This file is located in the same directory as the pictures in Windows XP and named <code class="literal">Thumbs.db</code>. The <code class="literal">Thumbs.db</code> file has a thumbnail version of the existing and also deleted pictures. <code class="literal">Thumbs.db</code> is a hidden file, and usually the user ignores it:</p><div class="mediaobject"><img src="graphics/image_09_005.jpg" alt="Windows Thumbs DB"/><div class="caption"><p>Figure 5: Files viewing options</p></div></div><p>If the user has deleted the pictures but hasn't delete the <code class="literal">Thumbs.db</code> file, it will be possible to recover the thumbnail version of the pictures deleted from that directory, which provide a good clue about the pictures' contents. Besides the thumbnail version of the picture, <code class="literal">Thumbs.db</code> contains the file name and the date and time of the last modification.</p><p>This <code class="literal">Thumbs.db</code> file is very important in cases related to pictures, such as child pornography cases.</p><p>Starting from Windows 7, the process of handling thumbnails files changed. All the <code class="literal">Thumbs.db</code> files are allocated in a single folder in <code class="literal">C:\Users\&lt;UserName&gt;\AppData\Local\Microsoft\Windows\Explorer</code>. This is better from the forensics prospective, as all the files are in the same place and there is no need to search for any <code class="literal">Thumbs.db</code> files in the whole partition or disk, and it won't be deleted if the user deleted the whole photos' folder. Also, the file name has changed to <code class="literal">Thumbcache.db</code>.</p><p>In the modern Windows version, the files' view has different sizes: small, medium, large, and extra-large. Different thumbcache files need to be allocated for each size of the viewing layout. Each size has a separate Thumbcache database, and the name of the Thumbcache file has a number, which indicates the size of the viewing layout, for example, <code class="literal">thumbcache_32.db</code> or <code class="literal">thumbcache_256.db</code>:</p><div class="mediaobject"><img src="graphics/image_09_006.jpg" alt="Windows Thumbs DB"/><div class="caption"><p>Figure 6: Files viewing options in modern Windows Oses</p></div></div><div class="section" title="Thumbcache analysis"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec84"/>Thumbcache analysis</h2></div></div></div><p>Thumbcache Viewer is a free tool, and it can be downloaded from <a class="ulink" href="https://thumbcacheviewer.github.io/">https://thumbcacheviewer.github.io/</a>. It extracts thumbnail images from Thumcache files, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/image_09_007.jpg" alt="Thumbcache analysis"/><div class="caption"><p>Figure 7: Thumbcache Viewer</p></div></div><p>Note that there is another version to parse <code class="literal">Thumbs.db</code> files.</p><p>The original file path is not stored in the <code class="literal">Thumbcache</code> file. To map the file to its original location, we can run the program in the target Windows system itself and start mapping from the live system. Or, we can extract and use the Windows search database <code class="literal">Windows.edb</code> file from the target system, the system under investigation. It is an ESE database located at <code class="literal">C:\ProgramData\Microsoft\Search\Data\Applications\Windows\</code>:</p><div class="mediaobject"><img src="graphics/image_09_008.jpg" alt="Thumbcache analysis"/><div class="caption"><p>Figure 8: Mapping Thumbcache files to location</p></div></div><p>This is created by the Windows indexing service that is used to speed the search process in Windows OS. Thumbcache viewer uses this file to map the entries to their original locations in the target system. Thumbcache viewer can run on another Windows system and use only this database file from the target Windows system. However, in this case, the host Windows OS must be the same version or higher of the target Windows system. Not all the entries will be mapped based on the data in the <code class="literal">Windows.edb</code> file, but the successfully mapped entries will be viewed in green:</p><div class="mediaobject"><img src="graphics/image_09_009.jpg" alt="Thumbcache analysis"/><div class="caption"><p>Figure 9: Mapped entries using the Windows.edb file.</p></div></div></div><div class="section" title="Corrupted Windows.edb files"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec85"/>Corrupted Windows.edb files</h2></div></div></div><p>Extracted <code class="literal">Windows.edb</code> files will be corrupted in some cases. If the <code class="literal">Windows.edb</code> file is corrupted, the tool will give you a warning about this and request a recovery first on this file to use it in mapping. Fortunately, the recovery of such a file can be done using the <code class="literal">esentutl.exe</code> Windows native tool with a /p switch:</p><div class="mediaobject"><img src="graphics/image_09_010.jpg" alt="Corrupted Windows.edb files"/><div class="caption"><p>Figure 10: Fixing corrupted Windows.edb file</p></div></div></div></div>
<div class="section" title="Windows RecycleBin"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec56"/>Windows RecycleBin</h1></div></div></div><p>When a user deletes file with the normal deletion process, the file actually doesn't leave the HDD. It will be only marked as deleted on the filesystem, and all the file's metadata and contents will continue existing on the hard disk until it is overwritten by another file's metadata and content. This will allow the user to recover such a file if it was deleted by mistake, for example. The deleted files will be located in what is called a <span class="strong"><strong>Recycle Bin</strong></span> in the Windows OS.</p><p>Usually, the advanced forensics tools will be able to find and view the deleted files if the system still has their metadata and can read them without carving. However, if the investigator only has the recycle bin file and needs to understand which files were deleted, this can be done by analyzing the <code class="literal">Recycle Bin</code> folder.</p><p>The name of the Recycle Bin differs from one version of Windows to another. In Windows versions 95 and 98, the location is under the system partition in a folder named <code class="literal">RECYCLED</code>. From Windows XP until before Vista, the location was the same, but the folder name changed to <code class="literal">RECYCLER</code>. Starting from Windows Vista, the name was changed to <code class="literal">$Recycle.Bin</code>.</p><p>The ordinary user on a live system can browse to the Recycle Bin, but they need to display hidden files and protected system files from the Explorer's view menu. From the Recycle Bin, the user can recover the file to its previous location by simply right-clicking on the file. As long the file exists in the Recycle Bin, it is still recoverable.</p><p>In postmortem analysis, the files won't be shown as in the live system, and it will need more understanding of its structure, which differs from one Windows version to another.</p><div class="section" title="RECYCLER"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec86"/>RECYCLER</h2></div></div></div><p>In the <code class="literal">RECYCLER</code> folder, there are other subfolders named after the users' IDs. In these folders, the deleted files don't have their normal names, but rather they have sequential names: DC1, DC2, and so on. There is another binary file named INFO2, which maps the Recycle Bin files to the real filename, date and time, and the recycler name of the file. In the following screenshot, we can see the structure of <code class="literal">RECYCLER</code> using FTK imager while opening a live Windows XP system:</p><div class="mediaobject"><img src="graphics/image_09_011.jpg" alt="RECYCLER"/><div class="caption"><p>Figure 11: Recycler in Windows XP with FTK Imager</p></div></div><p>As we can see, the files have no names, only sequential DC# names. The INFO2 file has all the names and paths of the actual file mapped to their DC names. We can see that by opening the INFO2 file with any hex editor or by the FTK Imager itself:</p><div class="mediaobject"><img src="graphics/image_09_012.jpg" alt="RECYCLER"/><div class="caption"><p>Figure 12: INFO2 file in Hex</p></div></div><p>The values can be parsed, as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The file sequence number in the Recycler: <code class="literal">Dc1</code></li><li class="listitem" style="list-style-type: disc">Deletion date: Wed, 24 December 2014 12:20:03 UTC. The deletion time can be decoded using the Dcode program, as follows:<div class="mediaobject"><img src="graphics/image_09_013.jpg" alt="RECYCLER"/></div></li><li class="listitem" style="list-style-type: disc">Actual file size in bytes: 929792 =908 KB</li><li class="listitem" style="list-style-type: disc">File location and name:<code class="literal">C:\Documents and Settings\Administrator\Desktop\&lt;FileName&gt;</code></li></ul></div></div><div class="section" title="$Recycle.bin"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec87"/>$Recycle.bin</h2></div></div></div><p>This was used starting from Windows Vista. Instead of the DC naming schema and the INFO2 file from RECYCLER, for each deleted file, there will be an INFO2-like file and another file that holds the content of the file instead of DC files. The content of each deleted file will be found under a file with a name that starts with <code class="literal">$R</code>, and its INFO2-like file will start with $I with the same name, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/image_09_014.jpg" alt="$Recycle.bin"/><div class="caption"><p>Figure 13: Recycle.bin in Windows 8.1</p></div></div><p>If we tried to parse the INFO2-like file and the $I file, we can extract the following information as before but from different offsets:</p><div class="mediaobject"><img src="graphics/image_09_015.jpg" alt="$Recycle.bin"/><div class="caption"><p>Figure 14: $I file opened in Hex</p></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">$I file header: 0x0000000000000001</li><li class="listitem" style="list-style-type: disc">Actual file size in bytes: 14942208 = 14592 KB</li><li class="listitem" style="list-style-type: disc">Deletion date: Mon, 16 February 2015 00:20:37 UTC</li><li class="listitem" style="list-style-type: disc">File location and name:<code class="literal">C:\Users\AymanT\Desktop\SYSTEM</code></li></ul></div></div></div>
<div class="section" title="Windows shortcut files"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec57"/>Windows shortcut files</h1></div></div></div><p>The ordinary user of the Windows system can create a shortcut to any file in the system. The shortcut is like a pointer to a specific file from another location in the filesystem. The user creates this file to achieve easy access to some locations or files in the filesystem.</p><p>The Windows operating system creates shortcut files for the recently opened files by default in the following locations:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">C:\users\&lt;username&gt;\AppData\Roaming\Microsoft\Windows\Recent</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">C:\users\&lt;username&gt;\AppData\Roaming\Microsoft\Office\Recent</code></li></ul></div><p>Windows XP saves the shortcut files at the following location:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">C:\Documents and Settings\&lt;username&gt;\Recent\</code></li></ul></div><p>Windows stores these shortcut files if the user has opened data or media files in the system. It stores the timestamps, the name and location of the original file, and the volume name.</p><p>The importance of these link files is that they won't be deleted even if the original file was deleted from the system specially in the automatically created shortcut files in the 'Recent' folder in the Windows OS. In this case, you can prove that a specific file, maybe an infected pdf file, has been opened in the system under investigation even if the file has been opened from an external storage that is now removed from the system. Also, in this case, you will find the path to this file in the external storage saved in the link file.</p><div class="section" title="Shortcut analysis"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec88"/>Shortcut analysis</h2></div></div></div><p>The filesystem timestamps of the shortcut file can reveal some information about the file itself. We can consider the creation time of the shortcut file as the first time the file was opened and the modification time is the last time the file was opened. If both timestamps are the same, this indicates that the file was opened only once from the location mentioned in the shortcut file:</p><div class="mediaobject"><img src="graphics/image_09_016.jpg" alt="Shortcut analysis"/><div class="caption"><p>Figure 15: Filesystem timestamps for shortcut files</p></div></div><p>To show the contents of the shortcut file in postmortem analysis, we can show it in a live system. However, the content may change to match some paths in the running Windows machine, or we can use a tool, such as Exiftool tool from <a class="ulink" href="http://www.sno.phy.queensu.ca/~phil/exiftool/">http://www.sno.phy.queensu.ca/~phil/exiftool/</a>. Exiftool is a platform-independent Perl library that was designed to read and edit Meta information for a wide variety of files, including photos with different formats and the <code class="literal">.lnk</code> files. All the supported files can be found at <a class="ulink" href="http://www.sno.phy.queensu.ca/~phil/exiftool/#supported">http://www.sno.phy.queensu.ca/~phil/exiftool/#supported</a>.</p><p>We can use the command line version of this tool in opening any shortcut file, and it will display different information, including the original file location and the timestamps of the shortcut file:</p><div class="mediaobject"><img src="graphics/image_09_017.jpg" alt="Shortcut analysis"/><div class="caption"><p>Figure 16: Exiftool opening a lnk file</p></div></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec58"/>Summary</h1></div></div></div><p>So, in this chapter, we discussed different extra Windows artifacts that are important to digital forensics analysis. We discussed the prefetch files, and how they can be used to track a malicious executable that ran within the system. We also showed the Windows tasks that can be used to preserve a malware existence in the infected Windows system. Then, we showed you how to investigate the photos existing in the system even after deletion using the Thumbcache files. By mentioning deletion, we discussed the Recycle Bin and its structure in different Windows OS versions. In the end, we discussed the shortcut or <code class="literal">.lnk</code> files and illustrated how to read their data and their forensic importance.</p><p>As opening a malicious URL or opening malicious attachments are the most common ways to infect a machine, in the following chapter, we will discuss browser forensics and show you how to track user activities and investigate the visited websites using different tools with different browsers. Also, we will explain how to conduct e-mail forensics and investigate received e-mails and their attachments or embedded links.</p></div></body></html>