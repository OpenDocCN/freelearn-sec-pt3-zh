- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Authentication and Authorization Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Assuming you read the previous chapter or already have knowledge about **Application
    Programming Interface** (**API**) reconnaissance, it’s now time to dive deeper
    into pentesting the API. In the previous chapter, we worked through a crAPI challenge
    by accessing data from objects that belong to other users. This data was supposed
    to be protected, but crAPI didn’t do it correctly. This was an authorization flaw.
  prefs: []
  type: TYPE_NORMAL
- en: We need to investigate how APIs establish some of their most fundamental security
    mechanisms, which are how they authenticate and authorize their users. We will
    use the term **AuthN** to refer to **authentication** and **AuthZ** to refer to
    **authorization** just to shorten the words; this is a common practice in the
    literature. Weak AuthN mechanisms can usually be discovered during the initial
    stage of our work, which we covered in the previous chapter. After some interactions
    and analysis, we can discover the data structures an API applies and then spot
    weak AuthZ controls.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn about both topics in more depth, not only analyzing
    how they are presented by APIs but also understanding best practices for configuring
    and implementing them to protect the app environment. Weak or poorly implemented
    AuthN and/or AuthZ guardrails can compromise the whole application, not just the
    API.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Examining authentication mechanisms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing for weak credentials and default accounts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring authorization mechanisms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bypassing access controls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ll leverage the same environment as the one described in [*Chapter 3*](B19657_03.xhtml#_idTextAnchor042).
    In summary, you’ll need a type 2 hypervisor, such as VirtualBox, and the same
    tools we used before, especially the crAPI project.
  prefs: []
  type: TYPE_NORMAL
- en: Examining authentication mechanisms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are various APIs on the internet that work without a need for previous
    AuthN, mainly for read-only operations. A good example of such a use case is the
    **Comprehensive Knowledge Archive Network** (**CKAN**) framework ([https://ckan.org/](https://ckan.org/)).
    It’s an open source project that makes it easier for companies and governments
    to publish data on the internet. Entirely written in Python, the framework has
    a RESTful API with both read and write operations. Since CKAN was designed to
    help *open data* initiatives, having read access to data served by portals supported
    by it is expected.
  prefs: []
  type: TYPE_NORMAL
- en: There is also a fair amount of API endpoints that work without AuthN. In the
    previous chapter, we mentioned the OSINT Framework, a website that curates a list
    of other **Open Source Intelligence** (**OSINT**) websites, tools, and blogs.
    You will find a couple of utilities, such as IP location and geo-location, that
    work on the internet completely for free and without previous AuthN. In such cases,
    only read operations are allowed and the services’ owners should protect their
    backends against inadvertent attempts to access protected data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sooner or later, an API might need an AuthN mechanism. We will explain the
    different AuthN mechanisms one by one. Currently, the following ones are the most
    common when implementing APIs, especially RESTful APIs:'
  prefs: []
  type: TYPE_NORMAL
- en: '**API keys**: Unique identifiers issued to applications for AuthN. Public cloud
    providers may give you one or two such keys to allow you to identify yourself
    (or some code) while interacting with the provider via their APIs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Basic AuthN**: Transmits the username and password in Base64 encoding (not
    recommended for sensitive data). Many people still confuse encoding with encryption.
    It doesn’t matter if the text looks like complete nonsense; there’s no security
    in simply encoding data. Even when basic AuthN happens using an encrypted channel,
    as a TLS connection, this should be avoided at all costs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**OAuth**: Open standard for AuthZ, delegating access without sharing credentials.
    Also called a bearer token, OAuth 2.0 provides a token-based AuthN mechanism.
    The client obtains a token from an AuthZ server and includes it in API requests.
    **OpenID Connect** (**OIDC**) is an AuthN layer built on top of OAuth. OIDC enhances
    OAuth by adding an identity layer, allowing clients to verify the identity of
    the end user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Session tokens**: Used to maintain an authenticated state after initial login.
    They are like temporary keys generated after you log in, stored in your browser
    or website code. They identify you to online platforms without constant logins
    and offer convenience and security benefits.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**JSON Web Tokens (JWTs)**: Self-contained tokens carrying user information
    and claims. This is a compact, URL-safe means of representing claims between two
    parties. They are often used as bearer tokens in AuthN. JWTs are often passed
    in headers or as query parameters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s delve deeper into each of these methods.
  prefs: []
  type: TYPE_NORMAL
- en: API keys
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: API keys are a form of AuthN used to control access to APIs. They are strings
    of characters, usually generated by the API provider, and act as a token to authenticate
    and authorize requests made by a client (an application, user, or another service)
    to the API server. They are unique strings of characters that act as digital identifiers,
    granting applications access to APIs. They serve as a basic AuthN mechanism, ensuring
    only authorized users can access sensitive data or functionality. As mentioned
    before, this is one of the ways public cloud providers choose to establish AuthN
    in their platforms, usually implemented when customers are writing applications
    to interact with their APIs or when using their CLI tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'API keys can be generated as single keys or pairs of keys (more common). When
    presented as pairs, one of the keys represents the login/username whereas the
    other works like a password. The keys are internally associated with an actual
    username. You may ask yourself, what’s the reason for having another pair of credentials
    if the well-known username/password method would sort out the AuthN part? It’s
    simple: while a username can only have a single active password, the same username
    can have multiple attached API keys that could in turn have different permissions
    bound to them (AuthZ). Another difference has to do with the essence of the concept.
    API keys allow *applications* to interact with APIs, and username/password credential
    pairs are meant to be used by *people*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To work, API keys need to be provided in all requests. There are various strategies
    to handle such keys. Some utilities store them in clear-text configuration files
    and load them to memory, whereas others simply create environment variables to
    store the contents. Storage of the keys is exactly the preferred way to discover
    them. Now and then, developers leak them to public repositories or even hardcode
    them in HTML or JavaScript files. You can leverage some tools to help you with
    this step, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**badsecrets** ([https://github.com/blacklanternsecurity/badsecrets](https://github.com/blacklanternsecurity/badsecrets)):
    Library to look for secrets in many different platforms.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Gitleaks** ([https://gitleaks.io/](https://gitleaks.io/)): Maybe the most
    popular tool to find keys in Git-like repositories, directories, and files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**KeyFinder** ([https://github.com/momenbasel/KeyFinder](https://github.com/momenbasel/KeyFinder)):
    Chrome extension to find keys while browsing the web.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Keyhacks** ([https://github.com/streaak/keyhacks](https://github.com/streaak/keyhacks)):
    Public repository with keys discovered in various bug bounty programs. Helps you
    check whether they are valid after the programs have ended. This tool has a ChatGPT
    Plus version: https://chat.openai.com/g/g-JaNIbfsRt-keyhacks-gpt.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mantra** ([https://github.com/MrEmpy/mantra](https://github.com/MrEmpy/mantra)):
    Search for keys in HTML and JavaScript files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Nuclei Templates** ([https://github.com/projectdiscovery/nuclei-templates](https://github.com/projectdiscovery/nuclei-templates)):
    You can use this to test the same keys against various API endpoints.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Secrets Patterns DB** ([https://github.com/mazen160/secrets-patterns-db](https://github.com/mazen160/secrets-patterns-db)):
    A regular expressions database that can be used by other tools, such as TruffleHog,
    to look for key, token, or password patterns in various types of files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**TruffleHog** ([https://github.com/trufflesecurity/truffleHog](https://github.com/trufflesecurity/truffleHog)):
    A Swiss army knife that looks for secrets and keys in many places, including GitHub
    repos, and container images.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some of these tools run as containers, some are libraries you can leverage
    to empower your own code, and some are command-line utilities. You won’t have
    trouble finding other similar tools, including for pentesting distros such as
    Kali Linux. Let’s make a quick test with TruffleHog against some of my personal
    GitHub repositories. First, we’ll use the tool alone and then we’ll add Secrets
    Patterns DB. To leverage Secrets Patterns DB, we first need to use it to create
    a regex JSON patterns file. Let’s run the tool first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s leverage Secrets Pattern DB and run it again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Thankfully, no secret has been found so far. As a side note, after generating
    the `regex.json` file you see in the preceding output, I had issues with a couple
    of the populated regular expressions. Maybe it had to do with some missing update
    on Secrets Patterns DB, since it mentions TruffleHog version 2 but this tool is
    already on version 3.
  prefs: []
  type: TYPE_NORMAL
- en: Basic authentication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is possibly one of the easiest AuthN methods to detect when in place. Every
    time you try to access a website and the browser shows you a dialog box asking
    you for a credential pair, that’s basic AuthN. When a web client accesses a server
    that requires basic AuthN, all requests are provided with an `Authorization` header
    that is filled with the username and the password separated by a colon, all encoded
    in Base64.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example request would be something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'When the server receives it, a simple Base64-decoding operation takes place
    to check whether the credentials are valid. When the AuthN passes, the server
    responds with the request; otherwise, it sends a 401 code for an unauthorized
    operation. Here, there are other factors that should be considered: how securely
    is such a user database stored and handled? Are the credentials even encrypted
    at rest? Is there some kind of hashing or salting mechanism to generate or double-check
    the validity of the passwords?'
  prefs: []
  type: TYPE_NORMAL
- en: And how can you realize when this type of AuthN is being used? Simple. The first
    method is through analyzing the requests. The presence of the `Authorization`
    keyword makes this clear. The responses can also denote its presence. Depending
    on how the server was implemented, you may receive the `WWW-Authenticate` header.
    Finally, if the connection is not protected via TLS, any network inspection tool,
    such as Wireshark, will disclose the AuthN type. Some very old web servers can
    even include the username and password as part of the query string itself.
  prefs: []
  type: TYPE_NORMAL
- en: Some ways to attack basic AuthN environments are through **Man-in-the-Middle**
    (**MiTM**) attacks when no TLS is applied or via brute force, by trying to systematically
    guess the credential pair, or even by applying some social engineering such as
    phishing. In fact, basic AuthN is so unsecure and old that you may not find many
    API endpoints out there running it. Nevertheless, in some searches I carried out
    while writing this chapter, I found some documentation explaining how to configure
    products such as WSO2 ([https://apim.docs.wso2.com/en/3.0.0/learn/design-api/endpoints/endpoint-security/basic-auth/](https://apim.docs.wso2.com/en/3.0.0/learn/design-api/endpoints/endpoint-security/basic-auth/))
    and Apigee’s Edge API ([https://docs.apigee.com/api-platform/system-administration/basic-auth](https://docs.apigee.com/api-platform/system-administration/basic-auth)).
    Daunting…
  prefs: []
  type: TYPE_NORMAL
- en: OAuth
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is possibly one of the most used AuthN mechanisms on the web nowadays.
    OAuth is key to enable you, for example, to log in to your preferred game platform
    without having to create a credential pair by simply leveraging some existing
    external credential, such as the one you use to access your Google, Facebook,
    or Apple accounts, for example.
  prefs: []
  type: TYPE_NORMAL
- en: OAuth has two versions released so far. Version 1.0 was published in 2010 and
    introduced the core concepts of token-based AuthN. It relies on the use of cryptographic
    signatures to secure communications. OAuth 2.0 was published in 2012 and is the
    most recent version since then. It is a significant evolution from OAuth 1.0,
    introducing a more simplified and flexible AuthZ framework. It relies on tokens,
    including access tokens and refresh tokens, to grant access and manage permissions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some key components need to be mentioned:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Resource owner**: The entity that owns the resource, typically the end user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Client**: The application or service that wants to access the user’s resources.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Authorization server**: Manages the authorization process and issues access
    tokens after successful AuthN.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resource server**: Hosts the protected resources (e.g., user photos) that
    the client wants to access.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Access token**: A credential representing the resource owner’s AuthZ.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Refresh token**: A credential used to obtain a new access token when the
    current one expires.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are a couple of ways we can detect when OAuth is being used by an API
    endpoint. The documentation is the first place to go and will save you time. Additionally,
    the presence of `Authorization: Bearer <token>` or `Authorization: Bearer <token
    type> <token>` will also reveal the AuthN type. Finally, you can adopt the generic
    *trial-and-error* method to send some dummy requests with invalid tokens and capture
    the outputs. The crAPI project does not make use of this. Instead, it applies
    something very similar that we will cover in the next section.'
  prefs: []
  type: TYPE_NORMAL
- en: One of the purposes of applying OAuth to a web application is to allow the user
    to leverage **Single Sign-On** (**SSO**). So, by having a single place to store
    the user’s credentials, there’s a single point that needs to be cared about encryption
    at rest at least for the users’ database. Then, by making use of a secure way
    to communicate the credentials, the same person can seamlessly log in to several
    different applications without needing to provide their credential pair every
    time.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the OAuth architecture, the **Identity Provider** (**IdP**) is the element
    responsible for storing and managing the credential pair. The OAuth 2.0 specification
    has a couple of different flows to provide a grant (a way to release an access
    token to the requesting application). When working on the application’s integration
    with the IdP, the developer needs to choose between the different flows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Authorization Code Grant (ACG) flow**: This is commonly the best option since
    it includes a double-checking step. It requires a backend server and does some
    HTTP 302 redirection to a redirection endpoint where some code is provided. The
    app developer needs to confirm that the IdP’s provided endpoint is the same as
    the one that was used by the user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Implicit Grant Flow (IGF)**: Also known as client-side-only flow, this is
    the second most common option. In this case, there is no backend server. The app
    communicates directly with the IdP. User credentials are provided to get an OAuth
    access token. There is no client ID because it can be easily spoofed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Client Credentials Grant (CCG) flow**: This is a niche use case and is rarely
    used. CCG can be used when the client application has resources with a service
    provider that are owned and consumed by the client application itself, and not
    by the end user. With CCG, the client app requests an access token on its own
    behalf, and then subsequently uses that access token to access protected resources
    it needs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Password Grant flow**: This should not be used whatsoever. It’s very simple
    since it only requires that the demanding service informs the username and password
    through a regular POST request. This method is not allowed according to the OAuth
    2.0 Security Best Practices (link in the *Further* *reading* section).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are some OAuth misconfigurations that could lead us to be successful in
    an attack against applications leveraging such a mechanism. The client ID and
    client secret should never be made available to end users. They should be protected
    just like a credential because they could allow a malicious customer to make calls
    to the IdP on behalf of a legitimate app and therefore impersonate the legitimate
    app. For OAuth 2.0, this by itself doesn’t allow for user impersonation because
    the attacker would still need access to user credentials. However, a malicious
    user could build a cloned application that gathers the credentials of users. This
    attack could be even easier by forming clickable links and putting them into a
    forum or email (with those links going back to an attacker’s backend server that
    has been configured with a stolen client ID/client secret).
  prefs: []
  type: TYPE_NORMAL
- en: 'One common attack against an OAuth-powered API is brute force. crAPI does not
    leverage such a mechanism, but let’s see what we can get with some simple Python
    code interacting with the vehicles’ parts website. The code was adapted from Tescum
    ([https://github.com/akimbo7/Tescum](https://github.com/akimbo7/Tescum)) and is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now some explanations. This code would better run with threads as the original,
    but it only worked once on my test system! This aside, the previous version works
    well, and I added a time sleeping line to avoid overloading crAPI’s endpoint.
    During some login activities, I realized all bearer tokens started with `eyJhbGciOiJSUzI1NiJ9.eyJzdWIiOiJ`.
    Hence, this was assigned to a variable. This represents, in part, `{"alg":"RS256"}`
    after decoding from Base64\. The rest of the token is a random sequence of letters,
    digits, and the symbols `-`, `.`, and `_`. Some of the iterations generate less
    probable valid tokens, such as the ones ending with a sequence of two underscores,
    whereas others are more similar. You can run this thousands of times without success
    but eventually, it will succeed. It’s a simple suggestion for a brute-force script.
  prefs: []
  type: TYPE_NORMAL
- en: Some applications have simpler token life cycle management, storing them on
    a local database and never rotating or expiring them. While convenient, since
    it makes the code smaller and easier to maintain, it has inherent security problems.
    Depending on how protected the storage location is, this database could be leaked
    or exfiltrated because of an attack, and then all the application’s users’ credentials
    would be available. Not frequently rotating tokens is also a bad habit because
    some users may choose to locally store them in unsafe ways, which would make them
    available to a handful of client-side attacks, including phishing variations.
  prefs: []
  type: TYPE_NORMAL
- en: 'OAuth is not exactly failproof. In late 2023, a failure in Google’s OAuth implementation
    was disclosed to the public many days after the company was notified and supposedly,
    they did not take any further action to fix it. The problem lies in how Google
    handles email addresses on its accounts, allowing different mailboxes with the
    same domain name to submit the same claim. The explanation is available here:
    [https://trufflesecurity.com/blog/google-oauth-is-broken-sort-of/](https://trufflesecurity.com/blog/google-oauth-is-broken-sort-of/).'
  prefs: []
  type: TYPE_NORMAL
- en: Session tokens
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Session tokens have been a fundamental component of web security, evolving in
    tandem with the growth of web applications. Their history can be traced to the
    need to maintain user states securely across multiple interactions with a web
    server. A session token is a unique identifier assigned to a user upon successful
    AuthN. It serves as a reference to the user’s session data stored on the server.
    Typically, a session token is generated after the user logs in, and it is sent
    back to the client, often as a cookie. Subsequent requests from the client include
    this token, allowing the server to identify the user and retrieve their session
    data. This mechanism helps maintain stateful interactions in stateless HTTP, enhancing
    user experience and security.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a typical scenario, after a user logs in to a web application, a session
    token is generated, securely stored on the server, and sent to the client. This
    token is then included in subsequent requests, enabling the server to associate
    requests with a specific user’s session and deliver personalized content or maintain
    user-specific settings. Detecting the use of session tokens involves inspecting
    the communication between the client and the server. They are commonly found in
    HTTP cookies, identifiable by names such as `session_id` or `access_token`. Additionally,
    examining the headers of HTTP requests may reveal the presence of session tokens.
    Let’s observe how such tokens could be generated with a sample Flask application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'You can interact with this application via Postman or, more simply, with a
    couple of `curl` commands. The app is waiting for a POST request as the login
    and subsequent GET requests. The login body must be provided in JSON format, so
    we need to instruct `curl` accordingly. Also, to guarantee the session cookie
    is correctly stored locally, we use the `--``cookie-jar` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `cookie.txt` file will have contents like these (font size reduced to facilitate
    comprehension):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Session tokens are vulnerable to attacks if not handled securely. Common attacks
    include **session hijacking**, where an attacker steals a user’s session token
    and impersonates them. **Session fixation** is another threat, involving an attacker
    forcing a user to use a specific session token. You can easily discover whether
    some API endpoint is using this mechanism by using the developer mode of your
    preferred web browser. crAPI, for example, does not use it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this implementation we provided, the cookie was signed with the key present
    in the very beginning of the application’s source code. There is a very handy
    tool written in Golang called CookieMonster ([https://github.com/iangcarroll/cookiemonster](https://github.com/iangcarroll/cookiemonster))
    that you can leverage to discover this key. It makes use of a default wordlist
    but also supports your own list, which grants it an interesting power. Let’s test
    it with the cookie that was generated by our sample app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'And *voilà*! The tool also has a convenient feature to resign cookies, which
    you can use to circumvent the API’s AuthZ mechanism by creating your own cookie
    with the corresponding token without having to authenticate first. However, it
    currently only works for Django apps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: JSON Web Tokens (JWTs)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JWTs are one of the most modern ways to authenticate and authorize applications
    and users on the web. They emerged at the beginning of the 2010s and were developed
    as a proposal to the increasing number of applications showing up in the mobile
    arena. This universe has an inherent demand for secure AuthN and AuthZ mechanisms.
    JWTs are different from the previous methods we talked about since they decouple
    the user identity from server sessions. They offer a more secure way to carry
    the necessary data to different systems and applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Every JWT has three parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Header**: Contains metadata about the token, including its format and signing
    algorithm.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Payload**: Holds the actual claims about the user, such as username, roles,
    and permissions. This data is typically encoded in JSON format.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Signature**: A unique cryptographic fingerprint generated using a secret
    key, ensuring the token’s integrity and authenticity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When you log in to a JWT-enabled system, the server generates a JWT containing
    your claims and signs it with a secret key. This token is then sent to your browser
    and securely stored. With every subsequent request, the browser automatically
    sends the token to the server. The server verifies the signature and decodes the
    payload, granting access based on the user’s claims. To detect the use of JWTs
    in an API endpoint, inspect the headers of incoming requests. JWTs are commonly
    transmitted in the `Authorization` header using the `Bearer` scheme, such as `Authorization:
    Bearer <token>`. This is the case with crAPI. Additionally, APIs might include
    information in their documentation or response headers indicating the use of JWTs
    for AuthN.'
  prefs: []
  type: TYPE_NORMAL
- en: There are two tools that you should consider when dealing with JWTs. The first
    one is [https://jwt.io/](https://jwt.io/). The header, payload, and signature
    are highlighted in different colors to facilitate comprehension. Using Postman,
    `curl`, or the developer tools of your web browser, log in to crAPI and obtain
    the token that is generated as a response to a successful AuthN attempt (*Figure
    4**.1*). Store it somewhere.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 – crAPI token generated after a successful login](img/B19657_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1 – crAPI token generated after a successful login
  prefs: []
  type: TYPE_NORMAL
- en: 'Copy the token into the **Encoded** section of the JWT.io website. This will
    reveal all the details about the token, including which algorithm was used to
    generate it. Now, download the second tool, JWT Toolkit v2, available at [https://github.com/ticarpi/jwt_tool](https://github.com/ticarpi/jwt_tool).
    This is a Python script that can carry out several different tasks related to
    JWTs. Let’s see what it says about our recently copied token (part of the command
    was omitted for brevity):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see the token was signed with RS256 and that there are four values in
    its payload: the `sub` (usually, the username), a role, and two timestamps, when
    the token was issued and its expiration date. JWTs may be signed using several
    algorithms, but it’s commonly more seen in one of these fashions: either with
    HS or without HS. The ones starting with HS are the most vulnerable simply because
    they are symmetric signing methods. They use **Hash-Based Message Authentication
    Code** (**HMAC**) combined with a **Secure Hash Algorithm** (**SHA**) hash. Because
    they are symmetric methods, it becomes more difficult to protect and share the
    signing key in scenarios when lots of peers are talking to each other. And, of
    course, once the key is compromised, a token can be forged and the AuthN/AuthZ
    system would not realize the difference from a legitimate token.'
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, RS-like JWTs use the **Rivest-Shamir-Adleman** (**RSA**)
    asymmetric algorithm, where the server signs the token with the private key and
    publishes the corresponding public key to allow the token verification by third
    parties. The system is as secure as the mechanisms applied to protect the private
    key. Obviously, these tokens are more secure, but their generation and verification
    might be slower since an asymmetric algorithm is in place.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, even systems with RS implementations might be vulnerable to JWT attacks.
    There are a couple of ways to test whether there is some flaw. Making use of our
    friend `jwt_tool`, let’s run it against our crAPI deployment just to see whether
    it can find some vulnerability. After recording the AuthZ token you received when
    logging in, type the following (single line). `/workshop/api/shop/products` is
    a crAPI endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: No vulnerabilities were found. The tool was not successful while attacking the
    original token. It suggests using `hashcat` to try some brute-force attack. You
    may try it, but you’ll find out that hashcat complains about the token size, saying
    it’s too big.
  prefs: []
  type: TYPE_NORMAL
- en: 'APIs that implement JWTs may have an endpoint available at `/.well-known/jwks.json`
    or `/jwks.json`. The sole purpose of such endpoints is to publicize the public
    keys used to sign the tokens generated by the API. `http://localhost:8888/.well-known/jwks.json`)
    and copy its contents. It is a JSON structure with a series of keys and values,
    something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We know that the user’s role is `user`, which makes us infer that this is a
    regular powerless persona. Our job now is to forge a token that makes this user
    an admin on crAPI. We can’t use the `-C` option of `jwt_tool` to crack the token
    since it was not signed with an HMAC algorithm. If a regular user’s role is called
    `user`, maybe an admin role is `admin`. We will check whether crAPI is vulnerable
    to the key confusion vulnerability, which consists of deceiving the web server
    by providing HS256 as a signing algorithm and checking whether the server’s token
    verification function is naïve enough to treat the provided public key as the
    HMAC secret. For the next test, you should consider using **Burp Suite** and installing
    the **JWT** and **JWT Editor** extensions. We will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Obtain the server’s public key (which we’ve already got).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Convert the key into an appropriate format.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Forge a new JWT by setting the “alg” header to HS256.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sign the new token with HS256 and use the public key as the symmetric secret.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Just follow this sequence of steps, and you will be good:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Burp Suite and install the previously mentioned extensions. You can do
    this via the **Extensions** | **BApp** **Store** tabs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **JWT Editor** extension and then click on **New** **RSA Key**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On this window, paste the JWKS contents inside the `key` block (when pasting,
    suppress the `keys` part and the surrounding curly brackets).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, select the **PEM** radio button. This will reveal the public key in PEM
    format.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy this text and click the **OK** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Move to the **Decoder** extension, paste the PEM public key, click the **Encode
    as…** button, and choose **Base64**. Copy the results.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return to the **JWT Editor** extension and click on **New Symmetric Key**. This
    will open a window with **Random secret** selected by default.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Just click on the **Generate** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Replace the contents of the `k` parameter with the text you copied from the
    **Decoder** extension.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure your web browser to use Burp Suite as a proxy. By default, Burp Suite
    runs on localhost port `8080`, but this is adjustable. Log in to crAPI with a
    valid username and password. This will generate a valid token. Switch to the `/identity/api/v2/vehicle/vehicles`.
    Select this request, right-click on it, and choose **Send to repeater**. Open
    **Repeater**. You will see the **JSON Web Tokens** tab beside the **Raw** and
    **Hex** tabs. Click on it. Change the algorithm to **HS256** and the role to **admin**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now click on the `/workshop/api/shop/products`, and send the request. It fails
    with an `Invalid JWT Token` message. This probably means the JWT implementation
    of crAPI is not vulnerable to the key confusion vulnerability. However, if you
    change the endpoint to `/identity/api/v2/user/dashboard`, crAPI will return a
    valid response with a JSON structure stating our original role (*Figure 4**.2*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2 – crAPI accepting the forged token for the user dashboard endpoint
    only](img/B19657_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2 – crAPI accepting the forged token for the user dashboard endpoint
    only
  prefs: []
  type: TYPE_NORMAL
- en: Session tokens, bearer tokens, and JWTs serve similar purposes but differ in
    their implementations. Session tokens are typically stored on the server, and
    their corresponding data is stored on the server side. Bearer tokens are self-contained,
    often used in OAuth for API AuthZ, while JWTs are a type of bearer token with
    additional features such as claims and digital signatures, making them versatile
    for secure data exchange. Session tokens are more closely tied to user sessions
    and are often used in web applications to maintain user state.
  prefs: []
  type: TYPE_NORMAL
- en: In essence, while session tokens are specific to user sessions in web applications,
    bearer tokens and JWTs are broader concepts used for various AuthN and AuthZ purposes,
    each offering unique advantages and considerations in different contexts. Understanding
    their characteristics is crucial for secure and effective implementation in web
    development and API security.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will look at how we can discover and implement AuthN
    and AuthZ with weak credentials and default accounts.
  prefs: []
  type: TYPE_NORMAL
- en: Testing for weak credentials and default accounts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When reading this section’s title, as an attentive reader, you probably drew
    a parallel with several routers, access points, network bridges, and an infinite
    number of **Internet of Things** (**IoT**) devices that are out there. Unfortunately,
    depending on the customer’s needs, they are just briefly configured and put to
    work, almost as a “plug-and-play” box. As a matter of fact, some are designed
    to be installed in exactly this way. The problem is that some of those types of
    equipment are somehow meant to be intelligent, which would require more complex
    software running and the **requirement for credentials**. As many users/customers
    simply don’t care about how the product works, a complete universe of possibilities
    opens up to explore default credentials.
  prefs: []
  type: TYPE_NORMAL
- en: The same can happen with APIs. Sometimes, the developer forgets to delete a
    credential pair used just for testing, sometimes it’s hardcoded somewhere in the
    code, which resides in a public repository, and sometimes powerful permissions
    are assigned to these credentials, which is the worst thing that can happen on
    an API. In other scenarios, the default accounts are not there, but the credentials,
    purposefully or not – yes, sometimes there could be malicious intent – are weak
    in the sense of being poorly secure. Simple and/or short passwords, badly implemented
    pseudorandom number generators, small seeds and salts, vulnerable hashing, and
    encryption algorithms, to name a few, are some examples of how weak credentials
    may be created and spread.
  prefs: []
  type: TYPE_NORMAL
- en: Brute-force attacks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is possibly the first topic that comes up in any discussion about application
    credentials. If you search Google for something such as *the most used passwords*
    or *common passwords*, or combinations of such terms, you will be surprised by
    the number of results. In the *Further reading* section of this chapter, you’ll
    find a list of catalogs of passwords, some of them with gigs of size, that can
    be leveraged.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the context of API pentesting, brute-force attacks target AuthN endpoints
    where credentials are required for access. You may automate the process using
    specialized tools that streamline the brute-force process by enabling you to specify
    username and password lists, target endpoints, and define attack parameters. Some
    tools that will be very handy are hashcat, Medusa, and Hydra. Let’s first try
    to use Hydra against crAPI. But first, we need to understand how crAPI handles
    AuthN attempts. Either using Burp Suite or ZAP, or even the developer tools of
    your web browser, open the login page and type in any email address and password.
    crAPI will obviously reject your attempt, but the important part is how the request
    is sent. You will discover something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to respect several of these fields when applying Hydra so crAPI’s backend
    can correctly process our attempts. The application is expecting the input to
    be in JSON format. Likewise, the error output will be in JSON as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, try this with a valid credential pair and observe the corresponding response.
    The answer is the JWT among other parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, pick all the request parameters that were sent as part of the successful
    login activity. You’ll need almost all of them to build the command. Regardless
    of the tool you used to capture the request, you’ll have the following parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Hydra parallelizes the brute-force attempts for the sake of optimizing your
    search. Considering `admin` as a possible username (Hydra replaces `http` with
    `http-get` or `http-post`, depending on the type of verb you want to use), and
    a text file with passwords (`passlist.txt`), run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s explain some of the parameters first:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-l`: Expects you to provide the sole username to test against'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-v`/`-V`: Activates the verbose mode'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-P`: Expects a password list file to be provided'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-s`: If the target is not using one of the default ports (`80` or `443`),
    you need to specify the port'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`http-post`: The Hydra module to use'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Everything inside the double quotes is either part of the headers or the request
    body. The `"/identity/api/auth/login:{\"email\"\:\"^USER^\",\"password\"\:\"^PASS^\"}"`
    part comprises the API endpoint plus the JSON structure crAPI expects to receive.
    Here, `^USER^` is replaced by the login name you provided with `-l`, whereas `^PASS^`
    is replaced with the passwords inside the `passlist.txt` file, one per attempt.
    After this, we specified what is expected to be received with a successful attempt
    (the `S` key). As we can see, when a successful login happens, we get access to
    a lot of data, including a `token` word followed by the corresponding JWT. All
    elements beginning with `H=` are part of the header. Also, observe the backslash
    character (`\`). It serves to escape the immediately following character so Hydra
    can process it rather than thinking it is, for example, the closing quote mark
    of the request or a semicolon separator.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have found nothing so far. Let’s try with a login file instead, where there
    will be several usernames. This file has lines such as `admin`, `administrator`,
    `Administrator`, `admin123`, and `4dm1n`. Of course, the more lines you have in
    both files, the lengthier the task will be. Better to leave this running while
    you do something else. Hydra also allows you to specify how many threads you’d
    like to run at the same time. The following command fits in a single line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Observe the parallel threads (16 by default) running the attack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The tool managed to find a valid username/password pair:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Bear in mind that methods like the one used by Hydra can be detected by the
    API backend itself or more easily by some other protection layer, such as a WAF.
    The tool generates thousands or even millions of requests to the target endpoint,
    which could be measured and blocked by API endpoints that have rate-limiting protections.
    Let’s check, for example, how a crAPI log entry looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: To circumvent this, you should run multiple instances of Hydra from different
    IP addresses. Either launch several containers, preferably with separate network
    segments, or create a controlled environment with spoofed IP addresses. Of course,
    never spoof valid IP addresses on the internet. We are security professionals,
    not criminals.
  prefs: []
  type: TYPE_NORMAL
- en: Other valid tools for brute-force explorations are Medusa and ncracker. However,
    these were not as successful on the tests that I conducted to write this chapter,
    or they did not have the same kind of performance as Hydra. You must never forget
    the wordlists when running these types of attacks. Combining them and mixing and
    matching them are all valid ways of getting closer to the credentials some API
    endpoint apply.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s a very interesting utility called **Common User Passwords Profiler**
    (**CUPP**; [https://github.com/Mebus/cupp](https://github.com/Mebus/cupp)). It
    facilitates downloading big password lists from the internet. It also has an interactive
    mode that creates lists based on questions it asks you about the target/victim.
    An advantage is that this Python code does not require any third-party module,
    allowing you to explore it right after downloading it. Let’s carry out a test
    with crAPI. We’ll download default usernames and passwords from AlectoDB (currently
    consolidated under [https://github.com/yangbh/Hammer/tree/master/lib/cupp](https://github.com/yangbh/Hammer/tree/master/lib/cupp)).
    Clone CUPP’s repository and type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'You just got the two text files with usernames and passwords. You’ll see more
    about this topic in [*Chapter 6*](B19657_06.xhtml#_idTextAnchor102), *Error Handling
    and Exception Testing*, but there’s another tool called `Wfuzz` ([https://github.com/xmendez/wfuzz](https://github.com/xmendez/wfuzz))
    that you can install in multiple ways and helps with carrying out brute-force
    attacks leveraging password lists. I installed it through `pip` and tested it
    against crAPI with the just downloaded usernames and passwords. The results follow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Observe the request numbers in the `ID` column. They are not in order. That’s
    because `Wfuzz` organizes them in different threads so multiple requests can be
    sent at once. We didn’t manage to find a match on this attempt, but this does
    not reduce the tool’s effectiveness. You can combine it with other wordlists.
    `Wfuzz` is very convenient as it attempts multiple combinations of usernames and
    passwords against the target and shows all successful attempts. Of course, if
    you already know either the username or the password, this will tremendously reduce
    the program’s effort. A reference to a list of links can be found at the end of
    the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Common credentials and default accounts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You may use the knowledge you acquired in the previous chapter, on topics such
    as OSINT techniques and other enumeration tips, to get your hands on some default
    API credentials. The API documentation itself is a valid source for default credentials.
    In your pentesting endeavors, you may discover a website leveraging a backend
    with a marketplace API provider. Some providers have default credentials, including
    administrative ones, for their products. Hence, by either inspecting the documentation
    or other active or passive methods, you may discover a couple of credential pairs.
  prefs: []
  type: TYPE_NORMAL
- en: Using the same approach as the previous sub-section, start by googling *default
    passwords* or *common passwords*. A list generated in 2024 is available at the
    end of the chapter. Some system administrators still run their API backends with
    default admin usernames such as `admin` or `administrator`. Even websites running
    popular `admin` or `administrator` would be the superuser’s username. Localized
    versions of it, such as `administrador`, are also valid.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, you can use Hydra, Medusa, or Burp Suite, with its `repeater` or
    `intruder` features, or even do this via your web browser, but you can also automate
    your effort by crafting a script with a simple loop such as the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the `wordlist` filename is put inside the `$passwords`
    variable. Then, I set the `$MAXWAIT` variable to `2`. Inside the `while` loop,
    I executed the `curl` command and appended its output inside the `output.txt`
    file. Then, I put the code to sleep for a random number of seconds between 0 and
    2\. The `$RANDOM` variable is built into Bash and returns a random integer between
    0 and 32,767\. That integer is then divided by `$MAXWAIT` and the remainder is
    the number of seconds to put the script to sleep. This is just to avoid being
    throttled by some API rate-limiting control. The script finished with the end
    of the `while` loop reading the `wordlist.txt` file line by line.
  prefs: []
  type: TYPE_NORMAL
- en: Doing the opposite is also valid, and is a technique called **password spraying**.
    It consists of testing a single password or a small set of passwords against multiple
    user accounts. It is quite useful for applications that generate the same initial
    password for all users and suggest users change the password after the first login.
    Solely relying on the human factor is not exactly a security best practice. To
    carry out password spraying, there are some tools, such as CrackMapExec, Patator,
    and Metasploit (which is an umbrella tool with tons of plugins). Let’s consider
    Patator for this task.
  prefs: []
  type: TYPE_NORMAL
- en: If you are following this chapter after having installed the lab environment
    mentioned in [*Chapter 2*](B19657_02.xhtml#_idTextAnchor028), getting Patator
    running on top of Ubuntu is as straightforward as running `sudo apt-get update`;
    `sudo apt-get install patator`. Just be mindful that this is a package with lots
    of dependencies. When I wrote this chapter, the software and its dependencies
    were consuming around 300 MB of disk space.
  prefs: []
  type: TYPE_NORMAL
- en: 'After digging a lot and discovering that version 0.9 of Patator (the one used
    to write this chapter) seems to not correctly handle HTTP request headers, I ended
    up with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Just to keep things consistent, the preceding command was typed on a single
    line. Now, let me explain to you all the parameters that are not self-explanatory:'
  prefs: []
  type: TYPE_NORMAL
- en: '`http_fuzz`: Patator has a considerable number of modules. This is the one
    to play with HTTP targets. As we were trying to authenticate against crAPI (an
    HTTP REST API implementation), it is the best choice.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`method=POST`: We need to tell `http_fuzz` which HTTP method we will use. To
    authenticate, crAPI expects the request to be sent using POST.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`resolve=domain:127.0.0.1`: This parameter needed to be added because Patator
    was getting confused with the URL. Since my crAPI implementation is running on
    my localhost, I’m just telling Patator that, when resolving the hostname, consider
    it as `127.0.0.1`. I know, it’s nonsense, but it was the way I found to make Patator
    work with my localhost URL.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`autourl_encode=0`: Instructs Patator to encode all the body’s characters before
    sending the request. This is incredibly useful especially when you are dealing
    with non-alphanumeric characters, such as the ones used by the JSON structure
    explained in the next point.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`body=''{"email": "FILE0", "password": "Admin!123"}''`: This is the JSON structure
    representing the login. I put the default crAPI admin password for the sake of
    showing you what happens when the tool is successful. `FILE0` indicates that the
    email will be replaced with the lines of a file that will be later specified.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0=./userlist.txt`: This matches the previous `FILE0` item. The `userlist.txt`
    file contains all usernames, one per line, taking the role of the login credential.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`header=@fuzzerheader.txt`: The `fuzzerheader.txt` file contains the required
    headers for the crAPI login request to work. This will change depending on how
    your target API endpoint was written and, as we discussed before, you need to
    enumerate the endpoint first so you can get to know its details.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `userlist.txt` file contents are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'And the `fuzzerheader.txt` file has the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Observe the columned output of the Patator command previously executed. Each
    line corresponds to one of the combinations of username and password. In this
    example, a single password was considered, but you can alternatively use another
    text file (such as a wordlist) to feed the tool. In the `code` section, you can
    see the HTTP code sent as a response. The `size:clen` column shows the number
    of characters received in the response: the total size and the content length,
    respectively. The latter is the one that interests us. Time is self-explanatory.
    `Candidate` assumes each combination of username and password. If we were trying
    multiple passwords, the lines would be something such as `username:password`.
    `Num` corresponds to the combination number. Observe Patator does not necessarily
    follow the order in the `userlist.txt` file. Although `admin@domain.com` is on
    the first line, it shows up as on the third output line. Finally, the message
    with the code again.'
  prefs: []
  type: TYPE_NORMAL
- en: We are looking for the 200 codes, which denote the attempt was successful. In
    our case, it happened on the fourth output line, where `size` was substantially
    bigger compared to the other lines. Nevertheless, the size difference alone does
    not state anything at all. You should focus on all lines with the `200 response`
    code. Be warned that false positives can also happen. Hence, separate all usernames
    and passwords whose attempts seem to have been successful and investigate more.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will go through the AuthZ mechanisms of an API.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring authorization mechanisms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, we’ve played with the AuthN part, but that’s just part of the party. After
    gaining access to the system, we need to have enough power to do a number of things
    a regular user could not do. However, it’s worth mentioning that even a regular
    user may have read-only access to sensitive data or other users’ data, depending
    on how the API’s AuthZ controls were implemented.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exploring AuthZ mechanisms during API pentesting is crucial for identifying
    potential security vulnerabilities and ensuring that only authorized users or
    clients can access protected resources. AuthZ mechanisms define the rules and
    policies that govern access to API endpoints, data, and functionalities, and testing
    these mechanisms helps assess their effectiveness in enforcing access controls
    and preventing unauthorized access. Before going further into how we can explore
    API AuthZ mechanisms, we need to understand what they are. AuthZ mechanisms are
    controls that specify what exactly a user can and cannot do once they are authenticated.
    The most used methods as of the time of writing are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Role-Based Access Control (RBAC)**: Each valid user in the system is assigned
    one or more roles that in turn dictate which actions are allowed. Depending on
    how the system was designed, some actions can also be explicitly denied. Once
    such a mechanism is detected, you can try to discover which roles exist and craft
    a way to bypass/invalidate the control. A real-world example would be a company
    whose employees belonging to the human resources department (role) would have
    access to payroll data whereas all others (excluding the board, of course) wouldn’t.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Attribute-Based Access Control (ABAC)**: Combines parameters or attributes
    that are assigned to the user, the resource they are trying to access, and even
    the environment where the resource is physically or logically defined or located.
    This is a control usually applied by public cloud players, where such attributes
    are often called “labels” or “tags” (not to be confused with smart tokens or tags).
    They comprise key-value pairs where the cloud’s sysadmin can assign them to different
    users and resources to better group the assets. Permissions can be set based on
    such tags. You can try to manipulate or inject attributes to gain unauthorized
    access. A real-world example would be contractors that do service on an institution.
    Once they present themselves wearing the uniforms (tags) their companies provide,
    they are granted access to areas assigned to their contracting companies. However,
    each contractor can only access the areas designated for the company they were
    hired from. When another contractor working for the same company is eventually
    added or replaces a previous one, the new contractor must receive an analogous
    uniform. By wearing another contractor’s uniform, you may enter their company’s
    area possibly unnoticed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**OAuth scopes**: We already covered what OAuth is and the power it provides
    to an API. In this context, scopes define the specific access levels or resources
    a user is authorized to request. A real-world example could be a military facility,
    where officers of different ranks would work together. Nevertheless, the context
    of information a major receives is higher than a captain’s, which is higher than
    a lieutenant’s, and so on and so forth. Impersonating an officer (bypassing a
    context) would give you access to restricted/privileged information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s look at each of them in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Role-based access control
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s suppose the system you are testing and trying to explore applies such
    a mechanism. crAPI does that, right? Do you remember when we were forging tokens
    pretending to have the `ROLE_ADMIN` role instead of `ROLE_USER`?
  prefs: []
  type: TYPE_NORMAL
- en: In the realm of API security, RBAC plays a crucial role in safeguarding access
    to sensitive data and functionalities. This approach grants permissions based
    on predefined roles assigned to users or groups, ensuring that individuals only
    have the level of access necessary for their designated tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'RBAC operates on three core components:'
  prefs: []
  type: TYPE_NORMAL
- en: '`admin`, `editor`, `reader`, or `guest`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Users**: Individual entities interacting with the API, typically identified
    through usernames, IDs, or other unique identifiers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Permissions**: Granular actions users can perform on API resources, such
    as **Create, Read, Update, or** **Delete** (**CRUD**).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Users first authenticate themselves with the API, providing credentials such
    as usernames and passwords or tokens. Based on the authenticated user, the system
    determines their assigned role(s). When a user requests access to a specific API
    resource, the system verifies whether their associated role(s) possess the necessary
    permissions for the requested action. If the user’s role has the required permission,
    access is granted; otherwise, it’s denied, and an appropriate error message is
    returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some benefits of RBAC are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Granular access control**: Enables fine-grained control over API access by
    tailoring permissions to specific roles.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reduced complexity**: Simplifies access management by grouping similar permissions
    under roles.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Improved security**: Minimizes the risk of unauthorized access by restricting
    actions based on user roles.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some examples of public APIs using RBAC include cloud storage APIs where granting
    read/write access to specific folders or files is based on user roles; social
    media APIs that allow users to post, edit, or delete content based on their account
    type (admin, moderator, or regular user); and e-commerce APIs that control access
    to product information, order management, and pricing data based on user roles
    (customer, vendor, or administrator).
  prefs: []
  type: TYPE_NORMAL
- en: Attribute-based access control
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ABAC goes further into the way access control works. Instead of simply relying
    on roles and their permissions, it offers a more nuanced and adaptable approach
    specifically suited for complex API environments. For example, healthcare APIs
    control access to sensitive patient data based on user roles, data sensitivity
    level, and access location. Financial APIs grant AuthZ for financial transactions
    based on user identity, account type, transaction amount, and time of day. IoT
    APIs enable secure device access and data exchange based on device type, location,
    and specific permissions associated with the device.
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides relying solely on predefined, and sometimes custom, roles, ABAC evaluates
    various attributes associated with different entities involved in an access request:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Subject**: The user or entity requesting access (e.g., username, IP address,
    or device type).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resource**: The API resource being accessed (e.g., data object or endpoint
    URL).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Action**: The operation being attempted (e.g., read, write, or delete).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Environment**: Contextual factors such as time, location, or specific conditions
    (e.g., emergency access).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Attributes**: Additional data points associated with any of the preceding
    entities (e.g., user department, resource sensitivity level, or time of day).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When a user interacts with the API, the system gathers relevant attributes from
    all involved entities. After that, the system evaluates predefined access control
    policies against the gathered attributes. These policies define conditions under
    which specific actions are permitted or denied. Finally, based on the policy evaluation
    outcome, access is either granted or denied.
  prefs: []
  type: TYPE_NORMAL
- en: Some benefits of applying ABAC include granular and flexible control, which
    enables highly granular access control by considering various attributes beyond
    just roles, dynamic and adaptable policies that can be dynamically adjusted based
    on changing attributes, making it suitable for complex and evolving environments,
    and reduced misconfigurations, which, by focusing on specific attributes and conditions,
    mitigates the risk of misconfigured roles.
  prefs: []
  type: TYPE_NORMAL
- en: '**Amazon Web Services** (**AWS**), for example, has a specific API for their
    resource group tagging, allowing a customer or partner to interact with their
    cloud resources by creating, attaching, updating, or deleting tags accordingly.
    Those tags can then be checked against an AWS IAM policy further on the cloud
    access control policy.'
  prefs: []
  type: TYPE_NORMAL
- en: OAuth scopes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: OAuth scopes are somewhat like attributes in ABAC-backed APIs in the sense that
    they also apply labels. They act as mechanisms that define the specific permissions
    an application can request and, consequently, the level of access it receives
    to an API’s resources. OAuth scopes are essentially strings that represent specific
    sets of permissions associated with an API. When an application requests access
    to an API using OAuth, it specifies the desired scopes within its AuthZ request.
    The AuthZ server then evaluates these requested scopes against the application’s
    registered permissions and grants an access token with the corresponding level
    of access.
  prefs: []
  type: TYPE_NORMAL
- en: 'From this, we can derive at least the following immediate benefits of leveraging
    OAuth scopes for an API:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Granular control**: Enables precise control over API access by allowing applications
    to request only the specific permissions they require.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reduced risk**: Mitigates the risk of unauthorized access by limiting the
    scope of an application’s access token.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Improved transparency**: Provides clear visibility into the permissions granted
    to each application, enhancing accountability and trust.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Numerous different scopes can be created on an API to fulfill specific needs.
    Some types of scopes an API can leverage are **read-only** (allows an application
    to read data from specific API resources but not modify or delete them), **write-only**
    (grants an application the ability to create or update data within the API but
    not read existing information), **full access** (provides comprehensive access
    to all API resources, including read, write, and delete capabilities), **user-specific**
    (defines permissions based on the user associated with the application, enabling
    granular control within specific user contexts), and **resource-specific** (limits
    access to specific resources within the API, allowing applications to access only
    the data they need).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following Python code block shows some dummy examples of handling OAuth
    scopes on an API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The last portion of the code shows an easy way to leverage Flask’s OAuth library.
    Flask is a framework that makes it easier to build Python backend applications.
  prefs: []
  type: TYPE_NORMAL
- en: Some widely known APIs that use OAuth scopes include Google Drive, GitHub, X
    (previously Twitter), Dropbox, and Facebook/Meta.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s learn how to circumvent access controls.
  prefs: []
  type: TYPE_NORMAL
- en: Bypassing access controls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To be successful in bypassing access controls, you have to either explore misconfigurations
    or lack of configurations in APIs, or even some backend logic flaw. All mentioned
    AuthZ mechanisms are strong, but the way they were implemented on an API endpoint
    may make them useless, or at least vulnerable to some attempts.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the sake of illustrating this, let’s propose three different scenarios
    where you have, respectively, RBAC, ABAC, and OAuth scopes in place. Let’s understand
    how some exploits could be exercised. For RBAC, suppose you have an API that manages
    employee data, with different roles such as `employee` and `admin`. The `admin`
    role has access to all employee records, while the `employee` role can only access
    their own record. However, the API doesn’t properly validate the user’s role during
    certain operations. In other words, the following are the case:'
  prefs: []
  type: TYPE_NORMAL
- en: As an employee, you’re only supposed to access your own data. However, you notice
    that the API doesn’t check your role when updating your personal information.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By modifying the API request to impersonate an admin user, you’re able to gain
    access to and modify any employee’s data, bypassing the intended RBAC controls.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An excerpt of some vulnerable Python code is shown here. Observe the logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The code simply fetches the role provided by the requestor from the headers
    without further checking whether such a claim is legitimate. Hence, in this case,
    once you submit a request with `user_role` as `admin`, you’ll receive full privileges
    on the API.
  prefs: []
  type: TYPE_NORMAL
- en: Now, moving on to ABAC, consider an API for an online banking application where
    access to financial transactions is controlled based on the user’s account type
    (e.g., standard or premium) and the transaction amount. However, due to a flaw
    in the attribute validation logic, an attacker can manipulate the transaction
    amount attribute to execute high-value transactions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Observe an example of vulnerable code written in Python to represent this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `initiate_transaction` endpoint is intended to restrict
    high-value transactions for standard account types. However, the code fails to
    properly validate the transaction amount, allowing an attacker to manipulate the
    amount and bypass ABAC controls. Observe that, using an analogous approach to
    RBAC, the validation code is simply relying on what is claimed by the requestor.
    In this case, should you send any account type different than `standard`, you
    would be able to process the transaction regardless of its amount.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, let’s see a way that would make OAuth scopes vulnerable to exploitation.
    Suppose you have an API that provides access to user profile information, with
    different scopes such as `read_profile` and `write_profile`. However, due to a
    misconfiguration in the OAuth server, the access token issued to a user contains
    unintended scopes, enabling unauthorized access to sensitive resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at the vulnerable code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, the `get_profile` endpoint is supposed to restrict access
    to users with the `read_profile` scope. However, the code incorrectly assumes
    that the access token scopes are trusted without proper validation, allowing an
    attacker to manipulate the token and bypass OAuth scope restrictions. In summary,
    if as part of the AuthZ token you send a claim for a privileged scope, you would
    achieve success with this backend code in place. There are two other topics that
    we can’t forget to mention. They are known by their acronyms: BOLA and BFLA.'
  prefs: []
  type: TYPE_NORMAL
- en: Broken Object Level Authorization (BOLA)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This consists of a security vulnerability that is present when an API does not
    correctly apply AuthZ verifications before effectively allowing access to objects
    and resources. This usually happens when an API solely relies on user input (such
    as object IDs) without checking whether the user providing them actually has permission
    to access such IDs. You can exploit this by manipulating inputs to achieve unauthorized
    access to data.
  prefs: []
  type: TYPE_NORMAL
- en: 'To exemplify this, let’s consider a scenario where an API endpoint retrieves
    user details based on a user ID. If the endpoint does not check whether the authenticated
    user has access to the required ID or not, a pentester can provide any valid user
    ID to get other users’ data. This situation may be quite dangerous when the vulnerable
    API (or the application behind it) handles sensitive data, such as financial or
    health records. When BOLA is present on an application or API code, you can enumerate
    object IDs and access unauthorized data. Observe the following Python code, which
    has a BOLA vulnerability:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Any authenticated user can access other users’ details by simply providing
    their ID. Now observe an example of a change that removes the vulnerability:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Observe the `get_user_by_id` function returning `None` if an invalid user ID
    is provided. Let’s move on to BFLA next.
  prefs: []
  type: TYPE_NORMAL
- en: Broken Function Level Authorization (BFLA)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This occurs when an API or the application behind it does not correctly apply
    AuthZ checks to its functions and actions, which allows attackers to run functions
    or access resources they don’t have permission to. This vulnerability usually
    shows up when there are no access control policies or they lack sophistication,
    and the application trusts user roles or privileges without properly verifying
    them before allowing function executions.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider an API that provides functionalities not properly restricted
    to authorized users. If a pentester with lower permissions can run tasks such
    as creating or changing users, the whole API security may be compromised. Even
    new administrators could be created by such a pentester. Observe the following
    Golang code, which uses BFLA:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Any user could access the `/admin/create_user` endpoint to create a new user.
    Now look at a suggestion of code to remove the vulnerability:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: You just learned how to identify and fix, with straightforward code changes,
    one of the most dangerous vulnerabilities that affect APIs. The `getCurrentUser`
    and `requireAdminRole` functions were implemented to reinforce protection on the
    AuthZ logic.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covered additional topics relating to an API pentest. We have looked
    at both the AuthN and AuthZ mechanisms, their details, and ways they can present
    themselves as vulnerable enough to be exploitable. You also learned about weak
    API credentials and default accounts, along with techniques to discover and leverage
    them as part of your attack. These constitute a very important part of any API
    pentest since other stages, such as persistence, lateral movement, and data exfiltration
    all depend on the successful exploitation of AuthN and AuthZ.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, which also starts *Part 3* of this book, you will be introduced
    to injection attacks and validation testing. The damage such attacks can cause
    can be massive and successfully protecting against them by implementing a correct
    user input validation is key. See you there!
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'CKAN, a Python framework to support open data websites: [https://ckan.org/](https://ckan.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Open Data Handbook, explaining basic concepts around open data: [https://opendatahandbook.org/guide/en/](https://opendatahandbook.org/guide/en/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'OAuth 2.0 Security Best Practices: [https://datatracker.ietf.org/doc/html/draft-ietf-oauth-security-topics](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-security-topics)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'More OAuth grant flows and some graphics: [https://frontegg.com/blog/oauth-grant-types](https://frontegg.com/blog/oauth-grant-types)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Exploring CookieMonster: [https://ian.sh/cookiemonster](https://ian.sh/cookiemonster)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'RFC 7517, which defines JSON Web Keys: [https://datatracker.ietf.org/doc/html/rfc7517](https://datatracker.ietf.org/doc/html/rfc7517)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'JWT Cracker, a tool written in C to crack JWTs with brute force: [https://github.com/brendan-rius/c-jwt-cracker](https://github.com/brendan-rius/c-jwt-cracker)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A curated list of tools and lists for cracking systems: [https://github.com/n0kovo/awesome-password-cracking](https://github.com/n0kovo/awesome-password-cracking)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Top 200 Most Common* *Passwords*: [https://nordpass.com/most-common-passwords-list/](https://nordpass.com/most-common-passwords-list/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Mentalist, a tool to create your own password lists: [https://github.com/sc0tfree/mentalist](https://github.com/sc0tfree/mentalist)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Patator – a brute-force attacker with fuzzing and password spraying features:
    [https://salsa.debian.org/pkg-security-team/patator](https://salsa.debian.org/pkg-security-team/patator)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*AWS Resource Group Tagging API* *Reference*: [https://docs.aws.amazon.com/resourcegroupstagging/latest/APIReference/overview.html](https://docs.aws.amazon.com/resourcegroupstagging/latest/APIReference/overview.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Part 3: API Basic Attacks'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you have been introduced to basic attacks in *Part 2*, it’s time to
    move on and increase your knowledge of more types of attacks. In this part, you
    will learn about techniques that you must not ignore while targeting APIs. We
    will discuss adapted SQL and NoSQL injection attacks, the problems caused by bad
    user input sanitization, what happens when an error is not correctly handled,
    and finally, the feared denial-of-service attack. You will also be presented with
    some ways to block or at least reduce the chances of such attacks being successful.
  prefs: []
  type: TYPE_NORMAL
- en: 'This section contains the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 5*](B19657_05.xhtml#_idTextAnchor078), *Injection Attacks and Validation
    Testing*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 6*](B19657_06.xhtml#_idTextAnchor102), *Error Handling and Exception
    Testing*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 7*](B19657_07.xhtml#_idTextAnchor110), *Denial of Service and Rate-Limiting
    Testing*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
