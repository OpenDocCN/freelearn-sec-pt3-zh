- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Basic Needs in My Build Chain
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Security begins at the design table. True. Yet it is enhanced and comes alive
    in the build chain. It is here where we will implement and validate our security
    policies, test, scan our prototypes, and leverage all the informational sources
    at our disposal to ensure that our product is as secure and robust as it possibly
    can be, long before it sees its first customer.
  prefs: []
  type: TYPE_NORMAL
- en: Here is truly where all the magic happens (or sadly, it doesn’t if you choose
    to ignore it). In the previous chapters, we have addressed countless design factors
    that have led up to your conceptual initial design criteria. From here and forward,
    we will be working hands-on to ensure those embedded systems’ best practices are
    adhered to along with the application of security measures.
  prefs: []
  type: TYPE_NORMAL
- en: Here’s a non-exhaustive sample of what may be in your company’s build environment.
    These tools should be accessible only to those working directly on this product
    or supporting production releases. From secure repositories to scanning tools
    and everything else in between, these critical tools will greatly contribute to
    the success of your product’s lifecycle.
  prefs: []
  type: TYPE_NORMAL
- en: 'The many tools you will need are vast and include (but are not limited to)
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Local repositories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Source code control systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Project management systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customer support systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build automation systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compliance and security scanning systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update infrastructure for deployed appliances
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most importantly, a comprehensive set of test systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here’s a perspective of systems and tools needed for a successful build chain
    infrastructure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – Example systems in a secure build and support chain](img/B22104_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.1 – Example systems in a secure build and support chain
  prefs: []
  type: TYPE_NORMAL
- en: Grab your favorite beverage. Clear your calendar. Grab some USB thumb drives
    and let’s go to the lab. I invite you to join me on this journey, roll up your
    sleeves, and get your keyboard thumping. Are you ready to start practicing how
    to secure your software supply chain?
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following sections, I will address key concepts and then walk you through
    some detailed exercises:'
  prefs: []
  type: TYPE_NORMAL
- en: Software supply chain control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automation and tool integration – a brief overview
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security scanning, testing, and remediation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manifest and configuration tracking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update control mechanisms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s get started.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you’d like to follow along with the exercises within this chapter, you will
    need at least two machines (physical or virtual) running the same distribution
    of Linux. In the exercises themselves, I will call out which distribution I have
    used for the exercise and any other pertinent configuration information. For the
    purposes of this book, it is assumed that you and your team have a substantial
    level of experience with whichever solution(s) for source code control/management.
  prefs: []
  type: TYPE_NORMAL
- en: 'This book itself has its own GitHub page and repository. Many of the exercises
    and example configuration files can be found there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/The-Embedded-Linux-Security-Handbook/tree/main/Chapter05/exercises](https://github.com/PacktPublishing/The-Embedded-Linux-Security-Handbook/tree/main/Chapter05/exercises)'
  prefs: []
  type: TYPE_NORMAL
- en: Software supply chain control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a solution provider, it is your responsibility to know, track, and maintain
    records of each component that goes into your solution. If your solution falls
    under any sort of government or industry compliance regulations, this requirement
    may have dire consequences if not maintained.
  prefs: []
  type: TYPE_NORMAL
- en: This is a situation where again, I recommend leveraging an enterprise Linux
    distribution. Their software sources are secure, from source code to compilation
    to packaging and, ultimately, its delivery to you. They maintain great records.
    They have to! These vendors can provide your team with what we call a **Software
    Bill of Materials** (**SBOM**). This is a complete listing of the components and
    their versions. Additionally, it is an attestation that they use secure, tested,
    and validated software.
  prefs: []
  type: TYPE_NORMAL
- en: There are several commercial solutions available on the market. Companies like
    Aqua, Synopsys®, and Red Hat® (just to name a few) create some excellent comprehensive
    solutions to securing the software pipeline. There are lots of viable options
    for your team to consider in this aspect, so let’s move onto the next section,
    Source code control.
  prefs: []
  type: TYPE_NORMAL
- en: Source code control
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Intellectual property, that very special code that makes your solution oh so
    special, is meant to be protected. Sometimes, at virtually all costs.
  prefs: []
  type: TYPE_NORMAL
- en: There are many excellent commercial and open source solutions for this. Oftentimes,
    these solutions are integrated with other solutions that may provide services
    for bug tracking, agile project management, software packaging solutions, etc.
    Regardless of which source code control system your organization has chosen, I
    recommend ensuring that all feasible steps to minimize access and secure the platform
    are taken. Protect your company’s intellectual property. Let’s move on to other
    parts of a good software supply chain.
  prefs: []
  type: TYPE_NORMAL
- en: Automation and tool integration – a brief overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: No DevOps shop can be complete without a substantial level of automation throughout
    the operation. Just like with source code control, there are many excellent commercial
    and open source solutions for this. Red Hat Ansible®, SaltStack®, Puppet Enterprise®,
    Chef®, Ansible AWX®, and Puppet Bolt® are the most commonly used.
  prefs: []
  type: TYPE_NORMAL
- en: Other products often found in a build chain may also include a significant level
    of automation. One such example is the platform offered by a company called CloudBees.
    Their Jenkins product has been at the leading edge of DevOps shops globally. This
    is just one example in a market of many solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Automation is an area that I can rant about for hours on end. That is definitely
    not what I intend for this brief section. The message I want to impart to you
    here is that automation, when done correctly, can ease the burden of many cumbersome
    and menial tasks that can be error-prone when humans are doing them repetitively.
    Risk mitigation and efficiency, pure and simple.
  prefs: []
  type: TYPE_NORMAL
- en: Whichever tool (or tools) your team selects for the project, I recommend their
    usage and efficiency be reviewed in the same manner you would review any other
    agile process at the end of a sprint. There is no wrong selection here, except
    in the case of not leveraging some sort of automation at all in your build, test,
    and support chain. Don’t just find something. Find what works best for your budget
    and your team’s skills, and can be leveraged easily within the timeframes you
    are allotted for the project.
  prefs: []
  type: TYPE_NORMAL
- en: We will definitely be covering much more about tools and integration in later
    chapters, so let’s move on.
  prefs: []
  type: TYPE_NORMAL
- en: Security scanning, testing, and remediation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By using **Free Open Source Software** (**FOSS**), your team can achieve many,
    if not all, aspects of your product’s lifecycle. Yes, I am definitely an open
    source advocate and have been since the late 1990s. There’s a good reason, especially
    in the Linux world. It’s the portability of skills.
  prefs: []
  type: TYPE_NORMAL
- en: Virtually all Linux distributions share about 90% of the same available commands
    and utilities. What they don’t share, that other 10%, is what makes those distributions
    unique, scalable, or more secure than the others. For discussion’s sake, I want
    to focus on that 90% – the common stuff.
  prefs: []
  type: TYPE_NORMAL
- en: When at a command prompt in Linux (regardless of distribution), there’s a baseline
    of commands we all come to know and rely upon. Granted there are variations out
    there, but the most common tools are what I am focusing on here.
  prefs: []
  type: TYPE_NORMAL
- en: The first command line tool I want to bring up is **Nmap**. Nmap has a GUI counterpart
    called **Zenmap** (or in older distributions, **nmap-fe**). It is commonly found
    in virtually all distributions of Linux and on all platforms. Why? Because it
    is great at finding out which ports are open and even doing something called **OS
    fingerprinting** (i.e., figuring out what operating system the host is using).
  prefs: []
  type: TYPE_NORMAL
- en: So, let’s take a quick look at Nmap and Zenmap in action in a quick hands-on
    exercise.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise – executing a network port scan
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we will be running detailed network port scans on some test
    machines. We’ll be using two similar tools. The first tool, called Nmap, is an
    open source command-line port scanning tool. The second tool, called Zenmap, is
    also an open source tool; however, it has a graphical user interface.
  prefs: []
  type: TYPE_NORMAL
- en: Requirements for the exercise
  prefs: []
  type: TYPE_NORMAL
- en: For this exercise, you’ll need access to a Linux host with its graphical desktop
    enabled along with a defined target host (to scan). In the accompanying screenshots,
    I’ve used Fedora® as the Linux distribution but virtually any distribution is
    acceptable here. Nmap should be available from your distribution’s own repositories,
    but we’ll need to download Zenmap from FlathubTM. On Fedora, this repository is
    preconfigured for you if you enable third-party repositories in the gnome-software
    application.
  prefs: []
  type: TYPE_NORMAL
- en: First, you need to log in to the host and open a terminal session. We can usually
    assume that it’s not installed by default, hence we will install it before continuing.
    If you’ve already installed the tools, you may skip this step.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we’ll install the Flathub `flatpak` repository (if it’s not already installed):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Next, we’ll confirm that the Flathub repository is available at the command
    line.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Please note that even if this is configured within gnome-software, it may not
    be available on the command line unless you physically install/enable it yourself.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now we’ll install the `zenmap` `flatpak`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Next, we’ll install Nmap out of the operating system’s own repository.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here’s an example of me running a scan in my network with the Nmap utility.
  prefs: []
  type: TYPE_NORMAL
- en: It’s actually me running a detailed port scan against a host called `ks01`.
    What we will see is the open ports and the services running.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2 – Nmap portscan and results](img/B22104_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.2 – Nmap portscan and results
  prefs: []
  type: TYPE_NORMAL
- en: In that example scan, we can see that SSH and HTTP are both accessible to external
    hosts.
  prefs: []
  type: TYPE_NORMAL
- en: First, let’s see what our options really are (*hint – there* *are MANY!!*).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now let’s run a simple scan of a target host. Please substitute the name of
    your target host where I have defined my target (`ks01`); otherwise, this will
    not work for you. This first example is the *fast* port scan.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now let’s do a more complex scan of our target host. Again, please substitute
    the name of your target host where I have listed my target (`ks01`). In this scan,
    we’ll be looking for detailed versioning information of the services running (when
    detected).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Next, I will demonstrate that this Nmap tool can not just scan individual hosts
    but entire subnets at once. This operation can take significantly longer and the
    total time to execute can vary depending on how many targets are in the network.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: Don’t try this at work without prior coordination with those teams who run the
    network and systems – you don’t want to set off any alarms (or get yourself into
    trouble).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Nmap is capable of running many types of scans and can also be somewhat intrusive
    if you are not careful. I recommend examining the documentation and perhaps grabbing
    one of the many cheat sheets on Nmap that are freely available online.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we’ve done a brief introduction to port scanning at the command line,
    let’s move on to using the slightly more feature-rich GUI tool: Zenmap.'
  prefs: []
  type: TYPE_NORMAL
- en: Here’s an example Zenmap scan that I ran, also targeting the same host as in
    the previous exercise and demonstration. Please note that the output is formatted
    much better than the command-line tool Nmap and there are options made available
    to the user for expanding upon details.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3 – Zenmap scan](img/B22104_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.3 – Zenmap scan
  prefs: []
  type: TYPE_NORMAL
- en: Here’s another example scan that I have run. This time, once I have the results,
    I have clicked on the **Ports / Hosts** tab in the interface.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.4 – Another Zenmap scan; focus on the Ports / Hosts tab](img/B22104_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.4 – Another Zenmap scan; focus on the Ports / Hosts tab
  prefs: []
  type: TYPE_NORMAL
- en: I cannot overemphasize the importance of ensuring that you scan release candidates
    for vulnerabilities, to validate open ports/services. We will touch on different
    types of scans in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have reviewed open source scanning, let’s move on to how one can
    track changes in the appliances.
  prefs: []
  type: TYPE_NORMAL
- en: Manifest and configuration tracking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The creation of a software manifest is a crucial step in knowing how to maintain
    the security of your systems. This ultimately is a detailed list of software packages
    and their respective versions. It is the sum of all packages in your operating
    system and your application stack, along with any additional third-party packages
    or combined dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing what goes into each and every release and where those packages come
    from, and curating a secure anthology of said packages will empower you to control
    the lifecycle of your solution.
  prefs: []
  type: TYPE_NORMAL
- en: I am not saying this will be easy. It can be, but as solutions become more and
    more complex, this truly becomes a labored effort – especially if not everything
    your solutions have consumed is provided in the same format.
  prefs: []
  type: TYPE_NORMAL
- en: Let me go into detail here. What if your operating system provider gives you
    their packages as RPMs but you have some dependencies that are downloaded as **tarballs**,
    or as flatpaks? And then what if we also run some containerized microservices
    on top? Tracking everything can get complex really fast. In fact, it almost becomes
    impossible to track at all. This is why change tracking and the SBOM matter. So,
    let’s take a look at how we can track changes in our own appliances.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise – tracking changes in your product
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we'll dive deep into how to correlate what’s in an existing
    build versus what changes (aka deltas) are present in the next round of updates
    for your appliance. Knowing which packages are new (those deltas again) will blatantly
    highlight what your team will need to provide to existing users as an update bundle
    either in a custom repository or via other methods.
  prefs: []
  type: TYPE_NORMAL
- en: Requirements for the exercise
  prefs: []
  type: TYPE_NORMAL
- en: For this hands-on exercise, you will only need access to a Linux machine (physical
    or virtual). Root (or `sudo`) access is mandatory. I am doing this example on
    my Fedora 40 box, but you could potentially follow along with me on any RHEL-like
    distribution.
  prefs: []
  type: TYPE_NORMAL
- en: First, we’ll create a script, using your favorite editor. Create a file called
    `my-inventory-creator.sh`. Ensure that you set the file permissions so that it’s
    executable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now let’s run the script and take note of the output file names (which include
    date stamps). These will be unique for you.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Now let’s review those output files. These will also be unique for your build/system.
    We will start with the software sources file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now let’s see the software details file (this will be long). The output of this
    command is huge so I will warn you upfront – I had to truncate it for space reasons.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Now we have a complete manifest of software and sources for our build. Let’s
    do a quick search for a specific package. For my example, I am using `httpd`,
    but you can practice searching for whichever package/version you prefer.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Now let’s install a package that will drag in some dependencies along with it.
    I’m going to install a package called `kdiff3`, which belongs to the vast family
    of “diff” tools that find differences in files or from command-line outputs. Again,
    here, the output from this command is pages and pages long, hence I have truncated
    it again.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In the last step, we installed a single package (but it brought along 113 dependencies).
    So, let’s now rerun our inventory script and do some introspection on what really
    changed.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Take note of the new files that were created in this run.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Your output files for this check are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Now let’s generate a list of differences between the two file sets.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: There was no change in the sources we drew our files from but there will be
    significant changes in the software details lists. Let’s do a side-by-side comparison.
    Please note the output will be big.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: You’ll now be able to see what was added (or changed) with this method. In the
    above example, there are 114 changes (actually, additions). I only truncated the
    output to save space and not bore you with the details.
  prefs: []
  type: TYPE_NORMAL
- en: This is where I prefer to leverage some GUI-based tools like the one I just
    installed. Let’s take a quick look at `kdiff3`.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll select the same files from the previous steps.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.5 – Starting the kdiff3 comparison operation](img/B22104_05_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.5 – Starting the kdiff3 comparison operation
  prefs: []
  type: TYPE_NORMAL
- en: Next, select the files in the interface. **A (Base)** is the older software
    details file. Finally, select the file for **B** as the latest one.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.6 – Selecting the files](img/B22104_05_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.6 – Selecting the files
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve defined all the files to compare, we click **OK**.
  prefs: []
  type: TYPE_NORMAL
- en: The output of this will highlight the differences graphically in the two lists.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.7 – Running the comparison](img/B22104_05_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.7 – Running the comparison
  prefs: []
  type: TYPE_NORMAL
- en: The differences are crucial knowledge for you and your team. With this knowledge,
    you know which files you’ll need to curate proper update releases for your customers
    (assuming you run this type of comparison as part of your release candidate review
    process). This is the perfect segue to our next section on how to provide update
    control mechanisms within your product.
  prefs: []
  type: TYPE_NORMAL
- en: Update control mechanisms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of my favorite discussions over the years with my embedded partners has
    been how to create a proper update methodology along with the processes and the
    infrastructure to support it. Ultimately, we already know – based on the customers’
    operating environment, use cases, and compliance footprint – whether these mechanisms
    will be simple and online, or offline and complex.
  prefs: []
  type: TYPE_NORMAL
- en: Your choices here will directly impact the User Interface (UI) of your product.
    Packaging your software and configurations will simplify lifecycle management
    and support costs while improving end-user experiences.
  prefs: []
  type: TYPE_NORMAL
- en: For this next set of exercises, we will assume that your team has chosen to
    package up your special sauce along with using RPM packages and custom repositories
    in both your build and support chains. This is the easiest route but not always
    the most feasible.
  prefs: []
  type: TYPE_NORMAL
- en: We will cover other update control mechanisms later (and online in the book’s
    GitHub repository). They can be (but are not limited to) encrypted tarballs, ISO
    images, thumb drives, FTP bundles, and many others. Each of those will require
    additional work in your build chain and vastly more attention in the support chain,
    not to mention more support staff who are better trained.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have reviewed how to track and document changes in your appliance,
    let’s move on to another key facet of maintaining control of your SBOM – this
    time, via custom packaging.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise – building custom software packages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I hope you are ready for some typing. We’re going to start building here. As
    there are a million things that you can do within your own custom packages, I
    will only cover something that’s near and dear to some embedded systems best practices,
    and that’s creating your own release definition file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following link that I am sharing is somewhat the *go-to* reference for
    all things RPM-based. I recommend spending some serious time there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://rpm-packaging-guide.github.io/](https://rpm-packaging-guide.github.io/)'
  prefs: []
  type: TYPE_NORMAL
- en: Requirements for the exercise
  prefs: []
  type: TYPE_NORMAL
- en: You’ll need access to a Linux server. Root or `sudo` access is mandatory. A
    little bit about my demo environment – I am running Fedora 40 Workstation and
    I have created a user called `mattbuild` (you can create your own build environment
    user before starting this exercise) and I’ve added it to the `sudoers` file. Now
    let’s set up your RPM package building environment.
  prefs: []
  type: TYPE_NORMAL
- en: First, we’ll install the packaging tools (along with their numerous dependencies).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Next, we’ll modify the user account we are using to build the packages to become
    a member of the *mock* system group.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we’ll confirm the changes to the user account. You can either leverage
    the `newgrp` command or log out and log back in to reset your environment. Once
    you’ve done either of those, validate that the group changes have taken effect.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Now let’s create a proper rpm build environment for that user. Running the `rpmdev-setuptree`
    command will build a folder structure that is required for the build process.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Now let’s create a `.spec` file for our project. I use `vi` or `vim`, but feel
    free to use your favorite. I’ll place a copy of this file in the GitHub repository
    in case you do not want to type this one out.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Now, we’ll edit the contents of the file. Be sure to save your file when done.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Only use *spaces* and not *tabs* anywhere in this file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Now let’s try our first rpm build. The output for this will be huge (so I’m
    not going to bother listing it all).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Now let’s do a test install.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Alright! We have our first custom package and our first custom file installer
    (and it works!)
  prefs: []
  type: TYPE_NORMAL
- en: Let’s show it off.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Great job! Now you are on your way to securing your software supply chain by
    creating your own packages. I truly hope you had at least a little fun in this
    exercise.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise – signing your custom RPM package
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now it’s time for extra credit. This is not an introductory course. This is
    a master-level course. Yes, it’s great we can now create a custom RPM package
    but we are focusing on securing your software supply chain in this chapter. Time
    to step things up. It’s time to add your own GPG signature to your custom package!
  prefs: []
  type: TYPE_NORMAL
- en: First, we’re going to leave the build account and switch over to root access.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We’re now going to ensure you have the right software installed to sign the
    RPMs that you build for your appliance. Install the `rpm-sign` package.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In this next set of steps, you’re going to generate your own super-cool secure
    `gpg` key. When you do this for real in production, you must ensure that you are
    using official names, email addresses, and so on for your `gpg` key.
  prefs: []
  type: TYPE_NORMAL
- en: For this example, we’ll use the name of John Doe with an email address of `john_doe@gmail.com`
    and the not-so-secure passphrase of `Embedded`. This next command is interactive
    and some of the dialogs actually present what I comically call screen vomit in
    order to keep the users’ attention to the dialogs. Others may simply call this
    a loosely managed **Text User** **Interface** (**TUI**).
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Use `gpg --full-generate-key` for a full-featured key generation dialog.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Next, the following dialog will appear; you’ll enter the passphrase `Embedded`
    and select `<OK>` to continue.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: You will most likely get scolded by the system for not using a super-secure
    passphrase, but this is training, so select `<Take this one anyway>` to continue.
    One just has to love these interactive text interfaces. They really do prevent
    you from having to learn a command line that’s a mile long.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: We’re almost there in getting the key created. We must confirm the passphrase
    `Embedded` to continue.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: And let’s watch it do its work. Your output should appear much like this (but
    not exactly as each key generation is unique).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: So now let’s take a look at all the keys on our system so far.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Your key is now imported. Let’s query the `rpm` database to see if it’s actually
    there. A simple query may not be sufficient, so we might need to add in some field
    parsing.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Okay. Now, let’s set up the signing environment for root and then verify that
    it is all ready to go. As root, use your favorite editor to create the `.rpmmacros`
    file in the root home directory.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Here’s what you’ll need to place in the `.rpmmacros` file. Don’t forget to save
    the file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: As many have heard me say (probably far too often), *Trust but verify*. So verify!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The magic moment that you’ve been waiting for. Let’s sign the RPM that you just
    built with your shiny new `GPG` key! Remember you’ll be asked for our super-secret
    passphrase – `Embedded`. Enter it and then select `<OK>`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: You’ve created your first custom file that aligns with embedded best practices
    by installing a release file in your appliance. Since security is paramount in
    the software supply chain, you’ve also ensured the sanctity of your package by
    adding your own `GPG` key signature. Pat yourself on the back.
  prefs: []
  type: TYPE_NORMAL
- en: Show off that awesome new skill set by testing the package again.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Here we are. Journey complete. Let’s move on to the next steps in securing our
    software supply chain.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise – creating a custom DNF repository
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are actually two schools of thought on this. One creates separate repositories
    for the applications stack and the operating system, and the other simply puts
    it all in a monolithic custom repository. I prefer the latter. I say just put
    it all together as tracking gets simpler. I also believe in the creation of numerous
    custom RPMs in the said repository that shall assist your team in the maintenance
    of your solution. I can literally feel my own eyes rolling when I type that. Am
    I repeating myself? Probably.
  prefs: []
  type: TYPE_NORMAL
- en: What else should go in this custom repository? First, I recommend an rpm that
    defines your release, much like we created just a little while ago. Second, I
    recommend the creation of a documentation rpm to be separate from your application
    itself. Finally, and most importantly, I strongly recommend the creation of an
    rpm that installs your repository information directly into the appliance. Defining
    the repository in its own rpm is key. It aids in the support and lifecycle of
    the solution and if you need to make changes to the repository (or the GPG keys),
    it gives you the simplest way of updating it for the end-customer.
  prefs: []
  type: TYPE_NORMAL
- en: These custom repositories are not just for the appliances’ updates. They can
    be greatly leveraged internally as part of your secure build chain. So, with all
    that said, how do we build a custom repository?
  prefs: []
  type: TYPE_NORMAL
- en: Requirements for the exercise
  prefs: []
  type: TYPE_NORMAL
- en: For this hands-on exercise, you will only need access to a Linux machine (physical
    or virtual). Root (or `sudo`) access is mandatory. I am doing this example on
    my Fedora 40 box, but you could potentially follow along with me on any RHEL-like
    distribution.
  prefs: []
  type: TYPE_NORMAL
- en: First, we’ll ensure that `httpd` and the `createrepo` utility are installed.
    Then, we’ll also make sure that the web server is actively running.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Next, we’ll create a folder under the html directory for our repository. Then
    we’ll copy the rpm we created in the previous exercise to the directory.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Next, we’ll initialize the repository.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Test to ensure that we can access the repository via a web browser locally.
  prefs: []
  type: TYPE_NORMAL
- en: Here’s an example of what you’ll see by testing on a local browser. It will
    show you an accessible set of contents in your newly created custom repository.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.8 – Localhost view of repository in a web browser](img/B22104_05_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.8 – Localhost view of repository in a web browser
  prefs: []
  type: TYPE_NORMAL
- en: Other steps for this internal repository are to enable `http` on the firewall
    (so our new repo can be accessed by machines in your lab internally) and, if in
    use, set the `selinux` file context for the repositories directory and files to
    `httpd_syscontent_t`. As this is not a basic sysadmin book, I trust you and your
    team already know how to do those simple tasks.
  prefs: []
  type: TYPE_NORMAL
- en: This is generally an OK setup for a lab. This setup is beyond unacceptable for
    anything externally facing (i.e., internet-facing). For that use case, there are
    many books and resources available on how to secure your web server; however,
    I will make some baseline recommendations that should go without saying.
  prefs: []
  type: TYPE_NORMAL
- en: For a public-facing web server, your system should be using `https` with a signed
    certificate. The server should be in your company’s external DNS so the customers
    can find it. Methods to control access, perhaps at an individual customer or user
    level, should be applied. Protect your system as best you can.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve created a custom package and hosted it via a custom repository,
    all that remains is how to configure the appliances to consume the new custom
    content. This next exercise will walk you through just that.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise – configuring your solution to use your custom repository
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s now configure our appliance to access our custom repository. This is a
    key step in ensuring that only your tested and vetted content is provided to your
    end-users in the future.
  prefs: []
  type: TYPE_NORMAL
- en: Requirements for the exercise
  prefs: []
  type: TYPE_NORMAL
- en: For this hands-on exercise, you will need access to the same Linux machine where
    you previously created a sample repository along with another machine to configure
    for accessing the said repository. Root (or `sudo`) access is mandatory. I am
    doing this example on my Fedora 40 box, but you could potentially follow along
    with me on any RHEL-like distribution.
  prefs: []
  type: TYPE_NORMAL
- en: These files are stored under `/etc/yum.repos.d/` and have the file extension
    of `.repo`. They should be owned by root, readable by all, but not writable by
    anyone else other than root. This will keep them secure.
  prefs: []
  type: TYPE_NORMAL
- en: So before you create your own example repository definition file, let’s take
    a look at a detailed breakdown of one I created for the custom repository in the
    earlier exercise. Here is an example file called `mycustomstuff.repo`. I will
    place a copy of this file in the GitHub repository in case you do not wish to
    type this one out.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Now that you have an example, create your own `mycustomstuff.repo` file and
    place it on the Linux machine that is not hosting the repo. The file should be
    owned by root but be readable by all groups and all users.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have completed that, test the functionality by installing the RPM package
    `myapprel` on the machine where you’ve set up the repository access.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve successfully attached our system to the repository and installed
    our custom package, we can celebrate our success. These exercises are crucial
    to how your team will be able to support your appliances in the future.
  prefs: []
  type: TYPE_NORMAL
- en: Other concerns to account for
  prefs: []
  type: TYPE_NORMAL
- en: This should go without saying, but I will say it anyway. Have actual people
    test your prototypes and release candidates. Only this will let your team know
    if you have truly achieved success. I am not saying that you should not test with
    automation – actually, quite the opposite. Do both. Do all the automated tests,
    the penetration tests, and the scans first. Once satisfied with those results,
    move on to human trials.
  prefs: []
  type: TYPE_NORMAL
- en: You must also test your processes and support infrastructure. Test how new releases
    will impact the support chain and how each new release will be consumed by your
    customers. Failed or broken updates can cause outages, service blockages, unusable
    appliances, and, worst of all, very disgruntled and dissatisfied customers.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, let’s recap. We truly have covered a lot of material in this chapter. You
    should feel that you’ve achieved some level of success. You have come a long way
    in a short time. Initially, you established your appliance’s bill of materials
    (SBOM), and then you defined your own custom packages, releases, and custom repositories.
    All of this culminated in putting them into action by granting your appliance
    access to your custom repository and installing new packages. You have secured
    your own software supply chain! I hope you now feel that you’re empowered to track
    the lifecycle of your future offering, so let’s move on to the next chapter where
    we will dive deep into the usage of encryption and protecting the data within
    your solution.
  prefs: []
  type: TYPE_NORMAL
