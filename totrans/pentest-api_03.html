<html><head></head><body>
		<div><h1 id="_idParaDest-43" class="chapter-number"><a id="_idTextAnchor042"/>3</h1>
			<h1 id="_idParaDest-44"><a id="_idTextAnchor043"/>API Reconnaissance and Information Gathering</h1>
			<p>Knowing the terrain before committing to attacking it is a military maxim. Sun Tzu, the famous author of the bestseller <em class="italic">The Art of War</em> wrote that “<em class="italic">you should have a strong sense of the surrounding terrain.</em>” Getting to know the target API is as important as deleting the intrusion evidence of the attack. So, know before you go!</p>
			<p>API reconnaissance<a id="_idIndexMarker180"/> and information gathering<a id="_idIndexMarker181"/> is the process of collecting information about an API, such as its endpoints, methods, parameters, authentication mechanisms, and business purpose. This information can then be used to identify security weaknesses, test the API’s functionality, or develop new applications that interact with the API.</p>
			<p>In this chapter, you will learn reconnaissance and information-gathering techniques that will become part of the planning activities of a penetration test. As a matter of fact, after correctly setting up your toolbelt, as you did in the previous chapter, uniting information about the target is the next step.</p>
			<p>You will learn <a id="_idIndexMarker182"/>important concepts, such as enumeration, API documentation, <strong class="bold">Open Source Intelligence </strong>(<strong class="bold">OSINT</strong>), and API schemas. All of these are related to basically any modern API available on the Internet. We will use OWASP’s crAPI and WebGoat projects as our playground.</p>
			<p>In this chapter, we’re going to cover the following main topics:</p>
			<ul>
				<li>Identifying and enumerating APIs</li>
				<li>Analyzing API documentation and endpoints</li>
				<li>Leveraging OSINT</li>
				<li>Identifying data and schema structures</li>
			</ul>
			<h1 id="_idParaDest-45"><a id="_idTextAnchor044"/>Technical requirements</h1>
			<p>Ideally, you should have already created your pentesting environment, as pointed out in <a href="B19657_02.xhtml#_idTextAnchor028"><em class="italic">Chapter 2</em></a>. However, if you haven’t, this is not a big deal.</p>
			<p>You can use the tools that follow to go through this chapter:</p>
			<ul>
				<li>A hypervisor such as Oracle VirtualBox is needed.</li>
				<li>A Linux <strong class="bold">Virtual Machine</strong> (<strong class="bold">VM</strong>); I recommend selecting either Ubuntu or Fedora distros because of the vast number of utilities on both.</li>
				<li>Postman (<a href="https://www.postman.com/downloads/">https://www.postman.com/downloads/</a>).</li>
				<li>OWASP <strong class="bold">Completely Ridiculous API</strong> (<strong class="bold">crAPI</strong>) (<a href="https://github.com/OWASP/crAPI/">https://github.com/OWASP/crAPI/</a>).</li>
				<li>OWASP WebGoat (<a href="https://owasp.org/www-project-webgoat/">https://owasp.org/www-project-webgoat/</a>).</li>
				<li>OWASP ZAP (<a href="https://www.zaproxy.org/">https://www.zaproxy.org/</a>).</li>
				<li>In terms of container engines, use either Docker or Podman, which is a superset of Docker.</li>
				<li>If you are going for the standalone version of WebGoat, you will need a Java runtime environment. I suggest selecting OpenJDK. Both Ubuntu and Fedora have packages for it. Other distros might have it as well.</li>
				<li>You will need at least 30 GB of disk space, 2 vCPUs, and 4 GB of RAM on your host to accommodate the VM. The recommendation is 50 GB, 4 vCPUs, and 8 GB, respectively.</li>
			</ul>
			<p class="callout-heading">Important note</p>
			<p class="callout">When this book was being written, there was no stable version of VirtualBox for computers with Apple Silicon chips. The beta versions available were unable to launch ARM VMs. If this is your scenario, I recommend using UTM (<a href="https://mac.getutm.app/">https://mac.getutm.app/</a>) instead. There are a few ways to install it, including via Homebrew. This chapter uses an Ubuntu 22.04 LTS server as a VM on top of UTM.</p>
			<h1 id="_idParaDest-46"><a id="_idTextAnchor045"/>Identifying and enumerating APIs</h1>
			<p>Identification <a id="_idIndexMarker183"/>and enumeration of targets can be done passively or actively and this is not<a id="_idIndexMarker184"/> exclusive to APIs. Passive recon involves gathering information about an API without directly interacting with it. This can be done through a variety of methods, such as the following:</p>
			<ul>
				<li><strong class="bold">Searching public documentation</strong>: Many API providers publish documentation that describes the API’s endpoints, methods, parameters, and authentication mechanisms. This documentation can be found on the provider’s website, in online forums, or in code repositories.</li>
				<li><strong class="bold">Analyzing public traffic</strong>: If the API is publicly accessible, it is possible to analyze traffic to the API to learn more about how it is used. This can be done using tools such as Wireshark or Fiddler.</li>
				<li><strong class="bold">Searching for exposed information</strong>: API providers may accidentally expose sensitive information, such as API keys or passwords, in public forums or code repositories. It is possible to find this information using search engines or tools such as Shodan.</li>
			</ul>
			<p><strong class="bold">Passive reconnaissance</strong> is about <a id="_idIndexMarker185"/>getting information about an API without necessarily talking to it. In other words, you need to search for the required information by using other sources such as public documentation, analyzing public traffic, or searching for exposed information. Many API providers release documentation about their API’s methods, verbs, and parameters, as well as how authentication and authorization work. This can eventually reveal weak control mechanisms, such as a simple pair of username/password credentials. If the API is publicly accessible, you can analyze its traffic by capturing it with the help of tools such as Wireshark and Fiddler. Additionally, sensitive data, such as keys, tokens, passwords, or special configuration parameters, might have been inadvertently leaked in code repositories or forums. With the use of a web search engine or a tool such as Shodan, you can easily find them.</p>
			<p><strong class="bold">Active enumeration</strong>, on the <a id="_idIndexMarker186"/>other hand, will require you to interact with the API. As is the case for all activate phases of a pentest, bear in mind that your actions might be logged by the API provider. Regardless of that, active recon usually follows this sequence:</p>
			<ol>
				<li>You start by<a id="_idIndexMarker187"/> discovering the API’s endpoints (that is, the URLs it’s waiting<a id="_idIndexMarker188"/> for) and answering requests. With a spider, such as Sitebulb or Screaming Frog SEO Spider, you can enumerate all the API’s e<a id="_idTextAnchor046"/><a id="_idTextAnchor047"/><a id="_idTextAnchor048"/>ndpoints:</li>
			</ol>
			<div><div><img src="img/B19657_03_01.jpg" alt="Figure 3.1 – Sitebulb’s interface (image credit: Sitebulb)"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.1 – Sitebulb’s interface (image credit: Sitebulb)</p>
			<p class="list-inset">You can then send requests to them via the <code>curl</code> utility or utilities such as Postman. In fact, one very interesting feature of Postman is translating the request you graphically build in a <code>curl</code> command:</p>
			<pre class="source-code">
<strong class="bold">$ curl --location 'https://url/api' \</strong>
<strong class="bold">--header 'Authorization:&lt;authorization token&gt;' \</strong>
<strong class="bold">--form 'form_field_1="content of field 1"' \</strong>
<strong class="bold">--form 'upload=@"/path/file_to_upload"' \</strong>
<strong class="bold">--form 'form_field_2="content of field 2"' \</strong>
<strong class="bold">--form 'format="PDF"' \</strong>
<strong class="bold">--form 'description="Details about the File"'</strong></pre>			<ol>
				<li value="2">Some API endpoints accept parameters that can be used to control the API’s behavior. By probing such parameters, you can learn more about them, including which values are acceptable and how they can affect the API’s operation.</li>
				<li>You can also<a id="_idIndexMarker189"/> choose to test the API’s authentication mechanism. Some <a id="_idIndexMarker190"/>APIs return data when you send a read-only request even without a prior authentication. However, if an API requires some type of authentication control, you can test it to understand its robustness, for example, by crafting special or fuzzed credentials.</li>
			</ol>
			<p>We are now going to cover a few tools that are quite useful for pentesting purposes, including crAPI, which you will use throughout the rest of the book.</p>
			<h2 id="_idParaDest-47"><a id="_idTextAnchor049"/>Analyzing WebGoat</h2>
			<p>Let’s start playing <a id="_idIndexMarker191"/>with our lab. Docker is installed along with crAPI<a id="_idIndexMarker192"/> and WebGoat, both using Docker images. crAPI is distributed with a Docker Compose multi-container definition file. You are more than free to pick any other combination of distributions and ways to install WebGoat and WebWolf (the accompanying application to test some features of WebGoat). Both can be installed with the same Docker image or directly executed using separate Java Archive files. Wireshark is also installed.</p>
			<div><div><img src="img/B19657_03_02.jpg" alt="Figure 3.2 – WebGoat’s login page (http://localhost:8080/WebGoat/login)"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.2 – WebGoat’s login page (http://localhost:8080/WebGoat/login)</p>
			<p>The following screenshot<a id="_idIndexMarker193"/> shows the login page for WebWolf:</p>
			<div><div><img src="img/B19657_03_03.jpg" alt="Figure 3.3 – WebWolf’s initial page (http://localhost:9090/home)"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.3 – WebWolf’s initial page (http://localhost:9090/home)</p>
			<p>Since our target APIs are crAPI and WebGoat, there’s no API documentation to be searched, which reduces our passive reconnaissance options. We can still simulate some traffic capture to understand how it works. Start Wireshark and start the capture on the loopback interface (<code>127.0.0.1</code>). To avoid getting overwhelmed with other traffic that your system generates, put a filter to restrict capturing HTTP packets on TCP port <code>8080</code> only (<code>tcp.port == 8080 and http</code>). With a simple load of WebGoat’s login page, you’ll see capture lines popping up. To facilitate identifying when the packets were captured, you may change the way Wireshark shows them by clicking on <strong class="bold">View</strong> | <strong class="bold">Time </strong><strong class="bold">Display Format</strong>.</p>
			<p>You need to register an account before start using the tool. The examples in this book use <code>pentest</code>/<code>pentest</code> as a pair of credentials. Register an account and launch Wireshark. Observe one of the captured packets. Obviously, we can see the password because WebGoat does not apply a digital certificate in the communication:</p>
			<div><div><img src="img/B19657_03_04.jpg" alt="Figure 3.4 – The output of a Wireshark packet capture showing a clear text password"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.4 – The output of a Wireshark packet capture showing a clear text password</p>
			<p>From that packet, you <a id="_idIndexMarker194"/>can verify that the element that created the credentials is called <code>/WebGoat/register.mvc</code>, which was called by <code>/WebGoat/registration</code>. Try to call it individually via <code>curl</code> to see whether there’s anything useful. If you do a <code>curl -vslk http://localhost:8080/WebGoat/register.mvc</code>, you’ll see something like the following. Part of the output was omitted for brevity.</p>
			<div><div><img src="img/B19657_03_05.jpg" alt="Figure 3.5 – WebGoat’s register.mvc element throwing an error message"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.5 – WebGoat’s register.mvc element throwing an error message</p>
			<p>The <code>curl</code> utility uses the <code>GET</code> HTTP verb by default. We just discovered that this element does not support the <code>GET</code> verb and it simply threw a very informative error message, saying (for example) that <a id="_idIndexMarker195"/>the application runs with the Spring framework. Even one of the affected source code files and its line are provided: <code>RequestMappingInfoHandler.java</code>, line <code>253</code>! You could have acquired this information via a web browser too, but getting used to <code>curl</code> is important. That was nice for a start, but WebGoat is not exactly the best tool to help us dive into an API’s internals. crAPI is a better candidate.</p>
			<h2 id="_idParaDest-48"><a id="_idTextAnchor050"/>Looking at crAPI</h2>
			<p>crAPI is an<a id="_idIndexMarker196"/> intentionally vulnerable application with a RESTful API that was created to facilitate exploring <a id="_idIndexMarker197"/>OWASP’s API Security Top 10 threats (<a href="https://owasp.org/API-Security/">https://owasp.org/API-Security/</a>). The year when this book was being written coincided with the latest release of the API Security Top 10 project. Another tool like crAPI is<a id="_idIndexMarker198"/> Juice Shop (<a href="https://owasp.org/www-project-juice-shop/">https://owasp.org/www-project-juice-shop/</a>), written in JavaScript.</p>
			<p>As soon as you finish running crAPI’s Docker Compose file, you can open the application by accessing <code>http://localhost:8888/</code>. You will be redirected to the <code>/login</code> path. This doesn’t necessarily mean at first that you are dealing with a RESTful API. Being redirected to another path simply means that the application either recognized that you are not authenticated yet or sent you to the correct page in case you have tried to open an obsolete component. The command is as follows:</p>
			<pre class="console">
$ docker compose -f docker-compose.yml --compatibility up -d</pre>			<p>The backward compatibility flag was implemented with the new version of Docker Compose. Support for the previous version was ended in June 2023. More information can be found at <a href="https://docs.docker.com/compose/compose-file/compose-versioning/">https://docs.docker.com/compose/compose-file/compose-versioning/</a>.</p>
			<p>As it is a container-based application, you will leverage the advantage of not having to manually download all the components. When Compose finishes downloading images, creating volumes and <a id="_idIndexMarker199"/>environment variables, and defining limits, you will have the <a id="_idIndexMarker200"/>following containers:</p>
			<table id="table001-1" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Container name</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Container image</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Purpose</strong></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>api.mypremiumdealership.com</code></p>
						</td>
						<td class="No-Table-Style">
							<p>gateway-service</p>
						</td>
						<td class="No-Table-Style">
							<p>The vulnerable API</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>crapi-community</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Same name</p>
						</td>
						<td class="No-Table-Style">
							<p>Community blogs</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>crapi-identity</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Same name</p>
						</td>
						<td class="No-Table-Style">
							<p>Authentication endpoint</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>crapi-web</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Same name</p>
						</td>
						<td class="No-Table-Style">
							<p>The web UI</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>crapi-workshop</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Same name</p>
						</td>
						<td class="No-Table-Style">
							<p>Car workshop</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>mailhog</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Same name</p>
						</td>
						<td class="No-Table-Style">
							<p>Mail service</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>mongodb</code></p>
						</td>
						<td class="No-Table-Style">
							<p>mongo</p>
						</td>
						<td class="No-Table-Style">
							<p>Self-explanatory</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>postgresdb</code></p>
						</td>
						<td class="No-Table-Style">
							<p>postgres</p>
						</td>
						<td class="No-Table-Style">
							<p>Self-explanatory</p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 3.1 – crAPI’s containers and images and their purposes</p>
			<p>crAPI implements a<a id="_idIndexMarker201"/> website for <a id="_idIndexMarker202"/>vehicle owners to search, find, and request maintenance for their cars, while also exposing a RESTful API to facilitate such tasks. I’m assuming that you have already installed either ZAP or <a id="_idIndexMarker203"/>Burp Suite, as per the previous chapter. We will use ZAP here. The first crAPI page is a sign <a id="_idIndexMarker204"/>in/sign up dialog box:</p>
			<div><div><img src="img/B19657_03_06.jpg" alt="Figure 3.6 – crAPI’s login page"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.6 – crAPI’s login page</p>
			<p>You can play with the signup page a bit by providing special characters in the username or email address fields. You can even provide an invalid phone number (the frontend logic only checks whether the contents are not null), which I did, and see the results on ZAP. I left the phone number empty and tried to sign up. The response is as follows:</p>
			<div><div><img src="img/B19657_03_07.jpg" alt="Figure 3.7 – An invalid sign-up page revealing details on the app’s backend"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.7 – An invalid sign-up page revealing details on the app’s backend</p>
			<p>On the very first <a id="_idIndexMarker205"/>interaction with the web application, without even crafting a special request, we discovered that it runs the Spring Framework, which means that we are dealing with a backend running on top of Java. Cool! Now let’s fill in the form as a car owner and log in. The response provides a bearer token:</p>
			<div><div><img src="img/B19657_03_08.jpg" alt="Figure 3.8 – The response of a valid login action, providing the corresponding bearer token"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.8 – The response of a valid login action, providing the corresponding bearer token</p>
			<p>Let’s proceed by adding a dummy vehicle. We will verify that more information about the application and the API endpoints will be revealed. When adding a vehicle, you need the PIN and the VIN, which are provided in an email sent to the address you entered when signing up. Simply open another browser tab and go to <code>http://localhost:8025</code> to access the Mailhog service. You will find the message there. The simple fact of logging in and clicking the corresponding button to add a vehicle reveals more API endpoints. Observe the series of figures that follows to know more. In the first one, you can see the response to a successful login.</p>
			<div><div><img src="img/B19657_03_09.jpg" alt="Figure 3.9 – The /api/v2/user endpoint after logging in"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.9 – The /api/v2/user endpoint after logging in</p>
			<p>The following is the <a id="_idIndexMarker206"/>sort of response you will get after adding a vehicle.</p>
			<div><div><img src="img/B19657_03_10.jpg" alt="Figure 3.10 – The /api/v2/vehicle endpoint after clicking the button to add a vehicle"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.10 – The /api/v2/vehicle endpoint after clicking the button to add a vehicle</p>
			<p>Finally, after correctly adding a vehicle, you will receive a screen like this one.</p>
			<div><div><img src="img/B19657_03_11.jpg" alt="Figure 3.11 – The random vehicle has been added"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.11 – The random vehicle has been added</p>
			<p>When a vehicle is added, the <a id="_idIndexMarker207"/>application assigns an UUID to it, as we can confirm by checking the response of the <code>/</code><code>api/v2/vehicle/vehicles</code> invocation:</p>
			<div><div><img src="img/B19657_03_12.jpg" alt="Figure 3.12 – The UUID generated as part of adding a vehicle"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.12 – The UUID generated as part of adding a vehicle</p>
			<p>Location data is also informed. Pay attention to this fact as it will be quite useful. You can play with the web UI a bit but check what happens with the response when you enter the <strong class="bold">Community</strong> section. This represents a sort of forum where vehicle owners can comment on or ask for help. The problem is that <em class="italic">all</em> owners’ posts have their corresponding vehicle IDs! It’s obviously not advisable to disclose data when it’s not strictly necessary, which is the case here. Why would some well-intentioned person want to know the vehicle ID of another person?</p>
			<div><div><img src="img/B19657_03_13.jpg" alt="Figure 3.13 – Other vehicle IDs are disclosed in the Community section of the application"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.13 – Other vehicle IDs are disclosed in the Community section of the application</p>
			<p>The <code>/api/v2/vehicle</code> endpoint has an option to provide the vehicle’s UUID and then specify the <code>location</code> keyword to obtain the car’s latitude and longitude. What if we leverage the output in the preceding screenshot and try to do this with a vehicle that’s not ours? You can do this however you prefer, such as via ZAP itself, Postman, or even the command line with the help of <code>curl</code>, for example. However, remember to log in first, as all subsequent requests will require the authorization token that you can only get after successfully authenticating. Observe in <em class="italic">Figure 3</em><em class="italic">.13</em> that my vehicle’s ID ends with <code>5b0a</code>. I will try to get the location of a vehicle whose ID ends with <code>8e3f</code>. Using <code>curl</code>, the command would be (this is a single command line):</p>
			<pre class="console">
$ curl http://localhost:8888/identity/api/v2/vehicle/4e9e1ab1-c478-4fe7-b141-c620dcd78e3f/location --header 'Content-Type: application/json' --header 'Authorization: Bearer &lt;put your authorization token here&gt;'</pre>			<p>Bingo! Observe the following <a id="_idIndexMarker208"/>screenshot. This demonstrates the fragility of the API provided by crAPI. By simply providing a valid token, I can see the details of an asset belonging to a different username!</p>
			<div><div><img src="img/B19657_03_14.jpg" alt="Figure 3.14 – Obtaining another vehicle’s data"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.14 – Obtaining another vehicle’s data</p>
			<p>Congratulations! You just inadvertently accessed another user’s vehicle data, which corresponds to the first<a id="_idIndexMarker209"/> crAPI challenge: <strong class="bold">Broken Object Level Authorization</strong> (<strong class="bold">BOLA</strong>). Let’s see how else we can get information about APIs.</p>
			<h1 id="_idParaDest-49"><a id="_idTextAnchor051"/>Analyzing API documentation and endpoints</h1>
			<p>You can<a id="_idIndexMarker210"/> also acquire important information about APIs by carefully analyzing their documentation and the endpoints they expose. Even nowadays, some API endpoints are made available without <strong class="bold">Transport Layer Security</strong> (<strong class="bold">TLS</strong>), which shouldn’t at all be a habit that is adopted. For<a id="_idIndexMarker211"/> the sake of keeping backward compatibility, some vendors and application owners choose to leave such insecure connection points open. They are sometimes used by lower-performance devices, such <a id="_idIndexMarker212"/>as <strong class="bold">Internet of Things</strong> (<strong class="bold">IoT</strong>) Raspberry Pis, Arduino controllers, or even regular clients with not much computing power. That’s because TLS offloading might demand substantial processing depending on the number of needed simultaneous or subsequent connections.</p>
			<p>Aside from that, by analyzing documentation and endpoints, you can spot other potential attack vectors such as weak or no authentication and/or authorization mechanisms. For the purposes of analyzing API documentation, you can make use of some decent utilities, such as <a id="_idIndexMarker213"/>SwaggerUI (<a href="https://github.com/swagger-api/swagger-ui">https://github.com/swagger-api/swagger-ui</a>) and <a id="_idIndexMarker214"/>ReDoc (<a href="https://github.com/Redocly/redoc">https://github.com/Redocly/redoc</a>). Although originally conceived to build documentation for APIs that follow the OpenAPI specification (<a href="https://www.openapis.org/">https://www.openapis.org/</a>), they can also be applied to analyze written docs. Considering the file that follows, replace the <code>&lt;&lt;&lt;Put OpenAPI Link here&gt;&gt;&gt;</code> placeholder with a link hosting an OpenAPI-like documentation YAML file. You <a id="_idIndexMarker215"/>can find websites on the <a id="_idIndexMarker216"/>APIs Guru’s website (<a href="https://apis.guru/">https://apis.guru/</a>); see <em class="italic">Figures 3.15</em> and <em class="italic">3.16</em>.</p>
			<pre class="source-code">
&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;ReDoc&lt;/title&gt;
    &lt;!-- needed for adaptive design --&gt;
    &lt;meta charset="utf-8"/&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt;
    &lt;link href="https://fonts.googleapis.com/css?family=Montserrat:300,400,700|Roboto:300,400,700" rel="stylesheet"&gt;
    &lt;!--
    ReDoc doesn't change outer page styles
    --&gt;
    &lt;style&gt;
      body {
        margin: 0;
        padding: 0;
      }
    &lt;/style&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;redoc spec-url='&lt;&lt;&lt;Put OpenAPI Link here&gt;&gt;&gt;'&gt;&lt;/redoc&gt;
    &lt;script src="img/redoc.standalone.js"&gt; &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre>			<p>You can find <a id="_idIndexMarker217"/>part of the Fitbit’s API documentation here:</p>
			<div><div><img src="img/B19657_03_15.jpg" alt="Figure 3.15 – Fitbit’s API documentation"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.15 – Fitbit’s API documentation</p>
			<p>Here you can see the <a id="_idIndexMarker218"/>same but for Forex’s API. It is a screenshot of the documentation screen showing the response to a request.</p>
			<div><div><img src="img/B19657_03_16.jpg" alt="Figure 3.16 – 1Forge Finance’s API documentation"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.16 – 1Forge Finance’s API documentation</p>
			<p>Observe that one<a id="_idIndexMarker219"/> of the first Fitbit items covers authentication, making use of the OAuth2 protocol. On the other hand, at first sight, 1Forge’s API does not provide any authentication whatsoever, at least not for those exposed services. As a matter of fact, it does provide this, but this is only correctly mentioned on their website. 1Forge also exposes pure HTTP endpoints. Leveraging that we just mentioned “exposed”, when you expand an item in the right pane of ReDoc, more information is given. In this case, we can see the websites we can leverage to interact with the API.</p>
			<p>Alternatively, to locally see a dummy OpenAPI specification, you can install ReDoc – or better yet, you can use its Docker version. I loaded the Docker version and set it to listen on the <code>8085</code> port (the default <code>8080</code> port was already being used either by ZAP or by another utility). This makes the dummy PetStore API documentation available for reading:</p>
			<pre class="console">
$ docker run -d -p 8085:80 redocly/redoc</pre>			<p>Another purpose of verifying an API’s documentation is to check its request and response structures. By analyzing how they need to be crafted or how they are sent back to you, it’s possible to infer some more details about the API. For example, that leak of other vehicle owners’ data would possibly go unnoticed if you didn’t use a proxy or your browser’s inspector tool. Another example concerns user IDs. Some applications may be vulnerable to user ID profiling. If an API allows you to create a user, you can build a simple script to make two or three requests in sequence to create a small list of users. If the API gives back to you the users’ IDs as part of the response, and if such IDs are sequential, you know the API is vulnerable to this threat. With pure HTTP endpoints, the game is even better since you can capture all other users’ data (on a local network) by faking a proxy server.</p>
			<p>Recalling the<a id="_idIndexMarker220"/> HTTP RFC (link on the reference), we know that an HTTP request has headers and a body. A web application developer can use any or both when implementing the API. By double checking the RFC, we can reach the consensus that if the data being sent in a request <em class="italic">is </em>metadata, then the <em class="italic">header</em> is the best place to put them. If the data <em class="italic">is not</em> metadata, then the <em class="italic">body</em> should be used instead. Why am I telling you that? Public cloud providers log pretty much everything that comes and goes to their networks. However, web requests’ bodies may not be fully logged since they can contain customers’ sensitive data and allowing an unauthorized person (such as a cloud provider’s engineer) to have access to such logs would cause failure in security compliance and no providers want this for sure. Hence, when interacting with any API, pay very close attention to the API’s response bodies, as they may hold very valuable data that can be used later when preparing for an attack.</p>
			<h1 id="_idParaDest-50"><a id="_idTextAnchor052"/>Leveraging OSINT</h1>
			<p>OSINT is a <a id="_idIndexMarker221"/>market that has substantially grown in the last few years and has a continuous tendency to keep growing. According to a publicly available report, in 2022 the market size was 4.2 billion USD. It’s expected to reach 7.32 billion USD in 2031, which represents a 73.43% increase with a <strong class="bold">Compound Annual Growth Rate</strong> (<strong class="bold">CAGR</strong>) of<a id="_idIndexMarker222"/> about 6.31% in a nine-year period. That’s something that can’t go unnoticed. This market is comprised mostly of companies that build software and/or training to explore the corresponding research techniques.</p>
			<p>If you have never heard about OSINT, I will summarize it for you. OSINT comprises a series of techniques for collecting and analyzing information that is publicly available. OSINT can be used to gather information about APIs in a variety of ways. For example, you can use OSINT to<a id="_idIndexMarker223"/> do the following:</p>
			<ul>
				<li>Find information about APIs that are not documented by the provider.</li>
				<li>Identify new API endpoints that have been released.</li>
				<li>Discover changes to existing API endpoints.</li>
				<li>Find<a id="_idIndexMarker224"/> information about security vulnerabilities in APIs.</li>
			</ul>
			<p>Some common OSINT resources for gathering information about APIs include the following:</p>
			<ul>
				<li><strong class="bold">Search engines</strong>: Search <a id="_idIndexMarker225"/>engines can be used to find information about APIs that are not documented by the provider.</li>
				<li><strong class="bold">Social media</strong>: Social<a id="_idIndexMarker226"/> media platforms such as X (previously known as Twitter) and GitHub can be used to find information about new API endpoints, changes to existing API endpoints, and security vulnerabilities in APIs.</li>
				<li><strong class="bold">Online forums</strong>: Online<a id="_idIndexMarker227"/> forums such as Stack Overflow and Reddit can be used to find information about how to use APIs and to troubleshoot problems with APIs.</li>
			</ul>
			<p>OSINT can also be used for several other activities, such as watching or tracking individuals or companies, discovering information about assets besides API endpoints, such as servers, applications, externally available systems, locating buildings or facilities among others. I know that it looks scary, but as with most things in life, there are good and evil uses for this technology. There is a decent amount of free content about OSINT available on the internet, including lists of resources and tools. Among everything, I would not forget to mention the following ones:</p>
			<ul>
				<li><strong class="bold">The OSINT framework</strong> (<a href="https://osintframework.com/">https://osintframework.com/</a>): This is an online catalog with a curated list<a id="_idIndexMarker228"/> of online resources categorized by type. Some of those are free, others allow you to test them, and still others are commercial.</li>
				<li><strong class="bold">Shodan</strong> (<a href="https://www.shodan.io/">https://www.shodan.io/</a>): This is a search service with a huge database of IoT <a id="_idIndexMarker229"/>devices, such as cameras, routers, and micro-controllers. Although it’s a paid service, it’s not rare to find good discounts on some dates, such as Black Friday.</li>
				<li><strong class="bold">The Google Hacking Database</strong> (<a href="https://www.exploit-db.com/google-hacking-database/">https://www.exploit-db.com/google-hacking-database/</a>): This is a <a id="_idIndexMarker230"/>compendium of Google dorks (specially crafted Google queries) that you can filter to show only the desired types of targets, including APIs.</li>
			</ul>
			<p><em class="italic">Figures 3.17</em> and <em class="italic">3.18</em> show<a id="_idIndexMarker231"/> examples of what you can find when looking for API endpoints on Shodan. The service can disclose whether the endpoint has vulnerabilities, as well as what they are. Practical, right? They are usually related to the operating systems that support the servers, but the web service can also be listed as vulnerable, which would help with your pentesting tasks. The screenshots were captured after logging in to the service. The first one shows an API endpoint. The screenshots have been anonymized on purpose.</p>
			<div><div><img src="img/B19657_03_17.jpg" alt="Figure 3.17 – An Indonesian university with a potentially vulnerable API endpoint"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.17 – An Indonesian university with a potentially vulnerable API endpoint</p>
			<p>The second one shows an Oracle server with an endpoint that is open to the world.</p>
			<div><div><img src="img/B19657_03_18.jpg" alt="Figure 3.18 – Simple API queries on Shodan"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.18 – Simple API queries on Shodan</p>
			<p>The service has a fair number of queries you can explore. Some of the most used ones follow:</p>
			<ul>
				<li><code>hostname:targetdomain.com</code>: This directs all queries to the target domain, which can also result in a hostname if the target uses an APEX domain name.</li>
				<li><code>content-type:application/json</code> (or <code>xml</code>): The majority of APIs accept and return data either in JSON or in XML. When combined with a hostname, this keyword filters the results to contain the desired content type.</li>
				<li><code>200 OK</code>: This corresponds to the successful HTTP status code. You can add this combined with other queries to return only the successful requests. If the target API does not accept Shodan queries, it may return HTTP codes of 300 or 400.</li>
				<li><code>wp-json</code>: When querying <a id="_idIndexMarker232"/>target <strong class="bold">Content Management Systems</strong> (<strong class="bold">CMSs</strong>), such as Joomla or Drupal, this type of query may reveal the presence of one of them. This, in particular, corresponds to the WordPress REST API.</li>
			</ul>
			<p>Let’s see what we <a id="_idIndexMarker233"/>can get with ExploitDB. If you search for the <code>API</code> term, the service will return a reasonable amount of Google dorks, a fair amount being <code>allintext</code>, <code>intitle</code>, and <code>inurl</code>. These represent searches for occurrences in the whole page’s content, in its title only, and in the URL’s name respectively. There are a few that deserve your attention:</p>
			<ul>
				<li><code>allintext:"API_SECRET*" ext:env | ext:yml</code>: Look for the string beginning with <code>API_SECRET</code> inside files whose extensions are either <code>.env</code> or <code>.yml</code>. This is useful since many configurations of applications store sensitive data, such as API keys, inside files with these extensions. An inattentive developer might have pushed them to a public repository. You can also get to know about versions of the implemented API. Old ones may have vulnerabilities.</li>
				<li><code>intitle:"Index of /api/"</code>: You will find websites that list all the files inside their <code>/api</code> web directories. You can find very useful information here for websites that you wouldn’t even imagine were disclosing this.</li>
				<li><code>inurl:execute-api site:amazonaws.com</code>: This lists all sites that have <code>execute-api</code> as part of their URLs. Sites like those are implemented by Amazon API Gateway, a public cloud service that exposes a layer before your actual web background.</li>
			</ul>
			<p>We are not restricted to the<a id="_idIndexMarker234"/> Google search engine. Nowadays, we have online generative AI services that can give us a hand with OSINT as well. Once you build good prompts, I mean, good questions, you can acquire pretty much all of the desired information. These services are being optimized over time and receiving additional guardrails to protect companies and individuals against inadvertent data exposure or leakage. Nevertheless, I can’t guarantee that all data will be fully protected.</p>
			<p>GitHub also has its dorks. Focused on specific file names, you can find relevant information about the API you are inspecting. The following is a small list of dorks that I got after asking such a generative AI service, organized by categories. You can mix and match them at will. The service didn’t want to give them to me at first, but as I said before, with the right prompts and some patience, you will make it:</p>
			<ul>
				<li>Path-based <a id="_idIndexMarker235"/>dorks:<pre class="source-code">
path:/config/
path:/secrets/
path:/keys/
path:/private/
path:/deploy/</pre></li>				<li>Language-specific <a id="_idIndexMarker236"/>dorks:<pre class="source-code">
language:json
language:yaml
language:python
language:javascript
language:ruby</pre></li>				<li>Extension-based<a id="_idIndexMarker237"/> dorks:<pre class="source-code">
extension:yml
extension:json
extension:xml
extension:cfg
extension:config</pre></li>				<li>User or <a id="_idIndexMarker238"/>organization-based dorks:<pre class="source-code">
user:username
org:organization</pre></li>				<li>Size-based<a id="_idIndexMarker239"/> dorks:<pre class="source-code">
size:&gt;1000 (Files larger than 1 KB)
size:&lt;500 (Files smaller than 500 bytes)</pre></li>				<li>Fork and stars<a id="_idIndexMarker240"/> dorks:<pre class="source-code">
fork:true
stars:&gt;100</pre></li>				<li>Date-range<a id="_idIndexMarker241"/> dorks:<pre class="source-code">
created:2022-01-01..2022-12-31
pushed:2022-01-01..2022-12-31
updated:2022-01-01..2022-12-31</pre></li>				<li>License-based<a id="_idIndexMarker242"/> dorks:<pre class="source-code">
license:mit
license:apache-2.0</pre></li>				<li>Text content <a id="_idIndexMarker243"/>dorks:<pre class="source-code">
in:file (Search within file content)
in:readme (Search within README files)
in:description (Search within repository descriptions)</pre></li>				<li>Wildcard<a id="_idIndexMarker244"/> dorks:<pre class="source-code">
*api* (Matches any repository with "api" in its name)
user:*api* (Matches repository with "api" in the username</pre></li>				<li>Some good keywords to reveal the presence of APIs’ sensitive data include the following:<pre class="source-code">
"api key", "api keys", "apikey", "access_token", "authorization: Bearer", "secret", "token"</pre></li>			</ul>
			<p>Moving forward, we are going to learn more about the internal details of APIs by learning their data and schema structures.</p>
			<h1 id="_idParaDest-51"><a id="_idTextAnchor053"/>Identifying data and schema structures</h1>
			<p>We will end our <a id="_idIndexMarker245"/>chapter about API reconnaissance and enumeration by covering a subject as important as all the others. By successfully identifying an API’s data and schema structures, you can acquire even more information about the target. Once you have analyzed the API documentation and endpoints, you need to identify the data and schema structures that are used by the API. This information can be used to understand how the API works and to develop applications that interact with the API.</p>
			<p>The API documentation should provide information about the data and schema structures that are used by the API. However, you may need to analyze the API responses to get a complete understanding of the data and schema structures.</p>
			<p>Some APIs return JSON structures, whereas others prefer to encode responses in XML before sending them to the requester. As a matter of fact, XML was the preferred data transport format for some years because of its flexibility and power. However, the drawback was derived from such advantages as well. The more complex an XML structure is, the more prone to attacks it is as well. Badly written XML interpreters may lead to unexpected application failures and worse, to data exposure or leakage.</p>
			<p>However, first, what are schemas? Like their counterpart in databases, API schemas are metadata used to define how data is structured inside the API. In other words, when requesting and receiving the responses of such requests, you can know in advance which components are expected and which data types they use. This is especially important for one operation in particular: <em class="italic">fuzzing</em>.</p>
			<p>We haven’t talked <a id="_idIndexMarker246"/>about this up to this point yet, but in general terms, fuzzing consists of generating random sequences of characters that are used as input for different interactions with a system. In our case, the system is an API endpoint. After knowing its schema and data structures, you can test the API by sending, for example, symbols to a field that’s expecting a date, or letters to a field that carries quantity. Alternatively, you can refer to a structure, such as a list or array, that does not belong to the data structure, and they check the endpoint behavior. When it is well written, a fuzzing-proof application simply ignores the data and optionally throws warning or error messages stating that a corrupted entry was provided.</p>
			<p>Let’s do some exercises. Leveraging our crAPI deployment and Postman, let’s make a few requests and verify their responses. crAPI expects JSON as input and returns a JSON structure as a response. crAPI already provides a handy collection of Postman requests in its repository. Let’s see what happens when we send something different from JSON. First, we need to log in to get an authorization token. This is our initial test. Let’s replace the JSON portion with, let’s say, an XML format:</p>
			<pre class="source-code">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;email&gt;{{email}}&lt;/email&gt;
&lt;password&gt;{{password}}&lt;/password&gt;</pre>			<p>The <code>{{email}}</code> and <code>{{password}}</code> annotations are conventions Postman uses to refer to variables. I have created variables in my Postman collection to store my login and password, so I don’t have to type them every time I need to log in. I did the same with the authorization token. Well, in this initial test, crAPI returned nothing at all. Let’s move on and log in the right way, with a JSON data structure as input. We just received the token.</p>
			<p>There’s another endpoint that is accessed with a POST verb. It’s called <code>Signup example.com</code>. It expects the following as the request body:</p>
			<pre class="source-code">
{
    "name": "{{name}}",
    "email": "{{email}}",
    "number": "{{phone}}",
    "password": "{{password}}"
}</pre>			<p>When you send the<a id="_idIndexMarker247"/> expected formats, such as the email address and a numeric sequence as the phone number, the API responds with the following:</p>
			<pre class="source-code">
{
    "message": "User registered successfully! Please Login.",
    "status": 200
}</pre>			<p>However, what if we send something slightly different, like this:</p>
			<pre class="source-code">
{
    "name": "{{name}}",
    "email": "304laskdf))(&amp;)&amp;)*",
    "number": "asdf98asd09fans2#$%@#$%",
    "password": "{{password}}"
}</pre>			<p>It seems that crAPI does validate the input somehow, but not exactly in a good way:</p>
			<pre class="source-code">
{
    "message": "Validation Failed",
    "details":
 "org.springframework.validation.BeanPropertyBindingResult: 2 errors\nField error in object 'signUpForm' on field 'number': rejected value [asdf98asd09fans2#$%@#$%]; codes [Size.signUpForm.number,Size.number,Size.java.lang.String,Size]; arguments [org.springframework.context.support.DefaultMessageSourceResolvable: codes [signUpForm.number,number]; arguments []; default message [number],15,0]; default message [size must be between 0 and 15]\nField error in object 'signUpForm' on field 'email': rejected value [304laskdf))(&amp;)&amp;)*]; codes [Email.signUpForm.email,Email.email,Email.java.lang.String,Email]; arguments [org.springframework.context.support.DefaultMessageSourceResolvable: codes [signUpForm.email,email]; arguments []; default message [email],[Ljavax.validation.constraints.Pattern$Flag;@5319e7,.*]; default message [must be a well-formed email address]"
}</pre>			<p>We discovered a <a id="_idIndexMarker248"/>few things with this simple test:</p>
			<ul>
				<li>crAPI definitely uses some flavor of Java as its backend.</li>
				<li>Email and phone are somehow validated, but errors look like exceptions.</li>
				<li>The maximum length of the phone number is 15 characters.</li>
			</ul>
			<p>When you verify the log of the identity container, you’ll find the following exceptions:</p>
			<pre class="console">
2023-12-28 18:34:17.934 DEBUG 8 --- [nio-8080-exec-9] o.s.web.method.HandlerMethod             : Could not resolve parameter [0] in public org.springframework.http.ResponseEntity&lt;com.crapi.model.CRAPIResponse&gt; com.crapi.controller.AuthController.registerUser(com.crapi.model.SignUpForm): JSON parse error: Illegal unquoted character ((CTRL-CHAR, code 10)): has to be escaped using backslash to be included in string value; nested exception is com.fasterxml.jackson.databind.JsonMappingException: Illegal unquoted character ((CTRL-CHAR, code 10)): has to be escaped using backslash to be included in string value
 at [Source: (PushbackInputStream); line: 1, column: 205] (through reference chain: com.crapi.model.SignUpForm["email"])
2023-12-28 18:34:17.934 DEBUG 8 --- [nio-8080-exec-9] .m.m.a.ExceptionHandlerExceptionResolver : Using @ExceptionHandler com.crapi.exception.ExceptionHandler#handleException(Exception, WebRequest)
2023-12-28 18:34:17.935 DEBUG 8 --- [nio-8080-exec-9] o.s.w.s.m.m.a.HttpEntityMethodProcessor  : Using 'application/octet-stream', given [*/*] and supported [*/*]
2023-12-28 18:34:17.935 DEBUG 8 --- [nio-8080-exec-9] .m.m.a.ExceptionHandlerExceptionResolver : Resolved [org.springframework.http.converter.HttpMessageNotReadableException: JSON parse error: Illegal unquoted character ((CTRL-CHAR, code 10)): has to be escaped using backslash to be included in string value; nested exception is com.fasterxml.jackson.databind.JsonMappingException: Illegal unquoted character ((CTRL-CHAR, code 10)): has to be escaped using backslash to be included in string value&lt;LF&gt; at [Source: (PushbackInputStream); line: 1, column: 205] (through reference chain: com.crapi.model.SignUpForm["email"])]</pre>			<p>With this, we have finished our chapter on API reconnaissance and information gathering.</p>
			<h1 id="_idParaDest-52"><a id="_idTextAnchor054"/>Summary</h1>
			<p>This chapter covered important topics on your journey toward pentesting APIs. You learned that you must begin by gathering information about the target and reconning it. After correctly identifying and enumerating the API, you learned that you must read its documentation carefully and find out which endpoints it exposes. This may reveal valuable information, as you learned. Additionally, you learned that you can make use of an extremely useful set of techniques called OSINT, which are extensively applied everywhere by forensic investigators and enthusiasts. The chapter finished with a complementary section about how API data and schema structures are important in this phase.</p>
			<p>In the next chapter, you will learn how to explore the authentication and authorization stages more while pentesting an API. This chapter included some introduction to that topic, but we’ll go into greater depth in the next one with analysis and more tests.</p>
			<h1 id="_idParaDest-53"><a id="_idTextAnchor055"/>Further reading</h1>
			<ul>
				<li>The VirtualBox type 2 hypervisor: <a href="https://www.virtualbox.org/">https://www.virtualbox.org/</a></li>
				<li>The UTM type 2 hypervisor:  <a href="https://mac.getutm.app/">https://mac.getutm.app/</a></li>
				<li>Podman, a superset of Docker: <a href="https://podman.io/">https://podman.io/</a></li>
				<li>The OWASP WebGoat vulnerable web app: <a href="https://owasp.org/www-project-webgoat/">https://owasp.org/www-project-webgoat/</a></li>
				<li>The OWASP crAPI vulnerable API: <a href="https://owasp.org/www-project-crapi/">https://owasp.org/www-project-crapi/</a></li>
				<li>The Zed Attack Proxy scanner: <a href="https://www.zaproxy.org/">https://www.zaproxy.org/</a></li>
				<li>Shodan, an IoT vulnerability search engine: <a href="https://www.shodan.io/">https://www.shodan.io/</a></li>
				<li>Fiddler, a network analysis tool: <a href="https://www.telerik.com/fiddler/fiddler-everywhere">https://www.telerik.com/fiddler/fiddler-everywhere</a></li>
				<li>Wireshark, one of the most famous network packet capture tools: <a href="https://www.wireshark.org/">https://www.wireshark.org/</a></li>
				<li>APIs Guru, a decent list of APIs’ documentation: <a href="https://apis.guru/">https://apis.guru/</a></li>
				<li>ReDoc, utility to build and read API documentation:  <a href="https://github.com/Redocly/redoc">https://github.com/Redocly/redoc</a></li>
				<li>Swagger UI, utility to build and read API documentation: <a href="https://github.com/swagger-api/swagger-ui">https://github.com/swagger-api/swagger-ui</a></li>
				<li>The RFC establishing the HTTP Specification: <a href="https://datatracker.ietf.org/doc/html/rfc2616#page-31">https://datatracker.ietf.org/doc/html/rfc2616#page-31</a></li>
				<li>A report discussing the OSINT growing market: <a href="https://www.businessresearchinsights.com/market-reports/open-source-intelligence-market-109546">https://www.businessresearchinsights.com/market-reports/open-source-intelligence-market-109546</a></li>
				<li>ExploitDB Google Dorks, a list with OSINT cheat sheets: <a href="https://www.exploit-db.com/google-hacking-database/">https://www.exploit-db.com/google-hacking-database/</a></li>
				<li>The OSINT Framework, a vast list of tools and resources about OSINT: <a href="https://osintframework.com/">https://osintframework.com/</a></li>
				<li>Google dork cheat sheet, more resources on OSINT: <a href="https://gist.github.com/ikuamike/c2611b171d64b823c1c1956129cbc055">https://gist.github.com/ikuamike/c2611b171d64b823c1c1956129cbc055</a></li>
				<li>crAPI Postman collections to help automate crAPI requests: <a href="https://github.com/OWASP/crAPI/tree/develop/postman_collections">https://github.com/OWASP/crAPI/tree/develop/postman_collections</a></li>
			</ul>
		</div>
	</body></html>