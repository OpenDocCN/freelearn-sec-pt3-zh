<html><head></head><body>
        

                            
                    <h1 class="header-title">Conclusions</h1>
                
            
            
                


            

            
        
    

        

                            
                    <h1 class="header-title">Recapping the topics you have learned</h1>
                
            
            
                
<p>So far in this book, we covered many topics about Go and information security. The topics covered are useful for a variety of people, including developers, penetration testers, SOC analysts, computer forensic analysts, network and security engineers, and DevOps engineers. Here is a high-level recap of the topics covered:</p>
<ul>
<li>The Go programming language</li>
<li>Working with files</li>
<li>Forensics</li>
<li>Packet capture and injection</li>
<li>Cryptography</li>
<li>Secure shell (SSH)</li>
<li>Brute force</li>
<li>Web applications</li>
<li>Web scraping</li>
<li>Host discovery and enumeration</li>
<li>Social engineering and honeypots</li>
<li>Post exploitation</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">More thoughts on the usage of Go</h1>
                
            
            
                
<p>Go is a great language, and it is a reliable choice for many use cases, but, like any other language, it is not the be-all-and-end-all language. As the old saying goes, "Always choose the best tool for the job." Throughout this book, we looked at the versatility of Go and the standard library. Go is also great for performance, reliability in production, concurrency, and memory usage, but the strong static type system may slow development, making Python a better choice for a simple proof of concept. Interestingly, you can extend Python using Go by writing Python modules in Go.</p>
<p>The C programming language may be a better choice in some situations when you don't want a garbage collector but need to compile the smallest binary possible. Go does provide an unsafe package, which allows you to bypass the type safety, but it does not give as much control as the C language. Go allows you to wrap C libraries and create bindings so that you can utilize any C library that does not have a Go equivalent.</p>
<p>Both Go and the cybersecurity industry show signs of growth. Go is continuing to evolve as a language, and some of the weaker areas of the language are starting to see promising signs. For example, GUI libraries such as Qt and Gtk are being wrapped in Go, and with 3D graphics libraries such as OpenGL also have wrappers. Even mobile development is possible and continuing to improve.</p>
<p>There are other useful packages in the standard library we didn't even cover, such as the <kbd>binary</kbd> package for manipulation binary data, the <kbd>xml</kbd> package for encoding and decoding XML documents, and the <kbd>flag</kbd> package for parsing command-line arguments.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">What I hope you take away from the book</h1>
                
            
            
                
<p>After reading this book, you should have a good idea of what packages are available in the standard library and how versatile Go can be out of the box. You should feel comfortable using Go for a variety of tasks, from simple tasks, such as working with files and making a network connection, to more advanced tasks, such as scraping websites and capturing packets. I also hope you gleaned some tips for writing idiomatic Go code.</p>
<p>The example programs provided should serve as references for building your own tools. Many of the programs are useful as-is and can be incorporated into your toolkit immediately, while a few are meant only to serve as a reference to help you perform common tasks.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Be aware of legal, ethical, and technical boundaries</h1>
                
            
            
                
<p>It is critical to be aware of the possible repercussions for any action you take against a machine or network. There are legal boundaries that can result in a fine or imprisonment, depending on the laws and jurisdiction. For example, in the United States, the <strong>Computer Fraud and Abuse Act</strong> (<strong>CFAA</strong>) makes it illegal to access a computer without authorization. Don't always assume that the client authorizing the scope of your penetration test has the right to authorize you on every device. Companies can lease physical servers or rent virtual or physical space in a data center that they do not own, requiring you to get authorization from other sources as well.</p>
<p>There are also ethical boundaries to be aware of, which are different from the legal boundaries. Ethical boundaries can be a gray area for some people. For example, with social engineering, if you target employees, do you think it is acceptable to attempt the social engineering outside of work hours? Is it acceptable to send phishing emails to their personal email address? Is it acceptable to impersonate another employee and lie to someone? Other aspects of ethics involve how you behave on compromised servers and what you do with the data you find. Is it acceptable to store client data off-site if it was exfiltrated during a penetration test? Is it acceptable to create your own user on a client's production server during a penetration test? Some people may disagree on where the ethical boundary lies for different situations. It is important to be conscious of these types of things and to discuss them with any client prior to an engagement.</p>
<p>In addition to the legal and ethical aspects, it is also imperative to understand the technical repercussions and the physical load your tools put on servers, networks, load balancers, switches, and so on. Make sure that you set sane limits on web crawlers and brute forcers. Also, make sure that you log and track any actions you take so that you can undo any permanent changes. If you are performing a penetration test for a client, you should never leave unnecessary files you created on their servers. For example, if you install a reverse bind shell, make sure that you uninstall it. If you modify file permissions or install a bind shell, make sure that you are not opening up the client to outside attacks.</p>
<p>There are a lot of things to be conscious of when working in the security field, but a lot of it comes down to common sense and being cautious. Respect the servers you are attacking, and don't take any action if you don't understand the implications. If you are unsure, seek guidance from a trusted and experienced peer or the community.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Where to go from here</h1>
                
            
            
                
<p>Start building your toolbox and cookbook. Use the examples that are useful to you and customize them to suit your needs. Take some of the existing examples and expand upon them. Can you think of other ideas? How can you modify some of the programs to be more useful? Are any of the examples useful as-is in your own toolbox? Do they give you any ideas for other custom tools? Explore more of the Go standard library and write applications to fill your toolbox.</p>
<p>Start practicing and using some of the tools provided. You may need to find or build your own test network, or just a simple VM, or find a bug bounty program. If you decide to try out bug bounties, be sure to read the scope and rules with a microscope. To put your new tools and skills in to action, research application testing and network penetration methodologies. If you want to become a penetration tester or just want to learn more about penetration testing methodology and practice in a safe lab environment, then, I highly recommend the <strong>Offensive Security Certified Professional</strong> (<strong>OSCP</strong>) course offered by Offensive Security at <a href="https://www.offensive-security.com/information-security-certifications/oscp-offensive-security-certified-professional/">https://www.offensive-security.com/information-security-certifications/oscp-offensive-security-certified-professional/</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting help and learning more</h1>
                
            
            
                
<p>To learn more about Go, its language design and specification, and the standard library, check out these links:</p>
<ul>
<li>The built-in documentation of godoc</li>
<li>Online Go documentation: <a href="https://golang.org/doc/">https://golang.org/doc/</a></li>
<li>A tour of learning the Go language: <a href="https://tour.golang.org/">https://tour.golang.org/</a></li>
<li>Go standard library documentation: <a href="https://golang.org/pkg/">https://golang.org/pkg/</a></li>
</ul>
<p>Communities are a great place to get help and find others to collaborate. Online communities and in-person communities each have their pros and cons. Here are a few places to seek help for Go:</p>
<ul>
<li>The #go-nuts Freenode.net IRC channel: <a href="http://irc.lc/freenode/go-nuts" target="_blank">http://irc.lc/freenode/go-nuts</a></li>
<li>The Go Forum: <a href="https://forum.golangbridge.org">https://forum.golangbridge.org</a></li>
<li>The Go Nuts mailing list: <a href="https://groups.google.com/group/golang-nuts">https://groups.google.com/group/golang-nuts</a></li>
<li>Local meetups: <a href="https://www.meetup.com">https://www.meetup.com</a></li>
<li>Go FAQ: <a href="https://golang.org/doc/faq">https://golang.org/doc/faq</a></li>
<li>Stack Overflow: <a href="https://stackoverflow.com">https://stackoverflow.com</a></li>
<li>Golang Subreddit: <a href="https://www.reddit.com/r/golang/">https://www.reddit.com/r/golang/</a></li>
</ul>
<p>Continue learning by applying the knowledge learned from this book. Write your own tools to reach your goals. Explore other third-party packages, or consider wrapping or porting a C library that Go is lacking. Experiment with the language. The most important thing is just to continue learning!</p>


            

            
        
    </body></html>