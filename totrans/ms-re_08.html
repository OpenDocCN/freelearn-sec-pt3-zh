<html><head></head><body><div><h1 class="header-title">Sandboxing - Virtualization as a Component for RE</h1>
                
            
            
                
<p>In previous chapters, we have used virtualization software, in particular, VirtualBox or VMware, to set up our Linux and Windows environments to conduct analysis. virtualization worked fine since these virtualization software only support x86 architecture. Virtualization is a very useful component of reverse engineering. In fact, most software is built under x86 architecture.  Virtualization uses the resources of the host machine's CPU via the hypervisor. </p>
<p>Unfortunately, there are other CPU architectures out there that doesn't support virtualization. VirtualBox nor VMware doesn't support these architectures.  What if we were given a non-x86 executable to work with?  And all we have is an operating system installed in an x86 machine. Well, this should not stop us from doing reverse engineering.</p>
<p>To work around this issue, we will be using emulators. Emulators have been around long before the hypervisor was even introduced.  Emulators, basically, emulates a CPU machine.  Treating this as a new machine, operating systems that run on a non-x86 architecture can be deployed.  After then, we can run native executables.</p>
<p>In this chapter, we will learn about QEMU to deploy an non-x86 operating system.  We will also learn about emulating the boot up of an x86 machine using Bochs.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Emulation</h1>
                
            
            
                
<p>The beauty of emulation is that it can fool the operating system into thinking that it is running on a certain CPU architecture. The drawback is noticeably slow performance, since almost every instruction is interpreted. To explain CPUs briefly, there are two CPU architecture designs: <strong>Complex Instruction Set Computing</strong> (<strong>CISC</strong>) and <strong>Reduced Instruction Set Computing</strong> (<strong>RISC</strong>). In assembly programming, CISC would only require a few instructions. For example, a single arithmetic instruction, such as MUL, executes lower-level instructions in it. In RISC, a low-level program should be carefully optimized. In effect, CISC has the advantage of requiring less memory space, but a single instruction would require more time to execute. On the other hand, RISC has better performance, since it executes instructions in a simplistic way. However, if a code is not properly optimized, programs built for RISC may not perform as fast as they should and may consume space. High-level compilers should have the ability to optimize low-level code for RISC.</p>
<p>Here is a short list of CPU architectures, categorized in terms of CISC and RISC:</p>
<ul>
<li>CISC:
<ul>
<li>Motorola 68000</li>
<li>x86</li>
<li>z/Architecture</li>
</ul>
</li>
<li>RISC:
<ul>
<li>ARM </li>
<li>ETRAX CRIS</li>
<li>DEC Alpha</li>
<li>LatticeMico32</li>
<li>MIPS</li>
<li>MicroBlaze</li>
<li>Nios II</li>
<li>OpenRISC</li>
<li>PowerPC</li>
<li>SPARC</li>
<li>SuperH</li>
<li>Hewlett Packard PA-RISC</li>
<li>Infineon TriCore</li>
<li>UNICORE</li>
<li>Xtensa</li>
</ul>
</li>
</ul>
<p>Popular among CISC and RISC architectures are x86 and ARM. x86 is used by Intel and AMD computers, in favor of having a minimum number of instructions used by programs. Newer devices, such as smartphones and other mobile devices, make use of ARM architecture, as it has the advantages of low power consumption with high performance.</p>
<p>For the purpose of discussion in this chapter, we are using ARM as the architecture that we are going to emulate on top of an x86 machine. We chose the ARM architecture since it is currently the most popular processor used in handheld devices today.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Emulation of Windows and Linux under an x86 host</h1>
                
            
            
                
<p>We explained that installing an operating system on a VM follows the architecture of the host machine. For example, a Windows x86 build can only be installed on a VM that is itself installed on an x86 machine. </p>
<p>A lot of Linux operating systems, including Arch Linux, Debian, Fedora, and Ubuntu, have support for running under ARM processors. On the other hand, Windows RT and Windows Mobile were built for devices using ARM CPUs.  </p>
<p>Since we are working on PCs using x86 processors, analyzing a non-x86-based executable still follows the same reverse engineering concepts of static and dynamic analysis. The only addition to these steps is that we would need to set up the environment for which the executable can run and learn the tools that can be used on top of this emulated environment.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Emulators</h1>
                
            
            
                
<p>We are going to introduce two of the most popular emulators: QEMU (Quick Emulator) and Bochs.   </p>
<p>QEMU has a reputation of being the most widely used emulator because of its support for a vast range of architectures, including x86 and ARM. It can also be installed under Windows, Linux, and macOS. QEMU is used from the command line, but there are available GUI tools, such as virt-manager, that can help set up and manage the guest operating system images. virt-manager, however, is only available for Linux hosts. </p>
<p>Bochs is another emulator, but is limited to only supporting x86 architecture. It is worth mentioning this emulator, as it is used to debug the <strong>Memory Boot Record</strong> (<strong>MBR</strong>) code. </p>


            

            
        
    </div>



  
<div><h1 class="header-title">Analysis in unfamiliar environments</h1>
                
            
            
                
<p>Here, the reverse engineering concepts are the same. However, the availability of tools is limited. Static analysis can still be done under an x86 environment, but when we need to execute the file, it would require sandbox emulation.</p>
<p>It is still best to debug native executables locally in the emulated environment. But, if local debugging is slim, one alternative way is to do remote debugging. For Windows, the most popular remote debugging tools are Windbg and IDA Pro. For Linux, we usually use GDB.</p>
<p>Analyzing ARM-compiled executables is not far from the process that we perform with x86 executables. We follow the same steps as we did with x86:</p>
<ol>
<li>Study the ARM low-level language</li>
<li>Do deadlisiting using disassembly tools</li>
<li>Debug the program in the operating system environment</li>
</ol>
<p>Studying the ARM low-level language is done in the same way that we studied x86 instructions. We just need to understand the memory address space, general purpose registers, special registers, stack, and language syntax. That would also include how API functions are called.  </p>
<p>Tools such as IDA Pro, among other ARM disassembly tools, can be used to show the ARM disassembly code of a native ARM executable.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Linux ARM guest in QEMU</h1>
                
            
            
                
<p>Linux ARM can be installed in an ARM CPU guest of QEMU, which runs under a Windows in an x86 CPU. Let's head straight to deploying an Arch Linux ARM, then. Running an Arch Linux instance as a QEMU guest is not that hard because of all the available resources we can download from the internet. For demo purposes, we will be using a pre-installed image of Arch Linux and running it in QEMU. Prepare to download these files:</p>
<ul>
<li>QEMU: <a href="https://qemu.weilnetz.de/">https://qemu.weilnetz.de/</a></li>
<li>Arch Linux image: <a href="http://downloads.raspberrypi.org/arch/images/archlinuxarm-29-04-2012/archlinuxarm-29-04-2012.img.zip">http://downloads.raspberrypi.org/arch/images/archlinuxarm-29-04-2012/archlinuxarm-29-04-2012.img.zip</a></li>
<li>System kernel: <a href="https://github.com/okertanov/pinguin/blob/master/bin/kernel/zImage-devtmpfs">https://github.com/okertanov/pinguin/blob/master/bin/kernel/zImage-devtmpfs</a> <a href="https://github.com/okertanov/pinguin/blob/master/bin/kernel/zImage-devtmpfs"/></li>
</ul>
<p>In this book, we will install QEMU on a Windows host. While installing, <strong>take note of where QEMU was installed</strong>. This is particularly important, as QEMU's path will be used later.</p>
<p>Extract the image file from <kbd>archlinuxarm-29-04-2012.img.zip</kbd> to a new directory, and copy <kbd>zImage-devtmpfs</kbd> into the same directory.</p>
<p>Open a command line in the image and kernel file's directory. Then, execute the following line:</p>
<pre>"c:\Program Files\qemu\qemu-system-arm.exe" -M versatilepb -cpu arm1136-r2 -hda archlinuxarm-29-04-2012.img -kernel zImage-devtmpfs -m 192 -append "root=/dev/sda2" -vga std -net nic -net user</pre>
<p>Here, change <kbd>C:\Program Files\qemu</kbd> to the path where QEMU was installed. This should fire up QEMU with Arch Linux running, as shown here:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1307 image-border" src="img/dca8e425-cb70-404d-83f3-229d47e58296.png" style="width:41.00em;height:34.25em;" width="642" height="536"/></p>
<p>Now, log in using these credentials:</p>
<pre>alarmpi login: root<br/>Password: root</pre>
<p>You can go ahead and play with it like a regular Linux console. Arch Linux is a popular OS installed by enthusiasts of Raspberry Pi.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">MBR debugging with Bochs</h1>
                
            
            
                
<p>When we turn on a computer, the first code that runs is from the BIOS (Basic Input/Output System), a program embedded in the CPU.  It performs a power-on self-test (POST)  that makes sure connected hardware are working properly.  The BIOS loads the master boot record (MBR) to memory and then passes code execution.  The master boot record (MBR) was read from the first disk sector of the designated boot disk.  The MBR contains the bootstrap loader which is responsible for loading an operating system. </p>
<p>If, for example, we want to debug a given MBR image, we can do that with an emulator called Bochs. Bochs can be downloaded from <a href="http://bochs.sourceforge.net/">http://bochs.sourceforge.net/</a>.</p>
<p>To test this out, we have provided a disk image that can be downloaded from <a href="https://github.com/PacktPublishing/Mastering-Reverse-Engineering/blob/master/ch8/mbrdemo.zip">https://github.com/PacktPublishing/Mastering-Reverse-Engineering/blob/master/ch8/mbrdemo.zip</a>. This ZIP archive extracts to about 10MB. The file contains the <kbd>mre.bin</kbd> disk image and the <kbd>bochsrc</kbd> image configuration file that will be passed to Bochs.</p>
<p>If we open the <kbd>mre.bin</kbd> using IDA Pro, we should be able to statically analyze the MBR code. The MBR almost always starts at the <kbd>0x7c00</kbd> address. It is a 16-bit code that uses hardware interrupts to control the computer.  </p>
<p>When loading the file in IDA Pro, make sure to change the loading offset to <kbd>0x7c00</kbd>, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1308 image-border" src="img/f01c86a8-1189-4eea-a220-a728cfa0d6fe.png" style="width:28.17em;height:34.00em;" width="378" height="456"/></p>
<p>When asked about the disassembly mode, choose 16-bit mode. Since everything is still undefined, we need to turn the data into code. Select the first byte code, right-click to open the context menu, then select Code, as shown here:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1309 image-border" src="img/40d220ad-a964-45ab-8a4d-689426c01d22.png" style="width:45.67em;height:13.92em;" width="751" height="229"/></p>
<p>When converted into disassembly code, we can see that IDA Pro was also able to identify the interrupt functions and how these are used. The following screenshot shows 16-bit disassembly and the use of interrupt <kbd>13h</kbd> to read data from disk sectors:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1310 image-border" src="img/cb1146c6-932a-41f9-bce9-ec8d4b3aa36f.png" style="width:53.42em;height:33.58em;" width="960" height="603"/></p>
<p>To debug the MBR with Bochs, we will have to make sure that <kbd>bochsrc</kbd> contains the following line:</p>
<pre>display_library: win32, options="gui_debug"</pre>
<p>This line enables the use of the Bochs GUI debugger.</p>
<p>If we have a different disk image, we can change the file name of the disk image file in the <kbd>at0-master</kbd> line. In this demo, the disk image's filename is <kbd>mre.bin</kbd>:</p>
<pre class="packt_figref">ata0-master: type=disk, path="mre.bin", mode=flat</pre>
<p>To emulate the disk image, execute these commands:</p>
<pre>set $BXSHARE=C:\Program Files (x86)\Bochs-2.6.8<br/>"C:\Program Files (x86)\Bochs-2.6.8\bochsdbg.exe" -q -f bochsrc</pre>
<p>You might need to change <kbd>C:\Program files (x86)\Bochs-2.6.8</kbd> to the path where you have installed Bochs. Take note that, for the <kbd>$BXSHARE</kbd> environment variable, there are no quotes.</p>
<p>Here, Bochs was installed under a Windows environment. The paths can be changed if working in a Linux environment.</p>
<p>Once running, the console will be filled up with logged lines, as shown here:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1311 image-border" src="img/b1310cd3-20ab-4479-9c88-2b89c564d6cd.png" style="width:49.42em;height:22.33em;" width="640" height="289"/></p>
<p>This will bring up the debugging console, which should look like the one shown in this screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1312 image-border" src="img/23c8ac52-51b1-44a8-af00-1e8eddee7420.png" style="width:55.67em;height:35.75em;" width="966" height="620"/></p>
<p>Another window that shows the output should also appear:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1313 image-border" src="img/ff86704e-52f5-41f6-aa57-88430f201331.png" style="width:53.00em;height:36.08em;" width="722" height="492"/></p>
<p>The MBR code begins at the <kbd>0x7c00 </kbd>address. We will have to place a breakpoint at <kbd>0x7c00</kbd>. Bochs GUI has a command line where we get to set the breakpoints at specified addresses. This is located at the bottom of the window. See the highlighted area in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1314 image-border" src="img/1305472c-1266-4cb8-af5f-7490917eb602.png" style="width:52.58em;height:33.83em;" width="966" height="621"/></p>
<p>To set a breakpoint at <kbd>0x7c00</kbd>, enter <kbd>lb 0x7c00</kbd>. To see a the list of commands, enter <kbd>help</kbd>. The most common commands used are the following:</p>
<pre>c             Continue/Run<br/>Ctrl-C        Break current execution<br/>s [count]     Step.  count is the number of instructions to step<br/>lb address    Set breakpoint at address<br/>bpe n         Enable breakpoint where n is the breakpoint number<br/>bpd n         Disable breakpoint where n is the breakpoint number<br/>del n         Delete breakpoint where n is the breakpoint number<br/>info break    To list the breakpoints and its respective numbers </pre>
<p>The GUI has also mapped keyboard keys with the commands. Select the Command menu to view these keys.</p>
<p>Press <em>F5</em> to continue the code, until it reaches the MBR code at <kbd>0x7c00</kbd>. We should now see the same disassembly code that we saw in IDA Pro. We can then start pressing <em>F11</em> to step debug on each instruction line:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1315 image-border" src="img/5db1ddf4-91c2-4b77-9c3b-6151d881e66f.png" style="width:47.75em;height:30.67em;" width="966" height="620"/></p>
<p>At some point, the code will enter an endless loop state. If we look at the output window, the end result should have the same message, as in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1316 image-border" src="img/0e4129c8-d9f1-4db7-b4ce-f380046a868d.png" style="width:52.50em;height:35.83em;" width="723" height="494"/></p>


            

            
        
    </div>



  
<div><h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we have learned that, even if the file is not a Windows or a Linux x86-native executable, we can still analyze a non-x86 executable file. With static analysis alone, we can analyze a file without even doing dynamic analysis, although we still need references to understand the low-level language of non-x86 architectures, categorized as RISC or CISC. Just as we learned x86 assembly language, languages such as ARM assembly can be learned with the same concepts.</p>
<p>However, an analysis can still be proven with actual code execution, using dynamic analysis. To do that, we need to set up the environment where the executable will run natively. We introduced an emulation tool called QEMU that can do the job for us. It has quite a number of architectures that it can support, including ARM. Today, one of the most popular operating system using ARM architecture is Arch Linux. This operating system is commonly deployed by Raspberry Pi enthusiasts.</p>
<p>We also learned about debugging MBR code taken from a disk image. Using Bochs, a tool that can emulate the boot sequence of an x86 system, we were able to show how you can load and debug 16-bit code that uses hardware interrupts. In addition, some ransomware employ features that can inject or replace the MBR with malicious code. With what we learned in this chapter, nothing can stop us from reversing these pieces of code.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Further Reading</h1>
                
            
            
                
<ul>
<li class="CDPAlignLeft CDPAlign">KVM and CPU feature enablement -<a href="https://wiki.qemu.org/images/c/c8/Cpu-models-and-libvirt-devconf-2014.pdf">https://wiki.qemu.org/images/c/c8/Cpu-models-and-libvirt-devconf-2014.pdf</a></li>
<li>A way for installing Windows ARM in QEMU - <a href="https://withinrafael.com/2018/02/11/boot-arm64-builds-of-windows-10-in-qemu/">https://withinrafael.com/2018/02/11/boot-arm64-builds-of-windows-10-in-qemu/</a></li>
<li>How to DEBUG System Code using The Bochs Emulator on a Windows PC - <a href="https://thestarman.pcministry.com/asm/bochs/bochsdbg.html">https://thestarman.pcministry.com/asm/bochs/bochsdbg.html</a></li>
</ul>


            

            
        
    </div>



  </body></html>