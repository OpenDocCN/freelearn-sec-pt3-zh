<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-164"><a id="_idTextAnchor163"/>6</h1>
<h1 id="_idParaDest-165"><a id="_idTextAnchor164"/>Threat Hunting with Wazuh</h1>
<p>Approximately 80% of threats can be mitigated with the assistance of tier 1 and 2 <strong class="bold">security operations center</strong> (<strong class="bold">SOC</strong>) analysts<a id="_idIndexMarker607"/> and automated security tools; the remaining 20% requires your attention. Threat hunting is an important proactive security method for finding threats and holes in security that are hard to spot with regular security measures. Threat hunting uses advanced analytics, threat intelligence, and human expertise to go beyond automated detection and actively seek, find, and fix any security holes or threats that might be hiding in an organization’s network. By being proactive, security teams can spot and stop complex threats before they happen. This reduces the time that attackers can stay on the network and stops possible breaches. In this chapter, we will learn how Wazuh can help security teams to proactively detect advanced threats. Wazuh offers an extensive overview of an organization’s security features by analyzing large amounts of logs, along with offering real-time monitoring, custom advanced rulesets, threat intelligence, MITRE ATT&amp;CK mapping, and much more.</p>
<p>In this chapter, we will cover the following:</p>
<ul>
<li>Proactive threat hunting with Wazuh</li>
<li>Log data analysis for threat hunting</li>
<li>MITRE ATT&amp;CK mapping on Wazuh</li>
<li>Threat hunting using Osquery</li>
<li>Command monitoring</li>
</ul>
<h1 id="_idParaDest-166"><a id="_idTextAnchor165"/>Proactive threat hunting with Wazuh</h1>
<p>Organizations can use Wazuh for <a id="_idIndexMarker608"/>proactive threat hunting, a security practice<a id="_idIndexMarker609"/> that helps them find and report possible security threats before they become significant threats. This can take the form, for example, of analyzing network traffic patterns to detect anomalous behavior that may indicate a potential cyber threat. By contrast, the main goal of reactive cybersecurity defenses is to react to threats once they are identified or after an incident has taken place. As an example, antivirus software detects and eradicates known malware, and firewalls prevent malicious traffic from entering the network based on predefined rules by the security team.</p>
<p>When you do proactive threat hunting, you look for possible risks or weaknesses in a network before any damage can be caused. Instead of waiting for alerts or known signatures, we can use Wazuh to conduct threat hunting by performing real-time log analysis across multiple platforms, correlating events to detect potential security issues, along with integrating third-party tools to enhance our event visibility and detection capabilities.</p>
<p>In this section, we will cover the following:</p>
<ul>
<li>Threat-hunting methodologies</li>
<li>Threat-hunting steps</li>
<li>How to use Wazuh for proactive threat hunting</li>
</ul>
<h2 id="_idParaDest-167"><a id="_idTextAnchor166"/>Threat-hunting methodologies</h2>
<p>When threat hunters look into a <a id="_idIndexMarker610"/>system, they assume that attackers are already there and look for strange behavior that could indicate that bad things are happening. While conducting proactive threat hunting, the first step of looking for a threat usually falls into three main categories:</p>
<ul>
<li><strong class="bold">Hypothesis-based investigation</strong>: Threat hunters often start hypothesis-based investigations when they<a id="_idIndexMarker611"/> find a new<a id="_idIndexMarker612"/> threat within the pool of attack information. This gives them information about the newest <strong class="bold">tactics, techniques, and procedures</strong> (<strong class="bold">TTPs</strong>) that<a id="_idIndexMarker613"/> attackers are using. Once threat hunters have found a new TTP, they check whether the attacker’s unique behaviors are common in their own area. For this, our Wazuh platform needs the following configured:<ul><li>File integrity monitoring rules to detect any unauthorized changes</li><li>Enabling rootkits behavior detection</li><li>Log collection from different security <a id="_idIndexMarker614"/>solutions such as Antivirus, <strong class="bold">Endpoint Detection and Response</strong> (<strong class="bold">EDR</strong>), and email security</li><li>Vulnerability <a id="_idIndexMarker615"/>detection</li><li>Command<a id="_idIndexMarker616"/> monitoring</li></ul></li>
<li><strong class="bold">Intelligence-based hunting</strong>: Intelligence-based hunting<a id="_idIndexMarker617"/> is a way to actively<a id="_idIndexMarker618"/> look for threats in response to different sources of intelligence. IOCs, IP addresses, hash values, and domain names are some of the threat intelligence sources that you can exploit. In order to accomplish this, Wazuh should be integrated with the following:<ul><li>Third-party threat intelligence tools such as VirusTotal or AbuseIPDB</li><li>MISP</li><li>OpenCTI</li></ul><p class="list-inset">Host or <a id="_idIndexMarker619"/>network artifacts from <strong class="bold">computer emergency response teams</strong> (<strong class="bold">CERTs</strong>) or <strong class="bold">information sharing and analysis centers</strong> (<strong class="bold">ISACs</strong>) allow <a id="_idIndexMarker620"/>you to export automated warnings or communicate crucial information about fresh threats in other businesses. These are mostly paid services, but they do offer highly curated information.</p></li>
<li>Investigation using <strong class="bold">indicators of attack </strong>(<strong class="bold">IOA</strong>): This is one of the most popular and widely used <a id="_idIndexMarker621"/>methods <a id="_idIndexMarker622"/>for threat hunting. The idea is simple: “Not every threat group is after you” or even if they are, why you should prioritize them. The first step is to identify the threat group based on its target location, industry, and software by using a free detection<a id="_idIndexMarker623"/> playbook called <strong class="bold">ATT&amp;CK Navigator</strong>. This online platform is built by MITRE, a not-for-profit organization that <a id="_idIndexMarker624"/>operates <strong class="bold">Federally Funded Research and Development Centers</strong> (<strong class="bold">FFRDCs</strong>) in the United States.</li>
</ul>
<h2 id="_idParaDest-168"><a id="_idTextAnchor167"/>Threat-hunting steps</h2>
<p>A proactive threat-hunting method <a id="_idIndexMarker625"/>consists of three stages: the <em class="italic">initial trigger phase</em>, the <em class="italic">investigation phase</em>, and the <em class="italic">resolution phase</em> (or, in some situations, an escalation to other teams as part of a communications or action plan). Let’s examine these three steps of the threat-hunting process in more detail:</p>
<ol>
<li><strong class="bold">Choosing the </strong><strong class="bold">right trigger</strong><ul><li>Threat <a id="_idIndexMarker626"/>hunting is usually an in-depth effort. The threat hunter gathers data about the environment and formulates hypotheses on potential threats.</li><li>Next, the threat hunter selects a trigger for further investigation. This might be a specific system, an area of the network, a hypothesis brought on by a disclosed vulnerability or patch, knowledge of a zero-day exploit, an abnormality seen in the security dataset, or a request coming from another department within the company.</li></ul></li>
<li><strong class="bold">Investigation</strong><ul><li>After a trigger has <a id="_idIndexMarker627"/>been identified, the hunt continues to focus on proactively looking for anomalies that support or contradict the theoretical threat.</li><li>The threat hunter works with the assumption that “<em class="italic">My network is compromised by a new malware or exploit</em>” and conducts reverse engineering to prove the assumption.</li><li>Threat hunters employ a variety of tools to help them analyze logs from multiple devices and security controls including server logs, Sysmon, antivirus logs, and<a id="_idIndexMarker628"/> spam filter logs.</li></ul></li>
<li><strong class="bold">Resolution </strong><strong class="bold">and reporting</strong><p class="list-inset">During the investigative<a id="_idIndexMarker629"/> phase, threat hunters gather crucial information and provide answers to the following questions:</p><ul><li><em class="italic">Who?</em> – i.e., perhaps an insider threat was involved</li><li><em class="italic">What?</em> – A timeline of incidents in chronological order</li><li><em class="italic">Where?</em> – Details of the affected system including computers and servers</li><li><em class="italic">Why?</em> – A lack of security controls, poor planning, human error, an external attack, and so on</li></ul><p class="list-inset">This information is circulated to other teams and tools during the resolution phase so that they may respond, prioritize, analyze, or retain the data for future use.</p></li>
</ol>
<h2 id="_idParaDest-169"><a id="_idTextAnchor168"/>Proactive threat hunting with Wazuh</h2>
<p>Proactive threat hunting<a id="_idIndexMarker630"/> with Wazuh entails an ongoing and methodical <a id="_idIndexMarker631"/>search for indicators of potential security threats in the environment of your organization. To conduct threat hunting, Wazuh can be leveraged by security teams for comprehensive log data analysis, seamless integration with MITRE ATT&amp;CK, and the utilization of Osquery (an endpoint analytics tool) and regular monitoring. Let’s cover each of these Wazuh capabilities in detail:</p>
<ul>
<li><strong class="bold">Log data analysis</strong>: Threat <a id="_idIndexMarker632"/>detection is significantly more <a id="_idIndexMarker633"/>effective when log data generated<a id="_idIndexMarker634"/> by various devices and systems within an organization is analyzed. Wazuh functions as a centralized platform for log management and analysis, receiving and examining data from a wide range of origins, including endpoints, servers, and network devices. In order to conduct a log analysis of each of the devices in your network, you need to have decoders for each of them. Wazuh extracts meaningful information from log data obtained from various sources using decoders.</li>
<li><strong class="bold">MITRE ATT&amp;CK mapping</strong>: The <a id="_idIndexMarker635"/>internationally acclaimed MITRE <strong class="bold">Adversarial Tactics, Techniques, and Common Knowledge</strong> (<strong class="bold">ATT&amp;CK</strong>) framework offers a thorough, current knowledge base on adversary tactics and techniques. Wazuh uses MITRE ATT&amp;CK to map observed security events to certain ATT&amp;CK approaches, improving threat-hunting capabilities. Security teams can gain a better understanding of prospective adversaries’ strategies by using this mapping.</li>
<li><strong class="bold">Osquery integration</strong>: An open-source, cross-platform endpoint security framework called Osquery<a id="_idIndexMarker636"/> enables organizations to communicate with and query their endpoint devices to obtain important data for threat hunting. Wazuh and Osquery combine to give an organization’s endpoints a comprehensive picture with endpoint visibility and live querying.</li>
<li><strong class="bold">Command monitoring</strong>: You can use Wazuh’s command tracking feature to track the output of certain commands and treat that output as log content. Command monitoring<a id="_idIndexMarker637"/> can be used for threat hunting to monitor many system properties, such as disk space usage, load averages, changes in network listeners, and the state of <a id="_idIndexMarker638"/>processes that are already<a id="_idIndexMarker639"/> running.</li>
</ul>
<p>Let’s get some deeper and more practical knowledge of Wazuh’s log data analysis functionality. This capability of Wazuh helps us to perform manual threat hunting by analyzing tons of log information.</p>
<h1 id="_idParaDest-170"><a id="_idTextAnchor169"/>Log data analysis for threat hunting</h1>
<p><strong class="bold">Log data analysis</strong> is a<a id="_idIndexMarker640"/> critical component of threat hunting. It involves inspecting and retrieving useful information from log files generated by various systems, applications, and devices. Traditional security methods may miss suspicious patterns or events, but threat hunters can detect them through constant monitoring and analysis of logs. Threat hunters examine log data in search of certain <strong class="bold">Indicators of Compromise</strong> (<strong class="bold">IOCs</strong>). These<a id="_idIndexMarker641"/> IOCs could be domain names, IP addresses, file hashes, or other identifiers linked to known security risks. The problem is that not all logs are the same. Depending on the source of the logs you want to gather, you may need to create a tailored Wazuh decoder. In this section, we will review the following:</p>
<ul>
<li>Wazuh decoders</li>
<li>Building decoders</li>
<li>Log collection</li>
<li>Log data analysis</li>
</ul>
<h2 id="_idParaDest-171"><a id="_idTextAnchor170"/>Wazuh decoders</h2>
<p>A <strong class="bold">Wazuh decoder</strong> is a <a id="_idIndexMarker642"/>component that interprets and extracts useful information from raw log data. It collects data from log files or events created by many sources, such as operating systems, applications, and network devices, and converts it into a standardized format that can easily be analyzed and related. We don’t have to create decoders every time we onboard a new endpoint as Wazuh has a selection of prebuilt decoders for sources such as Linux, Windows, and macOS.</p>
<p>Wazuh decoders are normally provided as XML files and stored at <code>/var/ossec/etc/decoders</code>. Each decoder is tailored to a certain log source such as <code>0025-apache_decoders.xml</code> for Apache, <code>0100-fortigate_decoders.xml</code> for FortiGate firewalls, and so on. These decoders specify how to parse log data, extract pertinent information (such as timestamps, IP addresses, user IDs, and so on), and transform it into a structured format suitable for security analysis and threat hunting. Wazuh decoders are extremely customizable, allowing users to create custom decoders for specific log sources as needed.</p>
<h2 id="_idParaDest-172"><a id="_idTextAnchor171"/>Building decoders</h2>
<p>Creating a custom <a id="_idIndexMarker643"/>Wazuh decoder begins with the creation of an XML file that explains how to decode and parse log data from a given source. If you want to build a custom decoder, you need to first take a look at an example event from the source. For example, let’s take a Check Point Firewall log from the decoder file available on GitHub at <a href="https://github.com/wazuh/wazuh-ruleset/blob/master/decoders/0050-checkpoint_decoders.xml">https://github.com/wazuh/wazuh-ruleset/blob/master/decoders/0050-checkpoint_decoders.xml</a>:</p>
<pre class="source-code">
Jan 21 15:15:45 myCP Checkpoint: 21Jan2019 15:15:45 monitor 10.0.10.1 &lt;bond0 Protection Name:Header Rejection;Severity:4;Confidence Level:4;protection_id:HttpHeaderRejection;SmartDefense Profile:SU2_Protection;Performance Impact:2;Industry Reference:CVE-2002-0032, CAN-2003-0237, CAN-2002-0254, CVE-2002-0155, CAN-2003-0397, CAN-2002-0314;Protection Type:protection;Signature Info:^User-Agent[^I ]*:[^I ]*.*esb|ESB;Update Version:634182243;rule:26;rule_uid:{405CB782-3274-4D7F-8AAA-4FB24CE726A0};resource:&lt;http://dnl-02.geo.kaspersky.com/bases/av/kdb/i386/kdb-i386-1211g.xml.klz;reject_id:5accf7c4-10053-c00080a-c0000003;web_client_type:Other:&gt; *BcfBAAAAgCCAAEFBAAwQfKXVzrzGvyfPESboPxow0mHhxRLAXAQAAIAAKAA=;Attack Info:WSE0100001 header rejection pattern found in request;attack:Header Rejection;src:10.20.10.1;dst:1.1.1.1;proto:6;proxy_src_ip:10.10.10.1;product:SmartDefense;service:80;s_port:51642;FollowUp:Not Followed;product_family:Network</pre> <p>Once you have the log, pay close attention to its format. Divide your log into two parts: <em class="italic">prematch</em> and <em class="italic">custom match</em>. <code>Jan 21 15:15:45 myCP Checkpoint: 21Jan2019 15:15:45</code>. Second, the <strong class="bold">custom match</strong> section varies every time. We can also call these the <em class="italic">parent decoder</em> and <em class="italic">child decoder</em> respectively. Let’s begin by writing the prematch decoder first.</p>
<h3>Parent decoder</h3>
<p>When creating a <a id="_idIndexMarker644"/>Wazuh decoder, it is a good practice to create a parent decoder and then a child decoder to simplify and organize the decoder rules in a file. The parent decoder usually consists of the date, time, and device name, and the child decoder consists of a specific pattern match. To extract the relevant information from the logs, we need to use a regular expression. A regular expression is a sequence of characters defining a search. The parent decoder is defined using the following <code>&lt;</code><code>prematch&gt;</code> tags:</p>
<pre class="source-code">
&lt;decoder name="checkpoint-syslog"&gt;
  &lt;program_name&gt;^Checkpoint&lt;/program_name&gt;
  &lt;prematch&gt;^\\s*\\S+ \\d\\d:\\d\\d:\\d\\d &lt;/prematch&gt;
&lt;/decoder&gt;</pre> <p>In the preceding regular expression, we can see the following:</p>
<ul>
<li>The <code>\d</code> operator is used to denote numeric characters from 0 to 9 for the time field.</li>
<li>The <code>\s</code> operator is used to represent alphabetical characters from <code>a</code> to <code>z</code>.</li>
</ul>
<h3>Child decoder</h3>
<p>The following <a id="_idIndexMarker645"/>decoder rule already exists in the Wazuh decoder ruleset with the filename <code>0050-checkpoint_decoders.xml</code>. To extract further information from the Check Point firewall log, multiple decoder rules have to be created. These are used to extract items such as the source IP address, destination IP address, source port, destination port, and service. All the rules must start with the parent decoder “<code>checkpoint-syslog</code>”:</p>
<pre class="source-code">
&lt;decoder name="checkpoint-syslog-fw"&gt;
  &lt;parent&gt;checkpoint-syslog&lt;/parent&gt;
  &lt;type&gt;firewall&lt;/type&gt;
  &lt;prematch offset="after_parent"&gt;^drop|^accept|^reject&lt;/prematch&gt;
  &lt;regex offset="after_parent"&gt;^(\\w+)\\s+\\S+ \\p\\S+ rule:\\.+&lt;/regex&gt;
  &lt;regex&gt;src: (\\S+); dst: (\\S+); proto: (\\S+);&lt;/regex&gt;
  &lt;order&gt;action,srcip,dstip,protocol&lt;/order&gt;
&lt;/decoder&gt;
&lt;decoder name="checkpoint-syslog-fw"&gt;
  &lt;parent&gt;checkpoint-syslog&lt;/parent&gt;
  &lt;type&gt;firewall&lt;/type&gt;
  &lt;regex offset="after_regex"&gt;service: (\\d+); s_port: (\\d+);&lt;/regex&gt;
  &lt;order&gt;dstport,srcport&lt;/order&gt;
&lt;/decoder&gt;
&lt;decoder name="checkpoint-syslog-ids"&gt;
  &lt;parent&gt;checkpoint-syslog&lt;/parent&gt;
  &lt;type&gt;ids&lt;/type&gt;
  &lt;prematch offset="after_parent"&gt;^monitor|^drop&lt;/prematch&gt;
  &lt;regex offset="after_prematch"&gt;attack:\\s*(\\.+);\\s*&lt;/regex&gt;
  &lt;regex&gt;src:\\s*(\\S+);\\s*dst:\\s*(\\S+);\\s*&lt;/regex&gt;
  &lt;regex&gt;proto:\\s*(\\S+);&lt;/regex&gt;
  &lt;order&gt;extra_data, srcip, dstip, protocol&lt;/order&gt;
  &lt;fts&gt;name, extra_data, srcip, dstip&lt;/fts&gt;
  &lt;ftscomment&gt;First time Checkpoint rule fired.&lt;/ftscomment&gt;
&lt;/decoder&gt;</pre> <p>While you are building your<a id="_idIndexMarker646"/> decoder, you can get help from the Wazuh built-in decoder validator module by running <code>/var/ossec/bin/wazuh-logtest</code>. You can also perform this test on the Wazuh dashboard by navigating to <strong class="bold">Ruleset Test</strong> under the <strong class="bold">Tools</strong> section. Once you execute the module, you need to enter your original Check Point log:</p>
<div><div><img alt="Figure 6.1 – Executing Wazuh’s decoder validator" src="img/B19549_6_01.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.1 – Executing Wazuh’s decoder validator</p>
<p>In the preceding screenshot, we<a id="_idIndexMarker647"/> can see the following:</p>
<ul>
<li>The phase 1 output shows the pre-decoding, which simply takes the log and processes it</li>
<li>The phase 2 and phase 3 output shows that the decoder name <code>checkpoint-syslog-ids</code> has been detected<a id="_idIndexMarker648"/> properly and we receive information such as <code>srcip</code>, <code>dstip</code>, protocol, and <code>extra_data</code></li>
</ul>
<p>After creating both the parent and child decoders, we need to create a Wazuh rule to trigger an alert once there is a match.</p>
<h2 id="_idParaDest-173"><a id="_idTextAnchor172"/>Creating Wazuh rules</h2>
<p>Wazuh rules examine the <a id="_idIndexMarker649"/>extracted decoder fields to determine the type of message received. The final rule that is matched determines whether an alert is created, as well as its level and category groups. For any event that triggers the Check Point FW decoders, the following grouping rule will issue an alert:</p>
<pre class="source-code">
&lt;group name="checkpoint-syslog,"&gt;
  &lt;!--Generic rule --&gt;
  &lt;rule "d="64"00" lev"l""3"&gt;
    &lt;decoded_as&gt;checkpoint-syslog&lt;/decoded_as&gt;
    &lt;description&gt;Checkpoint $(type) event&lt;/description&gt;
  &lt;/rule&gt;</pre> <p>In the preceding code, <code>&lt;decoded_as&gt;</code> represents the name of the decoder.</p>
<p>Alright, we have learned to create a decoder and the corresponding Wazuh rule, taking a Check Point firewall log as an example. Once you have a decoder, you can then create a Wazuh rule. If there is a match against any of the events received by the Wazuh manager, it will generate a security alert on the dashboard. To conduct a comprehensive threat-hunting program, all types of events have to be available on the Wazuh platform and hence, building a custom decoder should also be part of this process. In the next section, we will learn how Wazuh collects and categorizes different types of log data.</p>
<h2 id="_idParaDest-174"><a id="_idTextAnchor173"/>Log data collection</h2>
<p><strong class="bold">Log data collection</strong> means getting<a id="_idIndexMarker650"/> logs from different network sources and putting them all together. It is critical for threat hunters to access all types of logs from across endpoints, servers, security devices, and so on. The Wazuh indexer is responsible for log analysis as it stores and indexes alerts generated by the Wazuh server. By default, Wazuh will give you alerts that are triggered by Wazuh rules. However, we need access to all the events for better threat-hunting practice. We will learn to pull out all the events and archive them on the Wazuh server. Let’s first discuss the different indices used <a id="_idIndexMarker651"/>to store our event types.</p>
<h3>wazuh-alerts</h3>
<p>This is the default index<a id="_idIndexMarker652"/> that stores<a id="_idIndexMarker653"/> the alerts generated by the Wazuh server. When normal events get triggered by a rule with high priority, we see the alert and it gets stored in the <code>wazuh-alerts</code> index.</p>
<p>All the information in the <code>wazuh-alerts </code>index. To see the <code>wazuh-alerts</code> index, navigate to the <code>wazuh-alerts</code> index will be selected.</p>
<div><div><img alt="Figure 6.2 – wazuh-alerts index" src="img/B19549_6_02.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.2 – wazuh-alerts index</p>
<h3>wazuh-archives</h3>
<p>This index keeps track of all <a id="_idIndexMarker654"/>events that come in from the Wazuh server, even if they don’t set off<a id="_idIndexMarker655"/> alerts. The <code>wazuh-archives</code> index stores logs and allows queries that give more information about what’s happening on monitored endpoints. <code>wazuh-archives</code> is disabled by default to save space on the Wazuh server. Remember, to run an effective threat-hunting program, it is crucial to enable this index. Please follow these steps to turn it on, and once it is configured, two new files will be created to store all the events, <code>/var/ossec/logs/archives/archives.log</code> and <code>/var/ossec/logs/archives/archives.log</code>:</p>
<ol>
<li><code>/var/ossec/etc/ossec.conf</code> file, set the value of <code>&lt;logall&gt;</code> and <code>&lt;logall_json&gt;</code> to <code>yes</code>:<pre class="source-code">
&lt;ossec_config&gt;
  &lt;global&gt;
    &lt;jsonout_output&gt;yes&lt;/jsonout_output&gt;
    &lt;alerts_log&gt;yes&lt;/alerts_log&gt;
    &lt;logall&gt;yes&lt;/logall&gt;
    &lt;logall_json&gt;yes&lt;/logall_json&gt;
&lt;/ossec_config&gt;</pre></li> <li><strong class="bold">Restart the Wazuh manager</strong>: In order for the Wazuh manager to put into effect your changes, you are required to restart it with the following command:<pre class="source-code">
<code>filebeat</code> service by editing <code>/etc/filebeat/filebeat.yml</code> and changing <code>archives:</code> value to <code>true</code>.</p><p class="list-inset">Next, restart the <code>filebeat</code> service as follows:</p><pre class="source-code">
<code>wazuh-archives</code> index, go to <strong class="bold">Stack management</strong> &gt; <strong class="bold">index patterns</strong> and click on <strong class="bold">Create </strong><strong class="bold">index pattern</strong>.</li>
</ol>
<div><div><img alt="Figure 6.3 – Create index pattern" src="img/B19549_6_03.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.3 – Create index pattern</p>
<ol>
<li value="5"><code>wazuh-archives-*</code> index pattern to match all available <a id="_idIndexMarker656"/>indices, as shown in the following screenshot, and<a id="_idIndexMarker657"/> click on <strong class="bold">Next step</strong>.</li>
</ol>
<div><div><img alt="Figure 6.4 – Define index pattern" src="img/B19549_6_04.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.4 – Define index pattern</p>
<ol>
<li value="6"><code>timestamp</code> in<a id="_idIndexMarker659"/> the <strong class="bold">Time </strong><strong class="bold">field </strong>box.</li>
</ol>
<div><div><img alt="Figure 6.5 – Set primary time field" src="img/B19549_6_05.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.5 – Set primary time field</p>
<ol>
<li value="7"><strong class="bold">View the dashboard</strong>: Now, to view the events on the dashboard, navigate to <strong class="bold">Discover</strong> under <strong class="bold">OpenSearch Dashboards</strong>.</li>
</ol>
<div><div><img alt="Figure 6.6 – Discover under the OpenSearch Dashboards menu" src="img/B19549_6_06.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.6 – Discover under the OpenSearch Dashboards menu</p>
<p>Make sure <a id="_idIndexMarker660"/>you select<a id="_idIndexMarker661"/> the <strong class="bold">wazuh-archives</strong> index and finally, we get all the events.</p>
<div><div><img alt="Figure 6.7 – Select wazuh-archives" src="img/B19549_6_07.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.7 – Select wazuh-archives</p>
<h3>wazuh-monitoring</h3>
<p>This index keeps track of<a id="_idIndexMarker662"/> information about the state of Wazuh agents over time. The <a id="_idIndexMarker663"/>Wazuh agent’s state could be <em class="italic">Pending</em>, <em class="italic">Active</em>, <em class="italic">Disconnected</em>, or <em class="italic">Never Connected</em>. This information is very helpful for finding Wazuh agents that aren’t reporting to the dashboard for a number of reasons that need to be looked into. If you want to see all the events from the <code>wazuh-monitoring</code> index, navigate to <strong class="bold">Discover</strong> and then change the index to <strong class="bold">wazuh-monitoring</strong>.</p>
<div><div><img alt="Figure 6.8 – Select wazuh-monitoring" src="img/B19549_6_08.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.8 – Select wazuh-monitoring</p>
<p>Everything you see<a id="_idIndexMarker664"/> under the <strong class="bold">Agents</strong> tab comes from the wazuh-monitoring <a id="_idIndexMarker665"/>index.</p>
<div><div><img alt="Figure 6.9 – Wazuh Agents tab" src="img/B19549_6_09.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.9 – Wazuh Agents tab</p>
<h3>wazuh-statistics</h3>
<p>This index holds<a id="_idIndexMarker666"/> information <a id="_idIndexMarker667"/>about the Wazuh server’s overall performance. This information is very important for making sure that the Wazuh server uses its computing resources in the best way possible.</p>
<h2 id="_idParaDest-175"><a id="_idTextAnchor174"/>Log data analysis</h2>
<p>Log data analysis is<a id="_idIndexMarker668"/> a critical component of threat hunting because it gives you a lot of information about the activities of systems, and networks. This information helps you find security threats early, spot unusual activity and also helps you find IOCs. Also note that log collection and log analysis are also important in incident response, forensic investigations, security compliance, and many more areas. Let’s do some live testing with our <code>wazuh-archives</code> log events. We will run some notable MITRE ATT&amp;CK techniques on Windows Server 2012 Server using APT Simulator and then we will conduct some log data analysis. Let’s get started:</p>
<p class="callout-heading">Prerequisites</p>
<p class="callout">You will need Windows Server 2012 or higher.</p>
<ol>
<li><strong class="bold">Sysmon installation</strong>: In this first step, we need to install Sysmon and integrate it with Wazuh. Please refer to <a href="B19549_02.xhtml#_idTextAnchor042"><em class="italic">Chapter 2</em></a><em class="italic">, Malware Detection Using Wazuh</em>, the <em class="italic">Integrating Sysmon to detect fileless malware</em> section in particular, as it covers the step-by-step process to install Sysmon on Windows machines.</li>
<li><code>APTSimulator-0.9.4</code> folder, and execute the <code>APTSimulator.bat</code> file.<p class="list-inset">Type <code>0</code>. This will run every test including collection, command and control, credential access, defense evasion, discovery, execution, lateral movement, persistence, and privilege escalation.</p></li>
<li><code>agent.id</code>. In my case, <code>agent.id</code> is <code>002</code>.</li>
</ol>
<div><div><img alt="Figure 6.10 – Visualizing APT alerts" src="img/B19549_6_10.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.10 – Visualizing APT alerts</p>
<p>We have learned to create custom decoders, covered the different Wazuh log data indices, and analyzed the log data. In the next section, we will explore the MITRE ATT&amp;CK framework and how Wazuh maps the MITRE ATT&amp;CK tactics and techniques.</p>
<h1 id="_idParaDest-176"><a id="_idTextAnchor175"/>MITRE ATT&amp;CK mapping</h1>
<p>We cannot begin threat hunting by<a id="_idIndexMarker670"/> assuming everyone in the world is after us. We need a targeted threat actor or threat campaign-based approach. This is where both Wazuh and MITRE ATT&amp;CK become helpful. Wazuh can collect and trigger any alerts, but for threat hunting, we need to focus on relevant and high-priority threats to our business and need to map this to our Wazuh rules. The MITRE ATT&amp;CK framework helps threat hunters to focus on these kinds of threats and Wazuh allows us to map each of the techniques of those threat actors to Wazuh rules. As a result, threat hunters can hone their focus and save tremendous amounts of time. In this section, we will cover the following topics:</p>
<ul>
<li>What is MITRE ATT&amp;CK?</li>
<li>The ATT&amp;CK framework</li>
<li>Prioritizing the adversary’s techniques</li>
<li>MITRE ATT&amp;CK mapping</li>
</ul>
<h2 id="_idParaDest-177"><a id="_idTextAnchor176"/>What is MITRE ATT&amp;CK?</h2>
<p>The <strong class="bold">MITRE ATT&amp;CK</strong> framework<a id="_idIndexMarker671"/> was developed by the MITRE Corporation to provide a uniform taxonomy for analyzing and categorizing cyber threats. It provides a common language that both defensive and offensive teams in security operations can utilize to improve their capabilities.</p>
<h3>Tactics, techniques, and procedures (TTPs)</h3>
<p>The <strong class="bold">MITRE ATT&amp;CK framework</strong> is used <a id="_idIndexMarker672"/>to categorize and comprehend cyber attackers’ <strong class="bold">tactics, methods, and procedures</strong> (<strong class="bold">TTPs</strong>) during security operations. TTPs are used for organizing <a id="_idIndexMarker673"/>threat intelligence, threat detection, building an effective incident response, conducting a security gap analysis, and threat hunting. Let’s first understand what the TTP concept involves:</p>
<ul>
<li><strong class="bold">Tactics</strong>: These are the main modes of action that attackers use to reach their targets. Consider tactics as the “<em class="italic">what</em>” of an attack, such as gaining initial access or causing damage.</li>
<li><strong class="bold">Techniques</strong>: Techniques are precise ways or acts that attackers use to carry out their tactics. They are the “<em class="italic">how</em>” of an attack, outlining the processes or tools utilized to achieve an objective.</li>
<li><strong class="bold">Procedures</strong>: Procedures involve greater levels of specificity and detail in comparison to techniques. Procedures are like “<em class="italic">step-by-step instructions</em>” for carrying out an attack.</li>
</ul>
<h2 id="_idParaDest-178"><a id="_idTextAnchor177"/>ATT&amp;CK framework</h2>
<p>MITRE ATT&amp;CK is made up of several<a id="_idIndexMarker674"/> critical components that work together to provide a thorough understanding of adversary TTPs:</p>
<ul>
<li>Matrices</li>
<li>Tactics</li>
<li>Techniques</li>
<li>Procedures</li>
<li>Groups</li>
<li>Software</li>
</ul>
<h3>Matrices</h3>
<p>The ATT&amp;CK framework has <a id="_idIndexMarker675"/>three matrices: <em class="italic">Enterprise</em>, <em class="italic">Mobile</em>, and <em class="italic">Cloud</em>. The Enterprise Matrix is the most widely used matrix in the ATT&amp;CK framework. Let’s understand some of the technologies covered under each of these matrices as follows:</p>
<div><div><img alt="Figure 6.11 – MITRE ATT&amp;CK matrices" src="img/B19549_6_11.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.11 – MITRE ATT&amp;CK matrices</p>
<ul>
<li>The Enterprise Matrix contains information about platforms such as Windows, macOS, Azure, Office 365, SaaS, IaaS, network, and cloud</li>
<li>The Mobile Matrix covers techniques used by adversaries related to Android or iOS</li>
<li>ICS covers industrial <a id="_idIndexMarker676"/>control system-related tactics and techniques</li>
</ul>
<p>Throughout this chapter, our primary focus will be on the Enterprise Matrix.</p>
<h3>Tactics</h3>
<p>MITRE ATT&amp;CK provides 14 <strong class="bold">tactics</strong> that consist <a id="_idIndexMarker677"/>of several sets of techniques. In the following screenshot, you can see at the top of each column all of the tactics, and under each tactic column, you can find several techniques.</p>
<div><div><img alt="Figure 6.12 – MITRE ATT&amp;CK Tactics" src="img/B19549_6_12.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.12 – MITRE ATT&amp;CK Tactics</p>
<h3>Techniques</h3>
<p><strong class="bold">Techniques</strong> are <a id="_idIndexMarker678"/>specific means or procedures used by opponents to carry out tactics. For example, under the <em class="italic">Execution tactic</em>, you might find techniques such as <em class="italic">Command-Line Interface</em> or <em class="italic">Scripting</em>. Visit <a href="http://attack.mitre.org">attack.mitre.org</a> and click on any technique to display a list of sub-techniques. As an example, I selected the <strong class="bold">Reconnaissance </strong>tactic, then under that I clicked on the <strong class="bold">Gather Victim Network Information</strong> technique, and as a result, I got six sub-techniques: <strong class="bold">Domain Properties</strong>, <strong class="bold">DNS</strong>, <strong class="bold">Network Trust Dependencies</strong>, <strong class="bold">Network Topology</strong>, <strong class="bold">IP Addresses</strong>, and <strong class="bold">Network Security Appliances</strong> as shown in the following screenshot.</p>
<div><div><img alt="Figure 6.13 – MITRE ATT&amp;CK techniques" src="img/B19549_6_13.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.13 – MITRE ATT&amp;CK techniques</p>
<h3>Procedures</h3>
<p><strong class="bold">Procedures</strong> describe step <a id="_idIndexMarker679"/>by step and in detail how adversaries perform various techniques. In our preceding example, we got six sub-techniques. Click on any of those <a id="_idIndexMarker680"/>sub-techniques and you will land on a page with a list of example procedures.</p>
<div><div><img alt="Figure 6.14 – MITRE ATT&amp;CK procedures" src="img/B19549_6_14.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.14 – MITRE ATT&amp;CK procedures</p>
<h3>Groups</h3>
<p><strong class="bold">Groups</strong> are sets of threat<a id="_idIndexMarker681"/> actors or cybercriminal organizations that are known to use specific TTPs. You can refer to a list of all threat actors documented by MITRE ATT&amp;CK at <a href="https://attack.mitre.org/groups/">https://attack.mitre.org/groups/</a>.</p>
<h3>Software</h3>
<p><strong class="bold">Software</strong> lists the exact <a id="_idIndexMarker682"/>pieces of malware, tools, and software that attackers use to carry out their objectives. This helps threat hunters to identify the threat group based on the tools they use.</p>
<h2 id="_idParaDest-179"><a id="_idTextAnchor178"/>Prioritizing the adversary’s techniques</h2>
<p>ATT&amp;CK Navigator<a id="_idIndexMarker683"/> is a powerful analytical tool developed by MITRE as a part of the <a id="_idIndexMarker684"/>MITRE ATT&amp;CK framework. It provides a web-based interactive interface, helping threat hunters and security professionals to explore, visualize, and prioritize techniques used by threat actors. ATT&amp;CK Navigator also helps in aligning security controls against known adversary techniques. You can access the tool at <a href="https://mitre-attack.github.io/attack-navigator/">https://mitre-attack.github.io/attack-navigator/</a>:</p>
<div><div><img alt="Figure 6.15 – ATT&amp;CK Navigator" src="img/B19549_6_15.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.15 – ATT&amp;CK Navigator</p>
<p>The numbers in the<a id="_idIndexMarker685"/> preceding screenshot refer to the following:</p>
<ul>
<li><strong class="bold">1</strong> is <strong class="bold">layer</strong>, used to create multiple ATT&amp;CK framework layers.</li>
<li><strong class="bold">2</strong> is <strong class="bold">section controls</strong>, which gives the following options:<ul><li>Selection behavior</li><li>A search button for selecting techniques, threat groups, software, campaigns, data sources, and more</li><li>The option to deselect all techniques</li></ul></li>
<li><strong class="bold">3</strong> is <strong class="bold">layer controls</strong>, which have the following options:<ul><li>The option to add metadata information to each layer, including a name, description, and other custom metadata</li><li>Download the layer in JSON format</li><li>Export the layer in XML format</li><li>Download the layer in SVG format</li><li>A filter option to display techniques based on Linux, macOS, Windows, containers, and so on</li><li>Sorting the techniques based on AI</li><li>Color setup: You can choose a specific color for certain tactics on the interface</li></ul></li>
<li><strong class="bold">4</strong> is <strong class="bold">technique controls</strong>, which is useful to mark specific techniques with a color and score. We will use this feature when we combine multiple layers to identify <a id="_idIndexMarker686"/>overlapping techniques of multiple threat actors.</li>
</ul>
<h3>Practical use case using MITRE ATT&amp;CK</h3>
<p>Let me take you<a id="_idIndexMarker687"/> through a practical use case to perform threat hunting using MITRE ATT&amp;CK. Imagine yourself as a threat hunter working for a financial services organization based in the United States. After doing some research on the <strong class="bold">Groups</strong> page (<a href="https://attack.mitre.org/groups/">https://attack.mitre.org/groups/</a>) of the MITRE ATT&amp;CK official website, you settled on two relevant threat actors that target financial services organizations based in the United States. These are APT19 and APT38. (Remember, this is only an example – I suggest you do your research based on your specific industry, software, target countries, and so on.) To discover the priority techniques, we need to find common techniques used by both APT19 and APT38. To do this, we need to customize the ATT&amp;CK Navigator layers as explained in the following steps:</p>
<ol>
<li>Open ATT&amp;CK Navigator, click <strong class="bold">Create New Layer</strong>, and then select <strong class="bold">Enterprise</strong> as shown in the following screenshot.</li>
</ol>
<div><div><img alt="Figure 6.16 – Create a new layer in ATT&amp;CK Navigator" src="img/B19549_6_16.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.16 – Create a new layer in ATT&amp;CK Navigator</p>
<ol>
<li value="2">Click the search <a id="_idIndexMarker688"/>button under <strong class="bold">section controls</strong> and search for <strong class="bold">APT19</strong> under <strong class="bold">Threat Groups</strong>.</li>
</ol>
<div><div><img alt="Figure 6.17 – Select APT19 from Threat Groups" src="img/B19549_6_17.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.17 – Select APT19 from Threat Groups</p>
<ol>
<li value="3">Next, click the layer information button under <code>APT19</code> with the description <code>TTPs of APT19 - Initial </code><code>threat analysis</code>.</li>
</ol>
<div><div><img alt="Figure 6.18 – Enter basic information about the layer" src="img/B19549_6_18.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.18 – Enter basic information about the layer</p>
<ol>
<li value="4">Next, set the color of the APT19 techniques to red. To do this, click on the background <a id="_idIndexMarker689"/>color button under <strong class="bold">technique controls</strong>.</li>
</ol>
<div><div><img alt="Figure 6.19 – Apply a color to the APT19 techniques" src="img/B19549_6_19.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.19 – Apply a color to the APT19 techniques</p>
<ol>
<li value="5">Next, click on scoring under <code>1</code>.</li>
</ol>
<div><div><img alt="Figure 6.20 – Set a score for the APT19 techniques" src="img/B19549_6_20.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.20 – Set a score for the APT19 techniques</p>
<ol>
<li value="6">Repeat the <a id="_idIndexMarker690"/>same steps for APT38 with the following details:<ol><li class="upper-roman">Create a new layer.</li><li class="upper-roman">Click the search button under <code>APT38</code> with the description <code>TTPs of APT38 - Initial </code><code>threat analysis</code>.</li><li class="upper-roman">Set the color of the APT38 techniques to green by clicking on the background color button under <code>2</code>.</li></ol><p class="list-inset">The final APT38 layer will look like the following.</p></li>
</ol>
<div><div><img alt="Figure 6.21 – APT38 layer" src="img/B19549_6_21.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.21 – APT38 layer</p>
<ol>
<li value="7">Now, merge<a id="_idIndexMarker691"/> both layers to get the common techniques used by both APT19 and APT38. This will help us to prioritize the adversary’s techniques. Click on <strong class="bold">Create New Layer</strong> and then click on <strong class="bold">Create Layer from </strong><strong class="bold">other layers</strong>.</li>
</ol>
<div><div><img alt="Figure 6.22 – Create Layer from other layers" src="img/B19549_6_22.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.22 – Create Layer from other layers</p>
<p class="list-inset">Enter the following information:</p>
<ul>
<li><code>Enterprise </code><code>ATT&amp;CK v13</code></li>
<li><code>a+b</code></li>
</ul>
<p>You can leave <a id="_idIndexMarker692"/>everything else blank, then click on the <strong class="bold">Create</strong> button at the bottom.</p>
<div><div><img alt="Figure 6.23 – Provide the domain and set expression" src="img/B19549_6_23.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.23 – Provide the domain and set expression</p>
<ol>
<li>Once you click on <strong class="bold">Create</strong>, you will find a new layer with red techniques from APT19, yellow techniques from APT38, and green techniques that are common to both APT groups, as shown in the following screenshot.</li>
</ol>
<div><div><img alt="Figure 6.24 – Layers showing techniques from APT19 and APT38" src="img/B19549_6_24.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.24 – Layers showing techniques from APT19 and APT38</p>
<p>Based on the final<a id="_idIndexMarker693"/> layers, there are four common techniques. The threat hunter could now start their hunting process by focusing on these four techniques:</p>
<ul>
<li><strong class="bold">Drive-by Compromise</strong> with technique ID T1189 under the <strong class="bold">Initial </strong><strong class="bold">Access</strong> tactic</li>
<li><strong class="bold">Modify Registry</strong> with technique ID T1112 under the <strong class="bold">Defense </strong><strong class="bold">Evasion</strong> tactic</li>
<li><strong class="bold">System Information Discovery</strong> with technique ID T1082 under the <strong class="bold">Discovery</strong> tactic</li>
<li><strong class="bold">System Owner/User Discovery</strong> with technique ID T1033 under the <strong class="bold">Discovery</strong> tactic</li>
</ul>
<h2 id="_idParaDest-180"><a id="_idTextAnchor179"/>Wazuh MITRE ATT&amp;CK mapping</h2>
<p>Wazuh maps the security<a id="_idIndexMarker694"/> events in the environment to the MITRE ATT&amp;CK framework’s TTPs. Wazuh helps security teams by matching them with known threat groups’ TTPs. In order to map a MITRE ATT&amp;CK technique ID to a specific Wazuh event, you need to add the <code>&lt;mitre&gt;</code> tag under the given rule. For example, if you want to create a Wazuh rule to associate SSH brute-force attacks with MITRE technique ID T1110, you will use the following rule:</p>
<pre class="console">
&lt;rule id="100009" level="10" frequency="8" timeframe="120" ignore="60"&gt;
    &lt;if_matched_sid&gt;100001&lt;/if_matched_sid&gt;
    &lt;description&gt;sshd: brute force attack&lt;/description&gt;
    &lt;same_srcip /&gt;
    &lt;mitre&gt;
      &lt;id&gt;T1110&lt;/id&gt;
    &lt;/mitre&gt;
  &lt;/rule&gt;</pre> <p>You can also verify all the security events related to MITRE ID T1110 by going to the MITRE ATT&amp;CK module in<a id="_idIndexMarker695"/> Wazuh and searching for <strong class="bold">T1110</strong> under <strong class="bold">Techniques</strong>.</p>
<div><div><img alt="Figure 6.25 – MITRE ATT&amp;CK visualization in Wazuh" src="img/B19549_6_25.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.25 – MITRE ATT&amp;CK visualization in Wazuh</p>
<p>Once you click on <strong class="bold">T1110</strong>, you will see all the security events associated with this MITRE ID, as shown in the following screenshot.</p>
<div><div><img alt="Figure 6.26 – Security events related to MITRE ATT&amp;CK technique ID T1110" src="img/B19549_6_26.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.26 – Security events related to MITRE ATT&amp;CK technique ID T1110</p>
<p>We have learned to <a id="_idIndexMarker696"/>prioritize techniques using ATT&amp;CK Navigator and created a Wazuh rule mapped to a MITRE ATT&amp;CK technique ID. This helps security teams and threat hunters to discover triggers to start their investigations. In the next section, we will learn to utilize the Osquery tool to conduct comprehensive threat hunting.</p>
<h1 id="_idParaDest-181"><a id="_idTextAnchor180"/>Threat hunting using Osquery</h1>
<p>When it comes to threat hunting, we need in-depth visibility of endpoint activities and the ability to run queries to allow the threat hunter to retrieve IOCs, suspicious activities, and vulnerabilities in a given endpoint. <strong class="bold">Osquery</strong> is the ideal tool for this purpose. It helps threat hunters  treat their entire IT <a id="_idIndexMarker697"/>infrastructure, including endpoints, as a structured database that can be queried using SQL-like commands. You can get real-time, detailed information about your systems with Osquery and keep an eye on them for signs of compromise. In this section, we will cover the following topics:</p>
<ul>
<li>What is Osquery?</li>
<li>Installing Osquery</li>
<li>Integrating Osquery with Wazuh</li>
<li>Threat hunting with Osquery and Wazuh</li>
</ul>
<h2 id="_idParaDest-182"><a id="_idTextAnchor181"/>What is Osquery?</h2>
<p><strong class="bold">Osquery</strong> is an<a id="_idIndexMarker698"/> open-source tool built by Facebook in 2014. It converts the target operating system into a relational database and allows us to ask questions from the table using SQL queries containing things such as information about the state of remote machines, running processes, active user accounts, active network connections, and much more. Osquery can be installed on Windows, Linux, macOS, and FreeBSD.</p>
<p>Osquery is heavily used by security analysts, <strong class="bold">digital forensic and incident response</strong> (<strong class="bold">DFIR</strong>) analysts, and<a id="_idIndexMarker699"/> threat hunters. Before we discuss how threat hunters can utilize Osquery with Wazuh, let me first share with you some simple <a id="_idIndexMarker700"/>use cases of Osquery:</p>
<ul>
<li><strong class="bold">Use case #1 – query for the top 10 largest processes by resident </strong><strong class="bold">memory size</strong><p class="list-inset">To get the list of the top 10 largest processes by memory size, use this query:</p><pre class="source-code">
<strong class="bold">select pid, name, uid, resident_size from processes order by resident_size desc limit 10;</strong></pre></li> </ul>
<div><div><img alt="Figure 6.27 – Result of top 10 largest processes by memory size" src="img/B19549_6_27.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.27 – Result of top 10 largest processes by memory size</p>
<ul>
<li><strong class="bold">Use case #2 – query the list of the top 10 most active processes with </strong><strong class="bold">process counts</strong><p class="list-inset">In this use case, we <a id="_idIndexMarker701"/>will utilize Osquery to retrieve from the system the top 10 active processes based on their frequency and process count. The query is as follows:</p><pre class="source-code">
<strong class="bold">select count(pid) as total, name from processes group by name order by total desc limit 10;</strong></pre></li> </ul>
<p>Once the query is executed, you will get the result in the form of a table with the process names and corresponding frequencies. The output is shown in the following screenshot.</p>
<div><div><img alt="Figure 6.28 – Result of the top 10 most active processes with process counts" src="img/B19549_6_28.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.28 – Result of the top 10 most active processes with process counts</p>
<p>Before we integrate Osquery with Wazuh, we need to install Osquery in each of the individual Wazuh agents.</p>
<h2 id="_idParaDest-183"><a id="_idTextAnchor182"/>Installing Osquery</h2>
<p>The process of installing <a id="_idIndexMarker702"/>Osquery is different for each platform. In this section, we will cover the installation of Osquery on an Ubuntu machine and a Windows machine.</p>
<h3>Installing Osquery on Ubuntu Server/Desktop</h3>
<p>Installation of <a id="_idIndexMarker703"/>Osquery on the Ubuntu Server<a id="_idIndexMarker704"/> requires the OSQUERY KEY and downloading the official Osquery package, explained as follows:</p>
<ol>
<li><code>OSQUERY_KEY</code> to store the GPG key used to validate the Osquery package’s authenticity. This key is required to confirm that the packages you download are from a reliable source:</p><pre class="source-code">
<code>apt-key</code> command. This key is necessary to validate the Osquery packages you will be installing:</p><pre class="source-code">
<strong class="bold">apt-key adv --keyserver keyserver.ubuntu.com --recv-keys $OSQUERY_KEY</strong></pre></li> <li><strong class="bold">Add the Osquery repository and update </strong><strong class="bold">the package</strong><p class="list-inset">Next, you must add the Osquery repository to the list of software sources on your system. The Osquery package will be installed from this repository:</p><pre class="source-code">
<strong class="bold">add-apt-repository 'deb [arch=amd64] https://pkg.osquery.io/deb&gt; deb main'</strong>
<code>apt-get</code> <code>install</code> command to install Osquery. This will get Osquery from the newly added <a id="_idIndexMarker705"/>repository <a id="_idIndexMarker706"/>and install it:</p><pre class="source-code">
<strong class="bold">apt-get install osquery</strong></pre></li> </ol>
<h3>Installing Osquery on Windows</h3>
<p>Installing<a id="_idIndexMarker707"/> Osquery on Windows desktops is pretty simple. Please <a id="_idIndexMarker708"/>visit the official website of Osquery<a id="_idIndexMarker709"/> and download the packages. The website is <a href="https://www.osquery.io/">https://www.osquery.io/</a>.</p>
<h2 id="_idParaDest-184"><a id="_idTextAnchor183"/>Integrating Osquery with Wazuh</h2>
<p>The good news is that <a id="_idIndexMarker710"/>Wazuh is already integrated with Osquery. We<a id="_idIndexMarker711"/> just need to enable it and make some minor changes to the Osquery configuration file. Follow these steps to complete the installation:</p>
<ol>
<li><code>ossec.conf</code> file in the Wazuh agent and change the <code>&lt;disabled&gt;</code> tag value to <code>no</code> under &lt;<code>wodle name="osquery"</code>:<pre class="source-code">
&lt;!-- Osquery integration --&gt;
&lt;wodle name="osquery"&gt;
&lt;disabled&gt;no&lt;/disabled&gt;
&lt;run_daemon&gt;yes&lt;/run_daemon&gt; &lt;log_path&gt;/var/log/osquery/osqueryd.results.log&lt;/log_path&gt; &lt;config_path&gt;/etc/osquery/osquery.conf&lt;/config_path&gt; &lt;add_labels&gt;yes&lt;/add_labels&gt;
 &lt;/wodle&gt;</pre><p class="list-inset">In the preceding code, we can see the following:</p><ul><li><code>&lt;log_path&gt;</code> represents the location of the Osquery logs</li><li><code>&lt;config_path&gt;</code>  shows the location of the Osquery configuration file</li></ul></li> <li><code>/opt/osquery/share/osquery/osquery.example.conf</code>.<p class="list-inset">Let’s copy the file to <code>/etc/osquery/osquery.conf</code> using the <code>cp</code> command:</p><pre class="source-code">
<code>nano /etc/osquery/osquery.conf</code> to view the default packs:</p><pre class="source-code">   "packs": {
        "osquery-monitoring": "/opt/osquery/share/osquery/packs/osquery-monitoring.conf",
        "incident-response": "/opt/osquery/share/osquery/packs/incident-response.conf",
        "it-compliance": "/opt/osquery/share/osquery/packs/it-compliance.conf",
        "vuln-management": "/opt/osquery/share/osquery/packs/vuln-management.conf",
        "hardware-monitoring": "/opt/osquery/share/osquery/packs/hardware-monitoring.conf",
        "ossec-rootkit": "/opt/osquery/share/osquery/packs/ossec-rootkit.conf"
    }</pre><ul><li>In the preceding code, we can see the following:</li><li><code>osquery-monitoring.conf</code> is an Osquery configuration file to collect information <a id="_idIndexMarker712"/>about every Osquery pack, including <a id="_idIndexMarker713"/>general performance and versions</li><li><code>incident-response.conf</code> retrieves information about crontab, the loginwindow process, a list of open sockets, a list of mounted drives, and so on</li><li><code>it-compliance.conf</code> collects information about active directory, the operating system, shared services, browser plugins, Windows drivers, a list of USB drives, and so on</li><li><code>vuln-management.conf</code> retrieves information about installed applications, browser plugins, and Chrome extensions</li><li><code>hardware-monitoring.conf</code> gathers hardware-related information such as PCI devices, fan speed, an inventory of USB drives, kernel modules, and so on</li><li><code>ossec-rootkit.conf</code> collects information about rootkits</li></ul></li> <li><strong class="bold">Restart Osquery</strong>: Now, you <a id="_idIndexMarker714"/>need to restart Osquery for your <a id="_idIndexMarker715"/>changes to take effect:<pre class="source-code">
<strong class="bold">systemctl restart osqueryd</strong></pre></li> </ol>
<h2 id="_idParaDest-185"><a id="_idTextAnchor184"/>Threat hunting with Osquery</h2>
<p>Osquery gives you a SQL-like way <a id="_idIndexMarker716"/>to query requests and get real-time information about how a system is running. This lets security teams do proactive investigations and find threats. Threat hunting with Osquery involves actively searching for system information such as suspicious processes, unwanted software or modules, abnormal network connections, registry settings, file integrity, and more. For testing purposes, we will write some Osquery queries based on popular MITRE ATT&amp;CK techniques.</p>
<p>It is sufficient to run the queries on a single endpoint for testing purposes and to demonstrate the information retrievable by Osquery. However, keep in mind that the true power of Osquery presents itself when it is widely deployed and administered centrally by the Wazuh manager. Let’s focus on discovering persistence tactics in our environment by utilizing a few of its associated techniques.</p>
<h4>Local Job Scheduling (MITRE ATT&amp;CK ID T1168)</h4>
<p>Adversaries utilize local<a id="_idIndexMarker717"/> job scheduling to schedule and execute tasks or jobs on a hacked system. It is covered by MITRE <a id="_idIndexMarker718"/>ATT&amp;CK framework under <em class="italic">technique ID 1168</em>. On Linux-based systems, adversaries can schedule their multi-step attack jobs by abusing the Cron service. They may set up new Cron jobs to run harmful scripts or commands on a regular basis. You can use the following query to retrieve information about local Cron jobs:</p>
<pre class="console">
select command, path from crontab;</pre> <p>Once this query is executed, you will see the result in the form of a table with the command and corresponding path, as shown in the following screenshot:</p>
<div><div><img alt="Figure 6.29 – Resulting list of local Cron jobs" src="img/B19549_6_29.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.29 – Resulting list of local Cron jobs</p>
<h4>Kernel Modules and Extensions (MITRE ATT&amp;CK ID T1215)</h4>
<p>Adversaries can ensure that<a id="_idIndexMarker719"/> their <a id="_idIndexMarker720"/>code runs each time the system reboots by installing a malicious kernel module or extension at startup or during system initialization. This makes it difficult to identify and uninstall. This is described under MITRE ATT&amp;CK technique <em class="italic">ID T1215</em>. Kernel modules are pieces of code that can be dynamically loaded and unloaded from an operating system’s kernel. The query to retrieve the kernel modules is as follows:</p>
<pre class="console">
select name from kernel_modules;</pre> <p>Once this query is <a id="_idIndexMarker721"/>executed, you<a id="_idIndexMarker722"/> will get a list of all the kernel modules as shown in the following screenshot.</p>
<div><div><img alt="Figure 6.30 – Result of list of kernel modules" src="img/B19549_6_30.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.30 – Result of list of kernel modules</p>
<h4>Redundant Access (MITRE ATT&amp;CK ID T1108)</h4>
<p><strong class="bold">Redundant access</strong> is a strategy <a id="_idIndexMarker723"/>in which<a id="_idIndexMarker724"/> adversaries create several paths or techniques for accessing and manipulating a victim machine. This works like a “plan B” for threat actors. To detect redundant access, we need to retrieve information about all the running processes on the endpoint. To get this information, we can run the following query:</p>
<pre class="console">
select pr.pid, pr.name, usr.username, pr.path, pr.cmdline from processes pr LEFT JOIN users usr ON pr.uid = usr.uid WHERE pr.cmdline != '';</pre> <p>Once this query is executed, we will get the result in a table containing details on the process ID (<code>pid</code>), process name (<code>name</code>), <code>username</code>, <code>path</code>, and command line (<code>cmdline</code>) of the <a id="_idIndexMarker725"/>running processes, as<a id="_idIndexMarker726"/> shown in the following screenshot.</p>
<div><div><img alt="Figure 6.31 – Result of all running processes and their corresponding paths" src="img/B19549_6_31.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.31 – Result of all running processes and their corresponding paths</p>
<h3>Writing and organizing queries</h3>
<p>There are two<a id="_idIndexMarker727"/> ways you can create queries. You can either write a query directly under the <code>schedule</code> block of the <code>/etc/osquery/osquery.conf</code> file or you can organize<a id="_idIndexMarker728"/> them in the form of packs. When you have tons of queries to run, it’s always better to create a separate Osquery pack. In our scenario, we will add the following queries to a pack with the name <code>custom-pack-1.conf</code>:</p>
<pre class="source-code">
{
  "queries": {
    "Services": {
        "query": "SELECT * FROM services WHERE start_type='DEMAND_START' OR start_type='AUTO_START';",
        "interval": 3600,
        "description": "Lists all installed services configured to start automatically at boot - ATT&amp;CK T1050",
        "removed": false
    },
    "Snapshot_services": {
        "query": "SELECT * FROM services;",
        "interval": 28800,
        "description": "Snapshot Services query",
        "snapshot": true
    },
      "OtherServices": {
        "query": "SELECT name, display_name, status, start_type, path, module_path FROM services;",
        "interval": 3600,
        "description": "Services whose executables are placed in unfamiliar folders- ATT&amp;CK T1543.003",
        "removed": false
    }
   }
}</pre> <p>You need to add all the <a id="_idIndexMarker729"/>queries under the <code>queries</code> field. Each Osquery query can have <a id="_idIndexMarker730"/>multiple items of metadata including <code>query</code>, <code>interval</code>, <code>description</code>, and <code>snapshot</code>. The following screenshot shows a query pack containing three queries.</p>
<div><div><img alt="Figure 6.32 – Custom Osquery pack" src="img/B19549_6_32.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.32 – Custom Osquery pack</p>
<p>In the preceding screenshot, we can see the following:</p>
<ul>
<li><code>SELECT * FROM services WHERE start_type='DEMAND_START' OR start_type='AUTO_START</code>: This query retrieves all rows from the <code>services</code> table where <code>start_type</code> is either <code>'DEMAND_START'</code> or <code>'AUTO_START'</code></li>
<li><code>SELECT * FROM services</code>: This query retrieves all rows from the <code>services</code> table</li>
<li><code>SELECT name, display_name, status, start_type, path, module_path FROM services</code>: This query retrieves specific columns (<code>name</code>, <code>display_name</code>, <code>status</code>, <code>start_type</code>, <code>path</code>, <code>module_path</code>) from the <code>services</code> table</li>
</ul>
<p>You can save the file and call this under the <code>/etc/osquery/osquery.conf</code> Osquery file.</p>
<p>To visualize <a id="_idIndexMarker731"/>Osquery<a id="_idIndexMarker732"/> events on the Wazuh dashboard, navigate to <strong class="bold">Wazuh Modules</strong>&gt;<strong class="bold">Osquery</strong>&gt; <strong class="bold">Events</strong>. You should see all the query results as shown in the following screenshot.</p>
<div><div><img alt="Figure 6.33 – Visualizing Osquery events" src="img/B19549_6_33.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.33 – Visualizing Osquery events</p>
<p>We’ve learned to create custom Osquery queries and visualize the events on the Wazuh dashboard. In the next section, we will learn about command monitoring on Wazuh.</p>
<h1 id="_idParaDest-186"><a id="_idTextAnchor185"/>Command monitoring</h1>
<p>The most effective way to collect information <a id="_idIndexMarker733"/>about an endpoint is to run specific commands on the given endpoint, such as <code>netstat</code> (for network connections on Windows), <code>ps</code>  (to collect process information from Linux machines), and so on. This information plays a vital role in collecting IOCs and running a successful threat-hunting program. The good news is that Wazuh has a built-in feature to monitor the output of specific Windows/Linux commands and show that output as log content. In this section, we will learn the following:</p>
<ul>
<li>How does command monitoring work?</li>
<li>Monitoring Linux commands</li>
<li>List of Linux commands for threat hunting and security Investigations</li>
</ul>
<h2 id="_idParaDest-187"><a id="_idTextAnchor186"/>How does command monitoring work?</h2>
<p>Wazuh runs commands on the endpoints using the <em class="italic">Command</em> and <em class="italic">Logcollector</em> modules, and then sends the results to the Wazuh server for examination. The following steps describe the process of command monitoring.</p>
<h3>Step 1 – configuration</h3>
<p>The process <a id="_idIndexMarker734"/>starts when a user chooses to monitor how a particular command is being executed on a system. This can be accomplished locally by adding the necessary command to the local agent configuration file (<code>/var/ossec/etc/ossec.conf</code>) or remotely through the <code>agent.conf</code> file hosted on the Wazuh server. Wazuh has two modules that let you monitor the results of system commands that are running on an endpoint. The Command and Logcollector modules run and watch commands or executables on Windows, Linux, and macOS targets on a regular basis.</p>
<h4>Using the Command module</h4>
<p>Wazuh recommends using the Command module<a id="_idIndexMarker735"/> as it has checksum verification, allows encrypted communication, and helps in scheduling execution.</p>
<p>The following is an example of the Command module:</p>
<pre class="source-code">
 &lt;wodle name="command"&gt;
    &lt;disabled&gt;no&lt;/disabled&gt;
    &lt;tag&gt;tasklist&lt;/tag&gt;
    &lt;command&gt;PowerShell.exe C:\\activeTasks.bat&lt;/command&gt;
    &lt;interval&gt;2m&lt;/interval&gt;
    &lt;run_on_start&gt;yes&lt;/run_on_start&gt;
    &lt;timeout&gt;10&lt;/timeout&gt;
  &lt;/wodle&gt;</pre> <p>Here, the <code>PowerShell.exe C:\\tasklist.bat</code> value in the <code>&lt;command&gt;</code> tag is the command to be executed by the Command module. The PowerShell program executes the <code>C:\activetasks.bat</code> script.</p>
<h4>Using the Logcollector module</h4>
<p>Text files, Windows event logs, and <a id="_idIndexMarker736"/>straight syslog messages can all send logs to the Logcollector module. It is easy to use and also allows us to format fields such as <code>timestamp</code>, <code>hostname</code>, and <code>program_name</code>.</p>
<p>This is what a simple Logcollector module setup block looks like:</p>
<pre class="source-code">
&lt;localfile&gt;
&lt;log_format&gt;full_command&lt;/log_format&gt; &lt;command&gt;&lt;COMMAND&gt;&lt;/command&gt;
&lt;frequency&gt;120&lt;/frequency&gt;
 &lt;/localfile&gt;</pre> <p>In the preceding code, we can see the following:</p>
<ul>
<li><code>&lt;command&gt;</code> reads the output of the command executed by the Wazuh agent.</li>
<li><code>&lt;log_format&gt;</code> can be set to either <code>full_command</code> or <code>command</code>. <code>full_command</code> reads the output as a single-line entry and <code>command</code> reads the output as multiple entries.</li>
</ul>
<h3>Step 2 – execution by the Wazuh agent</h3>
<p>Following the configuration<a id="_idIndexMarker737"/> of the required command, the endpoint runs the command on a regular basis according to the predetermined frequency or interval.</p>
<p>Under the Command module, we define the <code>&lt;interval&gt;</code> tag to execute the command at a specified interval.</p>
<h3>Step 3 – monitoring and data forwarding</h3>
<p>The Wazuh agent monitors how<a id="_idIndexMarker738"/> the configured command is being executed. It records the result of the command along with any associated data, including the timestamp, execution details, and user that started the command. The agent sends this data to the Wazuh server for further analysis.</p>
<h3>Step 4 – Wazuh server analysis and alert generation</h3>
<p>The data is processed by the Wazuh <a id="_idIndexMarker739"/>server after it is received from the Wazuh agent. A number of crucial tasks are carried out by the server, such as pre-decoding, decoding, and matching the received logs against preset rules, explained as follows:</p>
<ul>
<li><strong class="bold">Pre-decoding and decoding</strong>: The raw data is converted into a readable format using a Wazuh decoder. So, yes, we need to write a decoder rule too.</li>
<li><strong class="bold">Matching rules</strong>: The Wazuh server matches the decoded logs to predefined Wazuh rules. These rules identify suspicious or malicious command-related activity using patterns and criteria. If a match is identified, the server alerts security.</li>
<li><code>/var/ossec/logs/alerts/alerts.log and /var/ossec/logs/alerts/alerts.json</code> file on the Wazuh server.</li>
</ul>
<p>Now that we have understood how command monitoring works, let’s take a simple use case of monitoring the output of the <code>netstat</code> command on a Linux machine.</p>
<h2 id="_idParaDest-188"><a id="_idTextAnchor187"/>Monitoring the output of the netstat command on Linux</h2>
<p><code>netstat</code> is <a id="_idIndexMarker741"/>a tool for looking at connection information and can be used to find connections that seem suspicious or unusual. As a threat hunter, you may need to focus on a certain endpoint in the context of any unusual network connections. In order to<a id="_idIndexMarker742"/> monitor the output of the <code>netstat</code> command, follow these next steps:</p>
<ol>
<li><code>net-tools</code> package is installed on all the monitored Linux endpoints:<pre class="source-code">
<code>ifconfig</code>, <code>netstat</code>, <code>route</code>, <code>arp</code>, <code>rarp</code>, and so on.</p></li> <li><code>netstat</code> command in the Wazuh agent’s <code>ossec.conf</code> file:<pre class="source-code">
<strong class="bold">&lt;ossec_config&gt;</strong>
<strong class="bold">&lt;localfile&gt;</strong>
<strong class="bold"> &lt;log_format&gt;full_command&lt;/log_format&gt;</strong>
<strong class="bold">&lt;command&gt;netstat -tulpn&lt;/command&gt;</strong>
<strong class="bold">&lt;alias&gt;netstat listening ports&lt;/alias&gt;</strong>
<strong class="bold"> &lt;frequency&gt;360&lt;/frequency&gt;</strong>
<strong class="bold"> &lt;/localfile&gt;</strong>
<code>&lt;log_format&gt;full_command&lt;/log_format&gt;</code>: This specifies the log format. In this case, it is set to <code>full_command</code>, indicating that the log consists of the full output.</li><li><code>&lt;command&gt;netstat -tulpn&lt;/command&gt;</code>: This indicates the command to be executed. In this case, the <code>netstat -tulpn</code> command is used to display active network connections, listening ports, and other related information.</li><li><code>&lt;frequency&gt;360&lt;/frequency&gt;</code>: This represents the frequency at which the preceding command will be executed. It is set to execute every 360 seconds (i.e., every 6 minutes).</li></ul></li> <li><strong class="bold">Restart and test</strong>: Now, restart<a id="_idIndexMarker743"/> the Wazuh agent using the following command and check the Wazuh manager for the alert:<pre class="source-code">
<strong class="bold">systemctl restart wazuh-agent</strong></pre></li> <li><strong class="bold">Visualizing the alert</strong>: To visualize the alerts, navigate to the <strong class="bold">Security alert</strong> module on the Wazuh manager and find the alert related to <strong class="bold">Listened port status (netstat)</strong> as shown in the following screenshot:</li>
</ol>
<div><div><img alt="Figure 6.34 – Wazuh alert about netstat listened ports status having changed" src="img/B19549_6_34.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.34 – Wazuh alert about netstat listened ports status having changed</p>
<p>You will notice that we<a id="_idIndexMarker744"/> didn’t even create any Wazuh decoder or rule, but we got the alert. It was possible because Wazuh has a built-in ruleset named <code>0015-ossec_rule.xml</code>, containing a rule for netstat listening, as follows:</p>
<pre class="source-code">
&lt;rule id="533" level="7"&gt;
&lt;if_sid&gt;530&lt;/if_sid&gt;
&lt;match&gt;ossec: output: 'netstat listening ports&lt;/match&gt;
&lt;check_diff /&gt;
&lt;description&gt;Listened ports status (netstat) changed (new port opened or closed).&lt;/description&gt;
&lt;group&gt;pci_dss_10.2.7,pci_dss_10.6.1,gpg13_10.1,gdpr_IV_35.7.d,hipaa_164.312.b,nist_800_53_AU.14,nist_800_53_AU.6,tsc_CC6.8,tsc_CC7.2,tsc_CC7.3,&lt;/group&gt;
&lt;/rule&gt;</pre> <p>And if you look at the parent rule, you will find the decoder named <code>ossec</code> as follows:</p>
<pre class="source-code">
&lt;group name="ossec,"&gt;
&lt;rule id="500" level="0"&gt;
&lt;category&gt;ossec&lt;/category&gt;
&lt;decoded_as&gt;ossec&lt;/decoded_as&gt;
&lt;description&gt;Grouping of ossec rules.&lt;/description&gt;
&lt;/rule&gt;
&lt;/group&gt;</pre> <h2 id="_idParaDest-189"><a id="_idTextAnchor188"/>List of Linux commands for threat hunting and security investigations</h2>
<p>As we bring this chapter to a close, let’s quickly review some essential Linux commands for threat hunting and security investigations:</p>
<ul>
<li><code>ss</code>: This is a <a id="_idIndexMarker745"/>tool used to dump socket statistics and provide information about network connections. The <code>ss</code> command is useful to identify open ports, check established <a id="_idIndexMarker746"/>connections, and gather network information. It is slightly more advanced than <code>netstat</code>.</li>
<li><code>ps</code>: Using the <code>ps</code> command, you can<a id="_idIndexMarker747"/> see which processes are active on your system. Examining <a id="_idIndexMarker748"/>active processes might assist you in locating unauthorized or suspicious software.</li>
<li><code>top</code> and <code>htop</code>: These <a id="_idIndexMarker749"/>commands <a id="_idIndexMarker750"/>provide<a id="_idIndexMarker751"/> up-to-date details on programs that are currently <a id="_idIndexMarker752"/>executing, and the number of system resources being consumed. They can also be used to spot any unexpected or resource-intensive activity.</li>
<li><code>lsof</code>: You <a id="_idIndexMarker753"/>can find open files and network connections with the <code>lsof</code> (for <em class="italic">list open files</em>) command, which can <a id="_idIndexMarker754"/>help you keep an eye on behavior that might be suspicious.</li>
<li><code>tcpdump</code>: This is a very <a id="_idIndexMarker755"/>powerful packet <a id="_idIndexMarker756"/>capture tool that can be used to detect network-based threats.</li>
</ul>
<h1 id="_idParaDest-190"><a id="_idTextAnchor189"/>Summary</h1>
<p>This chapter covered important aspects of modern intelligence and threat-hunting tactics. It started with Wazuh’s contribution to proactive threat hunting, then moved on to the importance of analyzing log data, and finally looked at how MITRE ATT&amp;CK mapping improves our understanding of threats. We learned how to use Osquery in Wazuh to effectively perform threat hunting and also learned how to use command monitoring in Wazuh to discover suspicious activities.</p>
<p>In the next chapter, we will learn about the Vulnerability detection and SCA modules of the Wazuh platform. We will learn how to leverage these modules to meet regulatory compliance including PCI DSS, NIST 800-53, and HIPPA.</p>
</div>


<div><h1 id="_idParaDest-191" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor190"/>Part 3: Compliance Management</h1>
</div>
<div><p>This part of this book focuses on compliance management using Wazuh and explores vulnerability detection and security configuration assessment modules of the Wazuh platform. You will learn to fulfill some specific requirements of regulatory compliance such as PCI DSS, HIPPA, and NIST 800-53 controls.</p>
<p>This part includes the following chapter:</p>
<ul>
<li><a href="B19549_07.xhtml#_idTextAnchor191"><em class="italic">Chapter 7</em></a>, Vulnerability and Configuration Assessment</li>
</ul>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
</body></html>