<html><head></head><body><div><h1 class="header-title">Preparing to Reverse</h1>
                
            
            
                
<p>In this first chapter, we will introduce reverse engineering and explain what it is for. We will begin by discussing some insights already being applied in various aspects that will help the reader understand what reverse engineering is. In this chapter, we will cover a brief introduction to the process and types of tools used in software reverse engineering. There are tips given here on the proper handling of malware. The last section of this chapter shows how easy it is to set up our initial analysis environment using tools that are readily available for download. The following topics will be covered:</p>
<ul>
<li>What reverse engineering is used for</li>
<li>Applying reverse engineering</li>
<li>Types of tools used in reverse engineering</li>
<li>Guide to handling malware</li>
<li>Setting up your reverse engineering environment</li>
</ul>


            

            
        
    </div>



  
<div><h1 class="header-title">Reverse engineering</h1>
                
            
            
                
<p>Breaking something down and putting it back together is a process that helps people understand how things were made. A person would be able to redo and reproduce an origami by unfolding it first. Knowing how cars work requires understanding each major and minor mechanical part and their purposes. The complex nature of the human anatomy requires people to understand each and every part of the body. How? By dissecting it. Reverse engineering is a way for us to understand how things were designed, why is it in its state, when it triggers, how it works, and what its purpose is. In effect, the information is used to redesign and improve for better performance and cost. It can even help fix defects.</p>
<p class="mce-root"/>
<p>However, reverse engineering entails ethical issues and is still a continuous debate. Similar to Frankenstein's case, there are existing issues that defy natural laws in a way that is not acceptable to humanity. Today, simple redesigning can raise copyright infringement if not thought through carefully. Some countries and states have laws governing against reverse engineering. However, in the software security industry, reverse engineering is a must and a common use case.</p>
<p>Imagine if the Trojan Horse was thoroughly inspected and torn down before it was allowed to enter the gates of a city. This would probably cause a few dead soldiers outside the gate fighting for the city. The next time the city is sent another Trojan Horse, archers would  know where to point their arrows. And no dead soldiers this time. The same is true for malware analysis—by knowing the behaviors of a certain malware through reverse engineering, the analyst can recommend various safeguards for the network. Think of it as the Trojan Horse being the malware, the analyst being the soldier who initially inspected the horse, and the city being the network of computers.</p>
<p>Anyone seeking to become a reverse engineer or an analyst should have the trait of being resourceful. Searching the internet is part of reverse engineering. An analyst would not plainly rely on the tools and information we provide in this book. There are instances that an analysis would even require reverse engineer to develop their own tools.</p>
<p>Software auditing may require reverse engineering. Besides high-level code review processes, some software quality verification also involves implementing reverse engineering. The aim of these test activities is to ensure that vulnerabilities are found and fixed. There are a lot of factors that are not taken into consideration during the design and development of a piece of software. Most of these are random input and external factors that may cause leaks, leading to vulnerabilities. These vulnerabilities may be used for malicious intents that not only disrupt the software, but may cause damage and compromise the system environment it is installed in. System monitoring and fuzzing tools are commonly used when testing software. Today's operating systems have better safeguards to protect from crashing. Operating systems usually report any discrepancies found, such as memory or file corruption. Additional information, such as crash dumps, are also provided. From this information, a reverse engineer would be able to pinpoint where exactly in the software they have to inspect.</p>
<p>In the software security industry, one of the core skills required is reverse engineering. Every attack, usually in the form of malware, is reversed and analyzed. The first thing that is usually needed is to clean the network and systems from being compromised. An analyst determines how the malware installed itself and became persistent. Then, they develop steps for uninstalling the malware. In the anti-malware phase, these steps are used to develop the clean-up routine, once the anti-malware product is able to detect that the system has been compromised.</p>
<p>The analysis provides information about how the malware was able to compromise the system. With this information, network administrators are able to impose policies to mitigate the attack. If the malware was able to enter the system because of a user opening an email attachment that contains JavaScript code, the network administrator would implement the blocking of emails that contain a JavaScript attachment.</p>
<p>Some administrators are even advised to restructure their network infrastructure. Once a system gets compromised, the attackers may already have got all of the information about the network, and would easily be able to make another wave of the same attack. Making major changes will greatly help prevent the same attack from happening again.</p>
<p>Part of restructuring the infrastructure is education. The best way to prevent a system from being compromised is by educating its users about securing information, including their privacy. Knowing about social engineering and having experience of previous attacks makes users aware of security. It is important to know how attackers are able to compromise an institution and what damage they can cause. As a result, security policies are imposed, backups are set up, and continuous learning is implemented.</p>
<p>Going further, targeted companies can report the attack to authorities. Even a small piece of information can give authorities hints to help them hunt down the suspects and shut down malware communication servers.</p>
<p>Systems can be compromised by taking advantage of software vulnerabilities. After the attacker gets knowledge about the target, the attacker can craft code that exploits known software vulnerabilities. Besides making changes in the infrastructure, any software used should also be kept up to date with security features and patches. Reverse engineering is also needed to find vulnerable code. This helps pinpoint the vulnerable code by backtracking it to the source.</p>
<p>All of these activities are done based on the output of reverse engineering. The information gathered from reverse engineering affects how the infrastructure needs to be restructured. </p>
<p class="mce-root"/>


            

            
        
    </div>



  
<div><h1 class="header-title">Technical requirements</h1>
                
            
            
                
<p>We will work in an environment that will make use of virtualization software. It is recommended that we have a physical machine with virtualization enabled and a processor with at least four cores, 4 GB of RAM, and 250 GB of disk space. Pre-install this physical machine with either the Windows or Linux operating system.</p>
<p>We will be using VirtualBox in our setup. The host operating system version of Windows or Linux will depend on the requirements of VirtualBox. See the latest version of VirtualBox at <a href="https://www.virtualbox.org/">https://www.virtualbox.org/</a> and look for the recommended requirements.</p>
<p>You may need to download virtual machines from Microsoft in advance, as these may take some time to download. See the developers' page at <a href="https://developer.microsoft.com/en-us/microsoft-edge/tools/vms/">https://developer.microsoft.com/en-us/microsoft-edge/tools/vms/</a>. Windows 10 can be downloaded from the following link: <a href="https://www.microsoft.com/en-us/software-download/windows10">https://www.microsoft.com/en-us/software-download/windows10</a></p>


            

            
        
    </div>



  
<div><h1 class="header-title">Reverse engineering as a process</h1>
                
            
            
                
<p>Like any other activity, reverse engineering is also a process. There is a guide that we can follow to help us generate information that can be helpful to both the analyst and stakeholders.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Seeking approval</h1>
                
            
            
                
<p>Ethics requires anyone carrying out reverse engineering of software to have approval from the owner of the software. However, there are a lot of instances where software shows its bugs upfront, while the operating system reports it. Some companies are more lenient about their software getting reversed without approval, but it is customary today that any vulnerabilities found should be reported directly to the owner and not publicized. It is up to the owner to decide when to report the vulnerability to the community. This prevents attackers from using a vulnerability before a software patch gets released.</p>
<p>It is a different story when malware or hacking is involved. Of course, reversing malware doesn't need approval from the malware author. Rather, one of the goals of malware analysis is to catch the author. If not sure, always consult a lawyer or a company's legal department.</p>
<p class="mce-root"/>


            

            
        
    </div>



  
<div><h1 class="header-title">Static analysis</h1>
                
            
            
                
<p>Without any execution, viewing the file's binary and parsing each and every byte provides much of the information needed to continue further. Simply knowing the type of file sets the mindset of the analyst in a way that helps them to prepare specific sets of tools and references that may be used. Searching text strings can also give clues about the author of the program, where it came from, and, most likely, what it does.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Dynamic analysis</h1>
                
            
            
                
<p>This type of analysis is where the the object being analyzed gets executed. It requires an enclosed environment so that behaviors that may compromise production systems do not happen. Setting up enclosed environments are usually done using virtual machines, since they can then easily be controlled. Tools that monitor and log common environment actions are implemented during dynamic analysis.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Low-level analysis</h1>
                
            
            
                
<p>There is some information that may be missed out during static and dynamic analyses. The flow of a program follows a path that depends of certain conditions. For example, a program will only create a file only if a specific process is running. Or, a program will create a registry entry in the <kbd>Wow6432Node</kbd> key only if it were running in a 64-bit Windows operating system. Debugging tools are usually used to analyze a program in low-level analysis.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Reporting</h1>
                
            
            
                
<p>While doing analysis, every piece of information should be collected and documented. It is common practice to document a reverse engineered object to help future analysis. An analysis serves as a knowledge base for developers who want to secure their upcoming programs from flaws. For example, a simple input can now be secured by placing bounds validation, which is known about as a result of a prior reverse-engineered program that indicated possible buffer overflow.</p>
<p>A good report answers questions regarding the following:</p>
<ul>
<li>How a reversed engineered object works</li>
<li>When specific behavior triggers</li>
<li>Why specific codes were used in the program</li>
<li>Where it was intended to work on</li>
<li>What the whole program does</li>
</ul>


            

            
        
    </div>



  
<div><h1 class="header-title">Tools</h1>
                
            
            
                
<p>Doing reverse code engineering starts off with understanding the meaning of every bit and byte. Simply viewing the bytes contained requires developing tools that aid in the reading of files and objects. Parsing and adding meaning to every byte would require another tool. Reverse engineering has evolved with tools that are continuously updated when encountering new software technology. Here, we have categorized these tools into binary analysis tools, disassemblers, decompilers, debuggers, and monitoring tools.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Binary analysis tools</h1>
                
            
            
                
<p>Binary analysis tools are used to parse binary files and extract information about the file. An analyst would be able to identify which applications are able to read or execute the binary. File types are generally identified from their magic header bytes. These Magic Header bytes are usually located at the beginning of a file. For example, a Microsoft executable file, an <kbd>EXE</kbd> file, begin with the MZ header (MZ is believed to be the initials of Mark Zbikowski, a developer from Microsoft during the DOS days). Microsoft Office Word documents, on the other hand, have these first four bytes as their Magic Header: </p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-979 image-border" src="img/1b5c4d48-b407-48dc-b86b-af4c9c90a1a9.png" style="width:16.75em;height:2.25em;" width="201" height="27"/><br/></p>
<p>The hexadecimal bytes in the preceding screenshot read as <kbd>DOCFILE</kbd> Other information such as text string also give hints. The following screenshot shows information indicating that the program was most likely built using Window Forms:</p>
<p class="packt_figref CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-980 image-border" src="img/837f29e5-03ec-4a88-abb2-a961b89176cb.png" style="width:36.50em;height:46.67em;" width="492" height="631"/><br/></p>


            

            
        
    </div>



  
<div><h1 class="header-title">Disassemblers</h1>
                
            
            
                
<p>Disassemblers are used to view the low-level code of a program. Reading low-level code requires knowledge of assembly language. Analysis done with a disassembler gives information about the execution conditions and system interactions that a program will carry out when executed. However, the highlights when reading low-level code are when the program uses <strong>Application Program Interface</strong> (<strong>API</strong>) functions. The following screenshot shows a code snippet of a program module that uses the <kbd>GetJob()</kbd> API. This API is used to get information about the printer job, as shown here:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-981 image-border" src="img/4d257d3c-0456-495d-98d6-08da4d4fc837.png" style="width:41.83em;height:39.33em;" width="638" height="600"/></p>


            

            
        
    </div>



  
<div><h1 class="header-title">Debuggers</h1>
                
            
            
                
<p>Disassemblers can show the code tree, but the analyst can verify which branch the code flows to by using a debugger. A debugger does actual execution per line of code. The analyst can trace through codes such as loops, conditional statements, and API execution. Since debuggers are categorized under dynamic analysis and perform a step-wise execution of code, debugging is done in an enclosed environment. Various file types have different disassemblers. In a .NET compiled executable, it is best to instead disassemble the p-code and work out what each operator means.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Monitoring tools</h1>
                
            
            
                
<p>Monitoring tools are used to monitor system behaviors regarding file, registry, memory, and network. These tools usually tap or hook on APIs or system calls, then log information such as newly created processes, updated files, new registry entries, and incoming SMB packets are generated by reporting tools.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Decompilers</h1>
                
            
            
                
<p>Decompilers are similar to disassemblers. They are tools that attempt to restore the high-level source code of program unlike disassemblers that attempt to restore the low-level (assembly language) source code of a program.</p>
<p>These tools work hand in hand with each other. The logs generated from monitoring tools can be used to trace the actual code from the disassembled program. The same applies when debugging, where the analyst can see the overview of the low-level code from the disassembly, while being able to predict where to place breakpoints based on the monitoring tools' logs.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Malware handling</h1>
                
            
            
                
<p>Readers of this book are required to take precautions when handling malware files. Here are some initial tips that can help us to prevent our host machine from being compromised:</p>
<ul>
<li>Do your analysis in an enclosed environment such as a separate computer or in a virtual machine.</li>
<li>If network access is not required, cut it off.</li>
<li>If internet access is not required, cut it off.</li>
<li>When copying files manually, rename the file to a filename that doesn't execute. For example, rename <kbd>myfile.exe</kbd> to <kbd>myfile.foranalysis</kbd>.</li>
</ul>


            

            
        
    </div>



  
<div><h1 class="header-title">Basic analysis lab setup</h1>
                
            
            
                
<p>A typical setup would require a system that can run malware without it being compromised externally. However, there are instances that may require external information from the internet. For starters, we're going to mimic an environment of a home user. Our setup will, as much as possible, use free and open source tools. The following diagram shows an ideal analysis environment setup:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-982 image-border" src="img/5a94fa51-490c-47de-82b7-823c2d2fdb25.png" style="width:36.00em;height:21.92em;" width="572" height="348"/></p>
<p>The sandbox environment here is where we do analysis of a file. MITM, mentioned on the right of the diagram, means the <strong>man in the middle</strong> environment, which is where we monitor incoming and outgoing network activities. The sandbox should be restored to its original state. This means that after every use, we should be able to revert or restore its unmodified state. The easiest way to set this up is to use virtualization technology, since it will then be easy to revert to cloned images. There are many virtualization programs to choose from, including VMware, VirtualBox, Virtual PC, and Bochs. </p>
<p>It should also be noted that there is software that can detect that it is being run, and doesn't like to be run in a virtualized environment. A physical machine setup may be needed for this case. Disk management software that can store images or re-image disks would be the best solution for us here. These programs include Fog, Clonezilla, DeepFreeze, and HDClone.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Our setup</h1>
                
            
            
                
<p>In our setup, we will be using VirtualBox, which can be downloaded from<a href="https://www.virtualbox.org/"> https://www.virtualbox.org/</a>. The Windows OS we will be using is Windows 7 32-bit, which can be downloaded from <a href="https://developer.microsoft.com/en-us/microsoft-edge/tools/vms/">https://developer.microsoft.com/en-us/microsoft-edge/tools/vms/</a>. In the following diagram, the system, which has an internet connection, is installed with two virtual machines, a guest sandbox and guest MITM:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-983 image-border" src="img/fda8a8f3-d844-4023-add5-72f0c768851b.png" style="width:30.33em;height:32.50em;" width="955" height="1024"/></p>
<ol>
<li>Download and install VirtualBox and run it. VirtualBox has installers for both Windows and Linux. Download the Windows 7 32-bit image, as shown here:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-984 image-border" src="img/77907ce3-95e7-4539-bcc8-4415eb179e55.png" style="width:45.33em;height:49.42em;" width="799" height="870"/></p>
<ol start="2">
<li>The image downloaded from the Microsoft website is zipped and should be extracted. In VirtualBox, click on File|Import Appliance. You should be shown a dialog where we can import the Windows 7 32-bit image. </li>
<li>Simply browse and select the OVA file that was extracted from the ZIP archive, then click on Next, as shown here:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-985 image-border" src="img/deb86cec-5fa0-4f88-9765-f11a515f1259.png" style="width:39.83em;height:32.92em;" width="478" height="395"/></p>
<p class="mce-root"/>
<ol start="4">
<li>Before continuing, the settings can be changed. The default RAM is set to 4096 MB. The more RAM allocated and the higher the number of CPU cores set, the better performance will be noticed when running or debugging. However, the more RAM added, the same amount of disk space gets consumed when storing snapshots of the image. This means that if we allocated 1 GB of RAM, creating a snapshot will also consume at least 1GB of disk space.  We set our RAM to 2048 MB, which would be a reasonable amount for us to work on:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-986 image-border" src="img/fcd19eec-7ef6-4a94-b184-44f0c08decc5.png" style="width:64.25em;height:37.25em;" width="771" height="447"/></p>
<ol start="5">
<li>Click on Import and it should start generating the virtual disk image. Once it has completed, we need to create our first snapshot. It is recommended to create a snapshot in a powered-off state, since the amount of disk space consumed is minimal. Look for the SnapShots tab, then click on Take. Fill out the Snapshot Name and Snapshot Description fields, then click on the OK button. This quickly creates your first snapshot.</li>
</ol>
<p>In a power-on state, the amount of RAM plus the amount of modified disk space in the virtual machine is equal to the total disk space that a snapshot will consume.</p>
<ol start="6">
<li>Click on Start to begin running the Windows 7 image. You should end up with the following window. In case it asks for a password, the default password is <kbd>Passw0rd!</kbd>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-987 image-border" src="img/c6bea7bb-783a-40ac-af31-299b8a4352c7.png" style="width:66.25em;height:54.67em;" width="795" height="656"/></p>
<p class="mce-root"/>
<p>At this point, the network setup is set to NAT. This means that any network resources required by the virtual machine will use the host computer's IP address. The IP address of the virtual machine is taken from the VirtualBox's virtual DHCP service. Remember that any network communication in the virtual machine makes use of the host computer's IP address.</p>
<p>Since we can't prevent a certain malware from sending out information to the web in order to return information back to our virtual machine, it is important to note that some ISPs may monitor common malware behavior. It would be best to review your contract with them and make a call if needed.</p>
<p>Most of our reverse engineering deals with malware and, as of the time of writing, attackers usually target Windows systems. Our setup uses Microsoft Windows 7 32-bit. Feel free to use other versions. We recommend installing the 32-bit version of Microsoft Windows, as it will be easier to track virtual and physical addresses later on during low-level debugging.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Samples</h1>
                
            
            
                
<p>We will be building our own programs to validate and understand how the low-level code<br/>
behaves and what it looks like. The following list outlines the software we will be using to build our programs:</p>
<ul>
<li>Dev C++ (<a href="http://www.bloodshed.net/devcpp.html">http://www.bloodshed.net/devcpp.htm</a>)<a href="http://www.bloodshed.net/devcpp.html"/></li>
<li>Visual Studio C++ (<a href="https://www.visualstudio.com/downloads/">https://www.visualstudio.com/downloads/</a>)</li>
<li>MASM32 (<a href="http://www.masm32.com/">http://www.masm32.com/</a>)</li>
</ul>
<p>If you are interested in malware, the samples can be obtained from the following sites:</p>
<ul>
<li><a href="https://github.com/PacktPublishing/Mastering-Reverse-Engineering">https://github.com/PacktPublishing/Mastering-Reverse-Engineering</a></li>
<li><a href="https://github.com/ytisf/theZoo">https://github.com/ytisf/theZoo</a></li>
</ul>


            

            
        
    </div>



  
<div><h1 class="header-title">Summary</h1>
                
            
            
                
<p>Reverse engineering has been around for years and has been a useful technique to understand how things work. In the software industry, reverse engineering helps validate and fix code flow and structures. The information from such tasks can improve the security of various aspects of software, network infrastructure, and human awareness. As a core skill requirement for the anti-malware industry, reverse engineering helps create detection and remediation information; the same information that is used to build safeguards for an institution's servers. It is also used by authorities and forensic experts to hunt down syndicates.</p>
<p>There are basic steps that help build reverse engineering information. Once an analyst has approval from the original author to carry out reverse engineering, they can begin with static analysis, dynamic analysis, and then low-level analysis. This is then followed by reporting the overview and details about the software.</p>
<p>When doing analysis, various types of tools are used, including static analysis tools, disassemblers, decompilers, debuggers, and system monitoring tools. When doing reverse engineering on malware, it is best to use these tools in an environment that has limited or no access to the network you use for personal purposes or work. This should prevent your infrastructure from being compromised. Malware should be handled properly, and we listed a couple of ways to prevent accidental double-clicks.</p>
<p>Malware analysis nonetheless requires the internet to get further information on how the malware works and what it does. There may be some legal issues that require you to consult the laws of your country and the policies of your local ISP, to ensure that you are not violating any of them.</p>
<p>The core requirement for the setup of an analysis lab is that the target operating system can be reverted back to its unmodified state.</p>
<p>Malware samples can be obtained from the following link: <a href="https://github.com/PacktPublishing/Mastering-Reverse-Engineering/tree/master/tools">https://github.com/PacktPublishing/Mastering-Reverse-Engineering/tree/master/tools</a>. These samples will be used throughout this book.</p>
<p>Now that we have our basic setup, let's embark on our journey through reverse engineering.</p>


            

            
        
    </div>



  </body></html>