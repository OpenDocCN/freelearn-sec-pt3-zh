["```\n>>> CREATE TABLE custodians (id INTEGER PRIMARY KEY, name TEXT);\n```", "```\n>>> INSERT INTO custodians (id, name) VALUES (null, 'Chell');\n>>> INSERT INTO custodians (id, name) VALUES (null, 'GLaDOS');\n```", "```\n>>> SELECT * FROM custodians;\n1|Chell\n2|GLaDOS\n```", "```\n>>> SELECT name,id FROM custodians WHERE id = 1;\nChell|1 \n```", "```\n001 \"\"\"File metadata capture and reporting utility.\"\"\"\n002 import argparse\n003 import csv\n004 import datetime\n005 import logging\n006 import os\n007 import sqlite3\n008 import sys\n...\n038 __authors__ = [\"Chapin Bryce\", \"Preston Miller\"]\n039 __date__ = 20181027\n040 __description__ = '''This script uses a database to ingest and\n041    report meta data information about active entries in\n042     directories.'''\n043 logger = logging.getLogger(__name__)\n```", "```\n046 def main(custodian, target, db):\n...\n081 def init_db(db_path):\n...\n111 def get_or_add_custodian(conn, custodian):\n...\n132 def get_custodian(conn, custodian):\n...\n148 def ingest_directory(conn, target, custodian_id):\n...\n207 def format_timestamp(timestamp):\n...\n219 def write_output(conn, target, custodian):\n...\n254 def write_csv(conn, target, custodian_id):\n...\n280 def write_html(conn, target, custodian_id, custodian_name):\n```", "```\n320 if __name__ == '__main__':\n321     parser = argparse.ArgumentParser(\n322     description=__description__,\n323     epilog='Built by {}. Version {}'.format(\n324         \", \".join(__authors__), __date__),\n325     formatter_class=argparse.ArgumentDefaultsHelpFormatter\n326     )\n327     parser.add_argument(\n328         'CUSTODIAN', help='Name of custodian collection is of.')\n329     parser.add_argument(\n330         'DB_PATH', help='File path and name of database to '\n331                         'create or append metadata to.')\n332     parser.add_argument(\n333         '--input', help='Base directory to scan.')\n334     parser.add_argument(\n335         '--output', help='Output file to write to. use `.csv` '\n336                          'extension for CSV and `.html` for HTML')\n337     parser.add_argument(\n338         '-l', help='File path and name of log file.')\n339     args = parser.parse_args()\n```", "```\n341     if args.input:\n342         arg_source = ('input', args.input)\n343     elif args.output:\n344         arg_source = ('output', args.output)\n345     else:\n346        raise argparse.ArgumentError(\n347            'Please specify input or output')\n```", "```\n349     if args.l:\n350         if not os.path.exists(args.l):\n351             os.makedirs(args.l) # create log directory path\n352         log_path = os.path.join(args.l, 'file_lister.log')\n353     else:\n354         log_path = 'file_lister.log'\n355 \n356     logger.setLevel(logging.DEBUG)\n357     msg_fmt = logging.Formatter(\"%(asctime)-15s %(funcName)-20s\"\n358         \"%(levelname)-8s %(message)s\")\n359     strhndl = logging.StreamHandler(sys.stdout)\n360     strhndl.setFormatter(fmt=msg_fmt)\n361     fhndl = logging.FileHandler(log_path, mode='a')\n362     fhndl.setFormatter(fmt=msg_fmt)\n363     logger.addHandler(strhndl)\n364     logger.addHandler(fhndl)\n365 \n366     logger.info('Starting File Lister v.' + str(__date__))\n367     logger.debug('System ' + sys.platform)\n368     logger.debug('Version ' + sys.version)\n```", "```\n370     args_dict = {'custodian': args.CUSTODIAN,\n371                  'target': arg_source, 'db': args.DB_PATH}\n372 \n373     main(**args_dict)\n```", "```\n046 def main(custodian, target, db):\n047     \"\"\"\n048     The main function creates the database or table, logs\n049         execution status, and handles errors\n050     :param custodian: The name of the custodian\n051     :param target: tuple containing the mode 'input' or 'output'\n052         as the first elemnet and a file path as the second\n053     :param db: The filepath for the database\n054     :return: None\n055     \"\"\"\n```", "```\n056     logger.info('Initiating SQLite database: ' + db)\n057     conn = init_db(db)\n```", "```\n058     logger.info('Initialization Successful')\n059     logger.info('Retrieving or adding custodian: ' + custodian)\n060     custodian_id = get_or_add_custodian(conn, custodian)\n061     while not custodian_id:\n062         custodian_id = get_or_add_custodian(conn, custodian)\n063     logger.info('Custodian Retrieved')\n```", "```\n064     if target[0] == 'input':\n065         logger.info('Ingesting base input directory: {}'.format(\n066             target[1]))\n067         ingest_directory(conn, target[1], custodian_id)\n068         conn.commit()\n069         logger.info('Ingest Complete')\n```", "```\n070     elif target[0] == 'output':\n071         logger.info('Preparing to write output: ' + target[1])\n072         write_output(conn, target[1], custodian)\n073     else:\n074         raise argparse.ArgumentError(\n075             'Could not interpret run time arguments')\n076 \n077     conn.close()\n078     logger.info('Script Completed')\n```", "```\n081     def init_db(db_path):\n082     \"\"\"\n083     The init_db function opens or creates the database\n084     :param db_path: The filepath for the database\n085     :return: conn, the sqlite3 database connection\n086     \"\"\"\n087     if os.path.exists(db_path):\n088         logger.info('Found Existing Database')\n089         conn = sqlite3.connect(db_path)\n090     else:\n091         logger.info('Existing database not found. '\n092                     'Initializing new database')\n093         conn = sqlite3.connect(db_path)\n094         cur = conn.cursor()\n```", "```\n096         sql = \"\"\"CREATE TABLE Custodians (\n097                  cust_id INTEGER PRIMARY KEY, name TEXT);\"\"\"\n098         cur.execute(sql)\n```", "```\n099         cur.execute('PRAGMA foreign_keys = 1;')\n```", "```\n100         sql = \"\"\"CREATE TABLE Files(id INTEGER PRIMARY KEY,\n101             custodian INTEGER NOT NULL, file_name TEXT,\n102             file_path TEXT, extension TEXT, file_size INTEGER,\n103             mtime TEXT, ctime TEXT, atime TEXT, mode TEXT,\n104             inode INTEGER, FOREIGN KEY (custodian)\n105             REFERENCES Custodians(cust_id));\"\"\"\n106         cur.execute(sql)\n107         conn.commit()\n108     return conn\n```", "```\n111 def get_or_add_custodian(conn, custodian):\n112     \"\"\"\n113     The get_or_add_custodian function checks the database for a\n114         custodian and returns the ID if present;\n115         Or otherwise creates the custodian\n116     :param conn: The sqlite3 database connection object\n117     :param custodian: The name of the custodian\n118     :return: The custodian ID or None\n119     \"\"\"\n120     cust_id = get_custodian(conn, custodian)\n121     cur = conn.cursor()\n122     if cust_id:\n123         cust_id = cust_id[0]\n```", "```\n124     else:\n125         sql = \"\"\"INSERT INTO Custodians (cust_id, name) VALUES\n126             (null, '{}') ;\"\"\".format(custodian)\n127         cur.execute(sql)\n128         conn.commit()\n129     return cust_id\n```", "```\n132     def get_custodian(conn, custodian):\n133     \"\"\"\n134     The get_custodian function checks the database for a\n135         custodian and returns the ID if present\n136     :param conn: The sqlite3 database connection object\n137     :param custodian: The name of the custodian\n138     :return: The custodian ID\n139     \"\"\"\n140     cur = conn.cursor()\n141     sql = \"SELECT cust_id FROM Custodians \"\\\n142         \"WHERE name='{}';\".format(custodian)\n```", "```\n143     cur.execute(sql)\n144     data = cur.fetchone()\n145     return data\n```", "```\n148     def ingest_directory(conn, target, custodian_id):\n149     \"\"\"\n150     The ingest_directory function reads file metadata and stores\n151         it in the database\n152     :param conn: The sqlite3 database connection object\n153     :param target: The path for the root directory to\n154         recursively walk\n155     :param custodian_id: The custodian ID\n156     :return: None\n157     \"\"\"\n158     cur = conn.cursor()\n159     count = 0\n```", "```\n160     for root, _, files in os.walk(target):\n```", "```\n161         for file_name in files:\n162             meta_data = dict()\n```", "```\n163             try:\n164                 meta_data['file_name'] = file_name\n165                 meta_data['file_path'] = os.path.join(root,\n166                                                       file_name)\n167                 meta_data['extension'] = os.path.splitext(\n168                     file_name)[-1]\n```", "```\n170                 file_stats = os.stat(meta_data['file_path'])\n171                 meta_data['mode'] = str(oct(file_stats.st_mode))\n```", "```\n172                 meta_data['inode'] = int(file_stats.st_ino)\n173                 meta_data['file_size'] = int(file_stats.st_size)\n174                 meta_data['atime'] = format_timestamp(\n175                     file_stats.st_atime)\n176                 meta_data['mtime'] = format_timestamp(\n177                     file_stats.st_mtime)\n178                 meta_data['ctime'] = format_timestamp(\n179                     file_stats.st_ctime)\n```", "```\n180             except Exception as e:\n181                 logger.error(\n182                     'Error processing file: {} {}'.format(\n183                         meta_data.get('file_path', None),\n184                         e.__str__()))\n```", "```\nINSERT INTO Files\n    (\"custodian\",\"ctime\",\"mtime\",\"extension\",\"inode\",\n     \"file_size\",\"file_name\",\"mode\",\"atime\",\"file_path\")\nVALUES \n    (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\n```", "```\n185             meta_data['custodian'] = custodian_id\n186             sql = 'INSERT INTO Files (\"{}\") VALUES ({})'.format(\n187                 '\",\"'.join(meta_data.keys()),\n188                 ', '.join('?' for x in meta_data.values()))\n189             try:\n190                 cur.execute(sql, tuple(meta_data.values()))\n```", "```\n191             except (sqlite3.OperationalError,\n192                     sqlite3.IntegrityError) as e:\n193                 logger.error(\n194                     \"Could not insert statement {}\"\n195                     \" with values: {}\".format(\n196                         sql, meta_data.values()))\n197                 logger.error(\"Error message: {}\".format(e))\n198             count += 1\n```", "```\n199         conn.commit()\n200     conn.commit()\n201     logger.info('Stored meta data for {} files.'.format(count))\n```", "```\n204 def format_timestamp(timestamp):\n205     \"\"\"\n206     The format_timestamp function formats an integer to a string\n207     timestamp\n208     :param timestamp: An integer timestamp\n209     :return: ts_format, a formatted (YYYY-MM-DD HH:MM:SS) string\n210     \"\"\"\n211     ts_datetime = datetime.datetime.fromtimestamp(timestamp)\n212     ts_format = ts_datetime.strftime('%Y-%m-%d %H:%M:%S')\n213     return ts_format\n```", "```\n216 def write_output(conn, target, custodian):\n217     \"\"\"\n218     The write_output function handles writing either the CSV or\n219     HTML reports\n220     :param conn: The sqlite3 database connection object\n221     :param target: The output filepath\n222     :param custodian: Name of the custodian\n223     :return: None\n224     \"\"\"\n225     custodian_id = get_custodian(conn, custodian)\n226     cur = conn.cursor()\n227     if custodian_id:\n228         custodian_id = custodian_id[0]\n229         sql = \"SELECT COUNT(id) FROM Files \"\\\n230               \"where custodian = {}\".format(\n231                   custodian_id)\n232         cur.execute(sql)\n233         count = cur.fetchone()\n234     else:\n235         logger.error(\n236             'Could not find custodian in database. Please check '\n237             'the input of the custodian name and database path')\n```", "```\n239     if not count or not count[0] > 0:\n240         logger.error('Files not found for custodian')\n241     elif target.endswith('.csv'):\n242         write_csv(conn, target, custodian_id)\n243     elif target.endswith('.html'):\n244         write_html(conn, target, custodian_id, custodian)\n245     elif not (target.endswith('.html')or target.endswith('.csv')):\n246         logger.error('Could not determine file type')\n247     else:\n248         logger.error('Unknown Error Occurred')\n```", "```\n251 def write_csv(conn, target, custodian_id):\n252     \"\"\"\n253     The write_csv function generates a CSV report from the\n254     Files table\n255     :param conn: The Sqlite3 database connection object\n256     :param target: The output filepath\n257     :param custodian_id: The custodian ID\n258     :return: None\n259     \"\"\"\n260     cur = conn.cursor()\n261     sql = \"SELECT * FROM Files where custodian = {}\".format(\n262         custodian_id)\n263     cur.execute(sql)\n264 \n265     cols = [description[0] for description in cur.description]\n```", "```\n266     logger.info('Writing CSV report')\n267     with open(target, 'w', newline=\"\") as csv_file:\n268         csv_writer = csv.writer(csv_file)\n269         csv_writer.writerow(cols)\n270 \n271         for entry in cur:\n272             csv_writer.writerow(entry)\n273         csv_file.flush()\n274     logger.info('CSV report completed: ' + target)\n```", "```\n277 def write_html(conn, target, custodian_id, custodian_name):\n278     \"\"\"\n279     The write_html function generates an HTML report from the\n280         Files table\n281     :param conn: The sqlite3 database connection object\n282     :param target: The output filepath\n283     :param custodian_id: The custodian ID\n284     :return: None\n285     \"\"\"\n286     cur = conn.cursor()\n287     sql = \"SELECT * FROM Files where custodian = {}\".format(\n288         custodian_id)\n289     cur.execute(sql)\n290 \n291     cols = [description[0] for description in cur.description]\n292     table_header = '</th><th>'.join(cols)\n293     table_header = '<tr><th>' + table_header + '</th></tr>'\n294 \n295     logger.info('Writing HTML report')\n```", "```\n297     with open(target, 'w') as html_file:\n298         html_string = \"\"\"<html><body>\\n\n299             <link rel=\"stylesheet\"\n300             href=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap.min.css\">\n301             <h1>File Listing for Custodian ID: {}, {}</h1>\\n\n302             <table class='table table-hover table-striped'>\\n\n303             \"\"\".format(custodian_id, custodian_name)\n304             html_file.write(html_string)\n305             html_file.write(table_header)\n```", "```\n307         for entry in cur:\n308             row_data = \"</td><td>\".join(\n309                 [str(x) for x in entry])\n```", "```\n310             html_string = \"\\n<tr><td>\" + row_data + \"</td></tr>\"\n311             html_file.write(html_string)\n312             html_file.flush()\n313         html_string = \"\\n</table>\\n</body></html>\"\n314         html_file.write(html_string)\n315     logger.info('HTML Report completed: ' + target)\n```", "```\n001 \"\"\"File metadata capture and reporting utility.\"\"\"\n002 import argparse\n003 import datetime\n004 from io import open\n005 import logging\n006 import os\n007 import sys\n008 import unicodecsv as csv\n009 import peewee\n010 import jinja2\n```", "```\n040 __authors__ = [\"Chapin Bryce\", \"Preston Miller\"]\n041 __date__ = 20181027\n042 __description__ = '''This script uses a database to ingest and\n043     report meta data information about active entries in\n044     directories.'''\n045 logger = logging.getLogger(__name__)\n046 database_proxy = peewee.Proxy()\n047 \n048 class BaseModel(peewee.Model):\n...\n052 class Custodians(BaseModel):\n...\n055 class Files(BaseModel):\n...\n069 def get_template():\n...\n106 def main(custodian, target, db):\n...\n138 def init_db(db):\n...\n150 def get_or_add_custodian(custodian):\n...\n167 def ingest_directory(source, custodian_model):\n...\n216 def format_timestamp(ts):\n...\n226 def write_output(source, custodian_model):\n...\n253 def write_csv(source, custodian_model):\n...\n282 def write_html(source, custodian_model):\n```", "```\n046 database_proxy = peewee.Proxy()\n047 \n048 class BaseModel(peewee.Model):\n049     class Meta:\n050         database = database_proxy\n```", "```\n052 class Custodians(BaseModel):\n053     name = peewee.TextField(unique=True)\n```", "```\n055 class Files(BaseModel):\n056     id = peewee.PrimaryKeyField(unique=True, primary_key=True)\n057     custodian = peewee.ForeignKeyField(Custodians)\n058     file_name = peewee.TextField()\n059     file_path = peewee.TextField()\n060     extension = peewee.TextField()\n061     file_size = peewee.IntegerField()\n062     atime = peewee.DateTimeField()\n063     mtime = peewee.DateTimeField()\n064     ctime = peewee.DateTimeField()\n065     mode = peewee.TextField()\n066     inode = peewee.IntegerField()\n```", "```\n069 def get_template():\n070     \"\"\"\n071     The get_template function returns a basic template for our\n072     HTML report\n073     :return: Jinja2 Template\n074     \"\"\"\n075     html_string = \"\"\"\n076         <html>\\n<head>\\n<link rel=\"stylesheet\"\n077         href=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/\ncss/bootstrap.min.css\">\n```", "```\n078         </head>\\n<body>\\n<h1>\n079         File Listing for Custodian {{ custodian.id }},\n080         {{ custodian.name }}</h1>\\n\n```", "```\n081         <table class=\"table table-hover table-striped\">\\n\n082         <tr>\\n\n083         {% for header in table_headers %}\n084             <th>{{ header }}</th>\n085         {% endfor %}\n086         </tr>\\n\n```", "```\n087         {% for entry in file_listing %}\n088             <tr>\n089                 <td>{{ entry.id }}</td>\n090                 <td>{{ entry.custodian.name }}</td>\n091                 <td>{{ entry.file_name }}</td></td>\n092                 <td>{{ entry.file_path }}</td>\n093                 <td>{{ entry.extension }}</td>\n094                 <td>{{ entry.file_size }}</td>\n095                 <td>{{ entry.atime }}</td>\n096                 <td>{{ entry.mtime }}</td>\n097                 <td>{{ entry.ctime }}</td>\n098                 <td>{{ entry.mode }}</td>\n099                 <td>{{ entry.inode }}</td>\n100             </tr>\\n\n101         {% endfor %}\n```", "```\n102         </table>\\n</body>\\n</html>\"\"\"\n103     return jinja2.Template(html_string)\n```", "```\n106 def main(custodian, target, db):\n107     \"\"\"\n108     The main function creates the database or table, logs\n109         execution status, and handles errors\n110     :param custodian: The name of the custodian\n111     :param target: tuple containing the mode 'input' or 'output'\n112         as the first element and its arguments as the second\n113     :param db: The file path for the database\n114     :return: None\n115     \"\"\"\n116     logger.info('Initializing Database')\n117     init_db(db)\n118     logger.info('Initialization Successful')\n119     logger.info('Retrieving or adding custodian: ' + custodian)\n120     custodian_model = get_or_add_custodian(custodian)\n```", "```\n121     if target[0] == 'input':\n122         logger.info('Ingesting base input directory: {}'.format(\n123             target[1]))\n124         ingest_directory(target[1], custodian_model)\n125         logger.info('Ingesting Complete')\n126     elif target[0] == 'output':\n127         logger.info(\n128             'Preparing to write output for custodian: {}'.format(\n129                 custodian))\n130         write_output(target[1], custodian_model)\n131         logger.info('Output Complete')\n132     else:\n133         logger.error('Could not interpret run time arguments')\n134 \n135     logger.info('Script Complete')\n```", "```\n138 def init_db(db):\n139     \"\"\"\n140 The init_db function opens or creates the database\n141     :param db_path: The file path for the database\n142     :return: conn, the sqlite3 database connection\n143     \"\"\"\n144     database = peewee.SqliteDatabase(db)\n```", "```\n145 database_proxy.initialize(database)\n146 table_list = [Custodians, Files] # Update with any new tables\n147 database.create_tables(table_list, safe=True)\n```", "```\n150 def get_or_add_custodian(custodian):\n151     \"\"\"\n152     The get_or_add_custodian function gets the custodian by name\n153         or adds it to the table\n154     :param custodian: The name of the custodian\n155     :return: custodian_model, custodian peewee model instance\n156     \"\"\"\n157     custodian_model, created = Custodians.get_or_create(\n158         name=custodian)\n159     if created:\n160         logger.info('Custodian added')\n161     else:\n162         logger.info('Custodian retrieved')\n163 \n164     return custodian_model\n```", "```\n167 def ingest_directory(source, custodian_model):\n168     \"\"\"\n169     The ingest_directory function reads file metadata and stores\n170         it in the database\n171     :param source: The path for the root directory to\n172         recursively walk\n173     :param custodian_model: Peewee model instance for the\n174         custodian\n175     :return: None\n176     \"\"\"\n177     file_data = []\n178     for root, _, files in os.walk(source):\n179         for file_name in files:\n180             ddate = datetime.datetime.min\n181             meta_data = {\n182                 'file_name': None, 'file_path': None,\n183                 'extension': None, 'mode': -1, 'inode': -1,\n184                 'file_size': -1, 'atime': ddate, 'mtime': ddate,\n185                 'ctime': ddate, 'custodian': custodian_model.id}\n186             try:\n187                 meta_data['file_name'] = os.path.join(file_name)\n188                 meta_data['file_path'] = os.path.join(root,\n189                     file_name)\n190                 meta_data['extension'] = os.path.splitext(\n191                     file_name)[-1]\n192 \n193                 file_stats = os.stat(meta_data['file_path'])\n194                 meta_data['mode'] = str(oct(file_stats.st_mode))\n195                 meta_data['inode'] = str(file_stats.st_ino)\n196                 meta_data['file_size'] = str(file_stats.st_size)\n197                 meta_data['atime'] = format_timestamp(\n198                     file_stats.st_atime)\n199                 meta_data['mtime'] = format_timestamp(\n200                     file_stats.st_mtime)\n201                 meta_data['ctime'] = format_timestamp(\n202                     file_stats.st_ctime)\n203             except Exception as e:\n204                 logger.error(\n205                     'Error processing file: {} {}'.format(\n206                         meta_data['file_path'], e.__str__()))\n207             file_data.append(meta_data)\n```", "```\n209     for x in range(0, len(file_data), 50):\n210         task = Files.insert_many(file_data[x:x+50])\n211         task.execute()\n212     logger.info('Stored meta data for {} files.'.format(\n213         len(file_data)))\n```", "```\n216 def format_timestamp(ts):\n217     \"\"\"\n218     The format_timestamp function converts an integer into a\n219     datetime object\n220     :param ts: An integer timestamp\n221     :return: A datetime object\n222     \"\"\"\n223     return datetime.datetime.fromtimestamp(ts)\n```", "```\n226 def write_output(source, custodian_model):\n227     \"\"\"\n228     The write_output function handles writing either the CSV or\n229         HTML reports\n230     :param source: The output filepath\n231     :param custodian_model: Peewee model instance for the\n232         custodian\n233     :return: None\n234     \"\"\"\n235     count = Files.select().where(\n236         Files.custodian == custodian_model.id).count()\n237 \n238     logger.info(\"{} files found for custodian.\".format(count))\n```", "```\n240     if not count:\n241         logger.error('Files not found for custodian')\n242     elif source.endswith('.csv'):\n243         write_csv(source, custodian_model)\n244     elif source.endswith('.html'):\n245         write_html(source, custodian_model)\n246     elif not (source.endswith('.html') or \\\n247         source.endswith('.csv')):\n248         logger.error('Could not determine file type')\n249     else:\n250         logger.error('Unknown Error Occurred')\n```", "```\n253 def write_csv(source, custodian_model):\n254     \"\"\"\n255     The write_csv function generates a CSV report from the Files\n256         table\n257     :param source: The output filepath\n258     :param custodian_model: Peewee model instance for the\n259         custodian\n260     :return: None\n261     \"\"\"\n262     query = Files.select().where(\n263         Files.custodian == custodian_model.id).dicts()\n264     logger.info('Writing CSV report')\n```", "```\n266     cols = [u'id', u'custodian', u'file_name', u'file_path',\n267         u'extension', u'file_size', u'ctime', u'mtime',\n268         u'atime', u'mode', u'inode']\n269 \n270     with open(source, 'wb') as csv_file:\n271         csv_writer = csv.DictWriter(csv_file, cols)\n272         csv_writer.writeheader()\n273         for counter, row in enumerate(query):\n274             csv_writer.writerow(row)\n275             if counter % 10000 == 0:\n276                 logger.debug('{:,} lines written'.format(counter))\n277         logger.debug('{:,} lines written'.format(counter))\n278 \n279     logger.info('CSV Report completed: ' + source)\n```", "```\n282 def write_html(source, custodian_model):\n283     \"\"\"\n284     The write_html function generates an HTML report from the\n285         Files table\n286     :param source: The output file path\n287     :param custodian_model: Peewee model instance for the\n288         custodian\n289     :return: None\n290     \"\"\"\n291     template = get_template()\n292     table_headers = [\n293         'Id', 'Custodian', 'File Name', 'File Path',\n294         'File Extension', 'File Size', 'Created Time',\n295         'Modified Time', 'Accessed Time', 'Mode', 'Inode']\n```", "```\n296     file_data = Files.select().where(\n297         Files.custodian == custodian_model.id)\n```", "```\n299     template_dict = {\n300         'custodian': custodian_model,\n301         'table_headers': table_headers,\n302         'file_listing': file_data}\n303 \n304     logger.info('Writing HTML report')\n305 \n306     with open(source, 'w') as html_file:\n307         html_file.write(template.render(**template_dict))\n308 \n309     logger.info('HTML Report completed: ' + source)\n```"]