- en: Extracting Artifacts from Binary Files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Parsing binary data is an indispensable skill. Inevitably, we are tasked with
    analyzing artifacts that are unfamiliar or undocumented. This issue is compounded
    when the file of interest is a binary file. Rather than analyzing a text-like
    file, we often need to use our favorite hex editor to begin reverse engineering
    the file's internal binary structure. Reverse engineering the underlying logic
    of binary files is out of scope for this chapter. Instead, we will work with a
    binary object whose structure is already well-known. This will allow us to highlight
    how to use Python to parse these binary structures automatically once the internal
    structure is understood. In this chapter, we will examine the `UserAssist` registry
    key from the `NTUSER.DAT` registry hive.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter illustrates how to extract Python objects from binary data and
    generate an automatic Excel report. We will use three modules to accomplish this
    task: `struct`, `yarp`, and `xlsxwriter`. Although the `struct` module is included
    in the standard installation of Python, both `yarp` and `xlsxwriter` must be installed
    separately. We will cover how to install these modules in their respective sections.'
  prefs: []
  type: TYPE_NORMAL
- en: The `struct` library is used to parse the binary object into Python objects.
    Once we have parsed the data from the binary object, we can write our findings
    into a report. In past chapters, we have reported results in the CSV or HTML files.
    In this chapter, we will create an Excel report containing tables and summary
    charts of the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the `UserAssist` artifact and its binary structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An introduction to ROT-13 encoding and decoding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing and manipulating registry files with the `yarp` module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `struct` to extract Python objects from binary data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating worksheets, tables, and charts using `xlsxwriter`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code for this chapter was developed and tested using Python 2.7.15 and Python
    3.7.1
  prefs: []
  type: TYPE_NORMAL
- en: UserAssist
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `UserAssist` artifact identifies **graphical user interface** (**GUI**)
    application execution on Windows machines. This artifact stores differing amounts
    of information depending on the version of Windows OS. To identify the data specific
    to certain applications, we have to decode the registry key name as it is stored
    as the ROT13-encoded path and name of the application. As an example, the `UserAssist`
    value data for Windows XP and Vista is 16 bytes in length, and it stores the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The last execution time in UTC (in FILETIME format)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Execution count
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Session ID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last execution time information is stored as a Windows FILETIME object.
    This is another common representation of time that differs from the UNIX timestamps
    we've seen in previous chapters. We will show how this timestamp can be interpreted
    within Python and displayed as human-readable, later in this chapter. The execution
    count represents the number of times the application has been launched.
  prefs: []
  type: TYPE_NORMAL
- en: 'Windows 7 and higher store even more data than their predecessors. Windows
    7 `UserAssist` values are 72 bytes in length and, in addition to the three previously
    mentioned artifacts, store the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Focus count
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Focus time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The focus count is the number of times the application was clicked on to bring
    it back into focus. For example, when you have two applications opened, only one
    is in focus at a given time. The other application is inactive until it is clicked
    on again. The focus time is the total amount of time a given application was in
    focus, and it is expressed in milliseconds.
  prefs: []
  type: TYPE_NORMAL
- en: This registry artifact does not store the execution of command-line-based programs
    or GUI applications that are Windows startup programs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `UserAssist` registry key is located within the `NTUSER.DAT` registry hive
    found in the root folder of every user''s home directory. Within this hive, the
    `UserAssist` key is found at `SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\UserAssist`.
    Subkeys of the `UserAssist` key consist of known GUIDs and their respective count
    subkey. Within the count subkey of each GUID, there may be numerous values related
    to program execution. This structure is demonstrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The values within the count subkey store the application execution information
    we are interested in parsing. Each value's name under the count subkey represents
    the ROT-13-encoded path and name of the executable. This makes it difficult to
    identify executables at first glance. Let's fix that.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the ROT-13 substitution cipher – rot13.py
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ROT-13 is a simple substitution cipher that transforms text and substitutes
    each character with another, thirteen characters after it. For example, the letter
    `a` would be substituted with the letter `n` and vice versa. Elements such as
    numbers, special characters, and a character's case are unaffected by the cipher.
    While Python does offer a built-in way of decoding ROT-13, we are going to pretend
    that it doesn't exist and manually decode ROT-13 data. We will use the built-in
    ROT-13 decoding method in our script.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we pretend that this functionality doesn''t exist, let''s quickly use
    it to illustrate how we could encode and decode ROT-13 data with Python 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Decoding or encoding with ROT-13 in Python 3 requires a slightly different
    approach with the native `codecs` library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's look at how you might approach this if it weren't already built-in.
    While you should never reinvent the wheel, we want to take this opportunity to
    practice list operations and introduce a tool to audit code. The code from the
    `rot13.py` script in the code bundle for this chapter is demonstrated next.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `rot_code()` function defined at line 32 accepts a ROT-13-encoded or ROT-13-decoded
    string. On line 39, we have `rot_chars`, a list of characters in the alphabet.
    As we iterate through each character in the supplied input, we will use this list
    to substitute the character with its counterpart 13 elements away. As we execute
    this substitution, we will store them in the substitutions list instantiated in
    line 43:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'On line 46, we begin to walk through each character, `c`, in the data string.
    On line 49, we use a conditional statement to determine if the character is uppercase
    or lowercase. We do this to preserve the case of the character as we process it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'On line 54, we attempt to identify the index of the character in our list.
    If the character is a non-alphabetical character, we will receive a `ValueError`
    exception. Non-alphabetical characters, such as numbers or special characters,
    are appended to the substitutions list unmodified as these types of values are
    not encoded by ROT-13:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have found the index of the character, we can calculate the corresponding
    index 13 characters away by subtracting 13\. For values less than 13, this will
    be a negative number. Fortunately, list indexing supports negative numbers and
    works splendidly here. Before appending the corresponding character to our substitutions
    list, we use the string `upper()` function to return the character to its original
    case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The `else` statement of the conditional block handles lowercase characters.
    The following code block is substantially the same functionality as what we just
    covered. The difference is that we never use lowercase or uppercase because the
    character is already in the proper case to be processed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, on line 76, we collapse the substitutions list to a string using the
    `join()` method. We join on an empty string so that each element of the list is
    appended without any separating characters. If this script is invoked from the
    command line, it will print out the processed string, `Jul, EBG-13?`, which we
    know corresponds to `ROT-13?`. We have the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot illustrates how we can import our `rot13` module and
    call the `rot_code()` method to either decode or encode a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b57fa910-b502-48b3-9555-b4d80ba72530.png)'
  prefs: []
  type: TYPE_IMG
- en: Make sure that the Python interactive prompt is opened in the same directory
    as the `rot13.py` script. Otherwise, an `ImportError` will be generated.
  prefs: []
  type: TYPE_NORMAL
- en: Evaluating code with timeit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s now audit our module and see if it is superior to the built-in method
    (spoiler: it''s not!) We mentioned that you should never reinvent the wheel unless
    absolutely required. There''s a good reason: most built-in or third-party solutions
    have been optimized for performance and security. How does our `rot_code()` function
    stack up against the built-in function? We can use the `timeit` module to calculate
    the time a function or line of code takes to execute.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's compare the difference between the two methods of decoding ROT-13 values.
    Supplying the Python interpreter with `-m` executes a named module if its parent
    directory is found in the `sys.path` list. The `timeit` module can be called directly
    from the command line using the `-m` switch.
  prefs: []
  type: TYPE_NORMAL
- en: We can see what directories are in scope by importing the `sys` module and printing
    `sys.path`. To extend the items available through `sys.path`, we can append new
    items to it using list attributes, such as append or extend.
  prefs: []
  type: TYPE_NORMAL
- en: The `timeit` module supports a variety of switches, and can be used to run individual
    lines of code or entire scripts. The `-v` switch prints more verbose output, and
    is increasingly more verbose when supplied with additional `v` switches. The `-n`
    switch is the number of times to execute the code or script (for example, the
    number of executions per measuring period). We can use the `-r` switch to specify
    how many times to repeat a measurement (defaults to `3`). Increasing this will
    allow us to calculate a more accurate average execution speed. Finally, the `-s`
    switch is a statement to be run once on the first round of execution, in this
    case, to allow us to import the script we made. For further documentation, please
    visit [http://docs.python.org/3/library/timeit.html](http://docs.python.org/3/library/timeit.html)
    or run `python -m timeit -h`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output generated on our computer when timing both methods is captured in
    the following screenshot. Performance may vary depending on the machine. For our
    first test, we measured the time it took to run three one million cycles of our
    script. On the first cycle, we imported our module, `rot13`, before calling it.
    On the second test, we similarly measured three one-million cycles of the built-in
    Python 2 `decode()` functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4a42bb2c-e3a3-452b-8dbe-5b982a4a4104.png)'
  prefs: []
  type: TYPE_IMG
- en: It turns out that there is good reason to not reinvent the wheel. Our custom
    `rot_code()` function is significantly slower than the built-in method when run
    a thousand times. Odds are we will not call this function a thousand times; for
    the `UserAssist` key, this function will likely be called only hundreds of times.
    However, if we were working with more data or had a particularly slow script,
    we could begin timing individual functions or lines of code to identify poorly
    optimized code.
  prefs: []
  type: TYPE_NORMAL
- en: As an aside, you can also use the `time.time()` function before and after a
    function call and calculate the elapsed time by subtracting the two times. This
    alternative approach is slightly simpler to implement but not as robust.
  prefs: []
  type: TYPE_NORMAL
- en: You have now learned about the `UserAssist` artifact, ROT-13 encoding, and a
    mechanism to audit our code. Let's shift focus and examine other modules that
    will be used in this chapter. One of those modules, `yarp`, will be used to access
    and interact with the `UserAssist` key and values.
  prefs: []
  type: TYPE_NORMAL
- en: Working with the yarp library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **yarp** (short for **Yet Another Registry Parser**) library can be used
    to obtain keys and values from registry hives. Python provides a built-in registry
    module named `_winreg`; however, this module only works on Windows machines. The
    `_winreg` module interacts with the registry on the system running the module.
    It does not support opening external registry hives.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `yarp` library allows us to interact with supplied registry hives and can
    be run on non-Windows machines. The `yarp` library can be downloaded from [https://github.com/msuhanov/yarp](https://github.com/msuhanov/yarp).
    On the project''s GitHub page, click on the releases section to see a list of
    all stable versions and download the desired version. For this chapter, we use
    version 1.0.25\. Once the archived file is downloaded and extracted, we can run
    the included `setup.py` file to install the module. In a Command Prompt, execute
    the following code in the module''s top-level directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This should install the `yarp` library successfully on your machine. We can
    confirm by opening the Python interactive prompt and typing `import yarp`. We
    will receive an error if the module was not installed successfully. With `yarp`
    installed, let's begin learning how we can leverage this module for our needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to import the `Registry` class from the `yarp` module. Then,
    we use the `RegistryHive` function and pass it the registry object we want to
    query. In this example, we have copied the `NTUSER.DAT` registry file to our current
    working directory, which allows us to supply just the filename and not the path.
    Next, we use the `find_key` method to navigate to our key of interest. In this
    case, we are interested in the `RecentDocs` registry key. This key contains recent
    active files separated by extension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'If we print the `recent_docs` variable, we can see that it contains 151 values
    with 75 subkeys, which may contain additional values and subkeys. In addition,
    we can use the `last_written_timestamp()` method to see the last written time
    of the registry key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We can iterate over the values in the `recent_docs` key using the `subkeys()` function
    in a for loop. For each value, we can access the `name()`, `value()`, and `values_count()`
    methods, among others. When accessing a value (as opposed to a subkey), we can
    also access the value''s raw data by using the `raw_data()` function. For our
    purposes, we use the `raw_data()` function when we want to work with the underlying
    binary data. We have the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Another useful feature of the `yarp` module is a provided means of querying
    for a certain subkey or value. This is provided by the `subkey()`, `value()`,
    or `find_key()` functions. A `None` value is generated when a subkey is not present
    when using the `subkey()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `find_key()` function takes a path and can find a subkey recursively through
    multiple levels. The `subkey()` and `value()` functions search only child elements.
    We can use these functions to confirm that a key or value exists before trying
    to navigate to them. `yarp` has a number of other relevant features not covered
    here, including recovering deleted registry keys and values, carving registry
    keys and values, and supporting transaction log files.
  prefs: []
  type: TYPE_NORMAL
- en: With the `yarp` module, finding keys and their values is straightforward. However,
    when the values are not strings and are instead binary data, we have to rely on
    another module to make sense of the mess. For all binary needs, the `struct` module
    is an excellent candidate.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the struct module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `struct` module is part of the standard Python library and is incredibly
    useful. The `struct` library is used to convert C structures to or from binary
    data. Full documentation for this module can be found at [http://docs.python.org/3/library/struct.html](http://docs.python.org/3/library/struct.html).
  prefs: []
  type: TYPE_NORMAL
- en: For forensic purposes, the most important function in the struct module is the
    `unpack()` method. This method takes a format string representing the objects
    to be extracted from the binary data. It is important that the size dictated by
    the format string correlates to the size of the binary data supplied to the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The format string informs the `unpack()` function of what kind of data is in
    the binary object and how it should be interpreted. If we do not correctly identify
    the types of data or try to unpack more or less than what is provided, the `struct`
    module will throw an exception. The following is a table of the most common characters
    we use to build our format strings. The standard size column indicates the expected
    size of the binary object in bytes:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Character** | **Python object** | **Standard size (bytes)** |'
  prefs: []
  type: TYPE_TB
- en: '| `h` | Integer | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| `i` | Integer | 4 |'
  prefs: []
  type: TYPE_TB
- en: '| `q` | Integer | 8 |'
  prefs: []
  type: TYPE_TB
- en: '| `s` | String | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| `x` | N/A | N/A |'
  prefs: []
  type: TYPE_TB
- en: There are additional characters that can be used in format strings. For example,
    other characters can interpret binary data as floats, Booleans, and other various
    C structures. The `x` character is simply a padding character that can be used
    to ignore bytes we're not interested in.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, an optional starting character can be used to define byte order,
    size, and alignment. The default is native byte order, size, and alignment. As
    we cannot predict the environment the script might be running on, it is often
    not advisable to use any native option. Instead, we can specify little or big
    endian byte order with standard sizes using the `<" and ">` symbols, respectively.
    Let's practice with a few examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, open an interactive prompt and import `struct`. Next, we assign 0x01000000
    to a variable. In Python 3, hex notation is specified by an escape character and
    an `x` before every two hexadecimal characters. The length of our hex data is
    four bytes, and to interpret this as an integer, we use the `i` character. Interpreting
    the hex as a little endian integer returns a value of `1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The `<i` and `>i` represents the string format. We are telling the `unpack()`
    method to interpret `raw_data` as a four-byte integer in little or big endian
    byte ordering. The struct module returns the unpacked data as a tuple. By default,
    Python will print a single element tuple in parenthesis with a trailing comma,
    as seen in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look at another example. We can interpret `rawer_data` as three 4-byte
    integers by using three `i` characters. Alternatively, we can prepend a number
    to the format character to parse multiple values in a row. In both cases, when
    interpreted as a little endian, we receive the integers `1`, `5`, and `4`. If
    we aren''t interested in the middle integer, we can skip it with the `4x` character:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We raised the possibility of errors with struct earlier in this section. Now,
    let''s purposely create errors with struct to understand what they mean. We receive
    an error for the following two examples because we tried to `unpack()` more or
    fewer values than were actually present in the `rawer_data` variable used previously.
    This can cause some initial frustration when trying to unpack a large amount of
    binary data. Always be sure to check the math, the byte order, and whether the
    size is standard or native:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take it one step further and parse a `UserAssist` value using the struct
    module. We will parse a Windows XP value, which represents the easiest scenario
    as it is only 16 bytes in length. The byte offsets of a Windows XP UserAssist
    value are recorded in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Byte offset** | **Value** | **Object** |'
  prefs: []
  type: TYPE_TB
- en: '| 0-3 | Session ID | Integer |'
  prefs: []
  type: TYPE_TB
- en: '| 4-7 | Count | Integer |'
  prefs: []
  type: TYPE_TB
- en: '| 8-15 | FILETIME | Integer |'
  prefs: []
  type: TYPE_TB
- en: 'The following hex dump is saved into the file `Neguhe Qrag.bin`. The file is
    packaged with the code bundle that can be downloaded from [https://packtpub.com/books/content/support](https://packtpub.com/books/content/support):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'When unpacking data from a file object, we need to open it in the `rb` mode
    rather than the default `r` mode to ensure that we can read the data as bytes.
    Once we have the raw data, we can parse it using our specific character format.
    We know that the first 8 bytes are two 4-byte integers (`2i`), and then one 8-byte
    integer (`q`) representing the FILETIME of the `UserAssist` value. We can use
    indexing on the returned tuple to print out each extracted integer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Once we have parsed the `UserAssist` values in our script, we will present the
    results in a report-ready format. In the past, we have used CSV and HTML for output
    reports. Frequently, reports are often reviewed in spreadsheet format using software
    such as Microsoft Excel. To provide reports that fully leverage this software,
    we will learn how to create XSLX-formatted spreadsheets as an output of our script.
  prefs: []
  type: TYPE_NORMAL
- en: Creating spreadsheets with the xlsxwriter module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`xlsxwriter` (version 1.1.2) is a useful third-party module that can write
    data to Excel spreadsheets. There are a plethora of Excel-supported modules for
    Python, but we chose this module because it was highly robust and well-documented.
    As the name suggests, this module can only be used to write Excel spreadsheets.
    The `xlsxwriter` module supports cell and conditional formatting, charts, tables,
    filters, and macros, among others. This module can be installed with `pip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Adding data to a spreadsheet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s quickly create a script named `simplexlsx.v1.py` for this example. On
    lines 2 and 3, we import the `xlsxwriter` and `datetime` modules. The data we
    are going to be plotting, including the column names, is stored as nested lists
    in the `school_data` variable. Each list is a row of information we will want
    to store in the Excel spreadsheet, with the first element containing the column
    names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The `write_xlsx()` function, defined on line 45, is responsible for writing
    our data to a spreadsheet. First, we must create our Excel spreadsheet using the
    `Workbook()` function and supplying the desired name of the file as an input.
    On line 53, we create a worksheet using the `add_worksheet()` function. This function
    can take the desired title of the worksheet or use the default name `Sheet N`,
    where `N` represents a number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The `date_format` variable stores a custom number format we will use to display
    our `datetime` objects in the desired human-readable format. On line 58, we begin
    to enumerate through our data to write. The conditional on line 59 is used to
    handle the first item, the column names, in the data list. We use the `write()`
    function and supply a numerical row and column. Alternatively, for instance, rather
    than using numerical values to represent the column and row to write the data
    to, we could have also used Excel notation such as `A1` to signify the data should
    be written to the first column and row:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The `write()` method will try to write the appropriate data type for an object
    when it can detect that data''s type. However, we can use different write methods
    to specify the correct format. These specialized writers preserve the data type
    in Excel, so we can use the appropriate data type-specific Excel functions for
    the object. Since we know the data types within the entry list, we can manually
    specify when to use the general `write()` function versus the `write_number()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'For the fourth entry in the list, the `datetime` object, we supply the `write_datetime()`
    function with our `date_format` defined on line 55\. After our data is written
    to the workbook, we use the `close()` function to close and save our spreadsheet.
    On line 73, we call the `write_xlsx()` function, passing it the `school_data`
    list we built earlier, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'A table of `write` functions and the objects they preserve is presented as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Function** | **Supported objects** |'
  prefs: []
  type: TYPE_TB
- en: '| `write_string` | `str` |'
  prefs: []
  type: TYPE_TB
- en: '| `write_number` | `int`, `float`, `long` |'
  prefs: []
  type: TYPE_TB
- en: '| `write_datetime` | `datetime` objects |'
  prefs: []
  type: TYPE_TB
- en: '| `write_boolean` | `bool` |'
  prefs: []
  type: TYPE_TB
- en: '| `write_url` | `str` |'
  prefs: []
  type: TYPE_TB
- en: 'When the script is invoked at the command line, a spreadsheet named `MyWorkbook.xlsx`
    is created. When we convert this to a table, we can sort by any of our values
    and use Excel functions and features we are all familiar with. Had we failed to
    preserve the data types, values such as our dates might be displayed differently
    than intended:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6ebf556b-de5e-4dcd-90d4-4920d67fd960.png)'
  prefs: []
  type: TYPE_IMG
- en: Building a table
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Being able to write data to an Excel file and preserve the object type is already
    a step up over CSV, but we can do better. Often, the first thing an examiner will
    do with an Excel spreadsheet is convert the data into a table and begin the frenzy
    of sorting and filtering the data set. However, we can convert our data range
    to a table using `xlsxwriter`. In fact, writing a table with `xlsxwriter` is arguably
    easier than writing each row individually. The code discussed in this section
    is represented in the `simplexlsx.v2.py` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this iteration, we have removed the initial list in the `school_data` variable
    that contained the column names. Our new `write_xlsx()` function writes the header
    separately, which we will see later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Lines 44 through 55 are identical to the previous iteration of the function.
    Writing our table to the spreadsheet is accomplished on line 58\. See the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The `add_table()` function takes multiple arguments. First, we pass a string
    representing the top-left and bottom-right cells of the table in Excel notation.
    We use the length variable, defined on line 56, to calculate the necessary length
    of our table. The second argument is a little more confusing; this is a dictionary
    with two keys, data and columns. The `data` key has the value of our data variable,
    which is perhaps poorly named in this case. The `columns` key defines each column
    header and, optionally, its format, as seen on line 62:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In fewer lines than the previous example, we've managed to create a more useful
    output built as a table. Now, our spreadsheet has our specified data already converted
    into a table and ready to be sorted.
  prefs: []
  type: TYPE_NORMAL
- en: There are more possible keys and values that can be supplied during the construction
    of a table. Please consult the documentation ([http://xlsxwriter.readthedocs.org](http://xlsxwriter.readthedocs.org))
    for more details on advanced usage.
  prefs: []
  type: TYPE_NORMAL
- en: This process is simple when we are working with nested lists representing each
    row of a worksheet. Data structures not in this format require a combination of
    both methods demonstrated in our previous iterations to achieve the same effect.
    For example, we can define a table to span across a certain number of rows and
    columns and then use the `write()` function for those cells. However, to prevent
    unnecessary headaches, we recommend keeping data in nested lists where possible.
  prefs: []
  type: TYPE_NORMAL
- en: Creating charts with Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Finally, let's create a chart with `xlsxwriter`. The module supports a variety
    of different chart types, including line, scatter, bar, column, pie, and area.
    We use charts to summarize data in meaningful ways. This is particularly useful
    when working with large datasets, allowing examiners to gain some preliminary
    understanding of the data before getting into the weeds.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s modify the previous iteration yet again to display a chart. We will
    save this modified file as `simplexlsx.v3.py`. On line 65, we are going to create
    a variable named `department_grades`. This variable will be our chart object created
    by the `add_chart()` method. For this method, we pass in a dictionary specifying
    keys and values. In this case, we specify the type of the chart to be a column
    chart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'On line 66, we use the `set_title()` function and again pass in a dictionary
    of parameters. We set the name key equal to our desired title. At this point,
    we need to tell the chart what data to plot. We do this with the `add_series()`
    function. Each category key maps to the Excel notation specifying the horizontal
    axis data. The vertical axis is represented by the `values` key. With the data
    to plot specified, we use the `insert_chart()` function to plot the data in the
    spreadsheet. We give this function a string representing the cell that will act
    as an anchor to plot the top-left corner of the chart to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this version of the script will convert our data into a table and generate
    a column chart, comparing departments by their cumulative grades. We can clearly
    see that, unsurprisingly, the Physics department has the highest GPA earners in
    the school''s program. This information is easy enough to eyeball for such a small
    dataset. However, when working with data orders of greater magnitude, creating
    summarizing graphics can be particularly useful to understand the big picture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e646a0eb-8a11-4cfe-bde6-4b14cf4c64cd.png)'
  prefs: []
  type: TYPE_IMG
- en: Be aware that there is a great deal of additional functionality in the `xlsxwriter`
    module that we will not use in our script. This is an extremely powerful module,
    and we recommend it for any operation that requires writing Excel spreadsheets.
  prefs: []
  type: TYPE_NORMAL
- en: The UserAssist framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our `UserAssist` framework is made up of three scripts, `userassist_parser.py`,
    `csv_writer.py`, and `xlsx_writer.py`. The `userassist_parser.py` script handles
    the bulk of the processing logic and then passes the results to the CSV or XLSX
    writer. The directory structure of our framework is shown as follows. Our writers
    are contained within a directory named `Writers`. Remember that for a directory
    to be searchable by Python, it needs to include the `__init__.py` file. This file
    may be empty, contain functions and classes, or contain code to be executed upon
    import:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Developing our UserAssist logic processor – userassist_parser.py
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `userassist_parser.py` script is responsible for handling user input, creating
    a log file, and parsing `UserAssist` data from the `NTUSER.DAT` file. On lines
    2 through 9, we import familiar and new modules to facilitate our tasks. The `yarp`
    and `struct` modules will grant us access to and then extract objects from the
    `UserAssist` binary data, respectively. We import our `xlsx_writer` and `csv_writer`
    modules, which are in the `Writers` directory. Other used modules have been introduced
    in previous chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The `KEYS` variable defined as an empty list on line 45 will store parsed `UserAssist`
    values. The `main()` function, defined on line 48, will handle all coordinating
    logic. It calls functions to parse the `UserAssist` key and then to write the
    results. The `create_dictionary()` function uses the `Registry` module to find
    and store `UserAssist` value names and raw data in a dictionary for each GUID.
  prefs: []
  type: TYPE_NORMAL
- en: 'On line 134, we define the `parse_values()` function, which processes the binary
    data of each `UserAssist` value using `struct`. During this method, we determine
    if we are working with Windows XP- or Windows 7-based `UserAssist` data based
    on length. The `get_name()` function is a small function that separates the executable
    name from the full path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'On lines 202 through 212, we create our argument parser object, which takes
    two positional arguments and one optional argument. Our `REGISTRY` input is the
    `NTUSER.DAT` file of interest. The `OUTPUT` argument is the path and filename
    of the desired output file. The optional `-l` switch is the path of the log file.
    If this is not supplied, the log file is created in the current working directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'If the user supplies a log path, we check on line 215 if the path exists. If
    it does not exist, we use the `os.makedirs()` function to create the log directory.
    In either case, we instantiate the `log_path` variable with the supplied directory
    and the log file. On line 220, we create our log and write startup details in
    the same manner as previous chapters, before calling `main()` on line 227:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The following flow chart depicts the interconnected functions within our `UserAssist` framework.
    Here, we can see how the `main()` function calls and receives data from the `create_dictionary()`
    and `parse_values()` functions. The `parse_values()` function separately calls
    the `get_name()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fc43a4f9-08e2-4833-8939-e1202ce69efd.png)'
  prefs: []
  type: TYPE_IMG
- en: Evaluating the main() function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `main()` function sends the registry file to be processed before calling
    the appropriate methods to write the `out_file`. On line 61, we call the `create_dictionary()`
    function to create a list of dictionaries containing `UserAssist` data mapped
    to the executable''s name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, this dictionary is fed into the `parse_values()` method that appends
    parsed data to the `KEYS` list we created on line 45\. This function returns an
    integer representing the type of `UserAssist` data parsed. This function returns
    a value of `0` for Windows XP `UserAssist` values and `1` for Windows 7\. We log
    this information for troubleshooting purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Once data is processed, it can be sent to our writers. We use the `endswith()`
    method to identify what the extension is of the user-supplied output. If the output
    ends with `.xlsx` or `.csv`, we send the data to our `excel_writer()` or `csv_writer()`
    functions, respectively, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'If the user does not include an extension in their output, we write a warning
    to the log and write the data to a CSV file in the current working directory.
    We chose a CSV output because it represents the simplest and most portable option
    of our supported output formats. In addition, if the user wanted to examine their
    data in a spreadsheet application, they could easily import and convert the CSV
    document to an XLSX format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Both writers accept the same arguments: `KEYS` and `out_file`. The `KEYS` list,
    which was defined on line 45, is a container of `UserAssist` dictionaries. We
    packaged our data as a list of dictionaries in order to use the dictionary keys
    to dictate which headers were present. The `out_file` is the path and name of
    the desired output.'
  prefs: []
  type: TYPE_NORMAL
- en: Defining the create_dictionary() function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `create_dictionary()` function prepares the `UserAssist` data for processing.
    This function pulls all values within each `UserAssist` GUID key. It creates a
    dictionary where the keys are the ROT-13 decoded executable name, and the values
    are the respective binary data. This binary data is extracted now, so we can process
    it in a later function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'On line 97, we try to open the registry file provided by the user. If there
    is an error accessing the input file, we catch the error, log it, and exit gracefully
    with an error code of `2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'If we can open the registry file, we then try to navigate to the `UserAssist`
    key. We use a conditional to catch the scenario where the `UserAssist` key is
    not found in the supplied registry file. Note that, for this error, we use the
    integer, `3`, to differentiate from our previous exit scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'On line 113, we create a list named `apps_list`, which will store `UserAssist`
    dictionaries. If we were able to find the `UserAssist` key, we loop through each
    `ua_subkey`, a GUID, and check their count subkey. This is an important step;
    as Windows has evolved, more GUIDs have been added to the `UserAssist` key. Rather
    than hardcoding these values, which could miss new GUIDs added in future versions
    of Windows, we opted for a more dynamic process that will discover and handle
    new GUIDs across many versions of Windows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'This process involves checking each GUIDs that has a subkey named `Count`,
    which stores the actual `UserAssist` application values. On line 118, we determine
    if the GUID has a subkey named `Count` with one or more values. This ensures that
    we find all the `UserAssist` values present on the system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'We create an apps dictionary on line 120 and begin to loop through each value
    under the `Count` subkey. For each value, we add the ROT-13-decoded name as the
    key, and associate it with its `raw_data` as the value. Once all the values in
    the GUID have been added to the dictionary, it is appended to `apps_list` and
    the cycle repeats. Once all of the GUIDs have been processed, our list is returned
    to the `main()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Extracting data with the parse_values() function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `parse_values()` function takes the list of GUID dictionaries as its input
    and uses struct to parse the binary data. As we''ve discussed, there are two types
    of `UserAssist` keys we will support: Windows XP and Windows 7\. The following
    two tables break down the relevant data structures we will parse. Windows XP-based
    keys are 16 bytes in length and contain a Session ID, Count, and FILETIME timestamp:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Byte offset** | **Value** | **Object** |'
  prefs: []
  type: TYPE_TB
- en: '| 0-3 | Session ID | Integer |'
  prefs: []
  type: TYPE_TB
- en: '| 4-7 | Count | Integer |'
  prefs: []
  type: TYPE_TB
- en: '| 8-15 | FILETIME | Integer |'
  prefs: []
  type: TYPE_TB
- en: 'Windows 7 artifacts are 72 bytes in length containing a session ID, count,
    focus count/time, and FILETIME timestamp:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Byte offset** | **Value** | **Object** |'
  prefs: []
  type: TYPE_TB
- en: '| 0-3 | Session ID | Integer |'
  prefs: []
  type: TYPE_TB
- en: '| 4-7 | Count | Integer |'
  prefs: []
  type: TYPE_TB
- en: '| 8-11 | Focus count | Integer |'
  prefs: []
  type: TYPE_TB
- en: '| 12-15 | Focus time | Integer |'
  prefs: []
  type: TYPE_TB
- en: '| 16-59 | ??? | N/A |'
  prefs: []
  type: TYPE_TB
- en: '| 60-67 | FILETIME | Integer |'
  prefs: []
  type: TYPE_TB
- en: '| 68-71 | ??? | N/A |'
  prefs: []
  type: TYPE_TB
- en: 'On lines 143 through 146, we set up our function by instantiating the `ua_type`
    variable and logging execution status. This `ua_type` variable will be used to
    document which type of `UserAssist` value we''re working with. On lines 148 and
    149, we loop through each value in each dictionary to identify its type and parse
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'On lines 151 and 159, we use the `len()` function to identify the type of `UserAssist`
    key. For Windows XP-based data, we need to extract two 4-byte integers followed
    by an 8-byte integer. We also want to interpret this data in little endian using
    standard sizes. We accomplish this on line 152 with `<2iq` as the struct format
    string. The second argument we pass to the unpack method is the raw binary data
    for the particular key from the GUID dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The Windows 7-based data is slightly more complicated. There are bytes in the
    middle and end of the binary data that we are not interested in parsing and yet,
    because of the nature of struct, we must account for them in our format. The format
    string we use for this task is `<4i44xq4x`, which accounts for the four 4-byte
    integers, the 44 bytes of intervening space, the 8-byte integer, and the remaining
    4 bytes we will ignore:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: As we parse `UserAssist` records, we append them to the `KEYS` list for storage.
    When we append the parsed values, we wrap them in curly braces to create our inner
    dictionary object. We also call the `get_name()` function on the `UserAssist`
    value name to separate the executable from its path. Note that regardless of the
    type of `UserAssist` key, we still create the same keys in our dictionary. This
    will ensure that all our dictionaries have the same structure and will help streamline
    our CSV and XLSX output functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'If a `UserAssist` value is not 16 or 72 bytes (which can happen), then that
    value is skipped and the user is notified of the name and size that was passed
    over. From our experience, these values were not forensically relevant, and so
    we decided to pass on them. On line 173, the `UserAssist` type is returned to
    the `main()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Processing strings with the get_name() function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `get_name()` function uses string operations to separate the executable
    from the path name. From testing, we found that a colon, backslash, or both characters
    were present in the path. Because this pattern exists, we can try to split this
    information using these characters to extract the name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'On line 185, we check to see if both colon and backslashes are in the `full_name`
    variable. If this is true, we use the `rindex()` function to get the index of
    the rightmost occurrence of the substring for both elements. On line 187, we check
    to see if the right-most index for the colon is found later in the string than
    the backslash. The element with the greatest index is used as the delimiter for
    the `split()` function. To get the last substring in the list (our executable
    name), we use the `-1` index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'On lines 196 and 198, we handle the alternative scenarios and split on either
    the colon or backslash, and return the last element in the list of substrings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: This completes the logic in our `userassist_parser.py` script. Now, let's turn
    our attention to our two writer functions responsible for writing our parsed data
    in a useful format.
  prefs: []
  type: TYPE_NORMAL
- en: Writing Excel spreadsheets – xlsx_writer.py
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `xlsx_writer.py` script contains the logic for creating an excel document
    containing our processed `UserAssist` values. In addition to this, this script
    also creates an additional worksheet that contains summarizing charts of our data.
    The `xlsxwriter` is imported on line 1 and is the third-party module we use to
    create the Excel document. The `itemgetter` function, imported on line 3, will
    be used and explained in the sorting functions later in this section. We have
    seen the `datetime` and `logging` modules from previous chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: There are six functions in the `xlsx_writer.py` script. The coordinating logic
    is handled by the `excel_writer()` function defined on line 36\. This function
    creates our Excel workbook object and then hands it off to the `dashboard_writer()`
    and `userassist_writer()` functions to create the dashboard and `UserAssist` worksheets,
    respectively.
  prefs: []
  type: TYPE_NORMAL
- en: The remaining three functions, `file_time()`, `sort_by_count()`, and `sort_by_date()`,
    are helper functions used by the dashboard and `UserAssist` writers. The `file_time()`
    function is responsible for converting FILETIME objects that we parsed from the
    raw `UserAssist` data into `datetime` objects. The sorting functions are used
    to sort the data by either count or date. We use these sorting functions to answer
    some basic questions about our data. What are the most-used applications? What
    are the least-used applications? What were the last 10 applications used on the
    machine (according to `UserAssist`)?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Controlling output with the excel_writer() function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `excel_writer()` function is the glue for this script. The headers list
    on line 47 is a list containing our desired column names. These column names also
    conveniently correlate to the keys in our `UserAssist` dictionaries we will be
    writing. On line 49, we create the `Workbook` object we will write to. On the
    next line, we create our `title_format`, which controls the color, font, size,
    and other style options for our spreadsheet header. We have the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The `title_format` is similar to the `date_format` we created when we previously
    discussed the `xlsxwriter` module. This format is a dictionary containing keywords
    and values. Specifically, we'll use this format when creating a title and subtitle
    rows so it sticks out from other data in our spreadsheet.
  prefs: []
  type: TYPE_NORMAL
- en: 'On lines 54 through 59, we convert our dictionaries back into lists. This might
    seem to you as though we made the wrong data type choice to store our data, and
    perhaps you have a point. However, storing our data in lists will immensely simplify
    writing out XSLX output. Once we see how the CSV writer handles the data, it will
    become clearer why we originally use dictionaries. In addition, the use of dictionaries
    allows us to easily understand the stored data without need for review of the
    code or documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: We use list comprehension to append data from our dictionary in the proper order.
    Let's break it down. On line 59, we iterate through each `UserAssist` dictionary.
    As we know, dictionaries do not store data by index and instead store by key mapping.
    However, we want our data to be written in a certain order as dictated by our
    headers list. The `x` in the headers loop allows us to iterate over that list.
    For each `x`, we use the `get()` method to return the value for `x` if found in
    the dictionary or an empty string.
  prefs: []
  type: TYPE_NORMAL
- en: 'On line 61 and 62, we call the two worksheet writers for the dashboard and
    `UserAssist` data. After the last of those functions exit, we `close()` the workbook
    object. It is incredibly important to close the workbook. Failing to do so will
    throw an exception that might prevent us from transferring our Excel document
    from memory to disk. Take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Summarizing data with the dashboard_writer() function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The aim of the `dashboard_writer()` function is to provide the analyst or reviewer
    with some graphics that summarize our `UserAssist` data. We chose to present the
    top 10, bottom 10, and most recent 10 executables to the user. This function is
    our longest and requires the most logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'On line 81, we add our dashboard worksheet object to the workbook. Next, we
    merge the first row from the `A` to `Q` columns and write our company name, `XYZ
    Corp`, using our title format created in the `excelWriter()` function. Similarly,
    we create a subtitle row to identify this worksheet as our dashboard on line 83,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'On line 87, we create and add a `date_format` to the workbook in order to properly
    format our dates. On lines 92 and 93, we make function calls to the two sorting
    functions. We use list slicing to carve the sorted data to create our sublists:
    `topten`, `leastten`, and `lastten`. For the `topten` executables used by count,
    we grab the last 10 elements in the sorted list. For the `leastten`, we simply
    perform the inverse. For the `lastten`, we grab the first 10 results in the sorted
    dates list, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'On line 103, we iterate over the elements in the `lastten` list. We must convert
    each timestamp into a `datetime` object. The `datetime` object is stored in the
    first index of the `UserAssist` list we created and is converted by the `file_time()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'On lines 108 through 116, we create our three tables for our top, bottom, and
    most recent data points. Note how these tables start on row 100\. We chose to
    place them far away from the top of the spreadsheet so the user sees the tables
    we will add instead of the raw data. As we saw when describing tables in the `xlsxwriter`
    section, the second argument of the `add_table()` function is a dictionary containing
    keywords for header names and formats. There are other keywords that could be
    provided for additional functionality. For example, we use the `format` keyword
    to ensure that our `datetime` objects are displayed as desired using our `date_format`
    variable. We have the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'On lines 118 to 153, we create our charts for the three tables. After instantiating
    `top_chart` as a pie chart, we set the title and the scale in the *X* and *Y*
    direction. During testing, we realized that the figure would be too small to adequately
    display all of the information, and so we used a larger scale:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'On line 127, we add the series for our pie chart; identifying the categories
    and values is straightforward. All we need to do is define the rows and columns
    we want to plot. The `data_labels` key is an additional option that can be used
    to specify the value''s format of the plotted data. In this case, we chose the
    `''percentage''` option as seen on line 130, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'With this setup, our pie chart will be split based on usage count, the legend
    will contain the name of the executable, and the percentage will show the relative
    execution in comparison to the other nine executables. After creating the chart,
    we call `insert_chart()` to add it to the dashboard worksheet. The `least_chart`
    is created in the same manner, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we create and add the `last_chart` to our spreadsheet. In an effort
    to save trees, this is handled in the same fashion as we previously discussed.
    This time, however, our chart is a column chart and we''ve modified the scale
    to be appropriate for the type of chart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Writing artifacts in the userassist_writer() function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `userassist_writer()` function is similar to the previous dashboard function.
    The difference is that this function creates a single table containing our raw
    data without any of the additional accouterments. On lines 167 through 169, we
    create the `UserAssist` worksheet object and add our title and subtitle to the
    spreadsheet. On line 173, we once again create a `date_format` to properly display
    dates, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'On line 178, we loop through the outer list and convert the FILETIME object
    into a `datetime` object using our prebuilt function. We also add an integer to
    the beginning of the list so that examiners can quickly determine how many `UserAssist`
    records are there by looking at the index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'On line 188, we begin creating our `UserAssist` table. We use the length variable,
    created in line 184, to determine the appropriate number distance to the bottom-right
    corner of the table. Note that the length is the length of the list plus three.
    We added three to this length because we need to account for our title and subtitle
    rows, taking up the first two columns, and the difference between how Python and
    Excel count. We have the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Defining the file_time() function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is a very small helper function. The FILETIME object we parsed with the
    struct library is an 8-byte integer representing the count of 100-nanosecond units
    since 01/01/1601\. This date is used by most Microsoft operating systems and applications
    as a common reference point in time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, to get the date it represents, we need to add the FILETIME value
    to the `datetime` object representing 01/01/1601 with the `timedelta()` function.
    The `timedelta` function calculates the number of days and hours an integer represents.
    We can then add the output from the `timedelta()` function directly to the `datetime`
    object to arrive at the correct date. In order to arrive at the correct magnitude,
    we need to divide the FILETIME value by `10`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Processing integers with the sort_by_count() function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `sort_by_count()` function sorts the inner lists based on their execution
    count value. This is a somewhat complicated one-liner, so let's take it apart
    step by step. To begin, let's focus on the `sorted(data, key=itemgetter(3))` step
    first. Python includes a built-in `sorted()` method to sort data by a key, normally
    an integer. We can supply the `sorted()` function with a key to tell it what to
    sort by and return a new sorted list.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with any new piece of code, let''s look at a simple example in the interactive
    prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we''ve created an outer list that contains inner
    lists with two elements: a character and a number. Next, we sort this list and
    use the number in the first index of the inner lists as the key. By default, `sorted()`
    will sort in ascending order. To sort in descending order, you need to supply
    the `reverse=True` argument. If we wanted to sort by letter, we would provide
    the `itemgetter()` with the value of `0` to specify to sort on elements found
    at that location.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, all that is left is to understand what `x[0:5:3]` means. Why are we even
    doing this in the first place? We are using list slicing to only grab the first
    and third element, that is, the name and count of the executable, to use for our
    table.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember that slicing notation supports three optional components: *List[x:y:z], *were,
    *x* = start index, *y* = end index, *z* = step.'
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we start at index 0 and stop at index 5, taking steps of 3\.
    If we do this, we will only get the elements at the zero and third position of
    the list before reaching the end.
  prefs: []
  type: TYPE_NORMAL
- en: Now, the statement `x[0:5:3]` for `x` in `sorted(data, key=itemgetter(3))` will
    loop through the newly sorted list and only retain the zero and third-positioned
    elements in each list. We then wrap this entire statement in a pair of square
    brackets in order to preserve our outer and inner list structure that `xlsxwriter`
    prefers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The list object also has a `sort()` method that is syntactically similar to
    the `sorted()` function. However, the `sort()` function is more memory-friendly
    as it does not create a new list, but rather sorts the current list in place.
    Because memory consumption is not a big concern for a dataset, that might contain
    a few hundred entries at most and, as we did not want to modify the original list,
    we chose to use the `sorted()` function. We have the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Processing datetime objects with the sort_by_date() function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `sort_by_date()` function is very similar to the `sort_by_count()` function
    except that it uses different indices. Since a `datetime` object is really just
    a number, we can easily sort by that as well. Supplying `reverse=True` allows
    us to sort in descending order.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once again, we''re first creating a new sorted list using the datetime in position
    4 as the key. We are then only retaining the zero- and fourth-positioned elements
    in each list and wrapping all of that inside another list to preserve our nested
    list structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Writing generic spreadsheets – csv_writer.py
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `csv_writer.py` script is fairly straightforward compared with the previous
    two scripts we''ve written. This script is responsible for the CSV output of our
    `UserAssist` data. The `csv_writer.py` script has two functions: `csv_writer()`
    and the helper function, `file_time()`. We explained the `file_time()` function
    in the `xlsx_writer` section, and it will not be repeated here as it has the same
    implementation.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the csv_writer() function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `csv_writer()` function, defined on line 38, is slightly different from
    the way we have been creating CSV output in previous chapters. We normally start
    by creating our headers list, creating a writer object, and writing the headers
    list and each sublist in our data variable. This time, instead of using `writer()`,
    we will use the `DictWriter()` method to handle writing our `UserAssist` dictionaries
    for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'On line 49, we do still create our headers list as normal. However, this list
    plays a more important role. This list contains the name of each key that will
    appear in our `UserAssist` dictionaries and in the order we want to display them.
    The `DictWriter()` method will allow us to then order our dictionaries by this
    list to ensure that our data is presented in the appropriate sequence. Depending
    on whether Python 2 or 3 is running the code, we open the `csvfile` using the
    appropriate method. Look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'We start by creating our `csvfile` object and our writer. The `DictWriter()`
    method takes a file object as its required argument and optional keyword arguments.
    The `fieldnames` argument will ensure that the dictionary keys are written in
    the appropriate order. The `extrasaction` keyword is set to ignore scenarios where
    a dictionary contains a keyword that is not in the `fieldnames` list. If this
    option was not set, we would receive an exception if there was an extra unaccounted-for
    key in the dictionary. In our scenario, we should never encounter this issue as
    we have hardcoded the keys. However, if for some reason there are extra keys,
    we would rather the `DictWriter()` ignore them than crash, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'With the `DictWriter()` object, we can call the `writeheader()` method to automatically
    write the supplied field names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we do some additional processing on each dictionary before writing
    it. First, we add the ID key to the current loop count. Next, on line 71, we call
    the `fileTime()` method to convert the FILETIME object into a `datetime` format.
    Finally, on line 73, we write our dictionary to the CSV output file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'After all the dictionaries have been written, we `flush()` and `close()` the
    handle on the `csvfile` object. And with that, we log the successful completion
    of our CSV script. All that''s left at this point is to actually run our new framework:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Running the UserAssist framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our script is capable of parsing both Windows XP- and Windows 7-based `UserAssist`
    keys. However, let''s focus our attention on the differences between the CSV and
    XLSX output options. Using the `xlsxwriter` module and seeing the output should
    make the advantages of writing directly to an excel file over CSV clear. While
    you do lose the portability of the CSV document, you gain a lot more functionality.
    The following is the screenshot of running the `userassist.py` script against
    a Vista `NTUSER.DAT` and creating an XLSX output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/29ff171f-7815-454a-b2a8-cc8540a30495.png)'
  prefs: []
  type: TYPE_IMG
- en: The CSV output is not capable of preserving Python objects or crafting report-ready
    spreadsheets. The upside of a CSV report, besides the portability, is that writing
    the module itself is very simple. We were able to write the main logic in just
    a few lines of code compared with over 100 lines for the Excel document, which
    clearly took more time to develop.
  prefs: []
  type: TYPE_NORMAL
- en: Being able to write a customized Excel report is great, but comes at a time
    cost. It might not always be a feasible addition for the forensic developer as
    time constraints often play a large role in the development cycle and dictate
    what you can and cannot do. However, if time permits, this can save the hassle
    of performing this process manually by the examiner and allow more time for analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Challenge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We talked extensively about the additions that Windows 7 brought to the `UserAssist`
    artifact. However, there are even more changes that we did not account for in
    our current implementation of the `UserAssist` framework. With Windows 7, some
    common folder names were replaced with GUIDs. The following is a table of some
    examples of folders and their respective GUIDs:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Folder** | **GUID** |'
  prefs: []
  type: TYPE_TB
- en: '| `UserProfiles` | `{0762D272-C50A-4BB0-A382-697DCD729B80}` |'
  prefs: []
  type: TYPE_TB
- en: '| `Desktop` | `{B4BFCC3A-DB2C-424C-B029-7FE99A87C641}` |'
  prefs: []
  type: TYPE_TB
- en: '| `Documents` | `{FDD39AD0-238F-46AF-ADB4-6C85480369C7}` |'
  prefs: []
  type: TYPE_TB
- en: '| `Downloads` | `{374DE290-123F-4565-9164-39C4925E467B}` |'
  prefs: []
  type: TYPE_TB
- en: An improvement to our script might involve finding these and other common folder
    GUIDs, and replacing them with the true path. A list of some of these common GUIDs
    can be found on Microsoft's MSDN website at [http://msdn.microsoft.com/en-us/library/bb882665.aspx](http://msdn.microsoft.com/en-us/library/bb882665.aspx).
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, the graph we chose to chart the last 10 executables may not be
    the best way of presenting dates graphically. It might be worthwhile to create
    a more timeline-focused graph to better represent that data. Try using some of
    the other built-in graphs and their features to become more familiar with the
    graphing features of `xlsxwriter`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This was a module-centric chapter, where we added three new modules to our toolkit.
    In addition, we gained an understanding of the `UserAssist` artifact and how to
    parse it. While these concepts are important, our brief detour with `timeit` may
    prove most valuable going forward.
  prefs: []
  type: TYPE_NORMAL
- en: As developers, there will be times where the execution of our scripts is lacking
    or, on large datasets, takes an absurd amount of time. In these situations, modules
    such as `timeit` can help audit and evaluate code to identify more efficient solutions
    for a given situation. The code for this project can be downloaded from GitHub
    or Packt, as described in the *Preface*.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will introduce how to hash files in Python. Specifically,
    we will focus on hashing blocks of data to identify identical and similar files.
    This is referred to as "fuzzy hashing." This technique is useful when evaluating
    objects that share a similar root, such as malware. We could take a known sample
    of malware we suspect was used on a system, fuzzy hash it, and search for matches
    on the system. Instead of finding an identical match, we receive a 90% match on
    an obscure file, which upon further inspection turns out to be a new variant of
    the malware that might otherwise have gone unnoticed. We will cover multiple methods
    to implement this functionality and the logic behind the process.
  prefs: []
  type: TYPE_NORMAL
