- en: '*Chapter 6*: Scripting Malware Analysis'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will apply the scripting capabilities of Ghidra to malware
    analysis. By using and writing Ghidra scripts, you will be able to analyze malware
    in a more efficient way.
  prefs: []
  type: TYPE_NORMAL
- en: You will learn how to statically resolve the Kernel32 API hashed functions used
    by Alina shellcode, which was superficially analyzed in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The Flat APIs are *simple* but powerful versions of the full-fledged complex
    Ghidra API. They are a great starting point for anyone looking to develop Ghidra
    modules and/or scripts.
  prefs: []
  type: TYPE_NORMAL
- en: We will start by classifying the Ghidra Flat API functions into categories in
    order to get more comfortable when looking for a function. Following that, we
    will look at how to iterate over the code using Java and Python, and, finally,
    we will use the mentioned code to deobfuscate malware.
  prefs: []
  type: TYPE_NORMAL
- en: 'To deobfuscate is to convert a program that is difficult to understand into
    one that is simple, understandable, and straightforward. There are tools available
    to deobfuscate tough code or a tough program into a simple and understandable
    form. Obfuscation is usually done to prevent reverse engineering, making it hard
    for those with malicious intentions to understand its inner functionality. Similarly,
    obfuscation may also be used to conceal malicious content in software. A deobfuscating
    tool is used to reverse-engineer these programs. Although deobfuscation is always
    possible, the attacker tries to benefit from the following asymmetry: little effort
    required to obfuscate versus a lot of effort to deobfuscate.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the Ghidra scripting API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing scripts using the Java programming language
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing scripts using the Python programming language
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deobfuscating malware samples using scripts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this chapter can be found at [https://github.com/PacktPublishing/Ghidra-Software-Reverse-Engineering-for-Beginners/tree/master/Chapter06](https://github.com/PacktPublishing/Ghidra-Software-Reverse-Engineering-for-Beginners/tree/master/Chapter06).
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following link to see the Code in Action video: [https://bit.ly/36RZOMQ](https://bit.ly/36RZOMQ)'
  prefs: []
  type: TYPE_NORMAL
- en: Using the Ghidra scripting API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Ghidra scripting API is divided into the Flat API (`ghidra.app.decompiler.flatapi`)
    and the rest of the functions ([http://ghidra.re/ghidra_docs/api/overview-tree.html](http://ghidra.re/ghidra_docs/api/overview-tree.html)),
    which are more complex.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Flat API is a simplified version of the Ghidra API, and it allows you,
    in summary, to perform the following actions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'These functions allow you to work with memory addresses: `addEntryPoint`, `addInstructionXref`,
    `createAddressSet`, `getAddressFactory`, and `removeEntryPoint`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Use these functions to perform code analysis: `analyze`, `analyzeAll`, `analyzeChanges`,
    `analyzeAll`, and `analyzeChanges`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Use the following function to clear the code listing: `clearListing`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following functions allow you to declare data: `createAsciiString`, `createAsciiString`,
    `createBookmark`, `createByte`, `createChar`, `createData`, `createDouble`, `createDWord`,
    `createDwords`, `createEquate`, `createUnicodeString`, `removeData`, `removeDataAt`,
    `removeEquate`, `removeEquate`, and `removeEquates`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Use these functions to get data from a memory address: `getInt`, `getByte`,
    `getBytes`, `getShort`, `getLong`, `getFloat`, `getDouble`, `getDataAfter`, `getDataAt`,
    `getDataBefore`, `getLastData`, `getDataContaining`, `getUndefinedDataAfter`,
    `getUndefinedDataAt`, `getUndefinedDataBefore`, `getMemoryBlock`, `getMemoryBlocks`,
    and `getFirstData`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following functions allow you to work with references: `createExternalReference`,
    `createStackReference`, `getReference`, `getReferencesFrom`, `getReferencesTo`,
    and `setReferencePrimary`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These functions allow you to work with data types: `createFloat`, `createQWord`,
    `createWord`, `getDataTypes`, and `openDataTypeArchive`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Use these functions to set a value to some memory address: `setByte`, `setBytes`,
    `setDouble`, `setFloat`, `setInt`, `setLong`, and `setShort`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These functions allow you to create fragments: `getFragment`, `createFragment`,
    `createFunction`, `createLabel`, `createMemoryBlock`, `createMemoryReference`,
    `createSymbol`, `getSymbol`, `getSymbols`, `getSymbolAfter`, `getSymbolAt`, `getSymbolBefore`,
    `getSymbols`, and `getBookmarks`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Use the following function to disassemble bytes: `disassemble`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These functions allow you to work with transactions: `end` and `start`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you want to find values, use the following set of functions: `find`, `findBytes`,
    `findPascalStrings`, and `findStrings`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following functions allow you to operate at a function level: `getGlobalFunctions`,
    `getFirstFunction`, `getFunction`, `getFunctionAfter`, `getFunctionAt`, `getFunctionBefore`,
    `getFunctionContaining`, and `getLastFunction`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following functions allow you to operate at a program level: `getCurrentProgram`,
    `saveProgram`, `set`, and `getProgramFile`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following functions allow you to operate at an instruction level: `getFirstInstruction`,
    `getInstructionAfter`, `getInstructionAt`, `getInstructionBefore`, `getInstructionContaining`,
    and `getLastInstruction`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These functions allow you to work with equates: `getEquate` and `getEquates`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you want to remove something, use the following set of functions: `removeBookmark`,
    `removeFunction`, `removeFunctionAt`, `removeInstruction`, `removeInstructionAt`,
    `removeMemoryBlock`, `removeReference`, and `removeSymbol`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These functions allow you to work with comments: `setEOLComment`, `setPlateComment`,
    `setPostComment`, `setPreComment`, `getPlateComment`, `getPostComment`, `getPreComment`,
    `getEOLComment`, and `toAddr`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Use the following function to decompile bytes: `FlatDecompilerAPI`, `decompile`,
    and `getDecompiler`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And finally, some miscellaneous functions: `getMonitor`, `getNamespace`, and
    `getProjectRootFolder`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This reference can be helpful to you when getting started with Ghidra scripting
    to identify the function that you need and look for the prototype in the documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Writing scripts using the Java programming language
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As you know from the previous chapter, Alina malware incorporates shellcode
    that is injected into the `explorer.exe` process. If you want to deobfuscate the
    shellcode Kernel32 API function calls, then you will need to identify call instructions.
    You will also need to filter the functions in order to get only what you need,
    and finally, of course, you will need to perform the deobfuscation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Let me explain how this code works line by line:'
  prefs: []
  type: TYPE_NORMAL
- en: It obtains the function containing the current address (the focused address)
    (line `01`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The instruction at the current address is also obtained (line `02`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A loop iterating from the current instruction to the end of the function is
    performed (line `03`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The mnemonic of the instruction is obtained (line `04`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It checks whether the mnemonic corresponds to a `CALL` instruction, which is
    the type of instruction we are interested in (line `05`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The instruction operands are also retrieved (line `06`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since obfuscated calls are relative to the `EBP` address where the hash table
    exists, we check whether `EBP` is an operand (line `07`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The deobfuscation routine must be implemented in this line (line `08`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Retrieve the next instruction (line `11`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this section, you learned how to use the Ghidra API to implement scripts
    using the Java language. In the next section, you will learn how to do the same
    thing using Python and we will compare both languages but in the context of Ghidra
    scripting.
  prefs: []
  type: TYPE_NORMAL
- en: Writing scripts using the Python programming language
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If we rewrite the deobfucation code skeleton using Python, it looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, it is similar to Java in that it doesn't need additional explanation.
  prefs: []
  type: TYPE_NORMAL
- en: To develop a Ghidra script, it is not necessary to remember all the functions.
    The only important thing is to be clear about what you want to do and have located
    the necessary resources, such as documentation to locate the right API functions.
  prefs: []
  type: TYPE_NORMAL
- en: Python is an awesome language with an awesome community that develops libraries
    and tools. If you want to write code really fast, Python is a great option. Unfortunately,
    Ghidra doesn't incorporate a pure Python implementation. Ghidra is mostly implemented
    in Java and then ported to Python via Jython.
  prefs: []
  type: TYPE_NORMAL
- en: 'Theoretically, you can choose indistinctly to use either Python or Java but,
    in practical terms, Jython has some issues:'
  prefs: []
  type: TYPE_NORMAL
- en: Jython relies on Python 2.x, which is deprecated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Sometimes, some things work as expected in Java but don''t work in Jython.
    Here are some examples:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '- [https://github.com/NationalSecurityAgency/ghidra/issues/1890](https://github.com/NationalSecurityAgency/ghidra/issues/1890)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- [https://github.com/NationalSecurityAgency/ghidra/issues/1608](https://github.com/NationalSecurityAgency/ghidra/issues/1608)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Due to the things mentioned here, it is your decision whether you implement
    your scripts using a more stable language such as Java or a quicker but a little
    more unstable one such as Python. Feel free to evaluate both options and make
    your decision!
  prefs: []
  type: TYPE_NORMAL
- en: Deobfuscating malware samples using scripts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we showed how Alina injects shellcode into the `explorer.exe`
    process. We analyzed this by simply reading the strings, which is a quick, practical
    approach, but we can be more accurate in our analysis. Let's focus on some shellcode
    details.
  prefs: []
  type: TYPE_NORMAL
- en: The delta offset
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When injecting code, it is placed in a position that is unknown at development
    time. As a consequence, the data cannot be accessed by using absolute addresses;
    instead, it must be accessed via relative positions. The shellcode retrieves the
    current address at runtime. In other words, it retrieves the `EIP` register.
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of the `EIP` register in x86 architecture (32-bit) is to point to
    the next instruction to execute; so, it controls the flow of a program. It determines
    the next instruction to execute.
  prefs: []
  type: TYPE_NORMAL
- en: 'But, as the `EIP` register is controlled implicitly (by control-transfer instructions,
    interruptions, and exceptions), it cannot be accessed directly, so it is retrieved
    by the malware performing the following technique:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Performs a `CALL` instruction pointing to an address 5 bytes away. So, the
    call performs two changes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '- It pushes the return address (the address of the next instruction) onto the
    stack, which is `0x004f6105`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 6.1 – The CALL instruction pushes the return address onto the stack'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B16207_06_001.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 6.1 – The CALL instruction pushes the return address onto the stack
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- It transfers the control to the target address:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 6.2 – The CALL instruction transfers the flow to the target address'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B16207_06_002.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 6.2 – The CALL instruction transfers the flow to the target address
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Then, it recovers the address stored in the stack via `POP EBP`. This instruction
    does the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '- It removes the latest value pushed onto the stack:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 6.3 – The POP instruction removes the latest value pushed onto the
    stack'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B16207_06_003.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 6.3 – The POP instruction removes the latest value pushed onto the stack
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- It stores the value in the targeting register, `EBP` in this case:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 6.4 – The POP instruction stores the removed stack value into the
    targeting EBP register'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B16207_06_004.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 6.4 – The POP instruction stores the removed stack value into the targeting
    EBP register
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Finally, it subtracts `0x5` units from the `EBP` register to get the `EIP` value
    (which we had when executing the `CALL` instruction, not the current one) stored
    in `EBP`:![Figure 6.5 – The SUB instruction subtracts 5 units from the EBP register
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16207_06_005.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 6.5 – The SUB instruction subtracts 5 units from the EBP register
  prefs: []
  type: TYPE_NORMAL
- en: By using this trick, the malware developer can refer to data values using the
    `EBP` register (the beginning of the shellcode) plus an offset to the mentioned
    data. By using this technique, the resulting code is position-independent; no
    matter in which position you place the shellcode, it will work anyway.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can check this in the following code fragment:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.6 – Delta offset stored in the EBP register for position-independent
    code'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16207_06_006.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.6 – Delta offset stored in the EBP register for position-independent
    code
  prefs: []
  type: TYPE_NORMAL
- en: 'This trick is commonly known as `0x5e2` offset relative to the shellcode starting
    address:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.7 – Storing the base address of the API hash table'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16207_06_007.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.7 – Storing the base address of the API hash table
  prefs: []
  type: TYPE_NORMAL
- en: After that, a function is responsible for replacing Kernel32 API function hashes
    with function directions, allowing you to call it from the program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the replacement is done, a lot of calls are done via offsets of this hash
    table, which is now converted into a table of API addresses:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.8 – Calling resolved API functions via relative offsets'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16207_06_008.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.8 – Calling resolved API functions via relative offsets
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the disassembly shows `CALL` instructions pointing to `EBP`
    relative offsets. It is much more preferable to see the callee function name instead.
    Improving the disassembly to show function names is our objective but, as a first
    step, in the next section, you will learn how API hashes are replaced with their
    corresponding API function addresses.
  prefs: []
  type: TYPE_NORMAL
- en: Translating API hashes to addresses
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following function is responsible for replacing the hash of the functions
    with the corresponding address of the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.9 – The function responsible for replacing the table of function
    hashes with addresses'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16207_06_009.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.9 – The function responsible for replacing the table of function hashes
    with addresses
  prefs: []
  type: TYPE_NORMAL
- en: The previous code iterates over each API name, extracted from the `AddressOfNames`
    section of the export table of the `kernel32.dll` library.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is easy to identify the mentioned functionality if you have some background
    in analyzing Portable Executable files because some offsets in the code are very
    striking. Let''s see the correspondence between the offsets shown in the previous
    `apiHashesToApiAdresses` disassembly and Portable Executable format fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '`0x3c` corresponds to the `e_lfanew` field, meaning the **Relative Virtual
    Address** (**RVA**) of the Portable Executable header.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0x78` is the RVA to the export table.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0x20` is the RVA of the name pointer table into the export table.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0x1c` is the RVA of the address table into the export table.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0x24` is the RVA of the ordinal table into the export table.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0x18` is the RVA of the number of names, which is the maximum number of loop
    iterations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Lines `21` and `22` in *Figure 6.9* are the key part of the code for deobfuscation
    purposes. On these mentioned lines, for each character of the API, a series of
    logical operations is applied. This series of operations can be easily translated
    into Python, as shown in the following Python shell command listing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Let me clarify these four Python commands:'
  prefs: []
  type: TYPE_NORMAL
- en: We store the `lstrlenW` string in the `apiname` variable, as we want to compute
    its hash value. In this way, we are testing our Python code over a real `kernel32.dll`
    API name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We initialize the `hash` value to `0`. This is the first step of this hashing
    algorithm.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We iterate over each character (variable `c`) of the `lstrlenW` string while
    updating the `hash` variable value according to the hashing algorithm.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We finally print the hash value using hexadecimal notation. Please notice that
    the `L` character at the end of the hash value means long data type and it doesn't
    belong to the hash.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Of course, the mentioned code can also be translated into Java:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: In this section, you learned how API hashing works and how to translate the
    algorithm from assembly language into Python and Java. In the next section, we
    will use the mentioned code to resolve the names of the callee functions and put
    it into the disassembly listing.
  prefs: []
  type: TYPE_NORMAL
- en: Deobfuscating the hash table using Ghidra scripting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before automatically deobfuscating the program, we need the complete list of
    `Kernel32.dll`-exported API function names. You can find the following script
    (`get_kernel32_exports.py`) on the dedicated GitHub repository, which uses Python''s
    `pefile` module for this purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'This listed code does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Imports the `pefile` module, allowing it to parse in Portable Executable file
    format, the file format used in 32-bit and 64-bit versions of Microsoft Windows
    operating systems for executables, object code, DLLs, and others
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Stores in `pe` an instance of the parsed `Kernel32.dll` Portable Executable
    file
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creates an empty set of `Kernel32.dll`-exported functions
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Iterates over the `Kernel32.dll`-exported functions
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Retrieves the name of the exported function (encoded using ASCII character codification)
    and adds it to the set of **exports**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The result produced by the previous script is a set containing the Kernel32
    exports, as shown in the following partial output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can put all the pieces together in order to automate the task of
    resolving hashed Kernel32 API addresses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'In summary, we are doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: We are declaring the set of Kernel32 API names at line `05`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We are looking for matches with those API names for a provided hash at line
    `06`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We are traversing the function looking for obfuscated calls in lines `14` to
    `20`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we are setting a comment and printing the name of the function in lines
    `23` and `24`, respectively.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The execution of the script produces the following changes in the disassembly
    listing (comments about the called functions):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.10 – Comments generated by the script indicating the resolved Kernel32
    API functions'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16207_06_010.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.10 – Comments generated by the script indicating the resolved Kernel32
    API functions
  prefs: []
  type: TYPE_NORMAL
- en: Showing function names is better than nothing but it is much better to show
    symbols because they reference the function as well as showing the name. In the
    next section, you will see how to add this improvement.
  prefs: []
  type: TYPE_NORMAL
- en: Improving the scripting results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can also improve the result by adding the necessary Kernel32 symbols to
    it. For instance, you can look for the `CreateFileA` symbol in the **Symbol Tree**
    window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.11 – Looking for the CreateFileA symbol'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16207_06_011.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.11 – Looking for the CreateFileA symbol
  prefs: []
  type: TYPE_NORMAL
- en: 'Attach this symbol to the current program and access the function address by
    double-clicking on it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16207_06_012.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.12 – Looking for the CreateFileA API address
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, patch the `CALL` instruction by using the *Ctrl* + *Shift* + *G* key
    combination:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.13 – Editing a CALL instruction'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16207_06_013.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.13 – Editing a CALL instruction
  prefs: []
  type: TYPE_NORMAL
- en: 'Patch it with the `CreateFileA` address obtained before:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.14 – Patching the CALL instruction with the target CreateFileA API
    address'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16207_06_014.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.14 – Patching the CALL instruction with the target CreateFileA API
    address
  prefs: []
  type: TYPE_NORMAL
- en: 'Press the *R* key and set this reference to `INDIRECTION`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.15 – Modifying the CALL address reference type to INDIRECTION'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16207_06_015.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.15 – Modifying the CALL address reference type to INDIRECTION
  prefs: []
  type: TYPE_NORMAL
- en: 'After this modification, the code is modified, allowing Ghidra to identify
    function parameters, identify references to the function, and so on when analyzing
    the code, which is always better than putting a comment. In the following screenshot,
    you can see the resulting disassembly listing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.16 – Disassembly listing using symbols instead of comments'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16207_06_016.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.16 – Disassembly listing using symbols instead of comments
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, scripting can be very useful when analyzing malware because
    repetitive tasks such as string deobfuscation, resolving API addresses, code deobfuscation,
    and so on can be fully automated by writing a few, simple lines of code.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, the more scripts you write, the more efficient you will become,
    and the more code you can reuse for your future scripts and projects.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use scripting to be more efficient when
    analyzing malware using Ghidra. We have used scripting to go beyond the limitations
    of static analysis and resolve some API function hashes that are calculated at
    runtime.
  prefs: []
  type: TYPE_NORMAL
- en: You also learned the advantages and disadvantages of using Python or Java when
    developing a script.
  prefs: []
  type: TYPE_NORMAL
- en: You learned how to translate assembly language algorithms into Java and Python,
    and also learned skills in scripting while developing your first extremely useful
    script. By using the provided Ghidra Flat API function classification, you are
    now able to quickly identify Ghidra API functions required by your own scripts
    without needing to remember or waste time looking for a function in the documentation.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter of this book, we will cover Ghidra headless mode, which
    can be very useful in some situations, such as performing analysis of a huge amount
    of binaries or using Ghidra alone to integrate it with other tools.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Given a memory address, what Ghidra Flat API allows you to set the byte located
    at the given memory address? Describe the steps you followed when looking for
    this function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the programming language that is best supported by Ghidra and how does
    Ghidra support Python?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is it possible to statically analyze things that are resolved at runtime?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can refer to the following links for more information on the topics covered
    in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Ghidra scripting course: [https://ghidra.re/courses/GhidraClass/Intermediate/Scripting_withNotes.html#Scripting.html](https://ghidra.re/courses/GhidraClass/Intermediate/Scripting_withNotes.html#Scripting.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Java Fundamentals*, *Gazihan Alankus, Rogério Theodoro de Brito, Basheer Ahamed
    Fazal et al.*, *March 2019*:[https://www.packtpub.com/eu/application-development/java-fundamentals](https://www.packtpub.com/eu/application-development/java-fundamentals)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Python Automation Cookbook*, *Jaime Buelta*, *May 2020*: [https://www.packtpub.com/eu/programming/python-automation-cookbook-second-edition](https://www.packtpub.com/eu/programming/python-automation-cookbook-second-edition)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
