- en: Social Engineering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Social engineering is when an attacker manipulates or tricks a victim into performing
    an action or providing private information. This is often done by impersonating
    a trusted person, creating a sense of urgency, or creating a false pretext to
    push the victim to act. The action may be as simple as divulging information,
    or more complex like downloading and executing malware.
  prefs: []
  type: TYPE_NORMAL
- en: We cover honeypots in this chapter, even though they are sometimes intended
    to trick bots and not humans. The goal is to intentionally deceive, which is the
    core of social engineering. We provide basic honeypot examples including TCP and
    HTTP honeypots.
  prefs: []
  type: TYPE_NORMAL
- en: There are many other types of social engineering that are not covered in this
    book. This includes physical or in-person situations, such as tailgating and pretending
    to be a maintenance worker, as well as other digital and remote methods such as
    phone calls, SMS messages, and social media messaging.
  prefs: []
  type: TYPE_NORMAL
- en: Social engineering can be a grey area legally. For example, even if a company
    gives you the full scope to social engineer their employees, it does not give
    you permission for phishing an employee's personal email credentials. Be conscious
    of both the legal and ethical boundaries.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will specifically cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Gathering intel on an individual using Reddit's JSON REST API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending phishing emails with SMTP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating QR codes and base64 encoding images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Honeypots
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gathering intel via JSON REST API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: REST with JSON are becoming the de facto interface for web APIs. Every API is
    different, so the primary objective of this example is to show how to process
    JSON data from a REST endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: This example will take Reddit username as an argument, and print the recent
    posts and comments by that user to get an idea of what topics they discuss. Reddit
    was chosen for this example because no authentication is required for certain
    endpoints, making it easy to test. Other services that provide REST APIs that
    you could query for intel gathering are Twitter and LinkedIn.
  prefs: []
  type: TYPE_NORMAL
- en: Remember, the emphasis of this example is to provide an example of parsing JSON
    from a REST endpoint. Since every API is different, this example should serve
    as a reference when writing your own programs to interact with JSON APIs. A data
    structure must be defined to match the response from the JSON endpoint. In this
    example, the data structure created matches the Reddit response.
  prefs: []
  type: TYPE_NORMAL
- en: When working with JSON in Go, you first need to define the data structures,
    and then use the `Marshal` and `Unmarshal` functions to encode and decode between
    the raw string and structured data formats. The following example creates a data
    structure that matches the structure of the JSON returned by Reddit. The `Unmarshal`
    function is then used to convert the string into a Go data object. You don't have
    to create a variable for every piece of data in the JSON. You can omit the fields
    you don't need.
  prefs: []
  type: TYPE_NORMAL
- en: The data in the JSON response is nested into many levels, so we will make use
    of anonymous structs. This prevents us from having to create a separate named
    type for every single level of nesting. This example creates one named struct
    with all of the nested levels stored as embedded anonymous structs.
  prefs: []
  type: TYPE_NORMAL
- en: The variable names in the Go data structs do not match the variable names provided
    in the JSON response, so the JSON variable name is provided right after the data
    type is defined in the structs. This allows the variables to be properly mapped
    from the JSON data to the Go struct. This is often necessary due to the case-sensitive
    nature of the variable names in a Go data structure.
  prefs: []
  type: TYPE_NORMAL
- en: Note that every web service has its own terms of service, which may limit or
    restrict the way you access their site. Some sites have rules against scraping
    and others have rate limits. While it may not be a criminal offense, the service
    may block your account or IP address for violating terms of service. Be sure to
    read the terms of service for every website or API you interact with.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for this example is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Sending phishing emails with SMTP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Phishing is the process in which an attacker tries to obtain sensitive information
    via a fake email or some other form of communication designed to look like a legitimate
    email from a trusted source.
  prefs: []
  type: TYPE_NORMAL
- en: Phishing is often done via email, but can also be done over the phone, on social
    media, or via text messages. We are focusing on the email method. Phishing can
    be done on a large scale, where a generic email is sent out to a large number
    of recipients hoping someone will take the bait. The *Nigerian prince* email scam
    was a popular phishing campaign. Other emails offering incentives are popular
    and work relatively well, such as offering an iPhone giveaway or a gift card if
    they participate and follow the link you provided and logging in with their credentials.
    Phishing emails also often mimic legitimate senders using real signatures and
    company logos. A sense of urgency is often created to convince the victim to act
    quickly without following standard procedures.
  prefs: []
  type: TYPE_NORMAL
- en: You can gather emails using the program from [Chapter 10](1b5ddb7b-00f9-47df-947c-e4d0ebeb94e5.xhtml),
    *Web Scraping*, that extracts emails from web pages. Combine the email extraction
    capability with the web crawler example provided, and you have a powerful tool
    for scraping emails off a domain.
  prefs: []
  type: TYPE_NORMAL
- en: '**Spear phishing** is a term for targeted phishing that focuses on a small
    number of targets, maybe even just one specific target. Spear phishing requires
    more research and targeting, tailoring an email specific to the person, creating
    a believable pretext, perhaps impersonating someone they do know. Spear phishing
    takes more work, but it increases the likelihood of fooling a user, and reduces
    your chances of getting caught by spam filters.'
  prefs: []
  type: TYPE_NORMAL
- en: When attempting a spear phishing campaign, you should first gather as much information
    about your target before crafting the email. Earlier in this chapter, we talked
    about using JSON REST APIs to gather data on a target. You can also use the word
    count program and the headings grabber program from [Chapter 10](1b5ddb7b-00f9-47df-947c-e4d0ebeb94e5.xhtml),
    *Web Scraping*, if your target individual or organization has a website. Gathering
    the most common words and headings of a website can be a fast way of learning
    what industry the target belongs to or what products and services they may offer.
  prefs: []
  type: TYPE_NORMAL
- en: The Go standard library comes with an SMTP package for sending emails. Go also
    has a `net/mail` package for parsing emails ([https://golang.org/pkg/net/mail/](https://golang.org/pkg/net/mail/)).
    The `mail` package is relatively small and is not covered in this book, but it
    allows you to parse the full text of an email into a message type that lets you
    extract the body and headers individually. This example is focused on how to send
    an email with the SMTP package.
  prefs: []
  type: TYPE_NORMAL
- en: The configuration variables are all defined at the top of the source code. Be
    sure to set proper SMTP host, port, sender, and password. Common SMTP ports are
    `25` for unencrypted access, and ports `465` and `587` are often used for encrypted
    access. The settings will all depend on the configuration of your SMTP server.
    This example will not run correctly without first setting the proper server and
    credentials. If you have a Gmail account, you can reuse most of the prepopulated
    values and just replace the sender and password.
  prefs: []
  type: TYPE_NORMAL
- en: If you are sending the mail using Gmail and using the two-factor authentication,
    you will need to create an application specific password at [https://security.google.com/settings/security/apppasswords](https://security.google.com/settings/security/apppasswords).
    If you are not using two-factor authentication, then enable less secure applications
    at [https://myaccount.google.com/lesssecureapps](https://myaccount.google.com/lesssecureapps).
  prefs: []
  type: TYPE_NORMAL
- en: This program creates and sends two example emails, one text and one HTML. It
    is also possible to send a combined text and HTML email, where the email client
    chooses which version to render. This can be done using the `Content-Type` header
    to `multipart/alternative` and setting a boundary to distinguish where the text
    email ends and the HTML email starts. Sending a combined text and HTML email is
    not covered here, but is worth mentioning. You can learn more about the `multipart`
    content type, *RFC 1341*, at [https://www.w3.org/Protocols/rfc1341/7_2_Multipart.html](https://www.w3.org/Protocols/rfc1341/7_2_Multipart.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Go also provides a `template` package that allows you to create a template
    file with variable placeholders, and then populate the placeholders with data
    from a struct. The templates are useful if you want to separate the template files
    from the source code, allowing you to modify the templates without recompiling
    the application. The following example does not use a template, but you can read
    more about templates at [https://golang.org/pkg/text/template/](https://golang.org/pkg/text/template/):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Generating QR codes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **Quick Response** (**QR**) code is a two-dimensional barcode. It stores more
    information than a traditional one-dimensional line barcode. They were originally
    developed in the Japanese automotive industry, but have been adopted by other
    industries. QR codes were approved as an international standard by ISO in 2000\.
    The latest specification can be found at [https://www.iso.org/standard/62021.html](https://www.iso.org/standard/62021.html).
  prefs: []
  type: TYPE_NORMAL
- en: QR codes can be found on some billboards, posters, handouts, and other advertising
    material. QR codes are also used frequently in transactions. You might see QR
    codes on train tickets or when sending and receiving cryptocurrency such as Bitcoin.
    Some authentication services such as two-factor authentication utilize QR codes
    for convenience.
  prefs: []
  type: TYPE_NORMAL
- en: QR codes are good for social engineering because a human can't tell just by
    looking at a QR code if it is malicious or not. Often times the QR code contains
    a URL that is loaded immediately, leaving the user open to risk. If you create
    a believable pretext, you may convince a user to trust the QR code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The package used in this example is called `go-qrcode` and is available at
    [https://github.com/skip2/go-qrcode](https://github.com/skip2/go-qrcode). This
    is a third-party library available on GitHub and not supported by Google or the
    Go team. The `go-qrcode` package utilizes the standard library image packages:
    `image`, `image/color`, and `image/png`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the `go-qrcode` package with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The ellipsis (`...`) in `go get` is a wildcard. It will also install all subpackages.
  prefs: []
  type: TYPE_NORMAL
- en: According to the package author, the maximum capacity of the QR code varies
    based on the content encoded and the error recovery level. The maximum capacity
    is 2,953 bytes, 4,296 alphanumeric characters, 7,089 numeric digits, or a combination.
  prefs: []
  type: TYPE_NORMAL
- en: There are two main points being demonstrated in this program. First is how to
    generate the QR code in the form of raw PNG bytes, and then the data to be embedded
    within an HTML page is base64 encoded. The full HTML `img` tag is generated, given
    as an output to standard output, and can be copied and pasted directly into an
    HTML page. The second part demonstrates how to simply generate the QR code and
    have it written directly to a file.
  prefs: []
  type: TYPE_NORMAL
- en: 'This example generates a QR code in the format of a PNG image. Let''s provide
    the text you want to encode and the output filename as command-line arguments,
    and the program will output the image with your data encoded as a QR image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Base64 encoding data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous example, the QR code was base64 encoded. Since this is a common
    task, it is worth covering how to encode as well as decode. Any time binary data
    needs to be stored or transmitted as a string, base64 encoding is useful.
  prefs: []
  type: TYPE_NORMAL
- en: 'This example demonstrates a very simple use case of encoding and decoding a
    byte slice. The two important functions for base64 encoding and decoding are `EncodeToString()`
    and `DecodeString()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Honeypots
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Honeypots are fake services you set to catch attackers. You intentionally put
    a service up with the intention of luring attackers, tricking them into thinking
    the service is real and contains some kind of sensitive information. Often, the
    honeypot is disguised to look like an old, outdated, and vulnerable server. Logging
    or alerts can be attached to the honeypot to quickly identify a potential attacker.
    Having a honeypot on your internal network may alert you of an attacker before
    any systems are compromised.
  prefs: []
  type: TYPE_NORMAL
- en: When attackers compromise a machine, they often use the compromised machine
    to continue enumerating, attacking, and pivoting. If a honeypot on your network
    detects strange behavior coming from another machine on your network, such as
    port scans or login attempts, the machine behaving strangely might be compromised.
  prefs: []
  type: TYPE_NORMAL
- en: There are many different kinds of honeypots. It could be anything from a simple
    TCP listener that logs any connection, a fake HTML page with a login form field,
    or a full blown web application that looks like a real employee portal. If the
    attacker thinks they have found a critical application, they are more likely to
    spend time trying to gain access. If you lay out attractive honeypots, you might
    get the attacker to spend the majority of their time working on a useless honeypot.
    If detailed logging is kept, you can learn about what methods the attacker is
    using, what tools they have, and perhaps even their location.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few other types of honeypots worth mentioning, but not demonstrated
    in this book:'
  prefs: []
  type: TYPE_NORMAL
- en: '**SMTP honeypot**: This simulates an open email relay that spammers abuse to
    catch spammers trying to use your mailer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Web crawler honeypot**: These are the hidden web pages that are not intended
    to be reached by a person, but links to it are hidden in the public places of
    your website, such as HTML comments, to catch spiders, crawlers, and scrapers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Database honeypot**: This is a fake or real database with verbose logging
    to detect attackers, that may also contain fake data to see what information attackers
    are interested in.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Honeynet**: This is an entire network full of honeypots, made to look like
    a real network to the extent of automating or faking client traffic to the honeypot
    services to simulate real users.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Attackers may be able to spot obvious honeypot services and avoid them. I recommend
    that you go with one of two extremes: making the honeypot mimic a real service
    as closely as possible, or making the service a total black box that does not
    give away any information to the attacker.'
  prefs: []
  type: TYPE_NORMAL
- en: We cover very basic examples in this section, to help you understand the concept
    of honeypots and give you a template to create your own more customized honeypots.
    First, a basic TCP socket honeypot is demonstrated. This will listen on a port
    and log any connections and data it receives. To accompany this example, a TCP
    testing tool is provided. It behaves like a primitive version of Netcat, allowing
    you to send a single message to a server via standard input. This can be used
    to test the TCP honeypot or to extend and use for other applications. The last
    example is an HTTP honeypot. It provides a login form that logs attempts to authenticate,
    but always returns an error.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure that you understand the risks of honeypots on your network. If you
    leave a honeypot running without keeping the underlying operating system updated,
    you are potentially adding a real risk to your network.
  prefs: []
  type: TYPE_NORMAL
- en: TCP honeypot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The simplest honeypot we will start with is a TCP honeypot. This will log any
    TCP connection received and any data received from the client.
  prefs: []
  type: TYPE_NORMAL
- en: It will respond with an authentication failure message. Since it logs any data
    received from the client, it will log any username and passwords they attempt
    to authenticate with. You can learn about their attack methods by inspecting what
    authentication methods they are attempting, since it acts like a black box and
    does not give any clues as to what authentication mechanism it might use. You
    can use the logs to see if they are treating it like an SMTP server, which may
    indicate a spammer, or maybe they are trying to authenticate with a database indicating
    they are looking for information. Studying the actions of an attacker can be very
    insightful and even enlighten to with the vulnerabilities you did not already
    know about. An attacker may use a service fingerprinting tool on the honeypot,
    and you might be able to identify patterns in their attack methods and find ways
    to block them. If an attacker tries to log in using real user credentials, that
    user is likely compromised.
  prefs: []
  type: TYPE_NORMAL
- en: 'This example will log high-level requests such as HTTP requests as well as
    low level connections such as a TCP port scanner. TCP connect scans will be logged,
    but TCP `SYN` only (stealth) scans will not be detected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The TCP testing tool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to test our TCP honeypot, we need to send it some TCP traffic. We can
    use any existing network tool, including a web browser or a FTP client to hit
    the honeypot. A great tool for this is also Netcat, the TCP/IP Swiss army knife.
    Instead of using Netcat though, let's create our own simple clone. It will simply
    read and write data over TCP. The input and output will be through standard input
    and standard output respectively, allowing you to use the keyboard and Terminal
    or pipe data in or out of files and other applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'This tool can be used as a general purpose network testing tool, and if you
    have any intrusion detection system or other monitoring you want to test, it may
    be useful. This program will take data from standard input and send it over the
    TCP connection, then read any data the server sends back and print it to standard
    output. When running this example, you must pass the host and port as a single
    string with a colon separator, like this: `localhost:9001`. Here is the code for
    the simple TCP testing tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: HTTP POST form login honeypot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you deploy this on the network, unless you are doing intentional testing,
    any form submission is a red flag. This means that someone is making an attempt
    to log in to your fake server. Since there is no legitimate purpose for it, only
    an attacker would have any reason to attempt to gain access. There will be no
    real authentication or authorization, just a facade to make the attacker think
    they are attempting to log in. The Go HTTP package does support HTTP 2 by default
    in Go 1.6+. Read more about the `net/http` package at [https://golang.org/pkg/net/http/](https://golang.org/pkg/net/http/).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following program will act as a web server with a login page, that just
    logs form submissions to standard output. You can run this server and then try
    to log in via the browser, and the log in attempt will be printed to Terminal,
    which runs the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: HTTP form field honeypots
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous example, we talked about creating a fake login form to detect
    someone attempting to log in. What if we want to identify whether it is a bot
    or not? The ability to detect a bot trying to log in can also be useful on a production
    site to block bots. One method of identifying automated bots is to use honeypot
    form fields. Honeypot form fields are input fields on an HTML form, which are
    hidden from the user and expected to be blank when the form is submitted by a
    human. A bot will still find the honeypot fields in the form and try to fill them
    out.
  prefs: []
  type: TYPE_NORMAL
- en: The goal is to trick bots into thinking that the form fields are real while
    keeping it hidden from users. Some bots will use regular expressions to look for
    keywords such as `user` or `email` and fill out only those fields; so honeypot
    fields often use names such as `email_address` or `user_name` to appear like a
    normal field. If the server receives data in those fields, it can assume that
    the form was submitted by a bot.
  prefs: []
  type: TYPE_NORMAL
- en: If we took the login form in the previous example and added a hidden form field
    named `email`, a bot might try to fill it out while a human would not see it.
    Form fields could be hidden using CSS or the `hidden` attribute on the `input`
    element. I recommend that you use CSS located in a separate style sheet to hide
    honeypot form fields, because a bot can easily determine if the form field had
    the `hidden` attribute, but would have a harder time detecting if the input was
    hidden using a style sheet.
  prefs: []
  type: TYPE_NORMAL
- en: Sandboxing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One related technique that is not demonstrated in this chapter, but is worth
    mentioning, is sandboxing. Sandboxing serves a different purpose from a honeypot,
    but they both make an effort to create an environment that looks legitimate, but
    is actually tightly controlled and monitored. An example of sandboxing is the
    creation of a virtual machine with no network connectivity, which logs all file
    changes and attempted network connections to see if anything suspicious happens.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, a sandbox environment can be detected by looking at the number of
    CPUs and the RAM. If the malicious application detects a system with a small amount
    of resources, say 1 CPU and 1 GB RAM, then it is likely not to be a modern desktop
    machine and may be a sandbox. Malicious software writers have learned to fingerprint
    sandbox environments and program the application to bypass any malicious actions
    if it suspects that it is being run within a sandbox.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After reading this chapter, you should now understand the general concept of
    social engineering and be able to provide a few examples. You should understand
    how to interact with the REST APIs using JSON, generate QR codes and base64 encode
    data, and send emails using SMTP. You should also be able to explain the concept
    of a honeypot and understand how to implement your own honeypot or extend these
    examples for your own needs.
  prefs: []
  type: TYPE_NORMAL
- en: What other types of honeypots can you think of? What are the common services
    that get brute forced or attacked frequently? How can you customize or expand
    upon the social engineering examples? Can you think of any other services that
    you can query for information gathering?
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll cover post exploitation topics, such as deploying
    a bind shell, reverse bind shell, or web shells; cross compiling; finding writable
    files; and modifying file timestamps, permission, and ownership.
  prefs: []
  type: TYPE_NORMAL
