["```\n// Line comment, everything after slashes ignored\n/* General comment, can be in middle of line or span multiple lines */\n```", "```\nvar customFlag bool = false  \n```", "```\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n   // Decimal for 15\n   number0 := 15\n\n   // Octal for 15\n   number1 := 017 \n\n   // Hexadecimal for 15\n   number2 := 0x0F\n\n   fmt.Println(number0, number1, number2)\n} \n```", "```\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n   // Long form assignment\n   var myText = \"test string 1\"\n\n   // Short form assignment\n   myText2 := \"test string 2\"\n\n   // Multiline string\n   myText3 := `long string\n   spanning multiple\n   lines` \n\n   fmt.Println(myText) \n   fmt.Println(myText2) \n   fmt.Println(myText3)\n} \n```", "```\nvar myByteArray [128]byte  \n```", "```\nsingleByte := myByteArray[4]\n```", "```\nmake([]T, lengthAndCapacity)\nmake([]T, length, capacity) \n```", "```\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n   // Create a nil slice\n   var mySlice []byte\n\n   // Create a byte slice of length 8 and max capacity 128\n   mySlice = make([]byte, 8, 128)\n\n   // Maximum capacity of the slice\n   fmt.Println(\"Capacity:\", cap(mySlice))\n\n   // Current length of slice\n   fmt.Println(\"Length:\", len(mySlice))\n} \n```", "```\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n   var mySlice []int // nil slice\n\n   // Appending works on nil slices.\n   // Since nil slices have zero capacity, and have\n   // no underlying array, it will create one.\n   mySlice = append(mySlice, 1, 2, 3, 4, 5)\n\n   // Individual elements can be accessed from a slice\n   // just like an array by using the square bracket operator.\n   firstElement := mySlice[0]\n   fmt.Println(\"First element:\", firstElement)\n\n   // To get only the second and third element, use:\n   subset := mySlice[1:4]\n   fmt.Println(subset)\n\n   // To get the full contents of a slice except for the \n   // first element, use:\n   subset = mySlice[1:]\n   fmt.Println(subset)\n\n   // To get the full contents of a slice except for the \n   // last element, use:\n   subset = mySlice[0 : len(mySlice)-1]\n   fmt.Println(subset)\n\n   // To copy a slice, use the copy() function.\n   // If you assign one slice to another with the equal operator,\n   // the slices will point at the same memory location,\n   // and changing one would change both slices.\n   slice1 := []int{1, 2, 3, 4}\n   slice2 := make([]int, 4)\n\n   // Create a unique copy in memory\n   copy(slice2, slice1)\n\n   // Changing one should not affect the other\n   slice2[3] = 99\n   fmt.Println(slice1)\n   fmt.Println(slice2)\n} \n```", "```\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n   // Define a Person type. Both fields public\n   type Person struct {\n      Name string\n      Age  int\n   }\n\n   // Create a Person object and store the pointer to it\n   nanodano := &Person{Name: \"NanoDano\", Age: 99}\n   fmt.Println(nanodano)\n\n   // Structs can also be embedded within other structs.\n   // This replaces inheritance by simply storing the\n   // data type as another variable.\n   type Hacker struct {\n      Person           Person\n      FavoriteLanguage string\n   }\n   fmt.Println(nanodano)\n\n   hacker := &Hacker{\n      Person:           *nanodano,\n      FavoriteLanguage: \"Go\",\n   }\n   fmt.Println(hacker)\n   fmt.Println(hacker.Person.Name)\n\n   fmt.Println(hacker)\n} \n```", "```\npackage main\n\nimport (\n   \"fmt\"\n   \"reflect\"\n)\n\nfunc main() {\n   myInt := 42\n   intPointer := &myInt\n\n   fmt.Println(reflect.TypeOf(intPointer))\n   fmt.Println(intPointer)\n   fmt.Println(*intPointer)\n} \n```", "```\npackage main\n\nimport \"fmt\"\n\n// Function with no parameters\nfunc sayHello() {\n   fmt.Println(\"Hello.\")\n}\n\n// Function with one parameter\nfunc greet(name string) {\n   fmt.Printf(\"Hello, %s.\\n\", name)\n}\n\n// Function with multiple params of same type\nfunc greetCustom(name, greeting string) {\n   fmt.Printf(\"%s, %s.\\n\", greeting, name)\n}\n\n// Variadic parameters, unlimited parameters\nfunc addAll(numbers ...int) int {\n   sum := 0\n   for _, number := range numbers {\n      sum += number\n   }\n   return sum\n}\n\n// Function with multiple return values\n// Multiple values encapsulated by parenthesis\nfunc checkStatus() (int, error) {\n   return 200, nil\n}\n\n// Define a type as a function so it can be used\n// as a return type\ntype greeterFunc func(string)\n\n// Generate and return a function\nfunc generateGreetFunc(greeting string) greeterFunc {\n   return func(name string) {\n      fmt.Printf(\"%s, %s.\\n\", greeting, name)\n   }\n}\n\nfunc main() {\n   sayHello()\n   greet(\"NanoDano\")\n   greetCustom(\"NanoDano\", \"Hi\")\n   fmt.Println(addAll(4, 5, 2, 3, 9))\n\n   russianGreet := generateGreetFunc(\"Привет\")\n   russianGreet(\"NanoDano\")\n\n   statusCode, err := checkStatus()\n   fmt.Println(statusCode, err)\n} \n```", "```\ntype error interface {\n   Error() string\n} \n```", "```\npackage main\n\nimport \"fmt\"\n\n// Define a custom type that will\n// be used to satisfy the error interface\ntype customError struct {\n   Message string\n}\n\n// Satisfy the error interface\n// by implementing the Error() function\n// which returns a string\nfunc (e *customError) Error() string {\n   return e.Message\n}\n\n// Sample function to demonstrate\n// how to use the custom error\nfunc testFunction() error {\n   if true != false { // Mimic an error condition\n      return &customError{\"Something went wrong.\"}\n   }\n   return nil\n}\n\nfunc main() {\n   err := testFunction()\n   if err != nil {\n      fmt.Println(err)\n   }\n} \n```", "```\ntype Reader interface {\n   Read(p []byte) (n int, err error)\n} \n\ntype Writer interface {\n   Write(p []byte) (n int, err error)\n} \n```", "```\npackage main\n\nimport (\n   \"fmt\"\n   \"reflect\"\n)\n\nfunc main() {\n   // Nil maps will cause runtime panic if used \n   // without being initialized with make()\n   var intToStringMap map[int]string\n   var stringToIntMap map[string]int\n   fmt.Println(reflect.TypeOf(intToStringMap))\n   fmt.Println(reflect.TypeOf(stringToIntMap))\n\n   // Initialize a map using make\n   map1 := make(map[string]string)\n   map1[\"Key Example\"] = \"Value Example\"\n   map1[\"Red\"] = \"FF0000\"\n   fmt.Println(map1)\n\n   // Initialize a map with literal values\n   map2 := map[int]bool{\n      4:  false,\n      6:  false,\n      42: true,\n   }\n\n   // Access individual elements using the key\n   fmt.Println(map1[\"Red\"])\n   fmt.Println(map2[42])\n   // Use range to iterate through maps\n   for key, value := range map2 {\n      fmt.Printf(\"%d: %t\\n\", key, value)\n   }\n\n} \n```", "```\npackage main\n\nimport (\n   \"log\"\n   \"time\"\n)\n\n// Do some processing that takes a long time\n// in a separate thread and signal when done\nfunc process(doneChannel chan bool) {\n   time.Sleep(time.Second * 3)\n   doneChannel <- true\n}\n\nfunc main() {\n   // Each channel can support one data type.\n   // Can also use custom types\n   var doneChannel chan bool\n\n   // Channels are nil until initialized with make\n   doneChannel = make(chan bool)\n\n   // Kick off a lengthy process that will\n   // signal when complete\n   go process(doneChannel)\n\n   // Get the first bool available in the channel\n   // This is a blocking operation so execution\n   // will not progress until value is received\n   tempBool := <-doneChannel\n   log.Println(tempBool)\n   // or to simply ignore the value but still wait\n   // <-doneChannel\n\n   // Start another process thread to run in background\n   // and signal when done\n   go process(doneChannel)\n\n   // Make channel non-blocking with select statement\n   // This gives you the ability to continue executing\n   // even if no message is waiting in the channel\n   var readyToExit = false\n   for !readyToExit {\n      select {\n      case done := <-doneChannel:\n         log.Println(\"Done message received.\", done)\n         readyToExit = true\n      default:\n         log.Println(\"No done signal yet. Waiting.\")\n         time.Sleep(time.Millisecond * 500)\n      }\n   }\n} \n```", "```\npackage main\n\nimport (\n   \"fmt\"\n   \"math/rand\"\n)\n\nfunc main() {\n   x := rand.Int()\n\n   if x < 100 {\n      fmt.Println(\"x is less than 100.\")\n   }\n\n   if x < 1000 {\n      fmt.Println(\"x is less than 1000.\")\n   } else if x < 10000 {\n      fmt.Println(\"x is less than 10,000.\")\n   } else {\n      fmt.Println(\"x is greater than 10,000\")\n   }\n\n   fmt.Println(\"x:\", x)\n\n   // You can put a statement before the condition \n   // The variable scope of n is limited\n   if n := rand.Int(); n > 1000 {\n      fmt.Println(\"n is greater than 1000.\")\n      fmt.Println(\"n:\", n)\n   } else {\n      fmt.Println(\"n is not greater than 1000.\")\n      fmt.Println(\"n:\", n)\n   }\n   // n is no longer available past the if statement\n} \n```", "```\npackage main\n\nimport (\n   \"fmt\"\n)\n\nfunc main() {\n   // Basic for loop\n   for i := 0; i < 3; i++ {\n      fmt.Println(\"i:\", i)\n   }\n\n   // For used as a while loop\n   n := 5\n   for n < 10 {\n      fmt.Println(n)\n      n++\n   }\n} \n```", "```\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n   intSlice := []int{2, 4, 6, 8}\n   for key, value := range intSlice {\n      fmt.Println(key, value)\n   }\n\n   myMap := map[string]string{\n      \"d\": \"Donut\",\n      \"o\": \"Operator\",\n   }\n\n   // Iterate over a map\n   for key, value := range myMap {\n      fmt.Println(key, value)\n   }\n\n   // Iterate but only utilize keys\n   for key := range myMap {\n      fmt.Println(key)\n   }\n\n   // Use underscore to ignore keys\n   for _, value := range myMap {\n      fmt.Println(value)\n   }\n} \n```", "```\npackage main\n\nimport (\n   \"fmt\"\n   \"math/rand\"\n)\n\nfunc main() {\n   x := 42\n\n   switch x {\n   case 25:\n      fmt.Println(\"X is 25\")\n   case 42:\n      fmt.Println(\"X is the magical 42\")\n      // Fallthrough will continue to next case\n      fallthrough\n   case 100:\n      fmt.Println(\"X is 100\")\n   case 1000:\n      fmt.Println(\"X is 1000\")\n   default:\n      fmt.Println(\"X is something else.\")\n   }\n\n   // Like the if statement a statement\n   // can be put in front of the switched variable\n   switch r := rand.Int(); r {\n   case r % 2:\n      fmt.Println(\"Random number r is even.\")\n   default:\n      fmt.Println(\"Random number r is odd.\")\n   }\n   // r is no longer available after the switch statement\n} \n```", "```\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\n   goto customLabel\n\n   // Will never get executed because\n   // the goto statement will jump right\n   // past this line\n   fmt.Println(\"Hello\")\n\n   customLabel:\n   fmt.Println(\"World\")\n} \n```", "```\npackage main\n\nimport (\n   \"log\"\n   \"os\"\n)\n\nfunc main() {\n\n   file, err := os.Create(\"test.txt\")\n   if err != nil {\n      log.Fatal(\"Error creating file.\")\n   }\n   defer file.Close()\n   // It is important to defer after checking the errors.\n   // You can't call Close() on a nil object\n   // if the open failed.\n\n   // ...perform some other actions here...\n\n   // file.Close() will be called before final exit\n} \n```", "```\nimport \"fmt\" \n```", "```\nimport (\n   \"fmt\"\n   \"log\"\n) \n```", "```\npackage main\n\nimport (\n   \"fmt\"\n   \"reflect\"\n)\n\ntype Person struct {\n   Name string\n   Age  int\n} \n\ntype Doctor struct {\n   Person         Person\n   Specialization string\n}\n\nfunc main() {\n   nanodano := Person{\n      Name: \"NanoDano\",\n      Age:  99,\n   } \n\n   drDano := Doctor{\n      Person:         nanodano,\n      Specialization: \"Hacking\",\n   }\n\n   fmt.Println(reflect.TypeOf(nanodano))\n   fmt.Println(nanodano)\n   fmt.Println(reflect.TypeOf(drDano))\n   fmt.Println(drDano)\n} \n```", "```\npackage main\n\nimport \"fmt\"\n\ntype Person struct {\n   Name string\n}\n\nfunc NewPerson() Person {\n   return Person{\n      Name: \"Anonymous\",\n   }\n}\n\nfunc main() {\n   p := NewPerson()\n   fmt.Println(p)\n} \n```", "```\nmyObject.myMethod() \n```", "```\npackage main\n\nimport \"fmt\"\n\ntype Person struct {\n   Name string\n}\n\n// Person function receiver\nfunc (p Person) PrintInfo() {\n   fmt.Printf(\"Name: %s\\n\", p.Name)\n}\n\n// Person pointer receiver\n// If you did not use the pointer receivers\n// it would not modify the person object\n// Try removing the asterisk here and seeing how the\n// program changes behavior\nfunc (p *Person) ChangeName(newName string) {\n   p.Name = newName\n}\n\nfunc main() {\n   nanodano := Person{Name: \"NanoDano\"}\n   nanodano.PrintInfo()\n   nanodano.ChangeName(\"Just Dano\")\n   nanodano.PrintInfo()\n} \n```", "```\npackage main\n\nimport (\n   \"log\"\n   \"time\"\n)\n\nfunc countDown() {\n   for i := 5; i >= 0; i-- {\n      log.Println(i)\n      time.Sleep(time.Millisecond * 500)\n   }\n}\n\nfunc main() {\n   // Kick off a thread\n   go countDown()\n\n   // Since functions are first-class\n   // you can write an anonymous function\n   // for a goroutine\n   go func() {\n      time.Sleep(time.Second * 2)\n      log.Println(\"Delayed greetings!\")\n   }()\n\n   // Use channels to signal when complete\n   // Or in this case just wait\n   time.Sleep(time.Second * 4)\n} \n```", "```\n # Get fmt package information\n godoc fmt\n\n # Get source code for fmt package\n godoc -src fmt\n\n # Get specific function information\n godoc fmt Printf\n\n # Get source code for function\n godoc -src fmt Printf\n\n # Run HTTP server to view HTML documentation\n godoc -http=localhost:9999\n\n```"]