<html><head></head><body><div><p>&#13;
			<h1 id="_idParaDest-91"><em class="italic"><a id="_idTextAnchor108"/>Chapter 6</em>: Scripting Malware Analysis</h1>&#13;
			<p><a id="_idTextAnchor109"/>In this chapter, we will apply the scripting capabilities of Ghidra to malware analysis. By using and writing Ghidra scripts, you will be able to analyze malware in a more efficient way.</p>&#13;
			<p>You will learn how to statically resolve the Kernel32 API hashed functions used by Alina shellcode, which was superficially analyzed in the previous chapter.</p>&#13;
			<p><a id="_idTextAnchor110"/><a id="_idTextAnchor111"/>The Flat APIs are <em class="italic">simple</em> but powerful versions of the full-fledged complex Ghidra API. They are a great starting point for anyone looking to develop Ghidra modules and/or scripts. </p>&#13;
			<p>We will start by classifying the Ghidra Flat API functions into categories in order to get more comfortable when looking for a function. Following that, we will look at how to iterate over the code using Java and Python, and, finally, we will use the mentioned code to deobfuscate malware.</p>&#13;
			<p>To deobfuscate is to convert a program that is difficult to understand into one that is simple, understandable, and straightforward. There are tools available to deobfuscate tough code or a tough program into a simple and understandable form. Obfuscation is usually done to prevent reverse engineering, making it hard for those with malicious intentions to understand its inner functionality. Similarly, obfuscation may also be used to conceal malicious content in software. A deobfuscating tool is used to reverse-engineer these programs. Although deobfuscation is always possible, the attacker tries to benefit from the following asymmetry: little effort required to obfuscate versus a lot of effort to deobfuscate.</p>&#13;
			<p>In this chapter, we're going to cover the following main topics: </p>&#13;
			<ul>&#13;
				<li>Using the Ghidra scripting API</li>&#13;
				<li>Writing scripts using the Java programming language</li>&#13;
				<li>Writing scripts using the Python programming language</li>&#13;
				<li>Deobfuscating malware samples using scripts</li>&#13;
			</ul>&#13;
			<h1 id="_idParaDest-92"><a id="_idTextAnchor112"/>Technical requirements </h1>&#13;
			<p>The code for this chapter can be found at <a href="https://github.com/PacktPublishing/Ghidra-Software-Reverse-Engineering-for-Beginners/tree/master/Chapter06">https://github.com/PacktPublishing/Ghidra-Software-Reverse-Engineering-for-Beginners/tree/master/Chapter06</a>.</p>&#13;
			<p>Check out the following link to see the Code in Action video: <a href="https://bit.ly/36RZOMQ">https://bit.ly/36RZOMQ</a></p>&#13;
			<h1 id="_idParaDest-93"><a id="_idTextAnchor113"/>Using the Ghidra scripting API</h1>&#13;
			<p>The Ghidra <a id="_idIndexMarker212"/>scripting API is divided into the Flat API (<code>ghidra.app.decompiler.flatapi</code>) and the rest of the functions (<a href="http://ghidra.re/ghidra_docs/api/overview-tree.html">http://ghidra.re/ghidra_docs/api/overview-tree.html</a>), which are more complex.</p>&#13;
			<p>The Flat API is a simplified version of the Ghidra API, and it allows you, in summary, to perform the following actions:</p>&#13;
			<ul>&#13;
				<li>These functions allow you to work with memory addresses: <code>addEntryPoint</code>, <code>addInstructionXref</code>, <code>createAddressSet</code>, <code>getAddressFactory</code>, and <code>removeEntryPoint</code>.</li>&#13;
				<li>Use these functions to perform code analysis: <code>analyze</code>, <code>analyzeAll</code>, <code>analyzeChanges</code>, <code>analyzeAll</code>, and <code>analyzeChanges</code>.</li>&#13;
				<li>Use the following function to clear the code listing: <code>clearListing</code>.</li>&#13;
				<li>The following functions allow you to declare data: <code>createAsciiString</code>, <code>createAsciiString</code>, <code>createBookmark</code>, <code>createByte</code>, <code>createChar</code>, <code>createData</code>, <code>createDouble</code>, <code>createDWord</code>, <code>createDwords</code>, <code>createEquate</code>, <code>createUnicodeString</code>, <code>removeData</code>, <code>removeDataAt</code>, <code>removeEquate</code>, <code>removeEquate</code>, and <code>removeEquates</code>.</li>&#13;
				<li>Use these functions to get data from a memory address: <code>getInt</code>, <code>getByte</code>, <code>getBytes</code>, <code>getShort</code>, <code>getLong</code>, <code>getFloat</code>, <code>getDouble</code>, <code>getDataAfter</code>, <code>getDataAt</code>, <code>getDataBefore</code>, <code>getLastData</code>, <code>getDataContaining</code>, <code>getUndefinedDataAfter</code>, <code>getUndefinedDataAt</code>, <code>getUndefinedDataBefore</code>, <code>getMemoryBlock</code>, <code>getMemoryBlocks</code>, and <code>getFirstData</code>.</li>&#13;
				<li>The following functions allow you to work with references: <code>createExternalReference</code>, <code>createStackReference</code>, <code>getReference</code>, <code>getReferencesFrom</code>, <code>getReferencesTo</code>, and <code>setReferencePrimary</code>.</li>&#13;
				<li>These functions allow you to work with data types: <code>createFloat</code>, <code>createQWord</code>, <code>createWord</code>, <code>getDataTypes</code>, and <code>openDataTypeArchive</code>.</li>&#13;
				<li>Use these functions <a id="_idIndexMarker213"/>to set a value to some memory address: <code>setByte</code>, <code>setBytes</code>, <code>setDouble</code>, <code>setFloat</code>, <code>setInt</code>, <code>setLong</code>, and <code>setShort</code></li>&#13;
				<li>These functions allow you to create fragments: <code>getFragment</code>, <code>createFragment</code>, <code>createFunction</code>, <code>createLabel</code>, <code>createMemoryBlock</code>, <code>createMemoryReference</code>, <code>createSymbol</code>, <code>getSymbol</code>, <code>getSymbols</code>, <code>getSymbolAfter</code>, <code>getSymbolAt</code>, <code>getSymbolBefore</code>, <code>getSymbols</code>, and <code>getBookmarks</code>.</li>&#13;
				<li>Use the following function to disassemble bytes: <code>disassemble</code>.</li>&#13;
				<li>These functions allow you to work with transactions: <code>end</code> and <code>start</code>.</li>&#13;
				<li>If you want to find values, use the following set of functions: <code>find</code>, <code>findBytes</code>, <code>findPascalStrings</code>, and <code>findStrings</code>.</li>&#13;
				<li>The following functions allow you to operate at a function level: <code>getGlobalFunctions</code>, <code>getFirstFunction</code>, <code>getFunction</code>, <code>getFunctionAfter</code>, <code>getFunctionAt</code>, <code>getFunctionBefore</code>, <code>getFunctionContaining</code>, and <code>getLastFunction</code>.</li>&#13;
				<li>The following functions allow you to operate at a program level: <code>getCurrentProgram</code>, <code>saveProgram</code>, <code>set</code>, and <code>getProgramFile</code>.</li>&#13;
				<li>The following functions allow you to operate at an instruction level: <code>getFirstInstruction</code>, <code>getInstructionAfter</code>, <code>getInstructionAt</code>, <code>getInstructionBefore</code>, <code>getInstructionContaining</code>, and <code>getLastInstruction</code>.</li>&#13;
				<li>These functions allow you to work with equates: <code>getEquate</code> and <code>getEquates</code>.</li>&#13;
				<li>If you want to remove something, use the following set of functions: <code>removeBookmark</code>, <code>removeFunction</code>, <code>removeFunctionAt</code>, <code>removeInstruction</code>, <code>removeInstructionAt</code>, <code>removeMemoryBlock</code>, <code>removeReference</code>, and <code>removeSymbol</code>.</li>&#13;
				<li>These functions allow you to work with comments: <code>setEOLComment</code>, <code>setPlateComment</code>, <code>setPostComment</code>, <code>setPreComment</code>, <code>getPlateComment</code>, <code>getPostComment</code>, <code>getPreComment</code>, <code>getEOLComment</code>, and <code>toAddr</code>.</li>&#13;
				<li>Use the following function to decompile bytes: <code>FlatDecompilerAPI</code>, <code>decompile</code>, and <code>getDecompiler</code>.</li>&#13;
				<li>And finally, some <a id="_idIndexMarker214"/>miscellaneous functions: <code>getMonitor</code>, <code>getNamespace</code>, and <code>getProjectRootFolder</code>.</li>&#13;
			</ul>&#13;
			<p>This reference can be helpful to you when getting started with Ghidra scripting to identify the function that you need and look for the prototype in the documentation.</p>&#13;
			<h1 id="_idParaDest-94"><a id="_idTextAnchor114"/>Writing scripts using the Java programming language</h1>&#13;
			<p>As you <a id="_idIndexMarker215"/>know from the previous chapter, Alina <a id="_idIndexMarker216"/>malware incorporates shellcode that is injected into the <code>explorer.exe</code> process. If you want to deobfuscate the shellcode Kernel32 API function calls, then you will need to identify call instructions. You will also need to filter the functions in order to get only what you need, and finally, of course, you will need to perform the deobfuscation:</p>&#13;
			<pre>01. Function fn = getFunctionAt(currentAddress);</pre>&#13;
			<pre>02. Instruction i = getInstructionAt(currentAddress);</pre>&#13;
			<pre>03. while(getFunctionContaining(i.getAddress()) == fn){</pre>&#13;
			<pre>04.     String nem = i.getMnemonicString();</pre>&#13;
			<pre>05.     if(nem.equals("CALL")){</pre>&#13;
			<pre>06.         Object[] target_address = i.getOpObjects(0);</pre>&#13;
			<pre>07.         if(target_address[0].toString().equals("EBP")){</pre>&#13;
			<pre>08.             // Do your deobfuscation here.</pre>&#13;
			<pre>09.         }</pre>&#13;
			<pre>10.     }</pre>&#13;
			<pre>11.     i = i.getNext();</pre>&#13;
			<pre>12. }</pre>&#13;
			<p>Let me explain how this code works line by line:</p>&#13;
			<ol>&#13;
				<li>It obtains the function containing the current address (the focused address) (line <code>01</code>).</li>&#13;
				<li>The instruction at the current address is also obtained (line <code>02</code>).</li>&#13;
				<li>A loop iterating from the current instruction to the end of the function is performed (line <code>03</code>).</li>&#13;
				<li>The <a id="_idIndexMarker217"/>mnemonic of the <a id="_idIndexMarker218"/>instruction is obtained (line <code>04</code>).</li>&#13;
				<li>It checks whether the mnemonic corresponds to a <code>CALL</code> instruction, which is the type of instruction we are interested in (line <code>05</code>).</li>&#13;
				<li>The instruction operands are also retrieved (line <code>06</code>).</li>&#13;
				<li>Since obfuscated calls are relative to the <code>EBP</code> address where the hash table exists, we check whether <code>EBP</code> is an operand (line <code>07</code>).</li>&#13;
				<li>The deobfuscation routine must be implemented in this line (line <code>08</code>).</li>&#13;
				<li>Retrieve the next instruction (line <code>11</code>).</li>&#13;
			</ol>&#13;
			<p>In this section, you learned how to use the Ghidra API to implement scripts using the Java language. In the next section, you will learn how to do the same thing using Python and we will compare both languages but in the context of Ghidra scripting.</p>&#13;
			<h1 id="_idParaDest-95"><a id="_idTextAnchor115"/>Writing scripts using the Python programming language</h1>&#13;
			<p>If we <a id="_idIndexMarker219"/>rewrite the deobfucation code skeleton <a id="_idIndexMarker220"/>using Python, it looks as follows:</p>&#13;
			<pre>01. fn = getFunctionAt(currentAddress)</pre>&#13;
			<pre>02. i = getInstructionAt(currentAddress)</pre>&#13;
			<pre>03. while getFunctionContaining(i.getAddress()) == fn:</pre>&#13;
			<pre>04.     nem = i.getMnemonicString()</pre>&#13;
			<pre>05.     if nem == "CALL":</pre>&#13;
			<pre>06.         target_address = i.getOpObjects(0)</pre>&#13;
			<pre>07.         if target_address[0].toString()=='EBP':</pre>&#13;
			<pre>08.             # Do your deobfuscation here.</pre>&#13;
			<pre>09.     i = i.getNext()</pre>&#13;
			<p>As you can see, it is similar to Java in that it doesn't need additional explanation.</p>&#13;
			<p>To develop a Ghidra script, it is not necessary to remember all the functions. The only important thing is to be clear about what you want to do and have located the necessary resources, such as documentation to locate the right API functions.</p>&#13;
			<p>Python is an awesome language with an awesome community that develops libraries and tools. If you want to write code really fast, Python is a great option. Unfortunately, Ghidra doesn't incorporate a pure Python implementation. Ghidra is mostly implemented in Java and then ported to Python via Jython.</p>&#13;
			<p>Theoretically, you can choose indistinctly to use either Python or Java but, in practical terms, Jython has some issues:</p>&#13;
			<ul>&#13;
				<li>Jython relies on Python 2.x, which is deprecated.</li>&#13;
				<li>Sometimes, some things work as expected in Java but don't work in Jython. Here are some examples:<p>- <a href="https://github.com/NationalSecurityAgency/ghidra/issues/1890">https://github.com/NationalSecurityAgency/ghidra/issues/1890</a></p><p>- <a href="https://github.com/NationalSecurityAgency/ghidra/issues/1608">https://github.com/NationalSecurityAgency/ghidra/issues/1608</a></p></li>&#13;
			</ul>&#13;
			<p>Due to the things mentioned here, it is your decision whether you implement your scripts using a <a id="_idIndexMarker221"/>more stable language <a id="_idIndexMarker222"/>such as Java or a quicker but a little more unstable one such as Python. Feel free to evaluate both options and make your decision!</p>&#13;
			<h1 id="_idParaDest-96"><a id="_idTextAnchor116"/>Deobfuscating malware samples using scripts</h1>&#13;
			<p>In the <a id="_idIndexMarker223"/>previous chapter, we showed how Alina injects <a id="_idIndexMarker224"/>shellcode into the <code>explorer.exe</code> process. We analyzed this by simply reading the strings, which is a quick, practical approach, but we can be more accurate in our analysis. Let's focus on some shellcode details.</p>&#13;
			<h2 id="_idParaDest-97"><a id="_idTextAnchor117"/>The delta offset</h2>&#13;
			<p>When injecting code, it is <a id="_idIndexMarker225"/>placed in a position that is unknown at <a id="_idIndexMarker226"/>development time. As a consequence, the data cannot be accessed by using absolute addresses; instead, it must be accessed via relative positions. The shellcode retrieves the current address at runtime. In other words, it retrieves the <code>EIP</code> register.</p>&#13;
			<p>The purpose of the <code>EIP</code> register in x86 architecture (32-bit) is to point to the next instruction to execute; so, it controls the flow of a program. It determines the next instruction to execute. </p>&#13;
			<p>But, as the <code>EIP</code> register is controlled implicitly (by control-transfer instructions, interruptions, and exceptions), it cannot be accessed directly, so it is retrieved by the malware performing the following technique:</p>&#13;
			<ol>&#13;
				<li value="1">Performs a <code>CALL</code> instruction pointing to an address 5 bytes away. So, the call performs two changes:<p>- It pushes the return address (the address of the next instruction) onto the stack, which is <code>0x004f6105</code>:</p><div><img src="img/B16207_06_001.jpg" alt="Figure 6.1 – The CALL instruction pushes the return address onto the stack&#13;&#10;"/></p><p class="figure-caption"> </p><p class="figure-caption">Figure 6.1 – The CALL instruction pushes the return address onto the stack</p><p>- It transfers the control to the target address:</p><div><img src="img/B16207_06_002.jpg" alt="Figure 6.2 – The CALL instruction transfers the flow to the target address&#13;&#10;"/></div><p class="figure-caption"> </p><p class="figure-caption">Figure 6.2 – The CALL instruction transfers the flow to the target address</p></li>&#13;
				<li>Then, it recovers <a id="_idIndexMarker227"/>the address stored in the stack via <code>POP EBP</code>. This instruction <a id="_idIndexMarker228"/>does the following:<p>- It removes the latest value pushed onto the stack:</p><div><img src="img/B16207_06_003.jpg" alt="Figure 6.3 – The POP instruction removes the latest value pushed onto the stack&#13;&#10;"/></div><p class="figure-caption"> </p><p class="figure-caption">Figure 6.3 – The POP instruction removes the latest value pushed onto the stack</p><p>- It stores the value in the targeting register, <code>EBP</code> in this case:</p><div><img src="img/B16207_06_004.jpg" alt="Figure 6.4 – The POP instruction stores the removed stack value into the targeting EBP register&#13;&#10;"/></div><p class="figure-caption"> </p><p class="figure-caption">Figure 6.4 – The POP instruction stores the removed stack value into the targeting EBP register</p></li>&#13;
				<li>Finally, it subtracts <code>0x5</code> units from the <code>EBP</code> register to get the <code>EIP</code> value (which we had when executing the <code>CALL</code> instruction, not the current one) stored in <code>EBP</code>:<div><img src="img/B16207_06_005.jpg" alt="Figure 6.5 – The SUB instruction subtracts 5 units from the EBP register&#13;&#10;"/></div></li>&#13;
			</ol>&#13;
			<p class="figure-caption"> </p>&#13;
			<p class="figure-caption">Figure 6.5 – The SUB instruction subtracts 5 units from the EBP register</p>&#13;
			<p>By using this trick, the <a id="_idIndexMarker229"/>malware developer can refer to data values using the <code>EBP</code> register (the beginning of the shellcode) plus an offset to the mentioned data. By using this <a id="_idIndexMarker230"/>technique, the resulting code is position-independent; no matter in which position you place the shellcode, it will work anyway.</p>&#13;
			<p>You can check this in the following code fragment:</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B16207_06_006.jpg" alt="Figure 6.6 – Delta offset stored in the EBP register for position-independent code&#13;&#10;"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption"> </p>&#13;
			<p class="figure-caption">Figure 6.6 – Delta offset stored in the EBP register for position-independent code</p>&#13;
			<p>This trick is commonly known as <code>0x5e2</code> offset relative to the shellcode starting address:</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B16207_06_007.jpg" alt="Figure 6.7 – Storing the base address of the API hash table&#13;&#10;"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption"> </p>&#13;
			<p class="figure-caption">Figure 6.7 – Storing the base address of the API hash table</p>&#13;
			<p>After that, a function is responsible for replacing Kernel32 API function hashes with function directions, allowing you to call it from the program.</p>&#13;
			<p>Once the replacement is done, a lot of calls are done via offsets of this hash table, which is now converted into a table of API addresses:</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B16207_06_008.jpg" alt="Figure 6.8 – Calling resolved API functions via relative offsets&#13;&#10;"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption"> </p>&#13;
			<p class="figure-caption">Figure 6.8 – Calling resolved API functions via relative offsets</p>&#13;
			<p>As you can see, the <a id="_idIndexMarker231"/>disassembly shows <code>CALL</code> instructions pointing to <code>EBP</code> relative <a id="_idIndexMarker232"/>&#13;
offsets. It is much more preferable to see the callee function name instead. Improving the disassembly to show function names is our objective but, as a first step, in the next section, you will learn how API hashes are replaced with their corresponding API function addresses.</p>&#13;
			<h2 id="_idParaDest-98"><a id="_idTextAnchor118"/>Translating API hashes to addresses</h2>&#13;
			<p>The following <a id="_idIndexMarker233"/>function is responsible for replacing the hash of the functions with the corresponding address of the function:</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B16207_06_009.jpg" alt="Figure 6.9 – The function responsible for replacing the table of function hashes with addresses&#13;&#10;"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption">Figure 6.9 – The function responsible for replacing the table of function hashes with addresses</p>&#13;
			<p>The previous code <a id="_idIndexMarker234"/>iterates over each API name, extracted from the <code>AddressOfNames</code> section of the export table of the <code>kernel32.dll</code> library.</p>&#13;
			<p>It is easy to identify the mentioned functionality if you have some background in analyzing Portable Executable files because some offsets in the code are very striking. Let's see the correspondence between the offsets shown in the previous <code>apiHashesToApiAdresses</code> disassembly and Portable Executable format fields:</p>&#13;
			<ul>&#13;
				<li><code>0x3c</code> corresponds to the <code>e_lfanew</code> field, meaning the <strong class="bold">Relative Virtual Address</strong> (<strong class="bold">RVA</strong>) of the Portable Executable header.</li>&#13;
				<li><code>0x78</code> is the RVA to the export table.</li>&#13;
				<li><code>0x20</code> is the RVA of the name pointer table into the export table.</li>&#13;
				<li><code>0x1c</code> is the RVA of the address table into the export table.</li>&#13;
				<li><code>0x24</code> is the RVA of the ordinal table into the export table.</li>&#13;
				<li><code>0x18</code> is the RVA of the number of names, which is the maximum number of loop iterations.</li>&#13;
			</ul>&#13;
			<p>Lines <code>21</code> and <code>22</code> in <em class="italic">Figure 6.9</em> are the key part of the code for deobfuscation purposes. On these mentioned lines, for each character of the API, a series of logical operations is applied. This series of operations can be easily translated into Python, as shown in the following Python shell command listing:</p>&#13;
			<pre>&gt;&gt;&gt; apiname = "lstrlenW"</pre>&#13;
			<pre>&gt;&gt;&gt; hash = 0</pre>&#13;
			<pre>&gt;&gt;&gt; for c in apiname:</pre>&#13;
			<pre>...     hash = hash &lt;&lt; 7 &amp; 0xffffff00 | ( (0xFF&amp;(hash &lt;&lt; 7)) | (0xFF&amp;(hash &gt;&gt; 0x19)) ^ ord(c))</pre>&#13;
			<pre>...</pre>&#13;
			<pre>&gt;&gt;&gt; print(hex(hash))</pre>&#13;
			<pre>0x2d40b8f0L</pre>&#13;
			<p>Let me clarify <a id="_idIndexMarker235"/>these four Python commands:</p>&#13;
			<ol>&#13;
				<li value="1">We store the <code>lstrlenW</code> string in the <code>apiname</code> variable, as we want to compute its hash value. In this way, we are testing our Python code over a real <code>kernel32.dll</code> API name.</li>&#13;
				<li>We initialize the <code>hash</code> value to <code>0</code>. This is the first step of this hashing algorithm.</li>&#13;
				<li>We iterate over each character (variable <code>c</code>) of the <code>lstrlenW</code> string while updating the <code>hash</code> variable value according to the hashing algorithm.</li>&#13;
				<li>We finally print the hash value using hexadecimal notation. Please notice that the <code>L</code> character at the end of the hash value means long data type and it doesn't belong to the hash.</li>&#13;
			</ol>&#13;
			<p>Of course, the mentioned code can also be translated into Java:</p>&#13;
			<pre>class AlinaAPIHash {</pre>&#13;
			<pre>	public static void main(String args[]) {</pre>&#13;
			<pre>		int hash = 0;</pre>&#13;
			<pre>		String apiName = "lstrlenW";</pre>&#13;
			<pre>		for (int i=0; i&lt;apiName.length(); i++) {</pre>&#13;
			<pre>			hash = (hash &lt;&lt; 7 &amp;</pre>&#13;
			<pre>                        0xFFFFFF00 | hash &lt;&lt; 7 &amp;</pre>&#13;
			<pre>                        0xFF | hash &gt;&gt; 0x19 &amp;</pre>&#13;
			<pre>                        0xFF ^ apiName.charAt(i)</pre>&#13;
			<pre>                 );</pre>&#13;
			<pre>			System.out.println(String.format("0x%08X",</pre>&#13;
			<pre>                                                 hash)</pre>&#13;
			<pre>                 );</pre>&#13;
			<pre>		}</pre>&#13;
			<pre>		System.out.println(String.format("0x%08X", hash))</pre>&#13;
			<pre>	}</pre>&#13;
			<pre>}</pre>&#13;
			<p>In this section, you <a id="_idIndexMarker236"/>learned how API hashing works and how to translate the algorithm from assembly language into Python and Java. In the next section, we will use the mentioned code to resolve the names of the callee functions and put it into the disassembly listing. </p>&#13;
			<h2 id="_idParaDest-99"><a id="_idTextAnchor119"/>Deobfuscating the hash table using Ghidra scripting</h2>&#13;
			<p>Before <a id="_idIndexMarker237"/>automatically deobfuscating the program, we <a id="_idIndexMarker238"/>need the complete list of <code>Kernel32.dll</code>-exported API function names. You can find the following script (<code>get_kernel32_exports.py</code>) on the dedicated GitHub repository, which uses Python's <code>pefile</code> module for this purpose:</p>&#13;
			<pre>01 import pefile</pre>&#13;
			<pre>02 pe=pefile.PE("c:\windows\system32\kernel32.dll")</pre>&#13;
			<pre>03 exports=set()</pre>&#13;
			<pre>04 for exp in pe.DIRECTORY_ENTRY_EXPORT.symbols:</pre>&#13;
			<pre>05    exports.add(exp.name.encode('ascii'))</pre>&#13;
			<p>This listed code does the following:</p>&#13;
			<ol>&#13;
				<li value="1">Imports the <code>pefile</code> module, allowing it to parse in Portable Executable file format, the file format used in 32-bit and 64-bit versions of Microsoft Windows operating systems for executables, object code, DLLs, and others</li>&#13;
				<li>Stores in <code>pe</code> an instance of the parsed <code>Kernel32.dll</code> Portable Executable file</li>&#13;
				<li>Creates an empty set of <code>Kernel32.dll</code>-exported functions</li>&#13;
				<li>Iterates over the <code>Kernel32.dll</code>-exported functions</li>&#13;
				<li>Retrieves the name of the exported function (encoded using ASCII character codification) and adds it to the set of <strong class="bold">exports</strong>.</li>&#13;
			</ol>&#13;
			<p>The result <a id="_idIndexMarker239"/>produced by the previous script is a set containing the <a id="_idIndexMarker240"/>Kernel32 exports, as shown in the following partial output:</p>&#13;
			<pre>exports = set(['GetThreadPreferredUILanguages', 'ReleaseMutex', 'InterlockedPopEntrySList', 'AddVectoredContinueHandler', 'ClosePrivateNamespace', … ])</pre>&#13;
			<p>Finally, we can put all the pieces together in order to automate the task of resolving hashed Kernel32 API addresses:</p>&#13;
			<pre>01. from ghidra.program.model.symbol import SourceType</pre>&#13;
			<pre>02. from ghidra.program.model.address.Address import *</pre>&#13;
			<pre>03. from struct import pack</pre>&#13;
			<pre>04.</pre>&#13;
			<pre>05. exports = set(['GetThreadPreferredUILanguages', 'ReleaseMutex', 'InterlockedPopEntrySList', 'AddVectoredContinueHandler', 'ClosePrivateNamespace', 'SignalObjectAndWait', …])</pre>&#13;
			<pre>06. def getHash(provided_hash):</pre>&#13;
			<pre>07.     for apiname in exports:</pre>&#13;
			<pre>08.         hash = 0</pre>&#13;
			<pre>09.         for c in apiname:</pre>&#13;
			<pre>10.             hash = hash &lt;&lt; 7 &amp; 0xffffff00 | ( (0xFF&amp;(hash &lt;&lt; 7)) | (0xFF&amp;(hash &gt;&gt; 0x19)) ^ ord(c))</pre>&#13;
			<pre>11.             if(provided_hash==pack('&lt;L', hash)):</pre>&#13;
			<pre>12.                 return apiname</pre>&#13;
			<pre>13.     return ""</pre>&#13;
			<pre>14. fn = getFunctionAt(currentAddress)</pre>&#13;
			<pre>15. i = getInstructionAt(currentAddress)</pre>&#13;
			<pre>16. while getFunctionContaining(i.getAddress()) == fn:</pre>&#13;
			<pre>17.     nem = i.getMnemonicString()</pre>&#13;
			<pre>18.     if nem == "CALL":</pre>&#13;
			<pre>19.         target_address = i.getOpObjects(0)</pre>&#13;
			<pre>20.         if target_address[0].toString()=='EBP':</pre>&#13;
			<pre>21.             current_hash = bytes(pack('&lt;L', getInt(currentAddress.add(int(target_address[1].toString(),16)))))</pre>&#13;
			<pre>22.             current_function_from_hash = getHash(current_hash)</pre>&#13;
			<pre>23.             setEOLComment(i.getAddress(), current_function_from_hash)</pre>&#13;
			<pre>24.             print(i.getAddress().toString() + " " + nem + "[EBP + "+target_address[1].toString()+ "]" + " -&gt; " + current_function_from_hash)</pre>&#13;
			<pre>25.     i = i.getNext()</pre>&#13;
			<p>In summary, we <a id="_idIndexMarker241"/>are doing the <a id="_idIndexMarker242"/>following:</p>&#13;
			<ol>&#13;
				<li value="1">We are declaring the set of Kernel32 API names at line <code>05</code>.</li>&#13;
				<li>We are looking for matches with those API names for a provided hash at line <code>06</code>.</li>&#13;
				<li>We are traversing the function looking for obfuscated calls in lines <code>14</code> to <code>20</code>.</li>&#13;
				<li>Finally, we are setting a comment and printing the name of the function in lines <code>23</code> and <code>24</code>, respectively.</li>&#13;
			</ol>&#13;
			<p>The execution of the script produces the following changes in the disassembly listing (comments about the called functions):</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B16207_06_010.jpg" alt="Figure 6.10 – Comments generated by the script indicating the resolved Kernel32 API functions&#13;&#10;"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption"> </p>&#13;
			<p class="figure-caption">Figure 6.10 – Comments generated by the script indicating the resolved Kernel32 API functions</p>&#13;
			<p>Showing <a id="_idIndexMarker243"/>function names is better than nothing but it is <a id="_idIndexMarker244"/>much better to show symbols because they reference the function as well as showing the name. In the next section, you will see how to add this improvement.</p>&#13;
			<h2 id="_idParaDest-100"><a id="_idTextAnchor120"/>Improving the scripting results</h2>&#13;
			<p>You can also improve the <a id="_idIndexMarker245"/>result by adding the necessary Kernel32 symbols to it. For instance, you can look for the <code>CreateFileA</code> symbol in the <strong class="bold">Symbol Tree</strong> window:</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B16207_06_011.jpg" alt="Figure 6.11 – Looking for the CreateFileA symbol&#13;&#10;"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption"> </p>&#13;
			<p class="figure-caption">Figure 6.11 – Looking for the CreateFileA symbol</p>&#13;
			<p>Attach this symbol to the current program and access the function address by double-clicking on it:</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B16207_06_012.jpg" alt=""/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption"> </p>&#13;
			<p class="figure-caption">Figure 6.12 – Looking for the CreateFileA API address</p>&#13;
			<p>Then, patch the <code>CALL</code> instruction by <a id="_idIndexMarker246"/>using the <em class="italic">Ctrl</em> + <em class="italic">Shift</em> + <em class="italic">G</em> key combination:</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B16207_06_013.jpg" alt="Figure 6.13 – Editing a CALL instruction&#13;&#10;"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption"> </p>&#13;
			<p class="figure-caption">Figure 6.13 – Editing a CALL instruction</p>&#13;
			<p>Patch it with the <code>CreateFileA</code> address obtained before:</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B16207_06_014.jpg" alt="Figure 6.14 – Patching the CALL instruction with the target CreateFileA API address&#13;&#10;"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption"> </p>&#13;
			<p class="figure-caption">Figure 6.14 – Patching the CALL instruction with the target CreateFileA API address</p>&#13;
			<p>Press the <em class="italic">R</em> key and set this reference to <code>INDIRECTION</code>:</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B16207_06_015.jpg" alt="Figure 6.15 – Modifying the CALL address reference type to INDIRECTION&#13;&#10;"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption"> </p>&#13;
			<p class="figure-caption">Figure 6.15 – Modifying the CALL address reference type to INDIRECTION</p>&#13;
			<p>After this modification, the code is modified, allowing Ghidra to identify function parameters, identify references to the function, and so on when analyzing the code, which is always <a id="_idIndexMarker247"/>better than putting a comment. In the following screenshot, you can see the resulting disassembly listing:</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B16207_06_016.jpg" alt="Figure 6.16 – Disassembly listing using symbols instead of comments&#13;&#10;"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption">Figure 6.16 – Disassembly listing using symbols instead of comments</p>&#13;
			<p>As you can see, scripting can be very useful when analyzing malware because repetitive tasks such as string deobfuscation, resolving API addresses, code deobfuscation, and so on can be fully automated by writing a few, simple lines of code.</p>&#13;
			<p>In addition, the more scripts you write, the more efficient you will become, and the more code you can reuse for your future scripts and projects.</p>&#13;
			<h1 id="_idParaDest-101"><a id="_idTextAnchor121"/>Summary	</h1>&#13;
			<p>In this chapter, you learned how to use scripting to be more efficient when analyzing malware using Ghidra. We have used scripting to go beyond the limitations of static analysis and resolve some API function hashes that are calculated at runtime.</p>&#13;
			<p>You also learned the advantages and disadvantages of using Python or Java when developing a script.</p>&#13;
			<p>You learned how to translate assembly language algorithms into Java and Python, and also learned skills in scripting while developing your first extremely useful script. By using the provided Ghidra Flat API function classification, you are now able to quickly identify Ghidra API functions required by your own scripts without needing to remember or waste time looking for a function in the documentation.</p>&#13;
			<p>In the next chapter of this book, we will cover Ghidra headless mode, which can be very useful in some situations, such as performing analysis of a huge amount of binaries or using Ghidra alone to integrate it with other tools.</p>&#13;
			<h1 id="_idParaDest-102"><a id="_idTextAnchor122"/>Questions </h1>&#13;
			<ol>&#13;
				<li value="1">Given a memory address, what Ghidra Flat API allows you to set the byte located at the given memory address? Describe the steps you followed when looking for this function.</li>&#13;
				<li>What is the programming language that is best supported by Ghidra and how does Ghidra support Python?</li>&#13;
				<li>Is it possible to statically analyze things that are resolved at runtime?</li>&#13;
			</ol>&#13;
			<h1 id="_idParaDest-103"><a id="_idTextAnchor123"/>Further reading</h1>&#13;
			<p>You can refer to the following links for more information on the topics covered in this chapter:</p>&#13;
			<ul>&#13;
				<li>Ghidra scripting course: <a href="https://ghidra.re/courses/GhidraClass/Intermediate/Scripting_withNotes.html#Scripting.html">https://ghidra.re/courses/GhidraClass/Intermediate/Scripting_withNotes.html#Scripting.html</a></li>&#13;
				<li><em class="italic">Java Fundamentals</em>, <em class="italic">Gazihan Alankus, Rogério Theodoro de Brito, Basheer Ahamed Fazal et al.</em>, <em class="italic">March 2019</em>:<em class="italic"> </em><a href="https://www.packtpub.com/eu/application-development/java-fundamentals">https://www.packtpub.com/eu/application-development/java-fundamentals</a></li>&#13;
				<li><em class="italic">Python Automation Cookbook</em>, <em class="italic">Jaime Buelta</em>, <em class="italic">May 2020</em>: <a href="https://www.packtpub.com/eu/programming/python-automation-cookbook-second-edition">https://www.packtpub.com/eu/programming/python-automation-cookbook-second-edition</a></li>&#13;
			</ul>&#13;
		</div>&#13;
	</div></body></html>