<html><head></head><body>
		<div><h1 id="_idParaDest-100" class="chapter-number"><a id="_idTextAnchor102"/>6</h1>
			<h1 id="_idParaDest-101"><a id="_idTextAnchor103"/>Error Handling and Exception Testing</h1>
			<p>In the previous chapter, you were introduced to the art of injecting code into legitimate input fields for API endpoints. Some of these types of threats use old techniques but they are still quite prevalent. One of them consists of fuzzing the text that will be injected. This may cause the target endpoint to misbehave simply because it was not prepared to receive unusual or bizarre input texts. This happens because the API endpoint is not correctly handling errors or the code implementing it is not treating eventual exceptions.</p>
			<p>Therefore, it is very important for API and application owners that both errors and exceptions are correctly tested and handled. And of course, you, as a pentester, cannot forget to add this to your testing notebook. Not only may vulnerabilities arise from bad error or exception handling. Valuable details on the infrastructure, such as frameworks, libraries, third-party software, operating system (including the kernel) version, and build number can be disclosed by an exception or an unforeseen error.</p>
			<p>We’ll begin this chapter by talking about some general error codes and messages and how you can easily identify them. Next, we will dive into fuzzing and how this can trigger some hidden vulnerabilities. Finally, we’ll learn how to leverage our research efforts to reveal the data we are looking for.</p>
			<p>In this chapter, we’re going to cover the following main topics:</p>
			<ul>
				<li>Identifying error codes and messages</li>
				<li>Fuzzing for exception handling vulnerabilities</li>
				<li>Leveraging error responses for information disclosure</li>
			</ul>
			<h1 id="_idParaDest-102"><a id="_idTextAnchor104"/>Technical requirements</h1>
			<p>As we did for <a href="B19657_05.xhtml#_idTextAnchor078"><em class="italic">Chapter 5</em></a>, we’ll leverage the same environment as the one pointed out in previous chapters. So, you’ll need a type 2 hypervisor, such as VirtualBox, and some Linux distribution, such as Ubuntu. Some other new relevant utilities will be mentioned in the corresponding sections.</p>
			<h1 id="_idParaDest-103"><a id="_idTextAnchor105"/>Identifying error codes and messages</h1>
			<p>In this section, we are going to learn<a id="_idIndexMarker484"/> about error codes and messages that can be provided by API endpoints when they are answering your requests. Error codes and messages are the cornerstones of effective API penetration testing. They act as a window into the API’s communication channels, revealing how they inform clients and users about issues encountered during request processing. By deciphering these messages, you can assess the strength and security of the API’s error-handling mechanisms. Scrutinizing error responses can expose potential security vulnerabilities such as information leaks, injection attacks, or weak input validation.</p>
			<p>One obvious approach to uncover error codes and messages is by checking the API documentation. In <a href="B19657_03.xhtml#_idTextAnchor042"><em class="italic">Chapter 3</em></a>, you learned about the importance of this stage of pentesting. Another approach is manual testing. Here, pentesters craft requests with deliberately malformed data or incorrect inputs, observing the resulting error responses. Analyzing the structure and content of these responses provides insights into how the API handles various error scenarios. For instance, sending a request with an invalid authentication token might trigger a <em class="italic">401 Unauthorized</em> response, signifying a failed authentication attempt. Manually inspecting such responses can unveil valuable information about the API’s security posture.</p>
			<p>Automated testing tools, such as Burp Suite and OWASP ZAP, are powerful allies in identifying error codes and messages. These tools can capture API requests and responses, enabling systematic analysis of error messages. By automating the process of sending requests with diverse payloads and inputs, you can efficiently identify potential vulnerabilities in the API’s error-handling mechanism. For example, Burp Suite’s <strong class="bold">Intruder</strong> tool can be used to send multiple requests<a id="_idIndexMarker485"/> with varying parameters, while its proxy feature allows for real-time capture and analysis of error responses. We’ve used both.</p>
			<p>Beyond the conventional HTTP status codes, error messages often include additional details, such as error codes, descriptions, or even stack traces. These details offer valuable insights into the nature and root cause of the error, facilitating further investigation and exploitation (from an ethical pentesting perspective, of course). You should keep a keen eye on these details as they may reveal vulnerabilities or misconfigurations within the API. An error message containing a stack trace, for instance, might expose sensitive information about the underlying infrastructure, such as server paths or database queries. Analyzing such information can help you identify potential attack vectors and assess the severity of the vulnerability.</p>
			<p>Furthermore, you can leverage parameter manipulation techniques to evoke specific error responses from the API. By modifying request parameters such as input data or HTTP headers, they can trigger different error scenarios and observe the API’s response. This approach allows you to systematically test the API’s error-handling capabilities and identify potential security weaknesses. For instance, sending requests with excessively large payloads or malformed data might cause the API to return error responses indicating input validation failures or buffer overflows.</p>
			<p>The consistency and predictability of error responses across different endpoints and input variations are crucial aspects of identifying error codes and messages. You can examine how the API handles errors under various conditions, such as different authentication states, input formats, or request methods. Consistent error handling is essential for ensuring the reliability and security of the API. Inconsistent or unpredictable error responses may indicate underlying vulnerabilities or implementation flaws that you could exploit.</p>
			<p>Let’s look at a practical example to illustrate<a id="_idIndexMarker486"/> the process of identifying error codes and messages. Imagine an API endpoint for user authentication that accepts username and password parameters via a POST request. We can send a request to this endpoint with invalid credentials and observe the resulting error response. Here’s an example request and response (command in a single line):</p>
			<pre class="console">
curl -X POST -H "Content-Type: application/json" -d \
'{"username": "admin", "password": "some invalid password"}' \
http://localhost:5000/api/authenticate</pre>			<p>A possible answer could be as follows:</p>
			<pre class="console">
{
  "error": {
    "message": "Invalid credentials",
    "code": 401,
    "details": "Authentication failed"
  }
}</pre>			<p>You receive not only an error code but also a message and more details. Let’s check out another type of error message that could reveal some more of this hypothetical API endpoint’s logic. We will try to log<a id="_idIndexMarker487"/> in with some generic user ID:</p>
			<pre class="console">
curl -X GET http://localhost:5000/api/user?id=abc123</pre>			<p>The endpoint returns the following:</p>
			<pre class="console">
{
  "error": {
    "message": "Invalid parameter: id must be a numeric value",
    "code": 400,
    "details": "Invalid input"
  }
}</pre>			<p>Now, you know that only numeric values are accepted as user IDs. This tremendously reduces the search scope of a user enumeration task. Likewise, you can try to look for other error codes by using other API endpoints or HTTP verbs. As an exercise, the relevant dummy code implements an API with some endpoints and error messages. It can be found at <a href="https://github.com/PacktPublishing/Pentesting-APIs/blob/main/chapters/chapter06/identify_error_codes.py">https://github.com/PacktPublishing/Pentesting-APIs/blob/main/chapters/chapter06/identify_error_codes.py</a>.</p>
			<p>A Flask application listens on port TCP <code>5000</code> by default. You can change it by using the <code>port=</code> parameter as part of the <code>app.run</code> method. Let’s see how it works by running some <code>curl</code> commands:</p>
			<pre class="console">
curl -X GET http://localhost:5000/api/user/1
{
  "email": "john.doe@example.com",
  "id": 1,
  "name": "John Doe"
}</pre>			<p>This is quite straightforward. No surprises there! Now, let’s verify how the endpoint behaves when we provide a nonexistent user:</p>
			<pre class="console">
curl -X GET http://localhost:5000/api/user/2
{
  "error": {
    "code": 404,
    "message": "User not found"
  }
}</pre>			<p>OK; that’s part of the application<a id="_idIndexMarker488"/> code too. What if we send something unexpected?</p>
			<pre class="console">
curl -X GET http://localhost:5000/api/user/aksfljdf\!\#\$\!\#\$\!\#224534
&lt;!doctype html&gt;
&lt;html lang=en&gt;
&lt;title&gt;404 Not Found&lt;/title&gt;
&lt;h1&gt;Not Found&lt;/h1&gt;
&lt;p&gt;The requested URL was not found on the server. If you entered the URL manually please check your spelling and try again.&lt;/p&gt;</pre>			<p>This was directly answered by Flask (not the code I wrote) since it didn’t find any <code>user</code> endpoint that accepts a string as input. This is a well-known error message among Python applications and modules that make use<a id="_idIndexMarker489"/> of the Werkzeug module, a library that implements a <strong class="bold">Web Server Gateway Interface</strong> (<strong class="bold">WSGI</strong>). At least the message reveals that this API uses Python as its backend. In a real-world scenario, we would have had a fingerprinting win!</p>
			<p>Moving forward, let’s try the other endpoints by causing a predicted error:</p>
			<pre class="console">
curl -X POST -H "Content-Type: application/json" -d '{"name": \ "Alice"}' http://localhost:5000/api/user/create
{
  "error": {
    "code": 400,
    "message": "Bad Request: Name and email are required"
  }
}</pre>			<p>You’ll receive this message should<a id="_idIndexMarker490"/> you forget to provide a name, email, or both. But in the case of this code, even if you send all parameters as expected, the application will throw an exception to show you how this can be revealing:</p>
			<pre class="console">
curl -X POST -H "Content-Type: application/json" -d '{"name": "Alice", \
"email": "alice@example.com"}' http://localhost:5000/api/user/create</pre>			<p>This is what we received as output:</p>
			<pre class="source-code">
&lt;!doctype html&gt;
...
&lt;output omitted for brevity&gt;
...
&lt;h1&gt;Exception&lt;/h1&gt;
...
&lt;output omitted for brevity&gt;
...
Traceback (most recent call last):
  File "/apitest/lib/python3.10/site-packages/flask/app.py", line 1488, in __call__
    return self.wsgi_app(environ, start_response)
  File "/apitest/lib/python3.10/site-packages/flask/app.py", line 1466, in wsgi_app
    response = self.handle_exception(e)
  File "/apitest/lib/python3.10/site-packages/flask/app.py", line 1463, in wsgi_app
    response = self.full_dispatch_request()
  File "/apitest/lib/python3.10/site-packages/flask/app.py", line 872, in full_dispatch_request
    rv = self.handle_user_exception(e)
  File "/apitest/lib/python3.10/site-packages/flask/app.py", line 870, in full_dispatch_request
    rv = self.dispatch_request()
  File "/apitest/lib/python3.10/site-packages/flask/app.py", line 855, in dispatch_request
    return self.ensure_sync(self.view_functions[rule.endpoint])(**view_args)  # type: ignore[no-any-return]
  File "/home/mauricio/Downloads/api_error_messages.py", line 22, in create_user
    raise Exception("Internal Server Error: Failed to create user")
Exception: Internal Server Error: Failed to create user</pre>			<p>See how dangerous badly treated<a id="_idIndexMarker491"/> exceptions can be? You have not only discovered that the endpoint uses Python behind the scenes but also part of the directory structure, including the Python version being used. The other endpoints will throw analogous messages. In the next section, we will play with fuzzing.</p>
			<h1 id="_idParaDest-104"><a id="_idTextAnchor106"/>Fuzzing for exception handling vulnerabilities</h1>
			<p>In <a href="B19657_04.xhtml#_idTextAnchor056"><em class="italic">Chapter 4</em></a>, you quickly experimented<a id="_idIndexMarker492"/> with fuzzing by taking part in the exercises that we conducted with Burp Suite. Now, we are going to dive deeper into this technique. Fuzzing is very important in the context of API pentesting since it can expose an application’s vulnerabilities and weaknesses when incorrectly handling unexpected input. The types of vulnerabilities that can be raised from such bad handling<a id="_idIndexMarker493"/> may vary from information disclosure to <strong class="bold">denial-of-service</strong> (<strong class="bold">DoS</strong>).</p>
			<p>A popular approach to fuzzing for exception handling vulnerabilities<a id="_idIndexMarker494"/> involves utilizing automated tools such as <strong class="bold">American Fuzzy Lop</strong> (<strong class="bold">AFL</strong>). AFL, created by Michal Zalewski and nowadays maintained by Google, is very good at creating random patterns to provide as input when testing API endpoints or apps. It operates by repeatedly modifying input files and monitoring the target application for crashes or unusual behavior. There are some good fuzzers out there you could leverage to fuzz API endpoints by bombarding them with requests containing malformed data, unexpected parameter values, or even specially crafted HTTP headers.</p>
			<p>For instance, imagine an API endpoint that processes JSON payloads for user authentication. A fuzzing test involves generating a series of malformed JSON payloads. These payloads could contain missing or invalid key-value pairs, excessively large sizes, or unexpected data types. By observing the API’s response to these inputs, you can identify potential exception-handling vulnerabilities, such as crashes, memory leaks, or unexpected behavior.</p>
			<p>AFL’s strength lies in its feedback-driven approach, making it particularly adept at identifying exception-handling vulnerabilities. As the tool discovers new inputs that trigger unique paths or behaviors within the target application, it prioritizes mutating those inputs to delve deeper into the application’s code base. This iterative process helps uncover subtle vulnerabilities that manual testing alone might miss.</p>
			<p>Another approach to fuzzing for exception-handling vulnerabilities involves meticulously mutating specific input parameters or request attributes. For instance, you might strategically inject special characters, boundary values, or unexpected data types into input fields to trigger exceptions or errors within the API’s processing logic. By meticulously crafting input payloads to target specific code paths or error-handling mechanisms, you can uncover vulnerabilities that might otherwise remain hidden.</p>
			<p>Open source fuzzing frameworks such as Sulley and Radamsa offer additional options for targeted fuzzing of API endpoints. These frameworks provide tools and libraries for generating and mutating input data, along with mechanisms for monitoring and analyzing the target application’s responses. By tailoring fuzzing campaigns to focus on specific input parameters or request attributes, you can efficiently pinpoint exception-handling vulnerabilities and assess their impact on the API’s security posture.</p>
			<p>Although AFL is quite versatile and powerful, I faced some trouble while compiling it to run on non-Intel chips. This scenario<a id="_idIndexMarker495"/> is supported, but you need to either apply <strong class="bold">Low-Level Virtual Machine</strong> (<strong class="bold">LLVM</strong>) or <strong class="bold">Quick Emulator</strong> (<strong class="bold">QEMU</strong>), two widely used hardware<a id="_idIndexMarker496"/> emulators, to be able to run it on ARM, for example. Sulley, in turn, stopped being maintained. A new project was raised in its place – Boofuzz. It seems promising and has good quickstart examples. However, Radamsa was easy to compile and install even on OSs backed by non-Intel chips. Many of the fuzzers require you to apply the change to the application’s code, which is not exactly what we are looking for. We want to understand how a generic API endpoint behaves when it needs to process random/unexpected input. Finally, <strong class="bold">Fuzz Faster U Fool</strong> (<strong class="bold">FFUF</strong>) is a quick web fuzzer written<a id="_idIndexMarker497"/> in Golang. Its installation is quite simple, besides the fact it can work in combination with other fuzzers, such as Radamsa. The point is that the majority of these fuzzers are good for sending fuzzed data, not <strong class="bold">files</strong>. Therefore, we will do things differently. Here, we will combine a mutator with custom code. We can handle response status codes and show just what we want.</p>
			<p>Hence, for our practical<a id="_idIndexMarker498"/> exercise, we will explore making requests with fuzzed data provided by Radamsa to illustrate the process of fuzzing for exception-handling vulnerabilities. We can leverage the same code that we’ve already shared but with at least one more endpoint. This new endpoint will accept and process CSV files to update user information. A fuzzing test like this might involve generating a series of malformed CSV files with unexpected column headers, delimiter characters, or row formats. By observing the API’s response to these inputs, you can cause potential vulnerabilities in its CSV parsing and exception-handling logic.</p>
			<p>The relevant code, which has been written to be vulnerable, could look something like this:</p>
			<pre class="source-code">
import csv
from io import StringIO
@app.route('/api/upload/csv', methods=['POST'])
def upload_csv():
    # Check if file is present in request
    if 'file' not in request.files:
        return jsonify(
          {'error': {
             'message': 'Bad Request: No file part',
             'code': 401}}), 401
    file = request.files['file']
    # Validate file extension
    if file.filename.split('.')[-1].lower() != 'csv':
        return jsonify({'error': {
            'message': 'Bad Request: Only CSV files are allowed',
            'code': 403}}), 403
    # Read and process the uploaded CSV file
    try:
        csv_data = StringIO(file.stream.read().decode("UTF8"),
            newline=None)
        # Potential for infinite recursion (missing argument)
        csv_reader = csv.reader(csv_data)
        # Vulnerable to large data sets (memory exhaustion or crashes)
        header = next(csv_reader)
        # Converting to list reads entire data at once
        data_rows = list(csv_reader)
        num_rows = len(data_rows)
        num_cols = len(header)
        return jsonify({
            'message': 'CSV file uploaded successfully',
            'header': header,
            'data_rows': data_rows,
            'num_rows': num_rows,
            'num_cols': num_cols
        }), 200
    except Exception as e:
        return jsonify({'error': {
        'message': f'Error processing CSV file: {str(e)}',
        'code': 500}}), 500</pre>			<p>This code is located at <a href="https://github.com/PacktPublishing/Pentesting-APIs/blob/main/chapters/chapter06/vulnerable_code_to_fuzz.py">https://github.com/PacktPublishing/Pentesting-APIs/blob/main/chapters/chapter06/vulnerable_code_to_fuzz.py</a>.</p>
			<p>Take the following files<a id="_idIndexMarker499"/> as two legitimate inputs for the <code>upload_csv()</code> endpoint:</p>
			<div><div><img src="img/B19657_06_01.jpg" alt="Figure 6.1 – The first CSV file containing legitimate data"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.1 – The first CSV file containing legitimate data</p>
			<p>The following figure shows the second CSV file that contains legitimate data:</p>
			<div><div><img src="img/B19657_06_02.jpg" alt="Figure 6.2 – The second CSV file containing legitimate data"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.2 – The second CSV file containing legitimate data</p>
			<p>The first step is to generate (fuzzed) data<a id="_idIndexMarker500"/> based on these files. With the help of Radamsa, we can quickly create thousands of fuzzed CSV files. There is a fair number of websites that can generate random data and files based on some parameters. I’ve put one of them in the <em class="italic">Further reading</em> section. You can create the fuzzed files with the following command:</p>
			<pre class="console">
radamsa -n 1000 -o %n.csv csvfile1.csv csvfile2.txt</pre>			<p>Filenames begin with <code>1.csv</code> and go up to <code>1000.csv</code>. Any data inside the original files (<code>csvfile1.csv</code> and <code>csvfile2.csv</code>) is subject to be fuzzed. So, you may expect fuzzed CSV files to have weird headers, such as <code>email4294967297</code>, negative IDs, or strange email addresses. That’s exactly the intention here. The custom script code follows. Observe that we are only filtering response codes different from <code>200</code>. When this happens, we repeat the request to display the exact API endpoint’s output:</p>
			<pre class="source-code">
#!/bin/bash
url=http://localhost:5000/api/upload/csv
for filename in ./*csv; do
    # Getting response code
    r_code=$(curl -s -o /dev/null -w "%{http_code}" -X POST -F \
             "file=@$filename" $url)
    if [ $r_code != 200 ]; then
         echo "Damaging file: `basename $filename`"
         # Making the complete request
         curl -X POST -F "file=@$filename" $url
         echo
    fi
done</pre>			<p>In my case, the code spotted two errors<a id="_idIndexMarker501"/> out of 1,000 attempts, which means only a 2% success. However, even less than 1% can do the trick. Let’s see what made the endpoint crazy:</p>
			<div><div><img src="img/B19657_06_03.jpg" alt="Figure 6.3 – API endpoint throwing error messages with “500” error codes"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.3 – API endpoint throwing error messages with “500” error codes</p>
			<p>Now, let’s have a quick look at what the <code>379.csv</code> file looks like. Observe the badly formatted header, which has been built like this on purpose:</p>
			<pre class="console">
id; firstnane;lastnane ;enatt; enat12 ;professton
110;Rubie;Wittie;Rubie.Hittie@yopmail.con;Rubie.Wittie@gnail.con;firefighter
111;Sindee;Fredi;Sindee.Fredi@yopmail.con;Sindee.Frediggnail.con;police officer
113; Joane;Freddi; Joane.Freddi@yopmail.com;Joane.Freddi@gnatl.con;worker
se:cavlene: Eno: cavlene, Enorvoomal, con: cavene, Enocamal, con:ti rer ahren
115; Sonnt;Argus; Sonnt.Argus@yopmatl.con;Sonnt.Argus@gmall.con;ftreftghter
117;Thalla;Urtas;Thalla.Urtas@yopmall.con;Thalla.Urtas@gnall.con;ftrefighter
118;Glustina;Libna;Glustina.Libnadyopnail.com;Gtustina.Libnaggnatl.com;worker
105; Deedee; Keelta; Deedee.Keelta@yopnatl.con; Deedee. Keeltaagnatl.com; doctor
10b.ressa.vorscertressa.vorscertyophou.con.tressa.vorscerdonas.com, docton
107; MagdaLena;Madox; MagdaLena.Madox@yopnall.con;MagdaLena.Madox@gnatl.com;doctor
109;Charlena:Ophelia;Charlena.Ophematl.con;orkerlena;0phelta;Charlena.Ophenall.com;korkerlena;0phelta;Charlena.Ophenatt.com;workerlena;0phelta;Charlena.0ph
enaul.con; worker Lena, 0phetta;Char Lena. DphenatL.con;worker Lena; OpheLta;Char Lena.OphenatL.con;worker Lena;ophe Lia; char Lena.OphemaL. Con; worker Lena; opheLLa; chat
lena.Ophenai1.com;workerlena;0phelia;CharLena.Ophemail.con;orkerlena;0phelia;Charlena.0phemail.con;korkerlena;0phelia;Charlena.Ophenatl.com;workerlena;0phe
Lta;Charlena.ophenail.con;orkerlena;ophelta;Charlena.Ophenatl.com;workerlena;ophelia;Charlena.Ophenail.com;workerlena;0phelio;Charlena.Opherail.com;workert
ena;0phelta;Charlena.Ophenatl.com;worker</pre>			<p>The fuzzed <code>554.csv</code> file looks<a id="_idIndexMarker502"/> similar:</p>
			<pre class="console">
1d;ftrstname; lastnane;ematl/enat12;professton
100; Eadte; Angelts;Eadte.Angel1s@yopnatl.com;Eadte.Angelts@gmatl.con;doctor 101;Chastity;Harday;Chastity.Harday@yopmatl.con;Chasttty.Harday@gnatt.com;ftreftghter
102;Angela;L1a;Angela.Lta@yopmatl.com;Angela.Lta@gnatl.com;developer
103;Paola;Audly;Paola.Audly@yopnatl.com;Paola.Audly@gnatl.com;ftrefighter
104;Audrie;Yorick;Audrie.Yorick@yopnatl.com;Audrie.Yorick@gmail.con;doctor
105;Deedee;Keelta;Deedee.Keeltaßyopnatl.com;Deedee-Keelta@gmail.com;doctor
106;Magdalena;Madox;Magdalena.Madox@yopmatl.con;Magdalena.Madox@gnatl.com; doctor
108:pertoroan:Periorgan.voonal.com:pertorgansonat,con:frertanter</pre>			<p>Observe that both input files have broken<a id="_idIndexMarker503"/> CSV structures. These could cause unexpected processing logic on the target API endpoint. What if, instead of 1,000 attempts, we submitted 5,000 requests? Maybe this could result in something naughty happening with the target. Delete all the fuzzed CSV files Radamsa created previously and repeat the same <code>radamsa</code> command, replacing <code>1000</code> with <code>5000</code>. The partial output of this is shown here:</p>
			<pre class="console">
Damaging file: 1006.csv
{
  "error": {
    "code": 500,
    "message": "Error processing CSV file: 'utf-8' codec can't decode bute oxff in
                position 802: Invalld start bvte"
  }
}
Damaging Tile: 102.csv
{
  "error": {
    "code": 500,
    "message": "Error processing CSV file: 'utf-8' codec can't decode byte Oxf4 in
                position 794: invalid continuation bvte"
  }
}</pre>			<p>In my case, this new set of files resulted in 41 errors, which represents less than 1% of the hit rate. OK, it didn’t work out as expected, but this doesn’t mean we’ve done it wrongly. As previously mentioned, you must have patience while dealing with fuzzing. You can combine techniques and tools to get different artifacts and try them against your targets. You can also generate files with more rows and columns. Sooner or later, you will eventually achieve success<a id="_idIndexMarker504"/> and cause a failure on the endpoint.</p>
			<p>In the next section, we are going to understand what we can discover based on the error messages an API endpoint throws when answering requests.</p>
			<h1 id="_idParaDest-105"><a id="_idTextAnchor107"/>Leveraging error responses for information disclosure</h1>
			<p>Cool! So, you’ve learned<a id="_idIndexMarker505"/> how to identify error codes and messages<a id="_idIndexMarker506"/> and you’ve practiced this with a generic API endpoint. It’s now time for you to learn what you can do with the answers you will receive from the requests you are making toward such endpoints. They can be quite revealing. And sometimes, we don’t even need to send pernicious payloads to cause them to fail. Sysadmins and developers may change configurations or parameters based on changes or new application releases, and the new scenarios can cause the API to stop working.</p>
			<p>You will see a couple of generic figures in the following sections that show real web applications’ error messages. Observe that in at least one of them, the application simply discloses the versions of both .NET Framework and ASP.NET. This is embarrassing. In this specific case, some changes to a <code>web.config</code> file could suppress that specific line. Likewise, lacking a <strong class="bold">web application firewall</strong> (<strong class="bold">WAF</strong>) can leave room for releasing more revealing<a id="_idIndexMarker507"/> error messages. WAFs can either filter<a id="_idIndexMarker508"/> those messages<a id="_idIndexMarker509"/> or provide less verbose ones. <em class="italic">Figure 6</em><em class="italic">.4</em> shows a .NET failure:</p>
			<div><div><img src="img/B19657_06_04.jpg" alt="Figure 6.4 – Error message from a .NET web application (Source: Code Aperture)"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.4 – Error message from a .NET web application (Source: Code Aperture)</p>
			<p><em class="italic">Figure 6</em><em class="italic">.5</em> shows a default Microsoft IIS error page:</p>
			<div><div><img src="img/B19657_06_05.jpg" alt="Figure 6.5 – Microsoft IIS error page (Source: Microsoft)"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.5 – Microsoft IIS error page (Source: Microsoft)</p>
			<p>At the beginning of this chapter, we made some tests with an API endpoint that was using Flask, which, in turn, was leveraging Werkzeug. During a simple test, we received an error message that revealed that information. We could then look for vulnerabilities involving those components and craft special payloads<a id="_idIndexMarker510"/> to exploit<a id="_idIndexMarker511"/> them. Quite straightforward.</p>
			<p>There are some points you should pay attention<a id="_idIndexMarker512"/> to when analyzing error messages thrown by API endpoints:</p>
			<ul>
				<li><code>/admin/users</code>, might return a 404 status code with a reason phrase such as <code>No route found for /admin/users</code>. This suggests the existence of an <code>admin</code> directory or a user management functionality within the API. You could use FFUF to recursively fuzz all endpoints under <code>/</code>.</p></li>
				<li><code>java.lang.RuntimeException: Unsupported file format at com.example.api.UploadController.processFile(UploadController.java:123)</code>. This exposes the use of Java and reveals the location of the function handling file processing within the application code.</p></li>
				<li><code>1003</code> due to an unauthorized attempt to update a user’s role. This code could hint at the existence of different permission levels or specific functionalities being mapped to these codes.</p></li>
				<li><strong class="bold">Automated tools</strong>: Several utilities can assist in parsing and analyzing error responses. We’ve played with some of them, such as OWASP ZAP and Burp Suite. In terms of fuzzing, we just used Radamsa to mutate CSV files and crafted a custom script to leverage them to test an API endpoint.<p class="list-inset">Using Burp Suite’s Intruder tool, you can fuzz parameter values within an API request and monitor the returned error messages. By analyzing patterns or specific details revealed in the error responses for different fuzzed inputs, they can potentially identify information disclosure vulnerabilities. We’ve done this for JWTs too.</p></li>
				<li><strong class="bold">Combining techniques</strong>: The effectiveness of leveraging error responses is often amplified when combined with other pentesting techniques. Fuzzing techniques, as demonstrated earlier, can be used to generate unexpected inputs, and trigger informative error messages. Additionally, manually analyzing the application behavior<a id="_idIndexMarker513"/> and code (should you have access to it) can provide valuable context for interpreting the information disclosed in error responses.</li>
			</ul>
			<p>As general best practice advice, API developers can take several steps to mitigate the risk of information disclosure<a id="_idIndexMarker514"/> through error responses. Generic error messages with minimal technical details<a id="_idIndexMarker515"/> are a good first step. Additionally, proper configuration of logging and error handling mechanisms can prevent sensitive information from being included in error responses that reach external users. For example, avoid raising the programming language exception as a last resort. You, as a developer, completely lose control when doing that. Instead, try to map as many exceptions as possible and as a last resort, send a generic error message.</p>
			<p>Talking about logs, be sure to protect the access to them. Do not solely rely on the OS’s security mechanisms, such as filesystem permissions. A good approach is to have at least one copy of them elsewhere, such as a secondary data center or even a public cloud provider, and encrypt them at rest with a strong algorithm<a id="_idIndexMarker516"/> that applies a reasonable key length. Consider keys<a id="_idIndexMarker517"/> with at least 256 bits.</p>
			<h1 id="_idParaDest-106"><a id="_idTextAnchor108"/>Summary</h1>
			<p>In this practical chapter, we looked at how error messages that are thrown by API endpoints when handling requests can be useful not only to reveal information about their environment and configurations (data leakage) but also to cause more damage, such as DoS attacks (when the endpoint can’t heal itself after receiving an aggressive payload). We got our hands dirty with mutation and fuzzing and leveraged them in an exercise to bomb an API endpoint with bizarre data.</p>
			<p>In the next chapter, we will get knee-deep in terms of DoS attacks and rate-limiting testing. Some APIs are protected by control mechanisms that reduce the number of requests a client can set at once. However, there are some techniques we can leverage to increase the chances of a successful attack.</p>
			<h1 id="_idParaDest-107"><a id="_idTextAnchor109"/>Further reading</h1>
			<p>To learn more about the topics that were covered in this chapter, take a look at the following resources:</p>
			<ul>
				<li>The Werkzeug code implementing the Flask “not found” error message: <a href="https://github.com/pallets/werkzeug/blob/main/src/werkzeug/exceptions.py#L345C1-L348C6">https://github.com/pallets/werkzeug/blob/main/src/werkzeug/exceptions.py#L345C1-L348C6</a></li>
				<li>More information about WSGI: <a href="https://wsgi.readthedocs.io/en/latest/">https://wsgi.readthedocs.io/en/latest/</a></li>
				<li>American Fuzzy Lop, a widely used fuzzer for various types of applications: <a href="https://github.com/google/AFL">https://github.com/google/AFL</a></li>
				<li>What is LLVM?: <a href="https://llvm.org/">https://llvm.org/</a></li>
				<li>QEMU: <a href="https://www.qemu.org/">https://www.qemu.org/</a></li>
				<li>Sulley – Fuzz Testing Framework: <a href="https://github.com/OpenRCE/sulley">https://github.com/OpenRCE/sulley</a></li>
				<li>Boofuzz – Sulley’s replacement: <a href="https://github.com/jtpereyda/boofuzz">https://github.com/jtpereyda/boofuzz</a></li>
				<li>Radamsa – a very good command-line fuzzer: <a href="https://gitlab.com/akihe/radamsa">https://gitlab.com/akihe/radamsa</a></li>
				<li>A free Burp extension for Radamsa: <a href="https://github.com/ikkisoft/bradamsa">https://github.com/ikkisoft/bradamsa</a></li>
				<li>FFUF – a fast web fuzzer written in Golang: <a href="https://github.com/ffuf/ffuf">https://github.com/ffuf/ffuf</a></li>
				<li>Generate random files: <a href="https://extendsclass.com/csv-generator.html">https://extendsclass.com/csv-generator.html</a></li>
			</ul>
		</div>
	</body></html>