<html><head></head><body>
		<div><h1 id="_idParaDest-119" class="chapter-number"><a id="_idTextAnchor238"/>4</h1>
			<h1 id="_idParaDest-120"><a id="_idTextAnchor239"/><a id="_idTextAnchor240"/><a id="_idTextAnchor241"/>Unpacking, Decryption, and Deobfuscation</h1>
			<p>In this chapter, we are going to explore different techniques that have been introduced by malware authors to bypass antivirus software static signatures and trick inexperienced reverse engineers. These are mainly, packing, encryption, and obfuscation. We will learn how to identify packed samples, how to unpack them, how to deal with different encryption algorithms – from simple ones, such as sliding key encryption, to more complex algorithms, such as 3DES, AES, and RSA – and how to deal with API encryption, string encryption, and network traffic encryption.</p>
			<p>This chapter will help you deal with malware that uses packing and encryption to evade detection and hinder reverse engineering. With the information in this chapter, you will be able to manually unpack malware samples with custom types of packers, understand the malware encryption algorithms that are needed to decrypt its code, strings, APIs, or network traffic, and extract its infiltrated data. You will also understand how to automate the decryption process using IDA Python scripting.</p>
			<p>In this chapter, we will cover the following topics: </p>
			<ul>
				<li>Exploring packers</li>
				<li>Identifying a packed sample </li>
				<li>Automatically unpacking packed samples </li>
				<li>Manual unpacking techniques</li>
				<li>Dumping the unpacked sample and fixing the import table </li>
				<li>Identifying simple encryption algorithms and functions</li>
				<li>Advanced symmetric and asymmetric encryption algorithms</li>
				<li>Applications of encryption in modern malware – Vawtrak banking Trojan</li>
				<li>Using IDA for decryption and unpacking</li>
			</ul>
			<h1 id="_idParaDest-121"><a id="_idTextAnchor242"/>Exploring packers</h1>
			<p>A packer is a tool that<a id="_idIndexMarker501"/> packs together the executable file’s code, data, and sometimes resources, and contains code for unpacking the program on the fly and executing it. Here are some processes we are going to tackle:</p>
			<ul>
				<li>Advanced symmetric and asymmetric encryption algorithms</li>
				<li>Applications of encryption in modern malware – Vawtrak banking Trojan</li>
				<li>Using IDA for decryption and unpacking</li>
			</ul>
			<p>Here is a high-level diagram of this process:</p>
			<div><div><img src="img/Figure_4.1_B18500.jpg" alt="Figure 4.1 – The process of unpacking a sample&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor243"/><a id="_idTextAnchor244"/>Figure 4.1 – The process of unpacking a sample</p>
			<p>Packers help malware authors hide their malicious code behind these compression and/or encryption layers. This code only gets unpacked and executed once the malware is executed (in runtime mode), which helps malware authors bypass static signature-based detections <a id="_idIndexMarker502"/>when they are applied against packed samples.<a id="_idTextAnchor245"/><a id="_idTextAnchor246"/><a id="_idTextAnchor247"/></p>
			<h2 id="_idParaDest-122"><a id="_idTextAnchor248"/>Exploring packing and encrypting tools</h2>
			<p>Multiple tools <a id="_idIndexMarker503"/>can pack/encrypt executable files, but each has a different purpose. It’s important to understand the difference between them as their encryption techniques are customized for the purpose they serve. Let’s go over them:</p>
			<ul>
				<li><strong class="bold">Packers</strong>: These <a id="_idIndexMarker504"/>programs mainly compress executable files, thereby reducing their total size. Since their purpose is compression, they were not created for hiding malicious traits and are not malicious on their own. Therefore, they can’t be indicators that the packed file is likely malicious. There are many well-known packers around, and they are used by both benign software and malware families, such as the following:<ul><li><strong class="bold">UPX</strong>: This is<a id="_idIndexMarker505"/> an open source packer, and its command-line tool can unpack the packed file.</li><li><strong class="bold">ASPack</strong>: This is a <a id="_idIndexMarker506"/>commonly used packer that has a free and a premium version. The same company that provides ASPack also provides protectors such as ASProtect.</li></ul></li>
				<li><strong class="bold">Legal protectors</strong>: The <a id="_idIndexMarker507"/>main purpose of these tools is to protect programs against reverse engineering attempts – for example, to protect the licensing system of shareware products or to hide implementation details from competitors. They often incorporate encryption and various anti-reverse engineering tricks. Some of them might be misused to protect malware, but this is not their purpose.</li>
				<li><strong class="bold">Malicious encryptors</strong>: Similar<a id="_idIndexMarker508"/> to legal protectors, their purpose is also to make the analysis process harder; however, the focus here is different: to avoid antivirus detection, you need to bypass sandboxes and hide the malicious traits of a file. Their presence indicates that the encrypted file is more than likely to be malicious as they are not available on the legal market.</li>
			</ul>
			<p>In reality, all of these tools are commonly called packers and may include both prot<a id="_idTextAnchor249"/>ection <a id="_idIndexMarker509"/>and compression capabilities.</p>
			<p>Now that we know more about packers, let’s talk about how to identif<a id="_idTextAnchor250"/>y them.</p>
			<h1 id="_idParaDest-123"><a id="_idTextAnchor251"/>Identifying a packed sample</h1>
			<p>There are multiple<a id="_idIndexMarker510"/> tools and multiple ways to identify whether the sample is packed. In this section, we will take a look at different techniques and signs that you can use, from the most straightforward to more intermedia<a id="_idTextAnchor252"/><a id="_idTextAnchor253"/><a id="_idTextAnchor254"/>te ones.</p>
			<h2 id="_idParaDest-124"><a id="_idTextAnchor255"/>Technique 1 – using static signatures</h2>
			<p>The first <a id="_idIndexMarker511"/>way to identify whether the<a id="_idIndexMarker512"/> malware is packed is by using static signatures. Every packer has unique characteristics that can help you identify it. Some PE tools, such <a id="_idIndexMarker513"/>as <strong class="bold">PEiD</strong> and <strong class="bold">CFF Explorer</strong>, can<a id="_idIndexMarker514"/> scan the PE file using these signatures or traits and identify the packer that was used to compress the file (if it’s packed); otherwise, they will identify the compiler that was used to compile this executable file (if it’s not packed). The following is an example:</p>
			<div><div><img src="img/Figure_4.2_B18500.jpg" alt="Figure 4.2 – The PEiD tool detecting UPX&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.2 – The PEiD tool detecting UPX</p>
			<p>All you need to do is open this file in PEiD – you will see the signature that was triggered on this PE file (in the preceding screenshot, it was identified as UPX). However, since they can’t always identify the packer/compiler that was used, you need other ways <a id="_idTextAnchor256"/>to identify whether<a id="_idIndexMarker515"/> it’s packed and what packer<a id="_idIndexMarker516"/> was <a id="_idTextAnchor257"/>used, if any.</p>
			<h2 id="_idParaDest-125"><a id="_idTextAnchor258"/>Technique 2 – evaluating PE section names</h2>
			<p>Section names <a id="_idIndexMarker517"/>can reveal a lot about the <a id="_idIndexMarker518"/>compiler or the packer if the file is packed. An unpacked PE file contains sections such as <code>.text</code>, <code>.data</code>, <code>.idata</code>, <code>.rsrc</code>, and <code>.reloc</code>, while packed files contain specific section names, such as <code>UPX0</code>, <code>.aspack</code>, <code>.stub</code>, and so on. Here is<a id="_idTextAnchor259"/> an example:</p>
			<div><div><img src="img/Figure_4.3_B18500.jpg" alt="Figure 4.3 – The PEiD tool’s section viewer&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.3 – The PEiD tool’s section viewer</p>
			<p>These section names can help you identify whether this file is packed. Searching for these section names on the internet could help you identify the packer that uses these names for its packed data or its stub (unpacking code). You can easily find the section names by opening the file in PEiD and clicking on the <strong class="bold">&gt;</strong> button beside <strong class="bold">EP Section</strong>. <a id="_idTextAnchor260"/>By doing this, you will see the list of sections in this PE file, as well a<a id="_idTextAnchor261"/>s their names.</p>
			<h2 id="_idParaDest-126"><a id="_idTextAnchor262"/>Technique 3 – using stub execution signs</h2>
			<p>Most<a id="_idIndexMarker519"/> packers<a id="_idIndexMarker520"/> compress PE file sections, including the code section, data section, import table, and so on, and then add a new section at the end that contains the unpacking code (stub). Since most of the unpacked PE files start the execution from the first section (in most cases, <code>.text</code>), the packed PE files start the execution from one of the last sections, which is a clear indication that a decryption process will be running. The following signs are an indication that this is happening:</p>
			<ul>
				<li>The entry point is not pointing to the first section (it would mostly be pointing to one of the last two sections) and this section’s memory permission is <code>EXECUTE</code> (in the section’s characteristics).</li>
				<li>The first section’s memory permission will be mostly <code>READ | WRITE</code>.</li>
			</ul>
			<p>It is worth mentioning <a id="_idIndexMarker521"/>that many virus families that infect<a id="_idIndexMarker522"/> executable files have s<a id="_idTextAnchor263"/><a id="_idTextAnchor264"/><a id="_idTextAnchor265"/>imilar attributes.</p>
			<h2 id="_idParaDest-127"><a id="_idTextAnchor266"/>Technique 4 – detecting a small import table</h2>
			<p>For most<a id="_idIndexMarker523"/> applications, the import table is full of APIs from system libraries, as well as third-party libraries; however, in most of the packed PE files, the import table will be quite small and will include a few APIs from known libraries. This is enough to unpack the file. Only one API from each library of the PE file will be used after being unpacked. The reason for this is that most of the packers load the import table manually after unpacking the PE file, as shown in the following screenshot:</p>
			<div><div><img src="img/Figure_4.4_B18500.jpg" alt="Figure 4.4 – The import table of an unpacked sample versus a packed sample with UPX&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.4 – The import table of an unpacked sample versus a packed sample with UPX</p>
			<p>The packed sample removed all the APIs from <code>ADVAPI32.dll</code> and left only one, so the library will be automatically loaded by Windows Loader. After unpacking, the unpacker stub code will load all of these APIs again using the <code>GetProcAddress</code> API.</p>
			<p>Now that we<a id="_idIndexMarker524"/> have a fair idea of how to identify a packed sample, let’s venture forward and explore how to automatically un<a id="_idTextAnchor267"/><a id="_idTextAnchor268"/><a id="_idTextAnchor269"/>pack packed samples.</p>
			<h1 id="_idParaDest-128"><a id="_idTextAnchor270"/>Automatically unpacking packed samples</h1>
			<p>Before you dive <a id="_idIndexMarker525"/>into the manual, time-consuming unpacking process, you need to try some fast automatic techniques first to get a clean unpacked sample in no time at all. In this section, we will explain the most well-known techniques for quick<a id="_idTextAnchor271"/>ly unpacking samples that have been packed <a id="_idTextAnchor272"/>with common packers.</p>
			<h2 id="_idParaDest-129"><a id="_idTextAnchor273"/>Technique 1 – the official unpacking process</h2>
			<p>Some<a id="_idIndexMarker526"/> packers, such as <strong class="bold">UPX</strong> or <strong class="bold">WinRAR</strong>, are <a id="_idIndexMarker527"/>self-extracting <a id="_idIndexMarker528"/>packages that include an unpacking technology that’s shipped with the tool. As you may know, these tools are not created to hide any malicious traits, so some of them provide these unpacking features for both developers and end users.</p>
			<p>In some cases, malware illegally uses a commercial protector to protect itself from reverse engineering and detection. In this case, you can ev<a id="_idTextAnchor274"/>en directly contact the protection provider to unprotect this piece of malware for your analysis.</p>
			<p>In the case of UPX, it is common for attackers to patch the packed sample so that it remains executable, but the standard tool can no longer unpack it. For example, in many cases, it involves replacing the <em class="italic">UPX</em> magic value at the beginning of its first section with something else: </p>
			<div><div><img src="img/Figure_4.5_B18500.jpg" alt="Figure 4.5 – The UPX magic value and section names have changed but the sample remains fully functional&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.5 – The UPX magic value and section names have changed but the sample remains fully functional</p>
			<p>Restoring the<a id="_idIndexMarker529"/> original values can make the sample unpacka<a id="_idTextAnchor275"/>ble by a standard tool.</p>
			<h2 id="_idParaDest-130"><a id="_idTextAnchor276"/>Technique 2 – using OllyScript with OllyDbg</h2>
			<p>There is an <a id="_idIndexMarker530"/>OllyDbg plugin <a id="_idIndexMarker531"/>called <strong class="bold">OllyScript</strong> that <a id="_idIndexMarker532"/>can help automate the unpacking process. It does this by scripting OllyDbg actions, such as setting a breakpoint, continuing execution, pointing the EIP register to a different place, or modifying some bytes.</p>
			<p>Nowadays, OllyScript is not that widely used, but it in<a id="_idTextAnchor277"/><a id="_idTextAnchor278"/><a id="_idTextAnchor279"/>spired the next technique.</p>
			<h2 id="_idParaDest-131"><a id="_idTextAnchor280"/>Technique 3 – using generic unpackers</h2>
			<p>Generic unpackers <a id="_idIndexMarker533"/>are debuggers <a id="_idIndexMarker534"/>that have been pre-scripted to unpack specific packers or to automate the manual unpacking process, which we will describe in the next section. Here is an example of one of them:</p>
			<div><div><img src="img/Figure_4.6_B18500.jpg" alt="Figure 4.6 – The QuickUnpack tool in detail&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.6 – The QuickUnpack tool in detail</p>
			<p>They are more generic and can work with multiple packers. However, malware may escape from these tools, which may lead to the malware being executed on the user’s machine. <a id="_idTextAnchor281"/>Because <a id="_idIndexMarker535"/>of this, you should <a id="_idIndexMarker536"/>always use these tools on an isolated virtual mach<a id="_idTextAnchor282"/>ine or in a safe environment.</p>
			<h2 id="_idParaDest-132"><a id="_idTextAnchor283"/>Technique 4 – emulation</h2>
			<p>Another group of<a id="_idIndexMarker537"/> tools worth mentioning is emulators. Emulators are programs that simulate the execution environment, including the processor (for executing instructions, dealing with registers, and so on), memory, th<a id="_idTextAnchor284"/>e operating system, and so on.</p>
			<p>These tools have more capabilities for running malware safely (as it’s all simulated) and have more control over the execution process. Therefore, they can help set up more sophisticated breakpoints and can also be easily <a id="_idIndexMarker538"/>scripted (such as <strong class="bold">libemu</strong> and the <strong class="bold">Pokas x86 Emulator</strong>), as <a id="_idIndexMarker539"/>shown in the following code:</p>
			<pre class="source-code">
from pySRDF import *
emu = Emulator(“upx.exe”)
x = emu.SetBp(“isdirty(eip)”) # which set bp on Execute on modified data
emu.Run() # OR emu.Run(“ins.log”) to log all running instructions
emu.Dump(“upx_unpacked.exe”, DUMP_FIXIMPORTTABLE) # DUMP_FIXIMPORTTABLE create new import table for new API
print(“File Unpacked Successfully\n\nThe Disassembled Code\n---------------”)</pre>
			<p>In this example, we used the Pokas x86 Emulator. It was much easier to set more complicated breakpoints, such as <em class="italic">Execute on mod<a id="_idTextAnchor285"/>ified data</em>, which gets triggered when the instruction pointer (EIP) is pointing to a decrypted/unpacked place in memory.</p>
			<p>Another great example<a id="_idIndexMarker540"/> of such a tool based on emulation<a id="_idIndexMarker541"/> is <strong class="bold">unipacker</strong>. It is based <a id="_idIndexMarker542"/>on the <strong class="bold">Unicorn</strong> engine and supports a decent amount of popular legitimate packers, including AS<a id="_idTextAnchor286"/>Pack, FSG, MEW, MPRESS, and others.</p>
			<h2 id="_idParaDest-133"><a id="_idTextAnchor287"/>Technique 5 – memory dumps</h2>
			<p>The last fast <a id="_idIndexMarker543"/>technique we will mention is incorporating memory dumps. This technique is widely used as it’s one of the easiest for most packers and protectors to apply (especially if they have anti-debugging techniques). The idea behind it is to just execute the malware and take a memory snapshot of its process. Some common sandboxing tools provide a process’s memory dump as a core feature or as one of their plugins’ features, such <a id="_idIndexMarker544"/>as <strong class="bold">Cuckoo</strong> sandbox.</p>
			<p>This technique is very beneficial for static analysis, as well as for static signature scanning; however, the memory dump that is produced is different from the original sample and can’t be executed. Apart from mismatching locations of code and data compared to the offsets specified in the section table, the import table will also need to be fixed before any further dynamic analysis is possible.</p>
			<p>Since this technique doesn’t provide a clean sample, and because of the limitations of the previous automated techniques we described, understanding how to unpack malware manually can help you with these special cases that you will encounter from time to time. With manual unpacking, and by understanding anti-reverse engineering techniques (these will be covered in <a href="B18500_06.xhtml#_idTextAnchor554"><em class="italic">Chapter 6</em></a>, <em class="italic">Bypassing Anti-Reverse Engineering Techniques</em>), you <a id="_idIndexMarker545"/>will be able to deal with the most advanced packers.</p>
			<p>In the next section, we will <a id="_idTextAnchor288"/><a id="_idTextAnchor289"/><a id="_idTextAnchor290"/>explore manual unpacking using OllyDbg.</p>
			<h1 id="_idParaDest-134"><a id="_idTextAnchor291"/>Manual unpacking techniques</h1>
			<p>Even though <a id="_idIndexMarker546"/>automated unpacking is faster and easier to use than manual unpacking, it doesn’t work with all packers, encryptors, or protectors. This is because some of them require a specific, custom way to unpack. Some of them have anti-VM techniques or anti-reverse engineering techniques, while others use unusual APIs or assembly instructions that emulators can’t detect. In this section, we will look at different techniques for unpacking malware manually.</p>
			<p>The main difference between the previous technique and manual unpacking is when we take the memory dump and what we do with it afterward. If we just execute the original sample, dump the whole process memory, and hope that the unpacked module will be available there, we will face multiple problems:</p>
			<ul>
				<li>It is possible that the unpacked sample will already be mapped by sections and that the import table will already have been populated, so the engineer will have to change the physical addresses of each section so that it’s equal to the virtual ones, restore imports, and maybe even handle relocations to make them executable again. </li>
				<li>The hash of this sample will be different from the original one.</li>
				<li>The original loader may unpack the sample to allocated memory, inject it somewhere else, and free the memory so that it won’t be a part of the full dump.</li>
				<li>It is very easy to miss some modules; for example, the original loader may unpack only a sample for either a 32- or 64-bit platform.</li>
			</ul>
			<p>The much cleaner way is to stop unpacking when the sample has just been unpacked but hasn’t been used yet. This way, it will just be an original file. In some cases, even its hash will match the<a id="_idIndexMarker547"/> original not-yet-packed sample and therefore <a id="_idTextAnchor292"/>can be used for threat hunting purposes.</p>
			<p>In this section, we will cover several common<a id="_idTextAnchor293"/> universal methods of unpacking samples.</p>
			<h2 id="_idParaDest-135"><a id="_idTextAnchor294"/>Technique 1 – memory breakpoint on execution</h2>
			<p>This technique <a id="_idIndexMarker548"/>works for packers that place an unpacked sample in the same place in memory where the packed file was loaded. As we know, the packed sample will contain sections of the original file (including the code section), and the unpacker stub just unpacks each of them and then transfers control<a id="_idIndexMarker549"/> to the <strong class="bold">original entry point</strong> (<strong class="bold">OEP</strong>) for the application to run it normally. This way, we can assume that OEP will be in the first section so that we can set a breakpoint to catch any instructions being executed th<a id="_idTextAnchor295"/><a id="_idTextAnchor296"/>ere. Let’s cover this process step by step.</p>
			<h3>Step 1 – setting the breakpoints</h3>
			<p>To intercept the <a id="_idIndexMarker550"/>moment when the code in the first section receives control, we can’t use hardware breakpoints on execution as they can be only set to a maximum of four bytes. This way, we would need to know where exactly the execution will start. The more effective solution is to set a memory breakpoint on execution.</p>
			<p>The ability to use memory breakpoints on execution is available in OllyDbg implicitly. It can be accessed by going to <strong class="bold">View </strong>| <strong class="bold">Memory</strong>, where we can change the first section’s memory permissions to <strong class="bold">Read/write</strong> if it was <strong class="bold">Full access</strong>. Here is an example: </p>
			<div><div><img src="img/Figure_4.7_B18500.jpg" alt="Figure 4.7 – Changing memory permissions in OllyDbg&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.7 – Changing memory permissions in OllyDbg</p>
			<p>In this case, we can’t execute code in this section until it gets execute permission. By default, in multiple Windows versions, it will still be executable for noncritical processes, even if the memory permissions don’t include the <code>EXECUTE</code> permission. Therefore, you need to enforce what is called <code>EXECUTE</code> permission<a id="_idIndexMarker551"/> and does not allow any non-executable data to be executed.</p>
			<p>This technology is used to prevent exploitation attempts, which we will cover in more detail in <a href="B18500_08.xhtml#_idTextAnchor811"><em class="italic">Chapter 8</em></a>, <em class="italic">Handling Exploits and Shellcode</em>; however, it comes in handy wh<a id="_idTextAnchor297"/><a id="_idTextAnchor298"/><a id="_idTextAnchor299"/>en we want to unpack malware samples easily.</p>
			<h3>Step 2 – turning on Data Execution Prevention</h3>
			<p>To turn on<a id="_idIndexMarker552"/> DEP, you<a id="_idIndexMarker553"/> can go to <strong class="bold">Advanced system settings</strong> and then <strong class="bold">Data Execution Prevention</strong>. You will need to turn it on for all programs and services, as shown in the following screenshot:</p>
			<div><div><img src="img/Figure_4.8_B18500.jpg" alt="Figure 4.8 – Changing the DEP settings on Windows&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figu<a id="_idTextAnchor300"/>re 4.8 – Changing the DEP settings on Windows</p>
			<p>Now, these<a id="_idIndexMarker554"/> types<a id="_idIndexMarker555"/> of breakpoints should b<a id="_idTextAnchor301"/>e enforced and the malware should be prevented from executing in this section, particularly<a id="_idTextAnchor302"/> at the beginning of the decrypted code (OEP).</p>
			<h3>Step 3 – preventing any further attempts to change memory permissions</h3>
			<p>Unfortunately, just <a id="_idIndexMarker556"/>enforcing DEP is not enough. The unpacking stub can easily bypass this breakpoint by changing the permission of this section to full access again by using the <code>VirtualProtect</code> API.</p>
			<p>This API gives the program the ability to change the memory permissions of any memory chunk to any other permissions. You need to set a breakpoint on this API by going to <code>VirtualProtect</code>), and set a breakpoint on the address it takes you to.</p>
			<p>If the stub tries to call <code>VirtualProtect</code> to change the memory permissions, the debugged process will stop, and you can change the permission it tries to set in the first section. You can change the <code>NewProtect</code> argument value to <code>READONLY</code> or <code>READ|WRITE</code> and remove the <code>EXECUTE</code> bit from it. Here is how it will look in the debugger:</p>
			<div><div><img src="img/Figure_4.9_B18500.jpg" alt="Figure 4.9 – Finding an address that the VirtualProtect API changes permissions for&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.9 – Finding an address that the VirtualProtect API changes permissions for</p>
			<p>Once we<a id="_idIndexMarker557"/> have handled this<a id="_idTextAnchor303"/><a id="_idTextAnchor304"/><a id="_idTextAnchor305"/> part, it is time to let the breakpoint trigger.</p>
			<h3>Step 4 – executing and getting the OEP</h3>
			<p>Once <a id="_idIndexMarker558"/>you<a id="_idIndexMarker559"/> click <strong class="bold">Run</strong>, the<a id="_idIndexMarker560"/> debugged <a id="_idIndexMarker561"/>process will eventually transfer control to the OEP, which will cause an access violation error to appear, as shown in the following screenshot:</p>
			<div><div><img src="img/Figure_4.10_B18500.jpg" alt="Figure 4.10 – Staying at the OEP of the sample in OllyDbg&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.10 – Staying at the OEP of the sample in OllyDbg</p>
			<p>This may not happen immediately as some packers modify the first few bytes of the first section with instructions such as <code>ret</code>, <code>jmp</code>, or <code>call</code>, just to make the debugged process break <a id="_idIndexMarker562"/>on this breakpoint; however, after<a id="_idIndexMarker563"/> a <a id="_idIndexMarker564"/>few <a id="_idIndexMarker565"/>iterations, the program will break. This occurs after full decryption/decompression of the first section, whi<a id="_idTextAnchor306"/><a id="_idTextAnchor307"/><a id="_idTextAnchor308"/>ch it does to execute the original code of the program.</p>
			<h2 id="_idParaDest-136"><a id="_idTextAnchor309"/>Technique 2 – call stack backtracing</h2>
			<p>Understanding<a id="_idIndexMarker566"/> the concept <a id="_idIndexMarker567"/>of the <strong class="bold">call stack</strong> is very useful for speeding up your malware analysis process. First up is the unpacking process.</p>
			<p>Take a look at the following code and imagine what the stack will look like:</p>
			<pre class="source-code">
func01:
1: push ebp
2: mov ebp, esp ; now ebp = esp
...
3: call func02
...
func02:
4: push ebp     ; which was the previous esp before the call
5: mov ebp, esp ; now ebp = new esp
...
6: call func03
...
func03:
7: push ebp     ; which is equal to previous esp
8: mov ebp, esp ; ebp = another new esp
...</pre>
			<p>When we look<a id="_idIndexMarker568"/> at the stack just after<a id="_idIndexMarker569"/> the return address saved by <code>call func03</code>, the value of the previous <code>esp</code> is saved using <code>push ebp</code> (it was copied to <code>ebp</code> at line <code>5</code>). On top of the stack from this previous <code>esp</code> value, the first <code>esp</code> value is stored (this is because instruction <code>4</code> of <code>ebp</code> is equal to the first <code>esp</code> value), <a id="_idTextAnchor310"/>followed by the return address from <code>call func02</code>, and so on. Here, the stored <code>esp</code> value is followed by a return address. This <code>esp</code> value points to the previously stored <code>esp</code> value, followed by the previous return address, and so on. This is known as a call stack. The following screenshot shows what this looks like in OllyDbg:</p>
			<div><div><img src="img/Figure_4.11_B18500.jpg" alt="Figure 4.11 – Stored values followed by a return address in OllyDbg&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.11 – Stored values followed by a return address in OllyDbg</p>
			<p>As you can see, the stored <code>esp</code> value points to the next stack frame (another stored <code>esp</code> value and the return address of the previous call), and so on.</p>
			<p>OllyDbg includes<a id="_idIndexMarker570"/> a view<a id="_idIndexMarker571"/> window for the call stack that can be accessed through <strong class="bold">View </strong>| <strong class="bold">Call Stack</strong>.<a id="_idTextAnchor311"/> It looks as follows:</p>
			<div><div><img src="img/Figure_4.12_B18500.jpg" alt="Figure 4.12 – Call stack in OllyDbg&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.12 – Call stack in OllyDbg</p>
			<p>Now, you may be wondering: how can the call stack help us unpack our malware in a fast and efficient way?</p>
			<p>Here, we can set a breakpoint that we are sure will make the debugged process break in the middle of the execution of the decrypted code (the actual program code after the unpacking phase). Once the execution stops, we can backtrace the call stack and get to the first call in the decrypted code. Once we are there, we can just slide up until we reach the start of the first function that was executed<a id="_idTextAnchor312"/> in the decrypted code, and we can declare this<a id="_idIndexMarker572"/> address<a id="_idTextAnchor313"/> as<a id="_idIndexMarker573"/> the OEP. Let’s describe this process in greater detail.</p>
			<h3>Step 1 – setting the breakpoints</h3>
			<p>To apply this<a id="_idIndexMarker574"/> approach, you need to set the breakpoints on the APIs that the program will execute at some point. You can rely on the common APIs that are used (examples include <code>GetModuleFileNameA</code>, <code>GetCommandLineA</code>, <code>CreateFileA</code>, <code>VirtualAlloc</code>, <code>HeapAlloc</code>, and <code>memset</code>), your behavioral analysis, or a sandbox report that will give you the APIs that were used during the execution of the sample.</p>
			<p>First, you must set a breakpoint on these APIs (use all of your known ones, except the ones that could be used by the unpacking stub) and execute the program until the execution breaks, as shown in the following screenshot:</p>
			<div><div><img src="img/Figure_4.13_B18500.jpg" alt="Figure 4.13 – The return address in the stack window in OllyDbg&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.13 – The return address in the stack window in OllyDbg</p>
			<p>Now, you need to check the stack,<a id="_idTextAnchor314"/> since most of your next steps will be on the stack <a id="_idTextAnchor315"/>side. By doing this, you can start following the call stack.</p>
			<h3>Step 2 – following the call stack</h3>
			<p>Follow<a id="_idIndexMarker575"/> the stored <code>esp</code> value<a id="_idIndexMarker576"/> in the stack and then the next stored <code>esp</code> value until you land on the first return address, as shown in the following screenshot:</p>
			<div><div><img src="img/Figure_4.14_B18500.jpg" alt="Figure 4.14 – The last return address in the stack window in OllyDbg&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure <a id="_idTextAnchor316"/>4.14 – The last return address in the stack window in OllyDbg</p>
			<p>Now, follow the return address on the disassembled section in the CPU window, as follows:</p>
			<div><div><img src="img/Figure_4.15_B18500.jpg" alt="Figure 4.15 – Following the last return address in OllyDbg&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.15 – Following the last return address in OllyDbg</p>
			<p>Once you<a id="_idIndexMarker577"/> have reached <a id="_idTextAnchor317"/>the<a id="_idIndexMarker578"/> first call in<a id="_idTextAnchor318"/> the unpacked section, the only step left is reaching the OEP.</p>
			<h3>Step 3 – reaching the OEP</h3>
			<p>Now, you only <a id="_idIndexMarker579"/>need to slide up<a id="_idIndexMarker580"/> until you reach the OEP. It can be recognized by a standard function prologue, as follows:</p>
			<div><div><img src="img/Figure_4.16_B18500.jpg" alt="Figure 4.16 – Finding the OEP in OllyDbg&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.16 – Finding the OEP in OllyDbg</p>
			<p>This is the same entr<a id="_idTextAnchor319"/>y point that we were able to reach using the previous technique. It’s a simple technique to use and it works with many complex packers and encryptors. However, this technique could easi<a id="_idTextAnchor320"/>ly lead to the actual execution of the malware or at<a id="_idTextAnchor321"/> least some <a id="_idIndexMarker581"/>pieces of its code, so it <a id="_idIndexMarker582"/>should be used with care.</p>
			<h2 id="_idParaDest-137"><a id="_idTextAnchor322"/>Technique 3 – monitoring memory allocated spaces for unpacked code</h2>
			<p>This method<a id="_idIndexMarker583"/> is <a id="_idIndexMarker584"/>extremely useful if the time to analyze a sample is limited, or if there are many of them, as here, we are not going into the details of how the original sample is stored.</p>
			<p>The idea here is that the original malware usually allocates a big block of memory to store the unpacked/decrypted embedded sample. We will cover what happens when this is not the case later.</p>
			<p>There are multiple Windows APIs that can be used for allocating memory in user mode. Attackers generally tend to use the following ones:</p>
			<ul>
				<li><code>VirtualAlloc/VirtualAllocEx/VirtualAllocExNuma</code></li>
				<li><code>LocalAlloc/GlobalAlloc/HeapAlloc</code></li>
				<li><code>RtlAllocateHeap</code></li>
			</ul>
			<p>In kernel mode, there are other functions such as <code>ZwAllocateVirtualMemory</code>; <code>ExAllocatePoolWithTag</code> can be used in pretty much the same way.</p>
			<p>If the sample is written in C, it makes sense to monitor <code>malloc/calloc</code> functions straight away. For C++ malware, we can also monitor the <code>new</code> operator.</p>
			<p>Once we have stopped at the entry point of the sample (or at the beginning of the TLS routine, if it is available), we can set a breakpoint on execution at these functions. Generally, it is OK to put a breakpoint on the first instruction of the function, but if there is a concern that malware can hook it (that is, replace the first several bytes with some custom code), the breakpoint at the last instruction will work better.</p>
			<p>Another advantage of this is that this way, it only needs one breakpoint for both <code>VirtualAllocEx</code> and <code>VirtualAlloc</code> (which is a wrapper around the former API). In the IDA debugger, it is possible to go to the API by pressing the <em class="italic">G</em> hotkey and prefixing the API name with the corresponding DLL without the file extension and separating it with an underscore, for example, <code>kernel32_VirtualAlloc</code>, as shown in the following screenshot:</p>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor323"/></p>
			<div><div><img src="img/Figure_4.17_B18500.jpg" alt="Figure 4.17 – Setting a breakpoint at memory allocation in WinAPI&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.17 – Setting a breakpoint at memory allocation in WinAPI</p>
			<p>After this, we continue execution and keep monitoring the sizes of the allocated blocks. So long as it is big enough, we can put a breakpoint on the write operation to intercept the moment when<a id="_idIndexMarker585"/> the <a id="_idIndexMarker586"/>encrypted (or already decrypted on the fly) payload is being written there. If the malware calls one of these functions too many times, it makes sense to set a conditional breakpoint and monitor only allocations of blocks bigger than a particular size. After this, if the block is still encrypted, we can keep a breakpoint on write and wait until the decryption routine starts processing it. Finally, we can dump the memory block to disk when the last byte is decrypted.</p>
			<p>Other API functions that can be used in the same approach include the following:</p>
			<ul>
				<li><code>VirtualProtect</code>: Malware authors can use this to make the memory block store the unpacked sample executable or make the header or the code section non-writeable.</li>
				<li><code>WriteProcessMemory</code>: This is often used to inject the unpacked payload, either into some other process or into itself.</li>
			</ul>
			<p>Some packers, such as UPX, follow a slightly different approach by having an entry in their section table with a section that takes a lot of space in RAM but is not present on a disk (having a physical size equal to 0). This way, the Windows Loader will prepare this space for the unpacker for free without any need for it to allocate memory dynamically. In this case, placing a breakpoint on write at the beginning of this section will work the same way as described previously.</p>
			<p>In most cases, malware unpacks the whole sample at once so that after dumping it, we get the correct MZ-PE file, which can be analyzed independently. However, other options exist, such as the following:</p>
			<ul>
				<li>A decrypted block is a corrupted executable and depends on the original packer to perform correctly.</li>
				<li>The packer decrypts the sample section by section and loads each of them one by one. There are many ways this can be handled, as follows:<ul><li>Dump sections, so long as they become available, and concatenate them later.</li><li>Modify the decryption routine to process the whole sample at once.</li><li>Write a script that decrypts the whole encrypted block.</li></ul></li>
			</ul>
			<p>If the <a id="_idIndexMarker587"/>malicious <a id="_idIndexMarker588"/>program terminates at any stage, it might be a sign that it either needs something extra (such as command-line arguments or an external file, or perhaps it needs to be loaded in a specific way) or that an anti-reverse engineering trick needs to be bypassed. You can confirm this in many ways – for example, by intercepting the moment when the program is going to terminate (for example, by placing a breakpoint on <code>ExitProcess</code>, <code>TerminateProcess</code>, or the more fancy <code>PostQuitMess<a id="_idTextAnchor324"/>age</code> API call) and tracing which part of the code is responsible for it. Some engineers prefer to go through the main function manually, step by step – without going into subroutines until one of them causes a termination – and then restart the process and trace the code of this routine. Then, we can trace the code of the routine inside it, if ne<a id="_idTextAnchor325"/><a id="_idTextAnchor326"/>cessary, right up until the<a id="_idIndexMarker589"/> moment the terminating logic is confirmed.</p>
			<h2 id="_idParaDest-138"><a id="_idTextAnchor327"/>Technique 4 – in-place unpacking</h2>
			<p>While not <a id="_idIndexMarker590"/>common, it is possible to either decrypt the sample in the same section where it was originally located (this section should have <code>WRITE|EXECUTE</code> permissions) or in another section of an original file.</p>
			<p>In this case, it makes sense to perform the following steps:</p>
			<ol>
				<li>Search for a big encrypted block (usually, it has high entropy and is visible to the naked eye in a hex editor).</li>
				<li>Find the exact place where it will be read (the first bytes of the block may serve other purposes – for example, they may store various types of metadata, such as sizes or checksums/hashes, to verify the decryption).</li>
				<li>Put a breakpoint on read and/or write there.</li>
				<li>Run the program and wait for the breakpoint to be triggered.</li>
			</ol>
			<p>So long as this block is accessed by the decryption routine, it is pretty straightforward to get the decrypted version of it – either by placing a breakpoint on execution at the end of the decryption function or a breakpoint on write to the last bytes of the encrypted block to intercept the moment when they are processed.</p>
			<p>It is worth mentioning that this approach can be used together with the one that relies on malware allocating memory. This will be discussed in the <em class="italic">Manual unpacking techniques</em> section.</p>
			<h2 id="_idParaDest-139"><a id="_idTextAnchor328"/>Technique 5 – searching for and transferring control to OEP</h2>
			<p>In <a id="_idIndexMarker591"/>theory, any<a id="_idIndexMarker592"/> control<a id="_idIndexMarker593"/> flow<a id="_idIndexMarker594"/> instruction can be used to transfer control to the OEP once the unpacking is done. However, in reality, many unpackers just use the <code>jmp</code> instruction as they don’t need any conditions and they don’t need to get the control back (another less common option is using a combination of <code>push &lt;OEP_addr&gt;</code> and <code>ret</code>). As the address of the OEP is often not known at compilation time, it is generally passed to <code>jmp</code> in the form of a register or a value stored at a particular offset rather than an actual virtual address and therefore easy to spot. Another option might be that the OEP address is known at compilation time, but there is no code there yet as the unpacking hasn’t finished yet. In both cases, searching for anomalous control transfer instructions may be a quick way to spot the OEP. In the case of <code>jmp</code>, it can be done by running a full-text search for all <code>jmp</code> instructions (In IDA, you can use the <em class="italic">Alt</em> + <em class="italic">T</em> hotkey combination) and sorting them to spot <a id="_idIndexMarker595"/>anomalous <a id="_idIndexMarker596"/>entries. Here <a id="_idIndexMarker597"/>is an <a id="_idIndexMarker598"/>example of such a control transfer:</p>
			<div><div><img src="img/Figure_4.18_B18500.jpg" alt="Figure 4.18 – Uncommon control transfer involving a register&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.18 – U<a id="_idTextAnchor329"/><a id="_idTextAnchor330"/><a id="_idTextAnchor331"/>ncommon control transfer involving a register</p>
			<p>Now let’s move on to technique 6.</p>
			<h2 id="_idParaDest-140"><a id="_idTextAnchor332"/>Technique 6 – stack restoration-based</h2>
			<p>This technique is<a id="_idIndexMarker599"/> usually <a id="_idIndexMarker600"/>quicker to do than the previous two, but it is less reliable. The idea here is that some packers will transfer control to the unpacked code at the end of the main function when the unpacking is done. We already know that, at the end of the function, the stack pointer is returned to the same address that it had at the beginning of this function. In this case, it is possible to set a breakpoint on access to the <code>[esp-4]</code>/<code>[rsp-8]</code> value while staying at the entry point of the sample and then execute it so that the breakpoint will hopefully trigger just before it transfers control to the unpacked code.</p>
			<p>This may never happen, depending on the implementation of the unpacking code, and there may be other situations where this does happen (for example, when there are multiple garbage calls before starting the actual unpacking process). Therefore, this method can only be used as a first quick check before more time is spent on the other methods.</p>
			<p>After we reach the point where we have the unpacked sample in memory, we need to save it to <a id="_idTextAnchor333"/>disk. In the next section, we will descri<a id="_idTextAnchor334"/>be how to dump the unpacked malware from memory<a id="_idIndexMarker601"/> to disk and fix the import table.</p>
			<h1 id="_idParaDest-141"><a id="_idTextAnchor335"/>Dumping the unpacked sample and fixing the import table</h1>
			<p>In this section, we<a id="_idIndexMarker602"/> will<a id="_idIndexMarker603"/> learn how to dump the unpacked malware in memory to disk and fix its import table. In addition to this, if the import table has already been populated with API addresses by the loader, we will need to restore the original values. In this case, other t<a id="_idTextAnchor336"/><a id="_idTextAnchor337"/><a id="_idTextAnchor338"/>ools will be able to read it, and we will be able to execute it for dynamic analysis.</p>
			<h2 id="_idParaDest-142"><a id="_idTextAnchor339"/>Dumping the process</h2>
			<p>To dump the<a id="_idIndexMarker604"/> process, you <a id="_idIndexMarker605"/>can use <strong class="bold">OllyDump</strong>. OllyDump is an OllyDbg plugin that can dump the process back to an executable file. It unloads the PE file back from memory into the necessary file format:</p>
			<div><div><img src="img/Figure_4.19_B18500.jpg" alt="Figure 4.19 – The OllyDump UI&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.19 – The OllyDump UI</p>
			<p>Once you reach<a id="_idIndexMarker606"/> the OEP from the previous manual unpacking process, you can set the OEP as the new entry point. OllyDump can fix the import table (as we will soon describe). You can eith<a id="_idTextAnchor340"/>er use it or uncheck the <strong class="bold">Rebuild Import</strong> checkbox if you are willing to use other tools.Another option is to use tools<a id="_idIndexMarker607"/> such <a id="_idIndexMarker608"/>as <strong class="bold">PETools</strong> or <strong class="bold">Lord PE</strong> for 32-bit and <strong class="bold">VSD</strong> for both 32- and 64-bit Windows. The <a id="_idIndexMarker609"/>main advantage of these solutions is that apart from the so-called <strong class="bold">Dump Full</strong> option, which mainly dumps original sections associated with the sample, it is also possible to dump a particular memory region – for example, allocated memory with the decrypted/unpacked sample(s),<a id="_idTextAnchor341"/> as shown in the following screenshot:</p>
			<div><div><img src="img/Figure_4.20_B18500.jpg" alt="Figure 4.20 – The Region Dump window of PETools&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.20 – The Region Dump window<a id="_idTextAnchor342"/> of PETools</p>
			<p>Next, we are going to <a id="_idIndexMarker610"/>look at fixing the import table of a piece of malware.</p>
			<h2 id="_idParaDest-143"><a id="_idTextAnchor343"/>Fixing the import table</h2>
			<p>Now, you may be<a id="_idIndexMarker611"/> wondering: what happens to the import table that needs to be fixed? The answer is: when the PE file gets loaded in the process memory or the unpacker stub loads the import table, the loader goes through the import table (you can find more information in <a href="B18500_03.xhtml#_idTextAnchor084"><em class="italic">Chapter 3</em></a>, <em class="italic">Basic Static and Dynamic Analysis for x86/x64</em>) and populates it with the actual addr<a id="_idTextAnchor344"/>esses of API functions from DLLs that are available on the machine. Here is an example:</p>
			<div><div><img src="img/Figure_4.21_B18500.jpg" alt="Figure 4.21 – The import table before and after PE loading&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.21 – The import table before and after PE loading</p>
			<p>After this, these API addresses are used to access these APIs throughout the application code, usually by using the <code>call</code> and <code>jmp</code> instructions:</p>
			<div><div><img src="img/Figure_4.22_B18500.jpg" alt="Figure 4.22 – Examples of diﬀerent API calls&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.22 – Examples of diﬀerent API calls</p>
			<p>To restore the<a id="_idIndexMarker612"/> import table, we need to find this list of API addresses, find which API each address represents (we need to go through each library list of addresses and their corresponding API names for this), and then replace each of these addresses with either an offset pointing to the API name string or an ordinal value. If we don’t find the API names in the file, we may need to create a<a id="_idTextAnchor345"/> new section that we can add these API names to and use them to restore the import table.</p>
			<p>Fortunately, some <a id="_idIndexMarker613"/>tools do this automatically. In this section, we will talk about <strong class="bold">Import<a id="_idTextAnchor346"/> REConstructor</strong> (<strong class="bold">ImpREC</strong>). Here is what it looks like:</p>
			<div><div><img src="img/Figure_4.23_B18500.jpg" alt="Figure 4.23 – The ImpREC interface&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.23 – The ImpREC interface</p>
			<p>To fix the import<a id="_idIndexMarker614"/> table, you need to follow these steps:</p>
			<ol>
				<li value="1">Dump the process or any library you want to dump using, for example, <strong class="bold">OllyDump</strong> (and uncheck the <strong class="bold">Rebuild Import</strong> checkbox) or any other tool of preference.</li>
				<li>Open <strong class="bold">ImpREC</strong> and choose the process you are currently debugging.</li>
				<li>Now, set the OEP value to the correct value and click on <strong class="bold">IAT AutoSearch</strong>.</li>
				<li>After that, click on <strong class="bold">Get Imports</strong> and delete any rows with <strong class="bold">valid: NO</strong> from the <strong class="bold">Imported Functions Found</strong> section.</li>
				<li>Click on the <strong class="bold">Fix Dump</strong> button and then select the previously dumped file. Now, you will have a working, unpacked PE file. You can load it into PEiD or any other PE explorer<a id="_idIndexMarker615"/> application to check whether it is working.</li>
			</ol>
			<p class="callout-heading">Important Note</p>
			<p class="callout">For a 64-bit Windows system, the Scylla or CHimpREC tools can be used instead.</p>
			<p>I<a id="_idTextAnchor347"/>n the next section, we will discuss basic encryption algorithms and fu<a id="_idTextAnchor348"/>nctions to strengthen our knowledge base and thus enrich our malware analysis capabilities.</p>
			<h1 id="_idParaDest-144"><a id="_idTextAnchor349"/>Identifying simple encryption algorithms and functions</h1>
			<p>In this section, we <a id="_idIndexMarker616"/>will take a look at the simple encryption <a id="_idIndexMarker617"/>algorithms that are widely used in the wild. We will learn about the difference between symmetric and asymmetric encryption, and<a id="_idTextAnchor350"/><a id="_idTextAnchor351"/><a id="_idTextAnchor352"/> we will learn how to identify these encryption algorithms in the malware’s disassembled code.</p>
			<h2 id="_idParaDest-145"><a id="_idTextAnchor353"/>Types of encryption algorithms</h2>
			<p>Encryption is the <a id="_idIndexMarker618"/>process of modifying data or information to make it unreadable or unusable without a secret key, which is only given to people who are expected to read the message. The difference between encoding or compression and encryption is that they do not use any key, and their main goal is not related to protecting the information or limiting access to it compared to encryption.</p>
			<p>There are two basic types of encryption algorithms: symmetric and asymmetric (also called public-key algorithms). Let’s explore the differences between them:</p>
			<ul>
				<li><strong class="bold">Symmetric algorithms</strong>: These <a id="_idIndexMarker619"/>types of algorithms use the same key for encryption and decryption. They use<a id="_idTextAnchor354"/> a single secret key that’s shared by both sides:</li>
			</ul>
			<div><div><img src="img/Figure_4.24_B18500.jpg" alt="Figure 4.24 – Symmetric algorithm explained &#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.24 – Symmetric <a id="_idIndexMarker620"/>algorithm explained </p>
			<ul>
				<li><strong class="bold">Asymmetric algorithms</strong>: In this case, two keys are used. One is used for encryption and the other is used for decryption. These two keys are called the <strong class="bold">public key</strong> and <a id="_idIndexMarker621"/>the <strong class="bold">private key</strong>. One<a id="_idIndexMarker622"/> key is shared publicly (the public key), while the other one is kept secret (the private key). Here<a id="_idIndexMarker623"/> is a high-level diagram describing this process:</li>
			</ul>
			<div><div><img src="img/Figure_4.25_B18500.jpg" alt="Figure 4.25 – Asymmetric algorithm explained&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.25 – Asymmetric algorithm explained</p>
			<p>Now, let’s talk about <a id="_idIndexMarker624"/>simple custom-made encryption algorithms commonly used in malware.</p>
			<h2 id="_idParaDest-146"><a id="_idTextAnchor355"/>Basic encryption algorithms</h2>
			<p>Most encryption <a id="_idIndexMarker625"/>algorithms that are used by malware consist of basic mathematical and logical instructions – that is, <code>xor</code>, <code>add</code>, <code>sub</code>, <code>rol</code>, and <code>ror</code>. These instructions are reversible, and you don’t lose data while encrypting with them compared to instructions such as <code>shl</code> or <code>shr</code>, where it is possible to lose some bits from the left and right. This also happen<a id="_idTextAnchor356"/>s with the <code>and</code> and <code>or</code> instructions, which can lead to data loss when using <code>or</code> with 1 or <code>and</code> with 0.</p>
			<p>These operations can be used in multiple ways, as follows:</p>
			<ul>
				<li><code>rol</code> instruction:</li>
			</ul>
			<div><div><img src="img/Figure_4.26_B18500.jpg" alt="Figure 4.26 – Example of the rol instruction&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.26 – Example of the rol instruction</p>
			<ul>
				<li><strong class="bold">Running key encryption</strong>: Here, the malware changes the key during the encryption. Here is an example:<pre>loop_start:
mov edx, &lt;secret_key&gt;
xor dword ptr [&lt;data_to_encrypt&gt; + eax], edx
add edx, 0x05 ; add 5 to the key
inc eax
loop loop_start</pre></li>
				<li><code>0x23</code>).</li>
				<li><strong class="bold">Other encryption algorithms</strong>: Malware authors never run out of ideas when it comes to creating new algorithms that represent a co<a id="_idTextAnchor357"/>mbination of these arithmetic <a id="_idIndexMarker627"/>and<a id="_idTextAnchor358"/> logical instructions. This leads us to the next question: how can we identify encryption functions?</li>
			</ul>
			<h2 id="_idParaDest-147"><a id="_idTextAnchor359"/>Identifying encryption functions in disassembly</h2>
			<p>The following<a id="_idIndexMarker628"/> screenshot demonstrates<a id="_idIndexMarker629"/> sections that have been numbered from <strong class="bold">1</strong> to <strong class="bold">4</strong>. These se<a id="_idTextAnchor360"/>ctions are key to understanding and identifying the encryption algorithms that are used in malware:</p>
			<div><div><img src="img/Figure_4.27_B18500.jpg" alt="Figure 4.27 – Things to pay attention to when identifying the encryption algorithm&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.27 – Things to pay attention to when identifying the encryption algorithm</p>
			<p>To identify an encryption function, there are four things you should be searching for, as shown in the following table:</p>
			<div><div><img src="img/Table__4.01_B18500.jpg" alt=""/>
				</div>
			</div>
			<p>These four points <a id="_idIndexMarker630"/>are the core parts of any encryption<a id="_idIndexMarker631"/> loop. They can easily be spotted in a small encryption loop but may be harder to spot in a more complicated encryption loo<a id="_idTextAnchor361"/>p such as RC4 encryption, which we will discuss later<a id="_idTextAnchor362"/>.</p>
			<h2 id="_idParaDest-148"><a id="_idTextAnchor363"/>String search detection techniques for simple algorithms</h2>
			<p>In this section, we<a id="_idIndexMarker632"/> will be looking into a technique<a id="_idIndexMarker633"/> called <strong class="bold">X-RAYING</strong> (first introduced by Peter Ferrie in the <em class="italic">PRINCIPLES AND PRACTISE OF X-RAYING</em> article in VB2004). This technique is used by antivirus products and other static signature tools to detect samples with signatures, even if they are encrypted. This technique can dig under the encryption layers to reveal the sample code and detect it without knowing the encryption key in the first place and without incorporating time-consuming techniques such as brute-forcing. Here, we will describe the theory and the applications of this technique, as well as some of the tools we can use to help us use it. We may use this technique to det<a id="_idTextAnchor364"/>ect embedded PE <a id="_idIndexMarker634"/>files or decrypt malicious samp<a id="_idTextAnchor365"/>les.</p>
			<h3>The basics of X-RAYING</h3>
			<p>For the types of <a id="_idIndexMarker635"/>algorithms that we described earlier, if you have the encrypted data, the encryption algorithm, and the secret key, you can easily decrypt the data (which is the purpose of all encryption algorithms); however, if you have the encrypted data (ciphertext) and a piece of the decrypted data, can you still decrypt the remaining parts of the encrypted data?</p>
			<p>In X-RAYING, you can brute-force the algorithm and its secret key(s) if you have a piece of decrypted data (plaintext), even if you don’t know the offset of this plain text data in the whole encrypted blob. It works on almost all the simple algorithms that we described earlier, even with multiple layers of encry<a id="_idTextAnchor366"/>ption. For most of the encrypted PE files, the plain text includes strings such as <code>This program cannot run in DOS mode</code> or <code>kernel32.dll</code>, as well as arrays of null bytes. </p>
			<p>First of all, we will choose the first candidate to be an encryption algorithm, for example, XOR. Then, we will search for a part of the plain text inside ciphertext. To do that, we will use a part of the expected plain text to XOR it against the ciphertext, for example, a 4-byte string. The result of XORing will give us a candidate decryption key (a property of the XOR algorithm). Then, we will test this key with the remaining plain text. If this key works, it will reveal the remaining plain text of the ciphertext, which means<a id="_idTextAnchor367"/> that we will have found the secret key and can decrypt the remaining data.</p>
			<p>Now, let’s talk about various tools that may help us speed up this pr<a id="_idTextAnchor368"/><a id="_idTextAnchor369"/><a id="_idTextAnchor370"/>ocess.</p>
			<h3>X-RAYING tools for malware analysis and detection</h3>
			<p>Some tools have <a id="_idIndexMarker636"/>been <a id="_idIndexMarker637"/>written to help malware researchers use the X-RAYING technique for scanning. The following are some of these tools that you can use, either from the command line or by using a script:</p>
			<ul>
				<li><code>rol</code> and <code>ror</code> instructions):</li>
			</ul>
			<div><div><img src="img/Figure_4.28_B18500.jpg" alt="Figure 4.28 – The XORSearch UI&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.28 – The XORSearch UI</p>
			<ul>
				<li><code>xor</code> signatures:</li>
			</ul>
			<div><div><img src="img/Figure_4.29_B18500.jpg" alt="Figure 4.29 – Example of using a YARA signature&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.29 – Example of using a YARA signature</p>
			<p>For more advanced X-RAYING techniques, you may need to write a small script to sc<a id="_idTextAnchor371"/>an with ma<a id="_idTextAnchor372"/>nually.</p>
			<h2 id="_idParaDest-149"><a id="_idTextAnchor373"/>Identifying the RC4 encryption algorithm</h2>
			<p>The RC4 algorithm <a id="_idIndexMarker640"/>is one of the most common encryption algorithms that is used by malware authors, mainly because it is simple and, at the same time, strong enough to not be broken like other simple encryption algorithms. Malware authors generally implement it manually instead of relying on WinAPIs, which makes it harder for novice reverse engineers to identify. In this section, we <a id="_idIndexMarker641"/>will see what this algorithm looks lik<a id="_idTextAnchor374"/>e and how you can<a id="_idTextAnchor375"/> spot it.</p>
			<h3>The RC4 encryption algorithm</h3>
			<p>The RC4 algorithm<a id="_idIndexMarker642"/> is a symmetric stream algorithm that consists of two parts: a <strong class="bold">key-scheduling algorithm</strong> (<strong class="bold">KSA</strong>) and a <strong class="bold">pseudo-random generation algorithm </strong>(<strong class="bold">PRGA</strong>). Let’s have a look at each <a id="_idTextAnchor376"/>of them in great<a id="_idTextAnchor377"/>er detail.</p>
			<h3>The key-scheduling algorithm</h3>
			<p>The key-scheduling <a id="_idIndexMarker643"/>part of the <a id="_idIndexMarker644"/>algorithm creates an array of 256 bytes called an <code>S</code> array from the secret key. This array will be used to initialize the stream key generator. This consists of two parts:</p>
			<ul>
				<li>It creates an <code>S</code> array with values from <code>0</code> to <code>256</code> sequentially:<pre>for i from 0 to 255
  S[i<a id="_idTextAnchor378"/>] := i
endfor</pre></li>
				<li>It permutates the <code>S</code> array using key material:<pre>for i from 0 to 255
  j := (j + S[i] + key[i mod keylength]) mod 256
  swap values of S[i] and S[j]
endfor</pre></li>
			</ul>
			<p>Once this initiation part for the key is done, the decryption algorithm starts. In most cases, the KSA part is written in a separate function that takes only the secret key as <a id="_idTextAnchor379"/>an argument, without the data that needs to be encrypted o<a id="_idTextAnchor380"/>r decrypted.</p>
			<h3>Pseudo-random generation algorithm (PRNG)</h3>
			<p>The pseudo-random <a id="_idIndexMarker645"/>generation<a id="_idIndexMarker646"/> part of the algorithm just generates pseudo-random values (again, based on swapping bytes, as we did for the <code>S</code> array), but also performs an XOR operation with the generated value and a byte from the data:</p>
			<pre class="source-code">
i := 0
j := 0
while GeneratingOutput:
  i := (i + 1) mod 256
  j := (j + S[i]) mod 256
  swap values of S[i] and S[j]
  K := S[(S[i] + S[j]) mod 256]
  Data[i] = Data[i] xor K
endwhile</pre>
			<p>As you can see, the actual encryption algorithm that was used was <code>xor</code>. However, all<a id="_idTextAnchor381"/> this swapping aims to generate a different key value every single time (similar to sliding ke<a id="_idTextAnchor382"/>y algorithms).</p>
			<h3>Identifying RC4 algorithms in a malware sample</h3>
			<p>To identify <a id="_idIndexMarker647"/>an RC4 algorithm, some key characteristics can help you detect it:</p>
			<ul>
				<li><code>RC4</code> algorit<a id="_idTextAnchor383"/>hm like this:</li>
			</ul>
			<div><div><img src="img/Figure_4.30_B18500.jpg" alt="Figure 4.30 – Array generation in the RC4 algorithm&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.30 – Array generation in the RC4 algorithm</p>
			<ul>
				<li><strong class="bold">There’s lots of swapping</strong>: If you can recognize the swapping function or code, you will find it everywhere in the RC4 algorithm. The KSA and PRGA parts of the algorithm are a good sign that it is an RC4 algorithm:</li>
			</ul>
			<div><div><img src="img/Figure_4.31_B18500.jpg" alt="Figure 4.31 – Swapping in the RC4 algorithm&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.31 – Swapping in the RC4 algorithm</p>
			<ul>
				<li><strong class="bold">The actual algorithm is XOR</strong>: At the end of a loop, you will notice that this algorithm<a id="_idIndexMarker648"/> is an XOR algorithm. All the swapping is done on the key. The only changes that affect the data are done through XOR:</li>
			</ul>
			<div><div><img src="img/Figure_4.32_B18500.jpg" alt="Figure 4.32 – The XOR operation in the RC4 algorithm&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.32 – The XOR operation in the<a id="_idTextAnchor384"/> RC4 algorithm</p>
			<ul>
				<li><strong class="bold">Encryption and decryption similarity</strong>: You will also notice that the encryption and the decryption functions are the same functions. The XOR logical gate is reversible. You can encrypt the data with XOR and the secret key and decrypt this <a id="_idIndexMarker649"/>encrypted data with XOR and the same key (which is different fr<a id="_idTextAnchor385"/>om the add/sub algorithms, for example).</li>
			</ul>
			<p>Now, it is time to talk about more compl<a id="_idTextAnchor386"/>ex algorithms.</p>
			<h1 id="_idParaDest-150"><a id="_idTextAnchor387"/>Advanced symmetric and asymmetric encryption algorithms</h1>
			<p>Standard encryption <a id="_idIndexMarker650"/>algorithms such as symmetric DES<a id="_idIndexMarker651"/> and AES or asymmetric RSA are widely used by malware authors. However, the vast majority of samples that include these algorithms never implement these algorithms themselves or copy their code into their malware. They are generally implemented using Windows APIs.</p>
			<p>These algorithms are mathematically more complicated than simple encryption algorithms or RC4. While you don’t necessarily need to understand their mathematical background to understand how they are implemented, it is important to know how to identify the way they can be used and how to figure out the exact algorit<a id="_idTextAnchor388"/>hm involved, the encryption/decryption key(s<a id="_idTextAnchor389"/>), and the data.</p>
			<h2 id="_idParaDest-151"><a id="_idTextAnchor390"/>Extracting information from Windows cryptography APIs</h2>
			<p>Some <a id="_idIndexMarker652"/>common APIs are used to provide access to cryptographic algorithms, including DES, AES, RSA, and even RC4 encryption. Some of these APIs are <code>CryptAcquireContext</code>, <code>CryptCreateHash</code>, <code>CryptHashData</code>, <code>CryptEncrypt</code>, <code>CryptDecrypt</code>, <code>CryptImportKey</code>, <code>CryptGenKey</code>, <code>CryptDestroyKey</code>, <code>CryptDestroyHash</code>, and <code>CryptReleaseContext</code> (from <code>Advapi32.dll</code>).</p>
			<p>Here, we will take a look at the steps malware has to go through to encrypt or decrypt its data using any of these algorithms and how to identify the exact algorithm that’s used, as well <a id="_idIndexMarker653"/>as the secret key.</p>
			<h3>Step 1 – initializing and connecting to the cryptographic service provider (CSP)</h3>
			<p>The cryptographic<a id="_idIndexMarker654"/> service provider is <a id="_idIndexMarker655"/>a library that implements cryptography-related APIs in Microsoft Windows. For the malware sample to initialize and use one of these providers, it executes the <code>CryptAcquireContext</code> API, as follows:</p>
			<pre class="source-code">
CryptAcquireContext(&amp;hProv,NULL,MS_STRONG_PROV,PROV_RSA_FULL,0);</pre>
			<p>You can find all the supported providers in your system in the registry in the following key:</p>
			<pre class="source-code">
HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Cryptograp<a id="_idTextAnchor391"/><a id="_idTextAnchor392"/>hy\Defaults\Provider</pre>
			<h3>Step 2 – preparing the key</h3>
			<p>There are two <a id="_idIndexMarker656"/>ways to prepare the encryption key. As you may know, the encryption keys for these algorithms are usually of a fixed size. Here are the steps that malware authors commonly take to prepare the key:</p>
			<ol>
				<li value="1">First, the author uses their plain text key and hashes it using any of the known hashing algorithms, such as <code>MD5</code>, <code>SHA128</code>, <code>SHA256</code>, or others:<pre>CryptCreateHash(hProv,CALG_MD5,0,0,&amp;hHash); CryptHashData(hHash,secretkey,secretkeylen,0);</pre></li>
				<li>Then, they create a session key from this hash using <code>CryptDeriveKey</code>, like so:<pre>CryptDeriveKey(hProv, CALG_3DES, hHash, 0, &amp;hKey);</pre></li>
			</ol>
			<p>From here, they can easily identify the algorithm from the second argument value that’s provided to this API. The most common algorithms/values are as follows:</p>
			<pre>CALG_DES = 0x00006601  // DES encryption algorithm.
CALG_3DES = 0x00006603 // Triple DES encryption algorithm.
CALG_AES = 0x00006611  // Advanced Encryption Standard (AES).
CALG_RC4 = 0x00006801   // RC4 stream encryption algorithm.
CALG_RSA_KEYX = 0x0000a400 // RSA public key exchange algorithm.</pre>
			<ol>
				<li value="3">Some malware authors use a <code>KEYBLOB</code>, which includes their key, along with <code>CryptImportKey</code>. A <code>KEYBLOB</code> is a simple structure that contains the key type, the algorithm that was used, and the secret key for encryption. The structure <a id="_idIndexMarker657"/>of a <code>KEYBLOB</code> is as follows:<pre>typedef struct KEYBLOB { BYTE bType;
BYTE bVersion; WORD reserved; ALG_ID aiKeyAlg; DWORD KEYLEN;
BYTE[] KEY;}</pre></li>
			</ol>
			<p>The <code>bType</code> phrase represents the type of this key. The most common types are as follows:</p>
			<ul>
				<li><code>PLAINTEXTKEYBLOB (0x8)</code>: States a plain text key for a symmetric algorithm, such as <code>DES</code>, <code>3DES</code>, or <code>AES</code></li>
				<li><code>PRIVATEKEYBLOB (0x7)</code>: States that this key is the private key of an asymmetric algorithm</li>
				<li><code>PUBLICKEYBLOB (0x6)</code>: States that this key is the public key of an asymmetric algorithm</li>
			</ul>
			<p>The <code>aiKeyAlg</code> phrase includes the type of the algorithm as the second argument of <code>CryptDeriveKey</code>. Some examples of this <code>KEYBLOB</code> are as follows:</p>
			<pre class="source-code">
BYTE DesKeyBlob[] = { 0x08,0x02,0x00,0x00,0x01,0x66,0x00,0x00, // BLOB header 0x08,0x00,0x00,0x00, // key length, in bytes
0xf1,0x0e,0x25,0x7c,0x6b,0xce,0x0d,0x34 // DES key with parity
};</pre>
			<p>As you can see, the first byte (<code>bType</code>) shows us that it’s a <code>PLAINTEXTKEYBLOB</code>, while the algorithm (0x01,0x66) represe<a id="_idTextAnchor393"/>nts <code>CALG_DES (0x6601)</code>.</p>
			<p>Another<a id="_idIndexMarker658"/> example of this is as follows:</p>
			<pre class="source-code">
BYTE rsa_public_key[] = {
0x06, 0x02, 0x00, 0x00, 0x00, 0xa4, 0x00, 0x00,
0x52, 0x53, 0x41, 0x31, 0x00, 0x08, 0x00, 0x00,
...
}</pre>
			<p>This represents a <code>PUBLICKEYBLOB (0x6)</code>, while the algorithm represents <code>CALG_RSA_KEYX (0xa400)</code>. After that, they are loaded via <code>CryptImportKey</code>:</p>
			<pre class="source-code">
CryptImportKey(akey-&gt;prov, (BYTE *) &amp;key_blob, sizeof(key_blob), 0, 0, &amp;akey-&gt;ckey)</pre>
			<p>Here is an example of how this looks in assembly:</p>
			<div><div><img src="img/Figure_4.33_B18500.jpg" alt="Figure 4.33 – The CryptImportKey API is being used to import an RSA key&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.33 – The CryptImportKey API is being used to import an RSA key</p>
			<p>Once the<a id="_idIndexMarker659"/> key is ready, it can be used for encryption a<a id="_idTextAnchor394"/><a id="_idTextAnchor395"/>nd decryption purposes.</p>
			<h3>Step 3 – encrypting or decrypting the data</h3>
			<p>Now that the <a id="_idIndexMarker660"/>key is ready, the malware uses <code>CryptEncrypt</code> or <code>CryptDecrypt</code> to encrypt or decrypt the data, respectively. With these APIs, you can identify the start of the encrypted blob (or the blob to be encrypted). These APIs are used like this:</p>
			<pre class="source-code">
CryptEncrypt(hKey,NULL,1,0,cyphertext,ctlen,sz); CryptDecrypt(hKey,NUL<a id="_idTextAnchor396"/><a id="_idTextAnchor397"/>L,1,0,plaintext,&amp;ctlen);</pre>
			<h3>Step 4 – freeing the memory</h3>
			<p>This is the last step, where <a id="_idIndexMarker661"/>we free the memory and all the handles that have been used by using <a id="_idTextAnchor398"/><a id="_idTextAnchor399"/>the <code>CryptDestroyKey</code> APIs.</p>
			<h2 id="_idParaDest-152"><a id="_idTextAnchor400"/>Cryptography API: Next Generation (CNG)</h2>
			<p>There are other <a id="_idIndexMarker662"/>ways to implement these encryption algorithms. One of them is by using <strong class="bold">Cryptography API: Next Generation</strong> (<strong class="bold">CNG</strong>), which is a new set of APIs that has been implemented by Microsoft. Still not widely used in malware, they are much easier to understand and extract information from. The steps<a id="_idIndexMarker663"/> for using them are as follows:</p>
			<ol>
				<li value="1"><code>MSDN</code> for the list of supported algorithms):<pre>BCryptOpenAlgorithmProvider(&amp;hAesAlg, BCR<a id="_idTextAnchor401"/>YPT_AES_ALGORITHM, NULL, 0)</pre></li>
				<li><strong class="bold">Prepare the key</strong>: This is different from preparing a key in symmetric and asymmetric algorithms. This API may use an imported key or generate a key. This can help you extract the secret key that’s used for encryption, like so:<pre>BCryptGenerateSymmetricKey(hAesAlg, &amp;hKey, pbKeyObject, cbKeyObject, (PBYTE)SecretKey, sizeof(SecretKey), 0)</pre></li>
				<li><strong class="bold">Encrypt or decrypt data</strong>: In this step, you can easily identify the start of the data blob to be encrypted (or decrypted):<pre>BCryptEncrypt(hKey, pbPlainText, cbPlainText, NULL, pbIV, cbBlockLen, NULL, 0, &amp;cbCipherText, BCRYPT_BLOCK_PADDING)</pre></li>
				<li><code>BCryptCloseAlgorithmProvider</code>, <code>BCrypt<a id="_idTextAnchor402"/>DestroyKey</code>, and <code>HeapFree</code> to clean up the data.</li>
			</ol>
			<p>Now, let’s see <a id="_idIndexMarker664"/>how all this knowledge will help us underst<a id="_idTextAnchor403"/>and malware’s functionality.</p>
			<h1 id="_idParaDest-153"><a id="_idTextAnchor404"/>Applications of encryption in modern malware – Vawtrak banking Trojan</h1>
			<p>In this chapter, we <a id="_idIndexMarker665"/>have seen how encryption or packing is used to protect the whole malware. Here, we will look at other implementations of these encryption algorithms inside the malware code for obfuscation and for hiding malicious key characteristics. These key characteristics can be used to identify the malware family using static signatures or even network signatures.</p>
			<p>In this section, we will take a look at a known banking trojan called Vawtrak. We will see how this malware <a id="_idIndexMarker666"/>family encrypts its strings and API names and obfusc<a id="_idTextAnchor405"/><a id="_idTextAnchor406"/><a id="_idTextAnchor407"/>ates its network communication.</p>
			<h2 id="_idParaDest-154"><a id="_idTextAnchor408"/>String and API name encryption</h2>
			<p>Vawtrak<a id="_idIndexMarker667"/> implements <a id="_idIndexMarker668"/>a quite simple encryption algorithm. It’s based on sliding key algorithm principles and uses subtraction as its main encryption technique. Its encryption looks like this:</p>
			<div><div><img src="img/Figure_4.34_B18500.jpg" alt="Figure 4.34 – Encryption loop in the Vawtrak malware&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.34 – Encryp<a id="_idTextAnchor409"/>tion loop in the Vawtrak malware</p>
			<p>The <a id="_idIndexMarker669"/>encryption<a id="_idIndexMarker670"/> algorithm consists of two parts:</p>
			<ul>
				<li><strong class="bold">Generating the next key</strong>: This generates a 4-byte number (called a seed) and uses only 1 byte of it as a key:<pre>seed = ((seed * 0x41C64E6D) + 0x3039 ) &amp; 0xFFFFFFFF key = seed &amp; 0xFF</pre></li>
				<li><strong class="bold">Encrypting the data</strong>: This part is very simple as it encrypts the data using the following logic:<pre>data[i] = data[i] - eax</pre></li>
			</ul>
			<p>This encryption algorithm is used to encrypt API names and DLL names so that after decryption, the malware can load the DLL dynamically using an API called <code>LoadLibrary</code>, which loads a library if it wasn’t loaded or just gets its handle if it’s already loaded.</p>
			<p>After getting the DLL address, the malware gets the API address to execute using an API called <code>GetProcAddress</code>, which gets this function address by the handle for the library and the API<a id="_idIndexMarker671"/> name. The<a id="_idIndexMarker672"/> malware implements it as follows:</p>
			<div><div><img src="img/Figure_4.35_B18500.jpg" alt="Figure 4.35 – Resolving API names in the Vawtrak malware&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.35 – Resolvin<a id="_idTextAnchor410"/>g API names in the Vawtrak malware</p>
			<p>The same function (<code>DecryptString</code>) is used a lot inside the malware to decrypt each string on demand (only when it’s being used), as follows:</p>
			<div><div><img src="img/Figure_4.36_B18500.jpg" alt="Figure 4.36 – The xrefs to decryption routine in Vawtrak malware&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.36 – The xrefs to decryption routine in Vawtrak malware</p>
			<p>To decrypt this, you need to go through each call to the decrypt function being called and pass the address of the encrypted string to decrypt it. This may be exhausting or time-consuming, so<a id="_idIndexMarker673"/> automation (for example, using IDA <a id="_idIndexMarker674"/>Python or a scriptable debugger/emulator) could help,<a id="_idTextAnchor411"/><a id="_idTextAnchor412"/><a id="_idTextAnchor413"/> as we will see in the next section.</p>
			<h2 id="_idParaDest-155"><a id="_idTextAnchor414"/>Network communication encryption</h2>
			<p>Vawtrak can <a id="_idIndexMarker675"/>use different <a id="_idIndexMarker676"/>encryption algorithms to encrypt its network communications. It implements multiple algorithms, including <code>RC4</code>, <code>LZMA</code> compression, the <code>LCG</code> encryption algorithm (this is used with strings, as we mentioned in the previous section), and others. In this section, we will take a look at the different parts of its encryption.</p>
			<p>Inside the requests, it has implemented some encryption to hide basic information, including <code>CAMPAIGN_ID</code> and <code>BOT_ID</code>, as shown in the following screenshot:</p>
			<div><div><img src="img/Figure_4.37_B18500.jpg" alt="Figure 4.37 – The network traﬃc of the Vawtrak malware&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.37 – The network traﬃc of the Vawtrak malware</p>
			<p>The cookie, or <code>PHPSESSID</code>, included an encryption key. The encryption algorithm that was used was RC4 encryption. Here is the message after decryption:</p>
			<div><div><img src="img/Figure_4.38_B18500.jpg" alt="Figure 4.38 – Extracted information from the network traﬃc of the Vawtrak malware&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Figure">Figure 4.38 – Extracted information from the <a id="_idTextAnchor415"/>network traﬃc of the Vawtrak malware</p>
			<p>The decrypted <code>PHPSESSID</code> includes the RC4 key in the first 4 bytes. <code>BOT_ID</code> and the next byte represent <code>Campaign_Id</code> (0x03), while the remaining ones represent some other important information.</p>
			<p>The data that’s received is in the following structure and includes the first seed that will be used in decryption, the total size, and multiple algorithms that are used to decrypt them:</p>
			<div><div><img src="img/Figure_4.39_B18500.jpg" alt="Figure 4.39 – The structure that’s used for decryption in the Vawtrak malware&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.39 – The structure that’s used for decryption in the Vawtrak malware</p>
			<p>Unfortunately, with network communication, there’s no simple way to grab the algorithms that were used or the protocol’s structure. You have to search for network communication<a id="_idIndexMarker677"/> functions <a id="_idIndexMarker678"/>such as <code>HttpAddRequestHeadersA</code> (the one we saw in the decryption process earlier) and other network APIs and trace the data that was received, as well as trace the data that’s going to be sent, until you find the alg<a id="_idTextAnchor416"/>orithms and the structure behind the command-and-control communication.</p>
			<p>Now, let’s explore various capabilities of IDA that may help us understand and circumvent the encrypt<a id="_idTextAnchor417"/>ion and packing techniques involved.</p>
			<h1 id="_idParaDest-156"><a id="_idTextAnchor418"/>Using IDA for decryption and unpacking</h1>
			<p>IDA is a very<a id="_idIndexMarker679"/> convenient tool for storing the markup of analyzed samples. Its embedded debuggers and several remote debugger server applications allow you to perform both static and dynamic analysis in one place for multiple platforms – even the ones where IDA can’t be executed on its own. It also has multiple plugins that can extend its functionality even further, as well as embedded script languages<a id="_idIndexMarker680"/> th<a id="_idTextAnchor419"/><a id="_idTextAnchor420"/><a id="_idTextAnchor421"/>at can automate various tedious tasks.</p>
			<h2 id="_idParaDest-157"><a id="_idTextAnchor422"/>IDA tips and tricks</h2>
			<p>While OllyDbg<a id="_idIndexMarker681"/> provides pretty decent functionality in terms of debugging, generally, IDA has more options for maintaining the markup. This is why many reverse engineers tend to do both static and dynamic analysis there, which is particularly useful in terms of unpacking. Here are some tips and tricks that<a id="_idTextAnchor423"/> will make this process more enjoyable.</p>
			<h3>Static analysis</h3>
			<p>First, let’s look at <a id="_idIndexMarker682"/>some recommendations that are mainly <a id="_idIndexMarker683"/>applicable to static analysis:</p>
			<ul>
				<li>When working with the memory dump rather than the original sample, it may happen that the import table has already been populated with APIs’ addresses.</li>
			</ul>
			<p>The easy way to get the actual API names is to use the <code>pe_dlls.idc</code> script, which is distributed in the <code>pe_scripts.zip</code> package. This is available for free on the official IDA website. From there, you need to load the required DLLs from the machine where the dump was made. When specifying the DLL name, don’t forget to remove the filename extension as a dot symbol can’t be used in names in IDA. In addition, the script won’t allow you to select the base address for the DLL. To fix that, add the following code at line 692 of the <code>pe_sections.idc</code> script:</p>
			<pre>imageBase = long(ask_addr(imageBase, “Enter base address”));</pre>
			<ul>
				<li>It generally makes sense to recreate structures that are used by malware in IDA’s <strong class="bold">Structures</strong> tab rather than adding comments throughout the disassembly, next to the instructions that are accessing their fields by offsets. Keeping track of structures is a much less error-prone approach and means that we can reuse them for similar samples, as well as for comparing different versions of malware.</li>
			</ul>
			<p>After this, you can simply right-click on the value and select the <strong class="bold">Structure offset</strong> option (the <em class="italic">T</em> hotkey). A structure can be quickly added by pressing the <em class="italic">Ins</em> hotkey in the <strong class="bold">Structures</strong> sub-view and specifying its name. Then, a single field can be added by putting your cursor at the end of the structure and pressing the <em class="italic">D</em> hotkey one, two, or three times, depending on the size that’s required. Finally, to add the rest of the fields that have the same size, select the required field, right-click and choose the <strong class="bold">Array...</strong> option, specify the required number of elements that have the same size, and remove the ticks in the checkboxes for the <strong class="bold">Use “du<a id="_idTextAnchor424"/>p” construct</strong> and <strong class="bold">Create as array</strong> options.</p>
			<ul>
				<li>For cases where the malware accesses fields of a structure stored in the stack, it is possible to <a id="_idIndexMarker684"/>get the actual offsets by right-clicking and<a id="_idIndexMarker685"/> selecting the <strong class="bold">Manual...</strong> option (the <em class="italic">Alt</em> + <em class="italic">F1</em> hotkeys) on the variable, replacing the variable name with the name of the pointer at the beginning of the structure and remaining offset, and then replacing the offset with the required structure field, as shown in the following screenshot:</li>
			</ul>
			<div><div><img src="img/Figure_4.40_B18500.jpg" alt="Figure 4.40 – Mapping a local variable to the corresponding structure ﬁeld&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.40 – Mapping a local variable to the corresponding structure ﬁeld</p>
			<p>Make sure that the <strong class="bold">Check operand</strong> option is enabled when renaming the operand to verify that the total sum of values remains accurate.</p>
			<p>Another option is to select the text of the variable (not just left-click on it), right-click the <strong class="bold">Structure offset</strong> option (again, the <em class="italic">T</em> hotkey), specify the offset delta value, which should be equal to the offset of the pointer at the beginning of the structure, and finally se<a id="_idTextAnchor425"/>lect the structure field that’s suggested.</p>
			<p>This method is quicker but doesn’t preserve the name of the pointer, as shown in the <a id="_idIndexMarker686"/>following <a id="_idIndexMarker687"/>screenshot:</p>
			<div><div><img src="img/Figure_4.41_B18500.jpg" alt="Figure 4.41 – Another way to map a local variable to the structure ﬁeld&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.41 – Another way to map a local variable to the structure ﬁeld</p>
			<ul>
				<li>Many custom encryption algorithms incorporate the <code>xor</code> operation, so the easy way to find them is by following these steps:<ol><li>Open the <code>xor</code> in the <code>xor</code> instructions that incorporate two different registers or a value in memory that is not accessed using the frame pointer register (<code>ebp</code>).</li></ol></li>
				<li>Don’t hesitate to<a id="_idIndexMarker688"/> use<a id="_idIndexMarker689"/> free<a id="_idIndexMarker690"/> plugins such as <code>–v</code> command-line argument to get the virtual addresses of identified functions.</li>
				<li>If you need to import a C file with a list of definitions as enums, it is recommended that you use the <code>h2enum.idc</code> script (don’t forget to provide a correct mask in the second dialog window). When importing C files with structures, it generally makes sense to prepend them with a <code>#pragma pack(1)</code> statemen<a id="_idIndexMarker692"/>t to keep offsets correct. Both <a id="_idIndexMarker693"/>the <strong class="bold">File </strong>| <strong class="bold">Load file </strong>| <strong class="bold">Parse C header file...</strong> option<a id="_idIndexMarker694"/> and the <strong class="bold">T<a id="_idTextAnchor426"/>ilib</strong> tool can be used pretty much interchangeably.</li>
				<li>If you need to rename multiple consequent values that are pointing to the actual APIs in the populated import table, select all of them and execute the <code>renimp.idc</code> script, which can be found in IDA’s <code>idc</code> directory.</li>
				<li>If you need to have both <code>IDA &lt;= 6.95</code> and <code>IDA 7.0+</code> together on one Windows machine, do the following:<ol><li value="1">Install both x86 and x64 Python to different locations – for example, <code>C:\Python27 </code>and <code>C:\Python27x64</code>.</li><li>Make sure that the following environment variables point to the setup for <code>IDA &lt;= 6.95</code>:</li></ol><pre>set PYTHONPATH=C:\Python27;C:\Python27\Lib;C:\Python27\DLLs;C:\Python27\Lib\lib-tk;
set NLSPATH=C:\IDA6.95\</pre></li>
			</ul>
			<p>By doing this, <code>IDA &lt;= 6.95</code> can be used as usual by clicking on its icon. To execute IDA 7.0+, create a special <code>LNK</code> file that will redefine these environment variables before executing IDA:</p>
			<pre>C:\Windows\System32\cmd.exe /c “SET PYTHONPATH=C:\Python27x64;C:\Python27x64\Lib;C:\Python27x64\DLLs;C:\Python27x64\Lib\lib-tk; &amp;&amp; SET NLSPATH=C:\IDA7.0 &amp;&amp; START /D ^”C:\IDA7.0^” ida.exe”</pre>
			<ul>
				<li>If your IDA version is shipped without FLIRT signatures for the Delphi programming language, it is still possible to mark them using an IDC script generated by<a id="_idIndexMarker695"/> the <strong class="bold">IDR</strong> tool. It is recommended to apply only names from the scripts that it produces.</li>
				<li>Recent versions of IDA provide decent support for the programs written in the Go<a id="_idIndexMarker696"/> language. For <a id="_idIndexMarker697"/>older versions of IDA, you <a id="_idIndexMarker698"/>should use<a id="_idIndexMarker699"/> plugins such as <strong class="bold">golang_loader_assist</strong> and <strong class="bold">IDAGolangHelper</strong>.</li>
				<li>To handle variable extension obfuscation, if the IDA Hex-Rays decompiler is available, use the <strong class="bold">D-810</strong> plugin based on the <strong class="bold">Z3</strong> project. Here is what its interface looks like:</li>
			</ul>
			<div><div><img src="img/Figure_4.42_B18500.jpg" alt="Figure 4.42 – Deobfuscation rules supported by the D-810 plugin&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.42 – Deobfuscation rules supported by the D-810 plugin</p>
			<ul>
				<li>Often, malware samples come with open source libraries such as OpenSSL that are statically <a id="_idIndexMarker700"/>linked to take advantage of the properly<a id="_idIndexMarker701"/> implemented encryption algorithms. Analyzing such code can be quite tricky, as it may not be immediately obvious which part of the code belongs to malware and which part belongs to the legitimate library. In addition, it may take a reasonable amount of time to figure out the purpose of each function within the library itself. Open source projects such <a id="_idIndexMarker702"/>as <code>.lib</code>/<code>.a</code> file for OpenSSL for the required platform (in our case, this is Windows). The compiler should be as close to the one that was used by the malware as possible.</li><li>Get <strong class="bold">Flair</strong> utilities for your IDA from the official website. This package contains a set of tools for generating unified PAT files from various object and library fo<a id="_idTextAnchor427"/>rmats (OMF, COFF, and so on), as <a id="_idIndexMarker704"/>well as the <strong class="bold">sigmake</strong> tool.</li><li>Generate PAT files, for example, by <a id="_idIndexMarker705"/>using the <strong class="bold">pcf</strong> tool:</li></ol><pre><strong class="bold">pcf libcrypto.a libcrypto.pat</strong></pre></li>
			</ul>
			<ol>
				<li value="4">Use <code>.sig</code> files:</li>
			</ol>
			<pre><strong class="bold">sigmake libcrypto.pat libcrypto.sig</strong></pre>
			<p>If necessary, resolve collisions by editing the <code>.exc</code> file that was created and rerun <code>sigmake</code>.</p>
			<ol>
				<li value="5">Place the resulting <code>.sig</code> file in the <code>sig</code> folder of the IDA root directory.</li>
				<li>Follow these steps to learn how to use it:<ol><li>Go to <strong class="bold">View</strong> | <strong class="bold">Open</strong><strong class="bold"> subviews</strong> | <strong class="bold">Signatures</strong> (the <em class="italic">Shift</em> + <em class="italic">F5</em> hotkey).</li><li>Right-click <strong class="bold">Apply new signature</strong> (the <em class="italic">Ins</em> hotkey).</li><li>Find the signature with the name you specified and confirm it by pressing <strong class="bold">OK</strong> or double-clicking on it.</li><li>Another way to do this is by using the <strong class="bold">File</strong> | <strong class="bold">Load file</strong> | <strong class="bold">FLIRT signature file...</strong> option.</li></ol></li>
			</ol>
			<p>Another<a id="_idIndexMarker707"/> popular <a id="_idIndexMarker708"/>option for creating custom FLIRT <a id="_idIndexMarker709"/>signatures <a id="_idIndexMarker710"/>is the <strong class="bold">idb2pat</strong> tool.</p>
			<p>Now<a id="_idTextAnchor428"/>, let’s talk about IDA capabilities in terms of dynamic analysis.</p>
			<h3>Dynamic analysis</h3>
			<p>These days, apart<a id="_idIndexMarker711"/> from its classic disassembler<a id="_idIndexMarker712"/> capabilities, IDA features multiple debugging options. Here are some tips and tricks that aim to facilitate dynamic analysis in IDA:</p>
			<ul>
				<li>To debug samples in IDA, make sure that the sample has an executable file extension (for example, <code>.exe</code>); otherwise, older versions of IDA may refuse to execute it, saying that the file does not exist.</li>
				<li>Older versions of IDA don’t have the <code>win64_remotex64.exe</code> server application located in the IDA’s <code>dbgsrv</code> folder. It is possible to run it on the same machine if necessary and make them interact with each <a id="_idTextAnchor429"/>other via localhost using the <strong class="bold">Debugger </strong>| <strong class="bold">Process options...</strong> option.</li>
			</ul>
			<p>The graph view only shows graphs for recognized or created functions. It is possible to quickly switch between text and graph views using the spacebar hotkey. When debugging starts, the <strong class="bold">Graph overview</strong> window in the graph view may disappear, but it can be restored by selecting the <strong class="bold">View </strong>| <strong class="bold">Graph Overview </strong>option.</p>
			<ul>
				<li>By default, IDA<a id="_idIndexMarker713"/> runs an automatic analysis when it<a id="_idIndexMarker714"/> opens the file, which means that any code that’s unpacked later won’t be analyzed. To fix this dynamically, follow these steps:<ol><li value="1">If necessary, make the IDA recognize the entry point of the unpacked block as code by pressing the <em class="italic">C</em> hotkey. Usually, it also makes sense to make a function from it using the <em class="italic">P</em> hotkey.</li><li>Mark the memory segment that stores the unpacked code as a <strong class="bold">loader segment</strong>. Follow <a id="_idIndexMarker715"/>these steps to do this:<ol><li>Go to <strong class="bold">View</strong> | <strong class="bold">Open subviews</strong> | <strong class="bold">Segments</strong> (the <em class="italic">Shift</em> + <em class="italic">F7</em> hotkey combination).</li><li>Find the segment storing the code of interest.</li><li>Either right-click on it and select the <strong class="bold">Edit segment...</strong> option or use the <em class="italic">Ctrl</em> + <em class="italic">E</em> hotkey combination.</li><li>Put a tick in the <strong class="bold">Loader segment</strong> checkbox.</li></ol></li><li>Rerun the analysis by either going to <strong class="bold">Options</strong> | <strong class="bold">General...</strong> | <strong class="bold">Analysis</strong> and pressing the <strong class="bold">Reanalyze program</strong> button or right-clicking in the bottom-left corner of the main IDA window and selecting the <strong class="bold">Reanalyze program</strong> option there.</li></ol></li>
				<li>If you need to unpack a DLL, follow these steps:<ol><li value="1">Load it into IDA just like any other executable.</li><li>Choose your debugger of preference:<ul><li>Local Win32 debugger for 32-bit Windows</li><li>Remote Windows debugger with the <code>win64_remote64.exe</code> application for 64-bit Windows</li></ul></li><li>Go to <code>rundll32.exe</code> (or <code>regsvr32.exe</code> for COM DLL, which can be recognized by <code>DllRegisterServer/DllUnregisterServ<a id="_idTextAnchor430"/>er</code><em class="italic"> </em>or the <code>DllInstall</code> exports that are present) to the <strong class="bold">Application</strong> field.</li><li>Set the full path to the DLL in the <strong class="bold">Parameters</strong> field. Additional parameters will vary, depending on the type of DLL:</li></ul></li>
			</ul>
			<p>a. For a typical DLL that’s loaded using <code>rundll32.exe</code>, append either a name or a hash followed by the ordinal (for example, <code>#1</code>) of the export function you want to debug and separate it from the path by a comma. You have to provide an argument, even if you want to execute only the main entry point logic.</p>
			<p>b. For <code>CPlApplet</code> export, the <code>shell32.dll,Control_RunDLL</code> argument can be specified before the path to the analyzed DLL instead.</p>
			<p>c. For the COM DLLs that are generally loaded with the help of <code>regsvr32.exe</code>, the full path should be prepended with the <code>/u</code> argument in case the <code>DllUnregisterServer</code> export needs to be debugged. For a <code>DllInstall</code> export, a combination of <code>/n/i[:cmdline]</code> arguments should be used instead.</p>
			<p>d. If the DLL is a service DLL (generally, it can be recognized by the <code>ServiceMain</code> export function and services-related imports) and you need to properly debug <code>ServiceMain</code>, see <a href="B18500_03.xhtml#_idTextAnchor084"><em class="italic">Chapter 3</em></a>, <em class="italic">Basic Static and Dynamic Analysis for x86/x64</em>, for more details on how to debug services.</p>
			<ul>
				<li>Among other scripts that are useful for dynamic <a id="_idIndexMarker719"/>analysis, the <strong class="bold">funcap</strong> tool appears to be extremely handy as it allows you to record arguments that have been passed to functi<a id="_idTextAnchor431"/>ons during the execution process and keep them in comments once it’s done.</li>
				<li>If, after <a id="_idIndexMarker720"/>decryption, the malware constantly uses <a id="_idIndexMarker721"/>code and data from another memory segment (Trickbot is a good example), it is possible to dump these segments and then add them separately to the IDB using the <code>0</code> and specify the actual virtual address in the <code>0</code> instead, it is possible to f<a id="_idTextAnchor432"/>ix it by going to <strong class="bold">View</strong> | <strong class="bold">Open sub<a id="_idTextAnchor433"/>views</strong> | <strong class="bold">Selectors</strong> and changing the value of the associated selector to zero.</li>
			</ul>
			<h2 id="_idParaDest-158"><a id="_idTextAnchor434"/>Classic and new syntax of IDA scripts</h2>
			<p>Talking about <a id="_idIndexMarker722"/>scripting, the original way to write IDA scripts was to use a proprietary IDC language. It provides multiple high-level APIs that can be used in both static and dynamic analysis. Later, IDA started supporting Python and providing access to IDC functions with the same names under the <code>idc</code> module. Another functionality (generally, this is more low level) is available in the <code>idaapi</code> and <code>idautils</code> modules, but for automating most generic things, the <code>idc</code> module is good enough.</p>
			<p>Since the list of APIs has extended over time, more and more naming inconsistencies have been accumulated. Eventually, at some stage, it started requiring a revision, which would be impossible to implement while keeping it backward-compatible. As a result, starting from IDA version 7.0 (the next version after 6.95), a new list of APIs was introduced that affected plugins that relied on the SDK and IDC functions. Some of them were just renamed from <code>CamelCase</code> to <code>underscore_case</code>, while others were replaced with new ones.</p>
			<p>Here are some examples of them, showing both the original and new syntax:</p>
			<ul>
				<li><code>Functions/NextFunction</code>: <code>get_next_func</code> allows you to iterate through functions.</li><li><code>Heads/NextHead</code>: <code>next_head</code> allows you to iterate through instructions.</li><li><code>ScreenEA</code>: <code>get_screen_ea</code> gets a sample’s virtual address where the cursor is <a id="_idIndexMarker723"/>currently located.</li></ul></li>
				<li><code>Byte/Word/Dword</code>: <code>byte/word/dword</code> reads a value of a particular size.</li></ul></li>
				<li><code>PatchByte/PatchWord/PatchDword</code>: <code>patch_byte/patch_word/patch_dword</code> writes a block of a particular size.</li><li><code>OpEnumEx</code>: <code>op_enum</code> converts an operand into an <code>enum</code> value.</li></ul></li>
			</ul>
			<p><strong class="bold">Auxiliary data storage</strong>:</p>
			<ul>
				<li><code>AddEnum</code>: <code>add_enum</code> adds a new <code>enum.</code></li>
				<li><code>AddStrucEx</code>: <code>add_struc</code> adds a new structure.</li>
			</ul>
			<p>Here is an example of an IDA Python script implementing a custom XOR decryption algorithm for s<a id="_idTextAnchor436"/>hort blocks:</p>
			<div><div><img src="img/Figure_4.43_B18500.jpg" alt="Figure 4.43 – Original IDA Python API syntax for 32-bit Windows&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.43 – Original IDA Python API syntax for 32-bit Windows</p>
			<p>Here is a script<a id="_idIndexMarker724"/> implementing the same custom XOR decryption algorithm for a 64-bit architecture using the new syntax:</p>
			<div><div><img src="img/Figure_4.44_B18500.jpg" alt="Figure 4.44 – New IDA Python API syntax for 64-bit Windows&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.44 – New IDA Python API syntax for 64-bit Windows</p>
			<p>Some situations may require an enormous amount of time to analyze a relatively big sample (or several <a id="_idIndexMarker725"/>of them) if the engineer doesn’t use IDA scripting<a id="_idTextAnchor437"/><a id="_idTextAnchor438"/><a id="_idTextAnchor439"/> and malware is using dynamic string decryption and dynamic WinAPIs resolution.</p>
			<h2 id="_idParaDest-159"><a id="_idTextAnchor440"/>Dynamic string decryption</h2>
			<p>In this case, the <a id="_idIndexMarker726"/>block of encrypted strings is not <a id="_idIndexMarker727"/>decrypted at once. Instead, each string is decrypted immediately before being used, so they are never decrypted all at the same time. To solve this problem, follow these steps:</p>
			<ol>
				<li value="1">Find a function that’s responsible for decrypting all strings.</li>
				<li>Replicate the decryptor’s behavior in a script.</li>
				<li>Let the script find all the places in the code where this function is being called by following cross-references and read an encrypted string that will be passed as its argument.</li>
				<li>Dec<a id="_idTextAnchor441"/>rypt<a id="_idIndexMarker728"/> it and write <a id="_idTextAnchor442"/>it back on top of the<a id="_idIndexMarker729"/> encrypted one so that all the references will remain valid.</li>
			</ol>
			<h2 id="_idParaDest-160"><a id="_idTextAnchor443"/>Dynamic WinAPIs resolution</h2>
			<p>With the dynamic<a id="_idIndexMarker730"/> WinAPIs resolution, only <a id="_idIndexMarker731"/>one function with different arguments is used to get access to all the WinAPIs. It dynamically searches for the requested API (and often the corresponding DLL), usually using some sort of checksum of the name that’s provided as an argument. There are two common approaches to making this <a id="_idIndexMarker732"/>readable:</p>
			<ul>
				<li><code>enum</code> values.</li><li>Find all the places where the resolving function is being used, take its checksum argument, and convert it into the corresponding <code>enum</code> name.</li></ol></li>
				<li><strong class="bold">Using comments</strong>:<ol><li value="1"> Find the matches between all checksums, APIs, and DLLs used.</li><li>Store the associations in memory.</li><li>Find all the places where the resolving function is being used, take its checksum argument, and place a comment with the corresponding API name next to it.</li></ol></li>
			</ul>
			<p>IDA scripting is really what makes a difference and turns novice analysts into professionals who can efficiently solve any reverse engineering problem promptly. After you have written a few scripts using this approach, it becomes p<a id="_idTextAnchor444"/>retty straightforward to update or <a id="_idIndexMarker733"/>extend them with extra functionality for <a id="_idIndexMarker734"/>new tasks.</p>
			<h1 id="_idParaDest-161"><a id="_idTextAnchor445"/>Summary</h1>
			<p>In this chapter, we covered various types of packers and explained the differences between them. We also gave recommendations on how we can identify the packer that’s being used. Then, we went through several techniques of how to unpack samples both automatically and manually and provided real-world examples of how to do so in the most efficient way, depending on the context. After this, we covered advanced manual unpacking methods that generally take more time to execute but give you the ability to unpack virtually any sample in a meaningful time frame.</p>
			<p>Furthermore, we covered different encryption algorithms and provided guidelines on how to identify and handle them. Then, we went through a modern malware example that incorporated these guidelines so that you could get an idea of how all this theory can be applied in practice. Finally, we covered IDA script languages – a powerful way to drastically speed up the analysis process.</p>
			<p>In <a href="B18500_05.xhtml#_idTextAnchor446"><em class="italic">Chapter 5</em></a>, <em class="italic">Inspecting Process Injection and API Hooking</em>, we are going to expand our knowledge about various techniques that are used by malware authors to achieve their goals and provide a handful of tips on how to deal with them.</p>
		</div>
		<div><div></div>
		</div>
	</body></html>