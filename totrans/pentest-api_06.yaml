- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Error Handling and Exception Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, you were introduced to the art of injecting code into
    legitimate input fields for API endpoints. Some of these types of threats use
    old techniques but they are still quite prevalent. One of them consists of fuzzing
    the text that will be injected. This may cause the target endpoint to misbehave
    simply because it was not prepared to receive unusual or bizarre input texts.
    This happens because the API endpoint is not correctly handling errors or the
    code implementing it is not treating eventual exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, it is very important for API and application owners that both errors
    and exceptions are correctly tested and handled. And of course, you, as a pentester,
    cannot forget to add this to your testing notebook. Not only may vulnerabilities
    arise from bad error or exception handling. Valuable details on the infrastructure,
    such as frameworks, libraries, third-party software, operating system (including
    the kernel) version, and build number can be disclosed by an exception or an unforeseen
    error.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll begin this chapter by talking about some general error codes and messages
    and how you can easily identify them. Next, we will dive into fuzzing and how
    this can trigger some hidden vulnerabilities. Finally, we’ll learn how to leverage
    our research efforts to reveal the data we are looking for.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Identifying error codes and messages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fuzzing for exception handling vulnerabilities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leveraging error responses for information disclosure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we did for [*Chapter 5*](B19657_05.xhtml#_idTextAnchor078), we’ll leverage
    the same environment as the one pointed out in previous chapters. So, you’ll need
    a type 2 hypervisor, such as VirtualBox, and some Linux distribution, such as
    Ubuntu. Some other new relevant utilities will be mentioned in the corresponding
    sections.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying error codes and messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to learn about error codes and messages that can
    be provided by API endpoints when they are answering your requests. Error codes
    and messages are the cornerstones of effective API penetration testing. They act
    as a window into the API’s communication channels, revealing how they inform clients
    and users about issues encountered during request processing. By deciphering these
    messages, you can assess the strength and security of the API’s error-handling
    mechanisms. Scrutinizing error responses can expose potential security vulnerabilities
    such as information leaks, injection attacks, or weak input validation.
  prefs: []
  type: TYPE_NORMAL
- en: One obvious approach to uncover error codes and messages is by checking the
    API documentation. In [*Chapter 3*](B19657_03.xhtml#_idTextAnchor042), you learned
    about the importance of this stage of pentesting. Another approach is manual testing.
    Here, pentesters craft requests with deliberately malformed data or incorrect
    inputs, observing the resulting error responses. Analyzing the structure and content
    of these responses provides insights into how the API handles various error scenarios.
    For instance, sending a request with an invalid authentication token might trigger
    a *401 Unauthorized* response, signifying a failed authentication attempt. Manually
    inspecting such responses can unveil valuable information about the API’s security
    posture.
  prefs: []
  type: TYPE_NORMAL
- en: Automated testing tools, such as Burp Suite and OWASP ZAP, are powerful allies
    in identifying error codes and messages. These tools can capture API requests
    and responses, enabling systematic analysis of error messages. By automating the
    process of sending requests with diverse payloads and inputs, you can efficiently
    identify potential vulnerabilities in the API’s error-handling mechanism. For
    example, Burp Suite’s **Intruder** tool can be used to send multiple requests
    with varying parameters, while its proxy feature allows for real-time capture
    and analysis of error responses. We’ve used both.
  prefs: []
  type: TYPE_NORMAL
- en: Beyond the conventional HTTP status codes, error messages often include additional
    details, such as error codes, descriptions, or even stack traces. These details
    offer valuable insights into the nature and root cause of the error, facilitating
    further investigation and exploitation (from an ethical pentesting perspective,
    of course). You should keep a keen eye on these details as they may reveal vulnerabilities
    or misconfigurations within the API. An error message containing a stack trace,
    for instance, might expose sensitive information about the underlying infrastructure,
    such as server paths or database queries. Analyzing such information can help
    you identify potential attack vectors and assess the severity of the vulnerability.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, you can leverage parameter manipulation techniques to evoke specific
    error responses from the API. By modifying request parameters such as input data
    or HTTP headers, they can trigger different error scenarios and observe the API’s
    response. This approach allows you to systematically test the API’s error-handling
    capabilities and identify potential security weaknesses. For instance, sending
    requests with excessively large payloads or malformed data might cause the API
    to return error responses indicating input validation failures or buffer overflows.
  prefs: []
  type: TYPE_NORMAL
- en: The consistency and predictability of error responses across different endpoints
    and input variations are crucial aspects of identifying error codes and messages.
    You can examine how the API handles errors under various conditions, such as different
    authentication states, input formats, or request methods. Consistent error handling
    is essential for ensuring the reliability and security of the API. Inconsistent
    or unpredictable error responses may indicate underlying vulnerabilities or implementation
    flaws that you could exploit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at a practical example to illustrate the process of identifying
    error codes and messages. Imagine an API endpoint for user authentication that
    accepts username and password parameters via a POST request. We can send a request
    to this endpoint with invalid credentials and observe the resulting error response.
    Here’s an example request and response (command in a single line):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'A possible answer could be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You receive not only an error code but also a message and more details. Let’s
    check out another type of error message that could reveal some more of this hypothetical
    API endpoint’s logic. We will try to log in with some generic user ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The endpoint returns the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now, you know that only numeric values are accepted as user IDs. This tremendously
    reduces the search scope of a user enumeration task. Likewise, you can try to
    look for other error codes by using other API endpoints or HTTP verbs. As an exercise,
    the relevant dummy code implements an API with some endpoints and error messages.
    It can be found at [https://github.com/PacktPublishing/Pentesting-APIs/blob/main/chapters/chapter06/identify_error_codes.py](https://github.com/PacktPublishing/Pentesting-APIs/blob/main/chapters/chapter06/identify_error_codes.py).
  prefs: []
  type: TYPE_NORMAL
- en: 'A Flask application listens on port TCP `5000` by default. You can change it
    by using the `port=` parameter as part of the `app.run` method. Let’s see how
    it works by running some `curl` commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This is quite straightforward. No surprises there! Now, let’s verify how the
    endpoint behaves when we provide a nonexistent user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: OK; that’s part of the application code too. What if we send something unexpected?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This was directly answered by Flask (not the code I wrote) since it didn’t find
    any `user` endpoint that accepts a string as input. This is a well-known error
    message among Python applications and modules that make use of the Werkzeug module,
    a library that implements a **Web Server Gateway Interface** (**WSGI**). At least
    the message reveals that this API uses Python as its backend. In a real-world
    scenario, we would have had a fingerprinting win!
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving forward, let’s try the other endpoints by causing a predicted error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll receive this message should you forget to provide a name, email, or
    both. But in the case of this code, even if you send all parameters as expected,
    the application will throw an exception to show you how this can be revealing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This is what we received as output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: See how dangerous badly treated exceptions can be? You have not only discovered
    that the endpoint uses Python behind the scenes but also part of the directory
    structure, including the Python version being used. The other endpoints will throw
    analogous messages. In the next section, we will play with fuzzing.
  prefs: []
  type: TYPE_NORMAL
- en: Fuzzing for exception handling vulnerabilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 4*](B19657_04.xhtml#_idTextAnchor056), you quickly experimented
    with fuzzing by taking part in the exercises that we conducted with Burp Suite.
    Now, we are going to dive deeper into this technique. Fuzzing is very important
    in the context of API pentesting since it can expose an application’s vulnerabilities
    and weaknesses when incorrectly handling unexpected input. The types of vulnerabilities
    that can be raised from such bad handling may vary from information disclosure
    to **denial-of-service** (**DoS**).
  prefs: []
  type: TYPE_NORMAL
- en: A popular approach to fuzzing for exception handling vulnerabilities involves
    utilizing automated tools such as **American Fuzzy Lop** (**AFL**). AFL, created
    by Michal Zalewski and nowadays maintained by Google, is very good at creating
    random patterns to provide as input when testing API endpoints or apps. It operates
    by repeatedly modifying input files and monitoring the target application for
    crashes or unusual behavior. There are some good fuzzers out there you could leverage
    to fuzz API endpoints by bombarding them with requests containing malformed data,
    unexpected parameter values, or even specially crafted HTTP headers.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, imagine an API endpoint that processes JSON payloads for user
    authentication. A fuzzing test involves generating a series of malformed JSON
    payloads. These payloads could contain missing or invalid key-value pairs, excessively
    large sizes, or unexpected data types. By observing the API’s response to these
    inputs, you can identify potential exception-handling vulnerabilities, such as
    crashes, memory leaks, or unexpected behavior.
  prefs: []
  type: TYPE_NORMAL
- en: AFL’s strength lies in its feedback-driven approach, making it particularly
    adept at identifying exception-handling vulnerabilities. As the tool discovers
    new inputs that trigger unique paths or behaviors within the target application,
    it prioritizes mutating those inputs to delve deeper into the application’s code
    base. This iterative process helps uncover subtle vulnerabilities that manual
    testing alone might miss.
  prefs: []
  type: TYPE_NORMAL
- en: Another approach to fuzzing for exception-handling vulnerabilities involves
    meticulously mutating specific input parameters or request attributes. For instance,
    you might strategically inject special characters, boundary values, or unexpected
    data types into input fields to trigger exceptions or errors within the API’s
    processing logic. By meticulously crafting input payloads to target specific code
    paths or error-handling mechanisms, you can uncover vulnerabilities that might
    otherwise remain hidden.
  prefs: []
  type: TYPE_NORMAL
- en: Open source fuzzing frameworks such as Sulley and Radamsa offer additional options
    for targeted fuzzing of API endpoints. These frameworks provide tools and libraries
    for generating and mutating input data, along with mechanisms for monitoring and
    analyzing the target application’s responses. By tailoring fuzzing campaigns to
    focus on specific input parameters or request attributes, you can efficiently
    pinpoint exception-handling vulnerabilities and assess their impact on the API’s
    security posture.
  prefs: []
  type: TYPE_NORMAL
- en: Although AFL is quite versatile and powerful, I faced some trouble while compiling
    it to run on non-Intel chips. This scenario is supported, but you need to either
    apply **Low-Level Virtual Machine** (**LLVM**) or **Quick Emulator** (**QEMU**),
    two widely used hardware emulators, to be able to run it on ARM, for example.
    Sulley, in turn, stopped being maintained. A new project was raised in its place
    – Boofuzz. It seems promising and has good quickstart examples. However, Radamsa
    was easy to compile and install even on OSs backed by non-Intel chips. Many of
    the fuzzers require you to apply the change to the application’s code, which is
    not exactly what we are looking for. We want to understand how a generic API endpoint
    behaves when it needs to process random/unexpected input. Finally, **Fuzz Faster
    U Fool** (**FFUF**) is a quick web fuzzer written in Golang. Its installation
    is quite simple, besides the fact it can work in combination with other fuzzers,
    such as Radamsa. The point is that the majority of these fuzzers are good for
    sending fuzzed data, not **files**. Therefore, we will do things differently.
    Here, we will combine a mutator with custom code. We can handle response status
    codes and show just what we want.
  prefs: []
  type: TYPE_NORMAL
- en: Hence, for our practical exercise, we will explore making requests with fuzzed
    data provided by Radamsa to illustrate the process of fuzzing for exception-handling
    vulnerabilities. We can leverage the same code that we’ve already shared but with
    at least one more endpoint. This new endpoint will accept and process CSV files
    to update user information. A fuzzing test like this might involve generating
    a series of malformed CSV files with unexpected column headers, delimiter characters,
    or row formats. By observing the API’s response to these inputs, you can cause
    potential vulnerabilities in its CSV parsing and exception-handling logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'The relevant code, which has been written to be vulnerable, could look something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This code is located at [https://github.com/PacktPublishing/Pentesting-APIs/blob/main/chapters/chapter06/vulnerable_code_to_fuzz.py](https://github.com/PacktPublishing/Pentesting-APIs/blob/main/chapters/chapter06/vulnerable_code_to_fuzz.py).
  prefs: []
  type: TYPE_NORMAL
- en: 'Take the following files as two legitimate inputs for the `upload_csv()` endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1 – The first CSV file containing legitimate data](img/B19657_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.1 – The first CSV file containing legitimate data
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure shows the second CSV file that contains legitimate data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2 – The second CSV file containing legitimate data](img/B19657_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.2 – The second CSV file containing legitimate data
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to generate (fuzzed) data based on these files. With the
    help of Radamsa, we can quickly create thousands of fuzzed CSV files. There is
    a fair number of websites that can generate random data and files based on some
    parameters. I’ve put one of them in the *Further reading* section. You can create
    the fuzzed files with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Filenames begin with `1.csv` and go up to `1000.csv`. Any data inside the original
    files (`csvfile1.csv` and `csvfile2.csv`) is subject to be fuzzed. So, you may
    expect fuzzed CSV files to have weird headers, such as `email4294967297`, negative
    IDs, or strange email addresses. That’s exactly the intention here. The custom
    script code follows. Observe that we are only filtering response codes different
    from `200`. When this happens, we repeat the request to display the exact API
    endpoint’s output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In my case, the code spotted two errors out of 1,000 attempts, which means
    only a 2% success. However, even less than 1% can do the trick. Let’s see what
    made the endpoint crazy:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.3 – API endpoint throwing error messages with “500” error codes](img/B19657_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.3 – API endpoint throwing error messages with “500” error codes
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s have a quick look at what the `379.csv` file looks like. Observe
    the badly formatted header, which has been built like this on purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The fuzzed `554.csv` file looks similar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Observe that both input files have broken CSV structures. These could cause
    unexpected processing logic on the target API endpoint. What if, instead of 1,000
    attempts, we submitted 5,000 requests? Maybe this could result in something naughty
    happening with the target. Delete all the fuzzed CSV files Radamsa created previously
    and repeat the same `radamsa` command, replacing `1000` with `5000`. The partial
    output of this is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In my case, this new set of files resulted in 41 errors, which represents less
    than 1% of the hit rate. OK, it didn’t work out as expected, but this doesn’t
    mean we’ve done it wrongly. As previously mentioned, you must have patience while
    dealing with fuzzing. You can combine techniques and tools to get different artifacts
    and try them against your targets. You can also generate files with more rows
    and columns. Sooner or later, you will eventually achieve success and cause a
    failure on the endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we are going to understand what we can discover based on
    the error messages an API endpoint throws when answering requests.
  prefs: []
  type: TYPE_NORMAL
- en: Leveraging error responses for information disclosure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cool! So, you’ve learned how to identify error codes and messages and you’ve
    practiced this with a generic API endpoint. It’s now time for you to learn what
    you can do with the answers you will receive from the requests you are making
    toward such endpoints. They can be quite revealing. And sometimes, we don’t even
    need to send pernicious payloads to cause them to fail. Sysadmins and developers
    may change configurations or parameters based on changes or new application releases,
    and the new scenarios can cause the API to stop working.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will see a couple of generic figures in the following sections that show
    real web applications’ error messages. Observe that in at least one of them, the
    application simply discloses the versions of both .NET Framework and ASP.NET.
    This is embarrassing. In this specific case, some changes to a `web.config` file
    could suppress that specific line. Likewise, lacking a **web application firewall**
    (**WAF**) can leave room for releasing more revealing error messages. WAFs can
    either filter those messages or provide less verbose ones. *Figure 6**.4* shows
    a .NET failure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.4 – Error message from a .NET web application (Source: Code Aperture)](img/B19657_06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.4 – Error message from a .NET web application (Source: Code Aperture)'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 6**.5* shows a default Microsoft IIS error page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.5 – Microsoft IIS error page (Source: Microsoft)](img/B19657_06_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.5 – Microsoft IIS error page (Source: Microsoft)'
  prefs: []
  type: TYPE_NORMAL
- en: At the beginning of this chapter, we made some tests with an API endpoint that
    was using Flask, which, in turn, was leveraging Werkzeug. During a simple test,
    we received an error message that revealed that information. We could then look
    for vulnerabilities involving those components and craft special payloads to exploit
    them. Quite straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are some points you should pay attention to when analyzing error messages
    thrown by API endpoints:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/admin/users`, might return a 404 status code with a reason phrase such as
    `No route found for /admin/users`. This suggests the existence of an `admin` directory
    or a user management functionality within the API. You could use FFUF to recursively
    fuzz all endpoints under `/`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.lang.RuntimeException: Unsupported file format at com.example.api.UploadController.processFile(UploadController.java:123)`.
    This exposes the use of Java and reveals the location of the function handling
    file processing within the application code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`1003` due to an unauthorized attempt to update a user’s role. This code could
    hint at the existence of different permission levels or specific functionalities
    being mapped to these codes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Automated tools**: Several utilities can assist in parsing and analyzing
    error responses. We’ve played with some of them, such as OWASP ZAP and Burp Suite.
    In terms of fuzzing, we just used Radamsa to mutate CSV files and crafted a custom
    script to leverage them to test an API endpoint.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Burp Suite’s Intruder tool, you can fuzz parameter values within an API
    request and monitor the returned error messages. By analyzing patterns or specific
    details revealed in the error responses for different fuzzed inputs, they can
    potentially identify information disclosure vulnerabilities. We’ve done this for
    JWTs too.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Combining techniques**: The effectiveness of leveraging error responses is
    often amplified when combined with other pentesting techniques. Fuzzing techniques,
    as demonstrated earlier, can be used to generate unexpected inputs, and trigger
    informative error messages. Additionally, manually analyzing the application behavior
    and code (should you have access to it) can provide valuable context for interpreting
    the information disclosed in error responses.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As general best practice advice, API developers can take several steps to mitigate
    the risk of information disclosure through error responses. Generic error messages
    with minimal technical details are a good first step. Additionally, proper configuration
    of logging and error handling mechanisms can prevent sensitive information from
    being included in error responses that reach external users. For example, avoid
    raising the programming language exception as a last resort. You, as a developer,
    completely lose control when doing that. Instead, try to map as many exceptions
    as possible and as a last resort, send a generic error message.
  prefs: []
  type: TYPE_NORMAL
- en: Talking about logs, be sure to protect the access to them. Do not solely rely
    on the OS’s security mechanisms, such as filesystem permissions. A good approach
    is to have at least one copy of them elsewhere, such as a secondary data center
    or even a public cloud provider, and encrypt them at rest with a strong algorithm
    that applies a reasonable key length. Consider keys with at least 256 bits.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this practical chapter, we looked at how error messages that are thrown by
    API endpoints when handling requests can be useful not only to reveal information
    about their environment and configurations (data leakage) but also to cause more
    damage, such as DoS attacks (when the endpoint can’t heal itself after receiving
    an aggressive payload). We got our hands dirty with mutation and fuzzing and leveraged
    them in an exercise to bomb an API endpoint with bizarre data.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will get knee-deep in terms of DoS attacks and rate-limiting
    testing. Some APIs are protected by control mechanisms that reduce the number
    of requests a client can set at once. However, there are some techniques we can
    leverage to increase the chances of a successful attack.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To learn more about the topics that were covered in this chapter, take a look
    at the following resources:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Werkzeug code implementing the Flask “not found” error message: [https://github.com/pallets/werkzeug/blob/main/src/werkzeug/exceptions.py#L345C1-L348C6](https://github.com/pallets/werkzeug/blob/main/src/werkzeug/exceptions.py#L345C1-L348C6)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'More information about WSGI: [https://wsgi.readthedocs.io/en/latest/](https://wsgi.readthedocs.io/en/latest/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'American Fuzzy Lop, a widely used fuzzer for various types of applications:
    [https://github.com/google/AFL](https://github.com/google/AFL)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'What is LLVM?: [https://llvm.org/](https://llvm.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'QEMU: [https://www.qemu.org/](https://www.qemu.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Sulley – Fuzz Testing Framework: [https://github.com/OpenRCE/sulley](https://github.com/OpenRCE/sulley)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Boofuzz – Sulley’s replacement: [https://github.com/jtpereyda/boofuzz](https://github.com/jtpereyda/boofuzz)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Radamsa – a very good command-line fuzzer: [https://gitlab.com/akihe/radamsa](https://gitlab.com/akihe/radamsa)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A free Burp extension for Radamsa: [https://github.com/ikkisoft/bradamsa](https://github.com/ikkisoft/bradamsa)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'FFUF – a fast web fuzzer written in Golang: [https://github.com/ffuf/ffuf](https://github.com/ffuf/ffuf)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Generate random files: [https://extendsclass.com/csv-generator.html](https://extendsclass.com/csv-generator.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
