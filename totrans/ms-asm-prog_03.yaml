- en: Intel Instruction Set Architecture (ISA)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It may virtually be right to say that any digital device has a specific set
    of instructions. Even a transistor, the foundation stone of modern digital electronics,
    has two instructions, on and off, where each one is represented by 1 or 0 (which
    one of these represents on and off depends on whether the transistor is *n-p-n*
    or *p-n-p*). A processor is constructed from millions of transistors and is, as
    well, controlled by sequences of 1s and 0s (grouped into 8-bit bytes grouped into
    instructions). Fortunately, we do not have to take care of instruction encoding
    (it's the 21st century out there) as assemblers do that for us.
  prefs: []
  type: TYPE_NORMAL
- en: Each CPU instruction (and this is right for any CPU, not only Intel based) has
    a mnemonic designation (further simply mnemonic), which you need to learn about
    along with a few simple rules regarding operand sizes (and memory addressing,
    but we will take a deeper look at that in [Chapter 4](7a0e22a2-ba7f-4750-ac01-91e2460ce0cd.xhtml),
    *Memory Addressing Modes*), and this is exactly what we will do in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will begin by creating a simple Assembly template, which we will use throughout
    the book as a starting point for our code. Then, we will proceed to the actual
    CPU instruction set and get acquainted with the following types of instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: Data transfer instructions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arithmetic instructions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Floating point instructions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Execution flow control instructions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extensions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assembly source template
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will start with two 32-bit templates, one for Windows and one for Linux.
    64-bit templates will be added very soon and we will see that they are not much
    different from 32-bit ones. The templates contain some macro instructions and
    directives that will be explained later in the book. As for now, these templates
    are provided with the sole purpose to give you the ability to write simple (and
    not so simple) snippets of code, compile them, and test them in a debugger.
  prefs: []
  type: TYPE_NORMAL
- en: The Windows Assembly template (32-bit)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Windows executable consists of several sections (the structure of a PE executable/object
    file will be covered in more detail in [Chapter 9](17490bf0-6e1c-4061-8cd1-339e5a5ec48a.xhtml),
    *Operating System Interface*); usually, one section for code, one for data, and
    one for import data (this contains information on external procedures, which are
    imported from dynamic link libraries). **Dynamic-link libraries** (**DLL**) also
    have an export section, which contains information on procedures/objects publicly
    available in the DLL itself. In our template, we simply define the sections and
    let the assembler do the rest of the work (write headers and so on).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s take a look at the template itself. See further explanation of
    PE specifics in the comments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The Linux Assembly template (32-bit)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'On Linux, although files on disc are divided into sections, executables in
    memory are divided into code and data segments. The following is our template
    for the ELF 32-bit executable for Linux:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As was mentioned in the preceding code, these two templates will be used as
    a starting point for any code we will write in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Data types and their definitions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we start working with Assembly instructions, we have to know how to define
    data, or, to be more precise, how to tell the assembler which type of data we
    are using.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Flat Assembler supports six built-in types of data and allows us to either
    define or declare variables. The difference between a definition and a declaration
    in this case is that when we define a variable we also assign a certain value
    to it, but when we declare, we simply reserve space for a certain type of data:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Variable definition format**: `[label] definition_directive value(s)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`label`: This is optional, but addressing an unnamed variable is harder'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Variable declaration format: `[label] declaration_directive count`'
  prefs: []
  type: TYPE_NORMAL
- en: '`label`: This is optional, but addressing an unnamed variable is harder'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`count`: This tells the assembler how many entries of the type specified in
    `declaration_directive` it should reserve memory for'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following table shows definition and declaration directives for built-in
    data types, sorted by size thereof:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Size of data type in bytes** | **Definition directive** | **Declaration
    (reservation) directive** |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | `db` file (includes binary file) | `rb` |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | `dw` `du` (defines unicode character) | `rw` |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | `dd` | `rd` |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | `dp` `df` | `rp` `rf` |'
  prefs: []
  type: TYPE_TB
- en: '| 8 | `dq` | `rq` |'
  prefs: []
  type: TYPE_TB
- en: '| 10 | `dt` | `rt` |'
  prefs: []
  type: TYPE_TB
- en: 'The preceding table lists acceptable data types ordered by their size in bytes,
    which is in the leftmost column. The column in the middle contains the directives
    we use in the Assembly code for definition of data of a certain type. For example,
    if we want to define a byte variable named `my_var`, then we write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `0x5a` is the value we assign to this variable. In cases where we do
    not need to initialize the variable with any specific value, we write this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Here, the question mark (`?`) means that the assembler may initialize the memory
    area occupied by this variable to any value (which would typically be `0`).
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two directives that require a bit more attention:'
  prefs: []
  type: TYPE_NORMAL
- en: '`file`: This directive instructs the assembler to include a binary file during
    the compilation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`du`: This directive is used just like `db` is used to define characters or
    strings thereof, yet it produces unicode-like characters/strings instead of ASCII.
    The effect is the 0 extension of 8-bit values to 16-bit values. This is rather
    a convenience directive and has to be overridden when a proper transformation
    to unicode is required.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Directives shown in the rightmost column are used when we want to reserve space
    for a range of data entries of a certain type without specifying the values thereof.
    For example, if we want to reserve space for, let''s say, 12 32-bit integers labeled
    `my_array`, then we would write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The assembler would then reserve 48 bytes for this array, beginning at a place
    labeled `my_array` in the code.
  prefs: []
  type: TYPE_NORMAL
- en: Although you will use these directives in the data section most of the time,
    there is no limitation as to where they may be placed. For example, you may (for
    whatever purpose) reserve some space within a procedure, or between two procedures,
    or include a binary file containing precompiled code.
  prefs: []
  type: TYPE_NORMAL
- en: A debugger
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are almost ready to begin the process of instruction set exploration; however,
    there is one more thing that we have not touched yet, as there was no need for
    it--a debugger. There is a relatively wide choice of debuggers out there and you,
    being a developer, have most likely worked with at least one of them. However,
    since we are interested in debugging programs written in the Assembly language,
    I would suggest one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**IDA Pro** ([https://www.hex-rays.com/products/ida/index.shtml](https://www.hex-rays.com/products/ida/index.shtml)):
    Very convenient, but also very expensive. If you have it, good! If not, never
    mind, we have other options. Windows only.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**OllyDbg** ([http://www.ollydbg.de/version2.html](http://www.ollydbg.de/version2.html)):
    Free debugger/disassembler. More than enough for what we need. Windows only. Unfortunately,
    the 64-bit version of this tool was never finished, meaning that you would not
    be able to use it with 64-bit examples.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**HopperApp** ([https://www.hopperapp.com](https://www.hopperapp.com)): Commercial,
    but very affordable disassembler with GDB frontend. macOS X and Linux.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GDB** (**GNU DeBugger**): Freely available, works on Windows, Linux, mac
    OS X, and others. Although GDB is a command-line tool, it is quite easy to use.
    The only limitation is that the disassembler''s output is in AT&T syntax.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You are free to choose either one of these or a debugger that is not mentioned
    on the list (and there are relatively many). There is only one important factor
    to consider while selecting a debugger--you should feel comfortable with it, as
    running your code in a debugger, seeing everything that happens in registers of
    a processor or in memory, would greatly enhance your experience while writing
    code in Assembly.
  prefs: []
  type: TYPE_NORMAL
- en: The instruction set summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have finally got to the interesting part--the instruction set itself. Unfortunately,
    describing each and every instruction of a modern Intel-based processor would
    require a separate book, but since there is already such a book ([http://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-instruction-set-reference-manual-325383.pdf](http://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-instruction-set-reference-manual-325383.pdf)),
    we will not multiply things without need and will concentrate on instruction groups
    rather than on individual instructions. At the end of the chapter, we will implement
    AES128 encryption for the sake of demonstration.
  prefs: []
  type: TYPE_NORMAL
- en: General purpose instructions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The general purpose instructions perform basic operations such as data movement,
    arithmetic, flow control, and so on. They are grouped by their purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: Data transfer instructions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Binary arithmetic instructions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decimal arithmetic instructions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logical instructions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shift and rotate instructions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bit/byte manipulation instructions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flow control instructions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: String manipulation instructions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ENTER/LEAVE instructions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flag control instructions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Miscellaneous instructions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The division of instructions into groups is the same as in the Intel Software
    Developer's Manual.
  prefs: []
  type: TYPE_NORMAL
- en: Data transfer instructions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data transfer instructions, as the name of the group suggests, are used to transfer
    data between registers or between registers and memory. Some of them may have
    an immediate value as their source operand. The following example illustrates
    their usage.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a closer look at the instructions used with the example:'
  prefs: []
  type: TYPE_NORMAL
- en: '**PUSH**: This instructs the processor to store the value of the operand onto
    a stack and decrements stack pointer (ESP register on 32-bit systems and RSP register
    on 64-bit ones).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**MOV**: This is the most commonly used instruction for transferring data:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It moves data between registers of the same size
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: It loads a register with either an immediate value or a value read from memory
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: It stores the content of a register to memory
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: It stores the immediate value to memory
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**MOVZX**: This is less powerful than MOV by means of addressing modes, as
    it may only transfer data from register to register or from memory to register,
    but it has its special feature--the value being transferred is converted to a
    wider (one that uses more bits) one and is zero extended. As to the addressing
    modes supported by this instruction, it may only do the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It moves the byte value from register or memory to a word-sized register and
    extends the resulting value with zeroes (one byte would be added)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: It moves byte value from register or memory to a double word-sized register,
    in which case three bytes would be added to the original value and the value itself
    would be extended with zeroes
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: It moves word-sized value from register or memory to a double word-sized register,
    adding two bytes and filling them with the extension value of 0
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**MOVSX** is similar to MOVZX; however, the extended bits are filled with the
    sign bit of the source operand.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**BSWAP/MOVBE** The BSWAP instruction is the easiest way to switch the endianness
    of a value; however, it is not really a transfer instruction as it only rearranges
    data within a register. The BSWAP instruction only works on 32/64-bit operands.
    MOVBE is a more convenient instruction for swapping byte order as it also moves
    data between the operands. This instruction works on 16, 32, and 64-bit operands.
    It cannot move data from register to register.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**POP**: This retrieves values previously stored on stack. The only operand
    of this instruction is the destination where the value should be stored, and it
    may be a register or a location in memory. This instruction increments the stack
    pointer register as well.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Binary Arithmetic Instructions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: These instructions perform basic arithmetic operations. Operands may be byte,
    word, double-word or quad-word registers, memory locations, or immediate values.
    They all modify CPU flags according to the result of operation thereof, which,
    in turn, lets us change the execution flow depending on the values of certain
    flags.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us take a look at a few basic arithmetic instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '**INC**: This is short for increment. This instruction adds 1 to the value
    of its operand. Obviously, the inc instruction, or its counterpart, the `dec`
    instruction, may not be used with immediate values. The `inc` instruction affects
    certain CPU flags. For example, consider that we take a register (let it be the
    EAX register for the sake of simplicity), set it to 0, and execute it, as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In this case, EAX would equal to 1 and ZF (zero flag, remember?) would be set
    to 0, meaning that the operation resulted in a non-zero value. On the other hand,
    if we load the EAX register with the `0xffffffff` value and increment it with
    the `inc` instruction, the register will become zero and, since zero is the result
    of the latest operation, ZF would be set then (will have value of `1`).
  prefs: []
  type: TYPE_NORMAL
- en: '**ADD**: This performs simple addition, adding the source operand to the destination
    operand and storing the resulting value in the destination operand. This instruction
    affects several CPU flags as well. In the following example, we will add `0xffffffff`
    to the EBX register, which has been set to `1`. The result of such an operation
    would be a 33-bit value, but as we only have 32 bits to store the result, the
    extra bit would go into the carry flag. Such a mechanism, in addition to being
    useful for control of the execution flow, may also be used when adding two big
    numbers (may be even hundreds of bits wide) as we can then process the numbers
    by smaller portions (of, for example, 32 bits).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ADC**: Talking about addition of big numbers, the `adc` instruction is the
    one that allows us to add the value of the carry flag, as set by a previous operation,
    to the summation of additional two values. For example, if we want to add `0x802597631`
    and `0x4fe013872`, we would then add `0x02597631` and `0xfe013872` first, resulting
    in `0x005aaea3` and a set carry flag. Then, we would add 8, 4 and, the value of
    the carry flag:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This would result in `8 + 4 + 1` (where 1 is the implicit operand--the value
    of the CF) `= 0xd`, thus, the overall result would be `0xd005aaea3`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example illustrates these instructions in more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Decimal arithmetic instructions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In about 15 years of Assembly development and reverse engineering software,
    I encountered these instructions exactly once, and that was in the college. However,
    it would be right to mention them, for a few reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: Instructions like AAM and AAD may sometimes be used as a smaller variant of
    multiplication and division, since they allow immediate operand. They're smaller
    as they allow generation of smaller code due to their encoding.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sequences like AAD 0 (which is division by zero) may be used as an exception
    trigger in certain protection schemes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Not mentioning them would be historically wrong.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decimal arithmetic instructions are illegal on 64-bit platforms.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, what is BCD? It is **Binary coded decimal** (**BCD**) and is,
    in fact, an attempt to ease the conversion of binary representations of numbers
    to their ASCII equivalent and vice versa, as well as adding the ability to perform
    basic arithmetic operations on decimal numbers represented in a hexadecimal form
    (not their hexadecimal equivalents!).
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two types of BCD: packed and unpacked. Packed BCD represents a decimal
    number using nibbles of a single byte. For example, the number 12 would be represented
    as 0x12\. Unpacked BCD, on the other hand, uses bytes for representation of individual
    digits (for example, 12 converts to 0x0102).'
  prefs: []
  type: TYPE_NORMAL
- en: However, given the fact that these instructions have not been changed since
    their first appearance, they only operate on values stored in a single byte, for
    packed BCD, or values stored in a single word, for unpacked BCD. More than this,
    these values should be stored only in the AL register for packed BCD and the AX
    register (or, to say it in a more precise way, in the AH:AL pair) for unpacked
    BCD.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are only six BCD instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Decimal Adjust after Addition** (**DAA**): This instruction is specific to
    packed BCD. Since the addition of two packed BCD numbers would not necessarily
    result in a valid packed BCD number, the invocation of DAA fixes the problem by
    making the adjustments needed for converting a result into a proper packed BCD
    value. For example, let''s add 12 and 18\. Normally, the result would be 30, but
    if we add `0x12` and `0x18`, the result would be `0x2a`. The following example
    illustrates the procedure for such a calculation:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '**Decimal Adjust after Subtraction** (**DAS**): This instruction performs similar
    adjustments after subtracting two packed BCD numbers. Let''s add some more lines
    to the preceding code (AL still contains `0x30`):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '**ASCII Adjust after Addition** (**AAA**): This instruction is similar to DAA,
    yet it works on unpacked BCD numbers (meaning, the AX register). Let''s look at
    the following example, where we still add 18 to 12, but we do that with the unpacked
    BCD:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The resulting value may easily be converted to the ASCII representation by adding
    `0x3030`.
  prefs: []
  type: TYPE_NORMAL
- en: '**ASCII Adjust after Subtraction** (**AAS**): This instruction is similar to
    DAS, but operates on unpacked BCD numbers. We may continue to add code to the
    preceding example (The AX register still has the value of `0x0300`). Let''s subtract
    3, which should, at the end, give us the value of `0x0207`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'What went wrong then? In fact, nothing went wrong; it is just that the internal
    implementation of the AAS instruction caused carry (and, as we may see in a debugger,
    the CF is in deed set) or, to be more precise, a borrow occurred. That is why
    it is better for our convenience to finalize this with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We end up with `0x0207`, which is the unpacked BCD representation of 27--exactly
    the result we were expecting.
  prefs: []
  type: TYPE_NORMAL
- en: '**ASCII Adjust AX after Multiply** (**AAM**): Result of the multiplication
    of two unpacked BCD numbers, as well, requires certain adjustments to be made
    in order to be in an unpacked BCD form. However, what we have to remember first
    of all is the size limitation implied by these operations. As we are limited to
    the AX register, the maximum value of a multiplicand is 9 (or `0x09`), meaning
    that, being limited to AX with the resulting value, we are limited to one byte
    with multiplicands. Let''s say we want to multiply 8 by 4 (which would be `0x08
    * 0x04`); naturally, the result would be `0x20` (the hexadecimal equivalent of
    32), which is not even close to being an unpacked BCD represented number. The
    `aam` instruction solves this problem by converting the value of the AL register
    to the unpacked BCD format and stores it in AX:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: As we see, the multiplication of two unpacked BCD bytes results in an unpacked
    BCD word.
  prefs: []
  type: TYPE_NORMAL
- en: '**ASCII Adjust AX before Division** (**AAD**): This is exactly as the name
    of the instruction suggests--it should adjust the value of the AX register before
    division. The size limitations are just the same as in AAM. The AX register still
    contains `0x0302` after the previous example, so let''s divide it by 4:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As we see, although these instructions may seem to be somewhat convenient, there
    are better ways to convert numbers between their ASCII notation and their binary
    equivalents, not to mention the fact that regular arithmetic instructions are
    much more convenient to use.
  prefs: []
  type: TYPE_NORMAL
- en: Logical instructions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This group contains instructions for bitwise logical operations which you, being
    a developer, already know. These are NOT, OR, XOR, and AND operations. However,
    while high-level languages do make a difference between bitwise and logical operators
    (for example, bitwise AND (&) and logical AND (&&) in C), they are all the same
    on the Assembly level and are quite commonly used in conjunction with the EFlags
    register (or RFlags on 64-bit systems).
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider the following simple snippet in C that checks for a specific
    bit being set and conditionally executes certain code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'It may be implemented in Assembly like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: One of the many other applications of these instructions is the finite field
    arithmetic, where XOR stands for addition and AND stands for multiplication.
  prefs: []
  type: TYPE_NORMAL
- en: Shift and rotate instructions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Instructions of this group let us move bits within the destination operand,
    which is something we only partially have in high-level languages. We can shift,
    but we cannot rotate, neither can we implicitly specify arithmetic shifts (the
    selection of arithmetic or a logical shift is usually performed by high-level
    language implementation based on the type of data the operations are carried on).
  prefs: []
  type: TYPE_NORMAL
- en: Using shift instructions, in addition to their primary role of moving bits left
    or right a certain number of positions, is a simpler way to perform integer multiplication
    and division of the destination operand by powers of two. Additionally, two special
    shift instructions exist that let us move certain amount of bits from one location
    to another--to be more precise, from a register to another register or to a memory
    location.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rotation instructions allow us, as the name suggests, to rotate bits from one
    end of the destination operand to another. It is important to mention that bits
    may be rotated through the CF (carry flag), meaning that the bit that is shifted
    out is stored in the CF while the value of the CF is shifted into the operand
    on the other side. Let''s consider the following example, one of the simplest
    integrity control algorithms, CRC8:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The body of the loop in the preceding snippet was intentionally left without
    comments as we would like to take a closer look at what is happening there.
  prefs: []
  type: TYPE_NORMAL
- en: The first instruction of the loop `shl al, 1` shifts out the most significant
    bit of the value we are calculating CRC8 for and stores it into the CF. The next
    instruction `rcl bl, 1` stores the value of the CF (the bit we shifted out of
    our bit stream) into the BL register. The following two instructions do the same
    for the DL register, storing the most significant bit into BH. The side effect
    of the `rcl` instruction is that the most significant bits of the first BL and
    then the BH register are moved to the CF. Although it is of no importance in this
    specific case, we should not forget about this when rotating through the CF. At
    the end, this means after 8 iterations, the preceding code provides us with the
    CRC8 value for `0x16` (which is `0xE5`) in the DL register.
  prefs: []
  type: TYPE_NORMAL
- en: 'The two shift and rotate instructions mentioned in the example have their right-sided
    counterparts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**SHR**: This shifts bits to the right, while saving the last bit shifted out
    in the CF'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**RCR**: This rotates bits to the right through the carry flag'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are a few additional instructions in this group that we cannot skip:'
  prefs: []
  type: TYPE_NORMAL
- en: '**SAR**: This shifts bits to the right while "dragging" the sign bit instead
    of simply filling the "vacant" bits with zeroes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SAL**: This is an arithmetic shift to the left. It is not truly an instruction,
    rather a mnemonic used for a programmer''s convenience. The assembler generates
    the same encoding as for SHL.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ROR**: This rotates bits to the right. Each bit being shifted out to the
    right and shifted in to the left is also stored in the CF.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally, as it was mentioned earlier, the two special shift instructions are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**SHLD**: This shifts a certain number of left-side (most significant) bits
    from a register into another register or into a memory location'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SHRD**: This shifts a certain number of right-side (least significant) bits
    from a register into another register or into a memory location'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another new instruction in the previous example is TEST, but it will be explained
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Bit and byte instructions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Instructions of this group are those that let us manipulate individual bits
    within an operand and/or set bytes in accordance with the sate of flags in the
    EFlags/RFlags register.
  prefs: []
  type: TYPE_NORMAL
- en: With high-level languages that implement bit fields, it is quite easy to access
    individual bits even if we want to perform more complex operations than just scan,
    test, set or reset, as provided by Intel Assembly. However, with high-level languages
    having no bit fields we have to implement certain constructs in order to have
    access to individual bits and that is where Assembly is more convenient.
  prefs: []
  type: TYPE_NORMAL
- en: 'While bit and byte instructions may have a variety of applications, let''s
    consider them (just a few of them) in the context of the CRC8 example. It would
    not be completely right to say that using these instructions in that example would
    have significantly optimized it; after all, it would let us get rid of a single
    instruction, making the implementation of the algorithm look a bit clearer. Let''s
    see how `crc_loop` would have changed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code is quite self-explanatory, but let''s take a closer look
    at the set of bit instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '**BT**: This stores a bit from the destination operand (bit base) to the CF.
    The bit is identified by the index specified in the source operand.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**BTS**: This is the same as BT, but it also sets the bit in the destination
    operand.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**BTR**: This is the same as BT, but it also resets the bit in the destination
    operand.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**BTC**: This is the same as BT, but it also inverts (complements) the bit
    in the destination operand.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**BSF**: This stands for **bit scan forward**. It searches the source operand
    for the least significant bit that is set. The index of the bit, if found, is
    returned in the destination operand. If the source operand is all zeros, then
    the value for the destination operand is not defined and ZF is set.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**BSR**: This stands for **bit scan reverse**. It searches the source operand
    for the most significant bit that is set. The index of the bit, if found, is returned
    in the destination operand. If the source operand is all zeros, then the value
    of the destination operand is not defined and ZF is set.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**TEST**: This instruction makes it possible to check for several bits being
    set at the same time. To put it simply, the TEST instruction performs the logical
    AND operation, sets flags accordingly, and discards the result.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Byte instructions are all of a form SETcc, where **cc** stands for **condition
    code**. The following are the condition codes on the Intel platform, as specified
    in section B.1 Condition Codes of *Appendix B EFlags Condition Codes* of Intel
    64 and IA-32 Architectures Software Developer''s Manual Volume 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Mnemonic (cc)** | **Condition tested for** | **Status flags setting** |'
  prefs: []
  type: TYPE_TB
- en: '| O | Overflow | OF = 1 |'
  prefs: []
  type: TYPE_TB
- en: '| NO | No overflow | OF = 0 |'
  prefs: []
  type: TYPE_TB
- en: '| B NAE | Below Neither above nor equal | CF = 1 |'
  prefs: []
  type: TYPE_TB
- en: '| NB AE | Not below Above or equal | CF = 1 |'
  prefs: []
  type: TYPE_TB
- en: '| E Z | Equal Zero | ZF = 1 |'
  prefs: []
  type: TYPE_TB
- en: '| NE NZ | Not equal Not zero | ZF = 0 |'
  prefs: []
  type: TYPE_TB
- en: '| BE NA | Below or equal Not above | (CF or ZF) = 1 |'
  prefs: []
  type: TYPE_TB
- en: '| NBE A | Neither below nor equal Above | (CF or ZF) = 0 |'
  prefs: []
  type: TYPE_TB
- en: '| S | Sign | SF = 1 |'
  prefs: []
  type: TYPE_TB
- en: '| NS | No sign | SF = 0 |'
  prefs: []
  type: TYPE_TB
- en: '| P PE | Parity Parity even | PF = 1 |'
  prefs: []
  type: TYPE_TB
- en: '| NP PO | No parity Parity odd | PF = 0 |'
  prefs: []
  type: TYPE_TB
- en: '| L NGE | Less Neither greater nor equal | (SF xor OF) = 1 |'
  prefs: []
  type: TYPE_TB
- en: '| NL GE | Not less Greater or equal | (SF xor OF) = 0 |'
  prefs: []
  type: TYPE_TB
- en: '| LE NG | Less or equal Not greater | ((SF xor OF) or ZF) = 1 |'
  prefs: []
  type: TYPE_TB
- en: '| NLE G | Not less or equal Greater | ((SF xor OF) or ZF) = 0 |'
  prefs: []
  type: TYPE_TB
- en: So, as we may conclude using the preceding table and the `setc` instruction
    from the CRC8 example, it instructs the processor to set `bl` (and `bh`) to 1
    if the C condition is true, which means CF == 1.
  prefs: []
  type: TYPE_NORMAL
- en: Execution flow transfer instructions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Instructions of this group make it possible to easily branch the execution,
    whether in accordance to a specific condition designated by the EFlags/RFlags
    register or completely unconditionally, and may, therefore, be divided into two
    groups:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Unconditional execution flow transfer instructions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**JMP**: Perform unconditional jump to an explicitly specified location. This
    loads the instruction pointer register with the address of the specified location.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CALL**: This instruction is used to call a procedure. This pushes the address
    of the next instruction onto the stack and loads the instruction pointer with
    the address of the first instruction in the called procedure.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**RET**: This instruction performs a return from procedure. It pops the value
    stored on the stack into the instruction pointer register. When used at the end
    of a procedure, it returns the execution to instruction following the CALL instruction.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The RET instruction may have a two-bytes value as its operand, in which case
    the value defines the amount of bytes occupied by the operands that were passed
    to the procedure on stack. The stack pointer is then automatically adjusted by
    adding the amount of bytes.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '**INT**: This instruction causes a software interrupt.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The use of this instruction on Windows while programming in ring 3 is quite
    rare. It may even be safe to assume that the only usage is INT3--software breakpoint.
    On 32-bit Linux, however, it is used for invocation of system calls.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Conditional execution flow transfer instructions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Jcc**: This is the conditional variant of the JMP instruction, where **cc**
    stands for **condition code**, which may be one of the condition codes listed
    in the preceding table. For example, look at the `jz .noxor` line from the CRC8
    example.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**JCXZ**: This is a special version of the conditional jump instruction, which
    uses the CX register as a condition. The jump is only executed if the CX register
    contains 0.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**JECXZ**: This is the same as above, but it operates on the ECX register.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**JRCXZ**: This is the same as above, but it operates on the RCX register (long
    mode only).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**LOOP**: A loop with ECX as a counter, this decrements ECX and, if the result
    is not 0, loads the instruction pointer register with the address of the loop
    label. We have already used this instruction in the CRC8 example.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**LOOPZ**/**LOOPE**: This is the loop with ECX as a counter while ZF = 1.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**LOOPNZ**/**LOOPNE**: This is the loop with ECX as a counter while ZF = 0.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s, for the sake of example, implement the CRC8 algorithm as a procedure
    (insert the following into the code section of the relevant 32-bit template):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: String instructions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is an interesting group of instructions that operate on strings of bytes,
    words, double words, or quad words (long mode only). These instructions have implicit
    operands only:'
  prefs: []
  type: TYPE_NORMAL
- en: The source address should be loaded into the ESI (RSI for long mode) register
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The destination address should be loaded into the EDI (RDI for long mode) register
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One of the EAX (for example, AL and AX) register variations is used with all
    of them except the MOVS* and CMPS* instructions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The number of iterations (if any) should be in ECX (only used with the REP*
    prefix)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ESI and/or EDI registers are automatically incremented by one for byte, two
    for word, and four for double word data. The direction of these operations (whether
    they increment or decrement ESI/EDI) is controlled by the direction flag (DF)
    in the EFlags register: DF = 1 : decrement ESI/EDI DF = 0 : increment ESI/EDI.'
  prefs: []
  type: TYPE_NORMAL
- en: 'These instructions may be divided into five groups. In fact, to put it in a
    more precise manner, there are five instructions supporting four data sizes each:'
  prefs: []
  type: TYPE_NORMAL
- en: '**MOVSB**/**MOVSW**/**MOVSD**/**MOVSQ**: These move byte, word, double word,
    or quad word in memory from the location pointed by ESI/RSI to the location pointed
    by EDI/RDI. The instruction''s suffix specifies the size of data to be moved.
    Setting ECX/RCX to the amount of data items to be moved and prefixing it with
    the REP* prefix instructs the processor to execute this instruction ECX times
    or while the condition used with the REP* prefix (if any) is true.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CMPSB**/**CMPSW**/**CMPSD**/**CMPSQ**: These compare the data pointed by
    the ESI/RSI register to the data pointed by the EDI/RDI register. The iteration
    rules are the same as for MOVS* instruction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SCASB**/**SCASW**/**SCASD**/**SCASQ**: These scan sequences of data items
    (size thereof is specified by the instruction''s suffix) pointed by the EDI/RDI
    register for a value specified in AL, AX, EAX, or RAX, depending on the mode (protected
    or long) and the instruction''s suffix. Iterations rules are the same as those
    for the MOVS* instruction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**LODSB**/**LODSW**/**LODSD**/**LODSQ**: These load AL, AX, EAX, or RAX (depending
    on operation mode and instruction''s suffix) with a value from memory, pointed
    by the ESI/RSI register. The iteration rules are the same as those for the MOVS*
    instruction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**STOSB**/**STOSW**/**STOSD**/**STOSQ**: These store the value of the AL, AX,
    EAX, or RAX registers to the memory location pointed by the EDI/RDI register.
    These iteration rules are the same as those for the MOVS* instruction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All of the preceding instructions have the explicit-operands form without a
    suffix, but in such a case, we need to specify the size of the operands. While
    the operands themselves may not be changed and therefore would always be ESI/RSI
    and EDI/RDI, all we may change is the size of the operand. The following is an
    example of such case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The following example shows typical usage of the SCAS* instruction--scanning
    a sequence of, in this particular case, bytes for specific value, which is stored
    in the AL register. The other instructions are similar in their usage.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The `rep` prefix, used in the preceding example, indicates to the processor
    that it should execute the prefixed command using the ECX register as a counter
    (in the same manner as it is used by the LOOP* instructions). However, there is
    one more optional condition designated by ZF (zero flag). Such a condition is
    specified by the condition suffix attached to REP. For example, using it with
    the E or Z suffix would instruct the processor to check ZF for being set before
    each iteration. Suffixes NE or NZ would instruct the processor to check ZF for
    being reset before each iteration. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This would instruct the processor to keep comparing two sequences of bytes (pointed
    by the EDI/RDI and ESI/RSI registers) while they are equal and ECX is not zero.
  prefs: []
  type: TYPE_NORMAL
- en: ENTER/LEAVE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: According to the Intel manual for developers, *these instructions provide machine-language
    support for procedure calls in block-structured languages;* however, they are
    very useful for Assembly developers as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we implement a procedure, we have to take care of the creation of the
    stack frame where we store the procedure''s variables, storing the value of ESP
    and then restoring all that before we leave a procedure. These two instructions
    can do all that work for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code is equivalent to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Flag control instructions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The EFlags register contains information on certain aspects of the last ALU
    operation as well as certain settings of the CPU (for example, the direction of
    string instructions); however, we have the mechanism for controlling the content
    of this register, up to the level of a single flag, with the following instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Set**/**clear carry flag** (**STC**/**CLC**): We may want to have the CF
    set or reset prior to certain operations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Complement the carry flag** (**CMC**): This instruction inverts the value
    of the CF.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Set**/**clear direction flag** (**STD**/**CLD**): We may use these instructions
    to set or reset the DF in order to define whether ESI/EDI (RSI/RDI) should increment
    or decrement with string instructions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Load flags into the AH register** (**LAHF**): There are certain flags, for
    example, ZF, that do not have associated instructions for direct modification,
    therefore, we may load the Flags register into AH, modify the corresponding bit,
    and reload the Flags register with the modified value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Store the AH register into flags** (**SAHF**): This instruction stores the
    value of AH register into the Flags register.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Set**/**clear the interrupt flag** (**STI**/**CLI**) (not in user land):
    These instructions are used on the operating system-level to enable/disable interrupts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Push Flags**/**EFlags**/**RFlags register onto the stack** (**PUSHF**/**PUSHFD**/**PUSHFQ**):
    LAHF/SAHF instructions may not be sufficient for inspection/modification of certain
    flags in the Flags/EFlags/RFlags register. With the PUSHF* instruction, we gain
    access to other bits (flags).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Retrieve Flags**/**EFlags**/**RFlags register from the stack** (**POPF**/**POPFD**/**POPFQ**):
    These reload Flags/EFlags/RFlags register with the new value from the stack.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Miscellaneous instructions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are a few instructions without any particular category assigned to them,
    which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Load effective address** (**LEA**): This instruction calculates the effective
    address specified with one of the processor''s addressing modes in the source
    operand and stores it in the destination operand. It is also frequently used instead
    of the ADD instruction when terms are specified as parts of the addressing mode.
    The following example code shows both cases:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '**No operation** (**NOP**): As the name states, this instruction performs no
    operation and is often used for filling the gaps between aligned procedures.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Processor identification** (**CPUID**): Depending on the value of the operand
    (in EAX), this instruction returns CPU identification information. This instruction
    is available only if the ID flag in the EFlags register (bit 21) is set.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: FPU instructions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'FPU instructions are executed by the x87 **floating-point unit** (**FPU**)
    and operate on floating point, integer, or binary coded decimal values. These
    instructions are grouped by their purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: FPU data transfer instructions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: FPU basic arithmetic instructions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: FPU comparison instructions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: FPU load constant instructions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: FPU control instructions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another important aspect of the FPU operation is the fact that, unlike the registers
    of the processor, floating point registers are organized in the form of a stack.
    Instructions like `fld` are used to push the operand onto the top of the stack,
    instructions like `fst` are used for reading a value from the top of the stack,
    and instructions like `fstp` are used for popping the value from the top of the
    stack and moving other values toward the top.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows the calculation of the circumference for a circle
    with radius of `0.2345`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Extensions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since the first Intel microprocessor, technology has significantly evolved
    and so has the complexity of the processor architecture. The initial set of instructions,
    although it was and still is quite powerful, is not enough for some tasks (and
    here we have to admit that the number of such tasks is growing as time goes by).
    The solution adopted by Intel is nice and quite user friendly: **Instruction Set
    Architecture Extensions** (**ISA Extensions**). Intel has gone a long way from
    **MMX** (unofficially, **MultiMedia eXtension**) to SSE4.2, AVX, and AVX2 extensions,
    which introduced support for 256-bit data processing and AVX-512, which allows
    the processing of 512-bit data and extends the number of usable SIMD registers
    to 32\. All of these are SIMD extensions, where SIMD stands for single instruction
    multiple data. In this section, we will particularly pay attention to the AES-NI
    extension and partially to SSE (which will be covered in more detail in [Chapter
    5](81d8a530-f9fe-484d-83f7-652ce31bfa1c.xhtml), *Parallel Data Processing*).'
  prefs: []
  type: TYPE_NORMAL
- en: AES-NI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**AES-NI** stands for **Advanced Encryption Standard New Instructions**, an
    extension initially proposed by Intel in 2008 for speeding up AES algorithm implementations.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code checks whether AES-NI is supported by the CPU:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Instructions in this extension are rather simple and few:'
  prefs: []
  type: TYPE_NORMAL
- en: '**AESENC**: This performs one round of AES encryption on 128-bit data using
    a 128-bit round key for all encryption rounds except the last round'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**AESENCLAST**: This performs the last round of AES encryption on 128-bit data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**AESDEC**: This performs one round of AES decryption on 128-bit data using
    a 128-bit round key for all decryption rounds except the last round'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**AESDECLAST**: This performs the last round of AES decryption on 128-bit data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**AESKEYGENASSIST**: This assists in the generation of an AES round key using
    an 8-bit round constant (RCON)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**AESIMC**: This performs the inverse mix column transformation on a 128-bit
    round key'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SSE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'SSE stands for Streaming SIMD Extension, which allows, as the name suggest,
    processing of multiple data with a single instruction, which is best seen in the
    following example code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Example program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you have noticed, the previous two sections (AES-NI and SSE) were left without
    proper examples. The reason is that the best way to demonstrate the abilities
    of both extensions would be to mix them in a single program. In this section,
    we will implement a simple AES-128 encryption algorithm with the help of the two.
    AES encryption is one the classic examples of an algorithm that would definitely
    benefit from parallel processing of data offered by SSE.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the templates we prepared in the beginning of this chapter, thus,
    all we have to do is write the following code in place of this comment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The code runs equally well on both Windows and Linux, so no other preparations
    required:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The following should be placed in the data section/segment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We began this chapter with creation of two templates--one for a 32-bit Windows
    executable and the other for a 32-bit Linux executable. While there are certain
    parts of both templates that may still be unclear, let that bother you not, as
    we will cover each and every aspect thereof when the time comes. You may use these
    templates as a skeleton for your own code.
  prefs: []
  type: TYPE_NORMAL
- en: The most significant part of the chapter, however, was dedicated to the Intel
    Instruction Set Architecture itself. It was, of course, a very brief overview
    as there was no need to describe each and every instruction--Intel did the job
    releasing their Programmer's Manual, which contains over three thousand pages.
    Instead, a decision was made to provide only the basic information and help us
    achieve certain level of acquaintance with Intel instruction set.
  prefs: []
  type: TYPE_NORMAL
- en: We ended the chapter by implementing the AES128 encryption algorithm with the
    aid of AES-NI extension, which makes the process of AES128 encryption/decryption
    significantly simpler and easier.
  prefs: []
  type: TYPE_NORMAL
- en: Now, when we understand the instructions, we are ready to proceed further to
    the memory organization and data and code addressing modes.
  prefs: []
  type: TYPE_NORMAL
