<html><head></head><body><div><div><p>&#13;
			<h1 id="_idParaDest-90" class="chapter-number"><a id="_idTextAnchor179"/>5</h1>&#13;
			<h1 id="_idParaDest-91"><a id="_idTextAnchor180"/>Basic Needs in My Build Chain</h1>&#13;
			<p>Security begins at the design table. True. Yet it is enhanced and comes alive in the build chain. It is here where we will implement and validate our security policies, test, scan our prototypes, and leverage all the informational sources at our disposal to ensure that our product is as secure and robust as it possibly can be, long before it sees its first customer.</p>&#13;
			<p>Here is truly where all the magic happens (or sadly, it doesn’t if you choose to ignore it). In the previous chapters, we have addressed countless design factors that have led up to your conceptual initial design criteria. From here and forward, we will be working hands-on to ensure those embedded systems’ best practices are adhered to along with the application of security measures.</p>&#13;
			<p>Here’s a non-exhaustive sample of what may be in your company’s build environment. These tools should be accessible only to those working directly on this product or supporting production releases. From secure repositories to scanning tools and everything else in between, these critical tools will greatly contribute to the success of your product’s lifecycle.</p>&#13;
			<p>The many tools you will need are vast and include (but are not limited to) the following:</p>&#13;
			<ul>&#13;
				<li>Local repositories</li>&#13;
				<li>Source code control systems</li>&#13;
				<li>Project management systems</li>&#13;
				<li>Customer support systems</li>&#13;
				<li>Build automation systems</li>&#13;
				<li>Compliance and security scanning systems</li>&#13;
				<li>Update infrastructure for deployed appliances</li>&#13;
				<li>Most importantly, a comprehensive set of test systems</li>&#13;
			</ul>&#13;
			<p>Here’s a perspective of systems and tools needed for a successful build chain infrastructure:</p>&#13;
			<div>&#13;
				<div>&#13;
					<img src="img/B22104_05_01.jpg" alt="Figure 5.1 – Example systems in a secure build and support chain" width="1070" height="650"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.1 – Example systems in a secure build and support chain</p>&#13;
			<p>Grab your favorite beverage. Clear your calendar. Grab some USB thumb drives and let’s go to the lab. I invite you to join me on this journey, roll up your sleeves, and get your keyboard thumping. Are you ready to start practicing how to secure your software supply chain?</p>&#13;
			<p>In the following sections, I will address key concepts and then walk you through some detailed exercises:</p>&#13;
			<ul>&#13;
				<li>Software supply chain control</li>&#13;
				<li>Automation and tool integration – a brief overview</li>&#13;
				<li>Security scanning, testing, and remediation</li>&#13;
				<li>Manifest and configuration tracking</li>&#13;
				<li>Update control mechanisms</li>&#13;
			</ul>&#13;
			<p>Let’s get started.</p>&#13;
			<h1 id="_idParaDest-92"><a id="_idTextAnchor181"/>Technical requirements</h1>&#13;
			<p>If you’d like to follow along with the exercises within this chapter, you will need at least two machines (physical or virtual) running the same distribution of Linux. In the exercises themselves, I will call out which distribution I have used for the exercise and any other pertinent configuration information. For the purposes of this book, it is assumed that you and your team have a substantial level of experience with whichever solution(s) for source code control/management.</p>&#13;
			<p>This book itself has its own GitHub page and repository. Many of the exercises and example configuration files can be found there:</p>&#13;
			<p><a href="https://github.com/PacktPublishing/The-Embedded-Linux-Security-Handbook/tree/main/Chapter05/exercises">https://github.com/PacktPublishing/The-Embedded-Linux-Security-Handbook/tree/main/Chapter05/exercises</a></p>&#13;
			<h1 id="_idParaDest-93">S<a id="_idTextAnchor182"/>oftware supply chain control</h1>&#13;
			<p>As a <a id="_idIndexMarker210"/>solution provider, it is your responsibility to know, track, and maintain records of each component that goes into your solution. If your solution falls under any sort of government or industry compliance regulations, this requirement may have dire consequences if not maintained.</p>&#13;
			<p>This is a situation where again, I recommend leveraging an enterprise Linux distribution. Their software sources are secure, from source code to compilation to packaging and, ultimately, its delivery to you. They maintain great records. They have to! These vendors can provide your team with what we<a id="_idIndexMarker211"/> call a <strong class="bold">Software Bill of Materials</strong> (<strong class="bold">SBOM</strong>). This is a complete listing of the components and their versions. Additionally, it is an attestation that they use secure, tested, and validated software.</p>&#13;
			<p>There are several commercial solutions available on the market. Companies like Aqua, Synopsys®, and Red Hat® (just to name a few) create some excellent comprehensive solutions to securing the software pipeline. There are lots of viable options for your team to consider in this aspect, so let’s move onto the next section, Source code control.<a id="_idTextAnchor183"/></p>&#13;
			<h2 id="_idParaDest-94"><a id="_idTextAnchor184"/>Source code control</h2>&#13;
			<p>Intellectual<a id="_idIndexMarker212"/> property, that very special code that makes your solution oh so special, is meant to be protected. Sometimes, at virtually all costs.</p>&#13;
			<p>There are many excellent commercial and open source solutions for this. Oftentimes, these solutions are integrated with other solutions that may provide services for bug tracking, agile project management, software packaging solutions, etc. Regardless of which source code control system your organization has chosen, I recommend ensuring that all feasible steps to minimize access and secure the platform are taken. Protect your company’s intellectual property. Let’s move on to other parts of a good software supply chain<a id="_idTextAnchor185"/>.</p>&#13;
			<h1 id="_idParaDest-95"><a id="_idTextAnchor186"/>Automation and tool integration – a brief overview</h1>&#13;
			<p>No DevOps shop <a id="_idIndexMarker213"/>can be complete without a substantial level of automation throughout the operation. Just like with source code control, there are many excellent <a id="_idIndexMarker214"/>commercial <a id="_idTextAnchor187"/>and open source solutions for this. Red Hat Ansible®, SaltStack®, Puppet Enterprise®, Chef®, Ansible AWX®, and Puppet Bolt® are <a id="_idTextAnchor188"/>the most commonly used.</p>&#13;
			<p>Other products often found in a build chain may also include a significant level of automation. One such example is the platform offered by a company called CloudBees. Their Jenkins product has been at the leading edge of DevOps shops globally. This is just one example in a market of many solutions.</p>&#13;
			<p>Automation is an area that I <a id="_idTextAnchor189"/>can rant about for hours on end. That is definitely not what I intend for this brief section. The message I want to impart to you here is that automation, when done correctly, can ease the burden of many cumbersome and menial tasks that can be error-prone when humans are doing them repetitively. Risk mitigation and efficiency, pure and simple.</p>&#13;
			<p>Whichever tool (or tools) your team selects for the project, I recommend their usage and efficiency be reviewed in the same manner you would review any other agile process at the end of a sprint. There is no wrong selection here, except in the case of not leveraging some sort of automation at all in your build, test, and support chain. Don’t just find something. Find<a id="_idIndexMarker215"/> what works best for your budget and your team’s skills, and can be leveraged easily within the timeframes you are allotted for the project.</p>&#13;
			<p>We will definitely be covering much more about tools and integration in later chapters, so let’s move<a id="_idTextAnchor190"/> on.</p>&#13;
			<h1 id="_idParaDest-96"><a id="_idTextAnchor191"/>Security scanning, testing, and remediation</h1>&#13;
			<p>By using <strong class="bold">Free Open Source Software</strong> (<strong class="bold">FOSS</strong>), your <a id="_idIndexMarker216"/>team can achieve many, if not all, aspects of your product’s lifecycle. Yes, I am definitely an<a id="_idIndexMarker217"/> open source advocate and have been since the late 1990s. There’s a good reason, especially in the Linux world. It’s the portability of skills.</p>&#13;
			<p>Virtually all <a id="_idIndexMarker218"/>Linux distributions share about 90% of the same available commands and utilities. What they don’t share, that other 10%, is what makes those distributions unique, scalable, or more secure than the others. For discussion’s sake, I want to focus on that 90% – the common stuff.</p>&#13;
			<p>When at a command prompt in Linux (regardless of distribution), there’s a baseline of commands we all come to know and rely upon. Granted there are variations out there, but the most common tools are what I am focusing on here.</p>&#13;
			<p>The first command line<a id="_idIndexMarker219"/> tool I want to bring up is <strong class="bold">Nmap</strong>. Nmap has a GUI counterpart <a id="_idIndexMarker220"/>called <strong class="bold">Zenmap</strong> (or in older distributions, <strong class="bold">nmap-fe</strong>). It is commonly found in virtually all distributions of Linux and on all platforms. Why? Because it is great at finding out<a id="_idIndexMarker221"/> which ports are open and even doing something called <strong class="bold">OS fingerprinting</strong> (i.e., figuring out what operating system the host is using).</p>&#13;
			<p>So, let’s take a quick look at Nmap and Zenmap in action in a quick hands-on exercise.</p>&#13;
			<h2 id="_idParaDest-97"><a id="_idTextAnchor192"/>Exercise – executing a network port scan</h2>&#13;
			<p>In this exercise, we<a id="_idIndexMarker222"/> will be running detailed network port scans on some test machines. We’ll be using two similar tools. The first tool, called <a id="_idTextAnchor193"/>Nmap, is an open source command-line port scanning tool. The second tool, called Zenmap,<a id="_idTextAnchor194"/> is also an open source tool; however, it has a graphical user interface.</p>&#13;
			<p class="callout-heading">Requirements for the exercise</p>&#13;
			<p class="callout">For this exercise, you’ll need access to a Linux host with its graphical desktop enabled along with a defined target host (to scan). In the accompanying screenshots, I’ve used Fedora® as the Linux distribution but virtually any distribution is acceptable here. Nmap should be available from your distribution’s own repositories, but we’ll need to download Zenmap from FlathubTM. On Fedora, this repository is preconfigured for you if you enable third-party repositories in the gnome-software application.</p>&#13;
			<p>First, you<a id="_idIndexMarker223"/> need to log in to the host and open a terminal session. We can usually assume that it’s not installed by default, hence we will install it before continuing. If you’ve already installed the tools, you may skip this step.</p>&#13;
			<p>Then, we’ll install the Flathub <code>flatpak</code> repository (if it’s not already installed):</p>&#13;
			<pre class="console">&#13;
$ flatpak remote-add --if-not-exists flathub \ &#13;
https://dl.flathub.org/repo/flathub.flatpakrepo&#13;
[mstonge@bm03 ~]$</pre>			<p>Next, we’ll confirm that the Flathub repository is available at the command line.</p>&#13;
			<p class="callout-heading">Tip</p>&#13;
			<p class="callout">Please note that even if this is configured within gnome-software, it may not be available on the command line unless you physically install/enable it yourself.</p>&#13;
			<pre class="console">&#13;
$ flatpak remotes&#13;
Name    Options&#13;
fedora  system,oci&#13;
flathub system</pre>			<p>Now we’ll install the <code>zenmap</code> <code>flatpak</code>.</p>&#13;
			<pre class="console">&#13;
$ sudo flatpak install zenmap&#13;
Looking for matches…&#13;
Found ref 'app/org.nmap.Zenmap/x86_64/stable' in remote 'flathub' (system).&#13;
Use this ref? [Y/n]: y&#13;
Required runtime for org.nmap.Zenmap/x86_64/stable (runtime/org.gnome.Platform/x86_64/45) found in remote flathub&#13;
Do you want to install it? [Y/n]: y&#13;
org.nmap.Zenmap permissions:&#13;
    ipc    network    x11    file access [1]&#13;
    [1] home&#13;
        ID                                  Branch          Op          &#13;
Remote           Download&#13;
 1. [✓] org.gnome.Platform.Locale           45              i           &#13;
flathub           18.1 kB / 369.6 MB&#13;
 2. [✓] org.gnome.Platform                  45              i           &#13;
flathub          242.7 MB / 378.4 MB&#13;
 3. [✓] org.nmap.Zenmap                     stable          i           &#13;
flathub            7.0 MB / 8.6 MB&#13;
Installation complete.</pre>			<p>Next, we’ll install <a id="_idIndexMarker224"/>Nmap out of the operating system’s own repository.</p>&#13;
			<pre class="console">&#13;
$ sudo dnf install -y nmap</pre>			<p>We will get the following output:</p>&#13;
			<pre class="console">&#13;
Last metadata expiration check: 0:00:27 ago on Tue 30 Apr 2024 &#13;
09:08:18 PM EDT.&#13;
Dependencies resolved.&#13;
========================================================================&#13;
 Package                Architecture             Version                 &#13;
           Repository                 Size&#13;
========================================================================&#13;
Installing:&#13;
 nmap                   x86_64                   3:7.95-1.fc40          &#13;
            updates                   5.8 M&#13;
Transaction Summary&#13;
========================================================================&#13;
Install  1 Package&#13;
Total download size: 5.8 M&#13;
Installed size: 25 M&#13;
Downloading Packages:&#13;
nmap-7.95-1.fc40.x86_64.rpm                                             &#13;
            299 kB/s | 5.8 MB     00:19&#13;
------------------------------------------------------------------------&#13;
--------------------------------------------&#13;
Total                                                                   &#13;
            297 kB/s | 5.8 MB     00:20&#13;
Fedora 40 - x86_64 - Updates                                            &#13;
            1.6 MB/s | 1.6 kB     00:00&#13;
Importing GPG key 0xA15B79CC:&#13;
 Userid     : "Fedora (40) &lt;fedora-40-primary@fedoraproject.org&gt;"&#13;
 Fingerprint: 115D F9AE F857 853E E844 5D0A 0727 707E A15B 79CC&#13;
 From       : /etc/pki/rpm-gpg/RPM-GPG-KEY-fedora-40-x86_64&#13;
Key imported successfully&#13;
Running transaction check&#13;
Transaction check succeeded.&#13;
Running transaction test&#13;
Transaction test succeeded.&#13;
Running transaction&#13;
  Preparing        :                                                   &#13;
                                         1/1&#13;
  Installing       : nmap-3:7.95-1.fc40.x86_64                         &#13;
                                         1/1&#13;
  Running scriptlet: nmap-3:7.95-1.fc40.x86_64                         &#13;
                                         1/1&#13;
Installed:&#13;
  nmap-3:7.95-1.fc40.x86_64&#13;
Complete!</pre>			<p>Here’s an example of me running a scan in my network with the Nmap utility.</p>&#13;
			<p>It’s actually me <a id="_idIndexMarker225"/>running a detailed port scan against a host called <code>ks01</code>. What we will see is the open ports and the services running.</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B22104_05_02.jpg" alt="Figure 5.2 – Nmap portscan and results" width="726" height="976"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.2 – Nmap portscan and results</p>&#13;
			<p>In that example scan, we can see that SSH and HTTP are both accessible to external hosts.</p>&#13;
			<p>First, let’s see <a id="_idIndexMarker226"/>what our options really are (<em class="italic">hint – there </em><em class="italic">are MANY!!</em>).</p>&#13;
			<pre class="console">&#13;
$ nmap --help</pre>			<p>We will get the following output:</p>&#13;
			<pre class="console">&#13;
Nmap 7.95 ( https://nmap.org )&#13;
Usage: nmap [Scan Type(s)] [Options] {target specification}&#13;
TARGET SPECIFICATION:&#13;
  Can pass hostnames, IP addresses, networks, etc.&#13;
  Ex: scanme.nmap.org, microsoft.com/24, 192.168.0.1; 10.0.0-255.1-254&#13;
  -iL &lt;inputfilename&gt;: Input from list of hosts/networks&#13;
  -iR &lt;num hosts&gt;: Choose random targets&#13;
  --exclude &lt;host1[,host2][,host3],...&gt;: Exclude hosts/networks&#13;
  --excludefile &lt;exclude_file&gt;: Exclude list from file&#13;
HOST DISCOVERY:&#13;
  -sL: List Scan - simply list targets to scan&#13;
  -sn: Ping Scan - disable port scan&#13;
  -Pn: Treat all hosts as online -- skip host discovery&#13;
  -PS/PA/PU/PY[portlist]: TCP SYN, TCP ACK, UDP or SCTP discovery to given ports&#13;
  -PE/PP/PM: ICMP echo, timestamp, and netmask request discovery probes&#13;
  -PO[protocol list]: IP Protocol Ping&#13;
  -n/-R: Never do DNS resolution/Always resolve [default: sometimes]&#13;
  --dns-servers &lt;serv1[,serv2],...&gt;: Specify custom DNS servers&#13;
  --system-dns: Use OS's DNS resolver&#13;
  --traceroute: Trace hop path to each host&#13;
SCAN TECHNIQUES:&#13;
  -sS/sT/sA/sW/sM: TCP SYN/Connect()/ACK/Window/Maimon scans&#13;
  -sU: UDP Scan&#13;
  -sN/sF/sX: TCP Null, FIN, and Xmas scans&#13;
  --scanflags &lt;flags&gt;: Customize TCP scan flags&#13;
  -sI &lt;zombie host[:probeport]&gt;: Idle scan&#13;
  -sY/sZ: SCTP INIT/COOKIE-ECHO scans&#13;
  -sO: IP protocol scan&#13;
  -b &lt;FTP relay host&gt;: FTP bounce scan&#13;
PORT SPECIFICATION AND SCAN ORDER:&#13;
  -p &lt;port ranges&gt;: Only scan specified ports&#13;
    Ex: -p22; -p1-65535; -p U:53,111,137,T:21-25,80,139,8080,S:9&#13;
  --exclude-ports &lt;port ranges&gt;: Exclude the specified ports from scanning&#13;
  -F: Fast mode - Scan fewer ports than the default scan&#13;
  -r: Scan ports sequentially - don't randomize&#13;
  --top-ports &lt;number&gt;: Scan &lt;number&gt; most common ports&#13;
  --port-ratio &lt;ratio&gt;: Scan ports more common than &lt;ratio&gt;&#13;
SERVICE/VERSION DETECTION:&#13;
  -sV: Probe open ports to determine service/version info&#13;
  --version-intensity &lt;level&gt;: Set from 0 (light) to 9 (try all probes)&#13;
  --version-light: Limit to most likely probes (intensity 2)&#13;
  --version-all: Try every single probe (intensity 9)&#13;
  --version-trace: Show detailed version scan activity (for debugging)&#13;
SCRIPT SCAN:&#13;
 -sC: equivalent to --script=default&#13;
  --script=&lt;Lua scripts&gt;: &lt;Lua scripts&gt; is a comma separated list of&#13;
           directories, script-files or script-categories&#13;
  --script-args=&lt;n1=v1,[n2=v2,...]&gt;: provide arguments to scripts&#13;
  --script-args-file=filename: provide NSE script args in a file&#13;
  --script-trace: Show all data sent and received&#13;
  --script-updatedb: Update the script database.&#13;
  --script-help=&lt;Lua scripts&gt;: Show help about scripts.&#13;
           &lt;Lua scripts&gt; is a comma-separated list of script-files or&#13;
           script-categories.&#13;
OS DETECTION:&#13;
  -O: Enable OS detection&#13;
  --osscan-limit: Limit OS detection to promising targets&#13;
  --osscan-guess: Guess OS more aggressively&#13;
TIMING AND PERFORMANCE:&#13;
  Options which take &lt;time&gt; are in seconds, or append 'ms' (milliseconds),&#13;
  's' (seconds), 'm' (minutes), or 'h' (hours) to the value (e.g. 30m).&#13;
  -T&lt;0-5&gt;: Set timing template (higher is faster)&#13;
  --min-hostgroup/max-hostgroup &lt;size&gt;: Parallel host scan group sizes&#13;
  --min-parallelism/max-parallelism &lt;numprobes&gt;: Probe parallelization&#13;
  --min-rtt-timeout/max-rtt-timeout/initial-rtt-timeout &lt;time&gt;: Specifies&#13;
      probe round trip time.&#13;
  --max-retries &lt;tries&gt;: Caps number of port scan probe retransmissions.&#13;
  --host-timeout &lt;time&gt;: Give up on target after this long&#13;
  --scan-delay/--max-scan-delay &lt;time&gt;: Adjust delay between probes&#13;
  --min-rate &lt;number&gt;: Send packets no slower than &lt;number&gt; per second&#13;
  --max-rate &lt;number&gt;: Send packets no faster than &lt;number&gt; per second&#13;
FIREWALL/IDS EVASION AND SPOOFING:&#13;
  -f; --mtu &lt;val&gt;: fragment packets (optionally w/given MTU)&#13;
  -D &lt;decoy1,decoy2[,ME],...&gt;: Cloak a scan with decoys&#13;
  -S &lt;IP_Address&gt;: Spoof source address&#13;
  -e &lt;iface&gt;: Use specified interface&#13;
  -g/--source-port &lt;portnum&gt;: Use given port number&#13;
  --proxies &lt;url1,[url2],...&gt;: Relay connections through HTTP/SOCKS4 proxies&#13;
  --data &lt;hex string&gt;: Append a custom payload to sent packets&#13;
  --data-string &lt;string&gt;: Append a custom ASCII string to sent packets&#13;
  --data-length &lt;num&gt;: Append random data to sent packets&#13;
  --ip-options &lt;options&gt;: Send packets with specified ip options&#13;
  --ttl &lt;val&gt;: Set IP time-to-live field&#13;
  --spoof-mac &lt;mac address/prefix/vendor name&gt;: Spoof your MAC address&#13;
  --badsum: Send packets with a bogus TCP/UDP/SCTP checksum&#13;
OUTPUT:&#13;
  -oN/-oX/-oS/-oG &lt;file&gt;: Output scan in normal, XML, s|&lt;rIpt kIddi3,&#13;
     and Grepable format, respectively, to the given filename.&#13;
  -oA &lt;basename&gt;: Output in the three major formats at once&#13;
  -v: Increase verbosity level (use -vv or more for greater effect)&#13;
  -d: Increase debugging level (use -dd or more for greater effect)&#13;
  --reason: Display the reason a port is in a particular state&#13;
  --open: Only show open (or possibly open) ports&#13;
  --packet-trace: Show all packets sent and received&#13;
  --iflist: Print host interfaces and routes (for debugging)&#13;
  --append-output: Append to rather than clobber specified output files&#13;
  --resume &lt;filename&gt;: Resume an aborted scan&#13;
  --noninteractive: Disable runtime interactions via keyboard&#13;
  --stylesheet &lt;path/URL&gt;: XSL stylesheet to transform XML output to HTML&#13;
  --webxml: Reference stylesheet from Nmap.Org for more portable XML&#13;
  --no-stylesheet: Prevent associating of XSL stylesheet w/XML output&#13;
MISC:&#13;
  -6: Enable IPv6 scanning&#13;
  -A: Enable OS detection, version detection, script scanning, and traceroute&#13;
  --datadir &lt;dirname&gt;: Specify custom Nmap data file location&#13;
  --send-eth/--send-ip: Send using raw ethernet frames or IP packets&#13;
  --privileged: Assume that the user is fully privileged&#13;
  --unprivileged: Assume the user lacks raw socket privileges&#13;
  -V: Print version number&#13;
  -h: Print this help summary page.&#13;
EXAMPLES:&#13;
  nmap -v -A scanme.nmap.org&#13;
  nmap -v -sn 192.168.0.0/16 10.0.0.0/8&#13;
  nmap -v -iR 10000 -Pn -p 80&#13;
SEE THE MAN PAGE (https://nmap.org/book/man.html) FOR MORE OPTIONS AND EXAMPLES</pre>			<p>Now let’s run a simple scan of a target host. Please substitute the name of your target host where I have defined my target (<code>ks01</code>); otherwise, this will not work for you. This first example is the <em class="italic">fast</em> port scan.</p>&#13;
			<pre class="console">&#13;
$ nmap -F ks01&#13;
Starting Nmap 7.95 ( https://nmap.org ) at 2024-04-30 21:41 EDT&#13;
Nmap scan report for ks01 (10.101.0.40)&#13;
Host is up (3.4s latency).&#13;
rDNS record for 10.101.0.40: ks01.local&#13;
Not shown: 68 filtered tcp ports (no-response), 30 filtered tcp ports (host-unreach)&#13;
PORT   STATE SERVICE&#13;
22/tcp open  ssh&#13;
80/tcp open  http&#13;
Nmap done: 1 IP address (1 host up) scanned in 28.40 seconds&#13;
$</pre>			<p>Now let’s do a more <a id="_idIndexMarker227"/>complex scan of our target host. Again, please substitute the name of your target host where I have listed my target (<code>ks01</code>). In this scan, we’ll be looking for detailed versioning information of the services running (when detected).</p>&#13;
			<pre class="console">&#13;
$ nmap -sV ks01&#13;
Starting Nmap 7.95 ( https://nmap.org ) at 2024-04-30 21:26 EDT&#13;
Nmap scan report for ks01 (10.101.0.40)&#13;
Host is up (0.021s latency).&#13;
rDNS record for 10.101.0.40: ks01.local&#13;
Not shown: 980 filtered tcp ports (no-response), 17 filtered tcp ports (host-unreach)&#13;
PORT     STATE SERVICE  VERSION&#13;
22/tcp   open  ssh      OpenSSH 8.7 (protocol 2.0)&#13;
80/tcp   open  http     Apache httpd 2.4.57 ((Red Hat Enterprise Linux))&#13;
9090/tcp open  ssl/http Cockpit web service 282 or later&#13;
Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel&#13;
Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .&#13;
Nmap done: 1 IP address (1 host up) scanned in 95.55 seconds</pre>			<p>Next, I will<a id="_idIndexMarker228"/> demonstrate that this Nmap tool can not just scan individual hosts but entire subnets at once. This operation can take significantly longer and the total time to execute can vary depending on how many targets are in the network.</p>&#13;
			<p class="callout-heading">Warning</p>&#13;
			<p class="callout">Don’t try this at work without prior coordination with those teams who run the network and systems – you don’t want to set off any alarms (or get yourself into trouble).</p>&#13;
			<pre class="console">&#13;
$ nmap 10.82.0.0/25&#13;
Starting Nmap 7.95 ( https://nmap.org ) at 2024-04-30 21:18 EDT&#13;
RTTVAR has grown to over 2.3 seconds, decreasing to 2.0&#13;
RTTVAR has grown to over 2.3 seconds, decreasing to 2.0&#13;
RTTVAR has grown to over 2.3 seconds, decreasing to 2.0&#13;
RTTVAR has grown to over 2.3 seconds, decreasing to 2.0&#13;
RTTVAR has grown to over 2.3 seconds, decreasing to 2.0&#13;
RTTVAR has grown to over 2.3 seconds, decreasing to 2.0&#13;
Nmap scan report for _gateway (10.82.0.1)&#13;
Host is up (0.0013s latency).&#13;
Not shown: 996 closed tcp ports (conn-refused)&#13;
PORT     STATE SERVICE&#13;
53/tcp   open  domain&#13;
80/tcp   open  http&#13;
443/tcp  open  https&#13;
1900/tcp open  upnp&#13;
Nmap scan report for 10.82.0.41&#13;
Host is up (0.93s latency).&#13;
Not shown: 856 filtered tcp ports (no-response), 141 filtered tcp ports (host-unreach)&#13;
PORT     STATE  SERVICE&#13;
22/tcp   open   ssh&#13;
80/tcp   open   http&#13;
9090/tcp closed zeus-admin&#13;
Nmap scan report for 10.82.0.42&#13;
Host is up (3.7s latency).&#13;
Not shown: 847 filtered tcp ports (no-response), 151 filtered tcp ports (host-unreach)&#13;
PORT   STATE SERVICE&#13;
22/tcp open  ssh&#13;
80/tcp open  http&#13;
Nmap scan report for bm03.local (10.82.0.52)&#13;
Host is up (0.00060s latency).&#13;
Not shown: 998 closed tcp ports (conn-refused)&#13;
PORT     STATE SERVICE&#13;
22/tcp   open  ssh&#13;
9090/tcp open  zeus-admin&#13;
Nmap done: 128 IP addresses (4 hosts up) scanned in 151.69 seconds</pre>			<p>Nmap is capable <a id="_idIndexMarker229"/>of running many types of scans and can also be somewhat intrusive if you are not careful. I recommend examining the documentation and perhaps grabbing one of the many cheat sheets on Nmap that are freely available online.</p>&#13;
			<p>Now that we’ve done a brief introduction to port scanning at the command line, let’s move on to using the slightly more feature-rich GUI tool: Zenmap.</p>&#13;
			<p>Here’s an example Zenmap scan that I ran, also targeting the same host as in the previous exercise and demonstration. Please note that the output is formatted much better than the command-line tool Nmap and there are options made available to the user for expanding upon details.</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B22104_05_03.jpg" alt="Figure 5.3 – Zenmap scan" width="1092" height="855"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.3 – Zenmap scan</p>&#13;
			<p>Here’s another<a id="_idIndexMarker230"/> example scan that I have run. This time, once I have the results, I have clicked on the <strong class="bold">Ports / Hosts</strong> tab in the interface.</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B22104_05_04.jpg" alt="Figure 5.4 – Another Zenmap scan; focus on the Ports / Hosts tab" width="953" height="563"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.4 – Another Zenmap scan; focus on the Ports / Hosts tab</p>&#13;
			<p>I cannot<a id="_idIndexMarker231"/> overemphasize the importance of ensuring that you scan release candidates for vulnerabilities, to validate open ports/services. We will touch on different types of scans in later chapters.</p>&#13;
			<p>Now that we have reviewed open source scanning, let’s move on to how one can track changes i<a id="_idTextAnchor195"/>n the appliances.</p>&#13;
			<h1 id="_idParaDest-98"><a id="_idTextAnchor196"/>Manifest and configuration tracking</h1>&#13;
			<p>The creation of a <a id="_idIndexMarker232"/>software manifest is a crucial step in knowing how to <a id="_idIndexMarker233"/>maintain the security of your systems. This ultimately is a detailed list of software packages and their respective versions. It is the sum of all packages in your operating system and your application stack, along with any additional third-party packages or combined dependencies.</p>&#13;
			<p>Knowing what <a id="_idIndexMarker234"/>goes into each and every release and where those packages come from, and curating a secure anthology of said packages will empower you to control the lifecycle of your solution.</p>&#13;
			<p>I am not saying this will be easy. It can be, but as solutions become more and more complex, this truly becomes a labored effort – especially if not everything your solutions have consumed is provided in the same format.</p>&#13;
			<p>Let me go into detail here. What if your operating system provider gives you their packages as RPMs but you have some dependencies that are<a id="_idIndexMarker235"/> downloaded as <strong class="bold">tarballs</strong>, or as flatpaks? And then what if we also run some containerized microservices on top? Tracking everything can get complex really fast. In fact, it almost becomes impossible to <a id="_idTextAnchor197"/>trac<a id="_idTextAnchor198"/>k at all. This is why change tracking and the SBOM matter. So, let’s take a look at how we can track changes i<a id="_idTextAnchor199"/>n our own appliances.</p>&#13;
			<h2 id="_idParaDest-99"><a id="_idTextAnchor200"/>Exercise – tracking changes in your product</h2>&#13;
			<p>In this <a id="_idIndexMarker236"/>exercise, we'll dive deep into how to correlate what’s in an existing build versus what changes (aka deltas) are present in the next round of updates for your appliance. Knowing which packages are new (those deltas again) will blatantly highlight what your team will need to provide to existing users as an update bundle either in a custom repository or via other methods.</p>&#13;
			<p class="callout-heading">Requirements for the exercise</p>&#13;
			<p class="callout">For this hands-on exercise, you will only need access to a Linux machine (physical or virtual). Root (or <code>sudo</code>) access is mandatory. I am doing this example on my Fedora 40 box, but you could potentially follow along with me on any RHEL-like distribution.</p>&#13;
			<p>First, we’ll create a script, using your favorite editor. Create a file called <code>my-inventory-creator.sh</code>. Ensure that you set the file permissions so that it’s executable.</p>&#13;
			<pre class="source-code">&#13;
#!/usr/bin/bash&#13;
#############################&#13;
#&#13;
# my-inventory-creator.sh&#13;
#&#13;
#############################&#13;
MYDATE=$(date +"%Y%m%d%H%M")&#13;
MYFILE1="my-software-sources_$MYDATE.txt"&#13;
MYFILE2="my-software-details_$MYDATE.txt"&#13;
# Notify user of the output filenames for this run&#13;
echo "Checking for RPMs and Flatpak sources"&#13;
echo "and what's installed..."&#13;
echo&#13;
echo "Your output files for this check are: "&#13;
echo "$MYFILE1"&#13;
echo "$MYFILE2"&#13;
# Determine software sources and output to file&#13;
dnf repolist | sort &gt; "$MYFILE1"&#13;
flatpak remotes | sort &gt;&gt; "$MYFILE1"&#13;
# Determine the software &amp; versions installed and output to file&#13;
rpm -qa | sort &gt; "$MYFILE2"&#13;
flatpak list | sort &gt;&gt; "$MYFILE2"&#13;
echo "Completed."</pre>			<p>Now let’s run the <a id="_idIndexMarker237"/>script and take note of the output file names (which include date stamps). These will be unique for you.</p>&#13;
			<pre class="console">&#13;
$ bash ./my-inventory-creator.sh</pre>			<p>We will get the following output:</p>&#13;
			<pre class="console">&#13;
Checking for RPMs and Flatpak sources&#13;
and what's installed...&#13;
Your output files for this check are:&#13;
my-software-sources_202405011944.txt&#13;
my-software-details_202405011944.txt&#13;
Completed.</pre>			<p>Now let’s review those output files. These will also be unique for your build/system. We will start with the software sources file.</p>&#13;
			<pre class="console">&#13;
$ cat my-software-sources_202405011944.txt&#13;
fedora-cisco-openh264          Fedora 40 openh264 (From Cisco) - x86_64&#13;
fedora                         Fedora 40 - x86_64&#13;
google-chrome                  google-chrome&#13;
repo id                        repo name&#13;
updates                        Fedora 40 - x86_64 - Updates&#13;
fedora  system,oci&#13;
flathub system</pre>			<p>Now let’s see the software details file (this will be long). The output of this command is huge so I will warn you upfront – I had to truncate it for space reasons.</p>&#13;
			<pre class="console">&#13;
$  cat my-software-details_202405011944.txt&#13;
aajohan-comfortaa-fonts-3.105-0.3.20210729git2a87ac6.fc40.noarch&#13;
aardvark-dns-1.10.0-1.fc40.x86_64&#13;
abattis-cantarell-fonts-0.301-12.fc40.noarch&#13;
abattis-cantarell-vf-fonts-0.301-12.fc40.noarch&#13;
abrt-2.17.5-1.fc40.x86_64&#13;
abrt-addon-ccpp-2.17.5-1.fc40.x86_64&#13;
abrt-addon-kerneloops-2.17.5-1.fc40.x86_64&#13;
abrt-addon-pstoreoops-2.17.5-1.fc40.x86_64&#13;
abrt-addon-vmcore-2.17.5-1.fc40.x86_64&#13;
abrt-addon-xorg-2.17.5-1.fc40.x86_64&#13;
abrt-cli-2.17.5-1.fc40.x86_64&#13;
(((output truncated)))&#13;
Red Hat, Inc.   io.podman_desktop.PodmanDesktop 1.9.1   stable  flathub system&#13;
Zenmap  org.nmap.Zenmap 7.94    stable  flathub system&#13;
$</pre>			<p>Now we have a<a id="_idIndexMarker238"/> complete manifest of software and sources for our build. Let’s do a quick search for a specific package. For my example, I am using <code>httpd</code>, but you can practice searching for whichever package/version you prefer.</p>&#13;
			<pre class="console">&#13;
$ grep httpd my-software-details_202405011944.txt&#13;
fedora-logos-httpd-38.1.0-5.fc40.noarch&#13;
httpd-2.4.59-2.fc40.x86_64&#13;
httpd-core-2.4.59-2.fc40.x86_64&#13;
httpd-filesystem-2.4.59-2.fc40.noarch&#13;
httpd-tools-2.4.59-2.fc40.x86_64&#13;
[mstonge@bm03 ~]$</pre>			<p>Now let’s install a package that will drag in some dependencies along with it. I’m going to install a package called <code>kdiff3</code>, which belongs to the vast family of “diff” tools that find <a id="_idIndexMarker239"/>differences in files or from command-line outputs. Again, here, the output from this command is pages and pages long, hence I have truncated it again.</p>&#13;
			<pre class="console">&#13;
$ sudo dnf install -y kdiff3&#13;
Last metadata expiration check: 0:57:55 ago on Wed 01 May 2024 07:06:13 PM EDT.&#13;
Dependencies resolved.&#13;
========================================================================================================&#13;
 Package                         Architecture Version                               Repository     Size&#13;
========================================================================================================&#13;
Installing:&#13;
 kdiff3                          x86_64       1.10.7-3.fc40                         fedora        1.9 M&#13;
Installing dependencies:&#13;
 SDL_image                       x86_64       1.2.12-37.fc40                        fedora         45 k&#13;
 aspell                          x86_64       12:0.60.8-14.fc40                     fedora        713 k&#13;
 breeze-icon-theme               noarch       6.1.0-1.fc40                          updates       9.7 M&#13;
 daala-libs                      x86_64       0-27.20200724git694d4ce.fc40          fedora        211 k&#13;
 dbusmenu-qt5                    x86_64       0.9.3-0.34.20160218.fc40              fedora         79 k&#13;
 docbook-dtds                    noarch       1.0-85.fc40                           fedora        335 k&#13;
 docbook-style-xsl               noarch       1.79.2-22.fc40                        fedora        1.5 M&#13;
 hspell                          x86_64       1.4-21.fc40                           fedora        684 k&#13;
 kde-settings                    noarch       40.0-1.fc40                           fedora         40 k&#13;
 kdsoap                          x86_64       2.2.0-4.fc40                          fedora        133 k&#13;
 kf5-kactivities                 x86_64       5.115.0-1.fc40                        fedora        137 k&#13;
 kf5-kactivities-stats           x86_64       5.115.0-1.fc40                        fedora        111 k&#13;
((( output truncated )))&#13;
Installed:&#13;
  SDL_image-1.2.12-37.fc40.x86_64                        aspell-12:0.60.8-14.fc40.x86_64&#13;
  aspell-en-50:2020.12.07-10.fc40.x86_64                 breeze-icon-theme-6.1.0-1.fc40.noarch&#13;
  daala-libs-0-27.20200724git694d4ce.fc40.x86_64         dbusmenu-qt5-0.9.3-0.34.20160218.fc40.x86_64&#13;
  docbook-dtds-1.0-85.fc40.noarch                        docbook-style-xsl-1.79.2-22.fc40.noarch&#13;
  hspell-1.4-21.fc40.x86_64                              kde-settings-40.0-1.fc40.noarch&#13;
  kdiff3-1.10.7-3.fc40.x86_64                            kdsoap-2.2.0-4.fc40.x86_64&#13;
  kf5-kactivities-5.115.0-1.fc40.x86_64                  kf5-kactivities-stats-5.115.0-1.fc40.x86_64&#13;
  kf5-karchive-5.115.0-1.fc40.x86_64                     kf5-kauth-5.115.0-1.fc40.x86_64&#13;
  kf5-kbookmarks-5.115.0-1.fc40.x86_64                   kf5-kcodecs-5.115.0-1.fc40.x86_64&#13;
(((output truncated)))&#13;
  speech-dispatcher-libs-0.11.5-5.fc40.x86_64            speexdsp-1.2.1-6.fc40.x86_64&#13;
  vlc-libs-1:3.0.20-12.fc40.x86_64                       vlc-plugin-pipewire-3-2.fc40.x86_64&#13;
  vlc-plugins-base-1:3.0.20-12.fc40.x86_64               voikko-fi-2.5-6.fc40.noarch&#13;
Complete!</pre>			<p>In the last step, we<a id="_idIndexMarker240"/> installed a single package (but it brought along 113 dependencies). So, let’s now rerun our inventory script and do some introspection on what really changed.</p>&#13;
			<p class="callout-heading">Tip</p>&#13;
			<p class="callout">Take note of the new files that were created in this run.</p>&#13;
			<pre class="console">&#13;
$ bash ./my-inventory-creator.sh&#13;
Checking for RPMs and Flatpak sources&#13;
and what's installed...</pre>			<p>Your output files for this check are:</p>&#13;
			<pre class="console">&#13;
my-software-sources_202405012008.txt&#13;
my-software-details_202405012008.txt&#13;
Completed.&#13;
$</pre>			<p>Now let’s <a id="_idIndexMarker241"/>generate a list of differences between the two file sets.</p>&#13;
			<pre class="console">&#13;
$ diff my-software-sources_202405011944.txt my-software-sources_202405012008.txt</pre>			<p class="callout-heading">Important note</p>&#13;
			<p class="callout">There was no change in the sources we drew our files from but there will be significant changes in the software details lists. Let’s do a side-by-side comparison. Please note the output will be big.</p>&#13;
			<pre class="console">&#13;
$ diff -y my-software-details_202405011944.txt my-software-details_202405012008.txt  | less&#13;
aajohan-comfortaa-fonts-3.105-0.3.20210729git2a87ac6.fc40.noa   aajohan-comfortaa-fonts-3.105-0.3.20210729git2a87ac6.fc40.noa&#13;
aardvark-dns-1.10.0-1.fc40.x86_64                               aardvark-dns-1.10.0-1.fc40.x86_64&#13;
abattis-cantarell-fonts-0.301-12.fc40.noarch                    abattis-cantarell-fonts-0.301-12.fc40.noarch&#13;
abattis-cantarell-vf-fonts-0.301-12.fc40.noarch                 abattis-cantarell-vf-fonts-0.301-12.fc40.noarch&#13;
abrt-2.17.5-1.fc40.x86_64                                       abrt-2.17.5-1.fc40.x86_64&#13;
abrt-addon-ccpp-2.17.5-1.fc40.x86_64                            abrt-addon-ccpp-2.17.5-1.fc40.x86_64&#13;
((( output truncated )))&#13;
brcmfmac-firmware-20240410-1.fc40.noarch                        brcmfmac-firmware-20240410-1.fc40.noarch&#13;
                                                              <strong class="bold">&gt; breeze-icon-theme-6.1.0-1.fc40.noarch</strong>&#13;
brlapi-0.8.5-13.fc40.x86_64                                     brlapi-0.8.5<a id="_idTextAnchor201"/>-13.fc40.x86_64&#13;
((( output truncated )))</pre>			<p>You’ll now <a id="_idIndexMarker242"/>be able to see what was added (or changed) with this method. In the above example, there are 114 changes (actually, additions). I only truncated the output to save space and not bore you with the details.</p>&#13;
			<p>This is where I prefer to leverage some GUI-based tools like the one I just installed. Let’s take a quick look at <code>kdiff3</code>.</p>&#13;
			<p>We’ll select the same files from the previous steps.</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B22104_05_05.jpg" alt="Figure 5.5 – Starting the kdiff3 comparison operation" width="699" height="465"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.5 – Starting the kdiff3 comparison operation</p>&#13;
			<p>Next, select <a id="_idIndexMarker243"/>the files in the interface. <strong class="bold">A (Base)</strong> is the older software details file. Finally, select the file for <strong class="bold">B</strong> as the latest one.</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B22104_05_06.jpg" alt="Figure 5.6 – Selecting the files" width="836" height="532"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.6 – Selecting the files</p>&#13;
			<p>Now that<a id="_idIndexMarker244"/> we’ve defined all the files to compare, we click <strong class="bold">OK</strong>.</p>&#13;
			<p>The output of this will highlight the differences graphically in the two lists.</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B22104_05_07.jpg" alt="Figure 5.7 – Running the comparison" width="843" height="658"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.7 – Running the comparison</p>&#13;
			<p>The<a id="_idIndexMarker245"/> differences are crucial knowledge for you and your team. With this knowledge, you know which files you’ll need to curate proper update releases for your customers (assuming you run this type of comparison as part of your release candidate review process). This is the perfect segue to our next section on how to provide update control mecha<a id="_idTextAnchor202"/>nisms within your product.</p>&#13;
			<h1 id="_idParaDest-100"><a id="_idTextAnchor203"/>Update control mechanisms</h1>&#13;
			<p>One of <a id="_idIndexMarker246"/>my favorite discussions over the years with my embedded partners has been how to create a proper update methodology along with the processes and the infrastructure to support it. Ultimately, we already know – based on the customers’ operating environment, use cases, and compliance footprint – whether these mechanisms will be simple and online, or offline and complex.</p>&#13;
			<p>Your choices here will directly impact the User Interface (UI) of your product. Packaging your software and configurations will simplify lifecycle management and support costs while improving end-user experiences.</p>&#13;
			<p>For this next set of exercises, we will assume that your team has chosen to package up your special sauce along with using RPM packages and custom repositories in both your build and support chains. This is the easiest route but not always the most feasible.</p>&#13;
			<p>We will cover other update control mechanisms later (and online in the book’s GitHub repository). They can be (but are not limited to) encrypted tarballs, ISO images, thumb drives, FTP bundles, and many others. Each of those will require additional work in your build chain and vastly more attention in the support chain, not to mention more support staff who are better trained.</p>&#13;
			<p>Now that we have reviewed how to track and document changes in your appliance, let’s move on to another key facet of maintaining control of your SBOM – thi<a id="_idTextAnchor204"/>s time, via custom packaging.</p>&#13;
			<h2 id="_idParaDest-101"><a id="_idTextAnchor205"/>Exercise – building custom software packages</h2>&#13;
			<p>I hope you are ready for <a id="_idIndexMarker247"/>some typing. We’re going to start building here. As there are a million things that you can do within your own custom packages, I will only cover something that’s near and dear to some embedded systems best practices, and that’s creating your own release definition file.</p>&#13;
			<p>The following link that I am sharing is somewhat the <em class="italic">go-to</em> reference for all things RPM-based. I recommend spending some serious time there:</p>&#13;
			<p><a href="https://rpm-packaging-guide.github.io/">https://rpm-packaging-guide.github.io/</a></p>&#13;
			<p class="callout-heading">Requirements for the exercise</p>&#13;
			<p class="callout">You’ll need access to a Linux server. Root or <code>sudo</code> access is mandatory. A little bit about my demo environment – I am running Fedora 40 Workstation and I have created a user called <code>mattbuild</code> (you can create your own build environment user before starting this exercise) and I’ve added it to the <code>sudoers</code> file. Now let’s set up your RPM package building environment.</p>&#13;
			<p>First, we’ll install <a id="_idIndexMarker248"/>the packaging tools (along with their numerous dependencies).</p>&#13;
			<pre class="console">&#13;
$ sudo dnf install -y fedora-packager fedora-review \&#13;
rpm-build rpm-devel rpmlint make python \&#13;
coreutils diffutils rpmdevtools&#13;
  ((( OUTPUT Truncated )))&#13;
Complete!</pre>			<p>Next, we’ll modify the user account we are using to build the packages to become a member of the <em class="italic">mock</em> system group.</p>&#13;
			<pre class="console">&#13;
$ sudo usermod -a -G mock mattbuild</pre>			<p>Finally, we’ll confirm the changes to the user account. You can either leverage the <code>newgrp</code> command or log out and log back in to reset your environment. Once you’ve done either of those, validate that the group changes have taken effect.</p>&#13;
			<pre class="console">&#13;
$ newgrp&#13;
$ id&#13;
uid=1001(mattbuild) gid=1001(mattbuild) groups=1001(mattbuild),135(mock) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023&#13;
[mattbuild@fedora  ~]$</pre>			<p>Now let’s create a proper rpm build environment for that user. Running the <code>rpmdev-setuptree</code> command will build a folder structure that is required for the build process.</p>&#13;
			<pre class="console">&#13;
$ rpmdev-setuptree&#13;
$ tree rpmbuild/&#13;
rpmbuild/&#13;
├── BUILD&#13;
├── RPMS&#13;
├── SOURCES&#13;
├── SPECS&#13;
└── SRPMS&#13;
6 directories, 0 files</pre>			<p>Now let’s <a id="_idIndexMarker249"/>create a <code>.spec</code> file for our project. I use <code>vi</code> or <code>vim</code>, but feel free to use your favorite. I’ll place a copy of this file in the GitHub repository in case you do not want to type this one out.</p>&#13;
			<pre class="console">&#13;
$ vi myapprel.spec</pre>			<p>Now, we’ll edit the contents of the file. Be sure to save your file when done.</p>&#13;
			<p class="callout-heading">Important note</p>&#13;
			<p class="callout">Only use <em class="italic">spaces</em> and not <em class="italic">tabs</em> anywhere in this file.</p>&#13;
			<pre class="source-code">&#13;
(code - myapprel.spec)&#13;
Name:          myapprel&#13;
Version:       1.0&#13;
Release:       1&#13;
Summary:       Example custom app release file installer&#13;
License:       MIT License&#13;
%description&#13;
This will install a custom release text for your appliance&#13;
%prep&#13;
# we have no source code - so let's skip this&#13;
%build&#13;
cat &gt; myappliance-release &lt;&lt; EOF&#13;
Welcome to my secure embedded linux system&#13;
version 1.0&#13;
EOF&#13;
%install&#13;
mkdir -p %{buildroot}/etc&#13;
install -m 644 myappliance-release %{buildroot}/etc/myappliance-release&#13;
%files&#13;
/etc/&#13;
/etc/myappliance-release&#13;
%changelog&#13;
# nothing to report on the first attempt</pre>			<p>Now let’s try <a id="_idIndexMarker250"/>our first rpm build. The output for this will be huge (so I’m not going to bother listing it all).</p>&#13;
			<pre class="console">&#13;
$ rpmbuild -ba myapprel.spec&#13;
warning: source_date_epoch_from_changelog set but %changelog is missing&#13;
Executing(%prep): /bin/sh -e /var/tmp/rpm-tmp.w4pHxJ&#13;
+ umask 022&#13;
+ cd /home/mattbuild/rpmbuild/BUILD&#13;
+ RPM_EC=0&#13;
++ jobs -p&#13;
+ exit 0&#13;
Executing(%build): /bin/sh -e /var/tmp/rpm-tmp.q2Jeer&#13;
+ umask 022&#13;
+ cd /home/mattbuild/rpmbuild/BUILD&#13;
+ CFLAGS='-O2 -flto=auto -ffat-lto-objects -fexceptions -g -grecord-gcc-switches -pipe -Wall -Werror=format-security -Wp,-U_FORTIFY_SOURCE,-D_FORTIFY_SOURCE=3 -Wp,-D_GLIBCXX_ASSERTIONS -specs=/usr/lib/rpm/redhat/redhat-hardened-cc1 -fstack-protector-strong -specs=/usr/lib/rpm/redhat/redhat-annobin-cc1  -m64   -mtune=generic -fasynchronous-unwind-tables -fstack-clash-protection -fcf-protection -fno-omit-frame-pointer -mno-omit-leaf-frame-pointer '&#13;
+ export CFLAGS&#13;
(((output truncated)))</pre>			<p>Now let’s do a test install.</p>&#13;
			<pre class="console">&#13;
$ cp ./rpmbuild/RPMS/x86_64/myapprel-1.0-1.x86_64.rpm ~/&#13;
[mattbuild@fedora  ~]$    total 12&#13;
-rw-r--r--. 1 mattbuild mattbuild 6861 Apr 20 16:37 myapprel-1.0-1.x86_64.rpm&#13;
-rw-r--r--. 1 mattbuild mattbuild  572 Apr 20 16:35 myapprel.spec&#13;
drwxr-xr-x. 8 mattbuild mattbuild   89 Apr 20 16:05 rpmbuild&#13;
[mattbuild@fedora  ~]$    sudo dnf install -y ./myapprel-1.0-1.x86_64.rpm&#13;
[sudo] password for mattbuild:&#13;
Last metadata expiration check: 0:08:09 ago on Sat 20 Apr 2024 04:31:26 PM EDT.&#13;
Dependencies resolved.&#13;
=======================================================================&#13;
 Package                     Architecture              Version         &#13;
           Repository                       Size&#13;
=======================================================================&#13;
Installing:&#13;
 myapprel                    x86_64                    1.0-1           &#13;
           @commandline                   6.7 k&#13;
Transaction Summary&#13;
=======================================================================&#13;
Install  1 Package&#13;
Total size: 6.7 k&#13;
Installed size: 55&#13;
Downloading Packages:&#13;
Running transaction check&#13;
Transaction check succeeded.&#13;
Running transaction test&#13;
Transaction test succeeded.&#13;
Running transaction&#13;
  Preparing        :                                                  &#13;
                                              1/1&#13;
  Installing       : myapprel-1.0-1.x86_64                            &#13;
                                              1/1&#13;
  Verifying        : myapprel-1.0-1.x86_64                            &#13;
                                              1/1&#13;
Installed:&#13;
  myapprel-1.0-1.x86_64&#13;
Complete!&#13;
$</pre>			<p>Alright! We <a id="_idIndexMarker251"/>have our first custom package and our first custom file installer (and it works!)</p>&#13;
			<p>Let’s show it off.</p>&#13;
			<pre class="console">&#13;
$ cat /etc/myappliance-release&#13;
Welcome to my secure embedded linux system&#13;
version 1.0</pre>			<p>Great job! Now you are on your way to securing your software supply chain by creating your own packages. I truly hope you had at least a little fun in this exercise.</p>&#13;
			<h2 id="_idParaDest-102"><a id="_idTextAnchor206"/>Exercise – signing your custom RPM package</h2>&#13;
			<p>Now it’s <a id="_idIndexMarker252"/>time for extra credit. This is not an introductory course. This is a master-level course. Yes, it’s great we can now create a custom RPM package but we are focusing on securing your software supply chain in this chapter. Time to step things up. It’s time to add your own GPG signature to your custom package!</p>&#13;
			<p>First, we’re going to leave the build account and switch over to root access.</p>&#13;
			<pre class="console">&#13;
$ su -&#13;
#</pre>			<p>We’re now going to ensure you have the right software installed to sign the RPMs that you build for your appliance. Install the <code>rpm-sign</code> package.</p>&#13;
			<pre class="console">&#13;
# dnf install rpm-sign&#13;
Last metadata expiration check: 1:37:57 ago on Sat 20 Apr 2024 04:31:26 PM EDT.&#13;
Dependencies resolved.&#13;
================================================================================&#13;
========================================&#13;
 Package                    Architecture             Version                    &#13;
        Repository                 Size&#13;
=================================================================================&#13;
=======================================&#13;
Installing:&#13;
 rpm-sign                   x86_64                   4.19.1.1-1.fc39             &#13;
       updates                    22 k&#13;
Transaction Summary&#13;
=================================================================================&#13;
=======================================&#13;
Install  1 Package&#13;
Total download size: 22 k&#13;
Installed size: 22 k&#13;
Is this ok [y/N]: n&#13;
Operation aborted.&#13;
[root@bm02 ~]# dnf install -y rpm-sign&#13;
Last metadata expiration check: 1:38:20 ago on Sat 20 Apr 2024 04:31:26 PM EDT.&#13;
Dependencies resolved.&#13;
=======================================================================&#13;
 Package                    Architecture             Version                     &#13;
       Repository                 Size&#13;
=======================================================================&#13;
Installing:&#13;
 rpm-sign                   x86_64                   4.19.1.1-1.fc39              &#13;
      updates                    22 k&#13;
Transaction Summary&#13;
=======================================================================&#13;
Install  1 Package&#13;
Total download size: 22 k&#13;
Installed size: 22 k&#13;
Downloading Packages:&#13;
rpm-sign-4.19.1.1-1.fc39.x86_64.rpm                                 &#13;
              &#13;
       49 kB/s |  22 kB     00:00&#13;
-------------------------------------------------------------------&#13;
---------------&#13;
--------------------------------------&#13;
Total                                                               &#13;
                     28 kB/s |  22 kB     00:00&#13;
Running transaction check&#13;
Transaction check succeeded.&#13;
Running transaction test&#13;
Transaction test succeeded.&#13;
Running transaction&#13;
  Preparing        :                                                &#13;
                                                                  1/1&#13;
  Installing       : rpm-sign-4.19.1.1-1.fc39.x86_64                 &#13;
                                               1/1&#13;
  Running scriptlet: rpm-sign-4.19.1.1-1.fc39.x86_64                 &#13;
                                         1/1&#13;
  Verifying        : rpm-sign-4.19.1.1-1.fc39.x86_64                 &#13;
                                              1/1&#13;
Installed:&#13;
  rpm-sign-4.19.1.1-1.fc39.x86_64&#13;
Complete!</pre>			<p>In this <a id="_idIndexMarker253"/>next set of steps, you’re going to generate your own super-cool secure <code>gpg</code> key. When you do this for real in production, you must ensure that you are using official names, email addresses, and so on for your <code>gpg</code> key.</p>&#13;
			<p>For this example, we’ll use the name of John Doe with an email address of <code>john_doe@gmail.com</code> and the not-so-secure passphrase of <code>Embedded</code>. This next command is interactive and some of the dialogs actually present what I comically call screen vomit in order to keep the users’ attention to the dialogs. Others may simply call this a loosely managed <strong class="bold">Text User </strong><strong class="bold">Interface</strong> (<strong class="bold">TUI</strong>).</p>&#13;
			<p class="callout-heading">Important note</p>&#13;
			<p class="callout">Use <code>gpg --full-generate-key</code> for a full-featured key generation dialog.</p>&#13;
			<pre class="console">&#13;
# gpg --gen-key&#13;
gpg (GnuPG) 2.4.4; Copyright (C) 2024 g10 Code GmbH&#13;
This is free software: you are free to change and redistribute it.&#13;
There is NO WARRANTY, to the extent permitted by law.&#13;
GnuPG needs to construct a user ID to identify your key.&#13;
Real name: John Doe&#13;
Email address: john_doe@gmail.com&#13;
You selected this USER-ID:&#13;
    "John Doe &lt;john_doe@gmail.com&gt;"&#13;
Change (N)ame, (E)mail, or (O)kay/(Q)uit?</pre>			<p>Next, the <a id="_idIndexMarker254"/>following dialog will appear; you’ll enter the passphrase <code>Embedded</code> and select <code>&lt;OK&gt;</code> to continue.</p>&#13;
			<pre class="console">&#13;
Please enter the passphrase to protect your new key&#13;
 Passphrase: ________________________________________&#13;
       &lt;OK&gt;                              &lt;Cancel&gt;</pre>			<p>You will most likely get scolded by the system for not using a super-secure passphrase, but this is training, so select <code>&lt;Take this one anyway&gt;</code> to continue. One just has to love these interactive text interfaces. They really do prevent you from having to learn a command line that’s a mile long.</p>&#13;
			<pre class="console">&#13;
Warning: You have entered an insecure passphrase.&#13;
A passphrase should contain at least 1 digit or special character.&#13;
 &lt;Take this one anyway&gt;             &lt;Enter new passphrase&gt;</pre>			<p>We’re almost there in getting the key created. We must confirm the passphrase <code>Embedded</code> to continue.</p>&#13;
			<pre class="console">&#13;
 Please re-enter this passphrase&#13;
   Passphrase: ________________________________________&#13;
       &lt;OK&gt;                              &lt;Cancel&gt;</pre>			<p>And let’s watch<a id="_idIndexMarker255"/> it do its work. Your output should appear much like this (but not exactly as each key generation is unique).</p>&#13;
			<pre class="console">&#13;
We need to generate a lot of random bytes. It is a good idea to perform some other action (type on the keyboard, move the mouse, utilize the disks) during the prime generation; this gives the random number generator a better chance to gain enough entropy.&#13;
We need to generate a lot of random bytes. It is a good idea to perform some other action (type on the keyboard, move the mouse, utilize the disks) during the prime generation; this gives the random number generator a better chance to gain enough entropy.&#13;
gpg: directory '/root/.gnupg/openpgp-revocs.d' created&#13;
gpg: revocation certificate stored as '/root/.gnupg/openpgp-revocs.d/417CAC67C4F673DEDC13C95CA01133131459C4AD.rev'&#13;
public and secret key created and signed.&#13;
pub   ed25519 2024-04-20 [SC] [expires: 2027-04-20]&#13;
      417CAC67C4F673DEDC13C95CA01133131459C4AD&#13;
uid                 Matt St. Onge &lt;matt_st_onge@yahoo.com&gt;&#13;
sub   cv25519 2024-04-20 [E] [expires: 2027-04-20]&#13;
[root@fedora  ~]#</pre>			<p>So now let’s take a look at all the keys on our system so far.</p>&#13;
			<pre class="console">&#13;
# gpg --list-keys&#13;
gpg: checking the trustdb&#13;
gpg: marginals needed: 3  completes needed: 1  trust model: pgp&#13;
gpg: depth: 0  valid:   1  signed:   0  trust: 0-, 0q, 0n, 0m, 0f, 1u&#13;
gpg: next trustdb check due at 2027-04-20&#13;
[keyboxd]&#13;
---------&#13;
pub   ed25519 2024-04-20 [SC] [expires: 2027-04-20]&#13;
      417CAC67C4F673DEDC13C95CA01133131459C4AD&#13;
uid           [ultimate] John Doe &lt;john_doe@gmail.com&gt;&#13;
sub   cv25519 2024-04-20 [E] [expires: 2027-04-20]</pre>			<p>Your key is <a id="_idIndexMarker256"/>now imported. Let’s query the <code>rpm</code> database to see if it’s actually there. A simple query may not be sufficient, so we might need to add in some field parsing.</p>&#13;
			<pre class="console">&#13;
# rpm -q gpg-pubkey&#13;
gpg-pubkey-18b8e74c-62f2920f&#13;
gpg-pubkey-7fac5991-45f06f46&#13;
gpg-pubkey-d38b4796-570c8cd3&#13;
gpg-pubkey-1459c4ad-6624378b&#13;
#    rpm -q gpg-pubkey --qf '%{name}-%{version}-%{release} --&gt; %{summary}\n'&#13;
gpg-pubkey-18b8e74c-62f2920f --&gt; Fedora (39) &lt;fedora-39-primary@fedoraproject.org&gt; public key&#13;
gpg-pubkey-7fac5991-45f06f46 --&gt; Google, Inc. Linux Package Signing Key &lt;linux-packages-keymaster@google.com&gt; public key&#13;
gpg-pubkey-d38b4796-570c8cd3 --&gt; Google Inc. (Linux Packages Signing Authority) &lt;linux-packages-keymaster@google.com&gt; public key&#13;
gpg-pubkey-1459c4ad-6624378b --&gt; John Doe &lt;john_doe@gmail.com&gt; public key</pre>			<p>Okay. Now, let’s set up the signing environment for root and then verify that it is all ready to go. As <a id="_idIndexMarker257"/>root, use your favorite editor to create the <code>.rpmmacros</code> file in the root home directory.</p>&#13;
			<pre class="console">&#13;
# vi .rpmmacros</pre>			<p>Here’s what you’ll need to place in the <code>.rpmmacros</code> file. Don’t forget to save the file.</p>&#13;
			<pre class="source-code">&#13;
%_signature gpg&#13;
%_gpg_path /root/.gnupg&#13;
%_gpg_name Matt St. Onge&#13;
%_gpgbin /usr/bin/gpg2</pre>			<p>As many have heard me say (probably far too often), <em class="italic">Trust but verify</em>. So verify!</p>&#13;
			<pre class="console">&#13;
# rpm --showrc | grep __gpg_sign_cmd -A 5&#13;
-13: __gpg_sign_cmd     %{shescape:%{__gpg}}&#13;
        gpg --no-verbose --no-armor --no-secmem-warning&#13;
        %{?_gpg_digest_algo:--digest-algo=%{_gpg_digest_algo}}&#13;
        %{?_gpg_sign_cmd_extra_args}&#13;
        %{?_gpg_name:-u %{shescape:%{_gpg_name}}}&#13;
        -sbo %{shescape:%{?__signature_filename}}&#13;
#</pre>			<p>The magic moment that you’ve been waiting for. Let’s sign the RPM that you just built with your shiny new <code>GPG</code> key! Remember you’ll be asked for our super-secret passphrase – <code>Embedded</code>. Enter it and then select <code>&lt;OK&gt;</code>.</p>&#13;
			<pre class="console">&#13;
# cp ~mattbuild/myapprel-1.0-1,x86_65.rpm ~/&#13;
# rpm --addsign myapprel-1.0-1.x86_64.rpm&#13;
 Please enter the passphrase to unlock the OpenPGP secret key: x&#13;
  "Matt St. Onge &lt;matt_st_onge@yahoo.com&gt;"&#13;
   255-bit EDDSA key, ID A01133131459C4AD,&#13;
 created 2024-04-20.&#13;
  Passphrase: _________________________________________ x&#13;
      &lt;OK&gt;                                   &lt;Cancel&gt;&#13;
[root@fedora  ~]#</pre>			<p>You’ve created<a id="_idIndexMarker258"/> your first custom file that aligns with embedded best practices by installing a release file in your appliance. Since security is paramount in the software supply chain, you’ve also ensured the sanctity of your package by adding your own <code>GPG</code> key signature. Pat yourself on the back.</p>&#13;
			<p>Show off that awesome new skill set by testing the package again.</p>&#13;
			<pre class="console">&#13;
# rpm -K ./myapprel-1.0-1.x86_64.rpm&#13;
./myapprel-1.0-1.x86_64.rpm: digests signatures OK&#13;
#</pre>			<p>Here we are. Journey complete. Let’s move on to the next ste<a id="_idTextAnchor207"/>ps in securing our software supply chain.</p>&#13;
			<h2 id="_idParaDest-103"><a id="_idTextAnchor208"/>Exercise – creating a custom DNF repository</h2>&#13;
			<p>There are <a id="_idIndexMarker259"/>actually two schools of thought on this. One creates separate repositories for the applications stack and the operating system, and the other simply puts it all in a monolithic custom repository. I prefer the latter. I say just put it all together as tracking gets simpler. I also believe in the creation of numerous custom RPMs in the said repository that shall assist your team in the maintenance of your solution. I can literally feel my own eyes rolling when I type that. Am I repeating myself? Probably.</p>&#13;
			<p>What else should go in this custom repository? First, I recommend an rpm that defines your release, much like we created just a little while ago. Second, I recommend the creation of a documentation rpm to be separate from your application itself. Finally, and most importantly, I <a id="_idIndexMarker260"/>strongly recommend the creation of an rpm that installs your repository information directly into the appliance. Defining the repository in its own rpm is key. It aids in the support and lifecycle of the solution and if you need to make changes to the repository (or the GPG keys), it gives you the simplest way of updating it for the end-customer.</p>&#13;
			<p>These custom repositories are not just for the appliances’ updates. They can be greatly leveraged internally as part of your secure build chain. So, with all that said, how do we build a custom repository?</p>&#13;
			<p class="callout-heading">Requirements for the exercise</p>&#13;
			<p class="callout">For this hands-on exercise, you will only need access to a Linux machine (physical or virtual). Root (or <code>sudo</code>) access is mandatory. I am doing this example on my Fedora 40 box, but you could potentially follow along with me on any RHEL-like distribution.</p>&#13;
			<p>First, we’ll ensure that <code>httpd</code> and the <code>createrepo</code> utility are installed. Then, we’ll also make sure that the web server is actively running.</p>&#13;
			<pre class="console">&#13;
# dnf install httpd createrepo -y&#13;
….output truncated&#13;
Complete!&#13;
# systemctl enable –now httpd&#13;
Created symlink /etc/systemd/system/multi-user.target.wants/httpd.service → /usr/lib/systemd/system/httpd.service.&#13;
# systemctl status httpd&#13;
● httpd.service - The Apache HTTP Server&#13;
     Loaded: loaded (/usr/lib/systemd/system/httpd.service; enabled; preset: disabled)&#13;
    Drop-In: /usr/lib/systemd/system/service.d&#13;
             └─10-timeout-abort.conf&#13;
     Active: active (running) since Mon 2024-04-22 21:39:01 EDT; 31s ago&#13;
       Docs: man:httpd.service(8)&#13;
   Main PID: 2712 (httpd)&#13;
     Status: "Total requests: 0; Idle/Busy workers 100/0;Requests/sec: 0; Bytes served/sec:   0 B/sec"&#13;
      Tasks: 177 (limit: 38325)&#13;
     Memory: 19.7M&#13;
        CPU: 93ms&#13;
     CGroup: /system.slice/httpd.service&#13;
             ├─2712 /usr/sbin/httpd -DFOREGROUND&#13;
             ├─2713 /usr/sbin/httpd -DFOREGROUND&#13;
             ├─2715 /usr/sbin/httpd -DFOREGROUND&#13;
             ├─2716 /usr/sbin/httpd -DFOREGROUND&#13;
             └─2717 /usr/sbin/httpd -DFOREGROUND&#13;
Apr 22 21:39:01 bm02.local systemd[1]: Starting httpd.service - The Apache HTTP Server...&#13;
Apr 22 21:39:01 bm02.local (httpd)[2712]: httpd.service: Referenced but unset environment variable evaluates to an&gt;&#13;
Apr 22 21:39:01 bm02.local httpd[2712]: Server configured, listening on: port 80&#13;
Apr 22 21:39:01 bm02.local systemd[1]: Started httpd.service - The Apache HTTP Server.&#13;
lines 1-22/22 (END)</pre>			<p>Next, we’ll <a id="_idIndexMarker261"/>create a folder under the html directory for our repository. Then we’ll copy the rpm we created in the previous exercise to the directory.</p>&#13;
			<pre class="console">&#13;
# cd /var/www/html&#13;
# mkdir myapp-for-x86_64-rpms&#13;
# cd myapp-for-x86_64-rpms&#13;
# cp ~/myapprel-1.0-1.x86_64.rpm .&#13;
# ls -l&#13;
total 8&#13;
-rw-r--r--. 1 root root 6861 Apr 22 21:44 myapprel-1.0-1.x86_64.rpm&#13;
[root@bm02 myapp-for-x86_64-rpms]#</pre>			<p>Next, we’ll initialize the repository.</p>&#13;
			<pre class="console">&#13;
# createrepo /var/www/html/myapp-for-x86_64-rpms/&#13;
Directory walk started&#13;
Directory walk done - 1 packages&#13;
Temporary output repo path: /var/www/html/myapp-for-x86_64-rpms/.repodata/&#13;
Pool started (with 5 workers)&#13;
Pool finished&#13;
#</pre>			<p>Test to ensure that we can access the repository via a web browser locally.</p>&#13;
			<p>Here’s an example of what you’ll see by testing on a local browser. It will show you an accessible set of contents in your newly created custom repository.</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B22104_05_08.jpg" alt="Figure 5.8 – Localhost view of repository in a web browser" width="892" height="340"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.8 – Localhost view of repository in a web browser</p>&#13;
			<p>Other steps<a id="_idIndexMarker262"/> for this internal repository are to enable <code>http</code> on the firewall (so our new repo can be accessed by machines in your lab internally) and, if in use, set the <code>selinux</code> file context for the repositories directory and files to <code>httpd_syscontent_t</code>. As this is not a basic sysadmin book, I trust you and your team already know how to do those simple tasks.</p>&#13;
			<p>This is generally an OK setup for a lab. This setup is beyond unacceptable for anything externally facing (i.e., internet-facing). For that use case, there are many books and resources available on how to secure your web server; however, I will make some baseline recommendations that should go without saying.</p>&#13;
			<p>For a public-facing web server, your system should be using <code>https</code> with a signed certificate. The server should be in your company’s external DNS so the customers can find it. Methods to control access, perhaps at an individual customer or user level, should be applied. Protect your system as best you can.</p>&#13;
			<p>Now that we’ve created <a id="_idIndexMarker263"/>a custom package and hosted it via a custom repository, all that remains is how to configure the appliances to consume the new custom content. This n<a id="_idTextAnchor209"/>ext exercise will walk you through just that.</p>&#13;
			<h2 id="_idParaDest-104"><a id="_idTextAnchor210"/>Exercise – configuring your solution to use your custom repository</h2>&#13;
			<p>Let’s now<a id="_idIndexMarker264"/> configure our appliance to access our custom repository. This is a key step in ensuring that only your tested and vetted content is provided to your end-users in the future.</p>&#13;
			<p class="callout-heading">Requirements for the exercise</p>&#13;
			<p class="callout">For this hands-on exercise, you will need access to the same Linux machine where you previously created a sample repository along with another machine to configure for accessing the said repository. Root (or <code>sudo</code>) access is mandatory. I am doing this example on my Fedora 40 box, but you could potentially follow along with me on any RHEL-like distribution.</p>&#13;
			<p>These files are stored under <code>/etc/yum.repos.d/</code> and have the file extension of <code>.repo</code>. They should be owned by root, readable by all, but not writable by anyone else other than root. This will keep them secure.</p>&#13;
			<p>So before you create your own example repository definition file, let’s take a look at a detailed breakdown of one I created for the custom repository in the earlier exercise. Here is an example file called <code>mycustomstuff.repo</code>. I will place a copy of this file in the GitHub repository in case you do not wish to type this one out.</p>&#13;
			<pre class="source-code">&#13;
# ID definition of the repository&#13;
[my-custom-stuff]&#13;
# NAME of the repository&#13;
name=my-custom-stuff&#13;
# the base URL - update this for your systems information&#13;
baseurl=http://bm02.local/myapp-for-x86_64-rpms/&#13;
# Repository enabled =1 ... disabled =0&#13;
enabled=1&#13;
# setting up a gpg key for the repo is a great idea if public facing&#13;
# repo gpg check enabled =1 disabled =0&#13;
repo_gpgcheck=0&#13;
# definition for the gpg key for the repo itself (if enabled)&#13;
# example formatting:&#13;
# gpgkey=file:///(path to file)&#13;
# (or)&#13;
# gpgkey=(URL to gpgkey)&#13;
#</pre>			<p>Now that you <a id="_idIndexMarker265"/>have an example, create your own <code>mycustomstuff.repo</code> file and place it on the Linux machine that is not hosting the repo. The file should be owned by root but be readable by all groups and all users.</p>&#13;
			<p>Once you have completed that, test the functionality by installing the RPM package <code>myapprel</code> on the machine where you’ve set up the repository access.</p>&#13;
			<pre class="console">&#13;
$ sudo dnf install -y myapprel&#13;
Last metadata expiration check: 0:21:52 ago on Wed 01 May 2024 10:45:50 PM EDT.&#13;
Dependencies resolved.&#13;
=======================================================================&#13;
===================================&#13;
 Package                 Architecture          Version               &#13;
Repository                      Size&#13;
======================================================================&#13;
====================================&#13;
Installing:&#13;
 myapprel                x86_64                1.0-1                 &#13;
my-custom-stuff                6.7 k&#13;
Transaction Summary&#13;
=====================================================================&#13;
=====================================&#13;
Install  1 Package&#13;
Total download size: 6.7 k&#13;
Installed size: 55&#13;
Downloading Packages:&#13;
myapprel-1.0-1.x86_64.rpm                                        &#13;
         1.9 MB/s | 6.7 kB     00:00&#13;
-----------------------------------------------------------------&#13;
-----------------------------------------&#13;
Total                                                             &#13;
        670 kB/s | 6.7 kB     00:00&#13;
Running transaction check&#13;
Transaction check succeeded.&#13;
Running transaction test&#13;
Transaction test succeeded.&#13;
Running transaction&#13;
  Preparing        :                                              &#13;
                                    1/1&#13;
  Installing       : myapprel-1.0-1.x86_64                        &#13;
                                    1/1&#13;
  Verifying        : myapprel-1.0-1.x86_64                        &#13;
                                    1/1&#13;
Installed:&#13;
  myapprel-1.0-1.x86_64&#13;
Complete!</pre>			<p>Now that we’ve <a id="_idIndexMarker266"/>successfully attached our system to the repository and installed our custom package, we can celebrate our success. These exercises are crucial to how your team will b<a id="_idTextAnchor211"/>e able to support your appliances in the future.</p>&#13;
			<p class="callout-heading">Other concerns to account for</p>&#13;
			<p class="callout">This should go without saying, but I will say it anyway. Have actual people test your prototypes and release candidates. Only this will let your team know if you have truly achieved success. I am not saying that you should not test with automation – actually, quite the opposite. Do both. Do all the automated tests, the penetration tests, and the scans first. Once satisfied with those results, move on to human trials.</p>&#13;
			<p class="callout">You must also test your processes and support infrastructure. Test how new releases will impact the support chain and how each new release will be consumed by your customers. Failed or broken updates can cause outages, service blockages, unusable appliances, and, worst of all, very disgruntled and dissatisfied customers.</p>&#13;
			<h1 id="_idParaDest-105"><a id="_idTextAnchor212"/>Summary</h1>&#13;
			<p>So, let’s recap. We truly have covered a lot of material in this chapter. You should feel that you’ve achieved some level of success. You have come a long way in a short time. Initially, you established your appliance’s bill of materials (SBOM), and then you defined your own custom packages, releases, and custom repositories. All of this culminated in putting them into action by granting your appliance access to your custom repository and installing new packages. You have secured your own software supply chain! I hope you now feel that you’re empowered to track the lifecycle of your future offering, so let’s move on to the next chapter where we will dive deep into the usage of encryption and protecting the data within your solution.</p>&#13;
		</div>&#13;
	</div></div></body></html>