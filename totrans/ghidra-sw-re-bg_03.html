<html><head></head><body><div><p>&#13;
			<h1 id="_idParaDest-28"><em class="italic"><a id="_idTextAnchor031"/>Chapter 2</em>: Automating RE Tasks with Ghidra Scripts</h1>&#13;
			<p><a id="_idTextAnchor032"/>In this chapter, we will cover <strong class="bold">Reverse Engineering</strong> (<strong class="bold">RE</strong>) automation by scripting Ghidra. We will start by <a id="_idIndexMarker034"/>reviewing the impressive and pretty well-organized arsenal of available Ghidra scripts built into the tool. These few hundreds of scripts are usually more than enough to cover the main automation needs.<a id="_idTextAnchor033"/></p>&#13;
			<p>Once you know the arsenal, you will probably also want to know how it works. Then, we will have an overview of the Ghidra script class in order to understand its internals and get some background, which will be very useful for the last part of this chapter.<a id="_idTextAnchor034"/></p>&#13;
			<p>Finally, you will learn how to develop your own Ghidra scripts. To do so, it will be necessary to have an overview of the Ghidra API. Fortunately, you will be able to program in Java or Python according to your preferences since the Ghidra API is the same in both cases.</p>&#13;
			<p>In this chapter, we're going to cover the following main topics: </p>&#13;
			<ul>&#13;
				<li>Exploring the Ghidra scripts arsenal</li>&#13;
				<li>Analyzing the Ghidra script class and the API</li>&#13;
				<li>Writing your own Ghidra scripts</li>&#13;
			</ul>&#13;
			<h1 id="_idParaDest-29"><a id="_idTextAnchor035"/>Technical requirements </h1>&#13;
			<p>The GitHub repository containing all the necessary code for this chapter can be found at <a href="https://github.com/PacktPublishing/Ghidra-Software-Reverse-Engineering-for-Beginners/tree/master/Chapter02">https://github.com/PacktPublishing/Ghidra-Software-Reverse-Engineering-for-Beginners/tree/master/Chapter02</a>.</p>&#13;
			<p>Check out the following video to see the Code in Action: <a href="https://bit.ly/3mZbdAm">https://bit.ly/3mZbdAm</a></p>&#13;
			<h1 id="_idParaDest-30"><a id="_idTextAnchor036"/>Using and adapting existing scripts</h1>&#13;
			<p>Ghidra scripts <a id="_idIndexMarker035"/>allow you to automate RE tasks when analyzing binaries. Let's cover an<a id="_idIndexMarker036"/> overview of how to use scripts from <code>hello world</code> program. Our starting point here is a <code>hello world</code> program loaded into Ghidra's <strong class="bold">CodeBrowser</strong>, as explained in the <em class="italic">Overview of Ghidra's features</em> section of <a href="B16207_01_Final_SK_ePub.xhtml#_idTextAnchor017"><em class="italic">Chapter 1</em></a>, <em class="italic">Getting Started with Ghidra</em>.</p>&#13;
			<p>As mentioned in the introduction of this chapter, Ghidra includes a true script arsenal. To access it, go to <strong class="bold">Window</strong> and then <strong class="bold">Script Manager</strong>. Alternatively, click the button highlighted in the following screenshot:</p>&#13;
			<div>&#13;
				<div>&#13;
					<img src="img/B16207_02_001.jpg" alt="Figure 2.1 – The run script button highlighted in the quick access bar&#13;&#10;"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption">Figure 2.1 – The run script button highlighted in the quick access bar</p>&#13;
			<p>As you can see on the left in the folder browser, all these scripts are categorized by folder, showing the scripts each one contains when selected:</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B16207_02_002.jpg" alt="Figure 2.2 – Script Manager&#13;&#10;"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption">Figure 2.2 – Script Manager</p>&#13;
			<p>In the preceding screenshot, when clicking on the checklist icon located at the upper right in the <strong class="bold">Script Manager</strong> window, the paths of the script directories will be shown:</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B16207_02_003.jpg" alt="Figure 2.3 – Script directories&#13;&#10;"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption"> </p>&#13;
			<p class="figure-caption">Figure 2.3 – Script directories</p>&#13;
			<p>This is a very good starting point to experiment with existing scripts. You can analyze and edit all of them by using Ghidra. It will allow you to understand how they work and how to adapt them to your needs. Use the highlighted icons shown in the following screenshot to edit scripts or create new ones:</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B16207_02_004.jpg" alt="Figure 2.4 – The edit script and create a new script buttons highlighted in the quick access bar&#13;&#10;"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption"> </p>&#13;
			<p class="figure-caption">Figure 2.4 – The edit script and create a new script buttons highlighted in the quick access bar</p>&#13;
			<p>As we are analyzing a <code>hello world</code> program that only prints <code>hello world</code> on the screen, we can <a id="_idIndexMarker037"/>choose a string-related Ghidra script, and then see how it can speed<a id="_idIndexMarker038"/> up the analysis. As you can see in the following screenshot, both Python and Java scripts are mixed in <strong class="bold">Script Manager</strong>:</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B16207_02_005.jpg" alt="Figure 2.5 – String-related scripts available in Script Manager&#13;&#10;"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption"> </p>&#13;
			<p class="figure-caption">Figure 2.5 – String-related scripts available in Script Manager</p>&#13;
			<p>For instance, the <code>RecursiveStringFinder.py</code> file can speed up your analysis by showing all the functions and their associated strings. It speeds up your analysis because strings can reveal the purpose of a function without the need for reading even a single line of code.</p>&#13;
			<p>Let's execute the mentioned script, taking the <code>_mainCRTStartup()</code> function of the <code>hello world</code> program as input (you will need to put the cursor onto this function) while seeing the output in the scripting console.</p>&#13;
			<p>As you can see in the following screenshot, <code>RecursiveStringFinder.py</code> printed out an indented (according to the calling depth) list of functions, each one containing its own referenced strings.</p>&#13;
			<p>For instance, the <code>_mainCRTStartup()</code> function is the first function that will be executed (we know this because of the indentation; it is the one that is the most to the left). After that, the <code>__pei386_runtime_relocator()</code> function, which was introduced by the compiler, will be called. This function contains the string <code>"   Unknown pseudo relocation bit size %d. \n"</code>, and we know that it is a string because of the <code>ds</code> indicator. You can see, after some functions and strings that are also introduced <a id="_idIndexMarker039"/>by the compiler, the <code>_main()</code> function containing <a id="_idIndexMarker040"/>the <code>"Hello world."</code> string, which reveals what our program does:</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B16207_02_006.jpg" alt="Figure 2.6 – Result of running the RecursiveStringFinder.py script over a Hello World program&#13;&#10;"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption"> </p>&#13;
			<p class="figure-caption">Figure 2.6 – Result of running the RecursiveStringFinder.py script over a Hello World program</p>&#13;
			<p>The previous script was developed in Python and it uses the <code>getStringReferences()</code> function (line <code>04</code>) to obtain the operands of instructions (line <code>07</code>) that are referencing something (line <code>10</code>). When the thing referenced is data and, to be more <a id="_idIndexMarker041"/>precise, a string (lines <code>12-14</code>), it is appended to the list of results, which <a id="_idIndexMarker042"/>is finally shown in the scripting console.</p>&#13;
			<p>We modified this script to implement a filter when appending strings to the list of results in <code>isAnInterestingString()</code> (line <code>15</code>) to determine whether to append it to the list of results or not (lines <code>16-20</code>). </p>&#13;
			<p>Imagine you are looking for URLs in the code of the program being analyzed, which can be very useful in practice when analyzing malware because it can reveal the server of the attackers. All you need to do is to open <code>strings</code> folder (this script works with strings). Then, open the <code>RecursiveStringFinder.py</code> script and add a filtering condition to it by implementing an <code>isAnInterestingString()</code> function (lines <code>00-02</code> in the following code snippet).</p>&#13;
			<p>As a general rule, don't write a script without first checking whether something similar already exists in Ghidra's arsenal:</p>&#13;
			<pre>00 def isAnInterestingString(string):</pre>&#13;
			<pre>01     """Returns True if the string is interesting for us"""</pre>&#13;
			<pre>02     return string.startswith("http")</pre>&#13;
			<pre>03</pre>&#13;
			<pre>04 def getStringReferences(insn):</pre>&#13;
			<pre>05     """Get strings referenced in any/all operands of an </pre>&#13;
			<pre>06        instruction, if present"""</pre>&#13;
			<pre>07     numOperands = insn.getNumOperands()</pre>&#13;
			<pre>08     found = []</pre>&#13;
			<pre>09     for i in range(numOperands):</pre>&#13;
			<pre>10         opRefs = insn.getOperandReferences(i)</pre>&#13;
			<pre>11         for o in opRefs:</pre>&#13;
			<pre>12             if o.getReferenceType().isData():</pre>&#13;
			<pre>13                 string = getStringAtAddr(o.getToAddress())</pre>&#13;
			<pre>14                 if string is not None and \</pre>&#13;
			<pre>15                              isAnInterestingString(string):</pre>&#13;
			<pre>16                     found.append(StringNode(</pre>&#13;
			<pre>17                                       insn.getMinAddress(),</pre>&#13;
			<pre>18                                       o.getToAddress(), </pre>&#13;
			<pre>19                                       string))</pre>&#13;
			<pre>20     return found</pre>&#13;
			<p>This script can be easily<a id="_idIndexMarker043"/> modified to search for URLs in the code, which is very useful <a id="_idIndexMarker044"/>when analyzing malware. All you need to do is to replace the condition in <code>isAnInterestingString()</code> with the appropriate regular expression.</p>&#13;
			<p>The previous script was developed in the Python programming language. If you want to experiment with Java, then you can analyze the code in <code>TranslateStringsScript.java</code>. For the sake of brevity, imports are omitted in the following code listing:</p>&#13;
			<pre>00 public class TranslateStringsScript extends GhidraScript {</pre>&#13;
			<pre>01</pre>&#13;
			<pre>02   private String translateString(String s) {</pre>&#13;
			<pre>03     // customize here</pre>&#13;
			<pre>04     return "TODO " + s + " TODO";</pre>&#13;
			<pre>05   }</pre>&#13;
			<pre>06</pre>&#13;
			<pre>07   @Override</pre>&#13;
			<pre>08   public void run() throws Exception {</pre>&#13;
			<pre>09</pre>&#13;
			<pre>10     if (currentProgram == null) {</pre>&#13;
			<pre>11       return;</pre>&#13;
			<pre>12     }</pre>&#13;
			<pre>13</pre>&#13;
			<pre>14     int count = 0;</pre>&#13;
			<pre>15</pre>&#13;
			<pre>16     monitor.initialize(</pre>&#13;
			<pre>17             currentProgram.getListing().getNumDefinedData()</pre>&#13;
			<pre>18     );</pre>&#13;
			<pre>19     monitor.setMessage("Translating strings");</pre>&#13;
			<pre>20     for (Data data : DefinedDataIterator.definedStrings(</pre>&#13;
			<pre>21                                       currentProgram,</pre>&#13;
			<pre>22                                       currentSelection)) {</pre>&#13;
			<pre>23       if (monitor.isCancelled()) {</pre>&#13;
			<pre>24         break;</pre>&#13;
			<pre>25       }</pre>&#13;
			<pre>26       StringDataInstance str = StringDataInstance. \</pre>&#13;
			<pre>27                                getStringDataInstance(data);</pre>&#13;
			<pre>28       String s = str.getStringValue();</pre>&#13;
			<pre>29       if (s != null) {</pre>&#13;
			<pre>30 	      TranslationSettingsDefinition. \ </pre>&#13;
			<pre>31            TRANSLATION.setTranslatedValue(data,</pre>&#13;
			<pre>32              translateString(s));</pre>&#13;
			<pre>33</pre>&#13;
			<pre>34          TranslationSettingsDefinition. \ </pre>&#13;
			<pre>35            TRANSLATION.setShowTranslated(data, true);</pre>&#13;
			<pre>36          count++;</pre>&#13;
			<pre>37          monitor.incrementProgress(1);</pre>&#13;
			<pre>38       }</pre>&#13;
			<pre>39     }</pre>&#13;
			<pre>40     println("Translated " + count + " strings.");</pre>&#13;
			<pre>41   }</pre>&#13;
			<pre>42 }</pre>&#13;
			<p>The previous script allows you to modify strings referenced in the program by prefixing and suffixing the <code>TODO</code> string to it (line <code>04</code>). The mentioned script can be useful in some cases. For example, if you need to decode a lot of Base64-encoded strings or defeat some similar malware obfuscation, then modify the <code>translateString()</code> function, which is responsible for taking the input string, applying some transformation, and returning it.</p>&#13;
			<p>The <code>run()</code> function is the main function of a Ghidra script (line <code>08</code>). In this case, a string counter is first initialized to zero (line <code>14</code>), and then, for each string (line <code>20</code>), the counter is incremented while the string transformation is produced (lines <code>30</code>–<code>32</code>) and shown (lines <code>34</code>–<code>35</code>) on each loop iteration.</p>&#13;
			<p>The execution of this <a id="_idIndexMarker045"/>script as is produces changes in all the program strings by <a id="_idIndexMarker046"/>prefixing and suffixing <code>TODO</code> to them. As you can see in the following screenshot, our <code>Hello world</code> string was modified in this way. The script also calculated the number of transformed strings:</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B16207_02_007.jpg" alt="Figure 2.7 – Result of running TranslateStringsScript.java over a Hello World program&#13;&#10;"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption"> </p>&#13;
			<p class="figure-caption">Figure 2.7 – Result of running TranslateStringsScript.java over a Hello World program</p>&#13;
			<p>We have seen how to use existing scripts and also how to adapt them to our needs. Next, we will learn <a id="_idIndexMarker047"/>how<a id="_idIndexMarker048"/> exactly the Ghidra script class works.</p>&#13;
			<h1 id="_idParaDest-31"><a id="_idTextAnchor037"/>The script class</h1>&#13;
			<p>To develop a<a id="_idIndexMarker049"/> Ghidra script, you need to click on the <strong class="bold">Create New Script</strong> option available on the <strong class="bold">Script Manager</strong> menu. Then, you will be able to decide which programming language to use:</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B16207_02_008.jpg" alt="Figure 2.8 – The programming language dialog during new script creation&#13;&#10;"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption">Figure 2.8 – The programming language dialog during new script creation</p>&#13;
			<p>If you decide to use Java, the skeleton of the script will be composed of three parts. The first part is the comments:</p>&#13;
			<pre>//TODO write a description for this script</pre>&#13;
			<pre>//@author </pre>&#13;
			<pre>//@category Strings</pre>&#13;
			<pre>//@keybinding </pre>&#13;
			<pre>//@menupath </pre>&#13;
			<pre>//@toolbar </pre>&#13;
			<p>Some comments are obvious, but some of them deserve mention. For instance, <code>@menupath</code> allows you to specify where to put the script in the menu when it is enabled:</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B16207_02_009.jpg" alt="Figure 2.9 – Enabling a script to be integrated with Ghidra&#13;&#10;"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption">Figure 2.9 – Enabling a script to be integrated with Ghidra</p>&#13;
			<p>Notice that the path must be split by a <code>.</code> character:</p>&#13;
			<pre>//@menupath Tools.Packt.Learn Ghidra script</pre>&#13;
			<p>The previous source code comment produces the following script integration with Ghidra's menu:</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B16207_02_010.jpg" alt="Figure 2.10 – Result of integrating a new script with Ghidra&#13;&#10;"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption"> </p>&#13;
			<p class="figure-caption">Figure 2.10 – Result of integrating a new script with Ghidra</p>&#13;
			<p>The next part is the <a id="_idIndexMarker050"/>imports, where the most important and strictly necessary one is <code>GhidraScript</code>. All scripts must inherit from this class and implement the <code>run()</code> method (which is the main method):</p>&#13;
			<pre>import ghidra.app.script.GhidraScript;</pre>&#13;
			<pre>import ghidra.program.model.util.*;</pre>&#13;
			<pre>import ghidra.program.model.reloc.*;</pre>&#13;
			<pre>import ghidra.program.model.data.*;</pre>&#13;
			<pre>import ghidra.program.model.block.*;</pre>&#13;
			<pre>import ghidra.program.model.symbol.*;</pre>&#13;
			<pre>import ghidra.program.model.scalar.*;</pre>&#13;
			<pre>import ghidra.program.model.mem.*;</pre>&#13;
			<pre>import ghidra.program.model.listing.*;</pre>&#13;
			<pre>import ghidra.program.model.lang.*;</pre>&#13;
			<pre>import ghidra.program.model.pcode.*;</pre>&#13;
			<pre>import ghidra.program.model.address.*;</pre>&#13;
			<p>All the imports are documented in Ghidra's Javadoc documentation; you should refer to it when developing your scripts.</p>&#13;
			<p class="callout-heading">Javadoc Ghidra API documentation</p>&#13;
			<p class="callout">By clicking on <strong class="bold">Help</strong> and then <strong class="bold">Ghidra API Help</strong>, JavaDoc documentation for Ghidra will be automatically generated, if it doesn't already exist. Then, you will be able to access the documentation for the mentioned import packages:/api/ghidra/app/script/package-summary.html/api/ghidra/program/model/.</p>&#13;
			<p>Finally, the body of the script inherits from <code>GhidraScript</code>, where the <code>run()</code> method must be <a id="_idIndexMarker051"/>implemented with your own code. You can access the following <code>GhidraScript</code> states in your implementation: <code>currentProgram</code>, <code>currentAddress</code>, <code>currentLocation</code>, <code>currentSelection</code>, and <code>currentHighlight</code>:</p>&#13;
			<pre>public class NewScript extends GhidraScript {</pre>&#13;
			<pre>    public void run() throws Exception {</pre>&#13;
			<pre>//TODO Add User Code Here</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>}</pre>&#13;
			<p>If you want to write a script using Python, the API is the same as Java and the script skeleton contains a header (the rest of the script must be filled with your own code) and it is very similar to the Java one:</p>&#13;
			<pre>#TODO write a description for this script</pre>&#13;
			<pre>#@author </pre>&#13;
			<pre>#@category Strings</pre>&#13;
			<pre>#@keybinding </pre>&#13;
			<pre>#@menupath </pre>&#13;
			<pre>#@toolbar </pre>&#13;
			<pre>#TODO Add User Code Here</pre>&#13;
			<p>In fact, the Java API is exposed to Python by wrapping it using Jython, which is an implementation of the Python programming language designed to run on the Java platform.</p>&#13;
			<p>If you go to <strong class="bold">Window</strong> and then <strong class="bold">Python</strong>, a Python interpreter will appear, allowing autocompletion when a <em class="italic">Tab</em> keystroke happens:</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B16207_02_011.jpg" alt="Figure 2.11 – The Ghidra Python interpreter autocompletion feature&#13;&#10;"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption"> </p>&#13;
			<p class="figure-caption">Figure 2.11 – The Ghidra Python interpreter autocompletion feature</p>&#13;
			<p>It also allows you to <a id="_idIndexMarker052"/>see the documentation by using the <code>help()</code> function. As you may have already noticed, it is highly recommended to have a Ghidra Python interpreter open while developing Ghidra scripts to quickly access the documentation, test code fragments, and more. It is very useful:</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B16207_02_012.jpg" alt="Figure 2.12 – Querying Ghidra help by using the Python interpreter&#13;&#10;"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption"> </p>&#13;
			<p class="figure-caption">Figure 2.12 – Querying Ghidra help by using the Python interpreter</p>&#13;
			<p>In this section, we covered the script class and its structure, how to query the Ghidra API documentation in order to implement it, and how the Python interpreter can help us during development. In <a id="_idIndexMarker053"/>the next section, we will put this into practice by writing a Ghidra script.</p>&#13;
			<h1 id="_idParaDest-32"><a id="_idTextAnchor038"/>Script development</h1>&#13;
			<p>Now you know all the<a id="_idIndexMarker054"/> things needed in order to implement your own script. Let's start by writing the header. This script will allow you to patch bytes with no operation instructions (<code>NOP</code> assembly opcode).</p>&#13;
			<p>First, we start writing the header. Notice that <code>@keybinding</code> allows us to execute the script with the <em class="italic">Ctrl</em> + <em class="italic">Alt</em> + <em class="italic">Shift</em> + <em class="italic">N</em> key combination:</p>&#13;
			<pre>//This simple script allows you to patch bytes with NOP opcode</pre>&#13;
			<pre>//@author Packt</pre>&#13;
			<pre>//@category Memory</pre>&#13;
			<pre>//@keybinding ctrl alt shift n </pre>&#13;
			<pre>//@menupath Tools.Packt.nop</pre>&#13;
			<pre>//@toolbar </pre>&#13;
			<pre>import ghidra.app.script.GhidraScript;</pre>&#13;
			<pre>import ghidra.program.model.util.*;</pre>&#13;
			<pre>import ghidra.program.model.reloc.*;</pre>&#13;
			<pre>import ghidra.program.model.data.*;</pre>&#13;
			<pre>import ghidra.program.model.block.*;</pre>&#13;
			<pre>import ghidra.program.model.symbol.*;</pre>&#13;
			<pre>import ghidra.program.model.scalar.*;</pre>&#13;
			<pre>import ghidra.program.model.mem.*;</pre>&#13;
			<pre>import ghidra.program.model.listing.*;</pre>&#13;
			<pre>import ghidra.program.model.lang.*;</pre>&#13;
			<pre>import ghidra.program.model.pcode.*;</pre>&#13;
			<pre>import ghidra.program.model.address.*;</pre>&#13;
			<p>Then, all our script needs to do is to get the current cursor location in Ghidra (the <code>currentLocation</code> variable), then obtain the address of it (line <code>03</code>), the instruction at that address is undefined (lines <code>06</code>-<code>08</code>), patch the byte with the <code>NOP</code> instruction opcode, which is <code>0x90</code> (lines <code>09</code>-<code>11</code>), and disassemble the bytes again (line <code>12</code>). The important work to do here is to search for the appropriate API functions in the mentioned Javadoc documentation:</p>&#13;
			<pre>00 public class NopScript extends GhidraScript {</pre>&#13;
			<pre>01</pre>&#13;
			<pre>02   public void run() throws Exception {</pre>&#13;
			<pre>03     Address startAddr = currentLocation.getByteAddress();</pre>&#13;
			<pre>04     byte nop = (byte)0x90;</pre>&#13;
			<pre>05     try {</pre>&#13;
			<pre>06       Instruction instruction = getInstructionAt(startAddr)</pre>&#13;
			<pre>07       int istructionSize = </pre>&#13;
			<pre>                instruction.getDefaultFallThroughOffset();</pre>&#13;
			<pre>08       removeInstructionAt(startAddr);</pre>&#13;
			<pre>09       for(int i=0; i&lt;istructionSize; i++){</pre>&#13;
			<pre>10         setByte(startAddr.addWrap(i), nop);</pre>&#13;
			<pre>11       }</pre>&#13;
			<pre>12       disassemble(startAddr);</pre>&#13;
			<pre>13     }</pre>&#13;
			<pre>14     catch (MemoryAccessException e) {</pre>&#13;
			<pre>15       popup("Unable to nop this instruction");</pre>&#13;
			<pre>16       return;</pre>&#13;
			<pre>17     }</pre>&#13;
			<pre>18   }</pre>&#13;
			<pre>19 }</pre>&#13;
			<p>Of course, as you <a id="_idIndexMarker055"/>know, it is straightforward to translate this piece of code to Python, since, as previously said, the API is the same for both languages:</p>&#13;
			<pre>#This simple script allows you to patch bytes with NOP opcode</pre>&#13;
			<pre>#@author Packt</pre>&#13;
			<pre>#@category Memory</pre>&#13;
			<pre>#@keybinding ctrl alt shift n</pre>&#13;
			<pre>#@menupath Tools.Packt.Nop</pre>&#13;
			<pre>#@toolbar </pre>&#13;
			<pre>currentAddr = currentLocation.getByteAddress()</pre>&#13;
			<pre>nop = 0x90</pre>&#13;
			<pre>instruction = getInstructionAt(currentAddr)</pre>&#13;
			<pre>instructionSize = instruction.getDefaultFallThroughOffset()</pre>&#13;
			<pre>removeInstructionAt(currentAddr)</pre>&#13;
			<pre>for i in range(instructionSize):</pre>&#13;
			<pre>    setByte(currentAddr.addWrap(i), nop)</pre>&#13;
			<pre>disassemble(currentAddr) </pre>&#13;
			<p>In this section, we covered how to write a simple Ghidra script in both supported languages: Java and Python. </p>&#13;
			<h1 id="_idParaDest-33"><a id="_idTextAnchor039"/>Summary</h1>&#13;
			<p>In this chapter, you learned how to use existing Ghidra scripts, how to easily adapt them to your needs, and finally, how to develop an extremely simple script for your preferred language as an introduction to this topic.</p>&#13;
			<p>In <a href="B16207_06_Final_SK_ePub.xhtml#_idTextAnchor108"><em class="italic">Chapter 6</em></a>, <em class="italic">Scripting Malware Analysis</em>, and <a href="B16207_09_Final_SK_ePub.xhtml#_idTextAnchor155"><em class="italic">Chapter 9</em></a>, <em class="italic">Scripting Binary Audits</em>, you will improve your skills in Ghidra scripting by developing and analyzing more complex scripts applied to malware analysis and binary auditing.</p>&#13;
			<p>In the next chapter, you will learn how to debug Ghidra by integrating it with the Eclipse IDE, which is an extremely useful and required skill to extend Ghidra features, as well as for exploring its internals.</p>&#13;
			<h1 id="_idParaDest-34"><a id="_idTextAnchor040"/>Questions</h1>&#13;
			<ol>&#13;
				<li>Why are Ghidra scripts useful? What is something that you can do with them?</li>&#13;
				<li>How are scripts organized in Ghidra? Is this organization related to its own source code or with the location of the script on the filesystem?</li>&#13;
				<li>Why is there no difference between the Java and Python Ghidra scripting APIs?</li>&#13;
			</ol>&#13;
		</div>&#13;
	</div></body></html>