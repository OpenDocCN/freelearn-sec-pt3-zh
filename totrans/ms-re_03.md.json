["```\n2018\nPlace value at position 1 is 1 multiplied by 8 represents 8.\nPlace value at position 2 is 10 multiplied by 1 represents 10.\nPlace value at position 3 is 100 multiplied by 0 represents 0.\nPlace value at position 4 is 1000 multiplied by 2 represents 2000.\n```", "```\n11010b\nPlace value at position 1 is 1 multiplied by 0 represents 0.\nPlace value at position 2 is 2 multiplied by 1 represents 2.\nPlace value at position 3 is 4 multiplied by 0 represents 0.\nPlace value at position 4 is 8 multiplied by 1 represents 8.\nPlace value at position 5 is 16 multiplied by 1 represents 16.\n\nThe equivalent decimal value of 11010b is 26.\n```", "```\nBEEFh\nPlace value at position 1 is 1 multiplied by 0Fh (15) represents 15.are\nPlace value at position 2 is 16 multiplied by 0Eh (14) represents 224.\nPlace value at position 3 is 256 multiplied by 0Eh (14) represents 3584.\nPlace value at position 4 is 4096 multiplied by 0Bh (11) represents 45056.\n\nThe equivalent decimal value of BEEFh is 48879.\n```", "```\n87 to base-2\n\n87 divided by 2 is 43 remainder 1.\n43 divided by 2 is 21 remainder 1.\n21 divided by 2 is 10 remainder 1.\n10 divided by 2 is 5 remainder 0.\n5 divided by 2 is 2 remainder 1.\n2 divided by 2 is 1 remainder 0.\n1 divided by 2 is 0 remainder 1.\nand nothing more to divide since we're down to 0.\n\nbase-2 has digits 0 and 1.\nWriting the remainders backward results to 1010111b. \n```", "```\n34512 to base-16\n\n34512 divided by 16 is 2157 remainder 0.\n2157 divided by 16 is 134 remainder 13 (0Dh)\n134 divided by 16 is 8 remainder 6.\n6 divided by 16 is 0 remainder 6.\n\nbase-16 has digits from 0 to 9 and A to F.\nWriting the remainders backward results to 66D0h.\n```", "```\nABCDh\n 0Ah = 1010b\n 0Bh = 1011b\n 0Ch = 1100b\n 0Dh = 1101b\n\n Just combine the equivalent binary number.\n ABCDh = 1010101111001101b\n```", "```\n1010010111010111b\n 1010b = 10 (0Ah)\n 0101b = 5\n 1101b = 13 (0Dh)\n 0111b = 7\n\n 1010010111010111b = A5D7h\n\n```", "```\n  1b               10101b\n+ 1b             +  1111b \n 10b              100100b\n```", "```\n 10b               1101b\n- 1b              - 111b \n  1b                110b\n```", "```\n   101b             1b x 1b = 1b\nx   10b             1b x 0b = 0b\n   000\n  101   \n  1010b\n```", "```\n       1010b                         1000b \n10b | 10100b                  11b | 11010b\n     -10                           -11 \n       010                           0010\n       -10                           -000\n         00                            10b (remainder)\n         -0\n          0\n```", "```\n01011011b = +91\n11011011b = -37\n10100101b = -91\n00100101b = +37\n```", "```\n63 = 0111111b\n```", "```\n0111111b -> 1000000b\n```", "```\n1000000b + 1 = 1000001b\n```", "```\n11000001b = -63\n```", "```\n10111011b\n```", "```\n  01000100b\n+        1b \n  01000101b\n```", "```\n- 01000101b = -69\n```", "```\nAddress       Byte\n0x00000000    AA\n0x00000001    00\n0x00000002    00\n0x00000003    00\n```", "```\nAddress     Opcode          Instructions\n00A92D7C    B8 00000080     MOV EAX,80000000h\n00A92D81    B9 02000000     MOV ECX,2\n00A92D86    F7E1            MUL ECX\n```", "```\nAddress     Bytes\n00A92D7C    B8 00 00 00 80 B9 02 00 00 00 F7 E1\n```", "```\nAddress   Bytes\n00000060: 60 61 62 63 64 65 66 67 68 69 6A 6B 6C 6D 6E 6F \n00000070: 70 71 72 73 74 75 76 77 78 79 7A 7B 7C 7D 7E 7F \n00000080: 80 81 82 83 84 85 86 87 88 89 8A 8B 8C 8D 8E 8F \n00000090: 90 91 92 93 94 95 96 97 98 99 9A 9B 9C 9D 9E 9F \n```", "```\n; the following lines reads from memory\nmov al, byte ptr [00000071]       ; al = 71h\nmov cx, word ptr [00000071]       ; cx = 7271h\nmov edx, dword ptr [00000071]     ; edx = 74737271h\n\n; the following lines writes to memory\nmov eax, 011223344h\nmov byte ptr [00000080], al       ; writes the value in al to address 00000080\nmov word ptr [00000081], ax       ; writes the value in ax to address 00000081\nmov dword ptr [00000083], eax     ; writes the value in eax to address 00000083\n```", "```\n00000060: 60 61 62 63 64 65 66 67 68 69 6A 6B 6C 6D 6E 6F \n00000070: 70 71 72 73 74 75 76 77 78 79 7A 7B 7C 7D 7E 7F \n00000080: 44 44 33 44 33 22 11 87 88 89 8A 8B 8C 8D 8E 8F \n00000090: 90 91 92 93 94 95 96 97 98 99 9A 9B 9C 9D 9E 9F \n```", "```\nmov eax, dword ptr [00000060]           ; stores 63626160h to eax\nmov eax, dword ptr [00000060]           ; stores 00000060h to eax\n```", "```\nstruct Test {\n    int x;\n    int y;\n} test[10];\n\nint value;\nint *p;\n\n// some code here that fills up the test[] array\n\nfor (int i=0; i<10, i++) {\n    value = test[i].y;\n    p = &test[i].y;\n}\n```", "```\n; using MUL and ADD\nmov ecx, 1111h\nmov ebx, 2222h\nmov eax, 2              ; eax = 2\nmul ecx                 ; eax = 2222h\nadd eax, ebx            ; eax = 4444h\nadd eax, 1              ; eax = 4445h\n\n; using LEA\nmov ecx, 1111h\nmov ebx, 2222h\nlea eax, [ecx*2+ebx+1]  ; eax = 4445h\n```", "```\nmov ecx, 0x0fffffff\nmov ebx, 0x0fffffff\nadd ecx, ebx\n```", "```\nmov ecx, 0x7fffffff\nmov ebx, 0x7fffffff\nadd ecx, ebx\n```", "```\nmov ecx, 0x80000000\nmov ebx, 0x80000000\nadd ecx, ebx\n```", "```\nmov ecx, 0x7fffffff\nmov edx, 0x80000000\nsub ecx, edx\n```", "```\nmov eax, 0xffffffff\ninc eax\n```", "```\nmov eax, 0\ndec eax\n```", "```\nmov eax, 0x80000000\nmov ecx, 2\nmul ecx\n```", "```\nJMP\n```", "```\njmp   eax\njmp   dword ptr [00403000]\njmp   dword ptr [eax+edx]\njmp   dowrd ptr [eax]\njmp   dword ptr [ebx*4+eax]\n```", "```\nAddress            Instruction\n00401000           CALL 00401100\n00401005           MOV ECX, EAX\n00401007\n...\n00401100           MOV EAX, F00BF00B\n00401105           RET\n```", "```\npush ebp                      ; save the current value of ebp\nmov ebp, esp                  ; stores current stack to ebp\nadd esp, 8                    ; create a stack frame with a size of 8 bytes\n```", "```\nformat PE CONSOLE\nentry start\n\ninclude '%include%\\win32a.inc' \n\nsection '.data' data readable writeable \n  message db 'Hello World!',0\n  msgformat db '%s',0\n\nsection '.code' code readable executable \n  start:\n    push message\n    push msgformat\n    call [printf]\n    push 0\n    call [ExitProcess]\n\nsection '.idata' import data readable writeable \n  library kernel32, 'kernel32.dll', \\\n          msvcrt, 'msvcrt.dll'\n  import kernel32, ExitProcess, 'ExitProcess'\n  import msvcrt, printf, 'printf'\n```", "```\nsection '.data' data readable writeable\n```", "```\n message db 'Hello World!',0\n msgformat db '%s',0\n```", "```\nsection '.code' code readable executable\n```", "```\npush <arg3>\npush <arg2>\npush <arg1>\ncall myfunction\n```", "```\n push message\n push msgformat\n call [printf]\n```", "```\n push 0 \n call [ExitProcess]\n```", "```\nsection '.idata' import data readable writeable\n```", "```\n library kernel32, 'kernel32.dll', \\\n           msvcrt, 'msvcrt.dll'\n```", "```\n import kernel32, ExitProcess, 'ExitProcess'\n import msvcrt, printf, 'printf'\n```", "```\nsection '.idata' import data readable writeable     ; import section has read and write permissions\n  library kernel32, 'kernel32.dll', \\               ; functions came from kernel32 and msvcrt dlls\n          msvcrt, 'msvcrt.dll'\n  import kernel32, ExitProcess, 'ExitProcess'       ; program will use ExitProcess and printf functions\n  import msvcrt, printf, 'printf'\n```", "```\n    call [printf]\n    call [ExitProcess]\n```", "```\n    CALL 00401000 ; <-- STEP INTO SUBROUTINE\n    MOV  EBX, EAX\n    ...\n00401000:  \n    MOV EAX, 37173 ; <- DEBUG POINTER GOES HERE\n    RET\n\n```", "```\n    CALL 00401000 ; <-- STEP OVER SUBROUTINE\n    MOV  EBX, EAX ; <- DEBUG POINTER GOES HERE\n    ...\n00401000:  \n    MOV EAX, 37173\n    RET\n\n```", "```\n00402000  push 0040100D\n00402005  push 0040100D\n0040200A  call dword ptr [printf]  ; <-- breakpoint set here\n00402010  push 0\n00402012  call dword ptr [ExitProcess]\n```"]