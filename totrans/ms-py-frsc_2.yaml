- en: Chapter 2. Forensic Algorithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Forensic algorithms are the building blocks for a forensic investigator. Independent
    from any specific implementation, these algorithms describe the details of the
    forensic procedures. In the first section of this chapter, we will introduce the
    different algorithms that are used in forensic investigations, including their
    advantages and disadvantages.
  prefs: []
  type: TYPE_NORMAL
- en: Algorithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we describe the main differences between **MD5**, **SHA256**,
    and **SSDEEP**—the most common algorithms used in the forensic investigations.
    We will explain the use cases as well as the limitations and threats behind these
    three algorithms. This should help you understand why using SHA256 is better than
    using MD5 and in which cases SSDEEP can help you in the investigation.
  prefs: []
  type: TYPE_NORMAL
- en: Before we dive into the different hash functions, we will give a short summary
    of what a cryptographic hash function is.
  prefs: []
  type: TYPE_NORMAL
- en: A **hash function** is a function that maps an *arbitrarily large* amount of
    data to a value of a *fixed length*. The hash function ensures that the same input
    always results in the same output, called the hash sum. Consequently, a hash sum
    is a characteristic of a specific piece of data.
  prefs: []
  type: TYPE_NORMAL
- en: A **cryptographic hash function** is a hash function that is considered practically
    impossible to invert. This means that it is not possible to create the input data
    while having a pre-defined hash sum value by any other means than trying all the
    possible input values, that is *brute force*. Therefore, this class of algorithms
    is known as *one-way* cryptographic algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 'The ideal cryptographic hash function has four main properties, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: It must be easy to compute the hash value for any given input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It must be infeasible to generate the original input from its hash.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It must be infeasible to modify the input without changing the hash.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It must be infeasible to find two different inputs with the same hash (**collision-resistant**).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the ideal case, if you create a hash of the given input and change only
    one bit of this input, the newly calculated hash will look totally different,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If all of the previously mentioned properties are fulfilled, the algorithm is
    a cryptographically correct hash function and can be used to compare, for example,
    files with each other to prove that they haven't been tampered with during analysis
    or by an attacker.
  prefs: []
  type: TYPE_NORMAL
- en: MD5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The MD5 message-digest algorithm was the most commonly used (and is still a
    widely used) cryptographic hash function that produces a 128-bit (16-byte) hash
    value, typically expressed in the text format as a 32-digit hexadecimal number
    (as shown in the previous example). This message digest has been utilized in a
    wide variety of cryptographic applications and is commonly used to verify data
    integrity in forensic investigations. This algorithm was designed by Ronald Rivest
    in 1991 and has been heavily used since then.
  prefs: []
  type: TYPE_NORMAL
- en: A big advantage of MD5 is that it calculates faster and produces small hashes.
    The small hashes are a major point of interest when you need to store thousands
    of these hashes in a forensic investigation. Just imagine how many files a common
    PC will have on its hard drive. If you need to calculate a hash of each of these
    files and store them in a database, it would make a huge difference if each of
    the calculated hash has 16 byte or 32 byte of size.
  prefs: []
  type: TYPE_NORMAL
- en: Nowadays, the major disadvantage of MD5 is the fact that it is no longer considered
    to be collision-resistant. This means that it is possible to calculate the same
    hash from two different inputs. Keeping this in mind, it is not possible anymore
    to guarantee that a file hasn't been modified just by comparing its MD5 hash at
    two different stages of an investigation. At the moment it is possible to create
    a collision very fast, (refer to [http://www.win.tue.nl/hashclash/On%20Collisions%20for%20MD5%20-%20M.M.J.%20Stevens.pdf](http://www.win.tue.nl/hashclash/On%20Collisions%20for%20MD5%20-%20M.M.J.%20Stevens.pdf))
    but it is still difficult to modify a file in a way, which is now a malicious
    version of that benign file, and keep the MD5 hash of the original file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The very famous cryptographer, Bruce Schneier, once wrote that ([https://www.schneier.com/blog/archives/2008/12/forging_ssl_cer.html](https://www.schneier.com/blog/archives/2008/12/forging_ssl_cer.html)):'
  prefs: []
  type: TYPE_NORMAL
- en: '*"We already knew that MD5 is a broken hash function" and that "no one should
    be using MD5 anymore".*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: We would not go that far (especially because a lot of tools and services still
    use MD5), but you should try switching to SHA256 or at least double-check your
    results with the help of different hash functions in cases where it is critical.
    Whenever the chain of custody is crucial, we recommend using multiple hash algorithms
    to prove the integrity of your data.
  prefs: []
  type: TYPE_NORMAL
- en: SHA256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SHA-2 is a set of cryptographic hash functions designed by the NSA (U.S. National
    Security Agency) and stands for Secure Hash Algorithm 2nd Generation. It has been
    published in 2001 by the NIST as a U.S. federal standard (FIPS). The SHA-2 family
    consists of several hash functions with digests (hash values) that are between
    224 bits and 512 bits. The cryptographic functions SHA256 and SHA512 are the most
    common versions of SHA-2 hash functions computed with 32-bit and 64-bit words.
  prefs: []
  type: TYPE_NORMAL
- en: Despite the fact that these algorithms calculate slower and that the calculated
    hashes are larger in size (compared to MD5), they should be the preferred algorithms
    that are used for integrity checks during the forensic investigations. Nowadays,
    SHA256 is a widely used cryptographic hash function that is still collision-resistant
    and entirely trustworthy.
  prefs: []
  type: TYPE_NORMAL
- en: SSDEEP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The biggest difference between **MD5**, **SHA256**, and **SSDEEP** is the fact
    that **SSDEEP** is not considered to be a **cryptographic hash function** as it
    only changes slightly when the input is changed by one bit. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The SSDEEP packages can be downloaded and installed as described in the following
    URL: [http://ssdeep.sourceforge.net/usage.html#install](http://ssdeep.sourceforge.net/usage.html#install)'
  prefs: []
  type: TYPE_NORMAL
- en: This behavior is not a weakness of SSDEEP, it is a major advantage of this function.
    In reality, SSDEEP is a program to compute and match the **Context Triggered Piecewise
    Hashing** (**CTPH**) values. CTPH is a technique that is also known as **Fuzzy
    Hashing** and is able to match inputs that have homologies. Inputs with homologies
    have sequences of identical bytes in a given order with totally different bytes
    in between. These bytes in between can differ in content and length. CTPH, originally
    based on the work of *Dr. Andrew Tridgell*, was adapted by *Jesse Kornblum* and
    published at the DFRWS conference in 2006 in a paper called *Identifying Almost
    Identical Files Using Context Triggered Piecewise Hashing*; refer to [http://dfrws.org/2006/proceedings/12-Kornblum.pdf](http://dfrws.org/2006/proceedings/12-Kornblum.pdf).
  prefs: []
  type: TYPE_NORMAL
- en: 'SSDEEP can be used to check how similar the two files are and in which part
    of the file the difference is located. This feature is often used to check if
    two different applications on the mobile devices have a common code base, as shown
    in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the previous example, you can see that the second sample matches the first
    one with a very high likelihood. These matches indicate the potential source code
    reuse or at least a large number of files inside the apk file are identical. A
    manual examination of the files in question is required to tell exactly which
    parts of the code or files are identical; however, we now know that both the files
    are similar to each other.
  prefs: []
  type: TYPE_NORMAL
- en: Supporting the chain of custody
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The outcomes of forensic investigations can have a severe impact on organizations
    and individuals. Depending on your field of work, your investigation can become
    evidence in the court.
  prefs: []
  type: TYPE_NORMAL
- en: Consequently, the integrity of forensic evidence has to be ensured not just
    when collecting the evidence, but also throughout the entire handling and analysis.
    Usually, the very first step in a forensic investigation is gathering the evidence.
    Normally, this is done using a bitwise copy of the original media. All the subsequent
    analysis is performed on this forensic copy.
  prefs: []
  type: TYPE_NORMAL
- en: Creating hash sums of full disk images
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To ensure that a forensic copy is actually identical to the original media,
    hash sums of the media and from the forensic copy are made. These hash sums must
    match to prove that the copy is exactly like the original data. Nowadays, it has
    become common to use at least two different cryptographic hash algorithms to minimize
    the risk of hash collisions and harden the overall process against hash collision
    attacks.
  prefs: []
  type: TYPE_NORMAL
- en: 'With Linux, one can easily create MD5 and SHA256 hashes from a drive or multiple
    files. In the following example, we will calculate MD5 sums and SHA256 sums for
    two files to provide a proof of identical content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This proof of identical content is required to support the chain of custody,
    that is, to show that the analyzed data is identical to the raw data on the disk.
    The term **sdb** refers to a drive attached to the forensic workstation (in Linux,
    the **second hard drive** is called **sdb**). To further support the chain of
    custody, it is highly recommended to use a write-block device between the evidence
    and forensic workstation to avoid any accidental change of the evidence. The second
    argument represents the location of a bitwise copy of the evidence. The commands
    output the hash sums for the original drive and the copy. The copy can be considered
    forensically sound if both the MD5 sums match and both the SHA256 sums match.
  prefs: []
  type: TYPE_NORMAL
- en: While the method shown in the previous example works, it has a big disadvantage,
    the evidence and its copy have to be read twice to calculate the hash sums. If
    the disk is a 1 TB hard drive, it can slow down the overall process by several
    hours.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following Python code reads the data only once and feeds it into two hash
    calculations. Therefore, this Python script is almost twice as fast as running
    `md5sum` followed by `sha256sum` and produces exactly the same hash sums as these
    tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following call of the script, we calculate the hash sums of some of
    the common Linux tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: It is crucial to document the hash sums of the original data and the forensic
    copy in the forensic report. An independent party can then read the same piece
    of evidence and confirm that the data that you analyzed is exactly the data of
    the evidence.
  prefs: []
  type: TYPE_NORMAL
- en: Creating hash sums of directory trees
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once the full image is copied, its contents should be indexed and the hash
    sums should be created for every file. With the support of the previously defined
    `multi_hash` function and Python standard libraries, a report template containing
    a list of all file names, sizes, and hash values can be created, as shown in the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This Python script is all it takes to generate the integrity information of
    a directory tree that includes file sizes, file names, and hash sums (SHA256,
    MD5). The following is an example call on our scripting directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'However, the resulting report file itself does not have any integrity protection.
    It is recommended to sign the resulting report, for example, using **GnuPG**,
    as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: If you have never used `gpg` before, you need to generate a private key before
    you can sign the documents. This can be done with the `gpg --gen-key` command.
    Consult [https://www.gnupg.org/documentation](https://www.gnupg.org/documentation)
    for more details about GnuPG and its use. This creates an additional `report.txt.asc`
    file containing the original report and a digital signature. Any subsequent modification
    of that file invalidates the digital signature.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The techniques described here are merely the examples of how to support the
    chain of custody. If the forensic analysis is to be used in the court, it is highly
    recommended to seek legal advice about the chain-of-custody requirements in your
    legislation.
  prefs: []
  type: TYPE_NORMAL
- en: Real-world scenarios
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section will demonstrate some use cases where the preceding algorithms
    and techniques are used to support the investigator. For this chapter, we use
    two very common and interesting examples, **Mobile Malware** and the **National
    Software Reference Library** (**NSRL**).
  prefs: []
  type: TYPE_NORMAL
- en: Mobile Malware
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example, we will check the installed applications on an Android smartphone
    against an online analysis system, **Mobile-Sandbox**. Mobile-Sandbox is a website
    that provides free Android files checking for viruses or suspicious behavior,
    [http://www.mobilesandbox.org](http://www.mobilesandbox.org). It is connected
    to **VirusTotal**, which uses up to 56 different antivirus products and scan engines
    to check for viruses that the user's antivirus solution may have missed or verify
    against any false positives. Additionally, Mobile-Sandbox uses custom techniques
    to detect applications that act potentially malicious. Antivirus software vendors,
    developers, and researchers behind Mobile-Sandbox can receive copies of the files
    to help in improving their software and techniques.
  prefs: []
  type: TYPE_NORMAL
- en: In the example, we will use two steps to successfully compare the installed
    applications with the already tested apps on the Mobile-Sandbox web service.
  prefs: []
  type: TYPE_NORMAL
- en: The first step is to get the hash sums of the installed applications on the
    device. This is very important as these values can help to identify the apps and
    check them against the online services. For this example, we will use an application
    from Google Play, **AppExtract** ([https://play.google.com/store/apps/details?id=de.mspreitz.appextract](https://play.google.com/store/apps/details?id=de.mspreitz.appextract)).
    The forensically more correct way of getting these values can be found in [Chapter
    6](ch06.html "Chapter 6. Using Python for Mobile Forensics"), *Using Python for
    Mobile Forensics*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Mobile Malware](img/2087_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'AppExtract for Android generates a list of installed and running apps with
    a large amount of metadata that can help in identifying unwanted or even malicious
    applications. This metadata contains the SHA256 hash sum of the application packages,
    an indicator whether the app has been installed by the user or the system itself,
    and a lot of additional data that can help in identifying if the app is benign
    or not. These lists can be transferred via your favorite email app for further
    analysis. Once you receive the plain-text email with the generated lists, you
    just need to copy the list that contains all the installed applications to a CSV
    file. This file can be used for an automated analysis or opened with **LibreOffice
    Calc** in the lab environment. You can see the metadata of the current version
    of the Chrome Browser for Android in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The second step is to compare the hash sums from the device (third column in
    our CSV file) with the Mobile-Sandbox database. This can be done with the help
    of the following script that we will save as `get_infos_mobilesandbox.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The script can be used as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: With the help of these three tools, it is possible to quickly check if an application
    on a mobile device is potentially infected (see the highlighted parts in the response)
    or at least where to start with the manual investigation if an application hasn't
    been tested before.
  prefs: []
  type: TYPE_NORMAL
- en: NSRLquery
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To increase efficiency in the forensic analysis, it is crucial to sort out any
    files that belong to known software and have not been modified. The **National
    Software Reference Library** (**NSRL**) maintains multiple lists of hash sums
    for the known content. NSRL is a project of the U.S. Department of Homeland Security,
    further details are available on [http://www.nsrl.nist.gov/](http://www.nsrl.nist.gov/).
    It is important to understand that these lists of hash sums merely indicate that
    a file was not modified as compared to the version that was submitted to the NSRL.
    Consequently, it is normal that a lot of files, which are to be analysed during
    a forensic investigation, are not listed in NSRL. On the other hand, even the
    listed files can be used and deployed by an attacker as a tool. For example, a
    tool such as `psexec.exe` is a program provided by Microsoft for remote administration
    and listed in NSRL. Nevertheless, an attacker may have deployed it for his malicious
    purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Which NSRL list should be used?**'
  prefs: []
  type: TYPE_NORMAL
- en: NSRL consists of several hash sets. It is highly recommended to begin with the
    *minimal set*. This set only contains one hash sum per file, which means only
    one file version is known.
  prefs: []
  type: TYPE_NORMAL
- en: The minimal set is offered free of charge to download on the NIST homepage.
    The download consists of a single ZIP file with the hash list and a list of supported
    software products as the most prominent contents.
  prefs: []
  type: TYPE_NORMAL
- en: 'The hashes are stored in the `NSRLFile.txt` file that holds one file hash per
    line, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The fields of this record are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The hash sum of the file that is calculated with SHA-1, a predecessor to the
    SHA-256 algorithm described earlier.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The hash sum of the file that is calculated with MD5.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The CRC32 checksum of the file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The file name.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The file size in bytes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A product code denoting the software product this file belongs to. The `NSRLProd.txt`
    file contains a list of all products and can be used to look up the product code.
    In the previous example, the code `14965` denotes Microsoft Picture It!.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The operating system where this file is to be expected. The list of operating
    system codes can be found in `NSRLOS.txt`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An indicator whether this file is to be considered normal (""), a malicious
    file ("N"), or special ("S"). While this flag is part of the specification, all
    the files of the current NSRL minimal set are set to be normal.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More details about the file specifications can be found at [http://www.nsrl.nist.gov/Documents/Data-Formats-of-the-NSRL-Reference-Data-Set-16.pdf](http://www.nsrl.nist.gov/Documents/Data-Formats-of-the-NSRL-Reference-Data-Set-16.pdf).
  prefs: []
  type: TYPE_NORMAL
- en: Downloading and installing nsrlsvr
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Currently, the NSRL database contains more than 40 million distinct hashes in
    the minimal set. A text-based search would take minutes, even on an up-to-date
    workstation. Therefore, it is important to make efficient lookups to that database.
    Rob Hanson's tool **nsrlsvr** provides a server that supports efficient lookups.
    It is available at [https://rjhansen.github.io/nsrlsvr/](https://rjhansen.github.io/nsrlsvr/).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are also public NSRL servers on the Internet that you can use. These are
    usually provided on an *as is* basis. However, to test smaller sets of hashes,
    you may use Robert Hanson's public server `nsrllookup.com` and continue reading
    with the next section.
  prefs: []
  type: TYPE_NORMAL
- en: To compile the software on a Linux system, the automake, autoconf, and c++ compiler
    tools must be installed. The detailed installation instructions including all
    the requirements are provided in the `INSTALL` file.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Installing nsrlsvr in a non-default directory**'
  prefs: []
  type: TYPE_NORMAL
- en: The installation directory of nsrlsvr can be changed by calling the `configure`
    script with the `--prefix` parameter. The parameter value denotes the target directory.
    If a user-writable directory is specified, the installation does not require root
    privileges and can be completely removed by removing the installation directory.
  prefs: []
  type: TYPE_NORMAL
- en: The nsrlsrv maintains its own copy of all the MD5 hash sums of the NSRL database.
    Therefore, it is required to initialize the hash database. The required nsrlupdate
    tool is provided with nsrlsrv.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'After the database is fully populated, the server can be started by simply
    calling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: If everything is installed correctly, this command returns without providing
    any output and the server starts listening to the TCP port 9120 for requests.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a client for nsrlsvr in Python
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is also a client tool for using nsrlsvr called **nsrllookup**. The client
    is written in C++ and available at [https://rjhansen.github.io/nsrllookup/](https://rjhansen.github.io/nsrllookup/).
    However, a client for interacting with nsrlsvr can easily be implemented in native
    Python. This section explains the protocol and shows a sample implementation of
    such a client.
  prefs: []
  type: TYPE_NORMAL
- en: 'The nsrlsvr implements a text-oriented protocol on its network port 9120\.
    Every command consists of one line of text followed by a newline (CR LF). The
    following commands are supported:'
  prefs: []
  type: TYPE_NORMAL
- en: '**version: 2.0**: The version command is used for the initial handshake between
    the nsrl client and nsrlsvr. The client is supposed to provide its version after
    the colon. The server will always respond with `OK` followed by a line break.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**query** **5CB360EF546633691912089DB24A82EE 908A54EB629F410C647A573F91E80775
    BFDD76C4DD6F8C0C2474215AD5E193CF**: The query command is used for actually querying
    the NSRL database from the server. The keyword **query** is followed by one or
    multiple MD5 hash sums. The server will respond with `OK` followed by a sequence
    of zeroes and ones. A `1` indicates that the MD5 hash sum was found in the database
    and a `0` indicates that there was no match. For example, the query shown previously
    would lead to the following answer:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This means that the first and the last MD5 hashes were found in NSRL, but the
    middle hash sum could not be found.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**BYE**: The bye command terminates the connection to the nsrlsvr.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Consequently, the following Python routine is sufficient to efficiently query
    the NSRL database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Using this module is as easy as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This code queries the NSRL server and returns a list of booleans, each indicating
    whether the corresponding MD5 hash has been found in the NSRL file list.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter provided an overview of the domains of the forensic and example
    algorithms for each of these domains. We also showed you how to compare applications
    installed on an Android device with web services such as **Mobile-Sandbox**. In
    the second real-world example, we demonstrated how to sort out benign and known
    files from a Windows system to reduce the amount of data that is to be analyzed
    manually. With **NSRLquery**, the forensic investigations can focus on new or
    modified content and do not need to waste time on the widely known content of
    standard applications.
  prefs: []
  type: TYPE_NORMAL
- en: In the following chapters, these algorithms will be applied to a selection of
    device types, operating systems, and applications for use during forensic investigation.
  prefs: []
  type: TYPE_NORMAL
