["```\nuser@lab:~$ pip install --upgrade pyVmomi\n\n```", "```\n#!/usr/bin/env python\n\nfrom pyVim import connect\nfrom pyVmomi import vmodl\nimport sys\n\ndef print_vm_info(vm):\n    \"\"\"\n    Print the information for the given virtual machine.\n    If vm is a folder, recurse into that folder.\n    \"\"\"\n\n    # check if this a folder...\n    if hasattr(vm, 'childEntity'):\n        vms = vm.childEntity\n        for child in vms:\n            print_vm_info(child)\n\n    vm_info = vm.summary\n\n    print 'Name:      ', vm_info.config.name\n    print 'State:     ', vm_info.runtime.powerState\n    print 'Path:      ', vm_info.config.vmPathName\n    print 'Guest:     ', vm_info.config.guestFullName\n    print 'UUID:      ', vm_info.config.instanceUuid\n    print 'Bios UUID: ', vm_info.config.uuid\n    print \"----------\\n\"\n\nif __name__ == '__main__':\n    if len(sys.argv) < 5:\n        print 'Usage: %s host user password port' % sys.argv[0]\n        sys.exit(1)\n\n    service = connect.SmartConnect(host=sys.argv[1],\n                                   user=sys.argv[2],\n                                   pwd=sys.argv[3],\n                                   port=int(sys.argv[4]))\n\n    # access the inventory\n    content = service.RetrieveContent()\n    children = content.rootFolder.childEntity\n\n    # iterate over inventory\n    for child in children:\n        if hasattr(child, 'vmFolder'):\n            dc = child\n        else:\n            # no folder containing virtual machines -> ignore\n            continue\n\n        vm_folder = dc.vmFolder\n        vm_list = vm_folder.childEntity\n        for vm in vm_list:\n            print_vm_info(vm)\n```", "```\nuser@lab:~$ python enumerateVMs.py 192.168.167.26 'readonly' 'mypwd' 443\nName:     vCenterServer\nState:      poweredOff\nPath:      [datastore1] vCenterServer/vCenterServer.vmx\nGuest:     Microsoft Windows Server 2012 (64-bit)\nUUID:      522b96ec-7987-a974-98f1-ee8c4199dda4\nBios UUID: 564d8ec9-1b42-d235-a67c-d978c5107179\n----------\n\n```", "```\nuser@lab:~$ tar xfz 192.168.167.26-vcsupport-2015-07-05@11-21-54.tgz\n\n```", "```\n#!/usr/bin/env python\n\nimport gzip\nimport os\nfrom os.path import join\nimport re\nimport sys\n\n# used to map session IDs to users and source IPs\nsession2user_ip = {}\n\ndef _logopen(filename):\n    \"\"\"Helper to provide transparent decompressing of compressed logs,\n       if indicated by the file name.\n    \"\"\"\n    if re.match(r'.*\\.gz', filename):\n        return gzip.open(filename, 'r')\n\n    return open(filename, 'r')\n\ndef collect_session_data(vpxlogdir):\n    \"\"\"Uses vpx performance logs to map the session ID to\n       source user name and IP\"\"\"\n    extract = re.compile(r'SessionStats/SessionPool/Session/Id=\\'([^\\']+)\\'/Username=\\'([^\\']+)\\'/ClientIP=\\'([^\\']+)\\'')\n\n    logfiles = os.listdir(vpxlogdir)\n    logfiles = filter(lambda x: 'vpxd-profiler-' in x, logfiles)\n    for fname in logfiles:\n        fpath = join(vpxlogdir, fname)\n        f = _logopen(fpath)\n\n        for line in f:\n            m = extract.search(line)\n            if m:\n                session2user_ip[m.group(1)] = (m.group(2), m.group(3))\n\n        f.close()\n\ndef print_cloning_hints(basedir):\n    \"\"\"Print timestamp, user, and IP address for VM cloning without\n       by reconstructing from vpxd logs instead of accessing\n       the 'official' event logs\"\"\"\n    vpxlogdir = join(basedir, 'ProgramData',\n                              'vCenterServer',\n                              'logs',\n                              'vmware-vpx')\n    collect_session_data(vpxlogdir)\n\n    extract = re.compile(r'^([^ ]+).*BEGIN task-.*?vim\\.VirtualMachine\\.clone -- ([0-9a-f-]+).*')\n\n    logfiles = os.listdir(vpxlogdir)\n    logfiles = filter(lambda x: re.match('vpxd-[0-9]+.log(.gz)?', x), logfiles)\n    logfiles.sort()\n\n    for fname in logfiles:\n        fpath = join(vpxlogdir, fname)\n        f = _logopen(fpath)\n\n        for line in f:\n            m = extract.match(line)\n            if m == None:\n                continue\n\n            timestamp = m.group(1)\n            session = m.group(2)\n            (user, ip) = session2user_ip.get(session, ('***UNKNOWN***', '***UNKNOWN***'))\n            print 'Hint for cloning at %s by %s from %s' % (timestamp, user, ip)\n\nif __name__ == '__main__':\n    if len(sys.argv) < 2:\n        print 'Usage: %s vCenterLogDirectory' % sys.argv[0]\n        sys.exit(1)\n\n    print_cloning_hints(sys.argv[1])\n```", "```\nuser@lab:~$ python extractCloning.py vc-winserver-2015-07-05--02.19/\nHint for cloning at 2015-07-05T01:30:01.071-07:00 by VSPHERE.LOCAL\\Administrator from 192.168.167.26\n\n```", "```\n#!/usr/bin/env python\n\nfrom pyVim import connect\nfrom pyVmomi import vmodl\nfrom pyVmomi import vim\nimport sys\n\ndef generate_portgroup_info(content):\n    \"\"\"Enumerates all hypervisors to get\n       network infrastructure information\"\"\"\n    host_view = content.viewManager.CreateContainerView(content.rootFolder,\n                                        [vim.HostSystem],\n                                        True)\n    hostlist = [host for host in host_view.view]\n    host_view.Destroy()\n\n    hostPgDict = {}\n    for host in hostlist:\n        pgs = host.config.network.portgroup\n        hostPgDict[host] = pgs\n\n    return (hostlist, hostPgDict)\n\ndef get_vms(content, min_nics=1):\n    vm_view = content.viewManager.CreateContainerView(content.rootFolder,\n                                        [vim.VirtualMachine],\n                                        True)\n    vms = [vm for vm in vm_view.view]\n    vm_view.Destroy()\n\n    vm_with_nics = []\n    for vm in vms:\n        num_nics = 0\n        for dev in vm.config.hardware.device:\n            # ignore non-network devices\n            if not isinstance(dev, vim.vm.device.VirtualEthernetCard):\n                continue\n\n            num_nics = num_nics + 1\n            if num_nics >= min_nics:\n                vm_with_nics.append(vm)\n                break\n\n    return vm_with_nics\n\ndef print_vm_info(vm, hosts, host2portgroup, content):\n    print \"\\n=== %s ===\" % vm.name\n\n    for dev in vm.config.hardware.device:\n        if not isinstance(dev, vim.vm.device.VirtualEthernetCard):\n            continue\n\n        dev_backing = dev.backing\n        if hasattr(dev_backing, 'port'):\n            # NIC is connected to distributed vSwitch\n            portGroupKey = dev.backing.port.portgroupKey\n            dvsUuid = dev.backing.port.switchUuid\n            try:\n                dvs = content.dvSwitchManager.QueryDvsByUuid(dvsUuid)\n            except:\n                portGroup = 'ERROR: DVS not found!'\n                vlanId = 'N/A'\n                vSwitch = 'N/A'\n            else:\n                pgObj = dvs.LookupDvPortGroup(portGroupKey)\n                portGroup = pgObj.config.name\n                vlObj = pgObj.config.defaultPortConfig.vlan\n                if hasattr(vlObj, 'pvlanId'):\n                    vlanId = str(pgObj.config.defaultPortConfig.vlan.pvlanId)\n                else:\n                    vlanId = str(pgObj.config.defaultPortConfig.vlan.vlanId)\n                vSwitch = str(dvs.name)\n        else:\n            # NIC is connected to simple vSwitch\n            portGroup = dev.backing.network.name\n            vmHost = vm.runtime.host\n\n            # look up the port group from the\n            # matching host\n            host_pos = hosts.index(vmHost)\n            viewHost = hosts[host_pos]\n            pgs = host2portgroup[viewHost]\n\n            for p in pgs:\n                if portgroup in p.key:\n                    vlanId = str(p.spec.vlanId)\n                    vSwitch = str(p.spec.vswitchName)\n\n        if portGroup is None:\n            portGroup = 'N/A'\n\n        print '%s -> %s @ %s -> %s (VLAN %s)' % (dev.deviceInfo.label,\n                                                 dev.macAddress,\n                                                 vSwitch,\n                                                 portGroup,\n                                                 vlanId)\n\ndef print_dual_homed_vms(service):\n    \"\"\"Lists all virtual machines with multiple\n       NICs to different networks\"\"\"\n\n    content = service.RetrieveContent()\n    hosts, host2portgroup = generate_portgroup_info(content)\n    vms = get_vms(content, min_nics=2)\n    for vm in vms:\n        print_vm_info(vm, hosts, host2portgroup, content)\n\nif __name__ == '__main__':\n    if len(sys.argv) < 5:\n        print 'Usage: %s host user password port' % sys.argv[0]\n        sys.exit(1)\n\n    service = connect.SmartConnect(host=sys.argv[1],\n                                   user=sys.argv[2],\n                                   pwd=sys.argv[3],\n                                   port=int(sys.argv[4]))\n    print_dual_homed_vms(service)\n```", "```\nuser@lab:~$ python listDualHomed.py 192.168.167.26 readonly 'mypwd' 443\n=== EvesMachine ===\nNetwork adapter 1 -> 00:50:56:ab:04:38 @ dvSwitch -> dvInternalNetwork (VLAN 8)\nNetwork adapter 2 -> 00:50:56:ab:23:50 @ dvSwitch -> dvDMZ (VLAN 0)\n\n=== Firewall ===\nNetwork adapter 1 -> 00:50:56:ab:12:e6 @ dvSwitch -> dvInternalNetwork (VLAN 8)\nNetwork adapter 2 -> 00:50:56:ab:4b:62 @ dvSwitch -> dvDMZ (VLAN 0)\n\n```", "```\n#!/usr/bin/env python\n\nfrom pyVim import connect\nfrom pyVmomi import vmodl\nfrom pyVmomi import vim\nimport re\nimport sys\n\ndef get_vms(content):\n    \"\"\"Returns a list of all virtual machines.\"\"\"\n    vm_view = content.viewManager.CreateContainerView(content.rootFolder,\n                                                      [vim.VirtualMachine],\n                                                      True)\n    vms = [vm for vm in vm_view.view]\n    vm_view.Destroy()\n    return vms\n\ndef print_vm_hardware_access(vm):\n    findings = []\n\n    for dev in vm.config.hardware.device:\n        if isinstance(dev, vim.vm.device.VirtualUSB):\n            findings.append('USB access to host device ' + dev.backing.deviceName)\n        elif isinstance(dev, vim.vm.device.VirtualSerialPort):\n            findings.append('Serial port access')\n        elif isinstance(dev, vim.vm.device.VirtualCdrom):\n            if not dev.backing is None:\n                if 'vmfs/devices/cdrom' in dev.backing.deviceName:\n                    findings.append('Access to CD/DVD drive')\n        elif isinstance(dev, vim.vm.device.VirtualDisk):\n            if dev.backing is None or \\\n               dev.backing.fileName is None or \\\n               re.match(r'.*\\.vmdk', dev.backing.fileName) is None:\n               findings.append('Suspicious HDD configuration')\n\n    if len(findings) > 0:\n        print '=== %s hardware configuration findings ===' % vm.name\n        for l in findings:\n            print l\n        print \"\\n\"\n\ndef print_direct_hardware_access(content):\n    vms = get_vms(content)\n    for vm in vms:\n        print_vm_hardware_access(vm)\n\nif __name__ == '__main__':\n    if len(sys.argv) < 5:\n        print 'Usage: %s host user password port' % sys.argv[0]\n        sys.exit(1)\n\n    service = connect.SmartConnect(host=sys.argv[1],\n                                   user=sys.argv[2],\n                                   pwd=sys.argv[3],\n                                   port=int(sys.argv[4]))\n\n    # access the inventory\n    content = service.RetrieveContent()\n    print_direct_hardware_access(content)\n```", "```\nuser@lab:~$ python listHardwareAccess.py 192.168.167.26 readonly pwd 443\n=== EvesMachine hardware configuration findings ===\nAccess to CD/DVD drive\nSerial port access\nUSB access to host device path:2/0 version:2\n\n=== DeveloperBox hardware configuration findings ===\nAccess to CD/DVD drive\n\n=== dmzBox hardware configuration findings ===\nAccess to CD/DVD drive\n\n```", "```\n#!/usr/bin/env python\n\nfrom pyVim import connect\nfrom pyVmomi import vim\nfrom datetime import datetime\nimport sys\n\ndef make_snapshot(service, vmname):\n    \"\"\"Creates a snapshot of all virtual machines with the given name\"\"\"\n\n    snap_name = 'Memory_Snapshot'\n    snap_desc = 'Snapshot for investigation taken at ' + datetime.now().isoformat()\n\n    content = service.RetrieveContent()\n    vm_view = content.viewManager.CreateContainerView(content.rootFolder,\n                                                      [vim.VirtualMachine],\n                                                      True)\n    vms = [vm for vm in vm_view.view if vm.name==vmname]\n    vm_view.Destroy()\n\n    for vm in vms:\n        print 'Taking snapshot from VM UUID=%s' % vm.summary.config.uuid\n        vm.CreateSnapshot_Task(name = snap_name,\n                               description = snap_desc,\n memory = True,\n                               quiesce=False)\n        print \"Done.\\n\"\n\nif __name__ == '__main__':\n    if len(sys.argv) < 6:\n        print 'Usage: %s host user password port vmname' % sys.argv[0]\n        sys.exit(1)\n\n    service = connect.SmartConnect(host=sys.argv[1],\n                                   user=sys.argv[2],\n                                   pwd=sys.argv[3],\n                                   port=int(sys.argv[4]))\n\n    make_snapshot(service, sys.argv[5])\n```"]