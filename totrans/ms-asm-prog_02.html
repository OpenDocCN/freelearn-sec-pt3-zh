<html><head></head><body>
        

                            
                    <h1 class="header-title">Setting Up a Development Environment</h1>
                
            
            
                
<p>We are slowly approaching the point where we will be able to begin to actually deal with Assembly language itself--writing code, examining programs, solving problems. We are just one step away, and the step is setting up a development environment for Assembly programming.</p>
<p>Despite the fact that the assembler used in this book is a <strong>Flat Assembler</strong> (<strong>FASM</strong>), it is important to cover at least two other options and, therefore, in this chapter, you will learn how to configure three types of development environment:</p>
<ul>
<li><strong>Setting up a development environment for Windows-based applications using Visual Studio 2017 Community</strong>: This will allow the direct integration of Assembly projects with existing solutions</li>
<li><strong>Installing GNU Compilers Collection</strong> (<strong>GCC</strong>): Although it is possible to use GCC on both Windows and *nix platforms, we will emphasize GCC usage on Linux</li>
<li><strong>Flat Assembler</strong>: This one seems to be the simplest and most comfortable one to use for Assembly programming on either Windows or Linux</li>
</ul>
<p>We will end each section with a short test program written in the Assembly language specifically for the assembler described in the section.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Microsoft Macro Assembler</h1>
                
            
            
                
<p>As the name of this assembler states, it supports macros and has a nice set of built-in ones. However, it is hard to find a more or less valuable assembler without this feature today.</p>
<p>The first assembler I ever used was <strong>Macro Assembler</strong> (<strong>MASM</strong>) (I do not remember which version) on DOS installed on a Sony laptop with 4-MB RAM and a 100-MB hard disk (ah, good old times), and MS-DOS edit.exe was the only IDE. Needless to say, the compilation and linking was performed manually in the command line (as if DOS had any other interface).</p>
<p>In my opinion, this is the best way to learn Assembly or any other programming language--just a simple editor with as few features as possible (however, syntax highlighting is a great advantage, as it helps in avoiding typos) and a set of command-line tools. Modern <strong>integrated development environments</strong> (<strong>IDEs</strong>) are very complex, yet very powerful tools, and I am not trying to underestimate them; however, it is much better to use them once you understand what happens behind this complexity.</p>
<p>However, the intent behind this book is to learn the language the CPU speaks, not a specific Assembly dialect or specific assembler command-line options. Not to mention the fact that the currently available Microsoft Visual Studio 2017 Community (the easiest way to get MASM is to install Visual Studio 2017 Community--free and convenient) comes with several assembler binaries:</p>
<ul>
<li>A 32-bit binary that produces 32-bit code</li>
<li>A 32-bit binary that produces 64-bit code</li>
<li>A 64-bit binary that produces 32-bit code</li>
<li>A 64-bit binary that produces 64-bit code</li>
</ul>
<p>Our goal is to know how the CPU thinks rather than how to make it understand our thoughts and how we can find the location of libraries and executables installed on the system. Therefore, if MASM is your choice, it's good to use Visual Studio 2017 Community, as it will save you a lot of time.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Installing Microsoft Visual Studio 2017 Community</h1>
                
            
            
                
<p>You may safely skip this step if you already have Microsoft Visual Studio 2017 Community or any other version of Microsoft Visual Studio installed.</p>
<p>This is one of the easiest actions described in this book. Go to <a href="https://www.visualstudio.com/downloads/">https://www.visualstudio.com/downloads/</a> and download and run the installer for Visual Studio 2017 Community.</p>
<p>The installer has many options that you may want to select depending on your development needs; however, there is one that we need for Assembly development, and it is called Desktop development with C++.</p>
<p>If you insist on using the command line to build your Assembly programs, you can find MASM executables at the following locations:<br/>
<kbd>VS_2017_install_dir\VC\bin\amd64_x86\ml.exe</kbd><br/>
<kbd>VS_2017_install_dir\VC\bin\amd64\ml64.exe</kbd><br/>
<kbd>VS_2017_install_dir\VC\bin\ml.exe</kbd><br/>
<kbd>VS_2017_install_dir\VC\bin\x86_amd64\ml64.exe</kbd><br/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Setting up the Assembly project</h1>
                
            
            
                
<p>Unfortunately, Visual Studio, by default, has no template for Assembly language projects, therefore, we have to create one ourselves:</p>
<ol>
<li>Launch Visual Studio and create an empty solution, as shown in the following screenshot:</li>
</ol>
<div><img class="image-border" height="451" src="img/55af3526-45f6-46dc-aa46-b4c56a13670d.png" width="664"/></div>
<p>Creating blank VS2017 solution</p>
<p style="padding-left: 60px">Look at the bottom-right part of the Start Page window, where you will see the option to create a blank solution. If there is no such option, click on More project templates... and select Blank Solution from there.</p>
<ol start="2">
<li>Once the solution has been created for us, we may add a new project. Right-click on the name of the solution and go to Add | New Project:</li>
</ol>
<div><img class="image-border" height="365" src="img/7314b70a-8938-4b95-8c39-b9a5e2e2f372.png" width="631"/></div>
<p>Adding a new project to the solution</p>
<p style="padding-left: 60px">As Visual Studio has no built-in template for an Assembly project, we will add an empty C++ project to our solution:</p>
<div><img class="image-border" height="444" src="img/591ac333-ae73-4aee-be46-1e99bfd0dbfb.png" width="659"/></div>
<p>Creating an empty project</p>
<ol start="3">
<li>Choose a name for the project and click on OK. There are a two more things we have to do before we can add source files. To be more precise, we can add sources and then take care of these two things, as the order does not really matter. Just keep in mind that we will not be able to build (or, correctly build) our project before we take care of these.</li>
</ol>
<ol start="4">
<li>The first thing to take care of is setting the subsystem for the project; otherwise, the linker will not know what kind of executable to generate.</li>
</ol>
<p style="padding-left: 60px">Right-click on the project name in the Solution Explorer tab and go to Properties. In the project properties window, we go to Configuration Properties | Linker | System and select Windows (/SUBSYSTEM:WINDOWS) under SubSystem:</p>
<div><img class="image-border" height="455" src="img/6607db15-b944-43f2-9c20-adc4bf14bdb8.png" width="642"/></div>
<p>Setting the target subsystem</p>
<ol start="5">
<li>The next step is to tell Visual Studio that this is an Assembly language project:</li>
</ol>
<div><img class="image-border" src="img/6f7ed48d-65b7-4ce5-b503-49c5640a6b47.png"/></div>
<p>Opening the "Build Customizations" window</p>
<ol start="6">
<li>Right-click on the project name and go to Build Dependencies in the context menu, click on Build Customizationsâ€¦, and from the build customizations window, select <kbd>masm(.targets, .props)</kbd>:</li>
</ol>
<div><img class="image-border" src="img/de28f203-e473-4739-b338-677df284b96b.png"/></div>
<p>Setting proper targets</p>
<ol start="7">
<li>We are now ready to add the first Assembly source file:</li>
</ol>
<div><img class="image-border" height="353" src="img/4b592922-ad41-4af4-ab45-742a2b2145cd.png" width="627"/></div>
<p>Adding a new Assembly source file</p>
<p style="padding-left: 60px">Unfortunately, Visual Studio does not seem to be prepared for Assembly projects and, therefore, has no built-in template for Assembly files. So, we right-click on Source Files in the Solution Explorer, select New Item under Add, and since there is no template for the Assembly source file, we select C++ File (.cpp), but set the name of the file with the <kbd>.asm</kbd> extension. We click on Add, and voila! Our first Assembly source file is shown in the IDE.</p>
<ol start="8">
<li>Just for fun, let's add some code:</li>
</ol>
<pre>        .686<br/>        .model flat, stdcall<br/><br/>        <em>; this is a comment</em><br/><em>        ; Imported functions</em><br/>        ExitProcess proto uExitCode:DWORD<br/>        MessageBoxA proto hWnd:DWORD, lpText:DWORD, lpCaption:DWORD, <br/>        uType:DWORD<br/><br/>        <em>; Here we tell assembler what to put into data section</em><br/>        .data<br/>            msg db 'Hello from Assembly!', 0<br/>            ti db 'Hello message', 0<br/><br/>        <em>; and here what to put into code section</em><br/>        .code<br/><br/>        <em>; This is our entry point</em><br/>        main PROC<br/>            push 0              <em>; Prepare the value to return to the </em><br/><em>                                ; operating system</em><br/>            push offset msg     <em>; Pass pointer to MessageBox's text to </em><br/><em>                                ; the show_message() function</em><br/>            push offset ti      <em>; Pass pointer to MessageBox's title to </em><br/><em>                                ; the show_message() function</em><br/>            call show_message   <em>; Call it</em><br/><br/>            call ExitProcess    <em>; and return to the operating system</em><br/>        main ENDP<br/><br/>        <em>; This function's prototype would be:</em><br/><em>        ; void show_message(char* title, char* message);</em><br/>        show_message PROC<br/>            push ebp<br/>            mov  ebp, esp<br/>            push eax<br/><br/>            push 0              <em>; uType</em><br/>            mov  eax, [dword ptr ebp + 8]<br/>            push eax            <em>; lpCaption</em><br/>            mov  eax, [dword ptr ebp + 12]<br/>            push eax            <em>; lpText</em><br/>            push 0              <em>; hWnd</em><br/>            call MessageBoxA    <em>; call MessageBox()</em><br/><br/>            pop  eax<br/>            mov  esp, ebp<br/>            pop  ebp<br/>            ret  4 * 2          <em>; Return and clean the stack</em><br/>        show_message ENDP<br/>        END main</pre>
<p>Do not worry if the code does not "speak" to you yet; we will begin to get acquainted with the instructions and program structure in <a href="57c5447c-2cc4-4a48-9c46-6825e4a83a9c.xhtml" target="_blank">Chapter 3</a>, <em>Intel Instruction Set Architecture (ISA)</em>.</p>
<p>Right now, let's build the project and run it. The code does not do much, as it simply displays a message box and terminates the program:</p>
<div><img class="image-border" height="133" src="img/574ca98e-c5b5-4027-b82a-1204fbda8a3d.png" width="156"/></div>
<p>Sample output</p>
<p>By now, we have a working setup for Assembly development on Windows.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">GNU Assembler (GAS)</h1>
                
            
            
                
<p>The GNU Assembler or GAS, or simply AS, is the most used assembler on *nix (Unix and Linux) platforms. While it is cross-platform (having the right build of GAS, we can compile Assembly code for a wide variety of platforms including Windows), flexible and powerful, it defaults to the AT&amp;T syntax, which is, for those used to Intel syntax, weird, to say the least. GAS is free software released under the terms of GNU General Public License v3.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Installing GAS</h1>
                
            
            
                
<p>GAS is distributed as part of the <kbd>binutils</kbd> package, but since it is the default backend for GCC (GNU Compilers Collection), it would be better if we install GCC. In fact, installing GCC instead of <kbd>binutils</kbd> alone will slightly simplify the creation of executables out of our Assembly code, as GCC would automatically handle a few tasks during the linking process. Despite having its roots in *nix systems, GAS is also available for Windows and may be downloaded from <a href="https://sourceforge.net/projects/mingw-w64/">https://sourceforge.net/projects/mingw-w64/</a> (just remember to add the <kbd>bin</kbd> subfolder in the installation folder to the <kbd>PATH</kbd> environment variable). Installation on Windows is quite straightforward--simply follow the steps in the GUI installation wizard.</p>
<p>Another option for those of us using Windows is "Bash on Windows;" however, this is only available on 64-bit Windows 10 with Anniversary/Creators Update installed. The installation steps for GAS would then be the same as those for running Ubuntu or Debian Linux.</p>
<p>As this book is intended for developers, it might be safe to assume that you already have it installed on your system, if you are on a *nix system, however, let's leave assumptions aside and install GAS.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Step 1 - installing GAS</h1>
                
            
            
                
<p>Open your favorite terminal emulator and issue the following command:</p>
<pre><strong>sudo apt-get install binutils gcc</strong></pre>
<p>If you are on a Debian-based distribution or if it is RH based, then use the following command:</p>
<pre><strong>sudo yum install binutils gcc</strong></pre>
<p>Alternatively, you can use the following:</p>
<pre><strong>su -c "yum install binutils gcc"</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Step 2 - let's test</h1>
                
            
            
                
<p>Once ready, let's build our first Assembly program on Linux. Create an Assembly source file named, for example, <kbd>test.S</kbd>.</p>
<p>Assembly source files on *nix platforms have the extension <kbd>.S</kbd> or <kbd>.s</kbd> instead of <kbd>.asm</kbd>.</p>
<p>Fill in the following code:</p>
<pre><em>/*</em><br/><em> This is a multiline comment.</em><br/><em>*/</em><br/><em>// This is a single line comment.</em><br/><em># Another single line comment.</em><br/><br/><em># The following line is not a necessity.</em><br/>   .file "test.S"<br/> <br/><em># Tell GAS that we are using an external function.</em><br/>   .extern printf<br/> <br/><em># Make some data - store message in data section 0</em><br/>   .data<br/>msg:<br/>   .ascii "Hello from Assembly language!xaxdx0"<br/> <br/><em># Begin the actual code</em><br/>   .text<br/><em># Make main() publicly visible</em><br/>   .globl main<br/><em>/*</em><br/><em> This is our main() function. </em><br/><em> It is important to mention, </em><br/><em> that we can't begin the program with </em><br/><em> 'main()' when using GAS alone. We have then</em><br/><em> to begin the program with 'start' or '_start' </em><br/><em> function.</em><br/><em>*/</em><br/><br/>main:<br/>   pushl %ebp<br/>   movl %esp, %ebp<br/>   pushl $msg          <em># Pass parameter (pointer</em><br/><em>                       # to message) to output_message function.</em><br/>   call output_message <em># Print the message</em><br/>   movl $0, %eax<br/>   leave<br/>   ret<br/> <br/><em># This function simply prints out a message to the Terminal</em><br/>output_message:<br/>   pushl %ebp<br/>   movl %esp, %ebp<br/>   subl $8, %esp<br/>   movl 8(%ebp), %eax<br/>   movl %eax, (%esp)<br/>   call _printf        <em># Here we call printf</em><br/>   addl $4, %esp<br/>   movl $0, %eax<br/>   leave<br/>   ret $4</pre>
<p>Prepend <kbd>printf</kbd> and <kbd>main</kbd> with an underscore (<kbd>_</kbd>) if you are on Windows.</p>
<p>If on Linux, build the code with the following command:</p>
<pre><strong>gcc -o test test.S</strong></pre>
<p>In order for this code to be compiled correctly on a 64-bit system, as it is written for 32-bit assembler, you should install the 32-bit toolchain and libraries, as well as add the <kbd>-m32</kbd> option, which tells GCC to generate code for a 32-bit platform, with this command:<br/>
<strong><kbd>gcc -m32 -o test test.S</kbd></strong><br/>
Refer to the documentation of your Linux distro for instructions on how to install 32-bit libraries.</p>
<p>If you're on Windows, change the name of the output executable accordingly:</p>
<pre><strong>gcc -o test.exe test.S</strong></pre>
<p>Run the executable in the Terminal. You should see the message followed by a new line:</p>
<pre><strong>Hello from Assembly language!</strong></pre>
<p>As you may have noticed, the syntax of this Assembly source is different from that supported by MASM. While MASM supports what is called Intel syntax, GAS originally supported only the AT&amp;T syntax. However, the support for Intel syntax was added at some point, thus making the life of new adepts significantly easier.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Flat Assembler</h1>
                
            
            
                
<p>Now that we have seen the complexities introduced by MASM and GAS, whether it is syntax or setup complexity, let's take a look at Flat Assembler, a free, portable, self-compiling assembler for Windows and Linux with Intel syntax (very similar to that of MASM, but much less complicated and much more understandable). Exactly the tool we need for easier and faster understanding of Intel Assembly language and usage thereof.</p>
<p>In addition to support for various executable file formats (DOS COM files to begin with, through Windows PE (both 32 bit and 64 bit) and up to ELF (both 32 bit and 64 bit)), FASM has a very powerful macro engine, which we will definitely take advantage of. Not to mention the fact that FASM can be easily integrated into existing development environments for more complex projects.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Installing the Flat Assembler</h1>
                
            
            
                
<p>Regardless of whether you are on Windows or on Linux, you can get the Flat Assembler in the same easy way:</p>
<ol>
<li>First, visit <a href="https://flatassembler.net/download.php">https://flatassembler.net/download.php</a> and select the proper package for your operating system:</li>
</ol>
<div><img class="image-border" height="210" src="img/404e2f83-c55c-489d-8b0c-f5b92f84a1d1.png" width="473"/></div>
<p>Flat Assembler download page</p>
<ol start="2">
<li>Unpack the package. Both Windows and Linux packages come with FASM sources, documentation, and examples. As we see in the following screenshot, the Windows version comes with two executables: <kbd>fasm.exe</kbd> and <kbd>fasmw.exe</kbd>. The only difference between the two is that <kbd>fasmw.exe</kbd> is a GUI implementation of Flat Assembler, while <kbd>fasm.exe</kbd> is the command line only:</li>
</ol>
<div><img class="image-border" height="174" src="img/827183a1-e26f-484d-89de-8346c68a845a.png" width="458"/></div>
<p>Content of the Flat Assembler package<br/></p>
<p style="padding-left: 60px">Both executables may be run from the directory you unpacked the package to, as they have no external dependencies. If you decide to move it elsewhere, do not forget to put the <kbd>INCLUDE</kbd> folder and the <kbd>FASMW.INI</kbd> file (if one has already been created) into the same directory. If you copy <kbd>FASMW.INI</kbd>, then you will have to manually edit the <kbd>Include</kbd> path under the <kbd>[Environment]</kbd> section. Alternatively, you may skip copying <kbd>FASMW.INI</kbd>, as it will be automatically created the first time you launch <kbd>FASMW.EXE</kbd>.</p>
<p style="padding-left: 60px">The Linux version lacks the GUI part, but it still contains the <kbd>fasm</kbd> source code, documentation, and examples:</p>
<div><img class="image-border" height="80" src="img/3bfd5451-679b-416c-8fb1-ba6e53688407.png" width="382"/></div>
<p>The content of the Flat Assembler package for Linux</p>
<p>While the <kbd>fasm</kbd> executable for Linux, just like its Windows counterpart, has no external dependencies and may be executed directly from the folder you unpacked the package to, it is a matter of convenience to copy it to a more proper location, for example, to <kbd>/usr/local/bin</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The first FASM program</h1>
                
            
            
                
<p>Now that we have installed the Flat Assembler, we cannot move further on unless we build a tiny test executable for either Windows or Linux. Interestingly enough, both examples may be compiled with the same assembler, meaning that the Linux example may be compiled on Windows and vice versa. But let's get to the example itself.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Windows</h1>
                
            
            
                
<p>If you are on Windows, launch <kbd>fasmw.exe</kbd> and enter the following code:</p>
<pre> include 'win32a.inc'<br/><br/> format PE GUI<br/> entry _start<br/><br/> section '.text' code readable executable<br/> _start:<br/>    push 0<br/>    push 0<br/>    push title<br/>    push message<br/>    push 0<br/>    call [MessageBox]<br/>    call [ExitProcess]<br/><br/> section '.data' data readable writeable<br/>    message db 'Hello from FASM!', 0x00<br/>    title db 'Hello!', 0x00<br/><br/> section '.idata' import data readable writeable<br/> library kernel, 'kernel32.dll',<br/>         user, 'user32.dll'<br/><br/> import kernel,\<br/>        ExitProcess, 'ExitProcess'<br/><br/> import user,\<br/>        MessageBox, 'MessageBoxA'</pre>
<p>Again, do not worry if you hardly understand anything in this code; it will begin to become clearer starting with the next chapter.</p>
<p>In order to run the preceding code, go to the Run menu and select Run.</p>
<div><img class="image-border" height="234" src="img/7ac22574-311d-40fc-9675-963ceaefc682.png" width="464"/></div>
<p>Compiling sources in FASMW</p>
<p>Admire the result for a few seconds.</p>
<div><img class="image-border" height="120" src="img/1868385c-240a-4f02-8700-37292c4f43c5.png" width="125"/></div>
<p>Example output</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Linux</h1>
                
            
            
                
<p>If you are on Linux, the source code will be even shorter. Open your favorite source editor, whether it is <kbd>nano</kbd>, <kbd>emacs</kbd>, or <kbd>vi</kbd>, or whatever, and enter the following code:</p>
<pre> format ELF executable 3<br/> entry _start<br/><br/> segment readable executable<br/> _start:<br/>    mov eax, 4<br/>    mov ebx, 1<br/>    mov ecx, message<br/>    mov edx, len<br/>    int 0x80<br/><br/>    xor ebx, ebx<br/>    mov eax, ebx<br/>    inc eax<br/>    int 0x80<br/><br/><br/> segment readable writeable<br/>    message db 'Hello from FASM on Linux!', 0x0a<br/>    len = $ - message</pre>
<p>The code is much more compact than that on Windows, as we are not using any high-level API functions; we'd rather use Linux system calls directly (this could turn into a nightmare on Windows). Save the file as <kbd>fasm1lin.asm</kbd> (this is not GAS or GCC, so we are free to give the Assembly source file its usual extension) and go to the terminal emulator. Issue the following command (assuming the <kbd>fasm</kbd> executable is in the place mentioned in the <kbd>PATH</kbd> environment variable) in order to build the executable out of this code:</p>
<pre><strong>fasm fasm1lin.asm fasm1lin</strong></pre>
<p>Then, try to run the file with the following:</p>
<pre><strong>./fasm1lin</strong></pre>
<p>You should see something like this:</p>
<div><img class="image-border" src="img/29d2fb0e-c2e8-4036-a8f0-99fd33905e69.png"/></div>
<p>Building and running a Linux executable with Flat Assembler</p>
<p>As simple as that.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>By now, we have reviewed three different assemblers: <strong>Microsoft Macro Assembler</strong> (<strong>MASM</strong>), this is an integral part of Visual Studio, <strong>GNU Assembler</strong> (<strong>GAS</strong>), this is the default backend for GNU Compilers Collection (GCC), <strong>Flat Assembler</strong> (<strong>FASM</strong>), this is a standalone, portable, flexible, and powerful assembler.</p>
<p>Although we will be using FASM, we may still refer to the other two from time to time, when the need arises (and it will).</p>
<p>Having an installed and working assembler, we are ready to proceed to <a href="57c5447c-2cc4-4a48-9c46-6825e4a83a9c.xhtml" target="_blank">Chapter 3</a>, <em>Intel Instruction Set Architecture (ISA)</em>, and start working with the Assembly language itself. There is a long road ahead, and we have not made the first step yet. In <a href="https://cdp.packtpub.com/mastering_assembly_programming/wp-admin/post.php?post=52&amp;action=edit&amp;save=save#post_108" target="_blank">Chapter 3</a>, <em>Intel Instruction Set Architecture (ISA)</em>, we will go through the instruction set architecture of Intel processors, and you will learn how to write simple programs for both Windows and Linux, 32 and 64-bit.</p>


            

            
        
    </body></html>