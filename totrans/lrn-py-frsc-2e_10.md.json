["```\npip install psutil==5.4.5\n```", "```\n>>> import psutil\n>>> pids = psutil.pids()\n>>> pids[0]\n62\n>>> proc = psutil.Process(pids[0])\n>>> proc.is_running()\nTrue\n>>> proc.name()\nsyslogd\n>>> proc.ppid()\n1\n>>> proc.parent().name()\nlaunchd\n>>> proc.open_files()[0]\npopenfile(path='/private/var/run/utmpx', fd=3)\n```", "```\n>>> for part in psutil.disk_partitions():\n...     print(\"Device: {}, Filesystem: {}, Mount: {},\"\n...           \" Size: {}, Disk Used: {}%\".format(\n...                 part[0], part[2], part[1], \n...                 psutil.disk_usage(part[1])[0], \n...                 psutil.disk_usage(part[1])[3]))\n...\nDevice: /dev/disk1s1, Filesystem: apfs, Mount: /, Size: 500068036608, Disk Used: 82.9%\n```", "```\n>>> psutil.users()[0].name\nPyForensics\n>>> psutil.users()[0].started\n1548086912.0\n>>> from datetime import datetime\n>>> print(datetime.utcfromtimestamp(psutil.users()[0].started))\n2019-01-21 16:08:32\n```", "```\npip install WMI==1.4.9\n```", "```\n>>> import wmi\n>>> conn = wmi.WMI()\n>>> for service in conn.query(\n...        \"SELECT * FROM Win32_Service WHERE State='Running'\"):\n...    print(\"Service: {}, Desc: {}, Mode: {}\".format(\n...         service.Name, service.Description, service.StartMode))\n...\nService: PlugPlay, Desc: Enables a computer to recognize and adapt to hardware changes with little or no user input. Stopping or disabling this service will result in system instability., Mode: Manual\n```", "```\n>>> for printer in conn.Win32_Printer():\n...    print(printer.Name)\n...\nMicrosoft XPS Document Writer\nMicrosoft Print to PDF\nHP[...] (HP ENVY Photo 6200 series)\nFax\n```", "```\n>>> for event in conn.query(\n            \"SELECT * FROM Win32_NTLogEvent WHERE Logfile='OAlerts'\"):\n...     print(event.Message, event.TimeGenerated)\n...\nMicrosoft Excel\nWant to save your changes to 'logonevent.csv'?\nP1: 153042\nP2: 15.0.5101.1000\nP3:\nP4:\n20190121031627.589966-000\n```", "```\npip install pywin32==224\n```", "```\n002 from __future__ import print_function\n003 import argparse\n004 import os\n005 import platform\n006 import sys\n007 \n008 import psutil\n009     if sys.version_info[0] == 2:\n010 import unicodecsv as csv\n011     elif sys.version_info[0] == 3:\n012 import csv\n...\n050 def return_none():\n051    \"\"\"\n052    Returns a None value, but is callable.\n053    :return: None.\n054    \"\"\"\n055    return None\n...\n058 def read_proc_connections(proc):\n...\n081 def read_proc_files(proc):\n...\n101 def get_pid_details(pid):\n...\n158 def get_process_info():\n...\n172 def wmi_info(outdir):\n...\n279 def csv_writer(data, outdir, name, headers, **kwargs):\n```", "```\n313 if __name__ == '__main__':\n314     parser = argparse.ArgumentParser(description=__description__,\n315                     epilog='Developed by ' +\n316                     __author__ + ' on ' +\n317                     __date__)\n318     parser.add_argument('OUTPUT_DIR',\n319     help=\"Path to output directory. Will create if not found.\")\n320     args = parser.parse_args()\n321\n322     if not os.path.exists(args.OUTPUT_DIR):\n323         os.makedirs(args.OUTPUT_DIR)\n```", "```\n325     if 'windows' in platform.system().lower():\n326         try:\n327             import wmi\n328         except ImportError:\n329             print(\"Install the wmi and pywin32 modules. \"\n330             \"Exiting...\")\n331             sys.exit(1)\n332         wmi_info(args.OUTPUT_DIR)\n```", "```\n334     # Run data gathering function\n335     print(\"[+] Gathering current active processes information\")\n336     pid_data = get_process_info()\n337     fields = ['pid', 'name', 'exe', 'ppid', 'cmdline',\n338         'username', 'cwd', 'create_time', '_errors']\n339 \n340     # Generate reports from gathered details\n341     csv_writer(pid_data, args.OUTPUT_DIR, 'pid_summary.csv',\n342         fields, type='DictWriter')\n```", "```\n158 def get_process_info():\n159     \"\"\"\n160     Gather details on running processes within the system.\n161     :return pid_info: A dictionary containing details of\n162     running processes.\n163     \"\"\"\n164 \n165     # List of PIDs\n166     pid_info = {}\n167     for pid in psutil.pids():\n168         pid_info[pid] = get_pid_details(pid)\n169     return pid_info\n```", "```\n101 def get_pid_details(pid):\n102     \"\"\"\n103     Gather details on a specific pid.\n104     :param pid: an integer value of a pid to query for\n105     additional details.\n106     :return details: a dictionary of gathered information\n107     about the pid.\n108     \"\"\"\n109     details = {'name': '', 'exe': '', 'cmdline': '', 'pid': pid,\n110                'ppid': 0, 'status': '', 'username': '',\n111                'terminal': '', 'cwd': '', 'create_time': '',\n112                'children': [], # list of pid ints\n113                'threads': [], # list of thread ints\n114                'files': [], # list of open files\n115                'connections': [], # list of network connections\n116                '_errors': []\n117     }\n```", "```\n118     try:\n119         proc = psutil.Process(pid)\n120     except psutil.NoSuchProcess:\n121         details['_errors'].append(\n122             (pid, 'Process no longer found'))\n123         return details\n124     except OSError:\n125         details['_errors'].append((pid, 'OSError'))\n126         return details\n```", "```\n128     for key in details:\n129         try:\n130             if key in ('pid', '_errors'):\n131                 continue\n132             elif key == 'children':\n133                 children = proc.children()\n134                 details[key] = [c.pid for c in children]\n135 \n136             elif key == 'threads':\n137                 threads = proc.threads()\n138                 details[key] = [t.id for t in threads]\n139             elif key == 'connections':\n140                 details[key] = read_proc_connections(proc)\n141             elif key == 'files':\n142                 details[key] = read_proc_files(proc)\n143             else:\n144                 details[key] = getattr(proc, key, return_none)()\n145         except psutil.AccessDenied:\n146             details[key] = []\n147             details['_errors'].append((key, 'AccessDenied'))\n148         except OSError:\n149             details[key] = []\n150             details['_errors'].append((key, 'OSError'))\n151         except psutil.NoSuchProcess:\n152             details['_errors'].append(\n153             (pid, 'Process no longer found'))\n154             break\n```", "```\n058 def read_proc_connections(proc):\n059     \"\"\"\n060     Read connection properties from a process.\n061     :param proc: An object representing a running process.\n062     :return conn_details: A list of process connection\n063     properties.\n064     \"\"\"\n065     conn_details = []\n```", "```\n066     for conn in proc.connections():\n067         conn_items = {}\n068         conn_items['fd'] = getattr(conn, 'fd', None)\n069         conn_items['status'] = getattr(conn, 'status', None)\n070         conn_items['local_addr'] = \"{}:{}\".format(\n071             getattr(conn.laddr, 'ip', \"\"), getattr(\n072                 conn.laddr, 'port', \"\"))\n073         conn_items['remote_addr'] = \"{}:{}\".format(\n074             getattr(conn.raddr, 'ip', \"\"), getattr(\n075                 conn.raddr, 'port', \"\"))\n076 \n077         conn_details.append(conn_items)\n078     return conn_details\n```", "```\n081 def read_proc_files(proc):\n082     \"\"\"\n083     Read file properties from a process.\n084     :param proc: An object representing a running process.\n085     :return file_details: a list containing process details.\n086     \"\"\"\n087     file_details = []\n088     for handle in proc.open_files():\n089         handle_items = {}\n090         handle_items['fd'] = getattr(handle, 'fd', None)\n091         handle_items['path'] = getattr(handle, 'path', None)\n092         handle_items['position'] = getattr(\n093             handle, 'position', None)\n094         handle_items['mode'] = getattr(handle, 'mode', None)\n095 \n096         file_details.append(handle_items)\n097 \n098     return file_details\n```", "```\n172 def wmi_info(outdir):\n173     \"\"\"\n174     Gather information available through Windows Management\n175     Interface. We recommend extending this script by adding\n176     support for other WMI modules -- Win32_PrintJob,\n177     Win32_NetworkAdapterConfiguration, Win32_Printer,\n178     Win32_PnpEntity (USB).\n179     :param outdir: The directory to write CSV reports to.\n180     :return: Nothing.\n181     \"\"\"\n182 \n183     wmi_dict = {\"Users\": [], \"Shares\": [], \"Services\": [],\n184         \"Disks\": [], \"Event Log\": []}\n185     conn = wmi.WMI()\n```", "```\n187     # See attributes for a given module like so: for user in\n188     # conn.Win32_UserAccount(); user._getAttributeNames()\n189 \n190     print(\"[+] Gathering information on Windows user profiles\")\n191     for user in conn.Win32_UserAccount():\n192         wmi_dict[\"Users\"].append({\n193             \"Name\": user.Name, \"SID\": user.SID,\n194             \"Description\": user.Description,\n195             \"InstallDate\": user.InstallDate,\n196             \"Domain\": user.Domain,\n197             \"Local Account\": user.LocalAccount,\n198             \"Password Changeable\": user.PasswordChangeable,\n199             \"Password Required\": user.PasswordRequired,\n200             \"Password Expires\": user.PasswordExpires,\n201             \"Lockout\": user.Lockout\n202         })\n```", "```\n204     print(\"[+] Gathering information on Windows shares\")\n205     for share in conn.query(\"SELECT * from Win32_Share\"):\n206         wmi_dict[\"Shares\"].append({\n207             \"Name\": share.Name, \"Path\": share.Path,\n208             \"Description\": share.Description,\n209             \"Status\": share.Status,\n210             \"Install Date\": share.InstallDate})\n211\n212     print(\"[+] Gathering information on Windows services\")\n213     for service in conn.query(\n214             \"SELECT * FROM Win32_Service WHERE State='Running'\"):\n215         wmi_dict[\"Services\"].append({\n216             \"Name\": service.Name,\n217             \"Description\": service.Description,\n218             \"Start Mode\": service.StartMode,\n219             \"State\": service.State,\n220             \"Path\": service.PathName,\n221             \"System Name\": service.SystemName})\n```", "```\n223     print(\"[+] Gathering information on connected drives\")\n224     for disk in conn.Win32_DiskDrive():\n225         for partition in disk.associators(\n226                 \"Win32_DiskDriveToDiskPartition\"):\n227             for logical_disk in partition.associators(\n228                     \"Win32_LogicalDiskToPartition\"):\n229                 wmi_dict[\"Disks\"].append({\n230                     \"Physical Disk Name\": disk.Name,\n231                     \"Bytes Per Sector\": disk.BytesPerSector,\n232                     \"Sectors\": disk.TotalSectors,\n233                     \"Physical S/N\": disk.SerialNumber,\n234                     \"Disk Size\": disk.Size,\n235                     \"Model\": disk.Model,\n236                     \"Manufacturer\": disk.Manufacturer,\n237                     \"Media Type\": disk.MediaType,\n238                     \"Partition Name\": partition.Name,\n239                     \"Partition Desc.\": partition.Description,\n240                     \"Primary Partition\": partition.PrimaryPartition,\n241                     \"Bootable\": partition.Bootable,\n242                     \"Partition Size\": partition.Size,\n243                     \"Logical Name\": logical_disk.Name,\n244                     \"Volume Name\": logical_disk.VolumeName,\n245                     \"Volume S/N\": logical_disk.VolumeSerialNumber,\n246                     \"FileSystem\": logical_disk.FileSystem,\n247                     \"Volume Size\": logical_disk.Size,\n248                     \"Volume Free Space\": logical_disk.FreeSpace})\n```", "```\n250     # Query for logon events type 4624\n251     print(\"[+] Querying the Windows Security Event Log \"\n252     \"for Event ID 4624\")\n253     wmi_query = (\"SELECT * from Win32_NTLogEvent WHERE Logfile=\"\n254         \"'Security' AND EventCode='4624'\")\n255     for logon in conn.query(wmi_query):\n256         wmi_dict[\"Event Log\"].append({\n257             \"Event Category\": logon.CategoryString,\n258             \"Event ID\": logon.EventIdentifier,\n259             \"Time Generated\": logon.TimeGenerated,\n260             \"Message\": logon.Message})\n```", "```\n262     csv_writer(wmi_dict[\"Users\"], outdir, \"users.csv\",\n263         sorted(wmi_dict[\"Users\"][0].keys()))\n264     csv_writer(wmi_dict[\"Shares\"], outdir, \"shares.csv\",\n265         sorted(wmi_dict[\"Shares\"][0].keys()))\n266     csv_writer(wmi_dict[\"Services\"], outdir, \"services.csv\",\n267         sorted(wmi_dict[\"Services\"][0].keys()))\n268     csv_writer(wmi_dict[\"Disks\"], outdir, \"disks.csv\",\n269         sorted(wmi_dict[\"Disks\"][0].keys()))\n270     try:\n271         csv_writer(wmi_dict[\"Event Log\"],outdir, \"logonevent.csv\", \n272                    sorted(wmi_dict[\"Event Log\"][0].keys()))\n273     except IndexError:\n274         print(\"No Security Event Log Logon events (Event ID \"\n275             \"4624). Make sure to run the script in an escalated \"\n276             \"command prompt\")\n```", "```\n279 def csv_writer(data, outdir, name, headers, **kwargs):\n280     \"\"\"\n281     The csv_writer function writes WMI or process information\n282     to a CSV output file.\n283     :param data: The dictionary or list containing the data to\n284         write to the CSV file.\n285     :param outdir: The directory to write the CSV report to.\n286     :param name: the name of the output CSV file.\n287     :param headers: the CSV column headers.\n288     :return: Nothing.\n289     \"\"\"\n290     out_file = os.path.join(outdir, name)\n291 \n292     if sys.version_info[0] == 2:\n293         csvfile = open(out_file, \"wb\")\n294     elif sys.version_info[0] == 3:\n295         csvfile = open(out_file, \"w\", newline='',\n296             encoding='utf-8')\n```", "```\n298     if 'type' in kwargs:\n299         with csvfile:\n300             csvwriter = csv.DictWriter(csvfile, fields,\n301                 extrasaction='ignore')\n302             csvwriter.writeheader()\n303             csvwriter.writerows([v for v in data.values()])\n304 \n305     else:\n306         with csvfile:\n307             csvwriter = csv.writer(csvfile)\n308             csvwriter.writerow(headers)\n309             for row in data:\n310                 csvwriter.writerow([row[x] for x in headers])\n```"]