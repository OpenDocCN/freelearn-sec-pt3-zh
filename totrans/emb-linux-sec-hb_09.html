<html><head></head><body><div><div><p>&#13;
			<h1 id="_idParaDest-131" class="chapter-number"><a id="_idTextAnchor264"/>9</h1>&#13;
			<h1 id="_idParaDest-132"><a id="_idTextAnchor265"/>Image-Based Deployments</h1>&#13;
			<p>In this chapter, we are going to truly diverge from the existing norms of package-based installs (and updates), which have been the mainstay of Linux for over thirty years. Let’s talk <a id="_idIndexMarker343"/>about <strong class="bold">immutable image-based systems</strong>. Immutable images have only been around for a few years. Just recently, they have captured the limelight. Some will argue <a id="_idTextAnchor266"/>(myself included) that immutable operating systems for appliances are the future of all embedded systems. The very thought of a system that is immutable and unchanging just gives us the impression of something even more secure than the rest. Or does it? If you too assume that it is more secure, you would be correct. More secure – yes – but not perfect...this chapter will give you a great overview of a topic that in my professional opinion deserves its own book due to its complexities and rapidly evolving future. In this chapter, we will review and also go through some focused exercises geared towards providing you with a greater understanding of the levels of security provided by immutable operating systems. We will take a look at some of the tools available and how to leverage them into building, deploying, and, later on, supporting your appliances once your customers have them in hand.</p>&#13;
			<p>By the end of this chapter, you might just convince yourself that this new method of deploying Linux was tailor-made for us in the embedded Linux systems community. Conversely, you may also decide after digging deeper into the technology that perhaps it’s not for you (yet).</p>&#13;
			<p>In this chapter, we will have the following main headings:</p>&#13;
			<ul>&#13;
				<li>Introducing image-based Linux deployments</li>&#13;
				<li>bootc and bootable container images</li>&#13;
				<li>Special tooling and support infrastructure differences</li>&#13;
				<li>Limitations of image-based deployments</li>&#13;
				<li>Updating and rolling back changes</li>&#13;
				<li>Practical exercises – step-by-step walkthrough of how to deploy image-based systems</li>&#13;
			</ul>&#13;
			<p>So, let’s move on and dive deeper.<a id="_idTextAnchor267"/></p>&#13;
			<h1 id="_idParaDest-133"><a id="_idTextAnchor268"/>Technical requirements</h1>&#13;
			<p>To successfully navigate through the exercises in this chapter, you will need two bare metal or virtual machines that you can modify or reinstall the operating system upon. Root access, internet access, and DHCP IP addressing are mandatory. You will also need the ability to download ISO images and have a 16 GB (or greater) USB thumb drive. Finally, you will need a free Red Hat Developer account and access to your own <strong class="bold">Quay</strong> registry (also free). The requirements are greater for these exercises as the outcomes are more significant. I am hopeful you’ll even have fun along the way, which in my opinion is also a requirement.</p>&#13;
			<p>For these exercises. I am using CentOS Streams 9 as my build machine’s operating system, and we’ll be creating a CentOS Streams 9 bootable container image. Let’s now move onward to the stars of the show, image-based Linux deployments.<a id="_idTextAnchor269"/></p>&#13;
			<h1 id="_idParaDest-134"><a id="_idTextAnchor270"/>Introducing image-based Linux deployments</h1>&#13;
			<p>This subject is<a id="_idIndexMarker344"/> something near and dear to my heart, as I am an embedded systems specialist and have dedicated the past decade to this endeavor. It’s truly my opinion that this set of technologies was virtually tailor made for our embedded Linux systems appliances and the ecosystem of people who build and support them. It would be justifiable for you to question why I, along with many other leaders in the industry, see this as the future. I will give you the short answer here, but we will review it in depth as the chapter progresses. Simplified lifecycle management is the single greatest reason to adopt this new technology for your products.</p>&#13;
			<p>In the upcoming sections, I will walk you through two of these methodologies, their features, their limitations, and their tooling, along with some exercises to make it all real for you<a id="_idTextAnchor271"/>.</p>&#13;
			<h2 id="_idParaDest-135"><a id="_idTextAnchor272"/>rpm-ostree and atomic images</h2>&#13;
			<p>The first <a id="_idIndexMarker345"/>type of image-based installation<a id="_idIndexMarker346"/> method that we’ll review is <strong class="bold">rpm-ostree</strong>. This <a id="_idIndexMarker347"/>type of deployment is sometimes also called <em class="italic">atomic</em> because of its immutability. Some vendors have their own marketing name for it. Red Hat® calls it RHEL for Edge™. Whatever they call it, I call it a game-changer. Many other distributions, in recent years, have added rpm-ostree deployment options. Maybe you’d like a few more examples? Fedora® Silverblue, NixOS, openSUSE® MicroOS, Nitrux, Vanilla OS, Talos Linux™, and BlendOS are some of the many purely atomic distributions.</p>&#13;
			<p>Any use case for Linux you previously had can be addressed with greater security and stability with an image-based deployment. Where you are deploying is irrelevant; these systems run on bare metal, virtual machines, or cloud instances with ease.</p>&#13;
			<p>The <code>/etc</code> and <code>/var</code>. Because of this image format, the old-school methodology of partitioning is essentially moot. …Or should I say immutable?</p>&#13;
			<p>OSTree at its core replicates read-only trees via HTTP. It also has mechanisms for application layering and installation either in <code>/var</code> or <code>/home</code> (which more details about their actual filesystem layout will be covered next). This mechanism is like how rpm repositories are hosted; however, they are different in the manner of images as reference data (versioning, tags, etc.). For your solution, you will have to create the infrastructure to support your deployed appliances.</p>&#13;
			<p>To give you a rough idea of how drastic a change in what might have been its own writable partition in the standard deployment model, here’s a look at how they are handled in this new model. With <code>/var</code> being RW, there are several key directory/filesystem mappings that are different from what you are used to in Linux. Pay close attention.</p>&#13;
			<p>Let’s see how filesystems are mapped and their permissions:</p>&#13;
			<ul>&#13;
				<li><code>/home</code> links to <code>/var/home</code> as RW</li>&#13;
				<li><code>/srv</code> links to <code>/var/srv</code> as RW</li>&#13;
				<li><code>/root</code> links to <code>/var/roothome</code> as RW</li>&#13;
				<li><code>/opt</code> links to <code>/var/opt</code> as RW</li>&#13;
				<li><code>/mnt</code> links to <code>/var/mnt</code> as RW</li>&#13;
				<li><code>/sysroot</code> is RO</li>&#13;
				<li><code>/boot</code> and <code>/boot/efi</code> are RW</li>&#13;
			</ul>&#13;
			<p class="callout-heading">Note</p>&#13;
			<p class="callout"><code>rpm-ostree</code> is the <a id="_idIndexMarker350"/>mechanism that enables <code>ostree</code> image base. Installing an RPM package with <code>rpm-ostree</code> forces the creation of a new image that is merely an update of the base image.</p>&#13;
			<p>To oversimplify, I <a id="_idIndexMarker351"/>will try to relate this methodology as I see it: a series of commits that build upon each other that can be easily rolled back delivered as an immutable image-based appliance-like deployment. I’ll say it again. I feel like sometimes this was tailor-made for embedded Linux systems and custom appliance solutions.</p>&#13;
			<p>So, how can we take advantage of <code>rpm-ostree</code> and layer more awesomeness on top? Let’s take a quick look at some of the ways as we already know that the base image itself is immutable. First, I give you this disclaimer: anything you layer on top might not be maintained as part of that image and could induce the risk of being forgotten as updates to that system progress.</p>&#13;
			<p>That said, we can layer things on top of an rpm-ostree system (outside the image itself). This can be done through fully self-contained applications deployed via flatpacks or as a running container image deployed outside the image. In this use case, the base image is simply the immutable platform for delivering a dynamic application.</p>&#13;
			<p>The other method is to install RPM packages on top of the image. I suppose someone has a use case where this makes sense, but I argue that it should just have been made part of the image, and the system should be updated with the latest image containing the additional RPM packages. Now that we understand rpm-ostree and its key features, here are examples of distributions that can be deployed <em class="italic">optionally</em> as rpm-ostree. Please note that this is a non-exhaustive list:</p>&#13;
			<ul>&#13;
				<li>Red Hat® Enterprise Linux®</li>&#13;
				<li>Fedora® (many variants; the most common is Silverblue)</li>&#13;
				<li>Vanilla OS (an Ubuntu®/Debian® variant)</li>&#13;
				<li>Debian® ostree</li>&#13;
				<li>openSUSE® (Slowroll)</li>&#13;
				<li>SUSE Linux Enterprise Server™</li>&#13;
				<li>CoreOS®</li>&#13;
				<li>Rocky Linux®</li>&#13;
				<li>AlmaLinux®</li>&#13;
				<li>Oracle Enterprise Linux™</li>&#13;
				<li>CentOS® Stream</li>&#13;
			</ul>&#13;
			<p>So, please know <a id="_idIndexMarker352"/>that you have many options for testing the waters with rpm-ostree, for more details I invite you to check out the libostree documentation online:  <a href="https://ostreedev.github.io/ostree/">https://ostreedev.github.io/ostree/</a>.</p>&#13;
			<p>Let’s move on to our next subject and that’s bootable co<a id="_idTextAnchor273"/>ntainers.</p>&#13;
			<h1 id="_idParaDest-136"><a id="_idTextAnchor274"/>bootc and bootable container images</h1>&#13;
			<p>I have been involved deeply with product teams in the scoping, testing, and documentation of this new leading-edge technology since before I started writing this book. These efforts introduced me to some really amazing engineers who are adept at thinking outside the box.</p>&#13;
			<p>What is bootc? A<a id="_idIndexMarker353"/> simplified way of looking at bootc would be to define it as a tool for layering a Linux kernel into a container image so the container image can boot itself without external operating systems hosting it.</p>&#13;
			<p>If you are interested in contributing to this global effort to transform technology (or just learning more), here’s the bootc GitHub repository: <a href="https://github.com/containers/bootc">https://github.com/containers/bootc</a>. There, you can find extensive documentation that is readily maintained.</p>&#13;
			<p>Let’s be clear, bootc is<a id="_idIndexMarker354"/> bleeding-edge technology. Red Hat® (the organization leading the charge in this new technology) considers this to have <em class="italic">Technology Preview</em> status and they will not consider it fully supportable until the tooling and support infrastructure are present. Basically, the technology will not be considered fully supportable, or as<a id="_idIndexMarker355"/> Red Hat calls it, <strong class="bold">Generally Available</strong> (<strong class="bold">GA</strong>), and production-workload-ready until the advent of RHEL 10 and RHEL 9.6, which are both released in May of 2025.</p>&#13;
			<p>This doesn’t mean you should be waiting around. I highly recommend doing an exhaustive level of testing and due diligence to see if this deployment method can add value to your product now and in the future.</p>&#13;
			<p>What exactly is bootc? bootc is an open source project that leverages an <strong class="bold">Open Container Initiative</strong> (<strong class="bold">OCI</strong>) standard-based container<a id="_idIndexMarker356"/> image to create a full operating system image. It leverages the same layering techniques that existing container infrastructures use today for their creation and also for updating themselves. It leverages the functionality of other projects, such as rpm-ostree, to create and update those operating system images.</p>&#13;
			<p>What makes bootc different from rpm-ostree? Both are image-based deployment methods. Both have levels of immutability. What sets them apart is how they are built and how they are updated. The single greatest defining point is bootc’s unique ability to use a container as the basis for an immutable image.</p>&#13;
			<p>Where the bootc methodology abso<a id="_idTextAnchor275"/>lutely shines is that there’s a vast ecosystem of developers and tools for building containers already. If you can build a container, you can build a whole system now. That whole build chain is now transformational, and for most companies, it will require little tooling to adapt to this new methodology if they’re already using containerized apps today.</p>&#13;
			<p>But hold on…in corporate America, and elsewhere globally, not every containerized application needs to be converted to an image-based appliance. The true transformations are, for us, the embedded Linux system community. With this technology, we can design, create, build, and automate the lifecycles of the products that drive our company’s success.</p>&#13;
			<p>Many engineers are currently working feverishly to deliver new tools to support this type of deployment method. By the time RHEL 9.5 ships, the community should have all new functionality available within what is considered the premier tool for building systems images and installers from the RHEL ecosystem and that tool is <strong class="bold">Image Builder</strong>. Image Builder<a id="_idIndexMarker357"/> has been around since RHEL 8.3 days (quite some time ago), but it has evolved and keeps getting better month by month.</p>&#13;
			<p>For those of us <a id="_idIndexMarker358"/>building images in Fedora and CentOS Stream, we can leverage new functionality today at the risk of being on the bleeding edge without the support and obvious stability of the enterprise distributions. I highly recommend checking out the ongoing development of functionality for Image Builder in this GitHub repository: <a href="https://github.com/osbuild/bootc-image-builder">https://github.com/osbuild/bootc-image-builder</a>.</p>&#13;
			<p>Now that we’ve introduced rpm-ostree and bootc images, let’s continue our journey and see h<a id="_idTextAnchor276"/>ow they differ.</p>&#13;
			<h2 id="_idParaDest-137"><a id="_idTextAnchor277"/>Special tooling and support infrastructure differences</h2>&#13;
			<p>This is where we can easily set one methodology against the other. Both methods work eloquently; however, creating, maintaining, and supporting appliances built from rpm-ostree alone is more difficult, and their tooling is more intensively hands-on.</p>&#13;
			<p>In the next few sections, I will primarily focus on open source tools that are the most relevant for either methodology. Let’s start this investigation by looking at tooling that can help you deliver an rpm-o<a id="_idTextAnchor278"/>stree solution.</p>&#13;
			<h3>rpm-ostree open source tooling</h3>&#13;
			<p>Today, there’s a <a id="_idIndexMarker359"/>vast set of tools available within the open source community for your teams to leverage, regardless of the operating system you have selected. That said, each distribution may have some slight alterations or functionality differences that tailor the tools to their specific distribution’s base.</p>&#13;
			<p>Some great examples of tools for building or maintaining functionality in an rpm-ostree image deployment that are available across distributions are:</p>&#13;
			<ul>&#13;
				<li><strong class="bold">Composer-cli:</strong> A command-line tool for defining the complex contents of a Linux image and a way of rendering the image into multiple formats</li>&#13;
				<li><strong class="bold">Osbuild</strong>: A command-line tool for building Linux images</li>&#13;
				<li><strong class="bold">Composer</strong> (also known as <strong class="bold">Image Builder</strong> in some distributions): A graphical, web-based tool for defining, building, and updating a Linux image</li>&#13;
				<li><strong class="bold">Cockpit-composer</strong>: A plugin for the web console on a Linux machine that enables a user to use Composer within the cockpit/web console web UI</li>&#13;
				<li><strong class="bold">Toolbox:</strong> An<a id="_idIndexMarker360"/> interactive command-line tool that assists in the troubleshooting of an operating system</li>&#13;
			</ul>&#13;
			<p>Let’s move on to what tools we can leverage for other methods of image-b<a id="_idTextAnchor279"/>ased deployments.</p>&#13;
			<h3>bootc bootable container image tooling</h3>&#13;
			<p>This is where things get <a id="_idIndexMarker361"/>a little interesting, in my opinion. bootc image-based systems don’t exactly require a plethora of complex tools to be built and supported. This concept we will dive into deeply in our hands-on exercises within this chapter.</p>&#13;
			<p>Please allow me to elaborate. As we will see shortly, all you really need on your build machine is a text editor and access to a registry in order to build and update your appliances. We’ll be leveraging some container tools as well during the build.</p>&#13;
			<p>Here’s an example list of the tools that you can leverage to create and support the lifecycle of a bootc image-based system:</p>&#13;
			<ul>&#13;
				<li>Editors (vi, emacs, nano, etc.): Simple text editing programs that are console-based or graphical, yet not as feature-rich as an IDE suite.</li>&#13;
				<li>Podman: A container management tool used for building, running, and managing containers on top of Linux</li>&#13;
				<li>IDE’s (Podman-Desktop, Eclipse, Visual Studio): Various graphical comprehensive development tools</li>&#13;
				<li>Image Builder: A graphical, web-based tool for defining, building, and updating a Linux image.</li>&#13;
				<li>Cockpit-composer: A plugin for the web console on a Linux machine that enables a user to use Composer within the cockpit/web console web UI.</li>&#13;
				<li>Console.redhat.com: A comprehensive service hosted by Red Hat®, that can assist in the building, maintaining, and introspection of systems</li>&#13;
				<li>Registries: A <a id="_idIndexMarker362"/>registry is crucial for hosting container images and providing a central location to distribute updates, for example, Quay™, Amazon Elastic Container Registry™ (ECR), Harbor, Azure Container Registry (ACR), GitHub Container Registry™, Google Container Registry™ (GCR), JFrog Container Registry™.</li>&#13;
			</ul>&#13;
			<p>Let’s move onto a more serious topic, the limitations of images-based<a id="_idTextAnchor280"/> deployments today.</p>&#13;
			<h1 id="_idParaDest-138"><a id="_idTextAnchor281"/>Limitations of image-based deployments</h1>&#13;
			<p>While <a id="_idIndexMarker363"/>image-based deployments are a paradigm shift in how we can create and maintain solutions, they do have idiosyncrasies that standard package-based deployments do not have. For image-based systems, updates happen at the speed of a reboot. Package-based systems’ update operations can take hours and require multiple reboots, all while hoping no dependencies are broken and everything works in the end.</p>&#13;
			<p>One significant perceived limitation is that filesystems are defined as non-writable. While many see the broader concept of immutability as a feature, if you are trying to install a third-party solution into your image and said solution expects to be installed in a very specific location (filesystem) that is readable and writable, but the actual location is read-only, issues are instantaneous.</p>&#13;
			<p>This is a perceived limitation, not an actual one. With some creative usage of symbolic links, this most likely can easily be circumvented.</p>&#13;
			<p>For those not involved in the ecosystem, these deployments can sometimes be miscategorized or perceived as inflexible, or as having limited ability to customize or tailor the solution easily, and often the necessary software may need to be layered onto them into non-standard filesystem locations so that those applications can function in read/write mode. Some of that is a myth, but not all of <a id="_idTextAnchor282"/>it. Let’s go deeper.</p>&#13;
			<h2 id="_idParaDest-139"><a id="_idTextAnchor283"/>rpm-ostree image limitations</h2>&#13;
			<p>Alright, rpm-ostree is <a id="_idIndexMarker364"/>a great solution. It really is. I have to give credit where it’s due. I love it. That said, I have to address the perception that it can be inflexible. I propose the statement that in all actuality it’s meant to be just that. It is a very secure, immutable image-based deployment. The very tooling itself helps to keep rpm-ostree a very prescriptive type of deployment methodology. rpm-ostree was basically designed to be a secure platform that can easily host containerized apps or virtual machines while retaining a very minimal footprint.</p>&#13;
			<p>There are some limitations and frustrations that I must bring to light for you. First, kernel customizations are a bit of a challenge as the tooling does not help you in that endeavor (yet). I would say that if you have some customizations for anything in the end-state that you desire, your team should create custom RPM packages for them to be implemented. This also requires that you have a deep understanding of the exact hardware that you plan to leverage as your appliances’ baseline. Managing operating-system-level user accounts can be a significant challenge because any changes, layered on such as passwords or group affiliations, that are added on after the deployment can easily be lost as they run the risk of being overwritten by the next image update deployment. In <a href="B22104_10.xhtml#_idTextAnchor305"><em class="italic">Chapter 10</em></a>, we will cover this in more depth; we’ll review the best practice of not having your end-users ever log into the operating system itself on your appliance. I can see how in a corporate environment, this can be seen as a massive issue, but in a secure appliance, I beg the question: is it an issue at all?</p>&#13;
			<p>Additionally, the places where data is actually in a read/write capability does add additional work in the design and support process. Users’ data, application data, and so on – these are seen as some of the complexities of this method of deployment. Planning, testing, and creative usage of symbolic links to locations that are writable will be key concepts that shall help you overcome most of these perceived issues.</p>&#13;
			<p>I often argue that these facets mentioned are truly not limitations but simply design considerations because if you choose to deploy via rpm-ostree, you are embarking on a different and complex journey with many security rewards. Remember when I stated that security begins at the design table?</p>&#13;
			<p>Let’s move on to how other systems could be <a id="_idTextAnchor284"/>perceived as limited.</p>&#13;
			<h2 id="_idParaDest-140"><a id="_idTextAnchor285"/>bootc bootable container image limitations</h2>&#13;
			<p>Here, I feel<a id="_idIndexMarker365"/> I must be a bit forgiving as the technology has not even reached version 1.0 status yet. bootc is still evolving, and its potential is astronomical. Additionally, I feel the need to reiterate that the advanced tools to support bootc are also still evolving as well. I might be biased, but I see a massively bright future for bootc images.</p>&#13;
			<p>For an embedded appliance, having a stable and secure update methodology is a major design point. Today, bootc images are most easily supported by access to the online registry that created their existence. That’s all good and well if your solution will have access to the internet once the customer has implemented it in their own environment. Today, for an embedded Linux system appliance based upon bootc, being <em class="italic">online</em> is best.</p>&#13;
			<p>One of the perceived limitations I see today isn’t exactly a limitation, but a serious design consideration that has to be addressed at the design table. Today, an offline bootc image-based deployment is possible. It’s just a little bit more complex. If your product is to be deployed in an <strong class="bold">air-gapped environment</strong> or non-networked environment, one must build into the appliance’s interface a way of ingesting its updates. This actually means a way of importing locally a new container image to use as the new baseline for its updates and rebuilding.</p>&#13;
			<p>Again, as with rpm-ostree, I recommend obscuring the operating system from the end-user by only allowing them application-based access and keeping the operating system accounts limited. This will address the similar difficulty of maintaining operating systems’ user accounts through each update/image rerendering. Yes, managing or controlling operating-system-level users is a concern in bootc images too. I suspect that there shall be additional tooling developed for this as bootc evolves.</p>&#13;
			<p>In comparison with rpm-ostree, bootc exceeds flexibility and customization. Kernel modifications are easier to achieve. Why? Containers are incredibly flexible themselves and they’re easier to maintain.</p>&#13;
			<p>My professional opinion is that this is a technology worth keeping a very close eye on because it can transform and simplify how you build appliances. I won’t say that it’s without pain points, but I do have the opinion that it has a very bright future. Let’s move on to how we can update or, in the w<a id="_idTextAnchor286"/>orst cases, roll back.</p>&#13;
			<h1 id="_idParaDest-141"><a id="_idTextAnchor287"/>Updating and rolling back changes</h1>&#13;
			<p><strong class="bold">Package-based systems</strong>, regardless <a id="_idIndexMarker366"/>of the package system (RPM, DNF, APT, Zypper, etc.) can have issues and artifacts when either moving to a newer version of their operating system or during an attempt to roll back installations <a id="_idIndexMarker367"/>that produce unintended consequences. If you have ever experienced this, you know exactly what I mean and I offer my condolences. For those of you who have been blessed or simply lucky enough to not have suffered a failed package update process, here’s the difference.</p>&#13;
			<p>Package-based systems are forced to do their dependency checks in real time when they process their updates. What this process amounts to is some packages may be added or deprecated that you might not even be aware of during the process. Not only can it be clunky and obtuse, but it consumes significant time. Hopefully, you tested this process for each release <em class="italic">ad nauseum</em> before presenting updates to your customers. Sometimes, oftentimes, multiple reboots are required. I feel for anyone enduring this. This is downtime. Hopefully, it just works the first time, because if it doesn’t, roll backs often require a recovery from a backup or a snapshot, Hahahahaha – if that even exists.</p>&#13;
			<p>Image-based operating systems do not fall victim to those issues. Whether providing an incremental update or a completely new operating system, this delivery method allows for a rapid in-place upgrade while not impacting user or application data. How? These systems stage their new image and then simply reboot into it. Fast, clean, efficient. More importantly, since you and your team have tested these images, there’s little worrying about whether or not this new image has issues.</p>&#13;
			<p>So, let’s assume the worst case: the image had some corruption in downloading. <em class="italic">No problem</em>. We can recover from the previous image with little to no effort. That’s some amazing upside, right?! Let’s move on to how these systems also can be upgraded <a id="_idTextAnchor288"/>in place without stress.</p>&#13;
			<h2 id="_idParaDest-142"><a id="_idTextAnchor289"/>Upgrade of operating system version in place</h2>&#13;
			<p>This is yet another area<a id="_idIndexMarker368"/> where all image-based deployments shine: upgrades in place.</p>&#13;
			<p>For atomic/rpm-ostree systems, all we need to do is create a new image based on a newer operating system and get that image staged in the appliance’s update repository. The appliance can download/stage the new image and will be upgraded to the new version of the operating system upon reboot.</p>&#13;
			<p>For bootc-based <a id="_idIndexMarker369"/>systems, all we need to do is base our container image upon a newer operating system base image, rebuild the container, and upload the container to the registry. When the system checks for updates, it will pull the new container and rerender itself as an upgraded system.</p>&#13;
			<p>Like I’ve said, it’s almost like these things are tailor-made for embedded Linux systems, right? Let’s move on to our hands-on exercises now an<a id="_idTextAnchor290"/>d build one for ourselves.</p>&#13;
			<h1 id="_idParaDest-143"><a id="_idTextAnchor291"/>Practical exercises</h1>&#13;
			<p>This is the<a id="_idIndexMarker370"/> time when we get to roll up our sleeves and bash the keyboard. If you follow the exercises in the order presented, at the end you will have a bootc image-based deployment ecosystem set up for yourself.</p>&#13;
			<p>Before we begin, I want to share with you some useful information. The tools for this type of infrastructure are evolving rapidly, and there is already more than one way to design, build, and deploy these images. I see this as an amazing opportunity for the Linux community. The method I am demonstrating here is simple and easy to either script or automate via something such as Ansible. Throughout the exercises, I will mention other ways or alternative tools that could enhance the developer experience and make things scale better.</p>&#13;
			<p>As these exercises require precision in the configuration files that we will be creating together, I urge extreme caution should you choose to leverage a method of cutting and pasting to rapidly create the files. It is often too easy to copy over hidden ASCII characters (or formatting characters) that will render your working configuration files utterly useless and virtually impossible to debug because when you enter your text editor you may only see a blank space (if anything). I have added templated files that you can download and tailor yourself to your own lab’s environment. They can be found in the book’s GitHub repository (<a href="https://github.com/PacktPublishing/The-Embedded-Linux-Security-Handbook/tree/main/Chapter09/exercises">https://github.com/PacktPublishing/The-Embedded-Linux-Security-Handbook/tree/main/Chapter09/exercises</a>), and they will also enlighten you about other options that we have not covered.</p>&#13;
			<p>So, grab a formattable 16 GB USB thumb drive along with your favorite beverage (maybe several), and let’s get started.</p>&#13;
			<h2 id="_idParaDest-144"><a id="_idTextAnchor292"/>Exercise 1 – preparing the environment</h2>&#13;
			<p>In this first exercise, we <a id="_idIndexMarker371"/>will install the necessary tools along with some optional tools to create our minimal bootable container image build chain. Let’s do that using the following steps:</p>&#13;
			<ol>&#13;
				<li>First, we will set up a build environment, configure our registry, and create a container that will become the basis for not just our application but our operating system as well:<pre class="source-code">&#13;
<strong class="bold">$ sudo dnf install -y containers-common crun \ </strong>&#13;
<strong class="bold">iptables netavark nftables slirp4netns \</strong>&#13;
<strong class="bold">composer-cli cockpit cockpit-composer \</strong>&#13;
<strong class="bold">skopeo buildah runc podman</strong></pre></li>				<li>Now we’ll ensure that the web console has been enabled:<pre class="source-code">&#13;
<strong class="bold">$ sudo systemctl enable cockpit.socket</strong></pre></li>				<li>And here, we’ll start the socket for the web console:<pre class="source-code">&#13;
<strong class="bold">$ sudo systemctl start cockpit.socket</strong></pre></li>				<li>Confirm the web console is active:<pre class="source-code">&#13;
<strong class="bold">$ sudo systemctl status cockpit.socket</strong></pre><p class="list-inset">Your output should resemble something like this:</p><pre class="source-code"><strong class="bold">●</strong><strong class="bold"> cockpit.socket - Cockpit Web Service Socket</strong>&#13;
<strong class="bold">     Loaded: loaded (/usr/lib/systemd/system/cockpit.socket; enabled; preset: disabled)</strong>&#13;
<strong class="bold">     Active: active (listening) since Fri 2024-08-09 12:39:24 EDT; 1 month 13 days ago</strong>&#13;
<strong class="bold">   Triggers: </strong><strong class="bold">●</strong><strong class="bold"> cockpit.service</strong>&#13;
<strong class="bold">       Docs: man:cockpit-ws(8)</strong>&#13;
<strong class="bold">     Listen: [::]:9090 (Stream)</strong>&#13;
<strong class="bold">      Tasks: 0 (limit: 38320)</strong>&#13;
<strong class="bold">     Memory: 648.0K (peak: 2.5M)</strong>&#13;
<strong class="bold">        CPU: 26ms</strong>&#13;
<strong class="bold">     CGroup: /system.slice/cockpit.socket</strong>&#13;
<strong class="bold">Aug 09 12:39:24 bm03.local systemd[1]: Starting cockpit.socket - Cockpit Web Service Socket...</strong>&#13;
<code>centos-bootc</code> repository.</li><li class="upper-roman">Click on the link for <strong class="bold">centos-bootc/centos-bootc</strong>.</li><li class="upper-roman">Make note of the URL as we’ll be using it soon. Consider bookmarking the page too.</li></ol></li>&#13;
			</ol>&#13;
			<div>&#13;
				<div>&#13;
					<img src="img/B22104_09_01.jpg" alt="Figure 9.1 – Searching for CentOS Stream’s bootc base image" width="1379" height="810"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.1 – Searching for CentOS Stream’s bootc base image</p>&#13;
			<ol>&#13;
				<li value="6">Back in <a id="_idIndexMarker373"/>your terminal, configure your non-root user account to be able to search the registry:<pre class="source-code">&#13;
<strong class="bold">$ cd ~</strong></pre></li>				<li>Create the requisite directories to store your container configuration so Podman will know where to seek for information:<pre class="source-code">&#13;
<strong class="bold">$ mkdir -p ~/.config/containers</strong></pre></li>				<li>Let’s change directories to the one we just created:<pre class="source-code">&#13;
<code>registries.conf</code> file to contain the defined contents:<pre class="source-code">&#13;
<strong class="bold">$ vi registries.conf</strong></pre><p class="list-inset">Set the file’s contents to match the following and save the file:</p><pre class="source-code"># we will use these registries only&#13;
[registries.search]&#13;
registries = ['registry.redhat.io','quay.io']</pre></li>				<li>Now, we’ll go back to our home directory:<pre class="source-code">&#13;
<strong class="bold">$ cd ~</strong></pre></li>				<li>Let’s<a id="_idIndexMarker374"/> download the CentOS Stream 9 DVD ISO image to be used later in the process when we create our custom installer. Use your web browser to go to <a href="https://centos.org/download/">https://centos.org/download/</a> and then click on the <strong class="bold">x86_64</strong> button.</li>&#13;
			</ol>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B22104_09_02.jpg" alt="Figure 9.2 – CentOS Stream 9 download" width="1075" height="914"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.2 – CentOS Stream 9 download</p>&#13;
			<ol>&#13;
				<li value="12">Let’s <a id="_idIndexMarker375"/>verify the file size and that it’s fully downloaded:<pre class="source-code">&#13;
<code>quay.io</code> via the command line. Use your own user account and the password you have previously set in order to access the <code>quay.io</code> registry:<pre class="source-code">&#13;
<strong class="bold">$ podman login quay.io</strong></pre><p class="list-inset">If the login <a id="_idIndexMarker376"/>was successful, you will receive the following message:</p><pre class="source-code"><strong class="bold">Login Succeeded!</strong></pre></li>			</ol>&#13;
			<p class="callout-heading">Important note</p>&#13;
			<p class="callout">If you opted to generate the encrypted CLI password, the <code>login</code> command should look a little different. Replace <code>[your username]</code> with your own username and <code>[encrypted pass]</code> with your long, encrypted password here:</p>&#13;
			<p class="callout"><code>$ podman login -u='[your username]' -p='[encrypted </code><code>pass]' quay.io</code></p>&#13;
			<ol>&#13;
				<li value="14">Let’s pull down our base container image:<pre class="source-code">&#13;
<strong class="bold">$ podman pull quay.io/centos-bootc/centos-bootc:stream9</strong></pre><p class="list-inset">The output for this one is astronomically long (again). Here, we’ve truncated the output to show you generally what you can expect to see:</p><pre class="source-code"><strong class="bold">((( output truncated)))</strong>&#13;
<strong class="bold">Copying blob 775d29f76a39 done   |</strong>&#13;
<strong class="bold">Copying blob 7eff373befa3 done   |</strong>&#13;
<strong class="bold">Copying blob 8c789e616763 done   |</strong>&#13;
<strong class="bold">Copying blob fd730fb4a24b done   |</strong>&#13;
<strong class="bold">Copying blob 54246c915569 done   |</strong>&#13;
<strong class="bold">Copying blob 232fb94490b0 done   |</strong>&#13;
<strong class="bold">Copying blob ad312c5c40cc done   |</strong>&#13;
<strong class="bold">Copying blob bd9ddc54bea9 done   |</strong>&#13;
<strong class="bold">Copying config a1163a9d15 done   |</strong>&#13;
<strong class="bold">Writing manifest to image destination</strong>&#13;
<strong class="bold">a1163a9d15d2f9a3f7f81748baf8fbcfc69690ed38030e770fe2006c090b0f83</strong></pre></li>				<li>Let’s check our local container inventory and verify that we have the intended CentOS Stream 9 bootc image in our inventory:<pre class="source-code">&#13;
<strong class="bold">$ podman images</strong></pre><p class="list-inset">Your output should resemble this:</p><pre class="source-code"><strong class="bold">REPOSITORY                         TAG         IMAGE ID      CREATED       SIZE</strong>&#13;
<strong class="bold">quay.io/centos-bootc/centos-bootc  stream9     a1163a9d15d2  43 hours ago  1.52 GB</strong></pre></li>				<li>Now, in<a id="_idIndexMarker377"/> the Quay.io web interface, we will create our own public repository for our container image project. We’ll start on the <strong class="bold">Repositories</strong> tab.</li>&#13;
			</ol>&#13;
			<p class="callout-heading">Important note</p>&#13;
			<p class="callout">As a simple reminder, this is not exactly how one should ever do this in production. We’ll be using a public configuration for lab purposes only. Private, secure registries are the only way I would recommend doing this deployment method while being connected to the internet.</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B22104_09_03.jpg" alt="Figure 9.3 – Quay – Repositories main page" width="1650" height="436"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.3 – Quay – Repositories main page</p>&#13;
			<ol>&#13;
				<li value="17">Next, we’ll click on the <code>bootc</code> and ensure that the <strong class="bold">Public</strong> radio button is selected along with the <strong class="bold">(Empty repository)</strong> radio button. Then, click the <strong class="bold">Create Public Repository</strong> button at the bottom.</p></li>&#13;
			</ol>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B22104_09_04.jpg" alt="Figure 9.4 – Creating a new repository in Quay" width="1205" height="946"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.4 – Creating a new repository in Quay</p>&#13;
			<p class="list-inset">Make note<a id="_idIndexMarker378"/> of the URL for your repository; we’ll be using it soon. I also recommend bookmarking it in your web browser.</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B22104_09_05.jpg" alt="Figure 9.5 – Your custom Quay repository" width="1650" height="643"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.5 – Your custom Quay repository</p>&#13;
			<p>Now, we have configured a baseline build environment on your system. By configuring how we leverage registries, installed container tools, and staged a container base image and a Linux installer<a id="_idIndexMarker379"/> ISO image, we have all we need to be successful. We additionally set up the web console on our build system, which will come in handy later. Let’s move on to building our initial container, which will be the basis <a id="_idTextAnchor293"/>for our future immutable image.</p>&#13;
			<h2 id="_idParaDest-145"><a id="_idTextAnchor294"/>Exercise 2 – creating a container file</h2>&#13;
			<p>In this exercise, we’ll create a container file that we will build using the base image we downloaded in the previous exercise. The results of this exercise will give us a container that can run a simple <strong class="bold">Linux Apache mySQL and PHP</strong> (<strong class="bold">LAMP</strong>) stack. If you decide not to type this file, there will be a prebuilt one in the book’s GitHub repository for reference.</p>&#13;
			<p>Let’s build our container:</p>&#13;
			<ol>&#13;
				<li>Let’s create the container file and name it <code>mycontainerfile.cf</code> :<pre class="source-code">&#13;
<strong class="bold">$ vi mycontainerfile.cf</strong></pre><p class="list-inset">Set the contents of the file to look like the following:</p><pre class="source-code">FROM quay.io/centos-bootc/centos-bootc:stream9&#13;
#install the lamp components&#13;
RUN dnf install -y httpd mariadb mariadb-server php-fpm php-mysqlnd &amp;&amp; dnf clean all&#13;
#start the services automatically on boot&#13;
RUN systemctl enable httpd mariadb php-fpm&#13;
#create an awe inspiring home page (all one command line)&#13;
RUN echo '&lt;h1 style="text-align:center;"&gt;Welcome to My Appliance&lt;/h1&gt; &lt;?php phpinfo(); ?&gt;' &gt;&gt; /var/www/html/index.php</pre></li>				<li>Let’s build<a id="_idIndexMarker380"/> our container image:</li>&#13;
			</ol>&#13;
			<p class="callout-heading">Important note</p>&#13;
			<p class="callout">Replace your own Quay.io username where <code>[my_account]</code> appears in the command line.</p>&#13;
			<pre class="source-code">&#13;
<strong class="bold">$ podman build -f mycontainerfile.cf -t quay.io/[my_account]/bootc/lamp-bootc:latest</strong></pre>			<p class="list-inset">The output for this one is really long too.  We’ve truncated the output somewhat to save space while still showing you what you can expect to see:</p>&#13;
			<pre class="source-code">&#13;
<strong class="bold">STEP 1/4: FROM quay.io/centos-bootc/centos-bootc:stream9</strong>&#13;
<strong class="bold">STEP 2/4: RUN dnf install -y httpd mariadb mariadb-server php-fpm php-mysqlnd &amp;&amp; dnf clean all</strong>&#13;
<strong class="bold">--&gt; Using cache a525b1bb126820c8522199f6d42b292210f06e4d178efbc148d97a92b94a64ed</strong>&#13;
<strong class="bold">--&gt; a525b1bb1268</strong>&#13;
<strong class="bold">STEP 3/4: RUN systemctl enable httpd mariadb php-fpm</strong>&#13;
<strong class="bold">--&gt; Using cache 9400a8bbc0287454ae0db9f42f9b49e518daf2b410fd3c3d0bb91a8b58e0a2a3</strong>&#13;
<strong class="bold">--&gt; 9400a8bbc028</strong>&#13;
<strong class="bold">STEP 4/4: RUN echo '&lt;h1 style="text-align:center;"&gt;Welcome to My Appliance&lt;/h1&gt; &lt;?php phpinfo(); ?&gt;' &gt;&gt; /var/www/html/index.php</strong>&#13;
<strong class="bold">--&gt; Using cache 4bcb220e3de6429f9f83264e84f064f2101c715c78e1104e388d11f6007b560e</strong>&#13;
<strong class="bold">COMMIT quay.io/matt_st_onge/bootc/lamp-bootc:latest</strong>&#13;
<strong class="bold">--&gt; 4bcb220e3de6</strong>&#13;
<strong class="bold">Successfully tagged quay.io/matt_st_onge/bootc/lamp-bootc:latest</strong>&#13;
<strong class="bold">4bcb220e3de6429f9f83264e84f064f2101c715c78e1104e388d11f6007b560e</strong></pre>			<p class="list-inset">Great! We <a id="_idIndexMarker381"/>now have our container image. Let’s do a quick test to see how well it works:</p>&#13;
			<p class="callout-heading">Important note</p>&#13;
			<p class="callout">Replace your own Quay.io username where <code>[my_account]</code> appears in the command line.</p>&#13;
			<pre class="source-code">&#13;
<strong class="bold">$ podman run -d --rm --name lamp -p 8080:80 \ </strong>&#13;
<strong class="bold">quay.io/[my_account]/bootc/lamp-bootc:latest</strong></pre>			<p class="list-inset">Your output will resemble something like this:</p>&#13;
			<pre class="source-code">&#13;
<strong class="bold">7d9c474d9dd4e6ab32d910c72775cdb111adfed764f29887c110461ca67c54a6</strong></pre>			<ol>&#13;
				<li value="3">With the container started, let’s open a browser window and verify that you can view the served content: http://[your_ip_address]:8080.<p class="list-inset">If the page<a id="_idIndexMarker382"/> doesn’t load, double-check your firewall settings. If you are on the same system where you are running the container, your loopback address should also work.</p></li>&#13;
			</ol>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B22104_09_06.jpg" alt="Figure 9.6 – Testing our container" width="1010" height="910"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.6 – Testing our container</p>&#13;
			<ol>&#13;
				<li value="4">We should now <a id="_idIndexMarker383"/>also be able to shell into the container while it’s running:<pre class="source-code">&#13;
<strong class="bold">$ podman exec -it lamp /bin/bash</strong></pre></li>				<li>When given the prompt feel free to test some commands but remember to exit:<pre class="source-code">&#13;
<strong class="bold">bash-5.1# exit</strong></pre><p class="list-inset">You will then be returned to your regular shell prompt on your system.</p></li>				<li>Stop the running container since we know that the image works:<pre class="source-code">&#13;
<code>lamp</code>.</p></li>				<li>Our final step<a id="_idIndexMarker384"/> will be saving our functional container image to your own repository within Quay.io:</li>&#13;
			</ol>&#13;
			<p class="callout-heading">Important note</p>&#13;
			<p class="callout">Log back into Quay.io via the command line if you are not logged in already.</p>&#13;
			<p class="callout">Replace your own Quay.io username where <code>[my_account]</code> appears in the command line.</p>&#13;
			<pre class="source-code">&#13;
<strong class="bold">$ podman push quay.io/[my_account]/bootc/lamp-bootc:latest</strong></pre>			<p class="list-inset">The output for this operation will be rather lengthy, so I’ll only show you the last few lines:</p>&#13;
			<pre class="source-code">&#13;
<strong class="bold">(((output truncated)))</strong>&#13;
<strong class="bold">Copying blob 7685af3680f8 skipped: already exists</strong>&#13;
<strong class="bold">Copying blob 9046686a9227 skipped: already exists</strong>&#13;
<strong class="bold">Copying blob d1c1676ee4e9 skipped: already exists</strong>&#13;
<strong class="bold">Copying blob 7a1c4a9ce068 skipped: already exists</strong>&#13;
<strong class="bold">Copying blob 0811ec9b544a done   |</strong>&#13;
<strong class="bold">Copying blob abef090ec865 done   |</strong>&#13;
<strong class="bold">Copying blob 6394663daed5 done   |</strong>&#13;
<strong class="bold">Copying blob 2daf40f13a19 skipped: already exists</strong>&#13;
<strong class="bold">Copying blob 9dad063a624b skipped: already exists</strong>&#13;
<strong class="bold">Copying config 8a4585ebc8 done   |</strong>&#13;
<strong class="bold">Writing manifest to image destination</strong></pre>			<p>Excellent! You’ve created the basis of your future operating system via the base image and layered the <a id="_idIndexMarker385"/>applications stack, all by creating a working container image. In our next exercise, we’ll create an installer so w<a id="_idTextAnchor295"/>e can deploy it as a bootable image.</p>&#13;
			<h2 id="_idParaDest-146"><a id="_idTextAnchor296"/>Exercise 3 – creating an installer</h2>&#13;
			<p>In this exercise, we will create a kickstart file and then take that kickstart along with a standard vendor-provided ISO install image and create our own custom ISO installer image for our amazing new system. This method of installation is great when you’re working in your lab or data center. Alternative methods will be necessary if you are deploying in a cloud services provider. For a great reference on how to build kickstart files, you can check out this guide: <a href="https://docs.fedoraproject.org/en-US/fedora/f36/install-guide/appendixes/Kickstart_Syntax_Reference/">https://docs.fedoraproject.org/en-US/fedora/f36/install-guide/appendixes/Kickstart_Syntax_Reference/</a>. </p>&#13;
			<p>Let’s move on to the first step of this exercise:</p>&#13;
			<ol>&#13;
				<li>In this first step, you will create a kickstart file (<code>mykickstart.ks</code>). Within this file, you will substitute your own account username, where I state <code>[you]</code>, and you’ll also be setting basic configuration for the operating system’s filesystem layout and root password. Save and exit the file when you are done. Should you choose not to type the file in its entirety, there’s an example in the book’s GitHub repository:</li>&#13;
			</ol>&#13;
			<p class="callout-heading">Important note</p>&#13;
			<p class="callout">Replace your own Quay.io username where <code>[my_account]</code> appears in the file’s contents.</p>&#13;
			<pre class="source-code">&#13;
<code>mykickstart.ks</code> look similar (with your substitutions) to<a id="_idIndexMarker386"/> this:</p>&#13;
			<pre class="source-code">&#13;
# mykickstart.ks&#13;
# version 1&#13;
# anaconda installer type&#13;
text&#13;
# ensure that you connect your device to a Ethernet network with active DHCP&#13;
network -–bootproto=dhcp -–device=link -–activate&#13;
# basic partitioning&#13;
clearpart –-all -–initlabel -–disklabel=gpt&#13;
reqpart --add-boot&#13;
part / --grow --fstype xfs&#13;
# here's where we reference the container image&#13;
# notice this kickstart has no packages section&#13;
ostreecontainer –-url quay.io/ [quay_username]/bootc/lamp-bootc:latest –-no-signature-verification&#13;
# additional settings for demonstration purposes&#13;
# in production use better settings&#13;
# the purpose of this exercise is not to tech you kickstart&#13;
# but to show how to leverage it in custom installers&#13;
firewall –-disabled&#13;
services –-enabled=sshd&#13;
# add your own user account to the system&#13;
user –-name=mstonge -–groups=wheel –-plaintext –-password=embedded&#13;
# set root password&#13;
rootpw –-plaintext embedded</pre>			<ol>&#13;
				<li value="2">Now, we<a id="_idIndexMarker387"/> will install the <code>lorax</code> software package, which will enable us to create a custom installer ISO image:<pre class="source-code">&#13;
<code>Complete</code>:</p><pre class="source-code"><strong class="bold">((( output truncated)))</strong>&#13;
<code>mkksiso</code> command, which is part of the <code>lorax</code> RPM package we just installed. This will create a custom installer for us:</li>&#13;
			</ol>&#13;
			<p class="callout-heading">Important note</p>&#13;
			<p class="callout">You will need to substitute exact paths of your own here.</p>&#13;
			<p class="callout">For example,</p>&#13;
			<p class="callout"><code>sudo mkksiso --ks /</code><code>home/mstonge/mykickstart.ks \</code></p>&#13;
			<p class="callout"><code>/</code><code>home/mstonge/CentOS-Stream-9-latest-x86_64-dvd1.iso \</code></p>&#13;
			<p class="callout"><code>/</code><code>home/mstonge/mycustominstaller.iso</code></p>&#13;
			<pre class="source-code">&#13;
<strong class="bold">$ sudo mkksiso –ks [absolute path to mykickstart.ks] \</strong>&#13;
<strong class="bold">[absolute path to the CentOS Stream 9 ISO] \</strong>&#13;
<strong class="bold">[absolute path to the new ISO you want created]</strong></pre>			<p class="list-inset">The output <a id="_idIndexMarker388"/>for this step is significantly long. I have truncated it here to prevent my editor from murdering me. The part you must pay attention to is the last line, which confirms the operation has completed successfully and that it wrote your custom ISO image:</p>&#13;
			<pre class="source-code">&#13;
<strong class="bold">     ((( output truncated)))</strong>&#13;
<strong class="bold">xorriso : UPDATE : Writing:     830548s   74.1%   fifo   0%  buf  50%  137.6xD</strong>&#13;
<strong class="bold">xorriso : UPDATE : Writing:     932628s   83.2%   fifo   0%  buf  50%  150.7xD</strong>&#13;
<strong class="bold">xorriso : UPDATE : Writing:    1007616s   89.9%   fifo  29%  buf  50%  110.7xD</strong>&#13;
<strong class="bold">xorriso : UPDATE : Writing:    1097728s   97.9%   fifo  10%  buf  50%  133.0xD</strong>&#13;
<strong class="bold">ISO image produced: 1120832 sectors</strong>&#13;
<strong class="bold">Written to medium : 1121008 sectors at LBA 48</strong>&#13;
<strong class="bold">Writing to '/home/mstonge/mycustominstaller.iso' completed successfully.</strong></pre>			<ol>&#13;
				<li value="4">Now that we <a id="_idIndexMarker389"/>have our own custom installer ISO image, let’s create boot media. For this step, you will need to use Fedora Media Writer. It should already be on your system; if not, download it first. If you need assistance downloading or installing the tool (which works on all major platforms), check out this reference link: <a href="https://docs.fedoraproject.org/en-US/fedora/latest/preparing-boot-media/#_fedora_media_writer">https://docs.fedoraproject.org/en-US/fedora/latest/preparing-boot-media/#_fedora_media_writer</a>.</li>&#13;
			</ol>&#13;
			<p class="callout-heading">Important note</p>&#13;
			<p class="callout">This step may be optional if you are working with virtual machines – you might be able just to boot from the ISO file itself within the hypervisor.</p>&#13;
			<p class="list-inset">Let’s look at how Fedora Media Writer can simplify the creation of boot media.</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B22104_09_07.jpg" alt="Figure 9.7 – Fedora Media Writer" width="633" height="443"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.7 – Fedora Media Writer</p>&#13;
			<ol>&#13;
				<li value="5">Here, you<a id="_idIndexMarker390"/> select the ISO image and the USB thumb drive that you want to commit the bootable image to.</li>&#13;
			</ol>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B22104_09_08.jpg" alt="Figure 9.8 – Choosing ISO images" width="630" height="363"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.8 – Choosing ISO images</p>&#13;
			<p class="list-inset">As the Fedora <a id="_idIndexMarker391"/>Media Writer requires elevated access, you’ll be prompted for authentication to achieve <code>sudo</code> status.</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B22104_09_09.jpg" alt="Figure 9.9 – Elevated permissions – authentication" width="857" height="560"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.9 – Elevated permissions – authentication</p>&#13;
			<p class="list-inset">It will definitely take <a id="_idIndexMarker392"/>a few minutes to render the ISO image to the physical media. Have patience, grab a beverage, and enjoy the break.</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B22104_09_10.jpg" alt="Figure 9.10 - ISO build in progress" width="629" height="513"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.10 - ISO build in progress</p>&#13;
			<p class="list-inset">Once the ISO build is <a id="_idIndexMarker393"/>completed, you’ll be greeted by this screen.</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B22104_09_11.jpg" alt="" width="643" height="523"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="IMG---Figure">Figured 9.11 – ISO image created</p>&#13;
			<p>You can now <a id="_idIndexMarker394"/>remove the thumb drive from the USB port. We’re just moments away from installation. You’ve successfully created your own custom installe<a id="_idTextAnchor297"/>r. Let’s move on and put it to good use.</p>&#13;
			<h2 id="_idParaDest-147"><a id="_idTextAnchor298"/>Exercise 4 – initial installation</h2>&#13;
			<p>In this exercise, we will install our first <strong class="bold">Image Mode system</strong> with our newly created custom installer. You will boot the test system from the newly created thumb drive (or from the ISO file we just created in the case of a virtual machine). You may need to interrupt your system’s normal boot process to get it to boot from the USB thumb drive.</p>&#13;
			<p>Sit back, relax, and watch the magic happen. Let’s move on to deploying our first system leveraging the automated installer that we just created:</p>&#13;
			<ol>&#13;
				<li>With your newly created boot media, use it to boot (or create a new virtual machine). If you are booting onto physical hardware, you need to be aware of some things before your installation:<ol><li class="upper-roman">Ensure all previous partitions are removed from the drive (especially the <strong class="bold">UEFI</strong> partition) before the installation process begins.</li><li class="upper-roman">Ensure that, within your <strong class="bold">UEFI BIOS</strong>, any previous entries for <strong class="bold">Secure Boot</strong> are removed (<strong class="bold">RESET</strong>) and that <strong class="bold">Secure Boot</strong> is set to <strong class="bold">DISABLED</strong> before the installation.</li><li class="upper-roman">Boot your<a id="_idIndexMarker395"/> system from the USB media (physical hardware) or directly from the ISO image (virtual machine). This is an automated install and it will notify you upon completion (or failure).</li></ol><p class="list-inset">Here’s what a successful text-based unattended installation looks like.</p></li>&#13;
			</ol>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B22104_09_12.jpg" alt="Figure 9.12 – Installation success!" width="1142" height="1210"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.12 – Installation success!</p>&#13;
			<ol>&#13;
				<li value="2">Once the installation<a id="_idIndexMarker396"/> is complete, test your login credentials at the console.</li>&#13;
			</ol>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B22104_09_13.jpg" alt="Figure 9.13 – First login to our new appliance" width="1210" height="544"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.13 – First login to our new appliance</p>&#13;
			<ol>&#13;
				<li value="3">Next, let’s <a id="_idIndexMarker397"/>determine the IP address of our new system:<pre class="source-code">&#13;
<strong class="bold">$ ip addr show</strong></pre><p class="list-inset">Your output should indicate that you have successfully obtained a DHCP address. Make a note of that IP address.</p></li>				<li>Now, let’s open a web browser on another machine and test the LAMP stack.<p class="list-inset">Go to the IP address that you found in the previous step.</p><p class="list-inset">Your result should look something like this:</p></li>&#13;
			</ol>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B22104_09_14.jpg" alt="Figure 9.14 – Viewing your appliance’s application" width="959" height="862"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.14 – Viewing your appliance’s application</p>&#13;
			<p>Welcome to the <a id="_idIndexMarker398"/>new world where, if you can create a container, you can build a whole system. Let’s now move <a id="_idTextAnchor299"/>on to how we update these awesome beasts.</p>&#13;
			<h2 id="_idParaDest-148"><a id="_idTextAnchor300"/>Exercise 5 – creating an updated container</h2>&#13;
			<p>In this exercise, we will make updates to our previously built container image, which will in turn provide updates to our Image Mode machine:</p>&#13;
			<ol>&#13;
				<li>Your new <a id="_idIndexMarker399"/>appliance is defined by its container image. To create an update for your appliance, all we need to do is create a new container and then publish it to our registry. In this step, we will start by creating a new container file called <code>mycontainerfile2.cf</code>:<pre class="source-code">&#13;
<strong class="bold">$ vi mycontainerfile2.cf</strong></pre><p class="list-inset">The contents of your file should look like this. Don’t forget to save the file:</p><pre class="source-code">FROM quay.io/centos-bootc/centos-bootc:stream9&#13;
RUN dnf install -y httpd mariadb mariadb-server php-fpm php-mysqlnd &amp;&amp; dnf clean all&#13;
RUN systemctl enable httpd mariadb php-fpm&#13;
# this next command is all one line although looks&#13;
# like two or more&#13;
RUN echo '&lt;h1 style="Text-align:center;"&gt;Welcome to My Appliance&lt;/h1&gt;&lt;?php phpinfo(); ?&gt;' &gt;&gt; /var/www/html/index.php&#13;
# new stuff&#13;
RUN dnf install -y cockpit&#13;
RUN systemctl enable cockpit.socket</pre></li>				<li>Build the new version of your container image:</li>&#13;
			</ol>&#13;
			<p class="callout-heading">Important note</p>&#13;
			<p class="callout">Replace your own Quay.io username where <code>[my_account]</code> appears in the command line. You may also have to log in to Quay before running this command (see <em class="italic">Exercise 1</em>, <em class="italic">step 13</em>).</p>&#13;
			<pre class="source-code">&#13;
<strong class="bold">$ podman build -f mycontainerfile2.cf -t \</strong>&#13;
<strong class="bold">quay.io/[my_account]/lamp-bootc:latest</strong></pre>			<p class="list-inset">The output for this <a id="_idIndexMarker400"/>one is significantly long. I have truncated the output in a few locations, so what we can see here is more of a short summary:</p>&#13;
			<pre class="source-code">&#13;
<strong class="bold">(((output truncated)))</strong>&#13;
<strong class="bold">Installed products updated.</strong>&#13;
<strong class="bold">Installed:</strong>&#13;
<strong class="bold">  PackageKit-1.2.6-1.el9.x86_64</strong>&#13;
<strong class="bold">  PackageKit-glib-1.2.6-1.el9.x86_64</strong>&#13;
<strong class="bold">  abattis-cantarell-fonts-0.301-4.el9.noarch</strong>&#13;
<strong class="bold">  adobe-source-code-pro-fonts-2.030.1.050-12.el9.1.noarch</strong>&#13;
<strong class="bold">((( output truncated more )))</strong>&#13;
<strong class="bold">  sscg-3.0.0-7.el9.x86_64</strong>&#13;
<strong class="bold">  tracer-common-1.1-2.el9.noarch</strong>&#13;
<strong class="bold">  udisks2-iscsi-2.9.4-11.el9.x86_64</strong>&#13;
<strong class="bold">  udisks2-lvm2-2.9.4-11.el9.x86_64</strong>&#13;
<strong class="bold">  webkit2gtk3-jsc-2.44.3-2.el9.x86_64</strong>&#13;
<strong class="bold">Complete!</strong>&#13;
<strong class="bold">--&gt; 6ab95e317a3c</strong>&#13;
<strong class="bold">STEP 6/6: RUN systemctl enable cockpit.socket</strong>&#13;
<strong class="bold">Created symlink /etc/systemd/system/sockets.target.wants/cockpit.socket → /usr/lib/systemd/system/cockpit.socket.</strong>&#13;
<strong class="bold">COMMIT quay.io/matt_st_onge/bootc/lamp-bootc:latest</strong>&#13;
<strong class="bold">--&gt; fe247cf7e89d</strong>&#13;
<strong class="bold">Successfully tagged quay.io/matt_st_onge/bootc/lamp-bootc:latest</strong>&#13;
<strong class="bold">fe247cf7e89d97d5832d889718750d63cc5f2f24dcfd5ed4cce39dfafd150778</strong></pre>			<ol>&#13;
				<li value="3">Now that you’ve rebuilt your container image, feel free to test it in the same way we did<a id="_idIndexMarker401"/> in a previous exercise, or don’t (it’s optional). We do, however, have to push this new image to our registry and set it as the latest version:</li>&#13;
			</ol>&#13;
			<p class="callout-heading">Important note</p>&#13;
			<p class="callout">Replace your own Quay.io username where <code>[my_account]</code> appears in the command line.</p>&#13;
			<pre class="source-code">&#13;
<strong class="bold">$ podman push quay.io/[my_account]/bootc/lamp-bootc:latest</strong></pre>			<p class="list-inset">The output from this command has been truncated significantly due to its length. You can expect your output to resemble this:</p>&#13;
			<pre class="source-code">&#13;
<strong class="bold">     (((output truncated)))</strong>&#13;
<strong class="bold">Copying blob ad312c5c40cc skipped: already exists</strong>&#13;
<strong class="bold">Copying blob bd9ddc54bea9 skipped: already exists</strong>&#13;
<strong class="bold">Copying blob 386e8ecea514 done   |</strong>&#13;
<strong class="bold">Copying blob 2463de35bc3e skipped: already exists</strong>&#13;
<strong class="bold">Copying blob d4cfe3c3d422 skipped: already exists</strong>&#13;
<strong class="bold">Copying blob eedcea4f81f6 done   |</strong>&#13;
<strong class="bold">Copying blob 2bca4ceb08f4 skipped: already exists</strong>&#13;
<strong class="bold">Copying config fe247cf7e8 done   |</strong>&#13;
<strong class="bold">Writing manifest to image destination</strong></pre>			<p>Wow! This is all that you have to do if you want your system to pick up an update automatically. As we are impatient creatures, let’s move on to the <a id="_idTextAnchor301"/>next exercise and force the update manually.</p>&#13;
			<h2 id="_idParaDest-149"><a id="_idTextAnchor302"/>Exercise 6 – updating your system</h2>&#13;
			<p>In this exercise, we will leverage the latest updates to the container you have created to improve and update our bootable container (bootc) machine.</p>&#13;
			<p class="callout-heading">Important note</p>&#13;
			<p class="callout">Your machine will check for updates automatically every few hours. The default time check period can be modified.</p>&#13;
			<p>Log back into the console of your appliance machine. Run the following as root:</p>&#13;
			<pre class="console">&#13;
#  /usr/bin/bootc update –-apply –-quiet</pre>			<p>Your machine will pull down its updates and reboot itself automatically.</p>&#13;
			<p>Well done! You have not only created your first bootc machine, but you have established an update mechanism and successfully updated your new machine. Congratulations!</p>&#13;
			<p>Success! You<a id="_idIndexMarker402"/> have updated your appliance by adding the web console to your image. Although you probably cannot log in as root, I hope you know that you can add additional users in the kickstart if you want to rebuild or you can add a user in your console now. Here, we only wanted to show just how easy it is to create an update. It works… gorgeously.</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B22104_09_15.jpg" alt="Figure 9.15 – Appliance is updated with new functionality" width="1452" height="839"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.15 – Appliance is updated with new functionality</p>&#13;
			<p>I hope that you have enjoyed walking through these exercises and that they have inspired thoughts as to how you could leverage this technology to build a better appliance. Additionally, I hope you continue to experiment and add to what we<a id="_idTextAnchor303"/>’ve covered in this chapter in your own lab.</p>&#13;
			<h1 id="_idParaDest-150"><a id="_idTextAnchor304"/>Summary</h1>&#13;
			<p>Thanks for sticking with me. I never said this journey would be easy. rpm-ostree has been around now for several years, but its time in the limelight has been overshadowed by bootc and bootable container images, an upcoming technology that builds upon its positive facets and the management is much simpler.</p>&#13;
			<p>In this chapter, we have done an overview of the option of deploying your Linux appliance as an immutable system. I truly believe this technology could fill an entire book itself, so I do use the term overview quite sparingly. As this does greatly enhance the security of the system, it clearly will add some additional complexity to your build and support processes. Now that you’ve been armed with the knowledge of the tools you may need, you will clearly have some homework to do to determine whether this methodology is right for your team or your product. If time permits, I highly recommend your team does additional research into the feasibility of leveraging this technology in your future solutions. I know that may be a heavy lift. So, let’s now move on to the next chapter, where we will dive deep into the art of tamper-proofing.</p>&#13;
		</div>&#13;
	</div></div></body></html>