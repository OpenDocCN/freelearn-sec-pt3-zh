<html><head></head><body>
        

                            
                    <h1 class="header-title">Uncovering Time</h1>
                
            
            
                
<p>Timestamps are stored in a wide variety of formats unique to the operating system or application responsible for their generation. In forensics, converting these timestamps can be an important aspect of an investigation.</p>
<p>As an example, we may aggregate converted timestamps and create a combined timeline of events to determine a sequence of actions across mediums. This evaluation of time can help us establish whether actions are within a defined scope and provide insights into the relationship between two events.</p>
<p>To decipher these formatted timestamps, we can use tools to interpret the raw values and convert them into human-readable time. Most forensic tools perform this operation silently as they parse known artifact structures (similarly to how our scripts often parse Unix timestamps).</p>
<p>In some cases, we don't have tools that properly or uniformly handle specific timestamps and will have to rely on our ingenuity to decipher the time value.</p>
<p class="mce-root">We'll use common libraries to interpret timestamps from user input and transform them into the desired formats. Using the TkInter library, we'll design a <strong>Graphical User Interface</strong> (<strong>GUI</strong>) that the user will interface with to display date information. We'll use a Python class to better organize our GUI and handle events such as when a user clicks a button on the GUI.</p>
<p>In this chapter, we'll build a graphic interface that converts timestamps between machine- and human-readable formats with the help of the following topics:</p>
<ul>
<li>The creation of cross-platform GUIs in Python</li>
<li>The conversion of common raw timestamp values between machine- and human-readable formats</li>
<li>The basics of Python class design and implementation, allowing the flexible addition of more time formats</li>
</ul>
<p>The code for this chapter was developed and tested using Python 2.7.15 and Python 3.7.1</p>


            

            
        
    

        

                            
                    <h1 class="header-title">About timestamps</h1>
                
            
            
                
<p>Timestamp formats often boil down to two components: a reference point and a convention or algorithm used to represent the amount of time that has passed from the said reference point. Documentation exists for most timestamps and can help us to determine the best means to convert raw time data into a human-readable timestamp. </p>
<p>As mentioned in the introduction, there is a wide array of timestamp formats, some of which we've already encountered, such as Unix time and Windows FILETIME. This makes the conversion process more difficult as the forensic scripts we develop may need to be prepared to process multiple time formats.</p>
<p>Python has several standard libraries bundled in the distribution that can help us convert timestamps. We've used the <kbd>datetime</kbd> module before to properly handle time values and store them within a Python object. We'll introduce two new libraries—<kbd>time</kbd>, which is part of the standard library, and the third-party <kbd>dateutil</kbd> module.</p>
<p>We can download and install <kbd>dateutil</kbd> (version 2.7.5) by running <kbd>pip install python-dateutil==2.7.5</kbd>. This library will be used to parse strings into <kbd>datetime</kbd> objects. The <kbd>parser()</kbd> method from the <kbd>dateutil</kbd> library takes a string as input and attempts to automatically convert it into a <kbd>datetime</kbd> object. Unlike the <kbd>strptime()</kbd> method, which requires explicit declaration of the format of the timestamp, the <kbd>dateutil.parser</kbd> converts timestamps of varying formats without requiring input from the developer.</p>
<p>An example string could be <kbd>Tuesday December 8th, 2015 at 6:04 PM</kbd> or <kbd>12/08/2015 18:04</kbd>, and both would be converted by the <kbd>parser()</kbd> method into the same <kbd>datetime</kbd> object. The following code block demonstrates this functionality, and works in both Python 2.7.15 and Python 3.7.1:</p>
<pre><strong>&gt;&gt;&gt; from dateutil import parser as duparser</strong><br/><strong>&gt;&gt;&gt; d = duparser.parse('Tuesday December 8th, 2015 at 6:04 PM')</strong><br/><strong>&gt;&gt;&gt; d.isoformat()</strong><br/><strong>'2015-12-08T18:04:00'</strong><br/><strong>&gt;&gt;&gt; d2 = duparser.parse('12/08/2015 18:04')</strong><br/><strong>&gt;&gt;&gt; d2.isoformat()</strong><br/><strong>'2015-12-08T18:04:00'</strong> </pre>
<p>On the first line of the code block, we import the <kbd>dateutil</kbd> parser and create an alias, <kbd>duparser</kbd>, as the function name parser is a generic term that could possibly collide with another variable or function. We then call the <kbd>parse()</kbd> method and pass a string representing a timestamp. Assigning this parsed value to the variable, <kbd>d</kbd>, we view its ISO format using the <kbd>isoformat()</kbd> function. We repeat these steps with a second timestamp in a different format and observe the same end result.</p>
<p>Please refer to the documentation for additional details on the <kbd>parse()</kbd> method at <a href="http://dateutil.readthedocs.org/en/latest/parser.html" target="_blank">http://dateutil.readthedocs.org/en/latest/parser.html</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">What's an epoch?</h1>
                
            
            
                
<p>An <em>epoch</em> is a point in time, marked as the origin of time for a given time format, and is usually used as a reference point to track movement through time. While we'll omit any philosophical discussion associated with measuring time, we'll use and reference an epoch as the starting point for a given time format in this chapter.</p>
<p>There're two major epoch times associated with most timestamps: <kbd>1970-01-01 00:00:00</kbd> and <kbd>1601-01-01 00:00:00</kbd>. The first, starting in 1970, is traditionally referred to as POSIX time as it's a common timestamp in Unix and Unix-like systems. In most Unix systems, timestamps are measured as seconds elapsed since POSIX time. This carries over to some applications as well, and variations exist that use milliseconds since the same epoch.</p>
<p>The second noted epoch, based in 1601, is commonly found on Windows-based systems and is used because it was the start of the first 400-year cycle of the Gregorian calendar to include leap years. The 400-year cycle starting in 1601 is the first cycle where digital files existed, and so this value became another common epoch. It's common to see Windows system timestamps as a count of 100-nanosecond segments since that epoch. This value will often be stored in hex or as an integer.</p>
<p>The next code block describes the process used to convert timestamps of different epochs. As we've seen in previous chapters, we can use the <kbd>datetime</kbd> module's <kbd>fromtimestamp()</kbd> method to convert Unix timestamps because it uses the 1970 epoch. For 1601-based timestamps, we'll need to convert them before using the <kbd>fromtimestamp()</kbd> function.</p>
<p>To make this conversion easier, let's calculate the constant between these dates and use that constant to convert between the two epochs. On the first line, we import the <kbd>datetime</kbd> library. Next, we subtract the two timestamps to determine the time delta between <kbd>1970-01-01</kbd> and <kbd>1601-01-01</kbd>. This statement produces a <kbd>datetime.timedelta</kbd> object, which stores the difference in time as a count of days, seconds, and microseconds between the two values.</p>
<p>In this instance, the difference between the 1970 and 1601 timestamps is exactly 134,774 days. We need to convert this into a microsecond timestamp to be able to accurately leverage it in our conversions. Therefore, in the third line, we convert the count of days (<kbd>time_diff.days</kbd>) into microseconds by multiplying it by <kbd>86400000000</kbd> (the product of <em>24 hours x 60 minutes x 60 seconds x 1,000,000 microseconds</em>) and print the constant value of <kbd>11644473600000000</kbd>. Take a look at the following code:</p>
<pre><strong>&gt;&gt;&gt; import datetime</strong><br/><strong>&gt;&gt;&gt; time_diff = datetime.datetime(1970,1,1) - datetime.datetime(1601,1,1)</strong><br/><strong>&gt;&gt;&gt; print (time_diff.days * 86400000000)</strong><br/><strong>11644473600000000</strong> </pre>
<p>With this value, we can convert timestamps between both epochs and properly ingest 1601-based epoch timestamps.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Using a GUI</h1>
                
            
            
                
<p>In this chapter, we'll use a GUI to convert timestamps between raw and human-readable formats. Timestamp conversion is a useful excuse to explore programming GUIs as it offers a solution to a common investigative activity. By using a GUI, we greatly increase the usability of our script among those deterred by the Command Prompt, with all of its arguments and switches.</p>
<p>There are many options for GUI development in Python, though, in this chapter, we'll focus on TkInter. The TkInter library is a cross-platform GUI development library for Python that hooks into the operating system's <kbd>Tcl</kbd>/<kbd>Tk</kbd> library found on Windows, macOS, and several Linux platforms.</p>
<p>This cross-platform framework allows us to build a common interface that's platform-independent. Although TkInter GUIs may not look the most modern, they allow us to rapidly build a functional interface to interact with, in a relatively simple manner.</p>
<p>We'll only be covering the basics of GUI development with TkInter here. Further information can be found online or in books dedicated to the topic that cover the development process and specific features related to developing with TkInter in more detail. The <a href="https://www.python.org/" target="_blank">https://www.python.org/</a> website has an extensive list of resources for learning and using TkInter at <a href="https://wiki.python.org/moin/TkInter">https://wiki.python.org/moin/TkInter</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Basics of TkInter objects</h1>
                
            
            
                
<p>We'll use a few different features of TkInter to display our GUI. The first item every TkInter GUI needs is a root window, also known as the master, which acts as the top-level parent to any other items we add to the GUI. Within this window, we'll combine several objects that allow the user to interact with our interface, such as the <kbd>Label</kbd>, <kbd>Entry</kbd>, and <kbd>Button</kbd> items:</p>
<ul>
<li>The <kbd>Label</kbd> object allows us to place text labels that cannot be edited on the interface. This allows us to add titles or provide a description for objects that indicate what should be written to or displayed in the field.</li>
<li>The <kbd>Entry</kbd> object allows the user to enter a single line of text as input to the application.</li>
<li>The <kbd>Button</kbd> object allows us to execute commands when pressed. In our case, the button will call the appropriate function to convert a timestamp of the specific format and update the interface with the returned value.</li>
</ul>
<p>Using these three features, we've already introduced all of the GUI elements needed for our interface. There're many more objects available for use and they can be found in greater detail in the TkInter documentation at <a href="https://docs.python.org/3/library/tkinter.html">https://docs.python.org/3/library/tkinter.html</a>.</p>
<p>We'll be writing our code in a way that works with both Python 2 and Python 3. For this reason, in Python 2 (for example, version 2.7.15), we'll import <kbd>Tkinter</kbd> as follows:</p>
<pre><strong>&gt;&gt;&gt; from Tkinter import *</strong></pre>
<p>For Python 3, for example, version 3.7.1, we'll instead import it as follows:</p>
<pre><strong>&gt;&gt;&gt; from tkinter import *</strong></pre>
<p>To condense this, we can instead use the <kbd>sys</kbd> module to detect the Python version and import the proper module, as shown here:</p>
<div><pre>import sys<br/>if sys.version_info[0] == 2:<br/>    from Tkinter import *<br/>elif sys.version_info[0] == 3:<br/>    from tkinter import *</pre></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Implementing the TkInter GUI</h1>
                
            
            
                
<p>This section illustrates a simple example of creating a TkInter GUI. In the first seven lines, we import the two modules we'll need to create our interface. This import method, while complex, allows us to import these two modules in a Python 2- or Python 3-specific way.</p>
<p>The first module imports all of the default objects needed for the TkInter GUI design. The <kbd>ttk</kbd> module imports the themed TkInter pack, which applies additional formatting to the interface depending on the host operating system and is a simple way to improve the overall look of our interface. In the last line, we create our root window.</p>
<p>When typed into a Python interpreter, the execution of the last line should display a blank 200 pixel × 200 pixel square window in the top-left of your screen. The dimensions and location are a default setting that can be modified. See the following code block:</p>
<pre><strong>&gt;&gt;&gt; import sys</strong><br/><strong>&gt;&gt;&gt; if sys.version_info[0] == 2:</strong><br/><strong>&gt;&gt;&gt;     from Tkinter import *</strong><br/><strong>&gt;&gt;&gt;     import ttk</strong><br/><strong>&gt;&gt;&gt; elif sys.version_info[0] == 3:</strong><br/><strong>&gt;&gt;&gt;     from tkinter import *</strong><br/><strong>&gt;&gt;&gt;     import tkinter.ttk as ttk</strong><br/><strong>&gt;&gt;&gt; root = Tk()</strong> </pre>
<p>The following screenshot displays a TkInter root window created when executing the code block on a macOS system:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-431 image-border" src="img/a0086a92-5426-4b23-b56e-a362f2462909.png" style="width:10.83em;height:11.00em;"/></p>
<p>With the root window created, we can begin to add items to the interface. A good first item is a label. In the code block mentioned later, we add a label from the themed <kbd>ttk</kbd> pack to the window:</p>
<pre><strong>&gt;&gt;&gt; first_label = ttk.Label(root, text="Hello World")</strong></pre>
<p>The <kbd>Label</kbd> parameter requires two arguments: the parent window it should be displayed on and the text to display. Additional attributes can be assigned to the label such as fonts and text size.</p>
<p>Note that, after executing the first line of the code block, the window doesn't update. Instead, we must specify how we want to display the object within the window with one of the available geometry managers.</p>
<p>TkInter uses geometry managers to determine the placement of objects within the window. There're three common managers: <kbd>grid</kbd>, <kbd>pack</kbd>, and <kbd>place</kbd>:</p>
<ul>
<li>The <kbd>grid</kbd> geometry manager places elements based on a row and column specification</li>
<li>The <kbd>pack</kbd> geometry manager is simpler and will place elements next to each other, either vertically or horizontally depending on a specified configuration</li>
<li>Finally, the <kbd>place</kbd> geometry manager uses <em>x</em> and <em>y</em> coordinates to place elements and requires the most effort to maintain and design</li>
</ul>
<p>For this example, we chose to use the <kbd>pack</kbd> method as seen on the second line of the code block. Once we describe which geometry manager to use, our interface is updated with the label:</p>
<pre><strong>&gt;&gt;&gt; first_label.pack()</strong></pre>
<p>The following screenshot reflects the addition of the label to our GUI:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-432 image-border" src="img/56703f87-63e8-455d-9545-db2801e8fd93.png" style="width:4.92em;height:2.50em;"/></p>
<p>As seen in the preceding screenshot, the root window has shrunk to fit the size of its elements. At this point, we can resize the window by dragging the edges to shrink or grow the size of the main window.</p>
<p>Let's add some space around our <kbd>Label</kbd> object. We can accomplish this by using two different techniques. The first adds padding around the <kbd>Label</kbd> object, using the <kbd>.config()</kbd> method. To add padding, we must provide a tuple of padding, in pixels, for the <em>x</em> and <em>y</em> axis.</p>
<p>In the example, we add a 10-pixel padding on both the <em>x</em> and <em>y </em>axes. When the following line is executed, it'll automatically update in the GUI since the geometry manager is already configured:</p>
<pre><strong>&gt;&gt;&gt; first_label.config(padding=(10,10))</strong> </pre>
<p>The padding is shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-433 image-border" src="img/4f642c0a-eec7-4b71-9fe7-1580d538c3a2.png" style="width:6.50em;height:4.25em;"/></p>
<p>This only adds padding around the label itself and not the entirety of the root window. To change the dimensions of the root window, we need to call the <kbd>geometry()</kbd> method and provide the width, height, position from the left of the screen, and position from the top of the screen.</p>
<p>In the following example, we'll set the dimensions to 200 pixels wide by 100 pixels high with an offset 30 pixels from the left of the screen and 60 pixels from the top of the screen:</p>
<pre><strong>&gt;&gt;&gt; root.geometry('200x100+30+60')</strong> </pre>
<p>The new resolution of the GUI is displayed in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-434 image-border" src="img/5eb7c94c-cbb8-4383-a1bb-fda167e633bc.png" style="width:16.25em;height:7.33em;"/></p>
<p>Depending on your operating system, the default colors within the GUI may vary due to the available theme packs.</p>
<p>Let's introduce the other two GUI elements we'll use, <kbd>Entry</kbd> and <kbd>Button</kbd>. We'll now initialize the <kbd>Entry</kbd> object, which will allow a user to enter text that we can capture and use in the program. In the first line, we initialize a <kbd>StringVar()</kbd> variable, which we'll use with the <kbd>Entry</kbd> object. Unlike prior scripts, we need to set up special variables that can respond to the event-driven nature of GUI interfaces:</p>
<pre><strong>&gt;&gt;&gt; text = StringVar()</strong></pre>
<p>TkInter supports a variety of special variables such as the <kbd>StringVar()</kbd> function for strings, <kbd>BooleanVar()</kbd> for Booleans, <kbd>DoubleVar()</kbd> for floats, and <kbd>IntVar()</kbd> for integers. Each of these objects allows for values to be set using the <kbd>set()</kbd> method and retrieved using the <kbd>get()</kbd> method. The preceding code shows the initialization of the <kbd>StringVar()</kbd>, setting it to a default value, assigning it to a created <kbd>Entry</kbd> element, and packing it into the root window. Finally, we can gather the input from the user via the <kbd>get()</kbd> method:</p>
<pre><strong>&gt;&gt;&gt; text.set("Enter Text Here")</strong><br/><strong>&gt;&gt;&gt; text_entry = ttk.Entry(root, textvariable=text)</strong><br/><strong>&gt;&gt;&gt; text_entry.pack()</strong><br/><strong>&gt;&gt;&gt; text.get()</strong><br/><strong>'Hello World!'</strong> </pre>
<p>The following two consecutive screenshots show the updates to the GUI with the new code block we've implemented:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-435 image-border" src="img/b04742d7-c0c7-40c1-a53e-af9e54bc8f45.png" style="width:14.75em;height:8.25em;"/></p>
<p>The preceding screenshot shows the default text in the <kbd>Entry</kbd> box, whereas the following screenshot shows what it looks like with modified values:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-436 image-border" src="img/a7d2b484-88fd-4073-8c3f-bfe05ce16828.png" style="width:14.42em;height:8.08em;"/></p>
<p>Please note that we wrote <kbd>Hello World!</kbd> into the <kbd>Entry</kbd> object before executing the <kbd>text.get()</kbd> method.</p>
<p>The <kbd>Button</kbd> object is used to initiate an event when the button is clicked. To set an action into motion, we need a function to call.</p>
<p>In the next example, we define the <kbd>clicked()</kbd> function, which prints a string as seen in the following code block. After this function, we define the button using the <kbd>ttk</kbd> theme pack, setting the button text to <kbd>Go</kbd> and the <kbd>command</kbd> parameter of the function name. After packing the button into the root window, we can click on it and see the statement printed in the Terminal, as seen on the last line of our following code block. Although this functionality isn't very useful, it demonstrates how a button calls an action. Our script will demonstrate further uses for the <kbd>Button</kbd> object and its command parameter:</p>
<pre><strong>&gt;&gt;&gt; def clicked(): 
...     print "The button was clicked!" 
...  
&gt;&gt;&gt; go = ttk.Button(root, text="Go", command=clicked) 
&gt;&gt;&gt; go.pack() 
The button was clicked!</strong> </pre>
<p>The addition of this button is shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-439 image-border" src="img/f2fb6d53-b7d4-447c-b330-e65f5996d548.png" style="width:15.25em;height:8.83em;"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Using frame objects</h1>
                
            
            
                
<p>TkInter provides another object we'll use named <kbd>frame</kbd>. Frames are containers we can place information in and that and provide additional organization. We'll have two frames in our final interface. The first is an input frame containing all of the objects that a user will interact with, and the second is our output frame that will display all of the information processed by the script. In the final code of this chapter, the two <kbd>frame</kbd> objects will be children to the root window and act as parents to the <kbd>Label</kbd>, <kbd>Entry</kbd>, and/or <kbd>Button</kbd> objects within them.</p>
<p>Another benefit of the <kbd>frame</kbd> object is that each one can use its own geometry manager. Since each parent object can use only a single geometry manager, this allows us to leverage several different managers within our overall GUI.</p>
<p>In our script, we'll use the <kbd>pack()</kbd> manager to organize the frames in the root window and the <kbd>grid()</kbd> manager to organize elements within each frame.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Using classes in TkInter</h1>
                
            
            
                
<p>We're yet to directly use classes in this book; however, it's the preferred way to design a GUI. A class allows us to build an object that can hold functions and attributes. In fact, we've often used classes without knowing it. Objects we're familiar with, such as <kbd>datetime</kbd> objects, are classes that contain functions and attributes available to them.</p>
<p>Classes, despite not being featured heavily in this book, may confuse new developers but are recommended for more advanced scripts. We'll briefly cover classes in this chapter and recommend further research into classes as your understanding of Python grows. The items we cover with classes are specific to the GUI example in this chapter.</p>
<p>A class is defined with a similar syntax to a function, where we use the <kbd>class</kbd> keyword in lieu of <kbd>def</kbd>. Once defined, we nest functions inside the <kbd>constructor</kbd> class to make these functions callable from a <kbd>class</kbd> object. These nested functions are called methods and are synonymous with the methods we have called from libraries. A method allows us to execute code just like a function. We have primarily, up to this point, used the terms method and function interchangeably. We apologize; this was done so as to not bore you and ourselves with the same word over and over again.</p>
<p>So far, classes sound like nothing more than a collection of functions. So what gives? The true value of a class is that we can create multiple instances of the same class and assign separate values to each instance. To further extend this, we can run our predefined methods on each instance separately. Say, for example, we have a time class where each time has an associated <kbd>datetime</kbd> variable. Some of these we may decide to convert into UTC while leaving others in their current time zone. This isolation is what makes designing code within a class valuable.</p>
<p>Classes are great for GUI design because they allow us to pass values across functions without additional duplicative arguments. This is accomplished with the <kbd>self</kbd> keyword, which allows us to specify values within a class that're portable within the class instance and all of its methods.</p>
<p>In the next example, we create a class, named <kbd>SampleClass</kbd>, which inherits from the object. This is the basic setup for a class definition, and while there are more parameters available, we'll focus on the basics for this chapter. On line 2, we define our first method named, <kbd>__init__()</kbd>, which is a special function. You may notice that it has double leading and trailing underscores like the <kbd>if __name__ == '__main__'</kbd> statements we have created in our scripts. If an <kbd>__init__()</kbd> method exists within a class, it'll be executed at the initialization of the class.</p>
<p>In the example, we define the <kbd>__init__()</kbd> method, passing <kbd>self</kbd> and <kbd>init_cost</kbd> as arguments. The <kbd>self</kbd> argument must be the first argument of any method and allows us to reference the values stored under the keyword, <kbd>self</kbd>. Following this, <kbd>init_cost</kbd> is a variable that must be set when the class is first called by the user. On line 3, we assign the value of the user-provided <kbd>init_cost</kbd> to <kbd>self.cost</kbd>. It's a convention to assign arguments (besides <kbd>self</kbd>) for class instantiation into class variables. On line 4, we define the second method, <kbd>number_of_nickels()</kbd>, and pass the <kbd>self</kbd> value as its only argument. On line 5, we complete the class by returning an integer of <kbd>self.cost * 20</kbd>, as shown:</p>
<pre><strong>&gt;&gt;&gt; class SampleClass(object):</strong><br/><strong>...     def __init__(self, init_cost):</strong><br/><strong>...         self.cost = init_cost</strong><br/><strong>...     def number_of_nickels(self):</strong><br/><strong>...         return int(self.cost * 20)</strong><br/><strong>...</strong> </pre>
<p>Next, we initialize <kbd>s1</kbd> as an instance of our <kbd>SampleClass</kbd> class with the initial value of <kbd>24.60</kbd>. Then, we call its value by using the <kbd>s1.cost</kbd> attribute. The <kbd>s1</kbd> variable refers to an instance of <kbd>SampleClass</kbd> and grants us access to the methods and values within the class. We call the <kbd>number_of_nickels()</kbd> method on <kbd>s1</kbd> and change its stored value to <kbd>15</kbd>, which updates the results of the <kbd>number_of_nickels()</kbd> method. Next, we define <kbd>s2</kbd> and assign a different value to it. Even though we run the same methods, we're only able to view the data in relation to the specific class instance:</p>
<pre>&gt;&gt;&gt; s1 = SampleClass(24.60)<br/>&gt;&gt;&gt; s1.cost<br/>24.6<br/>&gt;&gt;&gt; s1.number_of_nickels()<br/>492<br/>&gt;&gt;&gt; s1.cost = 15<br/>&gt;&gt;&gt; s1.number_of_nickels()<br/>300<br/>&gt;&gt;&gt; s2 = SampleClass(10)<br/>&gt;&gt;&gt; s2.number_of_nickels()<br/>200 </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Developing the date decoder GUI – date_decoder.py</h1>
                
            
            
                
<p>This script was tested in both Python 2.7.15 and 3.7.1 and uses the python-dateutil (version 2.7.5) third-party library which can be installed with <kbd>pip</kbd> like so: </p>
<ul>
<li><kbd>pip install python-dateutil==2.7.5</kbd></li>
</ul>
<p>After this introduction to timestamps, GUI development, and Python classes, let's begin developing our <kbd>date_decoder.py</kbd> script. We'll design a GUI with two primary functionalities that the end user will interact with.</p>
<p>First, the GUI allows the user to enter a timestamp from an artifact in native format and convert it into a human-readable time. The second feature allows the user to enter a human-readable timestamp and select an option to convert it into the respective machine time. To build this, we'll use an entry box, several labels, and different types of button for the user to interact with the interface.</p>
<p>All dates processed with this code assume local machine time for the time zone. Please ensure you convert all timestamp sources into a uniform time zone to simplify the analysis.</p>
<p>As with our other scripts, this code starts with our import statements followed by authorship details. After importing <kbd>datetime</kbd> and <kbd>logging</kbd>, we import TkInter and theme resource modules using our Python 2 and Python 3 conditional. We then import <kbd>dateutil</kbd>, which, as discussed, will handle date interpretation and conversion operations. We then set up our script license, documentation, and logging values:</p>
<pre>001 """Example usage of Tkinter to convert dates."""<br/>002 import datetime<br/>003 import logging<br/>004 import sys<br/>005 if sys.version_info[0] == 2:<br/>006     from Tkinter import *<br/>007     import ttk<br/>008 elif sys.version_info[0] == 3:<br/>009     from tkinter import *<br/>010     import tkinter.ttk as ttk<br/>011 from dateutil import parser as duparser<br/>...<br/>042 __authors__ = ["Chapin Bryce", "Preston Miller"]<br/>043 __date__ = 20181027<br/>044 __description__ = '''This script uses a GUI to show date values<br/>045     interpreted by common timestamp formats'''<br/>046 logger = logging.getLogger(__name__)</pre>
<p>We begin by defining the properties of our GUI, such as the dimensions, background, and title of the window, and create the root window. After configuring the base of the GUI, we populate our GUI with the desired widgets we've discussed. Once we've designed the interface, we create methods to handle events, such as converting timestamps and showing the results in the GUI. Instead of our typical <kbd>main()</kbd> functions, we instead create an instance of this class that'll launch the GUI window when executed.</p>
<p>Our code starts with the declaration of our <kbd>DateDecoder</kbd> class and its <kbd>__init__()</kbd> method. This method doesn't require any parameters to be passed by the user since we'll be accepting all of our input values and settings through the GUI. The next function we define will be our <kbd>run()</kbd> controller on line 74. This controller calls functions that design the GUI and then launches the said GUI:</p>
<pre>049 class DateDecoder(object):<br/>...<br/>054     def __init__():<br/>...<br/>074     def run():</pre>
<p>To display the GUI in a structured manner, we need to divide our GUI into functional units. With the methods on lines 84 and 119, we create our input and output frames that make up our GUI. These frames contain widgets pertinent to their action and are governed by their own geometry:</p>
<pre>084     def build_input_frame():<br/>...<br/>119     def build_output_frame():</pre>
<p>With the design of our interface established, we can focus on the functions that handle logic operations and events when buttons are clicked. The <kbd>convert()</kbd> method is used to call timestamp converters to interpret the value as a date.</p>
<p>These converters are specific to each of the supported timestamps and are defined on lines 175, 203, and 239. Our last class method, <kbd>output()</kbd>, is used to update the interface. This may be misleading as the previous <kbd>output()</kbd> functions in our scripts have generally created some kind of report. In this case, we'll be using our output function to update the GUI with our results, to display the information to the user in an organized and helpful manner:</p>
<pre>151     def convert():<br/>...<br/>175     def convert_unix_seconds():<br/>...<br/>203     def convert_win_filetime_64():<br/>...<br/>239     def convert_chrome_time():<br/>...<br/>183     def output():</pre>
<p>Unlike in previous chapters, this function has no need to handle command-line arguments. We do, however, still set up logging and then instantiate and run our GUI. In addition, starting on line 202, we initialize a logger using our basic logging convention. We hard-code the path to the log file as no command-line arguments are passed to this script. On lines 211 and 212, the class is initialized and then the <kbd>run()</kbd> method is called in order for our GUI to be created and displayed to the user, as follows:</p>
<pre>286 if __name__ == '__main__':<br/>287     """<br/>288     This statement is used to initialize the GUI. No<br/>289     arguments needed as it's a graphic interface<br/>290     """<br/>291     # Initialize Logging<br/>292     log_path = 'date_decoder.log'<br/>293 <br/>294     logger.setLevel(logging.DEBUG)<br/>295     msg_fmt = logging.Formatter("%(asctime)-15s %(funcName)-20s"<br/>296         "%(levelname)-8s %(message)s")<br/>297     fhndl = logging.FileHandler(log_path, mode='a')<br/>298     fhndl.setFormatter(fmt=msg_fmt)<br/>299     logger.addHandler(fhndl)<br/>300 <br/>301     logger.info('Starting Date Decoder v. {}'.format(__date__))<br/>302     logger.debug('System ' + sys.platform)<br/>303     logger.debug('Version ' + sys.version.replace("\n", " "))<br/>304 <br/>305     # Create Instance and run the GUI<br/>306     dd = DateDecoder()<br/>307     dd.run()</pre>
<p>We've split our flowchart into two screenshots, due to its width. The first screenshot shows the flow for setting up the <kbd>DateDecoder</kbd> class and the initial <kbd>run()</kbd> call, which creates our frames:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-440 image-border" src="img/8c62754e-4882-4165-86cb-6b51cd050f3b.png" style="width:35.67em;height:22.83em;"/></p>
<p>The second screenshot displays the flow for the operational code, where our converter function calls the specific time-converting function and then our <kbd>output()</kbd> function to display it to the user:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-441 image-border" src="img/c1d70252-399a-49d3-b824-6e25463917ac.png" style="width:97.25em;height:32.83em;"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">The DateDecoder class setup and __init__() method</h1>
                
            
            
                
<p>We initialize our class using the <kbd>class</kbd> keyword, followed by the class name, and passing the <kbd>object</kbd> argument as seen on line 49. It's best practice to name classes using the camelCase convention and methods with underscores to prevent confusion. On line 50, we define the <kbd>__init__()</kbd> special method described earlier with only the <kbd>self</kbd> parameter. This class doesn't require any user input at initialization, so we don't need to concern ourselves with adding additional arguments. Take a look at the following code:</p>
<pre>049 class DateDecoder(object):<br/>050     """<br/>051     The DateDecoder class handles the construction of the GUI<br/>052     and the processing of date &amp; time values<br/>053     """<br/>054     def __init__(self):<br/>055         """<br/>056         The __init__ method initializes the root GUI window and<br/>057         variable used in the script<br/>058         """</pre>
<p>On line 60, we create the root window of the GUI and assign it to a value within the <kbd>self</kbd> object. This allows us to reference it and any other object created with <kbd>self</kbd> in other methods within the class without needing to pass it as an argument, since the <kbd>self</kbd> parameter stores values for use throughout the class instance. On line 61, we define the size of the window as 500 pixels wide, 180 pixels high, and offset by 40 pixels on both the top and left sides of the screen.</p>
<p>To improve the look of the interface, we've added the background color to reflect the theme shown on macOS, though this can be set to any hexadecimal color as seen on line 62. Finally, we modify the title property of the root, giving it a name that displays on top of the GUI's window:</p>
<pre>059         # Init root window<br/>060         self.root = Tk()<br/>061         self.root.geometry("500x180+40+40")<br/>062         self.root.config(background = '#ECECEC')<br/>063         self.root.title('Date Decoder')</pre>
<p>After the initial GUI definition, we need to set the base values for important variables. While this isn't required, it's often best practice to create shared values in the <kbd>__init__()</kbd> method and define them with default values. After we define three class variables that will store our processed time values, we also define the epoch constants for 1601- and 1970-based timestamps. The code is as follows:</p>
<pre>065         # Init time values<br/>066         self.processed_unix_seconds = None<br/>067         self.processed_windows_filetime_64 = None<br/>068         self.processed_chrome_time = None<br/>069 <br/>070         # Set Constant Epoch Offset<br/>071         self.epoch_1601 = 11644473600000000<br/>072         self.epoch_1970 = datetime.datetime(1970,1,1)</pre>
<p>The <kbd>__init__()</kbd> method should be used to initialize of class attributes. In some situations, you may want this class to also run the primary operations of the class, but we'll not be implementing that functionality in our code. We separate the runtime operations into a new method named <kbd>run()</kbd> to allow us to start operations specific to running the main code. This allows users to change class configuration information before launching GUI.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Executing the run() method</h1>
                
            
            
                
<p>The following method is very short, consisting of function calls to other methods we'll discuss shortly. This includes building the input and output frames for the GUI and starting the main event listener loop. Because the class has already initialized the variables found in the <kbd>__init__()</kbd> method, we can reference these objects in a safe manner as follows:</p>
<pre>074     def run(self):<br/>075         """<br/>076         The run method calls appropriate methods to build the<br/>077         GUI and set's the event listener loop.<br/>078         """<br/>079         logger.info('Launching GUI')<br/>080         self.build_input_frame()<br/>081         self.build_output_frame()<br/>082         self.root.mainloop() </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Implementing the build_input_frame() method</h1>
                
            
            
                
<p>The <kbd>build_input_frame()</kbd> method is the first instance of the <kbd>frame</kbd> widget and is defined on lines 90 through 92. In a similar manner to how we defined this element in an earlier example, we call the themed <kbd>frame</kbd> widget and pass the <kbd>self.root</kbd> object as the parent window for this frame. On line 91, we add <kbd>30</kbd> pixels of padding along the <em>x </em>axis around the frame before using the <kbd>pack()</kbd> geometry manager on line 92. Because we can only use one geometry manager per window or frame, we must now use the <kbd>pack()</kbd> manager on any additional frames or widgets added to the <kbd>root</kbd> object:</p>
<pre>084     def build_input_frame(self):<br/>085         """<br/>086         The build_input_frame method builds the interface for<br/>087         the input frame<br/>088         """<br/>089         # Frame Init<br/>090         self.input_frame = ttk.Frame(self.root)<br/>091         self.input_frame.config(padding = (30,0))<br/>092         self.input_frame.pack()</pre>
<p>After creating the frame, we begin to add widgets to the frame for the user input. On line 95, we create a label using the new <kbd>input_frame</kbd> as the parent, with the text, <kbd>Enter Time Value</kbd>. This label is placed on the first row and column of the grid. With the grid manager, the first location will be the top-left location and all other elements will fit around it. Because we don't have any need to call this label at a later point, we don't assign it to a variable and can call the <kbd>.grid()</kbd> method immediately to add it to our GUI:</p>
<pre>094         # Input Value<br/>095         ttk.Label(self.input_frame,<br/>096             text="Enter Time Value").grid(row=0, column=0)</pre>
<p>On line 98, we initialize <kbd>StringVar()</kbd>, which we use to store the input from the user as a string. We'll need to reference this object and information throughout our code, so we'll want this to be assigned to the object, <kbd>self.input_time</kbd>.</p>
<p>On line 99 we create another widget, this time <kbd>Entry</kbd>, and once again will not assign it to a variable since we'll not need to manipulate this element after creation. The information we'll need from this element will be stored in the <kbd>self.input_time</kbd> variable. To instruct the <kbd>Entry</kbd> object to store the values in this object, we must pass the object name as the <kbd>textvariable</kbd> parameter. We also specify the width of the field as 25 characters, add it to the GUI with the <kbd>grid()</kbd> call, and place it one column over from the label:</p>
<pre>098         self.input_time = StringVar()<br/>099         ttk.Entry(self.input_frame, textvariable=self.input_time,<br/>100             width=25).grid(row=0, column=1, padx=5)</pre>
<p>Following the creation of the input area, we must provide the user with options for specifying the input type. This allows the user to select whether the source is a machine-readable or human-readable format. We create another <kbd>StringVar()</kbd> variable to hold the value of the user's selection.</p>
<p>Since we want the default action to convert raw timestamps into formatted ones, we call the <kbd>set()</kbd> method on the <kbd>self.time_type</kbd> variable on line 104 to auto-select the <kbd>raw</kbd> radio button created on line 106.</p>
<p>On line 106, we create the first radio button, passing the input frame as the parent, the radio button label set to <kbd>Raw Value</kbd>, and the variable that'll reflect whether the user has selected the radio button or not to <kbd>self.time_type</kbd>. Finally, we display this button using the grid manager. On line 110, we create the second radio button whose text and value are set to reflect the formatted timestamp input. In addition, we place this radio button on the same row in the adjacent column as the first radio button. Take a look at the following code:</p>
<pre>102         # Radiobuttons<br/>103         self.time_type = StringVar()<br/>104         self.time_type.set('raw')<br/>105 <br/>106         ttk.Radiobutton(self.input_frame, text="Raw Value",<br/>107             variable=self.time_type, value="raw").grid(row=1,<br/>108                 column=0, padx=5)<br/>109 <br/>110         ttk.Radiobutton(self.input_frame, text="Formatted Value",<br/>111             variable=self.time_type, value="formatted").grid(<br/>112                 row=1, column=1, padx=5)</pre>
<p>Finally, we build the button used to submit the data from the <kbd>Entry</kbd> field for processing. This button setup is similar to the other widgets with the addition of the command keyword, which, when clicked, executes the specified method. We then assign the <kbd>convert()</kbd> method as the button click action.</p>
<p>This method is started without any additional arguments supplied, as they're stored within the <kbd>self</kbd> property. We add this element to the interface via the grid manager, using the <kbd>columnspan</kbd> attribute to have the information spread across two or more columns. We also use the <kbd>pady</kbd> (pad <em>y</em>) attribute to provide some vertical space between the input field and the button:</p>
<pre>114         # Button<br/>115         ttk.Button(self.input_frame, text="Run",<br/>116             command=self.convert).grid(<br/>117                 row=2, columnspan=2, pady=5)</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating the build_output_frame() method</h1>
                
            
            
                
<p>The output frame design is similar to that of the input frame. One difference is that we'll need to save the widgets to variables to ensure that we can update them as we process date values. After the definition of the method and docstring, we create <kbd>output_frame</kbd> and configure the height and width of the frame. Because we used the <kbd>pack()</kbd> manager for the root, we must continue to use it to add this frame to the root windows of the GUI:</p>
<pre>119     def build_output_frame(self):<br/>120         """<br/>121         The build_output_frame method builds the interface for<br/>122         the output frame<br/>123         """<br/>124         # Output Frame Init<br/>125         self.output_frame = ttk.Frame(self.root)<br/>126         self.output_frame.config(height=300, width=500)<br/>127         self.output_frame.pack()</pre>
<p>After initialization, we add various widgets to <kbd>output_frame</kbd>. All of the output widgets are labels as they allow us to easily display a string value to the user without additional overhead. Another method for accomplishing this task would be to place the output in text entry boxes and mark them as read-only. Alternatively, we could create a single large text area for easy copying by the user. Both of these are challenges specified at the end of this chapter for additional experimentation on your own GUI implementation.</p>
<p>The first label element is titled <kbd>Conversion Results</kbd>, and is centered using the <kbd>pack(fill=X)</kbd> method on line 134. This fills the area along the <em>x </em>axis and stacks all packed sibling elements vertically. After creating the label on line 131, we configure the font size using the <kbd>config()</kbd> method and pass a tuple to the <kbd>font</kbd> keyword. This argument expects the first element to be a font name and the second a font size. By omitting the font name, we leave it as the default and modify only the size:</p>
<pre>129         # Output Area<br/>130         ## Label for area<br/>131         self.output_label = ttk.Label(self.output_frame,<br/>132             text="Conversion Results")<br/>133         self.output_label.config(font=("", 16))<br/>134         self.output_label.pack(fill=X)</pre>
<p>The following three labels represent the results for each of the supported timestamps. All three use the output frame as their parent window and set their text to reflect the timestamp type and the default <kbd>N/A</kbd> value. Finally, each of the labels calls the <kbd>pack(fill=X)</kbd> method to properly center and stack the values within the frame. We must assign these three labels to variables so we can update their values to reflect the converted timestamps after processing. The labels are set here:</p>
<pre>136         ## For Unix Seconds Timestamps<br/>137         self.unix_sec = ttk.Label(self.output_frame,<br/>138             text="Unix Seconds: N/A")<br/>139         self.unix_sec.pack(fill=X)<br/>140 <br/>141         ## For Windows FILETIME 64 Timestamps<br/>142         self.win_ft_64 = ttk.Label(self.output_frame,<br/>143             text="Windows FILETIME 64: N/A")<br/>144         self.win_ft_64.pack(fill=X)<br/>145 <br/>146         ## For Chrome Timestamps<br/>147         self.google_chrome = ttk.Label(self.output_frame,<br/>148             text="Google Chrome: N/A")<br/>149         self.google_chrome.pack(fill=X)</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Building the convert() method</h1>
                
            
            
                
<p>Once the user clicks on the button in the input frame, the <kbd>convert()</kbd> method is called. This method is responsible for validating the input, calling the converters, and writing the results to the labels built in the previous section. This method, if you will, replaces what would usually be our <kbd>main()</kbd> method. After the initial definition and docstring, we log the timestamp and format (raw or formatted) provided by the user. This helps keep track of any activity and troubleshoot any errors that may occur:</p>
<pre>151     def convert(self):<br/>152         """<br/>153         The convert method handles the event when the button is<br/>154         pushed. It calls to the converters and updates the<br/>155         labels with new output.<br/>156         """<br/>157         logger.info('Processing Timestamp: {}'.format(<br/>158             self.input_time.get()))<br/>159         logger.info('Input Time Format: {}'.format(<br/>160             self.time_type.get()))</pre>
<p>First, on lines 163 through 165, we reset the values of the three timestamp variables to <kbd>N/A</kbd> to clear any residual values when the application is run again. We then call the three methods that handle the timestamp conversion on lines 168 through 170. These methods are independent and will update the values for the three timestamp parameters without us needing to return any values or pass arguments.</p>
<p>As you can see, the <kbd>self</kbd> keyword really helps to make classes simple by providing access to shared class variables. On line 173, we call the <kbd>output()</kbd> method to write the newly converted formats to the GUI:</p>
<pre>162         # Init values every instance<br/>163         self.processed_unix_seconds = 'N/A'<br/>164         self.processed_windows_filetime_64 = 'N/A'<br/>165         self.processed_chrome_time = 'N/A'<br/>166 <br/>167         # Use this to call converters<br/>168         self.convert_unix_seconds()<br/>169         self.convert_win_filetime_64()<br/>170         self.convert_chrome_time()<br/>171 <br/>172         # Update labels<br/>173         self.output()</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Defining the convert_unix_seconds() method</h1>
                
            
            
                
<p>The Unix timestamp is the most straightforward of the three timestamps that we'll convert in this chapter. On lines 175 through 179, we define the method and its docstrings before stepping into an <kbd>if</kbd> statement. The <kbd>if</kbd> statement on line 180 evaluates whether the value of the radio button described earlier is equal to the <kbd>raw</kbd> string or <kbd>formatted</kbd>. If it's set to <kbd>raw</kbd>, we'll parse the timestamp as a count of seconds since <kbd>1970-01-01 00:00:00.0000000</kbd>. This is relatively simple because this is the epoch used by the <kbd>datetime.datetime.fromtimestamp()</kbd> method. In this case, we only have to convert the input into a float as seen on lines 182 and 183 before conversion.</p>
<p>Afterward, on lines 183 and 184, we format the newly formed <kbd>datetime</kbd> object as a string in the <kbd>YYYY-MM-DD HH:MM:SS</kbd> format. The logic on line 182 is wrapped in a try-except statement to catch any bugs and report them to the log file and to the user interface in a simplified form. This allows us to test each formula when a date is entered. Line 188 outlines that the conversion error will be displayed when we are unsuccessful in converting the timestamp. This will alert the user that there was an error and allow them to determine whether it's anticipated or not:</p>
<pre>175     def convert_unix_seconds(self):<br/>176         """<br/>177         The convert_unix_seconds method handles the conversion of<br/>178         timestamps per the Unix seconds format<br/>179         """<br/>180         if self.time_type.get() == 'raw':<br/>181             try:<br/>182                 dt_val = datetime.datetime.fromtimestamp(<br/>183                     float(self.input_time.get())).strftime(<br/>184                         '%Y-%m-%d %H:%M:%S')<br/>185                 self.processed_unix_seconds = dt_val<br/>186             except Exception as e:<br/>187                 logger.error(str(type(e)) + "," + str(e))<br/>188                 self.processed_unix_seconds = str(<br/>189                     type(e).__name__)</pre>
<p>If the timestamp is a formatted value, we need to first parse the input before attempting to convert it into a Unix timestamp, as it may not follow the intended format. Once converted by <kbd>dateutil.parser</kbd>, we can use the predefined epoch object to calculate the delta in seconds between the timestamp and epoch on lines 195 through 197. If an error occurs, it will be caught as in the prior <kbd>if</kbd> statement, logged, and displayed to the user, as follows:</p>
<pre>191         elif self.time_type.get() == 'formatted':<br/>192             try:<br/>193                 converted_time = duparser.parse(<br/>194                     self.input_time.get())<br/>195                 self.processed_unix_seconds = str(<br/>196                         (converted_time - self.epoch_1970<br/>197                     ).total_seconds())<br/>198             except Exception as e:<br/>199                 logger.error(str(type(e)) + "," + str(e))<br/>200                 self.processed_unix_seconds = str(<br/>201                     type(e).__name__)</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Conversion using the convert_win_filetime_64() method</h1>
                
            
            
                
<p>The conversion of Microsoft Windows FILETIME values is a little more complicated as it uses the <kbd>1601-01-01 00:00:00</kbd> value for epoch and counts time since then in 100-nanosecond blocks. To properly convert this timestamp, we have to take a few extra steps over the previous section.</p>
<p>This method starts the same as the last, including the <kbd>if</kbd>-<kbd>else</kbd> syntax to identify the timestamp type. If it's a raw format, we must convert the input from a hexadecimal string into a base 10 decimal using the <kbd>int(value, 16)</kbd> typecast seen on lines 210 and 211. This allows us to tell <kbd>int()</kbd> to convert a base 16 value into decimal (base 10). Base 16 values are often referred to as hexadecimal values.</p>
<p>Once converted, the integer is a count of 100-nanosecond groups since the epoch so all we have to do is convert the microseconds into a <kbd>datetime</kbd> value then add the epoch <kbd>datetime</kbd> object. On lines 212 through 214, we use the <kbd>datetime.timedelta()</kbd> method to generate an object that can be used to add to the epoch <kbd>datetime</kbd>. Once the conversion is complete, we need to format the <kbd>datetime</kbd> object as a time string and assign it to the corresponding label. The error handling is the same as the prior converter and will display conversion errors as follows:</p>
<pre>203     def convert_win_filetime_64(self):<br/>204         """<br/>205         The convert_win_filetime_64 method handles the<br/>206         conversion of timestamps per the Windows FILETIME format<br/>207         """<br/>208         if self.time_type.get() == 'raw':<br/>209             try:<br/>210                 base10_microseconds = int(<br/>211                     self.input_time.get(), 16) / 10<br/>212                 datetime_obj = datetime.datetime(1601,1,1) + \<br/>213                     datetime.timedelta(<br/>214                         microseconds=base10_microseconds)<br/>215                 dt_val = datetime_obj.strftime(<br/>216                     '%Y-%m-%d %H:%M:%S.%f')<br/>217                 self.processed_windows_filetime_64 = dt_val<br/>218             except Exception as e:<br/>219                 logger.error(str(type(e)) + "," + str(e))<br/>220                 self.processed_windows_filetime_64 = str(<br/>221                     type(e).__name__)</pre>
<p>If the input timestamp is a formatted value, we need to reverse this conversion. We were able to take some shortcuts before on line 212 using the <kbd>datetime.timedelta()</kbd> method. When moving in the other direction, we need to manually calculate the microseconds count before converting it into hex.</p>
<p>First, on line 225, we convert the data from a string into a <kbd>datetime</kbd> object so we can begin to process the values. From here, we subtract the epoch value from the converted time. After subtraction, we convert the <kbd>datetime.timedelta</kbd> object into microsecond values from the three stored values. We need to multiply the seconds by one million and the days by 86.4 billion to convert each value into microseconds. Finally, on lines 229 through 231, we're almost ready to convert our timestamp after adding all three values together:</p>
<pre>223         elif self.time_type.get() == 'formatted':<br/>224             try:<br/>225                 converted_time = duparser.parse(<br/>226                     self.input_time.get())<br/>227                 minus_epoch = converted_time - \<br/>228                     datetime.datetime(1601,1,1)<br/>229                 calculated_time = minus_epoch.microseconds + \<br/>230                     (minus_epoch.seconds * 1000000) + \<br/>231                     (minus_epoch.days * 86400000000)</pre>
<p>On lines 232 and 233, we perform the conversion, by casting the innermost layer, <kbd>calculated_time</kbd>, into an integer. In the integer state, it's multiplied by 10 to convert into a count of groups of 100 nanoseconds before conversion into hex with the <kbd>hex()</kbd> typecast. Since the code requires the output to be a string, we cast the hex value to a string as seen in the outside wrap on line 232 before assigning it to the <kbd>self.processed_windows_filetime_64</kbd> variable.</p>
<p>Similar to the other conversion functions, we add in error handling to the converter on lines 234 through 237:</p>
<pre>232                 self.processed_windows_filetime_64 = str(<br/>233                     hex(int(calculated_time)*10))<br/>234             except Exception as e:<br/>235                 logger.error(str(type(e)) + "," + str(e))<br/>236                 self.processed_windows_filetime_64 = str(<br/>237                 type(e).__name__)</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Converting with the convert_chrome_time() method</h1>
                
            
            
                
<p>The last of our showcased timestamps is the Google Chrome timestamp, which is similar to both of the previously mentioned timestamps. This timestamp is the number of microseconds since the <kbd>1601-01-01 00:00:00</kbd> epoch. We'll leverage the earlier-defined <kbd>self.unix_epcoh_offset</kbd> value to help in conversion. On line 248, we begin to convert the raw timestamp through a series of functions.</p>
<p>First, we convert the timestamp into a float and subtract the 1601 epoch constant. Next, we divide the value by one million to convert the value from microseconds into seconds so that the <kbd>datetime.datetime.fromtimestamp()</kbd> method can interpret the value properly. Finally, on line 251, we format <kbd>converted_time</kbd> to a string using the <kbd>strftime()</kbd> function. On lines 253 through 255, we handle exceptions that may occur from invalid values as seen in previous sections, as follows:</p>
<pre>239     def convert_chrome_time(self):<br/>240         """<br/>241         The convert_chrome_time method handles the<br/>242         conversion of timestamps per the Google Chrome<br/>243         timestamp format<br/>244         """<br/>245         # Run Conversion<br/>246         if self.time_type.get() == 'raw':<br/>247             try:<br/>248                 dt_val = datetime.datetime.fromtimestamp(<br/>249                         (float(self.input_time.get()<br/>250                     )-self.epoch_1601)/1000000)<br/>251                 self.processed_chrome_time = dt_val.strftime(<br/>252                     '%Y-%m-%d %H:%M:%S.%f')<br/>253             except Exception as e:<br/>254                 logger.error(str(type(e)) + "," + str(e))<br/>255                 self.processed_chrome_time = str(type(e).__name__)</pre>
<p>When a formatted value is passed as an input, we must reverse the process. As in our other functions, we convert the input to a <kbd>datetime</kbd> object from a string using the <kbd>duparser.parse()</kbd> method. Once converted, we calculate the number of seconds by adding the 1601 epoch constant to the <kbd>total_seconds()</kbd> method.</p>
<p>This count of seconds is multiplied by one million to convert it into microseconds. Once calculated, we can cast this integer value into a string that will be displayed in our GUI. In the event that any errors arise, we catch them on line 264 through 266 in the same way as with previous methods:</p>
<pre>257         elif self.time_type.get() == 'formatted':<br/>258             try:<br/>259                 converted_time = duparser.parse(<br/>260                     self.input_time.get())<br/>261                 chrome_time = (converted_time - self.epoch_1970<br/>262                     ).total_seconds()*1000000 + self.epoch_1601<br/>263                 self.processed_chrome_time = str(int(chrome_time))<br/>264             except Exception as e:<br/>265                 logger.error(str(type(e)) + "," + str(e))<br/>266                 self.processed_chrome_time = str(type(e).__name__)</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Designing the output method</h1>
                
            
            
                
<p>The last method of the class is the <kbd>output()</kbd> method, and it updates the labels found on the bottom frame of the GUI. This simple construct allows us to evaluate processed values and display them if they're string values. As seen on line 273, following the definition of the method and docstring, we check whether the <kbd>self.processed_unix_seconds</kbd> value is of the string type.</p>
<p>If it is, then we update the label by calling the <kbd>text</kbd> attribute as a dictionary key as seen on lines 274 and 275. This could also be accomplished via the use of the <kbd>config()</kbd> method, though in this instance it's simpler to define it in this manner. When this property is changed, the label is immediately updated as the element has already been set by a geometry manager. This behavior is repeated for each label to be updated, as seen on lines 277 through 283:</p>
<pre>268     def output(self):<br/>269         """<br/>270         The output method updates the output frame with the<br/>271         latest value.<br/>272         """<br/>273         if isinstance(self.processed_unix_seconds, str):<br/>274             self.unix_sec['text'] = "Unix Seconds: " + \<br/>275                 self.processed_unix_seconds<br/>276 <br/>277         if isinstance(self.processed_windows_filetime_64, str):<br/>278             self.win_ft_64['text'] = "Windows FILETIME 64: " + \<br/>279                 self.processed_windows_filetime_64<br/>280 <br/>281         if isinstance(self.processed_chrome_time, str):<br/>282             self.google_chrome['text'] = "Google Chrome: " + \<br/>283                 self.processed_chrome_time</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Running the script</h1>
                
            
            
                
<p>With the complete code, we can execute the GUI and begin to convert dates from machine- to human-readable and vice versa. As seen in the following screenshot, the finished GUI reflects our design goal and allows the user to easily interact and process dates:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-442 image-border" src="img/dffb48b8-0436-4ba8-9d3a-fcf1d08e40e8.png" style="width:31.08em;height:13.92em;"/></p>
<p>The preceding screenshot also shows us entering a formatted time value and getting all three converted raw timestamps back from our functions. Next, we provide a raw input in the Unix seconds format and can see that our Unix seconds parser returned the correct date:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-443 image-border" src="img/87c3f71c-7585-412f-a8d3-56396478b67b.png" style="width:32.83em;height:13.92em;"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Additional challenges</h1>
                
            
            
                
<p>This script introduced GUIs and some of the methods available to us via the TkInter module for converting timestamps. This script can be extended in many ways. We recommend the following challenges for those wishing to gain a better understanding of GUI development in Python.</p>
<p>As mentioned in this chapter, we only specify the conversion of three formats that're commonly seen in forensics and use several different methods to provide conversion. Try to add support for the FAT directory timestamp entry into the script, providing conversion into and from the raw format. This script is designed such that adding additional formatters is as simple as defining raw and formatted handlers, adding the labels to our output frame, and appending the method name to <kbd>convert()</kbd>.</p>
<p>In addition, consider replacing the output labels with entry fields so the user can copy and paste the results. A hint for this challenge is to look at the <kbd>set()</kbd> and <kbd>read-only</kbd> properties of the <kbd>Entry</kbd> widget.</p>
<p>The last challenge we present allows the user to specify a time zone, either from the command-line or the GUI interface. The <kbd>pytz</kbd> library may be of great use for this task.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we covered how to convert between machine- and human-readable timestamps and display that information in GUI. The primary goal of a forensic developer is to be capable of facilitating rapid design and deployment of tools that provide insight into investigations.</p>
<p>However, in this chapter, we focused a bit more on the end user by spending a little extra time on building a nice interface for the user to operate and interact with. The code for this project can be downloaded from GitHub or Packt, as described in the <em>Preface</em>.</p>
<p>In the next chapter, we'll explore triaging systems and how to collect essential live and volatile data from a system using Python.</p>


            

            
        
    </body></html>