- en: '13'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '13'
- en: Analyzing Android Malware Samples
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析 Android 恶意软件样本
- en: With the rise of mobile devices, the name Android has become well-known to most
    people, even to those far from the IT world. It was originally developed by Android
    Inc. and later acquired by Google in 2005\. The Android name is derived from the
    nickname of the founder of the company, Andy Rubin. This open source operating
    system is based on a modified version of the Linux kernel and there are several
    variants of it, such as Wear OS for wearable devices, and Android TV, which can
    be found on multiple smart TVs.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 随着移动设备的兴起，Android 这个名字已经为大多数人熟知，甚至是那些远离 IT 世界的人。它最初由 Android Inc. 开发，并在 2005
    年被谷歌收购。Android 这个名字源自公司创始人安迪·鲁宾（Andy Rubin）的昵称。这个开源操作系统基于修改版的 Linux 内核，并且有多个变种，如用于可穿戴设备的
    Wear OS 和可以在多款智能电视上找到的 Android TV。
- en: As mobile devices store and can provide access to more and more sensitive information,
    it’s no surprise that mobile platforms are increasingly becoming targets for attackers
    who are exploring ways to leverage their power for malicious purposes. In this
    chapter, we are going to dive into the internals of the most popular mobile operating
    system in the world, explore existing and potential attack vectors, and provide
    detailed guidelines on how to analyze malware targeting Android users.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 随着移动设备存储并能提供越来越多敏感信息，移动平台逐渐成为攻击者的目标，这也就不足为奇了。攻击者正在探索如何利用这些平台的力量来进行恶意活动。本章将深入探讨全球最受欢迎的移动操作系统的内部机制，分析现有和潜在的攻击向量，并提供如何分析针对
    Android 用户的恶意软件的详细指南。
- en: 'To facilitate learning, this chapter is divided into the following main sections:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 为了便于学习，本章分为以下几个主要部分：
- en: (Ab)using the Android internals
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （滥用）Android 内部机制
- en: Understanding Dalvik and ART
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 Dalvik 和 ART
- en: File formats and APIs
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件格式和 API
- en: Malware behavior patterns
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 恶意软件行为模式
- en: Static and dynamic analysis of threats
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对威胁的静态与动态分析
- en: Let’s get started!
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: (Ab)using the Android internals
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: （滥用）Android 内部机制
- en: Before analyzing the actual malware, let’s become familiar with the system itself
    first and understand the principles it is based on. This knowledge is vital when
    performing analysis, as it allows the engineer to better understand the logic
    behind malicious code and not miss any important part of its functionality.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在分析实际的恶意软件之前，让我们先了解系统本身，并理解其所基于的原理。这些知识在进行分析时至关重要，因为它可以帮助工程师更好地理解恶意代码背后的逻辑，并确保不会错过其功能中的任何重要部分。
- en: The file hierarchy
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件层次结构
- en: As Android is based on the modified Linux kernel, its file structure resembles
    the one that can be found in various Linux distributions. The file hierarchy is
    a single tree, with the top of it called the root directory or root (generally
    specified with the `/` symbol), and multiple standard Linux directories, such
    as `/proc`, `/sbin`, and others. The Android kernel is shipped with multiple supported
    filesystems; the exact selection varies depending on the version of the OS and
    the device’s manufacturer. It has used EXT4 as the default main filesystem since
    Android 2.3, but prior to that, YAFFS was used. External storage and SD cards
    are usually formatted using FAT32 to maintain compatibility with Windows.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Android 基于修改过的 Linux 内核，因此其文件结构与各种 Linux 发行版中的结构相似。文件层次结构是一个单一的树形结构，顶端称为根目录或根（通常使用
    `/` 符号表示），并且包含多个标准的 Linux 目录，例如 `/proc`、`/sbin` 等。Android 内核配备了多种支持的文件系统，具体选择取决于操作系统的版本和设备的制造商。从
    Android 2.3 开始，默认主文件系统为 EXT4，但在此之前，使用的是 YAFFS。外部存储和 SD 卡通常采用 FAT32 格式，以保持与 Windows
    的兼容性。
- en: 'In terms of the specifics of the directory structure, the official Android
    documentation defines the following data storage options:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 就目录结构的具体细节而言，官方 Android 文档定义了以下数据存储选项：
- en: '`/data/data/` directory and its symlink, the `/data/user/0` directory.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/data/data/` 目录及其符号链接，即 `/data/user/0` 目录。'
- en: Its main purpose is to securely store files privately from apps. What this means
    is that no other apps, or even the user, have direct access to them. Each app
    gets its own folder, and if the user uninstalls the application, all its content
    will be deleted. Thus, the usual applications don’t store anything that should
    persist independently of them here (for example, photos taken by a user with an
    app’s help). Later, we will see what the corresponding behavior of malicious apps
    is.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 它的主要目的是安全地将文件存储在应用的私有空间中。也就是说，其他任何应用程序，甚至用户，都无法直接访问它们。每个应用都有自己的文件夹，如果用户卸载该应用，其所有内容将被删除。因此，通常的应用程序不会在这里存储任何应独立于它们持久化的内容（例如，用户通过应用拍摄的照片）。接下来，我们将看到恶意应用程序的相应行为。
- en: '`/storage/emulated/0` path. In this case, `/storage/self/primary` is a main
    symlink to it, which, in turn, has `/sdcard` and `/mnt/sdcard` symlinks pointing
    to it. `/mnt/user/0/primary` is another common symlink pointing to `/storage/emulated/0`.
    This space is shared across all apps and is world-readable, including for the
    end user. This is where users see well-known folders such as `Downloads` or `DCIM`.
    For the apps themselves, its presence is not actually guaranteed, so its availability
    should be checked each time that it is accessed. In addition, apps have the option
    to have their own app-specific directory (in case they need more space), which
    will be deleted with the app once it is uninstalled. The main location for this
    data on modern forms of Android is `/storage/emulated/0/Android/data/<app_name>`.
    Again, this location is world-accessible.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/storage/emulated/0` 路径。在这种情况下，`/storage/self/primary` 是其主要符号链接，反过来，它有指向它的
    `/sdcard` 和 `/mnt/sdcard` 符号链接。`/mnt/user/0/primary` 是另一个指向 `/storage/emulated/0`
    的常见符号链接。这个空间是所有应用共享的，且是全局可读的，包括终端用户。这是用户看到如 `Downloads` 或 `DCIM` 等常见文件夹的位置。对于应用程序本身来说，实际上并不能保证它的存在，因此每次访问时都应检查它的可用性。此外，应用程序可以选择拥有自己专用的目录（如果它们需要更多空间），一旦应用程序被卸载，这些目录也会被删除。现代
    Android 系统中此数据的主要位置是 `/storage/emulated/0/Android/data/<app_name>`。再次强调，这个位置是全球可访问的。'
- en: In addition, the documentation describes shared preferences and databases, which
    are outside the scope of this book.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，文档还描述了共享首选项和数据库，这些内容超出了本书的范围。
- en: 'There may be a considerable level of confusion here in terms of naming, as
    many file-manager apps call the external file storage internal when they want
    to distinguish it from SD cards (which are treated by the OS in pretty much the
    same way as the embedded phone’s external storage). The truth is, unless the device
    is rooted, the internal storage can’t be accessed and therefore won’t be visible
    to a normal user:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这里可能会有一定程度的混淆，因为许多文件管理应用将外部存储称为内部存储，以便将其与 SD 卡区分开（SD 卡在操作系统中的处理方式与嵌入式手机的外部存储几乎相同）。事实上，除非设备已经获得
    root 权限，否则内部存储是无法访问的，因此普通用户是无法看到它的：
- en: '![Figure 13.1 – The file manager referring to external storage as internal'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 13.1 – 文件管理器将外部存储视为内部存储'
- en: '](img/Figure_13.1_B18500.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.1_B18500.jpg)'
- en: Figure 13.1 – The file manager referring to external storage as internal
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.1 – 文件管理器将外部存储视为内部存储
- en: 'Apart from this, here are some of the other important file paths unique to
    Android:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，以下是一些其他对 Android 独有的重要文件路径：
- en: '`/data/app` and its modern symlink, `/factory`: Contains APK and ODEX files
    for installed apps.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/data/app` 及其现代符号链接 `/factory`：包含已安装应用的 APK 和 ODEX 文件。'
- en: '`/data/dalvik-cache`: The optimized bytecode for installed apps.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/data/dalvik-cache`：已安装应用的优化字节码。'
- en: '`/system`: This is the location of the operating system itself. It contains
    directories that are normally found in the root directory.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/system`：这是操作系统本身的所在位置。它包含通常在根目录中找到的目录。'
- en: '`/vendor`: A symbolic link to `/system/vendor`. This path contains vendor-specific
    files.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/vendor`：指向 `/system/vendor` 的符号链接。这个路径包含厂商特定的文件。'
- en: '`/system/app/`: Contains pre-installed Android system apps, for example, to
    interact with the camera or messages.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/system/app/`：包含预安装的 Android 系统应用，例如用于与相机或消息进行交互。'
- en: '`/data/local/tmp/`: A directory where temporary files can be stored.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/data/local/tmp/`：一个可以存储临时文件的目录。'
- en: '![Figure 13.2 – Android’s root directory'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 13.2 – Android 的根目录'
- en: '](img/Figure_13.2_B18500.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.2_B18500.jpg)'
- en: Figure 13.2 – Android’s root directory
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.2 – Android 的根目录
- en: Later, we will see which paths malware generally uses during the deployment.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看到恶意软件在部署过程中通常使用的路径。
- en: The Android security model
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Android 安全模型
- en: There are multiple mechanisms implemented in Android in order to complicate
    the lives of attackers. The system has evolved gradually over time and the latest
    versions differ quite significantly from the earlier editions in terms of security.
    In addition, modern Android systems are based on the newer Linux kernel 4.x+ starting
    from version 7.0\. Let’s talk about some of the most important aspects of them.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Android 实现了多种机制来复杂化攻击者的操作。该系统随着时间的推移逐渐发展，最新版本在安全性方面与早期版本有显著区别。此外，现代 Android
    系统从 7.0 版本开始基于更新的 Linux 内核 4.x+。让我们讨论一些最重要的方面。
- en: Process management
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 进程管理
- en: Android implements **Mandatory Access Control** (**MAC**) over all processes
    and uses the **Security-Enhanced Linux** (**SELinux**) model to enforce it. SELinux
    is based on the deny-by-default principle, where everything that is not explicitly
    allowed is forbidden. Its implementation has evolved over different versions of
    Android; the enforcing mode was enabled in Android 5.0.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Android 实现了**强制访问控制**（**MAC**），并使用**增强安全 Linux**（**SELinux**）模型来执行它。SELinux
    基于默认拒绝原则，即一切没有明确允许的行为都是禁止的。其实现已经随着 Android 的不同版本而发展；在 Android 5.0 中启用了强制模式。
- en: 'On Android, each app runs as an individual process and its own user is created.
    This is how process sandboxing is implemented: to ensure that no process can access
    the data of another one. An example of the generated username in this case is
    `u2_a84`, where `2` is the actual user ID, with the offset `100000` (the actual
    value will be `100002`), and `84` is the app ID, with the offset `10000` (which
    means the value itself is `10084`). The mappings between apps and their corresponding
    user IDs can be found in the `/data/system/packages.xml` file (see the `userId`
    XML attribute), as well as in the matching, more concise `packages.list` file.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android 上，每个应用程序作为独立进程运行，并会创建自己的用户。这就是进程沙盒的实现方式：确保没有进程能够访问另一个进程的数据。在这种情况下，生成的用户名示例是`u2_a84`，其中`2`是实际用户
    ID，偏移量为`100000`（实际值为`100002`），`84`是应用程序 ID，偏移量为`10000`（即值本身为`10084`）。应用与其对应用户
    ID 之间的映射可以在`/data/system/packages.xml`文件中找到（参见`userId` XML 属性），以及在更简洁的`packages.list`文件中找到。
- en: 'In addition to actual users, Android has many system accounts with predefined
    IDs. Apart from `AID_ROOT` (0), which is used to run some native daemons, here
    are some other examples:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 除了实际用户，Android 系统中还有许多具有预定义 ID 的系统账户。除了用于运行一些原生守护进程的`AID_ROOT`（0）外，还有一些其他示例如下：
- en: '`AID_SYSTEM` (1000): This is a regular user account with special permissions
    to interact with system services.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AID_SYSTEM`（1000）：这是一个具有特殊权限的常规用户账户，用于与系统服务进行交互。'
- en: '`AID_VPN` (1016): This is associated with the **Virtual Private Network** (**VPN**)
    system.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AID_VPN`（1016）：与**虚拟私人网络**（**VPN**）系统相关。'
- en: '`AID_SHELL` (2000): This is the account the user gets when they use the `adb`
    tool with the `shell` argument.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AID_SHELL`（2000）：当用户使用`adb`工具并传递`shell`参数时，系统分配给用户的账户。'
- en: '`AID_INET` (3003): This can create `AF_INET` or `AF_INET6` sockets.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AID_INET`（3003）：此账户可以创建`AF_INET`或`AF_INET6`套接字。'
- en: A full, up-to-date list of these can be found in the `android_filesystem_config.h`
    file in the Android source code, which is easily accessible online.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这些账户的完整且最新的列表可以在 Android 源代码中的`android_filesystem_config.h`文件中找到，该文件可以在线轻松访问。
- en: In order to support **Inter-Process Communication** (**IPC**), a dedicated **Binder**
    mechanism has been introduced. It provides a remote method invocation functionality,
    where all the communication between client and server apps passes through a dedicated
    device driver. Later, we will discuss how a single vulnerability in it allows
    attackers to elevate privileges in order to root the corresponding devices.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持**进程间通信**（**IPC**），引入了一种专用的**Binder**机制。它提供了远程方法调用功能，其中所有客户端和服务器应用程序之间的通信都通过专用设备驱动程序进行。稍后我们将讨论如何通过它的一个漏洞使攻击者提升权限，从而使设备获取
    root 权限。
- en: The filesystem
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文件系统
- en: As we now know, all generic user data and shared app data is stored in `/storage/emulated/0`.
    It is available for read and write access but setting executable permissions for
    files located there is not allowed. The idea here is that the user won’t be able
    to simply write to a disk and then execute a custom binary directly, even by mistake
    or as the result of a social engineering attack.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们现在所知道的，所有通用用户数据和共享应用数据都存储在`/storage/emulated/0`中。该路径允许读写访问，但不允许为其中的文件设置可执行权限。这里的目的是，用户无法简单地将自定义二进制文件写入磁盘并直接执行，即使是无意间或作为社会工程攻击的结果。
- en: By contrast, each installed app has full access to its own directory in `/data/data`,
    but not to the directories of other apps unless they explicitly allow it. This
    is done so that one app won’t be able to affect the work of another one or get
    access to sensitive data.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，每个已安装的应用程序都可以完全访问其在`/data/data`中的目录，但不能访问其他应用程序的目录，除非它们明确允许。这样做的目的是为了防止一个应用程序影响另一个应用程序的工作或访问敏感数据。
- en: App permissions
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 应用程序权限
- en: The main purpose of app permissions is to protect user privacy by giving them
    control over what data and system functionalities can be accessed by each application.
    By default, no app can affect the work of another app, unless it is explicitly
    allowed to do so; the same applies to accessing sensitive user data. Depending
    on the version of Android and the settings, some permissions may be granted automatically,
    while others will require manual user approval.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序权限的主要目的是通过让用户控制每个应用程序可以访问的数据和系统功能来保护用户隐私。默认情况下，任何应用程序都不能影响其他应用程序的工作，除非明确允许这样做；同样，访问敏感用户数据也适用此规则。根据Android的版本和设置，一些权限可能会自动授予，而其他则需要用户手动批准。
- en: The default behavior when requesting user consent depends on the Android version
    and the SDK version used to build the app. For Android 6.0+ and SDK version >=
    23, the user is not notified about it at installation time. Instead, the app has
    to ask permission at runtime using a standard system dialog window. For older
    Android and SDK versions, all permissions were requested at installation time.
    The user is presented with groups of permissions rather than individual entries;
    otherwise, it might be overwhelming to go through all of them.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 请求用户同意的默认行为取决于所使用的Android版本和SDK版本。对于Android 6.0+及SDK版本>=23，安装时用户不会收到通知。相反，应用程序必须在运行时通过标准系统对话框窗口请求权限。对于较旧的Android版本和SDK版本，所有权限在安装时一次性请求。用户看到的是一组权限而不是单独的条目，否则逐一查看所有权限可能会感到不堪重负。
- en: 'Each app has to announce what permissions it requires in its embedded `manifest`
    file. For this purpose, dedicated `<uses-permission>` tags can be used. Permissions
    are split into three protection levels:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 每个应用程序都必须在其嵌入的`manifest`文件中声明其所需的权限。为此，可以使用专门的`<uses-permission>`标签。权限分为三个保护级别：
- en: '`ACCESS_NETWORK_STATE`'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ACCESS_NETWORK_STATE`'
- en: '`BLUETOOTH`'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BLUETOOTH`'
- en: '`NFC`'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NFC`'
- en: '`VIBRATE`'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VIBRATE`'
- en: '`BIND_AUTOFILL_SERVICE`*   `BIND_VPN_SERVICE`*   `WRITE_VOICEMAIL`*   `READ_CONTACTS`*   `WRITE_CONTACTS`*   `GET_ACCOUNTS`*   Location:'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BIND_AUTOFILL_SERVICE`*   `BIND_VPN_SERVICE`*   `WRITE_VOICEMAIL`*   `READ_CONTACTS`*   `WRITE_CONTACTS`*   `GET_ACCOUNTS`*   位置：'
- en: '`ACCESS_FINE_LOCATION`'
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ACCESS_FINE_LOCATION`'
- en: '`ACCESS_COARSE_LOCATION`'
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ACCESS_COARSE_LOCATION`'
- en: 'An example of the permissions requested by a sample in its manifest file can
    be seen in the following figure:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示为清单文件中请求权限的示例：
- en: '![Figure 13.3 – An example of the permissions requested by malware in the manifest
    ﬁle'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.3 – 恶意软件在清单文件中请求的权限示例'
- en: '](img/Figure_13.3_B18500.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.3_B18500.jpg)'
- en: Figure 13.3 – An example of the permissions requested by malware in the manifest
    ﬁle
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.3 – 恶意软件在清单文件中请求的权限示例
- en: It is worth mentioning that the list of permissions evolved over time, with
    multiple new permissions being enforced eventually, making the system more secure.
    The exact API version in which a particular permission was added (or deprecated)
    can be found in the most recent official Android documentation.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一提的是，权限列表随着时间的推移不断发展，最终强制执行了多个新权限，从而提高了系统的安全性。特定权限添加（或弃用）的确切API版本可以在最新的官方Android文档中找到。
- en: Apart from this, there are also so-called special permissions that are distinct
    from normal or dangerous ones. They are particularly important, so an app should
    ask for user authorization, in addition to declaring them in the manifest file.
    Examples of such permissions are `SYSTEM_ALERT_WINDOW` and `WRITE_SETTINGS`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，还有一些所谓的特殊权限，它们与普通权限或危险权限不同。这些权限特别重要，因此应用程序除了在清单文件中声明它们之外，还应请求用户授权。此类权限的示例包括`SYSTEM_ALERT_WINDOW`和`WRITE_SETTINGS`。
- en: As different devices may have different hardware features, another manifest
    tag, `<uses-feature>`, was introduced. In this case, if the `android:required`
    attribute is set to `True`, then Google Play won’t allow that app to be installed
    on the device without the feature being supported by it.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 由于不同设备可能具有不同的硬件特性，因此引入了另一个清单标签`<uses-feature>`。在这种情况下，如果`android:required`属性设置为`True`，则如果设备不支持该特性，Google
    Play将不允许在该设备上安装该应用。
- en: Security services
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安全服务
- en: 'Multiple services have been introduced on the Android platform in order to
    improve the overall security structure:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Android 平台已推出多个服务，以改善整体安全结构：
- en: '**Android updates**: As long as vulnerabilities are being identified and fixed,
    users receive updates to improve reliability and security.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Android 更新**：只要漏洞被识别并修复，用户就会收到更新，以提高可靠性和安全性。'
- en: '**Google Play**: Introduces several security features, such as application
    security scanning that aims to prevent malicious authors from uploading and promoting
    malicious software.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Google Play**：引入了多个安全功能，例如应用安全扫描，旨在防止恶意作者上传和推广恶意软件。'
- en: '**Google Play Protect**: A system that runs safety checks on apps downloaded
    from Google Play and checks the device for potentially malicious apps coming from
    other sources.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Google Play Protect**：一个对从 Google Play 下载的应用程序进行安全检查的系统，并检查设备是否存在来自其他来源的潜在恶意应用。'
- en: '**SafetyNet**: Provides several APIs, aiming to give apps that process sensitive
    data extra security-related information (for example, whether the current device
    is protected against known threats and whether the provided URL is safe).'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SafetyNet**：提供多种 API，旨在为处理敏感数据的应用提供额外的安全相关信息（例如，当前设备是否能防御已知威胁，以及提供的 URL 是否安全）。'
- en: The console
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 控制台
- en: 'By default, the console is not available on the device itself (`adb` is supposed
    to be used from another connected device). Thus, in order to get the ability to
    execute basic commands, users have to install third-party apps such as **Termux**
    or **Terminal Emulator**. The interface would look as follows on the mobile device:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，控制台在设备本身不可用（`adb` 应该在另一台连接的设备上使用）。因此，为了获得执行基本命令的能力，用户必须安装第三方应用程序，例如 **Termux**
    或 **Terminal Emulator**。在移动设备上的界面将如下所示：
- en: '![Figure 13.4 – Listing the ﬁles in a root directory using the Terminal Emulator
    app'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 13.4 – 使用终端模拟器应用列出根目录中的文件'
- en: '](img/Figure_13.4_B18500.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.4_B18500.jpg)'
- en: Figure 13.4 – Listing the ﬁles in a root directory using the Terminal Emulator
    app
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.4 – 使用终端模拟器应用列出根目录中的文件
- en: In this case, advanced commands can be used only on the rooted device with **BusyBox**
    or similar sets of tools installed separately.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，只有在已 root 的设备上并且安装了 **BusyBox** 或类似工具集时，才能使用高级命令。
- en: Now, let’s talk about rooting in greater detail.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们更详细地讨论一下 root。
- en: To root or not to root?
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 要进行 root 还是不进行 root？
- en: Every once in a while, users may encounter applications that require their device
    to be rooted. What exactly does this mean and how does this process actually work?
    In this section, we will explore the security mechanisms implemented within different
    Android versions and how they can be bypassed.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 用户偶尔会遇到需要设备进行 root 的应用程序。这到底意味着什么，这个过程是如何运作的呢？在这一部分，我们将探讨不同 Android 版本中实施的安全机制以及如何绕过它们。
- en: If the user requires some functionality not supported by standard system APIs
    (for example, removing certain pre-installed applications or carrier applications,
    overclocking the CPU, or completely replacing the OS), the only option they have
    – apart from creating a feature request – is to obtain root access through a known
    vulnerability. As a result, the user gets elevated privileges and full control
    over the system. The legality of this process varies depending on the country,
    but generally, it is either unclear (which means it falls into a gray area), acceptable
    for non-copyright-related activity, or regulated by some dedicated exemptions.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户需要一些标准系统 API 不支持的功能（例如，删除某些预装应用或运营商应用、超频 CPU 或完全替换操作系统），他们唯一的选择——除了提交功能请求——就是通过已知漏洞获取
    root 权限。这样，用户就能获得提升的权限并完全控制系统。这个过程的合法性因国家而异，但通常情况下，要么不明确（意味着处于灰色地带），要么对于与版权无关的活动是可以接受的，或者由一些专门的豁免进行规范。
- en: 'Sometimes, the rooting process is used interchangeably with jailbreaking, generally
    applied to iOS devices. However, these are different procedures in terms of scope.
    Jailbreaking is the process of bypassing several different types of end-user restrictions;
    the main ones are listed here:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，root 过程与越狱过程交替使用，一般适用于 iOS 设备。然而，这两者在范围上是不同的。越狱是绕过多种不同类型的最终用户限制的过程；主要的限制列举如下：
- en: The ability to modify and replace the operating system (controlled by the locked
    bootloader technology on iOS)
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改和替换操作系统的能力（由 iOS 上的锁定启动加载器技术控制）
- en: Installing non-official applications (sideloading)
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装非官方应用程序（侧载）
- en: Obtaining elevated privileges (what is usually known as rooting)
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取提升的权限（通常称为root）
- en: Unlike iOS, on Android, it is possible to officially enable sideloading, and
    many devices are shipped with bootloaders unlocked, so only rooting remains an
    issue.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 与iOS不同，Android上可以正式启用侧加载，且许多设备出厂时解锁了引导加载程序，因此只有root权限仍然是一个问题。
- en: 'Each time a new rooting-related vulnerability becomes known, the developers
    are expected to fix it and either release a security patch or make the next version
    of the OS more secure. Thus, researchers have to come up with a new vulnerability
    to exploit in order to make rooting possible. Some rooting methods involve using
    `adb`, while others can be executed with the help of the usual user interface.
    Here are some of the most well-known privilege escalation exploits for Android
    OS:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 每当一个新的与root相关的漏洞被发现时，开发人员需要修复它，并发布安全补丁或使操作系统的下一个版本更加安全。因此，研究人员必须想出新的漏洞来利用，从而实现root。一些root方法涉及使用`adb`，而其他方法则可以通过普通的用户界面执行。以下是一些最著名的Android操作系统特权升级漏洞：
- en: '![](img/Table_13.1_B18500.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Table_13.1_B18500.png)'
- en: Rooting is accompanied by security risks for end users, as in this case, they
    are no longer protected by system-embedded security mechanisms and restrictions.
    A common way to get root privileges is to place a standard Linux `su` utility,
    which can grant the required privileges to custom files, in an accessible location
    and use it on demand. Malware can check whether this tool is already available
    on the compromised device and misuse it at its discretion without any extra work
    being required.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Root操作伴随着终端用户的安全风险，因为此时用户不再受到系统内嵌的安全机制和限制的保护。获得root权限的常见方法是将标准Linux `su` 工具放置在一个可访问的位置，该工具能够为自定义文件授予所需权限，并按需使用。恶意软件可以检查该工具是否已在受损设备上存在，并可以在不需要额外操作的情况下任意滥用它。
- en: 'Many Android malware families are also bundled with rooting software in order
    to elevate privileges on their own. There are multiple reasons why root access
    is beneficial to malware authors; particularly, it allows them to obtain the following:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 许多Android恶意软件家族还与root软件捆绑在一起，以便自行提升权限。root访问对恶意软件作者有多个好处，特别是它使他们能够获取以下内容：
- en: Access to crucial data
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问重要数据
- en: Improved persistence capabilities
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改进的持久性能力
- en: Hiding capabilities
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐藏能力
- en: 'Examples of these kinds of malware families include:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类型的恶意软件家族的示例包括：
- en: '**Dvmap**: Uses root privileges to modify system libraries for persistence
    and privilege escalation'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Dvmap**：利用root权限修改系统库以实现持久化和特权升级'
- en: '**Zeahache**: Escalates privileges and opens a back door for other modules
    to enter the compromised system'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Zeahache**：提升权限并为其他模块打开后门，允许它们进入受损的系统'
- en: '**Guerrilla**: Here, root privileges are required to access a user’s Google
    Play tokens and credentials and gain the ability to interact with the store directly,
    installing and promoting other apps'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Guerrilla**：在这里，需要root权限才能访问用户的Google Play令牌和凭证，并获得与商店直接交互的能力，从而安装和推广其他应用程序'
- en: '**Ztorg**: Escalates privileges, mainly to achieve better stealth and aggressively
    display ads'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Ztorg**：提升权限，主要目的是实现更好的隐蔽性，并积极展示广告'
- en: '**CopyCat**: Infects Android’s **Zygote** process (a template for other processes)
    and loads itself into other processes to access and alter sensitive information'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CopyCat**：感染Android的**Zygote**进程（其他进程的模板），并将自己加载到其他进程中以访问和更改敏感信息'
- en: '**Tordow**: Steals sensitive information such as credentials from browsers'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Tordow**：窃取浏览器中的敏感信息，如凭证'
- en: It is worth mentioning that not all malware families implement rooting, as it
    also increases the probability of being detected by antivirus solutions or damaging
    the device. In the end, it is up to the authors whether the advantages associated
    with it outweigh the risks, all depending on the purpose of malware.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一提的是，并非所有恶意软件家族都实现root，因为它也增加了被杀毒软件检测到或损坏设备的概率。最终，是否使用root取决于作者，关键看其目的是否使得这些优点超过风险。
- en: As we now have some basic understanding of how Android works, it’s time to dive
    deeper into its internals.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对Android的基本工作原理有所了解，是时候深入研究其内部机制了。
- en: Understanding Dalvik and ART
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Dalvik和ART
- en: The Android OS has evolved drastically over the past several years in order
    to address user and industry feedback, making it more stable, fast, and reliable.
    In this section, we will explore how the file execution process was implemented
    and progressed. In addition, we will dig into various original and newer file
    formats and learn how the Android executables are actually working.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 为了响应用户和行业的反馈，Android 操作系统在过去几年中发生了巨大的变化，使其变得更加稳定、快速和可靠。在本节中，我们将探讨文件执行过程是如何实现和发展的。此外，我们将深入研究各种原始和更新的文件格式，并了解
    Android 可执行文件的实际工作方式。
- en: Dalvik VM (DVM)
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Dalvik 虚拟机（DVM）
- en: The **Dalvik VM** (**DVM**) was an open source process virtual machine used
    in Android up to version 4.4 (KitKat). It got its name from the village Dalvík
    in Iceland. The DVM implemented register-based architecture, which differs from
    stack-based architecture VMs such as Java VMs. The difference here is that stack-based
    machines use instructions to load and manipulate data on the stack and generally
    require more instructions than register machines in order to implement the same
    high-level code. By contrast, analogous register machine instructions must often
    define the register values used (which is not the case for stack-based machines,
    as the order of values on the stack is always known and the operands can be addressed
    implicitly by the stack pointer), so they tend to be bigger.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**Dalvik 虚拟机**（**DVM**）是一个开源的进程虚拟机，曾用于 Android 直到 4.4 版本（KitKat）。它的名字来自冰岛的
    Dalvík 村。DVM 实现了基于寄存器的架构，这与基于栈的架构虚拟机（如 Java 虚拟机）不同。这里的区别在于，基于栈的虚拟机使用指令来加载和操作栈上的数据，通常需要比寄存器机器更多的指令来实现相同的高级代码。相比之下，类似的寄存器机器指令通常必须定义所使用的寄存器值（而栈基机器则不需要，因为栈上的值的顺序始终已知，操作数可以通过栈指针隐式寻址），因此这些指令通常更大。'
- en: Usually, Dalvik programs are written in the `dx` is used, which converts Java
    class files into the **Dalvik Executable** (**DEX**) format. It is worth mentioning
    that multiple class files can be converted into a single DEX file.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，Dalvik 程序是用 `dx` 工具编写的，该工具将 Java 类文件转换为 **Dalvik 可执行文件**（**DEX**）格式。值得一提的是，多个类文件可以被转换为一个单独的
    DEX 文件。
- en: Once DEX files are created, they can be combined together with resources and
    code native to the `dexopt` tool, producing the **Optimized DEX** (**ODEX**) file,
    which is interpreted by the DVM.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦生成了 DEX 文件，它们可以与资源和本地代码一起通过 `dexopt` 工具进行合并，生成 **优化 DEX**（**ODEX**）文件，该文件由
    DVM 解释执行。
- en: Starting from Android 2.2, the **Just-In-Time** (**JIT**) compiler was introduced
    for Dalvik. The way it works is that it continually profiles applications on every
    run and dynamically compiles the most used blocks of bytecode into native machine
    code. However, independent benchmark tests have shown that stack-based the Java
    HotSpot VM was on average two to three times faster than the DVM (with enabled
    JIT) on the same device, with the Dalvik code not taking up less space either.
    In order to improve the overall performance and introduce more features, **Android
    Runtime** (**ART**) was created.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Android 2.2 开始，引入了 **即时编译**（**JIT**）编译器用于 Dalvik。其工作原理是它在每次运行时持续分析应用程序，并动态地将最常用的字节码块编译成本地机器代码。然而，独立的基准测试显示，在同一设备上，启用
    JIT 的 Dalvik 相比栈基的 Java HotSpot VM 平均慢了两到三倍，且 Dalvik 代码的空间占用也没有减少。为了提高整体性能并引入更多功能，**Android
    运行时**（**ART**）应运而生。
- en: Android runtime (ART)
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Android 运行时（ART）
- en: ART was first introduced as an alternative runtime environment in Android 4.4
    (KitKat) and completely replaced Dalvik in the subsequent major release of Android
    5.0 (Lollipop).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: ART 最早在 Android 4.4（KitKat）中作为替代运行时环境引入，并在随后的 Android 5.0（Lollipop）版本中完全替代了
    Dalvik。
- en: 'In order to explore the relationship between Dalvik and ART, let’s take a look
    at this diagram:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为了探索 Dalvik 和 ART 之间的关系，我们来看一下这张图：
- en: '![Figure 13.5 – A diagram depicting the diﬀerences between Dalvik and ART (origin:
    Wikimedia Commons)'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 13.5 – 描述 Dalvik 和 ART 之间差异的图示（来源：Wikimedia Commons）'
- en: '](img/Figure_13.5_B18500.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.5_B18500.jpg)'
- en: 'Figure 13.5 – A diagram depicting the diﬀerences between Dalvik and ART (origin:
    Wikimedia Commons)'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.5 – 描述 Dalvik 和 ART 之间差异的图示（来源：Wikimedia Commons）
- en: As you can see, both Dalvik and ART share the same logic at the beginning, and
    operate with the same DEX and APK files to maintain backward compatibility. The
    major differences lie in how the files are actually processed and executed. Instead
    of interpreting DEX bytecode, ART translates it to machine code instructions in
    order to achieve better performance results. This way, instead of generating ODEX
    files at install time, ART compiles apps using the `dex2oat` tool to generate
    ELF files (already covered in the previous chapters) that contain native code.
    Originally, they also contained DEX code, but on modern Android systems, the DEX
    code is stored in dedicated **VDEX** files rather than inside the **OAT** files.
    This process is known as **Ahead-Of-Time** (**AOT**) compilation.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，Dalvik 和 ART 在开始时共享相同的逻辑，并使用相同的 DEX 和 APK 文件以保持向后兼容性。主要的区别在于文件实际如何处理和执行。ART
    并不像 Dalvik 那样解释 DEX 字节码，而是将其转换为机器码指令，以实现更好的性能。因此，ART 在安装时不会生成 ODEX 文件，而是通过 `dex2oat`
    工具编译应用程序生成包含本地代码的 ELF 文件（在前面章节中已经讲过）。最初，这些 ELF 文件也包含 DEX 代码，但在现代 Android 系统中，DEX
    代码被存储在专用的 **VDEX** 文件中，而不是存储在 **OAT** 文件内。这个过程被称为 **提前编译**（**AOT**）编译。
- en: 'Starting from Android 7.0 (Nougat), a JIT compiler complements AOT compilation
    and optimizes the code execution on the fly based on the profiler output. While
    JIT and AOT use the same compiler, the former is able to incorporate runtime information
    in order to achieve better results generally, for example, via improved inlining.
    The following is a diagram depicting the relationship between JIT and AOT:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Android 7.0（Nougat）开始，JIT 编译器补充了 AOT 编译，并根据分析器输出实时优化代码执行。虽然 JIT 和 AOT 使用相同的编译器，但前者能够在运行时利用信息，以便一般性地获得更好的结果，例如通过改进的内联。下面是一个图示，描述了
    JIT 和 AOT 之间的关系：
- en: '![Figure 13.6 – The process of compiling and executing ﬁles in ART (origin:
    source.android.com)'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 13.6 – 在 ART 中编译和执行文件的过程（来源：source.android.com）'
- en: '](img/Figure_13.6_B18500.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.6_B18500.jpg)'
- en: 'Figure 13.6 – The process of compiling and executing ﬁles in ART (origin: source.android.com)'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.6 – 在 ART 中编译和执行文件的过程（来源：source.android.com）
- en: As you can see, if the AOT binary is available (which is not always the case),
    they are executed straight away, either from the JIT code cache (if it is JIT-compiled)
    or in the usual way. Otherwise, they are interpreted and optionally compiled by
    JIT, depending on how it is used throughout the system, in particular, whether
    it is used by other applications and whether it has a meaningful profile (profile
    files are recorded and created during the sample execution). The AOT compilation
    daemon also runs periodically and utilizes this information to (re)compile highly
    used files.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，如果 AOT 二进制文件可用（但并非总是如此），它们会直接执行，无论是从 JIT 代码缓存中执行（如果是 JIT 编译的）还是按常规方式执行。否则，它们会被解释并根据系统的使用情况选择性地由
    JIT 编译，特别是是否被其他应用程序使用，以及是否具有有效的分析数据（分析文件在执行过程中记录并生成）。AOT 编译守护进程也会定期运行，并利用这些信息来（重新）编译高频使用的文件。
- en: Now, let’s dive deeper into Dalvik’s bytecode instruction set.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们更深入地探讨 Dalvik 的字节码指令集。
- en: The bytecode set
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字节码集
- en: As we now know, Dalvik is a register-based machine, which defines the syntax
    of bytecode. There are multiple instructions operating with registers in order
    to access and manipulate data. The total size of any instruction is a multiple
    of 2 bytes. All instructions are type-agnostic, which means that they don’t differentiate
    between the values of different data types as long as their sizes are the same.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们现在所知，Dalvik 是一种基于寄存器的机器，它定义了字节码的语法。有多个指令通过寄存器进行操作，以访问和操作数据。任何指令的总大小都是 2 字节的倍数。所有指令都是与类型无关的，这意味着它们不会区分不同数据类型的值，只要它们的大小相同。
- en: 'Here are some examples of how they look in the official documentation. We’ll
    split them into several categories for easier navigation. The explanation of how
    to interpret the first column can be found after this table:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是它们在官方文档中的一些示例。我们将它们分为几个类别，便于浏览。关于如何解读第一列的说明可以在该表格后找到：
- en: '**Data access and movement**:'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据访问与传输**：'
- en: '![](img/Table_13.2(a)_B18500.jpg)![](img/Table_13.2(b)_B18500.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Table_13.2(a)_B18500.jpg)![](img/Table_13.2(b)_B18500.jpg)'
- en: '**Arithmetic operations**:![](img/Table_13.3(a)_B18500.jpg)'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**算术操作**：![](img/Table_13.3(a)_B18500.jpg)'
- en: '![](img/Table_13.3(b)_B18500.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Table_13.3(b)_B18500.jpg)'
- en: '**Branching and calls**: As all instructions are multiples of 2 bytes, all
    branching instructions operate with words:'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/Table_13.4(a)_B18500.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
- en: '![](img/Table_13.4(b)_B18500.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
- en: It is worth mentioning that some sets of instructions (for example, for optimized
    code) can be marked as unused in the official documentation, and it is quite unlikely
    they will be found in malware aiming to achieve the maximum coverage possible.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s examine the format notation used in the first column.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: The first byte is the opcode of the instruction (Dalvik utilizes only one-byte
    values (00-0xFF) to encode the instructions themselves). In the official documentation,
    some similar instructions are grouped into one row with the `range` they belong
    (“`..`” is used to define the range) specified in the first column and the mappings
    for the corresponding instructions provided in the second column.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: 'Supported instruction formats are described using a special format ID notation
    in the official documentation. Format IDs mostly consist of three characters –
    two digits and a letter:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: The first digit indicates the number of two-byte code units in the resulting
    bytecode (see the *Examples* column).
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second digit specifies the maximum number of registers used (as some instructions
    support a variable number of them).
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The final letter indicates the type of any extra data encoded by the format.
    Here is the official table describing these mnemonics:'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/Table_13.5_B18500.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
- en: 'Let’s use the first row of the first table as an example. Here, a `01 12x`
    value describing the `move v0, v1` instruction encoded using 2 bytes, `0110`,
    means the following:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '`01` – the byte encoding the actual instruction (`0x01`).'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`12x` should be interpreted as three individual values:'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`1` – the size of the instruction (one word, 2 bytes in total: `0x01` and `0x10`)'
  id: totrans-146
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`2` – the number of registers (two in total, `v0` and `v1`)'
  id: totrans-147
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`x` – no extra data used here'
  id: totrans-148
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As for the prefixes for arguments used in the second column of the first table,
    this is what they mean:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: The `v` symbol is used to mark the arguments that the name registers.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `#+` prefix specifies arguments indicating a literal value.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `+` symbol is used for arguments that indicate a relative instruction address
    offset.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `kind@` prefix indicates a constant pool kind (string, type, field, and
    so on).
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A separate official document describes all the possible variants of format.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of how a sequence of Dalvik bytecode looks:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.7 – An example of disassembled Dalvik bytecode'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.7_B18500.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.7 – An example of disassembled Dalvik bytecode
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: Overall, the related Android documentation is very detailed and easily accessible,
    so in case of doubt, it always makes sense to consult it.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how Android works, it’s time to go one level deeper and understand
    the main file formats used in its apps.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: File formats and APIs
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here are the most important file formats associated with applications written
    for different versions of Android.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是与为不同版本Android编写的应用程序相关的最重要的文件格式。
- en: DEX
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DEX
- en: 'The DEX format holds a set of class definitions and associated data. The file
    layout is as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: DEX格式包含一组类定义和相关数据。文件布局如下：
- en: '![](img/Table_13.6(a)_B18500.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Table_13.6(a)_B18500.jpg)'
- en: '![](img/Table_13.6(b)_B18500.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Table_13.6(b)_B18500.png)'
- en: 'The rest of the fields define the sizes and offset of other data blocks:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 其余字段定义了其他数据块的大小和偏移量：
- en: '![Figure 13.8 – A DEX header with the fields described in detail'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 13.8 – 详细描述字段的DEX头文件'
- en: '](img/Figure_13.8_B18500.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.8_B18500.jpg)'
- en: Figure 13.8 – A DEX header with the fields described in detail
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.8 – 详细描述字段的DEX头文件
- en: The header starts with an 8-byte `DEX_FILE_MAGIC` value that consists of a `dex`
    string (`\x64\x65\x78`) followed by the newline symbol (`\x0a`), the 3 bytes defining
    the format version, and finally a zero byte (`\x00`). This format aims to provide
    a way to identify DEX files and the corresponding layout used, and to prevent
    basic data corruption.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 头文件以一个8字节的`DEX_FILE_MAGIC`值开始，该值由一个`dex`字符串（`\x64\x65\x78`）后跟换行符（`\x0a`）、定义格式版本的3个字节，最后是一个零字节（`\x00`）组成。此格式旨在提供一种识别DEX文件及其使用的相应布局的方法，并防止基本的数据损坏。
- en: ODEX
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ODEX
- en: 'Actively used before the appearance of ART, ODEX files are the result of the
    optimizations made to DEX on the device in order to improve performance and decrease
    the result size. ODEX files consist of the already described DEX layout, wrapped
    with a short ODEX header:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在ART出现之前广泛使用的ODEX文件是对设备上DEX进行优化的结果，目的是提高性能并减少结果文件大小。ODEX文件由已描述的DEX布局组成，并加上一个简短的ODEX头文件：
- en: '[PRE0]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The header `magic` value is the same as for DEX but features a slightly different
    first 3-byte signature, `dey` (`\x64\x65\x79`), rather than `dex`. This format
    is defined in the `DexFile.h` source code file.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`magic`头文件的值与DEX相同，但其前三个字节的签名略有不同，使用`dey`（`\x64\x65\x79`），而不是`dex`。此格式在`DexFile.h`源代码文件中定义。'
- en: OAT
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OAT
- en: OAT files aimed to replace ODEX in the newer ART environment. To begin with,
    file extensions shouldn’t be trusted when dealing with Android executables. In
    particular, on recent Android systems, files with the `.dex`, `.odex,` and `.oat`
    extensions may actually implement the OAT format. It is not very well-documented
    and varies for different versions of Android, but the most important thing here
    is that the result data is wrapped in ELF shared objects. Starting from Android
    Oreo, OAT files don’t store DEX code, leaving it to VDEX files, and are used mainly
    to store mapping information and the native code.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: OAT文件旨在替代新ART环境中的ODEX。首先，在处理Android可执行文件时，不应仅仅依赖文件扩展名。特别是在近期的Android系统上，`.dex`、`.odex`和`.oat`扩展名的文件实际上可能实现了OAT格式。该格式文档并不完善，并且在不同版本的Android中有所不同，但最重要的一点是，结果数据被封装在ELF共享对象中。从Android
    Oreo开始，OAT文件不再存储DEX代码，而是将其交给VDEX文件，主要用于存储映射信息和本地代码。
- en: VDEX
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: VDEX
- en: These files were introduced in newer versions of Android (starting from Android
    Oreo) and are created by the `dex2oat` tool. The idea here is to store DEX code
    independently, not inside the OAT structure, with some additional metadata to
    speed up verification. As with OAT, the file format is not documented and changes
    between different versions of Android. Its description can be found in Android’s
    `vdex_file.h` source code file.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这些文件是在新版Android中引入的（从Android Oreo开始），并由`dex2oat`工具创建。其思路是将DEX代码独立存储，而不是存储在OAT结构中，并附加一些元数据以加速验证。与OAT一样，该文件格式未公开文档，并且在不同版本的Android中有所变化。其描述可以在Android的`vdex_file.h`源代码文件中找到。
- en: Apart from this, a new internal ART format called `cdex`. The most up-to-date
    description can be found in the `compact_dex_file.h` source code file.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一种新的内部ART格式，称为`cdex`。最新的描述可以在`compact_dex_file.h`源代码文件中找到。
- en: ART
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ART
- en: These files contain internal representations of certain strings and classes
    listed in the APK for ART and are used to speed up the application start. The
    common file extension used in this case is `.art`. As in the previous case, this
    file format is not documented and changes between different versions of Android.
    As it is generally not used by malware, we won’t go into greater detail here.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这些文件包含APK中列出的ART的某些字符串和类的内部表示，并用于加速应用程序启动。此情况下常用的文件扩展名为`.art`。与前面的情况一样，这种文件格式没有文档说明，并且在不同版本的Android中有所变化。由于它通常不被恶意软件使用，这里不再详细讨论。
- en: ELF
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ELF
- en: In addition to Android-specific file formats, it is also possible to execute
    general ELF files compiled for the corresponding architecture. Unlike Linux systems,
    which mostly rely on **glibc**, Android uses its own **Bionic C** library due
    to licensing issues. At the moment, x86 and ARM (both 32-bit and 64-bit) architectures
    are supported. Besides this, as has just been mentioned, it is also used to store
    OAT data blocks for optimized Android executables.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: The ELF format has already been covered in great detail in [*Chapter 11*](B18500_11.xhtml#_idTextAnchor1188),
    *Dissecting Linux and IoT Malware*.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: APK
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: APK files are archive files based on the JAR format, which, as we know from
    [*Chapter 9*](B18500_09.xhtml#_idTextAnchor946)*, Reversing Bytecode Languages
    – .NET, Java, and More*, implements the ZIP format. What this means is that APK
    files can be unpacked using any software supporting ZIP-compressed files.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: 'Usually, APK files contain the following files:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '`res`: This directory contains various resource files (such as XMLs and pictures).'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`META-INF`: Stores metadata files associated with the package, mainly the following
    ones:'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MANIFEST.MF`: A `manifest` file containing names and SHA1/SHA2 digests of
    files inside the APK'
  id: totrans-191
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<name>.RSA`: Contains the application’s signature and certificate'
  id: totrans-192
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<name>.SF`: Contains SHA1 or SHA2 digests of the corresponding lines in the
    `MANIFEST.MF` and the list of associated resources'
  id: totrans-193
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AndroidManifest.xml`: The main `manifest` file defining various important
    app-related values for the system and Google Play. It is stored in human-unreadable
    format inside the APK. One of the easiest ways to decode it is by using **apktool**
    for extraction.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`classes.dex`: A compiled file containing the app’s DEX bytecode; there can
    be several of them with numbers added following this format: `classes<num>.dex`.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`resources.arsc`: This compiled file contains metadata associated with resources
    used by the app.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At the moment, Android doesn’t perform CA verification for application certificates,
    so self-signed certificates are allowed. Apart from this, other directories such
    as assets and files can also be commonly found inside APK files.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: 'Regarding `AndroidManifest.xml`, only the `<manifest>` and `<application>`
    elements are required to be present. Generally, the following data can be specified
    there:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: Basic app information (such as the package name)
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: App components and the corresponding types (activity, service, broadcast receiver,
    or content provider)
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Required permissions (see the corresponding section, *The Android security model*)
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hardware and software features that the app needs
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Information about the supported Android SDK
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Unlike programs on many other systems, generally speaking, Android apps don’t
    necessarily have a single entry point, which means there is no main function.
    The sample’s main activities can be found by looking at the app’s `AndroidManifest.xml`
    file and searching for the components with the `android.intent.action.MAIN` value
    specified. Also check that if there is a class name mentioned in the `android:name`
    attribute of the `<application>` element (this name should represent a subclass
    of the `Application` class), it gets control first. Once found, search for the
    `onCreate` methods in these components – here is how they will look in disassembly:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 与许多其他系统上的程序不同，一般来说，Android 应用程序不一定具有单一的入口点，这意味着没有主函数。可以通过查看应用程序的 `AndroidManifest.xml`
    文件，搜索具有 `android.intent.action.MAIN` 值的组件来找到示例的主要活动。还需要检查 `<application>` 元素的
    `android:name` 属性中是否提到了类名（这个类名应代表 `Application` 类的子类），如果提到了，那么该类应首先获得控制权。一旦找到，接着搜索这些组件中的
    `onCreate` 方法——它们在反汇编中将会是这样的：
- en: '![Figure 13.9 – The onCreate method in the disassembled Android sample'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 13.9 – 反汇编后的 Android 示例中的 onCreate 方法'
- en: '](img/Figure_13.9_B18500.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.9_B18500.jpg)'
- en: Figure 13.9 – The onCreate method in the disassembled Android sample
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.9 – 反汇编后的 Android 示例中的 onCreate 方法
- en: Now that we have become familiar with the most common file formats used in Android,
    let’s talk about its APIs.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经熟悉了 Android 中最常用的文件格式，接下来让我们来讨论它的 API。
- en: APIs
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: APIs
- en: 'Most of the code for the Android platform is written in Java, so the whole
    infrastructure is built on it. However, Android implements its own APIs in order
    to let programs interact with the OS to achieve their goals. While some classes
    might be quite similar to Java (for example, the `System` class), there are also
    a significant number of differences, such as the different meanings of certain
    properties (or properties that have lost their meaning). In addition, some introduced
    classes and APIs are new and aim to provide access to the unique features implemented
    in Android. An example is the `DexClassLoader` class, which loads classes from
    JAR and APK files and can be used to execute code that wasn’t part of an application.
    Here are some other examples of APIs and their classes, with self-explanatory
    names that can be commonly seen in malware:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: Android 平台的大多数代码是用 Java 编写的，因此整个基础架构都是建立在 Java 上的。然而，Android 实现了自己的 API，以便让程序与操作系统交互以实现其目标。虽然某些类可能与
    Java 相似（例如，`System` 类），但也有许多不同之处，比如某些属性的含义不同（或有些属性失去了其原本的意义）。此外，一些新引入的类和 API 旨在提供对
    Android 中实现的独特功能的访问。例如，`DexClassLoader` 类，它从 JAR 和 APK 文件加载类，并可用于执行不属于应用程序的代码。以下是一些其他
    API 及其类的示例，这些类有着易于理解的名称，并且通常可以在恶意软件中看到：
- en: '`SmsManager`'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SmsManager`'
- en: '`sendTextMessage`'
  id: totrans-212
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sendTextMessage`'
- en: '`ActivityManager`'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ActivityManager`'
- en: '`GetRunningServices`'
  id: totrans-214
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetRunningServices`'
- en: '`getRunningAppProcesses`'
  id: totrans-215
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getRunningAppProcesses`'
- en: '`PackageManager`'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PackageManager`'
- en: '`GetInstalledApplications`'
  id: totrans-217
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetInstalledApplications`'
- en: '`getInstalledPackages`'
  id: totrans-218
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getInstalledPackages`'
- en: '`DevicePolicyManager`'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DevicePolicyManager`'
- en: '`LockNow`'
  id: totrans-220
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LockNow`'
- en: '`reboot`'
  id: totrans-221
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reboot`'
- en: '`Camera`'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Camera`'
- en: '`TakePicture`'
  id: totrans-223
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TakePicture`'
- en: '`DownloadManager`'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DownloadManager`'
- en: '`enqueue`'
  id: totrans-225
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`enqueue`'
- en: '`DownloadManager.Request`'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DownloadManager.Request`'
- en: '`setDestinationUri`'
  id: totrans-227
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setDestinationUri`'
- en: Some functionality can also be accessed through the use of a combination of
    the `Intent` class, with a particular argument describing the requested action,
    and the `Activity` class, to actually perform an action, generally using the `startActivityForResult`
    method.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以通过组合使用 `Intent` 类（其中包含描述所请求操作的特定参数）和 `Activity` 类（实际执行操作，通常使用 `startActivityForResult`
    方法）来访问某些功能。
- en: Regarding the downloading-related functionality, many malware families obviously
    prefer to avoid using the standard download manager, as it tends to be more visible
    to the user, and instead implement it using Java classes such as `java.net.URL`
    and `java.net.URLConnection`. And, of course, as we know, some APIs require particular
    permissions to be requested prior to use. In this case, it should be at least
    `android.permission.INTERNET`.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 关于下载相关的功能，许多恶意软件家族显然更倾向于避免使用标准下载管理器，因为它往往更容易被用户看到，而是使用 Java 类（如 `java.net.URL`
    和 `java.net.URLConnection`）来实现下载。当然，正如我们所知道的，某些 API 需要在使用之前请求特定的权限。在这种情况下，至少需要
    `android.permission.INTERNET` 权限。
- en: Now that we have learned how the files are structured as well as what APIs we
    need to pay attention to, it is time to focus on particular patterns commonly
    found in malware as well as the logic behind them.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: Malware behavior patterns
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Generally speaking, even though malware for mobile devices has its own nuances
    caused by the different environment and use cases of the targeted systems, many
    motivation patterns behind attacks stays the same as for PC platforms. In this
    section, we are going to dive deeper into various examples of mobile malware functionality
    and learn what methods it uses in order to achieve malevolent goals.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how things are supposed to work, let’s take a look at how malware
    authors leverage them. Here, we will go through various attack stages common for
    the vast majority of malware, which will enable us to see these patterns in the
    analyzed samples and understand their purpose.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: Initial access
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The most common ways malware gets access to devices are the following:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: Google Play
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Third-party markets and sideloading
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Malicious ads and exploits
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the first two cases, malware authors generally rely on social engineering,
    tricking users into installing a potentially useful app. There are many techniques
    used to make this possible, such as the following:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '**Similar design**: The app may look similar and have a similar name to some
    other well-known, legal application.'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fake reviews**: To make the app look authentic and not suspicious.'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Anti-detection techniques**: To bypass automatic malware scanners and prolong
    the hosting.'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Malicious update**: The original application uploaded to the store is clean,
    but its update contains hidden malicious functionality.'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Luring description**: Promises free or forbidden content, easy money, and
    so on.'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The app itself may be mostly legitimate but also contain hidden malicious functionality.
    There are multiple ways the user may come across them – by clicking fraudulent
    links received via messengers, texts, emails, or left on forums, or encountering
    it during searches for particular apps due to illegal **Search Engine Optimization**
    (**SEO**) techniques.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: Use of malicious ads involves delivering malicious code through the advertisement
    network with the help of exploits. An example could be **lbxslt**, an exploit
    leaked from HackingTeam and used by attackers to spread ransomware in 2017\. In
    addition, exploits may also be used for high-profile attacks targeting particular
    individuals.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: Privilege escalation
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next stage is to obtain all required permissions. Apart from the rooting
    options already discussed, it is possible for malware to abuse so-called administrative
    permissions.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: Originally designed for enterprise use cases to remotely administrate the mobile
    devices of employees, they can offer malware powerful capabilities, including
    the ability to wipe important data. Usually, the easiest way to get permissions
    is to keep asking the user and don’t stop until they are granted.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: As long as all the required privileges are obtained, malware generally attempts
    to deploy its modules somewhere on a device. At this stage, extra modules can
    be downloaded after contacting the command and control server.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: Persistence
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The most common places where malware installs itself once it gets executed
    are the following:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '`/data/data`: Standard paths intended to be used for all Android applications.
    This approach poses a threat to attackers, as it is relatively easy to remediate
    such threats.'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/system/(app|priv-app|lib|bin|xbin|etc)`: These paths require malware to use
    rooting exploits to get access to them. This makes it harder for the user to identify
    and delete the threat.'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Persistence in this case can be achieved using the standard Android `BroadcastReceiver`
    functionality common to all apps using the `BOOT_COMPLETED` action. The `RECEIVE_BOOT_COMPLETED`
    permission is required in this case.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: While many mass malware families follow similar patterns in order to achieve
    their goals, there is also a much smaller – but at the same time, often a more
    highly significant – set of examples implementing advanced techniques in order
    to achieve more specific goals. An example is APT groups performing high-profile
    espionage tasks and therefore having much higher requirements in terms of stealth
    and effectiveness. An example of the relevant malware family patching system libraries
    is `libdvm.so` and `libandroid_runtime.so`), injecting its code there. The libraries
    are supposed to execute a standard system executable with system privileges, which
    is replaced by the attackers to achieve persistence and escalate privileges at
    the same time.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: Impact
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As long as the malware completed its installation, it can switch to the main
    purpose it was created for. The exact implementation will vary drastically depending
    on that. Here are some of the most common behaviors found in mass malware:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '**Premium SMS senders**: Probably the easiest way to make money straight away
    in mobile malware in certain countries is to send paid SMS messages to premium
    numbers (including the ones related to in-app purchases) or subscribing to paid
    services. Each of them will cost a certain amount of money, or an automatic subscription
    payment will be taken regularly, which eventually leads to draining the victim’s
    balance. In order to bypass CAPTCHA protection, existing anti-CAPTCHA services
    may be used.'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Clickers**: A more generic group of threats that uses mobile devices to make
    money in multiple different ways:'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ad clickers**: Simulates clicks on advertising websites without the user’s
    interaction, eventually draining money from advertising companies.'
  id: totrans-261
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**WAP clickers**: This group is similar to SMS senders in the way that it uses
    another form of mobile payment, this time, by simulating clicks on WAP-billing
    web pages. The charge will be applied to the victim’s phone balance.'
  id: totrans-262
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Clickers that increase traffic to websites for illegal SEO purposes; for example,
    to promote malicious apps.
  id: totrans-263
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Clickers that leave fake reviews or change ratings of some apps and services.
  id: totrans-264
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Clickers that buy expensive apps on Google Play, for example, using accessibility
    services to emulate user taps or implementing their own clients to interact with
    the store directly.
  id: totrans-265
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Adware**: These threats aim to monetize custom advertisements shown to users,
    often in an excessive and abusive way.'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Infostealers**: As mobile devices often contain sensitive information, including
    saved credentials, photos, and private messages, it is also possible for malware
    authors to make money from stealing it, for example, by selling it on the underground
    market or extorting users. Another possible option here is cyber espionage.'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Banking trojans**: Sometimes also named infostealers, this malware aims to
    steal users’ banking information to get access to their bank accounts, or manipulate
    payments. The most common ways to do this are by displaying fake windows simulating
    a real banking or popular booking app on top of the real one and letting the user
    enter their credentials there, or by using accessibility services to make the
    real app perform illegitimate transactions. Access to SMS messages on a device
    can be used to bypass the two-factor authentication introduced by some banks.'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ransomware**: As in the PC world, some malware families try to block access
    to certain files or a whole device to illegally push the users into paying a ransom
    in order to restore access. Quite often, this behavior is accompanied by statements
    that the affected user did something wrong (for example, watched illegal content),
    and demanding them to pay a fine, otherwise, the information will become public.'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DDoS**: Multiple infected mobile devices can generate enough traffic to cause
    significant load for the targeted websites.'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Proxy**: Quite rarely used alone, this functionality allows malicious actors
    to use infected devices as a free proxy to get access to particular resources
    and increase anonymity. An example of such a family is **Sockbot**.'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cryptocurrency miners**: This group abuses a device’s calculation power in
    order to mine cryptocurrencies. While the CPU of each device might be not very
    powerful, a large amount of affected devices when put together can generate significant
    profit for attackers. For the affected user, it results in increased traffic usage,
    and the device slows down drastically and excessively heats up, which eventually
    may cause damage.'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some trojans prefer to implement **backdoor** or **RAT** functionality and then
    deliver customizable modules in order to achieve flexibility in extending malware
    functionality.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: It is worth mentioning that not all malware families get their unique names
    based on the actual functionality. Quite often, a shared name describing its propagation
    method is used, for example, **Fakeapp**.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: In terms of propagation, as malware can easily access a victim’s contacts, usually,
    the spreading mechanism involves sending links or samples to people the user knows
    via text, messengers, and email.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: As for getting the actual money, at first, malware authors preferred to get
    it via premium SMS messages and local payment kiosks. Later, with the rise of
    cryptocurrencies, alternative options became an obvious choice for malicious authors
    due to anonymity and an easier setup process, providing users with detailed instructions
    on how to make a payment.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: Collection
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Pure keylogging without screen capturing is not very common for Android malware.
    There are several reasons for this, starting with the fact that, in most cases,
    it is just not needed, and also because of the peculiarities of data input on
    mobile devices. Sometimes high-profile spying malware implements it in a pretty
    creative way. For example, it is possible to keep track of screen touches and
    match them against a pre-defined map of coordinates to deduce the keys pressed.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: An example of a family implementing it is **BusyGasper**, which is backdoor
    malware.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: Defence evasion
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are multiple anti-analysis techniques that mobile malware can incorporate
    in order to protect itself, including the following:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '**An inaccessible location**: A previously mentioned technique where malware
    uses rooting exploits to allow it to deploy itself in locations that are not accessible
    with standard user privileges. Another option is to overwrite existing system
    apps.'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Detecting privilege revocation**: Multiple techniques are used to scare the
    user when permissions are revoked in an attempt to prevent it.'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Detecting antivirus solutions**: In this case, malware keeps looking for
    files associated with known antivirus products and once detected, may display
    a nag window asking for its uninstallation. These kinds of messages are shown
    in a loop and prevent the victim from using the device properly until the requested
    action is taken.'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Emulator and sandbox detection**: Here, the malware checks whether it is
    being executed on the emulated environment or not. There are multiple ways it
    can be done: by checking the presence of certain system files or values inside
    them, such as IMEI and IMSI, build information, various product-related values,
    as well as the phone numbers used. In this case, malware behaves differently depending
    on the result to tamper with automatic and manual analysis. Another popular simple
    technique used to bypass basic sandboxes with an execution time limit is to sleep
    or perform benign actions for a certain period of time.'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Icon hiding**: The idea here is that the user can’t easily uninstall the
    app using an icon. For example, a transparent image with no visible app name can
    be used.'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Multiple copies**: Malware can install itself in various locations in the
    hope that some of them will be missed. In addition, infecting the Zygote process
    allows malware to create multiple copies in the memory.'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Code packing or obfuscation**: As many Android programs are written in Java,
    the same code protection solutions can also be used here. Multiple commercial
    options are available on the market at the moment. This topic has already been
    covered in [*Chapter 9*](B18500_09.xhtml#_idTextAnchor946), *Reversing Bytecode
    Languages – .NET, Java, and More*.'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In previous chapters, we covered state-of-the-art malware that aims to get more
    control over the operating system in order to perform more advanced tasks, such
    as hiding files and processes from monitoring software and amending data at a
    lower level. These approaches can be applied to mobile operating systems as well.
    While still not actively used by malware due to deployment complexity, there are
    several open source projects proving that it is possible.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: One of them is the `sys_call_table`. The final goal here is to hide the presence
    of a sample at a low level.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: Now, it’s time to summarize everything we have learned so far and apply it to
    practice to be able to understand the functionality of Android malware samples.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: Static and dynamic analysis of threats
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this stage, we have enough knowledge to start analyzing actual malware. For
    static analysis, the process and tools used will be mostly the same for different
    versions of the Android OS (regardless of whether it is based on the old DVM or
    new ART technology); the differences will be in the dynamic analysis techniques
    used. Now, it is time to get our hands dirty and become familiar with the tools
    that can facilitate this process.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: Static analysis
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Generally, static analysis of bytecode malware involves either disassembling
    it and digging into the bytecode instructions or decompiling to the original language
    and exploring the source code. In many cases, the latter approach is preferable
    wherever possible, as reading the human-friendly code reduces the time the analysis
    takes. The former approach is often used when decompiling doesn’t work for whatever
    reason, such as a lack of up-to-date tools or because of anti-reverse-engineering
    techniques implemented in the sample.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: Here are some of the most commonly used tools for static analysis of Android
    malware.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: Disassembling and data extraction
  id: totrans-297
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'These tools aim to restore Dalvik assembly from the compiled bytecode:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '`.smali` file extensions.'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There were a handful of changes to the format between version 1 and 2 of SMALI
    files. To convert existing SMALI files to the new format, you can assemble the
    old ones with the latest Smali tool, version 1, and then disassemble them with
    the latest Baksmali tool, version 2.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '**Apktool**: A wrapper around the Smali tool; it provides the functionality
    to easily process APK files. Its interface looks as follows:'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 13.10 – The interface of the Apktool'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.10_B18500.jpg)'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.10 – The interface of the Apktool
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: 'Apart from these, there are other online and desktop solutions built on top
    of these two, providing convenient UIs and extra features, for example, **APK
    Studio**:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '`aapt dump badging <path_to_apk>`, and to parse `AndroidManifest.xml`, use
    `aapt dump xmltree <path_to_apk> AndroidManifest.xml`'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**oat2dex** (part of **SmaliEx**): A very useful tool for extracting DEX bytecode
    from older ELF files, storing it as part of the OAT data so that it can be analyzed
    as usual.'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**vdexExtractor**: This tool can be used to extract DEX bytecode from VDEX
    files, as modern OAT files don’t store it anymore.'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**LIEF**: This cross-platform library provides plenty of functionality to parse
    and modify Android files of various formats.'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Androguard**: A versatile toolset combining multiple tools to perform various
    types of operations, including disassembling, parsing, and decoding of various
    files.'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While bytecode assembly can definitely be used for static analysis purposes
    on its own, many engineers prefer to work with decompiled code instead to save
    time. In this case, decompiling tools are extremely useful.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: Decompiling
  id: totrans-312
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Instead of restoring the assembly instructions, this set of tools restores
    the source code, which is usually a more human-friendly option:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: '**JADX**: A DEX to Java decompiler that provides both a command-line and a
    GUI tool to obtain something close to the original source code in the Java language.
    In addition, it provides a basic deobfuscation functionality. Here is how its
    interface looks:'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 13.11 – A decompiled Android sample in JADX'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.11_B18500.jpg)'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.11 – A decompiled Android sample in JADX
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: '**AndroChef**: This commercial decompiler supports both Java and Android files
    and provides a handy GUI to go through the results.'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**JEB decompiler**: Another powerful commercial disassembling and decompiling
    solution, this supports both Dalvik and machine code.'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**dex2jar**: While not exactly a decompiler, this tool allows engineers to
    convert DEX files to JARs. After that, it becomes possible to use multiple Java
    decompilers to obtain Java source code, as already discussed in [*Chapter 9*](B18500_09.xhtml#_idTextAnchor946),
    *Reversing Bytecode Languages – .NET, Java, and More*.'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ghidra**: In addition to native executables, this powerful toolset also supports
    Android apps by converting them into JARs and can be used to facilitate static
    analysis for this platform.'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once obtained, the source code can be analyzed in any IDE or text editor with
    syntax highlighting that supports it.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: Now, it is time to explore the options engineers have to perform dynamic analysis.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic analysis
  id: totrans-324
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Effective dynamic analysis requires either some sort of emulation or remote
    debugging, as many mobile devices tend to have relatively small native screens
    and basic input capabilities.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: Android Debug Bridge
  id: totrans-326
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Android Debug Bridge** (**ADB**) is a versatile command-line tool that lets
    users interact with mobile devices from the PC, providing a variety of actions.
    It is a part of Android SDK Platform Tools and consists of three parts:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: A client running on the PC, providing an interface to enter commands.
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A daemon (**adbd**) executing entered commands on the mobile device. It runs
    as a background process on all devices.
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A server running on the PC that manages communication between the client and
    the daemon.
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the physical devices, ADB can be allowed by enabling the **USB Debugging**
    option under **Developer options** in **Settings**. On a modern Android OS, this
    option is hidden by default and can become visible by tapping the **Build number**
    option (usually, can be found in **Settings** | **About phone**) multiple times
    and then returning to the previous screen. In addition to real devices, ADB can
    also recognize and work with an Android emulator without any changes required.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: In addition to accessing the device via USB, wireless interaction via Wi-Fi
    is also possible by first issuing the `adb tcpip <port>` command via USB, disconnecting
    the device, and using the `adb connect <ip_address>:<port>` command.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some examples of other command-line options available:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: '`adb devices`: Lists the attached devices.'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 13.12 – Adb seeing an emulated device'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.12_B18500.jpg)'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.12 – Adb seeing an emulated device
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: '`adb kill-server`: Resets the adb host'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`adb install <path_to_apk>`: Sideloads the app using its APK file'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`adb pull` or `adb push`: Moves files between the mobile device and the PC'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`adb root` or `adb unroot`: Restarts the `adbd` daemon with or without root
    permissions (not intended to be used in production builds)'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`adb forward`: Forwards the specified port from the host to the device:'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Example: `adb forward tcp:1234 tcp:5678` – forwards the host’s port `1234`
    to the device’s port `5678`'
  id: totrans-343
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`adb shell [<command>]`: Creates a remote interactive shell or runs a command
    within the shell'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Apart from traditional Linux commands, such as `ls` or `cat`, the Android shell
    supports multiple custom commands. Here are some examples:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: '`screencap <filepath>`: Takes a screenshot and save the result on the device.'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 13.13 – Using the screencap command'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.13_B18500.jpg)'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.13 – Using the screencap command
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: '`screenrecord <filepath>`: Performs screen video recording until *Ctrl + C*
    is pressed.'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`monkey <package_name>`: Originally designed to perform random activities and
    this way, stress-test applications, it can also be used to launch desired apps
    by using the `adb shell monkey -p <package_name> 1` syntax.'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`input keyevent <num>`: Initiates the specified key event. Here are a few examples
    of them and the corresponding numbers:'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`3` – presses the `4` – presses the `64` – opens a browser'
  id: totrans-353
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`207` – opens contacts'
  id: totrans-354
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The complete up-to-date list can be found by looking at the `KeyEvent` class
    in the official Android documentation.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: To pass arguments requiring quotes as part of the command, you will have to
    surround the quoted string with a pair of different quotes (either single or double).
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, ADB can be used to issue commands to additional modules:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: '`adb shell pm list packages` – lists the names of all packages. Use the `–f`
    option to also get the paths of the corresponding APKs. Third-party apps can be
    filtered out using the `–3` argument.'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`adb shell am start -a android.intent.action.MAIN -n <package_name>/<main_activity>`
    – launches the main activity of an app. The most reliable way to specify the main
    activity is to provide the full path to it within the package (such as `adb shell
    am start -a android.intent.action.MAIN -n com.google.android.calendar/com.android.calendar.LaunchActivity`).*   `adb
    shell dpm set-active-admin -user current <component>` – sets the specified component
    as an active admin, usually to enforce security policies.'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the commands can be found in the comprehensive official documentation.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: Emulators
  id: totrans-362
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As with any other platform, emulators aim to facilitate dynamic analysis by
    emulating the executed instructions without the need to use real devices. There
    are several third-party solutions aiming to provide easier access to Android apps
    and games, for example, BlueStacks. However, for reverse-engineering purposes,
    solutions that are more focused on giving developers the ability to create and
    debug apps generally provide better options. They include the following:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: '**Android Emulator**: The official Android Emulator can be installed as part
    of the official **Android Studio** or using the command-line **SDK Manager**.
    It provides almost all the capabilities of real physical devices and comes with
    predefined sets of configurations aiming to simulate various mobile devices (whether
    a phone, tablet, and wearable) on the PC.'
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To install the emulator without Android Studio (using only the command line),
    follow these steps:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: If you have never installed the Android SDK before, create an empty directory
    somewhere where you would like the whole Android SDK to be located and create
    an environment variable, `ANDROID_HOME`, to point to this directory.
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Download the Android command-line tools, unzip them, and move the whole extracted
    directory, `cmdline-tools`, (not its content!) to the Android SDK folder.
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inside `$ANDROID_HOME/cmdline-tools`, create a directory called `latest`, and
    move the whole content of `cmdline-tools` there.
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the `$ANDROID_HOME/cmdline-tools/latest/bin` directory, you can find the
    `sdkmanager` tool. Use this method to get the emulator and platform tools, including
    `adb`:'
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You can list all the available Android system images by running the following
    command:'
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'For example, we decided to emulate Android 12, corresponding to the API level
    of `31`. Use the following command to download a system image that will be emulated
    on an x86-64 machine, together with the corresponding packages:'
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-374
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Important note
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: Using `google_apis_playstore` images will enable access to Google Play but the
    `adb root` command will not work on them!
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following command to create a virtual device linked to the chosen system
    image (no need to create a custom hardware profile). In this case, the name used
    is `avd_31_noplay`, but it can be any other name:'
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, everything is ready to run the emulator, located in the `$ANDROID_HOME/emulator`
    directory, using the following command:'
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-380
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Important note
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: When running an emulator on the VM, you may be prompted about hardware acceleration
    – to address it, enable support for Intel VT-x in the VM’s settings.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how the result will look:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.14 – Running the Android Emulator on a VM'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.14_B18500.jpg)'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.14 – Running the Android Emulator on a VM
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: The Emulator also allows us to create and restore snapshots containing the entire
    state of the emulated device.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: '**VMWare, VirtualBox, or QEMU**: These versatile solutions can be used to run
    an **Android-x86** image and perform dynamic analysis in a similar way to what
    would be done on the Linux VM. Keep in mind that Android-x86 is usually a few
    versions behind the latest Android release:'
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 13.15 – Running Android-x86 on a VM'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.15_B18500.jpg)'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.15 – Running Android-x86 on a VM
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: Other ways to get access to Android systems include cloud-based **Genymotion**
    and container-based **anbox** solutions.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: Once we have the environment to run Android programs, we need debuggers to do
    it in a controlled way.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: Debuggers
  id: totrans-394
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once the app of interest is decompiled back to Java code, parts of it can be
    debugged as with usual source code in the IDE supporting it, for example, Android
    Studio. If you are using a physical device instead of an emulator, don’t forget
    to enable USB debugging. In addition, the code should include the `debuggable
    true` option in its build configuration.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, it is required to debug the native Dalvik instructions or whole apps.
    Luckily, there are tools that can facilitate this process. One that deserves particular
    attention is **smalidea**. It is a plugin for IntelliJ IDEA (or Android Studio,
    which is based on it) allowing for step-by-step execution of the analyzed code.
    This project belongs to the Smali authors and can be found with the corresponding
    assembler and disassembler tools.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, Android also provides tools to debug native code. Here are the
    instructions on how to attach at the start:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: First, obtain the Android NDK to get `lldb-server` prebuilt, as well as the
    `lldb` tools (in the past, the `gdbserver` and `gdb` tools were used)
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then, push the `lldb-server` executable to the device, for example, to the
    `/data/local/tmp` directory, and make it executable:'
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-400
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Set up port forwarding:'
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-402
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, we have two options: either to use `lldb-server` in `gdbserver` or the
    `platform` mode. Let’s provide examples for both.'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the `gdbserver` mode involves the following:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: 'Start the debugger server on the Android device – the sample of interest should
    be copied there as well:'
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-406
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Launch `lldb` on the host and connect to the debugger server running on the
    device via the forwarded port:'
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-408
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Using the `platform` mode involves the following:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: 'Start the debugger server on the Android device – no need to copy the sample
    there:'
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-411
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Important note
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: Here, we have to provide the `--gdbserver-port` argument, otherwise, `lldb`
    won’t be able to copy a sample from the host machine to the Android device later.
    An additional `adb forward` command is required to forward this auxiliary port.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: 'Launch `lldb` on the host, connect to the debugger server via the forwarded
    port, and launch the sample – it will be copied to the Android device automatically:'
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-415
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here is how the successful connection will look on the debugger server side:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.16 – A successful connection to the debugger server running on
    the Android emulator'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.16_B18500.jpg)'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.16 – A successful connection to the debugger server running on the
    Android emulator
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: Apart from that, IDA is shipped with a set of proprietary debugger servers for
    Android supporting both 32- and 64-bit versions of x86 and ARM platforms (`android_server`
    or `android_server64`).
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: 'App startup can be debugged in the following way:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: Go to `jdb` debugger to be attached.
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start the app from the launcher or using the console, wait for it to load.
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Attach a debugger such as `lldb`, set the required breakpoints, and continue
    the execution.
  id: totrans-424
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Attach the `jdb` debugger to let the app run:'
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-426
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now, let’s talk about behavioral analysis.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: Behavioral analysis and tracing
  id: totrans-428
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As with many other platforms, the **fsmon** tool can be used to monitor file
    operations on Android. Here is an example of it being used to detect the creation
    of a new file:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.17 – Testing fsmon on the Android Emulator by recording test file
    creation'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.17_B18500.jpg)'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.17 – Testing fsmon on the Android Emulator by recording test file
    creation
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: In terms of APIs, an **AppMon** solution includes a set of components to intercept
    and manipulate API calls. It is based on the **Frida** project, which also provides
    its own versatile tools, such as **frida-trace** (working together with **frida-server**).
    One more tool based on Frida is **Objection**, which provides access to multiple
    options including various memory-related tasks, heap manipulation, and the execution
    of custom scripts.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: 'For native programs, the standard `strace` tool can also be used to monitor
    system calls. As you can see in the following screenshot, its interface is identical
    to the one found on Linux systems:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.18 – Using strace for behavioral analysis on the Android Emulator'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.18_B18500.jpg)'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.18 – Using strace for behavioral analysis on the Android Emulator
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: Speaking about recording network traffic, the standard `tcpdump` tool can run
    on the device for this purpose and is generally the easiest-to-use solution. Wireshark
    creators also supply a tool called **androiddump** to provide interfaces to capture
    on Android devices (which generally needs to be built separately). In addition,
    as long as the malicious sample is decompiled, it also becomes possible to embed
    various libraries intercepting API calls, for example, **AndroidSnooper** to intercept
    HTTP traffic.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: Once we know which tools can be used for the analysis, let’s summarize the analysis
    workflow.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: The analysis workflow
  id: totrans-440
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here is an example of the workflow, describing how the Android sample analysis
    can be performed:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: '`boot.oat` file.'
  id: totrans-442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Application`’s subclass from the `android:name` attribute of the `<application>`
    element (if present)'
  id: totrans-443
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Decompilation or disassembling**: It always makes sense to try to get the
    decompiled source code, as it is usually much easier to read it and perform dynamic
    analysis, including alteration if necessary. If decompilation doesn’t work and
    some anti-reverse-engineering technique is expected, then the code can be disassembled
    so that the tampering logic can be amended. Native code in ELF binaries can be
    processed in the same way as described in [*Chapter 11*](B18500_11.xhtml#_idTextAnchor1188),
    *Dissecting Linux and IoT Malware*.'
  id: totrans-444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`onCreate` methods of the main activities, and the previously mentioned optional
    `Application`’s subclass specified in the manifest, as the app execution starts
    there.'
  id: totrans-445
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Deobfuscation and decryption**: If it has been confirmed that the sample
    is obfuscated, at first, it’s worth trying to figure out whether it is a known
    Java solution and whether any ready deobfuscators exist. If not, then generic
    method renaming will be helpful. There are multiple tools that can do this; refer
    to [*Chapter 9*](B18500_09.xhtml#_idTextAnchor946), *Reversing Bytecode Languages
    – .NET, Java, and More*.'
  id: totrans-446
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Behavioral analysis**: It may make sense to execute a sample in the emulator
    with your behavioral analysis tools of choice enabled to quickly get an idea of
    the potential functionality. If an emulator detection technique is implemented,
    it’s usually pretty straightforward to identify it in the code and amend the sample
    to exclude these checks.'
  id: totrans-447
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Debugging**: Sometimes, it’s hard to understand certain blocks of functionality,
    particularly ones where malware heavily interacts with the operating system. In
    this case, proper step-by-step debugging may be required to speed up the analysis.
    Always use emulators supporting snapshot creation, so that it is possible to go
    back and quickly reproduce the same situation as many times as necessary.'
  id: totrans-448
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Obviously, each case is unique, and depending on circumstances, the selection
    of actions and their order may vary. Malware analysis is also an art and often
    requires a certain amount of creativity in order to achieve results in a prompt
    way.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-450
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about the most important aspects of Android’s internals,
    covering various runtime environments implemented in different versions of it.
    In addition, we became familiar with the associated file formats and went through
    the syntax of the bytecode instructions.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: Then, we dove deeper into the world of modern mobile malware, familiarizing
    ourselves with its different types and the associated behavior. We also learned
    how attackers can bypass Android security mechanisms in order to achieve their
    goals. Finally, we learned about various reverse-engineering tools aiming to facilitate
    static and dynamic analysis, and established guidelines on how and when they can
    be used.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: Equipped with this knowledge, you can better track threat actors that are trying
    to penetrate Android devices and promptly mitigate the risks. In addition, the
    set of skills obtained can be used during the incident response process to properly
    understand the logic of the attacks to improve the overall security posture.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: This is the last chapter of this book – we hope you enjoyed it! As a next step,
    we recommend putting your new knowledge into action by practicing analyzing various
    types of malware and sharing your results with the community. Malware analysis
    is a never-ending journey. We really hope this book will help many novice and
    experienced engineers to analyze modern and future threats more efficiently and
    eventually make the world a safer place.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
