- en: '11'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Analyzing Compromised Containers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Until this chapter, we looked at some standard methods and techniques to acquire
    and analyze forensic images of **virtual machines** (**VMs**) and cloud services.
    However, developing and analyzing a containerized environment introduces an entirely
    new challenge.
  prefs: []
  type: TYPE_NORMAL
- en: In today’s technology landscape, containerization and Kubernetes orchestration
    have become fundamental to modern application deployment; therefore, ensuring
    these containers’ security is paramount. Containers offer tremendous benefits
    in terms of efficiency and scalability, but they also present new challenges,
    with security being a top concern.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter aims to understand containers’ architecture and how containers
    are managed and orchestrated via Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will be looking at the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What are containers?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detecting and analyzing compromised containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are containers?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Containers** are lightweight, standalone, and executable packages containing
    everything needed to run a piece of software, including the code, runtime, system
    tools, libraries, and settings. They are designed to provide consistency across
    different computing environments, from development and testing to deployment in
    production, by encapsulating the application and its dependencies in a containerized
    environment.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Some critical advantages of containerized deployments include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Isolation**: Containers use operating system-level virtualization to create
    isolated environments. Each container shares the same OS kernel as the host but
    runs independently, ensuring separation from other containers on the same system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Portability**: Containers are highly portable, allowing you to run the same
    application consistently across various platforms, such as Linux distributions
    or cloud providers. Containerization technologies such as Docker and container
    runtimes enable this portability.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lightweight**: Containers are lightweight compared to traditional VMs. They
    consume fewer system resources because they do not require a full OS and only
    package the application and its dependencies.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resource efficiency**: Containers start and stop quickly, making them efficient
    for scaling applications up and down dynamically in response to changes in workload.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Immutable infrastructure**: Containers are typically created from predefined
    images. When you want to update an application, you build a new container image
    with the changes, ensuring consistency and repeatability in your infrastructure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Orchestration**: Container orchestration platforms such as Kubernetes provide
    automated management of containerized applications, including scaling, load balancing,
    and self-healing, making them suitable for deploying and managing microservices-based
    architectures.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Version control**: Container images can be versioned, making it easy to roll
    back to the previous version in case of issues. This supports a more controlled
    software development and deployment process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security isolation**: Containers offer a level of security isolation. However,
    it’s essential to configure and manage them correctly to ensure proper security
    practices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DevOps and CI/CD**: Containers are a fundamental tool in **DevOps** practices,
    as they facilitate **continuous integration and continuous deployment** (**CI/CD**)
    pipelines, allowing for streamlined and automated software development and delivery
    processes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Microservices**: Containers are often used in a microservices architecture,
    where applications are broken down into small, independent services that can be
    easily deployed and scaled individually.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker versus Kubernetes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Although Docker and Kubernetes are the most popular containerization technologies,
    they serve different purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Docker**: **Docker** is a containerization platform that allows developers
    to package applications and their dependencies into a single, portable container
    unit. Containers are lightweight and efficient, providing a consistent environment
    for running applications across different systems. Docker simplifies the development
    process by encapsulating everything an application needs to run, ensuring it runs
    consistently from a developer’s laptop to a production server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker’s ease of use and user-friendly **command-line interface** (**CLI**)
    have made it immensely popular among developers and operations teams. It’s a valuable
    tool for local development, creating container images and sharing them via Docker
    Hub or private registries. Docker’s primary focus is on application packaging
    and distribution, and it’s often used as the foundation for building container
    images that can be run in various environments.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Kubernetes**: **Kubernetes**, often abbreviated as **K8s**, is an open source
    container orchestration platform that manages the deployment, scaling, and operation
    of containerized applications. While Docker is primarily concerned with packaging
    and running individual containers, Kubernetes takes a higher-level approach by
    orchestrating multiple containers into groups or services. It automates tasks
    such as load balancing, scaling, rolling updates, and self-healing, making it
    well suited for complex and distributed application architectures.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kubernetes is particularly valuable for microservices-based applications where
    multiple containers must work together seamlessly. It abstracts the underlying
    infrastructure and provides a unified API for managing containers across various
    environments, such as on-premises servers, public clouds, or hybrid setups. Kubernetes
    ensures **high availability** (**HA**), **fault tolerance** (**FT**), and resource
    efficiency, making it a cornerstone in modern containerized application deployment.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In short, Docker and Kubernetes are rather complementary technologies. Docker
    is ideal for creating and packaging individual containers, while Kubernetes is
    the go-to solution for orchestrating, scaling, and managing those containers within
    a larger ecosystem. They can be used together, with Docker providing container
    images deployed and orchestrated by Kubernetes, allowing organizations to build
    and manage resilient, scalable, and efficient containerized applications. The
    choice between Docker and Kubernetes largely depends on your specific needs and
    the application lifecycle stage you’re addressing.
  prefs: []
  type: TYPE_NORMAL
- en: Containers have revolutionized how applications are developed, deployed, and
    managed, providing a consistent and efficient way to package and run software
    across various environments. In the next section, we will look into the types
    of containers and some of the use cases they serve.
  prefs: []
  type: TYPE_NORMAL
- en: Types of containers and their use cases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As indicated in the previous section, containers are packaged applications
    in various forms. Next are some forms of containers and their potential use cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Docker containers**: Docker containers are perhaps the most well-known and
    widely used type. Docker provides a platform for developing, shipping, and running
    container applications. Docker containers are highly portable and easy to manage,
    making them suitable for various use cases.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Linux Containers (LXC)**: LXC is an operating-system-level virtualization
    method that uses the Linux kernel’s groups and namespaces to create isolated environments.
    LXC containers are less user-friendly than Docker but offer more flexibility and
    control, making them suitable for specific use cases where customization is crucial.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rkt` (pronounced *rocket*) is an alternative container runtime that focuses
    on security and simplicity. It is designed to be more secure and lightweight than
    Docker and is used in some Kubernetes deployments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`containerd` is an industry-standard core container runtime used by various
    container platforms and orchestration systems. It is designed to be a simple and
    reliable runtime for containers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Podman containers**: Podman is an open source container management tool compatible
    with Docker but offers a more secure and rootless container experience. It is
    suitable for scenarios where you need Docker compatibility with added security.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**OpenVZ containers**: OpenVZ is a containerization technology that provides
    a lightweight form of virtualization. It differs from traditional containers,
    as it uses a shared kernel and provides more isolation than typical containers
    but less than full virtualization.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**FreeBSD jails**: FreeBSD jails are similar to Linux containers but are specific
    to the FreeBSD operating system. They provide lightweight virtualization on FreeBSD
    systems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Windows containers**: Windows Server also supports containerization, while
    most containers are associated with Linux. Windows containers can run Windows-based
    applications within isolated environments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`systemd-nspawn` is a containerization tool provided by the `systemd init`
    system. It offers lightweight OS-level virtualization, and it’s commonly used
    for development and testing environments on Linux systems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Kata Containers**: Kata Containers is an open source project that combines
    the security benefits of VMs with the efficiency and speed of containers. It’s
    designed for workloads that require a high level of isolation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following are some use cases enterprises typically leveraged to deploy
    a containerized environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Application packaging and distribution**: Containers package applications
    and all their dependencies into a single, portable unit. This ensures consistent
    and reliable application deployment across different environments, from development
    to production.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Microservices architecture**: Containers are central to microservices, where
    applications are broken down into small, independent services. Each microservice
    runs in its own container, allowing scalability, flexibility, and easy maintenance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Development and testing**: Developers use containers to create isolated development
    and testing environments that mirror production conditions. This ensures that
    applications work as expected and eliminates the “*it works on my* *machine*”
    problem.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CI/CD**: Containers enable streamlined CI/CD pipelines. Developers package
    their code and dependencies in containers, which are tested, deployed, and scaled
    automatically, improving software delivery speed and reliability.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Multi-cloud and hybrid cloud deployment**: Containers can run consistently
    across cloud providers and on-premises environments. This makes them suitable
    for multi-cloud and hybrid cloud strategies, allowing for cloud-agnostic application
    deployment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Isolation and security**: Containers provide lightweight isolation between
    applications, enhancing security and minimizing the risk of conflicts or vulnerabilities
    between them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Legacy application modernization**: Containers can wrap legacy applications,
    making them more portable and easier to manage. This helps organizations modernize
    existing systems without rewriting code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scalability and load balancing**: Containers can be quickly scaled up or
    down in response to changing workloads, making them ideal for applications that
    require elastic scaling and efficient resource utilization.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stateful and statelessness**: Containers can be used for stateful and stateless
    applications. Stateful applications such as databases can run in containers, and
    stateless services can scale horizontally.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resource efficiency**: Containers are lightweight, requiring fewer system
    resources than traditional VMs, resulting in better resource utilization and cost
    savings.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Orchestration**: Container orchestration platforms such as Kubernetes provide
    automated management of containers. They handle scaling, load balancing, and self-healing,
    making them suitable for complex application architectures.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**HA and disaster recovery (DR)**: Containers can be orchestrated across multiple
    nodes and data centers to ensure HA and DR capabilities, reducing downtime and
    data loss.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Service discovery and load balancing**: Containers can be easily integrated
    with service discovery and load balancing solutions to ensure efficient communication
    and distribution of traffic among services.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Content delivery and content delivery networks (CDNs)**: CDNs use containers
    to cache and distribute content globally, reducing latency and improving content
    delivery performance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data processing and analytics**: Containers are used for running data processing
    and analytics workloads, providing a scalable and isolated environment for data-related
    tasks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Internet of Things (IoT) and edge computing**: Containers can be employed
    for deploying and managing applications on edge devices and IoT devices, bringing
    computation closer to data sources.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Desktop virtualization**: Containers can be used for desktop virtualization,
    allowing users to run isolated desktop environments with specific applications
    and configurations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the following few sections, we will look into how to analyze a compromised
    container, what steps are required, and which forensic collection mechanism can
    be applied to collect forensic images of a containerized environment securely.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting and analyzing compromised containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most organizations operate container architectures through Kubernetes since
    it offers many more scalable options and flexibility. Before we dive deeper into
    container analysis, it is essential to understand the components of Kubernetes,
    as they will play a pivotal role in your investigations.
  prefs: []
  type: TYPE_NORMAL
- en: About the Kubernetes orchestration platform
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following screenshot illustrates the basic architecture of a Kubernetes
    cluster; in summary, as we know, Kubernetes is an orchestration framework that
    manages one or more nodes that run one or more containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.1 – Simple Kubernetes architecture](img/00130.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.1 – Simple Kubernetes architecture
  prefs: []
  type: TYPE_NORMAL
- en: 'For the Kubernetes cluster, you need a master node that controls and orchestrates
    the cluster’s operations and worker nodes that run the pods and tasks assigned
    by the master node. Here are some critical components of a Kubernetes cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '`kubectl` command. The API server operates as a RESTful API server, meaning
    it’s a stateless protocol, with no information on previous requests being retained
    by the server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scheduler**: The scheduler is responsible for determining the optimal placement
    of pods onto available nodes in a cluster. Its primary function is to make intelligent
    scheduling decisions based on resource requirements, node affinity, and user-defined
    constraints. By evaluating the available resources on each node, the scheduler
    aims to balance the workload across the cluster, ensuring efficient resource utilization.
    The scheduler also supports features such as pod priority, preemption, affinity
    rules, and taints/tolerations, providing flexibility and customization for workload
    distribution. Additionally, Kubernetes allows for the creation of custom schedulers
    to address specific deployment requirements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Controller manager**: One of the core components of Kubernetes architecture,
    it is responsible for managing various controllers that regulate the state of
    the cluster. Each controller is a separate process responsible for monitoring
    and reconciling the actual state of cluster objects with their desired state,
    as defined in the Kubernetes API server. Key controllers managed by the controller
    manager include the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Replication controller**, which ensures the specified number of pod replicas
    are running'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Node controller**, which handles node lifecycle and the service account'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Token controller**, managing the lifecycle of service accounts and API access
    tokens'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The controller manager enhances the self-healing capabilities of Kubernetes
    by continuously monitoring and adjusting the cluster to maintain the desired configuration,
    ensuring HA and resilience of containerized applications.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`etcd` is a distributed key-value store central to Kubernetes, serving as the
    primary data repository for cluster configuration and state. Employing the `etcd`
    ensures strong consistency and HA across distributed nodes, providing reliability
    and FT. It plays a vital role in cluster coordination, enabling components such
    as the API server and controller manager to synchronize and share real-time information.
    Providing support for features such as data backup, secure communication, and
    a watch mechanism for dynamic updates, `etcd` contributes to the resilience and
    efficiency of Kubernetes clusters, serving as a critical foundation for managing
    containerized applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`containerd`) to manage the containers on the node, implementing the desired
    state described in the pod specifications. Additionally, the kubelet performs
    health checks on the containers, restarts failed containers when necessary, and
    reports the node’s status back to the control plane.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`localhost`. This design allows them to share data and dependencies easily.
    Pods serve as the basic building blocks for deploying applications on Kubernetes,
    and they encapsulate one or more containers, along with shared storage resources
    and options for how the containers should be run. The Kubernetes API server manages
    pods and can be replicated, scaled, and updated to meet the dynamic demands of
    containerized applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kube-proxy` is a vital component in Kubernetes responsible for network proxying
    and load balancing. Operating at the service level, it facilitates communication
    between pods and services by maintaining network rules and updating them based
    on changes in the cluster’s services and endpoints. With capabilities for service
    discovery, load balancing, and managing NodePort services, `kube-proxy` ensures
    efficient and reliable network connectivity within the cluster. It abstracts the
    complexities of networking, playing a pivotal role in enabling seamless communication
    between different components of containerized applications in a Kubernetes environment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can explore the Kubernetes architecture by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '![Figure 11.2 – List of pods associated with the GKE cluster system (no application
    pods)](img/00149.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.2 – List of pods associated with the GKE cluster system (no application
    pods)
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will focus on extracting logs for investigations. Now
    that we understand the Kubernetes architecture, accessing these logs will be much
    easier and simpler.
  prefs: []
  type: TYPE_NORMAL
- en: Acquiring forensic data and container logs for analysis
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have an overview of key components of the Kubernetes architecture,
    let us look at how investigators can obtain logs/artifacts from a cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Container logs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Various logs are typically available within Kubernetes clusters; some are operational
    logs, meaning they are related to the cluster’s health, while some are associated
    with applications running within the containers. These can be specifically useful
    for **Digital Forensics and Incident Response** (**DFIR**) teams to investigate
    nefarious activities involving a Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand logs, we break them down into two categories—operational and
    security logs—along with their use cases. You will notice that some of the logs
    offer operational insights and security logs:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Operational logs**:'
  prefs: []
  type: TYPE_NORMAL
- en: '**API server logs**: Reflecting upon the Kubernetes architecture, the API server
    plays a crucial role in ensuring the Kubernetes cluster operates efficiently.
    API server logs provide insights into API-related activity, including requests,
    responses, and authentication details. Specifically, API server logs help monitor
    API server health, track user activity, and troubleshoot API-related issues.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can access API server logs using the following command:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Controller manager logs**: Provides logs related to controller activities,
    such as node, replication, and cluster interactions. Useful for monitoring the
    controller’s health, tracking controller decisions, and understanding replication
    and service-related events. You may access events related to the controller manager
    through the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Scheduler logs**: Records logs associated with scheduling decisions made
    by the Kubernetes scheduler, such as pod placement. This log helps understand
    and monitor workload distribution, scheduling decisions, and node utilization.
    You can access logs specific to the Kubernetes controller through the following
    command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**kubelet logs**: Provides details about pod lifecycle events, container runtime
    interactions, and heartbeats; logs associated with the kubelet provide insights
    into pod health and runtime issues. You can access logs related to a particular
    pod using the following command; note that this command will fetch operational
    events related to running the pod and not the application logs running within
    the pod:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'etcd nodes. etcd logs provide critical insights into monitoring etcd health,
    tracking cluster state changes, and understanding etcd-related issues. You can
    access etcd logs using a similar command:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`kubectl` command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Ingress controller logs**: Instrumental in investigating issues when external
    network traffic does not connect to the intended Kubernetes pod. Typical reasons
    could be misconfigurations on the ingress controller itself. Ingress controllers
    are also responsible for terminating SSL/TLS connections; monitoring these events
    will provide crucial insights into service disruptions due to expired certificates.
    Similar to accessing other logs, ingress controller logs can be accessed through
    the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Security logs**:'
  prefs: []
  type: TYPE_NORMAL
- en: '**API server logs**: From a DFIR perspective, investigators can look into API
    server logs to identify unauthorized access attempts or authentication failures.
    You can also use API server logs to monitor for suspicious changes to critical
    resources such as pods through API server logs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**kubelet logs**: You can use kubelet logs to look for container anomalies.
    kubelet logs can provide insights into unexpected behaviors or network activity.
    You can also use kubelet logs to investigate node-level activities, resource exhaustion,
    or unusual activities.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`etcd` logs to identify data corruption or inconsistencies.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tcpdump` to verify the network traffic activity using this command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Network plugin logs provide insights into malicious network traffic between
    pods and identify evidence of lateral movements.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: All in all, Kubernetes provides a framework to access these logs within each
    of the pods; however, if the cluster is running on a cloud platform, investigators
    can also leverage the native log viewer provided by each of the CSPs to quickly
    access the logs without accessing the logs directly via the cluster. In the following
    sections, we will look into both perspectives of accessing logs directly via the
    cluster and using the CSP’s logging console to access Kubernetes cluster logs
    for investigation.
  prefs: []
  type: TYPE_NORMAL
- en: Examining the container runtime
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s say you now have a Kubernetes cluster running on the cloud and a pod
    (applications) setup exposed to the internet accepting user connections. To explain
    the investigative approach, we are going to define a situation. We have a Kubernetes
    cluster deployed on Google Cloud, with WordPress and a MySQL server deployed as
    pods. As outlined in the next screenshot, we have three pods that frame the part
    of the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.3 – Pods under the GKE cluster](img/00167.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.3 – Pods under the GKE cluster
  prefs: []
  type: TYPE_NORMAL
- en: These pods are configured so that MySQL will store the contents of the WordPress
    blog and authentication information. As investigators, we are tasked to investigate
    brute-force attempts on the MySQL server.
  prefs: []
  type: TYPE_NORMAL
- en: Now, there are multiple ways to address this. The most popular method is using
    Google’s Log Explorer. While we walk through an investigation using a cloud tool,
    you can perform similar tasks with other CSPs as long as Kubernetes logs are configured
    to be ingested within the CSPs’ cloud logging tools. Currently, there are two
    ways to investigate/gain access to logs. One is via Log Explorer, and the other
    is via the command line. It’s up to the investigators to extract the logs and
    analyze them. We will explore both approaches and determine outcomes. Before investigating
    Kubernetes, investigators must understand how the organization has deployed the
    Kubernetes cluster and its architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Option 1 – Log Explorer
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Once investigators can access Log Explorer, we can directly start pinpointing
    activities relevant to the WordPress and MySQL servers. Remember that WordPress
    is a frontend tool, while the MySQL server provides the backend database as part
    of the complete application stack.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Through initial triage, we know that there were brute-force attempts; the resource
    usage dashboard can validate this. The following sample screenshot shows the general
    resource metrics associated with the Kubernetes cluster that highlight the increased
    resource usage:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.4 – Kubernetes cluster resource usage](img/00186.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.4 – Kubernetes cluster resource usage
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have established the basics, we jump onto the Log Explorer page. If
    you are familiar with querying Log Explorer, you can query the logs in the cluster’s
    `default` namespace and where the container name is not `wordpress`. Next is the
    search query snippet that gathers all logs not associated with WordPress:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Typically, brute-force attempts can be identified through a series of failed
    logins followed by successful login attempts. We will modify the preceding query
    to pinpoint the investigator’s failed MySQL access attempts. As investigators,
    if we are unfamiliar with Google’s Log Explorer query capabilities, we can always
    click and select appropriate filters, and the query will automatically update
    itself:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once you filter down the logs, you can quickly pinpoint logs associated with
    brute-force attacks. The next screenshot demonstrates the outcomes of the analysis
    using Log Explorer. In the screenshot, you can see multiple failed login attempts
    against MySQL before a successful one. Depending upon the deployed container,
    some logs may also collect granular information. In this case, we can use various
    usernames being tried by the threat actor before successfully connecting to the
    server using the `wp-admin` account:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.5 – Analysis of brute-force attacks on Kubernetes pod](img/00006.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.5 – Analysis of brute-force attacks on Kubernetes pod
  prefs: []
  type: TYPE_NORMAL
- en: Next, we look into accessing logs directly via the command line.
  prefs: []
  type: TYPE_NORMAL
- en: Option 2 – Direct command-line access (kubectl)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In situations where access to the CSP’s logger service is not available, as
    investigators, you can always `kubectl` to access these individual pod-based logs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Accessing logs from pods is relatively easy. Once you have enumerated all the
    pods, you can use `kubectl logs <pod name>` to access entire logs. Logs are printed
    by default to the console; however, you can write the logs to disk for offline
    analysis. In this case, let’s pull the logs associated with the MySQL pod—`kubectl
    logs wordpress-1-mysql-0.` The next screenshot extracts the logs associated with
    the brute-force attack:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.6 – Log extract of MySQL pod, evidencing brute-force attack](img/00022.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.6 – Log extract of MySQL pod, evidencing brute-force attack
  prefs: []
  type: TYPE_NORMAL
- en: As investigators, we know the importance of logs; with Kubernetes, each pod
    will have its logs associated with the application it is running, along with other
    operational logs. However, knowing how to access these logs is vital, as investigators’
    access to the CSP’s logging console will also immensely help as they can be maintained
    longer than hunting the pod itself.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter explored the distinctions between Docker and Kubernetes, emphasizing
    their collaborative use for comprehensive container management. We delved into
    various types of containers and their specific use cases, highlighting their efficiency
    in scenarios such as microservices architectures.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, we looked at acquiring forensic data and logs for analysis in
    Kubernetes environments, emphasizing logging mechanisms, tools, and best practices
    for practical forensic analysis, including identifying security breaches and incident
    investigations. However, accessing Kubernetes logs is one of the most straightforward
    investigations. If Kubernetes is deployed in the cloud, CSPs are crucial for providing
    access to a centralized log explorer for longer-term log access.
  prefs: []
  type: TYPE_NORMAL
- en: In our next chapter, we will review the analysis of the cloud productivity suites
    hosted on Microsoft 365 and Google Workspace. The focus of this chapter is to
    understand how to analyze common threat vectors on productivity suites and which
    logs are available to investigators.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*The Raft Consensus* *Algorithm*: [https://raft.github.io/](https://raft.github.io/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Cluster* *Networking*: [https://kubernetes.io/docs/concepts/cluster-administration/networking/](https://kubernetes.io/docs/concepts/cluster-administration/networking/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Kubernetes* *Forensics*: [https://medium.com/@cloud_tips/kubernetes-forensics-c1e558b10d53#:~:text=This%20can%20involve%20looking%20for,command%2Dline%20interface%20for%20Kubernetes](mailto:https://medium.com/@cloud_tips/kubernetes-forensics-c1e558b10d53#:~:text=This%20can%20involve%20looking%20for,command%2Dline%20interface%20for%20Kubernetes)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Incident response and* *forensics*: [https://aws.github.io/aws-eks-best-practices/security/docs/incidents/?source=post_page-----c1e558b10d53](https://aws.github.io/aws-eks-best-practices/security/docs/incidents/?source=post_page-----c1e558b10d53)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Image* *security*: [https://aws.github.io/aws-eks-best-practices/security/docs/image/](https://aws.github.io/aws-eks-best-practices/security/docs/image/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*CIS Kubernetes* *Benchmarks*: [https://www.cisecurity.org/benchmark/kubernetes](https://www.cisecurity.org/benchmark/kubernetes)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*10+ Top Kubernetes Security Tools in* *2023*: [https://medium.com/@pdevsecops/10-top-kubernetes-security-tools-in-2023-df26642f995a](mailto:https://medium.com/@pdevsecops/10-top-kubernetes-security-tools-in-2023-df26642f995a)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Top Kubernetes Security Tools in* *2023*: [https://www.armosec.io/blog/kubernetes-security-tools/](https://www.armosec.io/blog/kubernetes-security-tools/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
