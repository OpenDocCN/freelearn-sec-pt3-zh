- en: Forensic Analysis of Android Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter will cover application analysis. This chapter will focus on analyzing
    the data that would be recovered using any of the logical or physical techniques
    detailed in [Chapter 4](b5ab11df-1911-4deb-accd-f92c74650e6d.xhtml), *Extracting
    Data Logically from Android Devices*, and [Chapter 5](a910938e-1c0b-4f19-baae-509ccaa36c09.xhtml),  *Extracting
    Data Physically from Android Devices*. It will also rely heavily on the storage
    methods discussed in [Chapter 2](b81853c6-388b-4e15-b8dd-deb5c1b5b36d.xhtml),
    *Setting Up the Android Forensic Environment*; we will see numerous SQLite databases,
    XML files, and other file types from various locations within the file hierarchy
    described in that chapter. By the end of this chapter, the reader should be familiar
    with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Application analysis overview
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why do app analysis?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Third-party applications and various methods used by popular applications to
    store and obfuscate data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application analysis overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Forensically analyzing an application is as much of an art as it is a science.
    There are myriad ways an application can store, or obfuscate, its data. Different
    versions of the same application may even store the same data differently. Developers
    are really only limited by their imagination (and Android platform restrictions)
    when it comes to choosing how to store their data. Because of these factors, application
    analysis is a moving target; methods an examiner uses one day may be completely
    irrelevant the next.
  prefs: []
  type: TYPE_NORMAL
- en: 'The end goal of forensically analyzing an application is consistently the same:
    to understand what the app was used for, and to find user data.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will look at the current version of many common applications.
    Because apps can, and do, change how they store data through updates, nothing
    in this chapter is a definitive guide for how to analyze that application. Instead,
    we will look at a broad range of applications to show a variety of different methods
    used by applications to store their data. For the most part, we will be looking
    at very common applications (millions of downloads from Google Play), except for
    cases where looking at an obscure app can reveal interesting new ways of storing
    data.
  prefs: []
  type: TYPE_NORMAL
- en: Why do app analysis?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For starters, even standard phone functions such as contacts, calls, and SMS
    are done through applications on Android devices, so even acquiring basic data
    requires analyzing an application. Secondly, a person''s app usage can tell you
    a lot about them: where they''ve been (and when they were there), who they''ve
    communicated with, and even what they may be planning in the future.'
  prefs: []
  type: TYPE_NORMAL
- en: Many phones come with more than 20 pre-installed applications. An examiner has
    no real way of knowing which of these apps could contain information useful for
    an investigation, and therefore they must all be analyzed. An examiner may be
    tempted to skip over certain apps that would appear to have little useful data,
    such as games. This would be a bad idea, though; many popular games have a built-in
    chat feature, which could yield useful information. Our analysis will focus heavily
    on messaging applications, as our experience shows that these tend to be the most
    valuable in a forensic analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Layout of this chapter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For each application we examine, we will provide a package name and files of
    interest. All apps store their data in the `/data/data` or `/data/user_de/0` (newer
    devices) directory by default; apps can also use the SD card if they ask for this
    permission when the app is installed. The package name is the name of the directory
    for the application in one of these directories. The paths in the *Files of interest* section
    are from the root of the package name. Paths to data on the SD card are shown
    beginning with `/sdcard`. Do not expect to find data paths beginning with `/sdcard`
    in the `/data/data` or `/data/user_de/0` directory of the application!
  prefs: []
  type: TYPE_NORMAL
- en: We will begin by looking at some of Google's applications, because these are
    pre-installed on the majority of devices (though they do not have to be). Then
    we will look at third-party applications that can be found on Google Play.
  prefs: []
  type: TYPE_NORMAL
- en: Determining which apps are installed
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To see what applications are on the device, an examiner could navigate to /data/data
    and run the `ls` command. But that doesn''t provide well-formatted data that will
    look good in a forensic report. We suggest pulling the `/data/system/packages.list`
    file; this file lists the package name for every app on the device and path to
    its data (if this file does not exist on the device, the `adb shell pm list packages
    –f` command is a good alternative). For example, here is an entry for Google Chrome
    (the full file on our test device contained 120 entries):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1ea28b32-b1f2-4bab-8af2-fdbb49237cb0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This is data storage method 1: plaintext. Often we will see apps store data
    in plaintext, even including data you wouldn''t expect (such as passwords).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Perhaps of greater interest is the `/data/system/package-usage.list` file,
    which shows the last time that package (or application) was used. It''s not perfect;
    the times shown in the file did not correlate exactly with the last time we used
    the app. It appears that the app updating or receiving notifications (even if
    the user does not view them) may affect the time, however it is good for a general
    indication of the last apps the user accessed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/435f777d-2b28-4ccf-aee7-429d4f6ba2c0.png)'
  prefs: []
  type: TYPE_IMG
- en: If you're wondering where to find the time in that line, it's in a format known
    as Unix epoch time.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Unix epoch time
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Unix epoch time**, also known as Unix time or Posix time, is stored as the
    number of seconds (or milliseconds) since midnight on January 1st, 1970 UTC. A
    10-digit value indicates it is in seconds, while a 13-digit value is indicative
    of a millisecond value (at least for times likely to be found on a smartphone,
    as 9-digit second and 12-digit millisecond values haven''t occurred since 2001).
    In our example, the value is `1422206858650`; Google Chrome was last used 1 billion,
    422 million, 206 thousand, 858 seconds, and 650 milliseconds since midnight on
    January 1st, 1970! Don''t worry, we don''t know what date/time that is either.
    There are many scripts and tools available for download that can convert this
    into a human-readable format; we like DCode, a free tool that can be found here:
    [http://www.digital-detective.net/digital-forensic-software/free-tools/](http://www.digital-detective.net/digital-forensic-software/free-tools/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In DCode, simply select **Unix: Millisecond Value** from the dropdown list,
    type in the value in the **Value to Decode** field, and click **Decode**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b95ad1ed-254a-4333-8452-0f63c2e89168.png)'
  prefs: []
  type: TYPE_IMG
- en: The **Add Bias** field can be selected to convert the time into the desired
    timezone.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, there is also a very useful online epoch calculator at [http://www.epochconverter.com/](http://www.epochconverter.com/).
  prefs: []
  type: TYPE_NORMAL
- en: Using either method, we can see that Google Chrome was actually last used on
    January 25th, 2015 at 17:27:38.650 UTC. Unix epoch time is frequently used on
    Android devices to store date/time values, and will come up repeatedly in our
    application analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Wi-Fi analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Wi-Fi is not technically an application, but it is an invaluable source of
    data that should be examined, so we''ll briefly discuss it here. Wi-Fi connection
    data is found in `/data/misc/wifi/wpa_supplicant.conf`. The `wpa_supplicant.conf`
    file contains a list of access points that the user has chosen to connect to automatically
    (this is set by default when a new access point is connected to). Access points
    that the user has *forgotten* through the device settings will not be shown. If
    the access point requires a password, that is also stored in the file in plaintext.
    In the following example, the `NETGEAR60` access point required a password (`ancientshoe601`),
    while `hhonors` did not:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e15e3ab6-fe01-40aa-91f5-20e22f364d00.png)'
  prefs: []
  type: TYPE_IMG
- en: The presence of an SSID in this file does NOT mean that this device connected
    to that access point. These settings are saved to a user's Google account, and
    added to the device when that account is set up. An examiner can only conclude
    that the user connected to these access points from some Android device, not necessarily
    the device being examined.
  prefs: []
  type: TYPE_NORMAL
- en: Contacts/Call analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Contact and call logs are stored in the same database. Contacts do not have
    to be added explicitly by the user, they may be autofilled when an email is sent
    through Gmail, a person is added on Google+, or many other ways.
  prefs: []
  type: TYPE_NORMAL
- en: '**Package name**: `com.android.providers.contacts`'
  prefs: []
  type: TYPE_NORMAL
- en: '**Files of interest**:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/files/`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`photos/`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`profile/`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/databases/`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`contacts2.db`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`calllog.db`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `files` directory contains photos for the user's contacts in the `photos`
    directory, and the user's profile photo in the `profile` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `contacts2.db` database contains all of the information about all contacts
    in the user''s Google account:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Table** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `accounts` | Shows accounts on the device that have access to the contacts
    list. At least one of the accounts will show the user''s Google account email
    address. This list may include third-party apps installed that have permission
    to access the contacts list (we will see this in the Tango, Viber, and WhatsApp
    sections). |'
  prefs: []
  type: TYPE_TB
- en: '| `contacts` | Contains partial information for contacts (more data can be
    found in the `raw_contacts` table). The `name_raw_contact_id` value corresponds
    to the `_id` value in the `raw_contacts` table. The `photo_file_id` value corresponds
    to the filename found in the `/files/photos` directory. `times_contacted` and
    `last_time_contacted` show the number of times that contact was called from or
    made a call to the device, and the time of the last call in Unix epoch format.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `data` | This table contains all of the information for each contact, such
    as email address and phone numbers. The `raw_contact_id` column is a unique value
    for each contact that can be correlated with the `_id` value in the `raw_contact_id`
    to identify the contact. Note that each contact may have several rows, as seen
    by the identical `raw_contact_id` values. There are 15 data columns (`data1`-`data15`)
    that contains some information about the contact, but there are no discernible
    patterns. The same column may contain the contact name, an email address, a Google+
    profile, and so on. The value in the `data14` column correlates to the file names
    of the images in the `files/profiles` path. The `data15` column contains a thumbnail
    of the contact''s profile photo. |'
  prefs: []
  type: TYPE_TB
- en: '| `deleted_contacts` | Contains a `contact_id` value and `deleted_contact_timestamp`
    in Unix epoch format. However, this cannot be correlated back to any other tables
    to identify the name of the contact that was deleted. It may be possible to use
    the deleted data-recovery techniques in [Chapter 6](ef5e768c-313d-4637-8784-15067dbf51dc.xhtml), *Recovering
    Deleted Data from an Android Device*, to recover the contact names, though. The
    `contact_id` value corresponds to the `contact_id` column in the `raw_contacts`
    table. |'
  prefs: []
  type: TYPE_TB
- en: '| `groups` | Shows groups in the contact list, either automatically generated
    or created by the user. The title of the group is the name of the group. There
    does not appear to be a way to identify users in each group. |'
  prefs: []
  type: TYPE_TB
- en: '| `raw_contacts` | Contains all information for every contact in the contact
    list. The `display_name` shows the contact''s name, if it is available. To determine
    the contact''s phone number, email address, or other information, the `_id` column
    value must be matched back to the `raw_contact_id` value in the data table. The
    `sync3` column shows a timestamp, but based on our testing, this cannot be assumed
    to be when the contact was added; we had contacts several years old that were
    synced this month. The `times_contacted` and `last_time_contacted` columns only
    apply for phone calls; sending an email or SMS to a contact did not increment
    these values.We were unable to identify any means to determine whether a contact
    was added through the phone interface, added as a friend on Google+, or added
    through other methods. |'
  prefs: []
  type: TYPE_TB
- en: '`calllog.db` contains all of the information about incoming, outgoing, and
    missed calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Table** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `calls` | Contains information regarding all calls to and from the device.
    The number column shows the remote user''s phone number and whether the call was
    sent or received. The `date` column is the date/time of the call, stored in Unix
    epoch format. The `duration` column is the length of the call in seconds. The
    `type` column indicates the type of call:'
  prefs: []
  type: TYPE_NORMAL
- en: Incoming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Outgoing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Missed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `name` column shows the remote user's name, if the number was stored in
    the contact list. `geocoded_location` shows the location of the phone number,
    based on the area code (for US numbers) or country code. |
  prefs: []
  type: TYPE_NORMAL
- en: SMS/MMS analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SMS and MMS messages are stored in the same database. In our experience, this
    database is also used regardless of what application is used to send the SMS/MMS
    (that is, sending an SMS through Google Hangouts will populate this database,
    not the Hangouts database examined here), although third-party apps may also record
    the data in their own databases.
  prefs: []
  type: TYPE_NORMAL
- en: '**Package name**: `com.android.providers.telephony`'
  prefs: []
  type: TYPE_NORMAL
- en: '**Files of interest**:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/files`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/databases/`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mmssms.db`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`telephony.db`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `files` directory contains attachments sent as an MMS, both sent and received.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `telephony.db` database is small, but contains one potentially useful source
    of information:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Table** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `siminfo` | Contains historical data for all SIMs that have been used in
    the device, including the ICCID, phone number (if it was stored on the SIM), and
    the MCC/MNC, which can be used to identify the network provider. |'
  prefs: []
  type: TYPE_TB
- en: 'The `mmssms.db` database contains all information regarding SMS and MMS messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Table** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `part` | Contains information about files attached to an MMS. Each message
    will have at least two parts: an SMIL header and the attachment—this can be seen
    in the `mid` and `ct` columns, as well as the file type attached. The `_data`
    column provides the path to find the file on the device. |'
  prefs: []
  type: TYPE_TB
- en: '| `pdu` | Contains metadata about each MMS. The `date` column identifies when
    the message was sent or received, in Linux epoch format. The `_id` column appears
    to correspond to the mid value in the `part` column; correlating these values
    will show the time a specific image was sent. The `msg_box` column shows the direction
    of the message (`1` = received and `2`=sent). |'
  prefs: []
  type: TYPE_TB
- en: '| `sms` | Contains metadata about each SMS (does not include MMS information).
    The address column shows the phone number of the remote user, regardless of whether
    it was a sent or received message. The `person` column contains a value that can
    be looked up in the `contacts2.db` database, and corresponds with `raw_contact_id`
    in the `data` table. The `person` column will be blank if it was a sent message,
    or if the remote user is not in the contacts list. The `date` column shows the
    timestamp a message was sent in Linux epoch format. The `type` column shows the
    direction of the message (`1` = received and `2` = sent). The `body` column displays
    the content of the message. The seen column indicates whether the message was
    read (`0` = unread and `1` = read); all sent messages will be marked as unread.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `words`, `words_content`, `words_segdir` | Appears to contain duplicate content
    of messages; the exact purpose of this table is unclear. |'
  prefs: []
  type: TYPE_TB
- en: User dictionary analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The user dictionary is an incredible source of data for an examiner. The user
    dictionary is populated any time the user types a word that isn't recognized and
    chooses to save the word to avoid it being flagged by autocorrect. Interestingly,
    our test device contained dozens of words that we never typed or saved on the
    device; this data appears to sync with a user's Google account and persists across
    multiple devices. Words synced from the account were added in alphabetical order
    at the top of the database, while words added manually afterwards were populated
    in the order they were added at the bottom.
  prefs: []
  type: TYPE_NORMAL
- en: '**Package name**: `com.android.providers.userdictionary`'
  prefs: []
  type: TYPE_NORMAL
- en: '**Files of interest**:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/databases/user_dict.db`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| **Table** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `words` | The `word` column contains the word that was added to the dictionary.
    The frequency column should likely be ignored; it displayed the same value (250)
    regardless of the number of times we used the word. |'
  prefs: []
  type: TYPE_TB
- en: 'Here are sample entries from a user dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c49f7f3e-39c9-4d3c-a9ab-9bed56a79507.png)'
  prefs: []
  type: TYPE_IMG
- en: Gmail analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Gmail is an email service provided by Google. A Gmail account is often asked
    for, though is not required, when the device is being set up for the first time.
  prefs: []
  type: TYPE_NORMAL
- en: '**Package name**: `com.google.android.gm`'
  prefs: []
  type: TYPE_NORMAL
- en: '**Files of interest**:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/cache`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/databases/`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mailstore.<username>@gmail.com.db`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`databases/suggestions.db`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/shared_prefs/`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MailAppProvider.xml`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Gmail.xml`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UnifiedEmail.xml`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `/cache` directory within the application folder contains recent files that
    were attached to emails, both sent and received. These attachments are saved here
    even if they are not explicitly downloaded by the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `mailstore.<username>@gmail.com.db` file contains a variety of useful information.
    Interesting tables within the database include:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Table** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `attachments` | Information about attachments, including their size and file
    path on the device (the `/cache` directory mentioned above). Each row also contains
    a `messages_conversation` value; this value can be compared with the conversations
    table to correlate an attachment with the email it was included within. The `filename`
    column identifies the path on the device where the file is located. |'
  prefs: []
  type: TYPE_TB
- en: '| `conversations` | In older versions, entire email conversations could be
    recovered. In the current version, Google no longer stores the entire conversation
    on the device, likely assuming that the user will have a data connection to download
    the full conversation. Instead, only the subject line and a snippet can be recovered.
    The snippet is roughly the amount of text that would appear in the notification
    bar or inbox screen of the app. The `fromCompact` column identifies the sender
    and any other recipients. |'
  prefs: []
  type: TYPE_TB
- en: The `suggestions.db` database contains terms that were searched within the application.
  prefs: []
  type: TYPE_NORMAL
- en: The XML files within the `shared_prefs` directory can confirm the account(s)
    that were used with the application. `Gmail.xml` contained another account that
    was linked with our test account, but never used with the application. `UnifiedEmail.xml`
    contained a partial list of senders who emailed the account, but with no discernible
    rationale; many senders were on the list, but far from all, and they appeared
    in no particular order. `Gmail.xml` also contained the last time that the application
    was synced, in the Unix epoch format.
  prefs: []
  type: TYPE_NORMAL
- en: Google Chrome analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Google Chrome is a web browser, and is the default browser on many devices.
    Chrome data on the device is somewhat unique in that it contains data not just
    from the device, but from all devices on which the user has logged into Chrome.
    This means that it is entirely possible (even very likely) that data from the
    user browsing on their desktop computer will be found in the databases on their
    phone. However, this also leads to huge amounts of data for an examiner to sort
    through, but that's a good problem to have.
  prefs: []
  type: TYPE_NORMAL
- en: '**Package name**: `com.android.chrome`'
  prefs: []
  type: TYPE_NORMAL
- en: '**Files of interest**:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/app_chrome/Default/`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Sync Data/SyncData.sqlite3`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Bookmarks`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Cookies`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Google Profile Picture.png`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`History`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Login Data`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Preferences`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Top Sites`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Web Data`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/app_ChromeDocumentActivity/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of the files listed in the `/app_chrome/Default` folder, except for the
    one PNG file, `Bookmarks`, and `Preferences`, are SQLite databases despite the
    lack of a file extension.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `SyncData.sqlite3` database is interesting because it appears to contain
    a list of data that has been synced from the user''s account on the device back
    to Google''s servers. Our database, with a very active Chrome account, contained
    over 2,700 entries, and included browsing history, autofill form information,
    passwords, and bookmarks. As an example, we were able to find a term one of the
    authors had searched for from 2012, seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d129000c-f8a7-4666-87d7-8d831ce7c253.png)'
  prefs: []
  type: TYPE_IMG
- en: '| **Table** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `metas` | There are many columns in the database that contain timestamps,
    and in our database they all appear to only seconds apart for each entry. It is
    unclear which time corresponds to the exact time an entry was added, but all of
    the times roughly correspond with the time of the activity in the user''s account.
    The columns with timestamps are `mtime`, `server_mtime`, `ctime`, `server_ctime`,
    `base_version`, and `server_version`.The `non_unique_name` and `server_non_unique_name`
    columns show the content that was synced. For example, one of our entries shows:`autofill_entry&#124;LNAME&#124;Tindall`Other
    entries in these columns include URLs visited, passwords, and even devices that
    the account has used. |'
  prefs: []
  type: TYPE_TB
- en: 'The `Bookmarks` file is a plaintext file, containing information about bookmarks
    synced with the account. It includes the name of each site that is bookmarked,
    the URL, and the date/time it was bookmarked, which is stored in a format we have
    not come across yet: Webkit format. To decode the values, see the *Decoding the
    Webkit time format* section.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is data storage method 3: Webkit time format.'
  prefs: []
  type: TYPE_NORMAL
- en: The `Cookies` database stores cookie information for sites visited (depending
    on the site and Chrome settings), including the name of the site, the date the
    cookie was saved, and the last time the cookie was accessed, in Webkit time format.
  prefs: []
  type: TYPE_NORMAL
- en: The `Google Profile Picture.PNG` file is the user's profile picture.
  prefs: []
  type: TYPE_NORMAL
- en: The `History` database contains the user's web history.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Table** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `keyword_search_terms` | Contains a list of terms that were searched for
    using Google within Chrome. The term column shows what was searched, while the
    `url_id` can be correlated with the URLs table to see the time of the search.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `segments` | This table contains some URLs that were visited, but not all.
    It is not clear what causes data to be entered into this table. |'
  prefs: []
  type: TYPE_TB
- en: '| `urls` | Contains browsing history for the Google account across all devices,
    not just the device the database was pulled from. Our history went back approximately
    3 months and contained 494 entries, although the Google account is much older
    than that and we have certainly visited more than 494 pages in that time. It is
    unclear exactly what causes this discrepancy or determines the cutoff date for
    the history.The `id` column is a unique value for each row in the table. The `url`
    and `title` columns contain the URL visited and the name of the page. The `visit_count`
    column appears to be an accurate count of how many times the URL was visited.
    `typed_count` is always equal to or lesser than `visit_count`, but we do not know
    exactly what it indicates. For some sites, the discrepancy can be accounted for
    by factoring in the number of times the site was visited through a bookmark rather
    than typing the URL, but this does not hold true for all cases. `last_visit_time`
    is the last time the URL was visited, in Webkit time format. |'
  prefs: []
  type: TYPE_TB
- en: '| `visits` | Contains a row for each visit to the URLs in the `urls` table;
    the number of entries in this table for a URL corresponds to the value in the
    `visit_count` column of the `url` table. The `url` column value correlates to
    the value in the id column of the `url` table. The time of each visit can be found
    in the `visit_time` column, again in Webkit time format. |'
  prefs: []
  type: TYPE_TB
- en: 'The `Login Data` database contains login information saved in Chrome, and is
    synced across all devices that use the Google account:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Table** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `logins` | `origin_url` is the site the user visited initially, `action_url`
    is the URL of the login page if the user is redirected to one; if the first page
    visited is the login page, both URLs are the same. The `username_value` and `password_value`
    columns show the username and password stored for that URL in plaintext; and no,
    we''re not going to include a screenshot of our database! `date_created` is the
    date/time that login information was first saved, in Webkit time format. The `date_synced`
    column is the date/time that login data was synced locally to the device, again
    in Webkit time format. The `times_used` column shows the number of times that
    login information was autofilled by Chrome after it was saved (excluding the first
    login, so some values may be 0). |'
  prefs: []
  type: TYPE_TB
- en: The `Preferences` file is a text file, and contains the Google account(s) the
    user has signed into Chrome with.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Top Sites` database contains the sites that are most frequently visited,
    as these are shown by default when Chrome opens.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Web Data` database contains information the user has saved in order to
    automatically fill in forms on websites.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| **Table** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `autofill` | Contains a list of fields on web-based forms and the value the
    user typed. The `name` column shows the name of the field that was typed in, while
    the `value` column shows what the user typed. `date_created` and `date_last_used`
    are self-explanatory, and are stored in Linux epoch format.Note that while this
    is potentially very valuable information (for example, our database contained
    a few usernames not stored elsewhere), there is also very little context available.
    The URL where the information is not stored, and may not be determinable. |'
  prefs: []
  type: TYPE_TB
- en: '| `autofill_profile_emails` | Contains all values the user has saved to autofill
    the `email` field on a web form. |'
  prefs: []
  type: TYPE_TB
- en: '| `autofill_profile_names` | Contains all values the user has saved to autofill
    the **First**, **Middle**, **Last**, and **Full Name** fields on a web form. |'
  prefs: []
  type: TYPE_TB
- en: '| `autofill_profile_phonwa` | Contains all values the user has saved to autofill
    the **Phone Number** field on a web form. |'
  prefs: []
  type: TYPE_TB
- en: '| `autofill_profiles` | Contains all values the user has saved to autofill
    address information fields on a web form. |'
  prefs: []
  type: TYPE_TB
- en: The `/app_ChromeDocumentActivity/` directory contains files with history for
    recent tabs that were open on the device. URLs can be recovered from these files
    for sites that were visited.
  prefs: []
  type: TYPE_NORMAL
- en: Decoding the Webkit time format
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here is a sample Webkit time value: 13066077007826684.'
  prefs: []
  type: TYPE_NORMAL
- en: At first glance, it appears to be very similar to Unix epoch time, just slightly
    longer (perhaps it is storing nanoseconds?). An examiner who attempts to decode
    this as epoch time will get a date in May 2011, which may seem accurate, but is
    in fact several years off from the correct date!
  prefs: []
  type: TYPE_NORMAL
- en: Webkit time *is* an epoch time, it is just based on a different starting point
    than Unix epoch time. Webkit epoch time is the number of microseconds since midnight
    on January 1st, 1601\. Yes, we said the year 1601\. Once we know where the epoch
    begins, converting to a recognizable format simply becomes a math problem. But,
    once again, we'd rather use DCode.
  prefs: []
  type: TYPE_NORMAL
- en: 'This time in DCode, choose Google Chrome Value in the **Decode Format** dropdown
    selection, and click **Decode**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/03e81ce5-4f46-4ef6-b02f-5b90f73c9872.png)'
  prefs: []
  type: TYPE_IMG
- en: The actual value of our example is November 2nd, 2014 at 18:04:33 UTC; significantly
    different than the value we would have come up with if we'd thought it was a Unix
    epoch time!
  prefs: []
  type: TYPE_NORMAL
- en: Google Maps analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Maps is a map/navigation application provided by Google.
  prefs: []
  type: TYPE_NORMAL
- en: '**Package name**: `com.google.android.apps.maps`'
  prefs: []
  type: TYPE_NORMAL
- en: '**Files of interest**:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/cache/http/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/databases/`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gmm_myplaces.db`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gmm_storage.db`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `/cache/http` folder contains many files, with `.0` and `.1` file extensions.
    The `.0` files are web requests for the corresponding `.1` file. The `.1` files
    are predominantly images, and can be viewed by changing their extension appropriately;
    on our test device, they were either `.jpg` or `.png` files. These files were
    predominantly locations near the user, not necessarily locations the user specifically
    searched for.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is data storage method 4: misnamed file extensions'
  prefs: []
  type: TYPE_NORMAL
- en: Always verify the header of a file that can't be opened, or use automated tools,
    such as EnCase, to detect the mismatched header/file extension. A good resource
    to verify a file's signature is [http://www.garykessler.net/library/file_sigs.html](http://www.garykessler.net/library/file_sigs.html).
  prefs: []
  type: TYPE_NORMAL
- en: The `gmm_myplaces.db` database contains locations saved by the user. This file
    syncs with the user's Google account, so these locations were not necessarily
    saved using the application.
  prefs: []
  type: TYPE_NORMAL
- en: '`gmm_storage.db` contains search hits and locations that were navigated to:'
  prefs: []
  type: TYPE_NORMAL
- en: '| ** Table** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `gmm_storage_table` | The `_key_pri` column appears to identify the type
    of the location, bundled appears to be a hit that came up on a search, while `ArrivedAtPlacemark`
    identifies locations that were actually navigated to. The `_data` column contains
    the address for the location. |'
  prefs: []
  type: TYPE_TB
- en: Google Hangouts analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Hangouts is a chat/SMS application provided by Google. Hangouts is the default
    SMS client on Android devices.
  prefs: []
  type: TYPE_NORMAL
- en: '**Package name**: `com.google.android.talk`'
  prefs: []
  type: TYPE_NORMAL
- en: '**Files of interest**:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/cache/volleyCache/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/databases/babel#.db` (our device had `babel0.db` and `babel1.db`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/shared_prefs/accounts.xml`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `cache` directory contains .0 files, as discussed in the Google Maps example.
    The files contain a URL to fetch the profile pictures of contacts, as well as
    a JPG embedded within the file. Visiting the URL or carving the JPG from the file
    will recover the contact's picture.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `babel#.db` file contains all messaging data. On our test device, `babel0.db`
    was blank and `babel1.db` had all of the data for the active account. There are
    many tables within this database worth looking at:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Table** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `conversations` | Contains conversation data. There is a unique `conversation_id`
    for each chat. `latest_message_timestamp` is the time of the most recent chat,
    in Linux epoch format. The `generated_name` column has a list of all participants
    in the chat, minus the account on the device. The `snippet_text` column is the
    content of the most recent message; like Gmail, the entire chat is not stored
    on the device. The `latest_message_author_full_name` and `latest_message_author_first_name`
    columns identify the author of the `snippet_text` column. The `inviter_full_name`
    and `inviter_first_name` columns identify which person initiated the conversation.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `dismissed_contacts` | Has a list of names of former contacts that had been
    messaged. These are labelled as a **Hidden Contact** within the app. |'
  prefs: []
  type: TYPE_TB
- en: '| `messages` | As expected, contains a detailed message history for each conversation.
    Text contains the content of the message, and the timestamp column is the date/time
    in Linux epoch format. The `remote_url` column is, once again, a URL to retrieve
    images shared in the message. Again, it can be accessed publicly. `author_chat_id`
    is a value that can be correlated with the participants table to identify the
    author of each message. |'
  prefs: []
  type: TYPE_TB
- en: '| p`a`rticipants | Contains a list of people chatted with. Includes full names,
    profile picture URLs, and a `chat_id` to identify the person in the messages table.
    |'
  prefs: []
  type: TYPE_TB
- en: The `accounts.xml` file has a `phone_verification` field that contains the phone
    number associated with the Google account when Hangouts is configured to send
    SMS. This could be highly useful, because it is frequently difficult to obtain
    the device's phone number as it is often not stored on the device.
  prefs: []
  type: TYPE_NORMAL
- en: Google Keep analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Keep is a note-taking application provided by Google. It can also be used to
    set reminders, either at a certain date/time or when the user is at a specified
    location.
  prefs: []
  type: TYPE_NORMAL
- en: '**Package name**: `com.google.android.keep`'
  prefs: []
  type: TYPE_NORMAL
- en: '**Files of interest**:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/databases/keep.db`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/files/1/image/original`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `files/1/image/original` directory contains photos taken using the app.
    Notes and reminders can both be associated with an image.
  prefs: []
  type: TYPE_NORMAL
- en: '`Keep.db` contains all of the information about notes and reminders. There
    are, once again, several tables of interest:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Table** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `alert` | Contains information about location-based reminders. `reminder_id`
    can be correlated with entries in the reminder table. The `reminder_detail` table
    contains the latitude and longitude set for the reminder. `scheduled_time` is
    the date/time the reminder was set, in Linux epoch time. |'
  prefs: []
  type: TYPE_TB
- en: '| `blob` | Contains metadata about images in the `/files` directory, including
    the filename and size. `blob_id` can be correlated with the `_id` column in the
    `blob_node` table. |'
  prefs: []
  type: TYPE_TB
- en: '| `blob_node` | Contains the time created value for the images in the `/files`
    directory, in Linux epoch time. |'
  prefs: []
  type: TYPE_TB
- en: '| `list_item` | Stores data for each note on the device. The text column contains
    the full text of each note. The `list_parent_id` column is a unique value for
    each note; if multiple rows have the same value, it means they were created as
    a list within the same note. The `time_created` and `time_last_updated` columns
    are the time the note was created, and the time it was last synced with the Google
    servers, in Linux epoch time. |'
  prefs: []
  type: TYPE_TB
- en: '| `reminder` | Contains data about each reminder set within the app. If the
    reminder is time-based, the `julian_date` and `time_of_day` columns will be populated.
    |'
  prefs: []
  type: TYPE_TB
- en: Converting a Julian date
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Julian dates are similar to the Linux epoch format, simply starting from a
    different date. The Julian date system counts the number of days since noon on
    January 1st, 4713 BC. The United States Naval Observatory has an excellent Julian
    date calculator: [http://aa.usno.navy.mil/data/docs/JulianDate.php](http://aa.usno.navy.mil/data/docs/JulianDate.php).
    To obtain the Julian date from the database, simply combine the two columns with
    a decimal in between, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b3403864-ed38-4447-b41a-b109e10bb0cf.png)'
  prefs: []
  type: TYPE_IMG
- en: This would correspond to the Julian date `2457042.46800000`. When this value
    is input to the website, we find out the date the reminder is set for is January
    19 2015 at 23:13:55.2 UT. The `location_name`, `latitude`, `longitude`, and `location_address`
    columns will be populated if a reminder is set as location-based. Finally, the
    `time_created` and t`ime_last_updated` columns are the time the note was created,
    and the time it was last synced with the Google servers, in Linux epoch time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Data storage method 5: Julian date'
  prefs: []
  type: TYPE_NORMAL
- en: Recovering video messages from Skype
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As noted, video messages are not stored on the device. Luckily for us, they
    can be accessed via the internet. The first step is to verify that a video message
    was sent, by looking in the Messages table in the `body_xml` column. Next, note
    the `convo_id` field for the message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f5db9d12-4c94-4810-a676-7b559636dcdc.png)'
  prefs: []
  type: TYPE_IMG
- en: Our video message is in `convo_id` `257`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, look in the Chats table for that `convo_id` in the `conv_dbid` column,
    and find the `dbpath` value. This will be the name of the conversation''s backup
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5e05131a-7f75-4b61-9efb-fd56e96a56e8.png)'
  prefs: []
  type: TYPE_IMG
- en: To find the backup file, look in `files/<username>/chatsync`. There will be
    a folder for each conversation, the name of the folder is the first two digits
    of the backup name. Our backup will be in folder `28`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the backup file in a hex editor, and search for `videomessage`. You should
    find a URL and a code to access the video:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d5be7bdf-9ff6-4a69-9862-c265f38f342e.png)'
  prefs: []
  type: TYPE_IMG
- en: Actually accessing the URL may require an additional warrant or legal permission,
    depending on your local jurisdiction. As this data is not on the device, and is
    private, viewing it without legal guidance could invalidate any evidence found
    in the video.
  prefs: []
  type: TYPE_NORMAL
- en: Google Plus analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Google Plus is the Google-based social network. It allows the sharing of text/videos/images,
    adding friends, following people, and messaging. Google Plus may also, depending
    on the user's settings, automatically upload all pictures taken on the user's
    device.
  prefs: []
  type: TYPE_NORMAL
- en: '**Package name**: `com.google.android.apps.plus`'
  prefs: []
  type: TYPE_NORMAL
- en: '**Files of interest**:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/databases/es0.db`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Es0.db` contains all the information an examiner would expect to find from
    a social media account:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Table** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `all_photos` | Contains a URL to download images shared by and with the user, 
    as well as the creation date/time in Linux epoch format |'
  prefs: []
  type: TYPE_TB
- en: '| `activities` | Data displayed in the user''s stream (that is, their news
    feed). The created and modified time for each post is, once again, stored in Linux
    epoch time. The title and comment columns will contain the post title and at least
    some of the comments from it. The permalink column contains a URL that can be
    followed to view the post, if it was shared publicly. If the post is shared privately,
    the content can still be recovered from the embed table. The related table contains
    the hashtags automatically generated for the post by Google, this will also populate
    even if the post is private. |'
  prefs: []
  type: TYPE_TB
- en: '| `activity_contacts` | Contains a list of names for people whose posts are
    in the activities table. |'
  prefs: []
  type: TYPE_TB
- en: '| `all_photos` | Contains a list of ALL photos the user has backed up to Google
    Plus, whether they were shared or not. `image_url` can be used to download any
    of the user''s photos, and is publicly available. Removing the `-d` on the end
    of the URL will allow you to view the image without downloading. The timestamp
    column is the date/time the image was *taken*, based on the image metadata; it
    does not indicate when the image was uploaded. |'
  prefs: []
  type: TYPE_TB
- en: '| `all_tiles` | Contains an unknown subset of `all_photos`, but also includes
    images shared with the user. |'
  prefs: []
  type: TYPE_TB
- en: '| `circle_contact` | Contains a list of people the user has added to their
    circles. Does not include names, but some of the `link_person_id` values include
    email addresses. The `link_circle_id` value can be correlated with the circles
    table to identify the name of each circle. `link_person_id` can then be correlated
    with the contacts table to identify which user is in which circle. |'
  prefs: []
  type: TYPE_TB
- en: '| `circles` | Has all circles the user has created, as well as a count of the
    number of users in each one. |'
  prefs: []
  type: TYPE_TB
- en: '| `contacts` | A list of all contacts in the user''s circles. |'
  prefs: []
  type: TYPE_TB
- en: '| `events` | A listing of all events the user has been invited to, whether
    they attended or not. The name column is the title of the event. `creator_gaia_id`
    can be correlated with the `gaia_id` column in the contacts table to identify
    the event creator. The `start_time` and `end_time` columns are the time of the
    event, in Linux epoch format. The `event_data` column has the description of the
    event entered by the creator, as well as information about the location if added.
    It also lists all other users who were invited to the event. |'
  prefs: []
  type: TYPE_TB
- en: '| `squares` | A list of groups the user has joined. |'
  prefs: []
  type: TYPE_TB
- en: Facebook analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Facebook is a social media application with more than 1,000,000,000 downloads
    from Google Play.
  prefs: []
  type: TYPE_NORMAL
- en: '**Package name**: `com.facebook.katana`'
  prefs: []
  type: TYPE_NORMAL
- en: '**Files of interest**:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/files/video-cache/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/cache/images/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/databases/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bookmarks_db2`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`contacts_db2`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nearbytiles_db`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`newsfeed_db`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`notifications_db`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`prefs_db`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`threads_db2`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `/files/video-cache` directory contains videos from the user's newsfeed,
    though there does not appear to be a way to correlate them with the user who posted
    them.
  prefs: []
  type: TYPE_NORMAL
- en: The `/cache/images` directory contains images from the user's newsfeed, as well
    as profile photos of contacts. The directory contains a multitude of other directories
    (65 on our test phone), and each directory can contain multiple `.cnt` files.
    The `.cnt` files are typically JPG files or other image formats.
  prefs: []
  type: TYPE_NORMAL
- en: The `bookmarks_db2` database is a list of items that appear on the side of the
    user's newsfeed, such as groups and applications. Many of these bookmarks are
    automatically generated by Facebook, but may also be created by the user.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Table** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| bookmarks | Contains all of the info within the database. The `bookmark_name`
    column is the name of the bookmark displayed to the user. The `bookmark_pic` column
    has a publicly-accessible URL to view the bookmark icon displayed to the user.
    The `bookmark_type` column identifies the type of the group; our testing showed
    `profile`, `group`, `app`, `friend_list`, `page`, and `interest_list`. Finally,
    the `bookmark_unread_count` column shows how many messages in the group have not
    been read by the user. |'
  prefs: []
  type: TYPE_TB
- en: 'The `contacts_db2` database, predictably, contains information about all of
    the user''s contacts:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Table** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `contacts` | Contains all information about the user''s contacts. The `fbid`
    column is a unique ID that is used to identify the contact in other databases.
    The `first_name`, `last_name`, and `display_name` columns show the contact''s
    name. `small_picture_url`, `big_picture_url`, and `huge_picture_url` contain public
    links to the contact''s profile picture. `communication_rank` appears to be a
    number identifying how often the contact communicates with the user (taking into
    account messages, comments, and possibly other factors); a higher number indicates
    more communication with that contact. `added_time_ms` shows the time (in Linux
    epoch format) the contact was added as a friend. The `bday_day` and `bday_month`
    columns show the contact''s birthdate, but not the year. The data column contains
    a duplicate of all the rest of the data in the database, but also contains the
    contact''s location, which is not found elsewhere in the database. |'
  prefs: []
  type: TYPE_TB
- en: '`nearbytiles_db` is a database that contains locations near the user that may
    interest them; this is apparently populated constantly, even if the user does
    not view the locations. It is interesting because, while it isn''t a fine location
    (most of our tests showed locations within 6-10 miles of our location), it is
    a rough idea of places a user has been:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Table** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `nearby_tiles` | Contains latitude and longitude values for locations near
    the user, as well as the time the location was retrieved from the Facebook servers
    in Linux epoch format. |'
  prefs: []
  type: TYPE_TB
- en: '`newsfeed_db` contains data shown to the user in their newsfeed. Depending
    on the usage of the app, it can be a very large file:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Table** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `home_stories` | The `fetched_at` column shows the time the story was pulled
    from the Facebook servers, and likely corresponds closely with the time the user
    was using the application or saw the story. The `story_data` column contains the
    story, stored as a blob of data. When viewed in a hex or text editor, the username
    of the person posting the story can be found. The content of the post can also
    be found in plaintext, and is often preceded by a tag that says `text`. An example
    of this is shown here: |'
  prefs: []
  type: TYPE_TB
- en: '![](img/391c6707-f4f6-44a6-b3cc-9b6faa6b72d5.png)'
  prefs: []
  type: TYPE_IMG
- en: Note that the actual content of this one cell in the `story_data` column contained
    over 10,000 bytes of data, though the actual message is only around 50 bytes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `notifications_db` contains notifications sent to the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Table** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `gql_notifications` | The `seen_state` column shows whether the notification
    has been seen and read. The updated column contains the time the notification
    was updated (that is, sent if it is unread, or the time it was read) in Linux
    epoch format. The `gql_payload` column contains the content of the notification
    as well as the sender, similar to the `story_data` column in `newsfeed_db`. The
    message content again is frequently preceded by the `text` flag. A much smaller
    amount of data, which shows the text of the notification, can be found in the
    `summary_graphql_text_with_entities` and `short_summary_graphql_text_with_entities`
    columns. `profile_picture_uri` contains a public URL to view the sender''s profile
    picture, and the `icon_url` column has a link to view the icon associated with
    the notification. |'
  prefs: []
  type: TYPE_TB
- en: 'The `prefs_db` database contains application preferences:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Table** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `preferences` | The `/auth/user_data/fb_username` row shows the user''s Facebook
    username. The `/config/gk/last_fetch_time_ms` value is the timestamp of the app''s
    last communication with Facebook servers, but may not be an exact time of the
    user''s last interaction with the app. `/fb_android/last_login_time` shows the
    last time the user logged in through the app. The database contains many other
    timestamps that, when put together, can be used to build a decent profile of the
    app''s usage. The `/auth/user_data/fb_me_user` contains data about the user, including
    their name, email address, and phone number. |'
  prefs: []
  type: TYPE_TB
- en: 'The `threads_db` database contains messaging information:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Table** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `messages` | Each message has a unique ID in the `msg_id` column. The text
    column contains the message in plaintext. The sender column identifies the Facebook
    ID and name of the message sender. The `timestamp_ms` column is the time the message
    was sent, in Linux epoch format. The attachments column contains a public URL
    to retrieve attached images. The coordinates column will have the sender''s latitude
    and longitude if they have opted to show their location. The source column identifies
    whether the message was sent via the website or app. |'
  prefs: []
  type: TYPE_TB
- en: Facebook Messenger analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Facebook Messenger is messaging app, separate from the main Facebook application.
    It has over 500,000,000 downloads in the Play Store.
  prefs: []
  type: TYPE_NORMAL
- en: '**Package name**: `com.facebook.orca`'
  prefs: []
  type: TYPE_NORMAL
- en: '**Files of interest**:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/cache/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`audio/`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fb_temp/`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`image/`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/sdcard/com.facebook.orca`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`` `/files/ rti.mqtt.analytics.xml` ``'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/databases/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`call_log.sqlite`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`contacts_db2`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`prefs_db`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`threads_db2`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `/cache/audio` directory contains audio messages sent through the application.
    The files have a `.cnt` file extension, but are actually RIFF files that can be
    played with Windows Media Player, VLC media player, and other programs.
  prefs: []
  type: TYPE_NORMAL
- en: The `/cache/fb_temp` path contains temp files for images and video sent through
    the application. It is unclear how long these files will remain; in our testing,
    we sent and received a total of five files, and all five were still in the temp
    folder one week later.
  prefs: []
  type: TYPE_NORMAL
- en: The `/cache/image` directory contains a multitude of other directories (33 on
    our test phone), and each directory can contain multiple `.cnt` files. The file
    header should be verified on each file, as some were video files and some were
    images. Several of the files from the `fb_temp` folder were found, as well as
    the profile pictures of some contacts.
  prefs: []
  type: TYPE_NORMAL
- en: The `fb_temp` folder on the SD card contains sent images and video only.
  prefs: []
  type: TYPE_NORMAL
- en: The application also includes an option (disabled by default) to download all
    received images/video to the device's Gallery. If this option is selected, all
    received images/video would be found on the SD card.
  prefs: []
  type: TYPE_NORMAL
- en: The `/files/rti.mqtt.analytics.xml` file has the user's Facebook UID.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `call_log.sqlite` database contains a log of calls made through the application.
    The `person_summary` table contains the relevant data:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Table** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `person_summary` | The `user_id` column contains the Facebook ID of the remote
    user; this can be correlated with the `fbid` column in `contacts_db2` to determine
    the user''s name. The `last_call_time` column contains the time of the previous
    call in Linux epoch format. This table does not contain information about the
    direction of the call (sent or received). |'
  prefs: []
  type: TYPE_TB
- en: 'The `contacts_db2` file is a SQLite database, despite the lack of a file extension.
    Useful tables within this database include:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Table** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `contacts` | This table includes contacts the user has added, as well as
    contacts that were scraped from the user''s phonebook (if the phonebook contact
    uses Facebook Messenger). It contains the first and last name of each contact,
    as well as that contact''s Facebook ID (as discussed in the `call_log.sqlite`
    table). `added_time_ms` shows the time each user was added into the app. This
    can give some insight into whether the contact was added manually or automatically;
    a large group of contacts added within milliseconds of each other were likely
    created automatically when the app was installed. The `small_picture_url`, `big_picture_url`,
    and `huge_picture_url` columns contain public links to the contact''s profile
    picture. A contact''s phone number can be found in the blob of information within
    the data column.It should be noted that we have no idea where some of the contacts
    in this database came from. They were not Facebook friends with our account, and
    were not contacts in our device''s phonebook, but were added at the same time
    that the phonebook was scraped. Our best guess is that some contacts in our phone
    have phone numbers that Facebook associated with other users. |'
  prefs: []
  type: TYPE_TB
- en: '| `favorite_contacts` | The `favorite_contacts` table shows contacts that have
    been added as a favorite by the user. They are identified by the `fbid` column,
    which can be correlated back to the contacts table. |'
  prefs: []
  type: TYPE_TB
- en: 'The `prefs_db` database contains useful metadata about the app and the account:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Table** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `preferences` | The `/messenger/first_install_time` value indicates the time
    the application was installed, in Linux epoch time. The `/auth/user_data/fb_username`
    value shows the username associated with the application. The `/config/neue/validated_phonenumbe`r
    value shows the phone number associated with the application. The user''s first
    and last name can be found in the `/auth/user_data/fb_me_user` value. |'
  prefs: []
  type: TYPE_TB
- en: 'Finally, the `threads_db2` database contains data about messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Table** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `group_clusters` | Shows folders the user has created. |'
  prefs: []
  type: TYPE_TB
- en: '| `group_conversations` | Contains the `thread_key` value for each group chat;
    this can be correlated with the messages table. |'
  prefs: []
  type: TYPE_TB
- en: '| `messages` | The `thread_key` is a unique ID generated for each chat session.
    The text column has the contents of each text message sent and received. This
    also identifies voice calls using the phrases `You called Facebook User.`, `Facebook
    User called you.`, and `You missed a call from Facebook User`. The sender column
    identifies which user sent each message (or made each call). The `timestamp_ms`
    column shows the time each message was sent, in Linux epoch format. The attachments
    column will show data for each sent or received attachment, the file type is also
    visible in the data. `pending_send_media_attachment` shows the path on the device
    to recover sent attachments. Finding received attachments directly does not appear
    possible, although they were recovered in the `/cache/images` directory, there
    was no way to correlate them with a specific message or sender. |'
  prefs: []
  type: TYPE_TB
- en: Skype analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Skype is a voice/video calling app, as well as a messaging app owned by Microsoft.
    It has over 100,000,000 installs on Google Play.
  prefs: []
  type: TYPE_NORMAL
- en: '**Package name**: `com.skype.raider`'
  prefs: []
  type: TYPE_NORMAL
- en: '**Files of interest**:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/cache/skype-4228/DbTemp`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/sdcard/Android/data/com.skype.raider/cache/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/files/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`shared.xml`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<username>/thumbnails/`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<username>/main.db`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<username>/chatsync`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `/cache/skype-4228/DbTemp` directory contained multiple files with no extension.
    One of these files (`temp-5cu4tRPdDuQ3ckPQG7wQRFgU` on our device) was actually
    a SQLite database that contained the SSID and MAC of wireless access points it
    had been connected to.
  prefs: []
  type: TYPE_NORMAL
- en: The SD card path will contain any images or files received in a chat. If a file
    is downloaded, it will be in the Downloads folder in the root of the SD.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `shared.xml` file listed the account''s username, as well as the last IP
    address that connected to Skype:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/545e70f4-bb0c-4979-8d4e-fe86fc76d4b3.png)'
  prefs: []
  type: TYPE_IMG
- en: The `<username>/thumbnails` directory contained the user's profile picture.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `main.db` database, like it sounds, contains all of the app usage history.
    Here are some important tables:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Table** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `Accounts` | Shows the accounts used on the device, and the associated email
    addresses. |'
  prefs: []
  type: TYPE_TB
- en: '| `CallMembers` | Call logs from the app. The duration table is the duration
    of the call, and `start_timestamp` is the start time in Linux epoch format; neither
    of these columns is populated if the call is not answered. `creation_timestamp`
    is the actual beginning of the call; it is populated as soon as the call is initiated
    within the app, so even unanswered calls are shown in this column. The `ip_address`
    column shows the IP address of the user for connected calls.  The type column
    indicates whether the call was outgoing or incoming (1 = incoming, 2 = outgoing).
    The `guid` column also shows the direction of the call, listing each participant
    from left to right, with the user on the left being the one who initiated the
    call. The `call_db_id` column can be correlated with the calls table to find further
    information about the call. |'
  prefs: []
  type: TYPE_TB
- en: '| `Calls` | Very similar to `CallMembers`, but with less information. It is
    worth noting that the `begin_timestamp` column in this table is identical to `creation_timestamp`
    in `CallMembers`. There is an `is_incoming` column to show the direction of the
    call: 0 indicates outgoing, 1 indicates incoming. Finally, it should be noted
    that the duration of some calls did NOT match the `CallMembers` table. One of
    the durations was a second longer than the other table indicated. It appears that
    the `CallMembers` table calculates duration based on `start_timestamp`, while
    the Calls table calculates duration based on `begin_timestamp`. The difference
    in duration is likely caused by the amount of time it took the user to accept
    the call. |'
  prefs: []
  type: TYPE_TB
- en: '| `ChatMembers` | Shows the users in each chat. The adder column lists the
    user that initiated the chat. |'
  prefs: []
  type: TYPE_TB
- en: '| `Chats` | Lists each unique chat session. The timestamp column is the date/time
    the conversation began, in Linux epoch format. The dialog_partner column shows
    users in the chat, excluding the account on the device. The posters table shows
    every user that has made a comment in the chat, and includes the account on the
    device if it has posted. The participants column is similar to the `dialog_partner`
    column, but includes the user''s account. Finally, the `dbpath` column contains
    the name of the chat backup file found in the `<username>/chatsync` directory.
    This will become important further in this analysis. |'
  prefs: []
  type: TYPE_TB
- en: '| `Contacts` | This is actually a very misleading table. In our test, we added
    two users to our contact list; the contacts table has 233 entries! The `is_permanent`
    column indicates the status of the users listed in this table; if it is 1, the
    user is added as an actual contact within the application. The other 231 entries
    appear to be names that came up in results when we searched for contacts, but
    we never communicated with or added them. |'
  prefs: []
  type: TYPE_TB
- en: '| `Conversations` | We have no idea what the difference between Conversations
    and Chats is. They contain much of the same information, and in fact appear to
    be referencing the same chat sessions. |'
  prefs: []
  type: TYPE_TB
- en: '| `Messages` | Contains every individual message from chats/conversations.
    The `convo_id` column has a unique value for each conversation; any messages with
    the same `convo_id` value are from the same conversation. The author and `from_dispname`
    columns show who wrote each message. The timestamp column, once again, shows the
    date/time of the message in Linux epoch format. The type column indicates the
    type of message that was sent; here are the values from our testing:'
  prefs: []
  type: TYPE_NORMAL
- en: '**50**: Friend request'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**51**: Request accepted'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**61**: Plaintext message'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**68**: File transfer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**30**: Call begin (voice or video)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**39**: Call end (voice or video)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**70**: Video message'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `body_xml` column has the content of the message. For plaintext messages
    and friend requests, the content is simply what the message said. File transfers
    show the size and name of the file. Video messages say that they are a video message,
    but provide no other information. Calls show the duration if it was connected,
    and no duration if they were missed/ignored. The identities column shows who sent
    each message, but may be blank if it was sent by the user account on the device.
    The reason column appears to be for calls, and shows either `no_answer` or `busy`
    to explain why a call was not connected. |
  prefs: []
  type: TYPE_NORMAL
- en: '| `Participants` | Similar to `ChatMembers`, shows each user involved with
    a chat/conversation. |'
  prefs: []
  type: TYPE_TB
- en: '| `SMSes` | Our testing did not include SMS messaging; however, each column
    in this table is self-explanatory. |'
  prefs: []
  type: TYPE_TB
- en: '| `Transfers` | Shows information about files transferred. Includes the file
    name, size, and path on the device. The `partner_dispname` column identifies which
    user began the file transfer. |'
  prefs: []
  type: TYPE_TB
- en: '| `VideoMessages` | Shows the author and creation timestamp of video messages.
    Note that video messages are NOT stored on the device; accessing them will be
    covered in a separate section below. |'
  prefs: []
  type: TYPE_TB
- en: '| `VoiceMails` | Our testing did not include voicemails; however, each column
    in this table appears self-explanatory. |'
  prefs: []
  type: TYPE_TB
- en: Snapchat analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Snapchat is an image-sharing and text-messaging service with over 100,000,000
    downloads. Its signature feature is that images and videos sent will "self-destruct"
    after a time limit set by the sender, from 1-10 seconds. Furthermore, if a user
    takes a screenshot of the image, the sender is notified.Text chats do not have
    an expiration timer.
  prefs: []
  type: TYPE_NORMAL
- en: '**Package name**: `com.snapchat.android`'
  prefs: []
  type: TYPE_NORMAL
- en: '**Files of interest**:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/cache/stories/received/thumbnail/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/sdcard/Android/data/com.snapchat.android/cache/my_media/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/shared_prefs/com.snapchat.android_preferences.xml`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/databases/tcspahn.db`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/cache/stories/received/thumbnail` contains thumbnails of pictures taken by
    the user on the device. The `/sdcard` path contains the full-sized images. These
    remain even after the time limit has expired and the recipient can no longer access
    them. The files in both of these locations may not have proper file extensions.'
  prefs: []
  type: TYPE_NORMAL
- en: The `com.snapchat.android_preferences.xml` file contains the email address used
    to create an account, and the phone number of the device registered with the account.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `tcspahn.db` database contains all other information about the app''s usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Table** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `Chat` | Lists all text chats. Shows the sender, recipient, timestamp in
    Linux epoch time, and the text of the message. |'
  prefs: []
  type: TYPE_TB
- en: '| `ContactsOnSnapchat` | Shows all users in the user''s phonebook who also
    have Snapchat installed. The `isAddedAsFriend` column will show a 1 if the user
    has actually been added as a contact. |'
  prefs: []
  type: TYPE_TB
- en: '| `Conversation` | Has information about each open conversation. Includes the
    sender and recipient, and the timestamp of the last sent and received snaps in
    Linux epoch format. |'
  prefs: []
  type: TYPE_TB
- en: '| `Friends` | Similar to `ContactsOnSnapchat`, but only includes users who
    have been added as a friend. Includes the timestamp that each user added the other.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `ReceivedSnaps` | Metadata about received images and videos. Once the image/video
    is viewed, it appears to be removed from this table at some point. Contains a
    timestamp for each message, a status, whether or not a snap was screenshot, and
    the sender. |'
  prefs: []
  type: TYPE_TB
- en: '| `SentSnaps` | Metadata about sent images and videos. Once the image/video
    is viewed, it appears to be removed from this table at some point. Contains a
    timestamp for each message, a status, and the recipient. |'
  prefs: []
  type: TYPE_TB
- en: Viber analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Viber is a messaging and voice/video calling app with over 100,000,000 downloads.
  prefs: []
  type: TYPE_NORMAL
- en: '**Package Name**: `com.viber.voip`'
  prefs: []
  type: TYPE_NORMAL
- en: '**Files of interest**:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/files/preferences/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`activated_sim_serial`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`display_name`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reg_viber_phone_num`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/sdcard/viber/media/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/User Photos/`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/Viber Images/`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/Viber Videos/`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/databases/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`viber_data`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`viber_messages`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The files in `/files/preferences` contain the SIM card's ICCID, the name the
    user displays in the app, and the phone number used to register with the app.
  prefs: []
  type: TYPE_NORMAL
- en: The files in the `/sdcard/viber/media` path are the profile photos of people
    in the user's contact list who use Viber (regardless of whether they have been
    added as friends in the app), and all images and videos sent through the app.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `viber_data` file is a database, even though it does not have the `.db`
    file extension. It contains information about the user''s contacts:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Table** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `calls` | This table did not populate, even though we made calls from within
    the app. |'
  prefs: []
  type: TYPE_TB
- en: '| `phonebookcontact` | This table could be extremely valuable from a forensic
    standpoint. When Viber is first opened, it scrapes the user''s phonebook and adds
    all the entries it finds to this database. This means it may contain historical
    data about the user''s contacts; if they later delete an entry from the phonebook,
    it may still be recovered in this database. This table only includes names of
    contacts in the phonebook. |'
  prefs: []
  type: TYPE_TB
- en: '| `phonebookdata` | Similar to a phonebook contact, except it includes email
    addresses and phone numbers for contacts in the device''s phone book. |'
  prefs: []
  type: TYPE_TB
- en: '| `vibernumbers` | Shows the Viber phone number for each contact in the device''s
    phonebook that uses the app. The value in the `actual_photo` corresponds with
    the filenames in the `/sdcard/viber/media/User/ Photos` directory. |'
  prefs: []
  type: TYPE_TB
- en: 'The `viber_messages` file is a database, even though it does not have the `.db`
    file extension. It contains information about the app''s usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Table** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `conversations` | Contains a unique ID, the recipient, and date for each
    unique conversation. |'
  prefs: []
  type: TYPE_TB
- en: '| `messages` | Contains each individual message from all conversations. The
    address is the phone number of the remote party in the conversation. The date
    column is in Unix epoch format. The type column corresponds to incoming or outgoing:
    1 is an outgoing message, 0 is incoming. The `location_lat` and `location_lng`
    columns will be populated if a location is shared. Shared files can be sent with
    text to describe them; this is found in the description column. |'
  prefs: []
  type: TYPE_TB
- en: '| `messages_calls` | This table did not populate, even though we made calls
    from within the app. |'
  prefs: []
  type: TYPE_TB
- en: '| `participants_info` | Has profile information for each account that has been
    in a conversation with the user. |'
  prefs: []
  type: TYPE_TB
- en: Tango analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tango is a voice/text/video messaging application. It has over 100,000,000 downloads
    in the Play Store.
  prefs: []
  type: TYPE_NORMAL
- en: '**Package name**: `com.sgiggle.production`'
  prefs: []
  type: TYPE_NORMAL
- en: This package name is seemingly innocuous, and could be overlooked by an examiner
    thinking it was a game. This is an example of why every application should be
    analyzed.
  prefs: []
  type: TYPE_NORMAL
- en: '**Files of interest**:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/sdcard/Android/data/com.sgiggle.production/files/storage/appdata/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TCStorageManagerMediaCache_v2/`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`conv_msg_tab_snapshots/`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/files/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tc.db`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`userinfo.xml.db`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `/TCStorageManagerMediaCache_v2` path on the SD card contains images that
    were sent and received with the application, as well as profile pictures of contacts.
    However, it also contains many images that were never seen or used in the application;
    they appear to either be images for ads or stock emoji type images that can be
    attached to conversations. The filenames found here can be correlated with `tc.db`
    to find the exact image that was used in a conversation.
  prefs: []
  type: TYPE_NORMAL
- en: The `conv_msg_tab_snapshots` path on the SD card contains files with a `.dat`
    extension. When viewed in a hex editor, we were able to find snippets of conversations
    in plaintext, as well as paths and URLs to images sent and received in conversations.
    It is unclear what causes these files to exist, but it may be possible to retrieve
    content from these files that may have been deleted in `tc.db`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `tc.db` database is what Tango uses to store all message information:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Table** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `conversations` | Contains a unique ID in the `conv_id` column for each conversation.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `messages` | Contains messages sent and received through the app. The `msg_id`
    column is a unique identifier for each message, and the `conv_id` column identifies
    which conversation the message is from. The `send_time` column identifies the
    time a message was sent, or when it was received, depending on the direction.
    The direction column shows the direction of the message: 1 = sent and 2 = received.
    The type column identifies the type of the message; based on our testing, they
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**0**: Plaintext message'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**1**: Video message'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**2**: Audio message'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**3**: Image'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**4**: Location/coordinates'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**35**: Voice call'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**36**: Attempted voice call (missed by either party)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**58**: Attached stock image, such as the emojis found in the `TCStorageManagerMediaCache_v2`
    path'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, the payload column contains the content of the message… sort of. The
    data is Base64-encoded, which will be discussed in detail below. |
  prefs: []
  type: TYPE_NORMAL
- en: The `user_info_xml.db` contains metadata about the account, such as the user's
    name and phone number. However, its data is entirely Base64-encoded, like the
    messages in `tc.db`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Data storage method 6: Base64'
  prefs: []
  type: TYPE_NORMAL
- en: Decoding Tango messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Base64 is an encoding scheme that is commonly used for data transport; it is
    not considered encryption because it has a known method for decoding, and does
    not require a unique key to decode the data. Base64 contains ASCII-printable characters,
    but the underlying data is binary (which will make our output somewhat messy!).
    An example from the payload column in the messages table of tc.db looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note the equal signs on the end of our message; this is a strong indicator that
    data is Base64-encoded. The input that will be encoded needs to be divisible by
    3 for the math behind Base64 to work properly. If the input is not divisible by
    3, it will be padded, resulting in the equal signs seen in the output.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Input string** | **Number of characters/bytes** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| `Hello, World` | `12` | `SGVsbG8sIFdvcmxk` |'
  prefs: []
  type: TYPE_TB
- en: '| `Hello, World!` | `13` | `SGVsbG8sIFdvcmxkIQ==` |'
  prefs: []
  type: TYPE_TB
- en: '| `Hello, World!!` | `14` | `SGVsbG8sIFdvcmxkISE=` |'
  prefs: []
  type: TYPE_TB
- en: You can see that the 12-byte input (divisible by 3) has no padding, while the
    other two input do have padding because they are not divisible by 3\. This is
    important because it shows that while the equal signs are a strong indicator of
    Base64, the lack of an equal sign does not mean it isn't Base64!
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we understand a little about Base64, and recognize that our payload
    column is very likely encoded in Base64, we need to decode it. There are websites
    that will allow the user to paste in encoded data, and it will be decrypted (such
    as [www.base64decode.org](http://www.base64decode.org)), but this is inconvenient
    for large amounts of data as each message must be input individually (and putting
    evidentiary data on the internet is also frowned upon in most cases). Likewise,
    it can be decoded on the command line of Linux-based systems, but is equally inconvenient
    for large amounts of data. Our solution was to build a Python script that pulls
    the Base64 data from the database, decodes it, and writes it back out to a new
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'To run the code, simply paste this code into a new file, named `tcdb.py`, place
    the script in the same directory as `tc.db`, and on the command line navigate
    to that directory and run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The script will make a file named `tcdb_out.txt` in the same directory. Opening
    the file in a text editor (or importing it into Excel as a tab-delimited file)
    will show the `msg_id` value so that the examiner can correlate the message back
    to the messages table, and the decoded payload shows a plaintext message (noted
    as type 0 in the database):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6e2ee03c-aed9-43cf-9e53-1dc65c120b30.png)'
  prefs: []
  type: TYPE_IMG
- en: Note that the message content is now visible in plaintext, and is preceded by
    the conversation ID. There is also a ton of binary data cluttering up our output;
    this is likely metadata or other information used by Tango. If the message was
    received, the user's name will also be in the output (here it is Tango).
  prefs: []
  type: TYPE_NORMAL
- en: 'There are other messages types worth looking at. Here is a decoded payload
    entry for a video message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7de46304-7f2f-4f6f-ab43-f16845e24548.png)'
  prefs: []
  type: TYPE_IMG
- en: Note that with the video message, we can see two URLs. They are both public,
    meaning anyone with the link can access them. The URL ending in thumbnail is a
    thumbnail of the video, while the other URL will download the complete video in
    MP4 format. The path to the SD card and filename for the image is also shown.
  prefs: []
  type: TYPE_NORMAL
- en: Image and audio messages are stored in a very similar format, and contain URLs
    to either view or download the file, as well as the path to the file on the SD
    card.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a sample location message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/591003d2-6f67-436a-afbb-9c6885fc5ee0.png)'
  prefs: []
  type: TYPE_IMG
- en: This time, we can see the exact coordinates the user was at, as well as the
    address. Again, a path on the SD card is also present, and will show the map view
    of the location. As with the other message types, a received message would also
    show the sender's name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s take a look at the `userinfo.xml.db` database. Here is what
    it looks like before being decoded properly:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7c5925fe-2196-4cbb-9242-5f64f7a9c9a7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We wrote another script very similar to the first to parse the `userinfo.xml.db`
    database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The only difference in the code is that the filenames, table names, and values
    changed, and this time both of the columns in the database are base64-encoded.
    Again, it can be run by placing it in the same location as `userinfo.xml.db` and
    running it with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the relevant portion of the resulting output file, showing the personal
    data the user used to register the account:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1303398c-f8bf-43d8-bbbb-86fc1b6df47c.png)'
  prefs: []
  type: TYPE_IMG
- en: Further down in the output, there is also a list of all of the user's contacts
    who use Tango, and it includes the contacts' names and phone numbers.
  prefs: []
  type: TYPE_NORMAL
- en: WhatsApp analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: WhatsApp is a popular chat/video messaging service with over 500,000,000 downloads
    in Google Play.
  prefs: []
  type: TYPE_NORMAL
- en: '**Package name**: `com.whatsapp`'
  prefs: []
  type: TYPE_NORMAL
- en: '**Files of interest**:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/files/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Avatars/`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`me`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`me.jpeg`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/shared_prefs/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RegisterPhone.xml`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`` `VerifySMS.xml` ``'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/databases/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`msgstore.db`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`wa.db`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/sdcard/WhatsApp/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Media/`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Databases/`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `/files/avatars` directory contains thumbnails of the profile pictures of
    contacts that use the app, and `me.jpg` is a full-size version of the user's profile
    picture. The me file contains the phone number associated with the account.
  prefs: []
  type: TYPE_NORMAL
- en: The phone number associated with the account can also be recovered in `/shared_prefs/RegisterPhone.xml`.
    The `/shared_prefs/VerifySMS.xml` file shows the time that the account was verified
    (in Unix epoch format, of course), indicating when the user first began using
    the app.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `msgstore.db` database, like it sounds, contains messaging data:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Table** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `chat_list` | The `key_remote_jid` column shows each account the user has
    communicated with; the value in the table is the remote user''s phone number.
    For example, if the value is `13218675309@s.whatsapp.net`, the remote user''s
    number is `1-321-867-5309`. |'
  prefs: []
  type: TYPE_TB
- en: '| `group_participants` | Contains metadata about group chats. |'
  prefs: []
  type: TYPE_TB
- en: '| `messages` | Shows all message data. Once again, the `key_remote_jid` field
    identifies the remote sender. The `key_from_me` value indicates the direction
    of the message (0=received, 1=sent). The data column contains the text of messages,
    and timestamp is the sent or received time in Linux epoch format.For attachments,
    `media_mime_type` identifies the file format; the `media_size` and `media_name`
    columns should be self-explanatory. If the attachment had a caption, the text
    would be shown in the `media_caption` column. If the attachment was a location,
    the latitude and longitude columns will be populated appropriately. The `thumb_image`
    column has a lot of useless data in it, but also contains the path of the attachment
    on the device. The `raw_data` column contains thumbnails for images and videos.
    |'
  prefs: []
  type: TYPE_TB
- en: 'The `wa.db` database is used to store contact information:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Table** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `wa_contacts` | Like other apps, WhatsApp scrapes and stores the user''s
    entire phonebook, and stores the information in its own database. It contains
    the contact''s name and phone number, as well as a status if that contact is a
    WhatsApp user. |'
  prefs: []
  type: TYPE_TB
- en: The SD card is a treasure trove of WhatsApp data. The `/sdcard/WhatsApp/Media`
    folder contains a folder for each type of media (Audio, Calls, Images, Video,
    and Voice Notes), and stores all attachments of that type in the folder. Sent
    media is stored in a directory called, unimaginatively, Sent. Received media is
    simply stored in the root of the folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Databases directory is an even greater source of information. WhatsApp
    makes a backup of `msgstore.db` nightly, and stores the backups here. This allows
    an examiner to see historical data that may have been deleted; if I delete a chat
    today, but you look at a backup from yesterday, you''ll be able to access the
    data I deleted. The app is even kind enough to put the date in the filename, for
    example: `msgstore-2018-12-12.1.db.crypt12`. The only catch is that these backups
    are encrypted!'
  prefs: []
  type: TYPE_NORMAL
- en: Decrypting WhatsApp backups
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Luckily, there is a tool available to decrypt the backups. It can be found
    here, along with detailed instructions: [https://andreas-mausch.de/whatsapp-viewer/](https://andreas-mausch.de/whatsapp-viewer/).
    WhatsApp Viewer can be used to decrypt different versions of encrypted WhatsApp
    databases. In this example, we are going to decrypt its latest version, `.crypt12`:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to File | Decrypt .crypt12….
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Choose encrypted database file and key file (can be found in the `/files` directory):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/618d37b8-0d88-4452-b46a-bedc01ea32e1.png)'
  prefs: []
  type: TYPE_IMG
- en: Click the Decrypt… button and choose the location of the decrypted database
    file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Data storage method 7: Encrypted files'
  prefs: []
  type: TYPE_NORMAL
- en: Kik analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kik is a messaging app with over 100,000,000 downloads from the Play Store.
  prefs: []
  type: TYPE_NORMAL
- en: '**Package name**: `kik.android`'
  prefs: []
  type: TYPE_NORMAL
- en: '**Files of interest**:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/cache/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`chatPicsBig/`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`contentpics/`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`profPics/`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/files/staging/thumbs`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/shared_prefs/KikPreferences.xml`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/sdcard/Kik/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/databases/kikDatabase.db`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `chatPicsBig` and `contentpics` directories in `/cache` contain images that
    were sent and received within the application. The files in `contentpics` contain
    what appears to be `Kik` metadata embedded before the image; the JPG has to be
    carved out of these files. In our testing, all of the files in `contentpics` were
    also stored in `chatPicsBig`, though this may change with more extensive app usage.
    The user's profile picture is found in /the `/profPics` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Data storage method 8: Basic steganography; a file is stored within a larger
    file.'
  prefs: []
  type: TYPE_NORMAL
- en: The `/files/staging/thumbs` directory contains thumbnails of images sent and
    received with the application; our testing found the same images in this location
    as the `/cache` directories, but again it is possible this would vary with more
    extensive application usage.
  prefs: []
  type: TYPE_NORMAL
- en: The `KikPreferences.xml` file in `/shared_prefs` shows the user's username and
    email address used with the application. Interestingly, it also contains an unsalted
    SHA1 hash of the user's password.
  prefs: []
  type: TYPE_NORMAL
- en: The `/sdcard/Kik` directory contains full-sized images that were sent and received
    in the application. The filenames can be correlated with `kikDatabase.db messagesTable`
    to identify which message contained the image.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `kikDatabase.db` database contains all of the messaging data from the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Table** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `KIKContentTable` | This table contains metadata about sent and received
    images. Each message is assigned a unique `content_id` value that corresponds
    to the filenames in the `sdcard/Kik` directory. The preview and icon values for
    each image correspond to the filenames found at `/files/staging/thumbs`. Each
    image also contains a `file-url` value; this is a public URL that can be accessed
    to view the file. |'
  prefs: []
  type: TYPE_TB
- en: '| `KIKcontactsTable` | This table shows `user_name` and `display_name` for
    each contact. The `in_roster` value appears to be set for contacts the user has
    specifically added (if it is set to `1`); contacts with an `in_roster` value of
    0 appear to be added automatically. The `jid` column is a unique value for each
    contact. |'
  prefs: []
  type: TYPE_TB
- en: '| `messagesTable` | This table contains all data for messages sent and received
    with the app. The body column shows the text data sent in a message. The `partner_jid`
    value can be correlated back to the `jid` column in `KIKcontactTable` to identify
    the remote user. The `was_me` column is used to indicate the direction of the
    message (`0` = sent, `1` = received). The `read_state` column shows whether the
    message has been read (`500` = read and `400` = unread). The timestamp, yet again,
    is in Linux epoch format. The `content_id` column is populated with message attachments,
    and can be correlated to `KIKContentTable` for more information. |'
  prefs: []
  type: TYPE_TB
- en: WeChat analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: WeChat is a messaging app with over 100,000,000 downloads in the Play Store.
  prefs: []
  type: TYPE_NORMAL
- en: '**Package name**: `com.tencent.mm`'
  prefs: []
  type: TYPE_NORMAL
- en: Note that some of these paths contain an asterisk (*). This is used to indicate
    a unique string that will differ for each account. Our device had `7f804fdbf79ba9e34e5359fc5df7f1eb`
    in place of the asterisk.
  prefs: []
  type: TYPE_NORMAL
- en: '**Files of interest**:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/files/host/*.getdns2`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/shared_prefs/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`com.tencent.mm_preferences.xml`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`system_config_prefs.xml`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/sdcard/tencent/MicroMsg/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`diskcache/`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WeChat/`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/sdcard/tencent/MicroMsg/*/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`image2/`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`video/`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`voice2/`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/MicroMsg/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CompatibleInfo.cfg`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*/EnMicroMsg.db`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `*.getdns2` files found in `/files/host` can be opened as text files or
    in a hex editor. There is a section called `[clientip]` that shows the IP address
    from which the user connected, as well as the time of the connection in Linux
    epoch format. Our device contained three of these files to show three different
    connections, though increased application usage may generate more than three of
    these files.
  prefs: []
  type: TYPE_NORMAL
- en: The `com.tencent.mm_preferences.xml` file in `/shared_prefs` records the device's
    phone number in the `login_user_name` field. The `system_config_prefs.xml` file
    contains the path to the user's profile picture on the device, as well as a `default_uin`
    value that will be needed later.
  prefs: []
  type: TYPE_NORMAL
- en: The SD card contains a wealth of WeChat data. The `/tencent/MicroMsg/diskcache`
    directory contained an image that was never used with the application; we think
    it was put there when attaching a different image, as WeChat loads a view of many
    images from the device's gallery. The `/WeChat` directory within `/sdcard/tencent/MicroMsg`
    contained images sent from the device.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `/video`, `/voice`, and `/voice2` folders within `/sdcard/tencent/MicroMsg/*`
    contain exactly what they say: video and voice files sent using the app.'
  prefs: []
  type: TYPE_NORMAL
- en: WeChat is fairly unique in that it does not utilize a `/databases` directory
    within the app's directory structure; `MicroMsg` is its equivalent. `CompatibleInfo.cfg`
    contains the device's IMEI, which will be useful later.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `*` directory within `/MicroMsg` contains the `EnMicroMsg.db` database.
    There''s only one problem: the database is encrypted using SQLCipher! SQLCipher
    is an open source extension for SQLite that encrypts the entire database. Luckily,
    like other apps that use encryption, the key to decrypting the file is on the
    device.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Data storage method 9: SQLCipher, full database encryption'
  prefs: []
  type: TYPE_NORMAL
- en: Decrypting the WeChat EnMicroMsg.db
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Fortunately for us, Forensic Focus has an excellent article on doing exactly
    this: [http://articles.forensicfocus.com/2014/10/01/decrypt-wechat-enmicromsgdb-database/](http://articles.forensicfocus.com/2014/10/01/decrypt-wechat-enmicromsgdb-database/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'They even provide a Python script to do the work for us: [https://gist.github.com/fauzimd/8cb0ca85ecaa923df828/download#](https://gist.github.com/fauzimd/8cb0ca85ecaa923df828/download#).'
  prefs: []
  type: TYPE_NORMAL
- en: 'To run the Python script, simply put the `EnMicroMsg.db` file and the `system_config_prefs.xml`
    files in the same directory as the script and, in the command line, type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The script will then prompt you for the IMEI of the device. This can be found
    in the `/MicroMsg/CompatibleInfo.cfg` file, printed somewhere on the device (behind
    the battery, on the SIM card tray, or etched onto the back of the device are common
    locations), or typing `*#06#` in the keypad.
  prefs: []
  type: TYPE_NORMAL
- en: The script should run, and place a file called `EnMicroMsg-decrypted.db` in
    the directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now examine `EnMicroMsg-decrypted.db`:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Table** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `ImgInfo2` | Contains path information for sent and received images. The
    `bigImgPath` column contains the filename for the image; this can be searched
    on the SD card to find the picture. Alternatively, images are stored in the `/sdcard/tencent/MicroMsg/*/image2`
    directory in folders that correspond to the filename. For example, the `3b9edb119e04869ecd7d1b21a10aa59f.jpg`
    file can be found in the `image2` directory in the `/3b/9e` path. The folders
    are broken down by the first two bytes of the name, then the second two bytes
    of the name. `thumbImgPath` contains the name of thumbnails for the images. |'
  prefs: []
  type: TYPE_TB
- en: '| `message` | Contains all message information for the app. The `isSend` column
    indicates the message direction (`0` = received, `1` = sent). The `createTime`
    table is the timestamp of the message, in Linux epoch format. The talker column
    contains a unique ID for the remote user, this can be correlated with the `rcontact`
    table to identify the remote user. The content column shows the data of messages
    sent as text, and identifies video calls as `voip_content_voice`. `imgPath` contains
    the path to image thumbnails, which can be correlated with the `ImgInfo2` table
    to locate the full-sized images. It also includes file names for audio files,
    which can be searched for or located in the `/sdcard/tencent/MicroMsg/*/voice2`
    directory. |'
  prefs: []
  type: TYPE_TB
- en: '| `rcontact` | Contains a list of contacts, and includes many that are added
    by default by the app. The username can be correlated with the talker column in
    the message table. The nickname column shows the user''s name. The type column
    is an indicator of whether the contact was added manually or automatically (`1`
    = device user, `3` = added by user, `33` = added by app). The exception to this
    is the `weixin` user, which is automatically added, but has a type value of 3.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `userinfo` | This table contains info about the user, including name and
    phone number. |'
  prefs: []
  type: TYPE_TB
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter has been an in-depth study of specific Android applications, and
    how/where they store their data. We looked at 19 specific applications, and discovered
    9 different methods of storing and obfuscating data. Knowing that applications
    store their data in a variety of ways should help an examiner have a better understanding
    of the data that they are examining, and hopefully push them to look harder when
    they can't find data they expect an app to have. An examiner has to be able to
    adapt to the changing world of application analysis; since applications constantly
    update, an examiner has to be able to update their own methods and abilities in
    order to keep up.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will take a look at several free/open source and commercial
    tools to image and analyze Android devices.
  prefs: []
  type: TYPE_NORMAL
