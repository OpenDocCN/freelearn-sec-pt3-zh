<html><head></head><body>
        

                            
                    <h1 class="header-title">Parallel Data Processing</h1>
                
            
            
                
<p>I remember sitting in front of my ZX Spectrum with 64 KB of memory (16 KB ROM + 48 KB RAM) with an old tape recorder plugged in, and a newly bought cassette inserted. Among the relatively large amount of programs on the cassette, there was one that specifically drew my attention. Not that it was able to do anything special; after all, it simply computed personal biorhythm graphs based on the date of birth (in fact, I had to enter the current date too) and plotted them on the screen. There wasn't even any sophistication in the algorithm (how ever sophisticated an algorithm may be when it is all about calculation of sine over some value). What seemed to be interesting was the Wait while results are being processed message, which had some kind of a progress bar that appeared for for almost half a minute (yes, I was naive enough to think that some calculations were really taking place "behind" the message), and the three graphs being plotted simultaneously. Well, it looked as if they were being plotted simultaneously.</p>
<p>The program was written in BASIC, so reversing it was a fairly easy task. Easy but disappointing. Of course, there was no parallel processing when plotting the graphs, simply the same function, sequentially called for each graph on each point.</p>
<p>Obviously, the ZX Spectrum was not the right platform to look for parallel processing capabilities. Intel architecture, on the other hand, provides us with such a mechanism. In this chapter, we will examine a few capabilities provided by the <strong>Streaming SIMD Extension</strong> (<strong>SSE</strong>), which allows simultaneous computations on the so-called packed integers, the packed single precision or packed double precision floating point numbers that are contained in 128-bit registers.</p>
<p>We will begin the chapter with a brief introduction to the SSE technology, reviewing available registers and access modes thereof. Later, we will proceed to the implementation of the algorithm itself, which involves parallel operations of single precision floating point values related to all three biorhythms.</p>
<p>Some steps, which are essential for biorhythmic graph calculation and are trivial when implemented in high-level languages, like calculation of sine, exponentiation, and factorial, will be covered in more detail, as we do not have access (at this moment) to any math library; hence, we have no ready-to-use implementation of the procedures involved in the aforementioned calculations. We will make our own implementation for each step.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">SSE</h1>
                
            
            
                
<p>The Intel Pentium II processor brought along the <strong>MMX</strong> technology (unofficially called the <strong>MultiMedia eXtension</strong>, however, such an alias has never been used in Intel documentation), which provided us with the possibility of working with packed integer data using 64-bit registers. Despite the obvious benefit, there were at least two disadvantages:</p>
<ul>
<li>We could process integer data only</li>
<li>The MMX registers were mapped onto the registers of the <strong>floating-point unit</strong> (<strong>FPU</strong>)</li>
</ul>
<p>While being better than nothing, the MMX technology still did not provide enough computational power.</p>
<p>The situation changed a lot with the introduction of the Pentium III processor with its Streaming SIMD Extension with its own set of 128-bit registers and instructions, allowing a wide range of operations to be performed on scalar or packed bytes, 32-bit integers, 32-bit single precision floating-point values, or 64-bit double precision floating point values.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Registers</h1>
                
            
            
                
<p>Intel-based processors have 8 XMM registers for use with SSE, which are named XMM0 to XMM7 on 32-bit platforms, and 16 XMM registers, named XMM0 to XMM15, on 64-bit platforms. It is important to note that only 8 XMM registers are available on 64-bit platforms while not in long mode.</p>
<p>The content of each of the XMM registers may be considered to be one of the types below:</p>
<ul>
<li>16 bytes (which we saw in the AES-NI implementation)</li>
<li>Eight 16-bit words</li>
<li>Four 32-bit double words</li>
<li>Four 32-bit single precision floating-point numbers (we will use the registers this way throughout the chapter)</li>
<li>Two 64-bit quad words</li>
<li>Two 64-bit double precision floating point numbers</li>
</ul>
<p>SSE instructions are able to operate on the same parts of registers that are used as operands and on different parts of the operands (for example, they can move the lower part of the source register to the higher part of the destination register).</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Revisions</h1>
                
            
            
                
<p>There are, at the moment, five revisions of the SSE instruction set (and hence of the technology), which are as follows:</p>
<ul>
<li><strong>SSE</strong>: This was introduced in 1999 and contained the initial design of the technology and instructions thereof</li>
<li><strong>SSE2</strong>: This revision came out with Pentium 4 and brought 144 new instructions with it</li>
<li><strong>SSE3</strong>: Although only 13 new instructions were added with SSE3, they introduced the ability to perform the so-called "horizontal" operations (operations performed on a single register)</li>
<li><strong>SSSE3</strong>: This introduced 16 new instructions, including the instructions for horizontal integer operations</li>
<li><strong>SSE4</strong>: This brought another 54 instructions, thus making life significantly easier for developers</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Biorhythm calculator</h1>
                
            
            
                
<p>I have mentioned it before and I would like to reiterate that, in my eyes, the best way to understand and learn things is by example. We began this chapter by mentioning an old program for biorhythm level calculation and it seems that this program, when implemented using the SSE architecture, may be a simple yet good example of how parallel calculations may be performed. The code in the next section demonstrates biorhythms calculations for my humble self for the period between May 9, 2017 and May 29, 2017, storing results into a table. All calculations (including exponentiation and sine) are implemented using SSE instructions and, obviously, XMM registers.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The idea</h1>
                
            
            
                
<p>The word "biorhythm" originates from two Greek words; "bios", meaning life and "rhythmos", meaning rhythm. The idea itself was developed by Wilhelm Fliess, a German otolaryngologist, who lived in the late nineteenth and the beginning of the twentieth centuries. He believed that our life is influenced by biological cycles, which affect the mental, physical, and emotional aspects.</p>
<p>Fliess derived three major biorhythmic cycles:</p>
<ul>
<li><strong>Physical cycle</strong><br/>
Duration: 23 days<br/>
Denotes:
<ul>
<li>Coordination</li>
<li>Strength</li>
<li>Well-being</li>
</ul>
</li>
<li><strong>Emotional cycle</strong><br/>
Duration: 28 days<br/>
Denotes:
<ul>
<li>Creativity</li>
<li>Sensitivity</li>
<li>Mood</li>
<li>Awareness</li>
</ul>
</li>
<li><strong>Intellectual cycle</strong><br/>
Duration: 33 days<br/>
Denotes:
<ul>
<li>Alertness</li>
<li>Analytical and logical abilities</li>
<li>Communication</li>
</ul>
</li>
</ul>
<p>The theory itself may be quite arguable, especially since it is considered pseudoscience by most of scientific public; however, it is scientific enough to, at least, serve for an example of a parallel data processing mechanism.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The algorithm</h1>
                
            
            
                
<p>The algorithm of biorhythm calculation is fairly simple, not to say trivial.</p>
<p>Variable values, used to specify the rate of each biorhythm at specific date, are in the (-1.0, 1.0) range and are calculated using this formula:</p>
<div><em>x = sin((2 * PI *t) / T)</em></div>
<p>Here, <em>t</em> is the number of days that have passed since the date of the person's birth till the date we want to know the biorhythms' values for (most likely, the current date), and <em>T</em> is the period of a given biorhythm.</p>
<p>There aren't too many things we may optimize with the aid of the SSE technology. What we definitely can do is calculate data for all three types of biorhythms at once, which in turn is sufficient to demonstrate the abilities and power of the Streaming SIMD Extension.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Data section</h1>
                
            
            
                
<p>As there is no specific order of sections in the source file, we will begin with a quick look at the data section in order to better comprehend the code. The data section or, to be more precise, the arrangement of data in a data section, is quite self-explanatory. The emphasis was made on data alignment, allowing faster access with aligned SSE instructions:</p>
<pre>section '.data' data readable writeable<br/>   <em>; Current date and birth date</em><br/><em>   ; The dates are arranged in a way most suitable</em><br/><em>   ; for use with XMM registers</em><br/>   cday   dd 9               <em>; Current day of the month</em><br/>   cyear  dd 2017            <em>; Current year</em><br/>   bday   dd 16              <em>; Birth date day of the month</em><br/>   byear  dd 1979            <em>; Birth year</em><br/><br/>   cmonth dd 5               <em>; 1-based number of current month</em><br/>          dd 0              <br/>   bmonth dd 1               <em>; 1-based number of birth month</em><br/>          dd 0<br/><br/><br/>   <em>; These values are used for calculation of days</em><br/><em>   ; in both current and birth dates</em><br/>   dpy    dd 1.0<br/>          dd 365.25<br/><br/>   <em>; This table specifies number of days since the new year</em><br/><em>   ; till the first day of specified month.</em><br/><em>   ; Table's indices are zero based</em><br/>monthtab:<br/>         dd 0   <em>; January</em><br/>         dd 31  <em>; February</em><br/>         dd 59  <em>; March</em><br/>         dd 90  <em>; April</em><br/>         dd 120 <em>; May</em><br/>         dd 151 <em>; June</em><br/>         dd 181 <em>; July</em><br/>         dd 212 <em>; August</em><br/>         dd 243 <em>; September</em><br/>         dd 273 <em>; October</em><br/>         dd 304 <em>; November</em><br/>         dd 334 <em>; December</em><br/><br/> align 16<br/> <em>; Biorhythmic periods</em><br/> T       dd 23.0 <em>; Physical</em><br/>         dd 28.0 <em>; Emotional</em><br/>         dd 33.0 <em>; Intellectual</em><br/><br/> pi_2    dd 6.28318 <em>; 2xPI - used in formula</em><br/><br/> align 16<br/> <em>; Result storage</em><br/><em> ; Arranged as table:</em><br/><em> ; Physical : Emotional : Intellectual : padding</em><br/> output  rd 20 * 4<br/><br/><em>; '.idata' section: contains import information, </em><br/><em>; is readable, is writeable</em><br/>section '.idata' import data readable writeable<br/><br/><em>; 'library' macro from 'win32a.inc' creates </em><br/><em>; proper entry for importing</em><br/><em>; functions from a dynamic link library. </em><br/><em>; For now it is only 'kernel32.dll'.</em><br/>library kernel, 'kernel32.dll'<br/><br/><em>; 'import' macro creates the actual entries </em><br/><em>; for functions we want to import from a dynamic link library</em><br/>import kernel,\<br/> exitProcess, 'ExitProcess'</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">The code</h1>
                
            
            
                
<p>We will begin with the standard template for 32-bit Windows (if you are on Linux, you may safely use the Linux template instead).</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Standard header</h1>
                
            
            
                
<p>First of all, we tell the assembler what kind of output we expect, which is the GUI executable (although, it would be without any GUI), what our entrypoint is, and, of course, we include the <kbd>win32a.inc</kbd> file in order to be able to call the <kbd>ExitProcess()</kbd> Windows API. Then, we create the code section:</p>
<pre>format PE GUI                             <em>; Specify output file format</em><br/>entry _start                              <em>; Specify entry point</em><br/>include 'win32a.inc'                      <em>; Include some macros</em><br/>section '.text' code readable executable  <em>; Start code section</em></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">The main() function</h1>
                
            
            
                
<p>The following is the analog of the C/C++ <kbd>main()</kbd> function, which controls the whole algorithm and is responsible for performing all the needed preparations as well as for the execution of the forecast calculation loop.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Data preparation steps</h1>
                
            
            
                
<p>First of all, we need to make some tiny corrections to the dates (months are specified by their number). We are interested in the number of days since January 1 until the first day of a month. The easiest and fastest way to perform such correction would be using a small table with 12 entries, containing the number of days between January 1 and the first day of a month. The table is called <kbd>monthtab</kbd> and is located in the data section.</p>
<pre><em>;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</em><br/><em>;</em><br/><em>; Entry point</em><br/><em>;</em><br/><em>;-----------------------------------------------------</em><br/>_start:<br/>   mov ecx, 20                     <em>; Length of biorhythm data to    </em><br/><em>                                   ; produce</em><br/><br/>   mov eax, [bmonth]               <em>; Load birth month</em><br/>   dec eax                         <em>; Decrement it in order to address   </em><br/><em>                                   ; 0-based array</em><br/><br/>   mov eax, [monthtab + eax * 4]   <em>; Replace month with number of days</em><br/><em>                                   ; since New Year</em><br/>   mov [bmonth], eax               <em>; Store it back</em><br/><br/>   mov eax, [cmonth]               <em>; Do the same for current month</em><br/>   dec eax<br/>   mov eax, [monthtab + eax * 4]<br/>   mov [cmonth], eax<br/><br/>   xor eax, eax                <em>; Reset EAX as we will use it as counter</em></pre>
<p>The preceding code illustrates this very fix being applied:</p>
<ul>
<li>We read the month number from the birth date</li>
<li>Decrement it as the table we are using is in fact a 0-based array of values</li>
<li>Replace the original month number with the value read from the table</li>
</ul>
<p>By the way, the addressing mode used when reading a value from the table is a variation of the scale/index/base/displacement. As we may see, <kbd>monthtab</kbd> is the displacement, <kbd>eax</kbd> register holds the index and 4 is the scale.</p>
<p>The day/month/year of the two dates are specifically pre-arranged to fit properly in the XMM registers and to ease calculations. It may seem that the first line of the following code loads the value of <kbd>cday</kbd> into XMM0, but, in fact, the instruction being used loads <kbd>xmmword</kbd> (128-bit data type) starting from the address of <kbd>cday</kbd>, meaning that it loads four values into XMM0:</p>
<table style="width: 918px;height: 163px">
<tbody>
<tr>
<td>
<div><strong>bits 96 - 127</strong></div>
</td>
<td>
<div><strong>bits 64 - 95</strong></div>
</td>
<td>
<div><strong>bits 32 - 63</strong></div>
</td>
<td>
<div><strong>bits 0 - 31</strong></div>
</td>
</tr>
<tr>
<td>
<div><kbd>byear</kbd></div>
</td>
<td>
<div><kbd>bday</kbd></div>
</td>
<td>
<div><kbd>cyear</kbd></div>
</td>
<td>
<div><kbd>cday</kbd></div>
</td>
</tr>
<tr>
<td>
<p class="CDPAlignCenter CDPAlign">1979</p>
</td>
<td>
<p>16</p>
</td>
<td>
<p>2017</p>
</td>
<td>
<p>9</div>
</td>
</tr>
</tbody>
</table>
<div>Data representation in the XMM0 register</p>
<p>Similarly, the second <kbd>movaps</kbd> loads XMM1 register with four double words starting at address of <kbd>cmonth</kbd>:</p>
<table style="width: 916px;height: 161px">
<tbody>
<tr>
<td>
<div><strong>bits 96 - 127</strong></div>
</td>
<td>
<div><strong>bits 64 - 95</strong></div>
</td>
<td>
<div><strong>bits 32 - 63</strong></div>
</td>
<td style="height: 20px">
<div><strong>bits 0 - 31</strong></div>
</td>
</tr>
<tr>
<td>
<p>0</div>
</td>
<td>
<div><kbd>bmonth</kbd></p>
</td>
<td>
<p>0</div>
</td>
<td>
<div><kbd>cmonth</kbd></p>
</td>
</tr>
<tr>
<td>
<p>0</div>
</td>
<td>
<div>0</p>
</td>
<td>
<p class="CDPAlignCenter CDPAlign">0</p>
</td>
<td>
<p>120</p>
</td>
</tr>
</tbody>
</table>
<p>Data representation in the XMM1 register</p>
<p>As we can see, placing the two tables directly one above the other and thinking of them as XMM registers 0 and 1, we have <kbd>cmonth</kbd>/<kbd>cday</kbd> and <kbd>bmonth</kbd>/<kbd>bday</kbd> loaded to the same double words in both XMM0 and XMM1. We will see why such an arrangement of the data was so important in a few moments.</p>
<p>The <kbd>movaps</kbd> instruction is only able to move data between two XMM registers or an XMM register and a 16 bytes aligned memory location. You should use <kbd>movups</kbd> for accessing unaligned memory locations.</p>
<p>In the last two lines of the following code fragment, we convert the values we have just loaded from double words to single precision float numbers:</p>
<pre>   movaps xmm0, xword[cday]    <em>; Load the day/year parts of both dates</em><br/>   movapd xmm1, xword[cmonth]  <em>; Load number of days since Jan 1st for both dates</em><br/>   cvtdq2ps xmm0, xmm0         <em>; Convert loaded values to single precision floats</em><br/>   cvtdq2ps xmm1, xmm1</pre>
<p>We still have not finished conversion of dates into the amount of days, as years are still, well, years, and the number in days of a month and the number of days since January 1st for both dates are still stored separately. All we have to do before summation of the days for each date is multiply each year by 365.25 (where 0.25 is a compensation for leap years). However, parts of the XMM registers cannot be accessed separately, as with parts of general purpose registers (for example, there is no analog to AX, AH, AL in EAX). We can, however, manipulate parts of XMM registers by using special instructions. In the first line of the following code fragment we load the lower 64-bit part of XMM2 register with two float values stored at <kbd>dpy</kbd> (days per year). The aforementioned values are <kbd>1.0</kbd> and <kbd>365.25</kbd>. What does 1.0 have to do with it, you may ask, and the answer is shown in the following table:</p>
<table>
<tbody>
<tr>
<td><strong>bits 96 - 127</strong></td>
<td><strong>bits 64 - 95</strong></td>
<td><strong>bits 32 - 63</strong></td>
<td><strong>bits 0 - 31</strong></td>
<td><strong>register name</strong></td>
</tr>
<tr>
<td>1979.0</td>
<td>16.0</td>
<td>2017.0</td>
<td>9.0</td>
<td>XMM0</td>
</tr>
<tr>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>120.0</td>
<td>XMM1</td>
</tr>
<tr>
<td>0.0</td>
<td>0.0</td>
<td>365.25</td>
<td>1.0</td>
<td>XMM2</td>
</tr>
</tbody>
</table>
<p>Content of XMM0 - XMM2 registers</p>
<p>Packed operations on XMM registers (packed means operations on more than one value) are, most of the time, performed in columns. Thus, in order to multiply <kbd>2017.0</kbd> by <kbd>365.25</kbd>, we need to multiply XMM2 by XMM0. However, we must not forget about <kbd>1979.0</kbd> either, and the easiest way to multiply both <kbd>2017.0</kbd> and <kbd>1979.0</kbd> by <kbd>365.25</kbd> with a single instruction is to copy the content of the lower part of XMM2 register to its upper part with the <kbd>movlhps</kbd> instruction.</p>
<pre>   movq xmm2, qword[dpy]  <em>; Load days per year into lower half of XMM2</em><br/>   movlhps xmm2, xmm2     <em>; Duplicate it to the upper half</em></pre>
<p>After these instructions the content of the XMM0 - XMM2 registers should look like this:</p>
<table>
<tbody>
<tr>
<td><strong>bits 96 - 127</strong></td>
<td><strong>bits 64 - 95</strong></td>
<td><strong>bits 32 - 63</strong></td>
<td><strong>bits 0 - 31</strong></td>
<td><strong>register name</strong></td>
</tr>
<tr>
<td>1979.0</td>
<td>16.0</td>
<td>2017.0</td>
<td>9.0</td>
<td>XMM0</td>
</tr>
<tr>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>120.0</td>
<td>XMM1</td>
</tr>
<tr>
<td>365.25</td>
<td>1.0</td>
<td>365.25</td>
<td>1.0</td>
<td>XMM2</td>
</tr>
</tbody>
</table>
<p>Content of XMM0 - XMM2 registers after movlhps</p>
<p>Use <kbd>pinsrb</kbd>/<kbd>pinsrd</kbd>/<kbd>pinsrq</kbd> instructions for insertions of individual bytes/double words/quad words into an XMM register when needed. They are not used in our code for the purpose of demonstration of horizontal operations.</p>
<p class="packt_figref">Now we are safe to proceed with multiplication and summation:</p>
<pre>addps xmm1, xmm0      <em>; Summation of day of the month with days since January 1st</em><br/>mulps xmm2, xmm1      <em>; Multiplication of years by days per year</em><br/>haddps xmm2, xmm2     <em>; Final summation of days for both dates</em><br/>hsubps xmm2, xmm2     <em>; Subtraction of birth date from current date</em></pre>
<p>The preceding code first calculates the total number of days since January 1 up to the day of the month for both dates on the first line. On the second line, at last, it multiplies the years of both dates by the number of days per year. This line also explains why the days per year value was accompanied by <kbd>1.0</kbd>--as we are multiplying XMM1 by XMM2 and we do not want to lose the previously calculated number of days, we simply multiply the number of days since January 1st by <kbd>1.0</kbd>.</p>
<p>At this moment the content of the three XMM registers should be like this:</p>
<table>
<tbody>
<tr>
<td><strong>bits 96 - 127</strong></td>
<td><strong>bits 64 - 95</strong></td>
<td><strong>bits 32 - 63</strong></td>
<td><strong>bits 0 - 31</strong></td>
<td><strong>register name</strong></td>
</tr>
<tr>
<td>1979.0</td>
<td>16.0</td>
<td>2017.0</td>
<td>9.0</td>
<td>XMM0</td>
</tr>
<tr>
<td>1979.0</td>
<td>16.0</td>
<td>2017.0</td>
<td>129.0</td>
<td>XMM1</td>
</tr>
<tr>
<td>722829.75</td>
<td>16.0</td>
<td>736709.25</td>
<td>129.0</td>
<td>XMM2</td>
</tr>
</tbody>
</table>
<p>Content of XMM0 - XMM2 registers after addition of days and multiplication by days per year of relative parts of XMM2 and XMM1 registers</p>
<p>There are two remaining operations to perform:</p>
<ul>
<li>Finalize calculation of the total number of days for each date</li>
<li>Subtract the earlier date from the later one</li>
</ul>
<p>By this time, all of the values that we need to use in our calculations are stored in a single register, XMM2. Luckily, SSE3 introduced two important instructions:</p>
<ul>
<li><kbd>haddps</kbd>: Horizontal addition of single-precision values<br/>
Adds the single-precision floating-point values in the first and second and in third and fourth dwords of the destination operand, and stores the results in the first and second dwords of the destination operand respectively. The third and fourth dwords are overwritten with the results too, where the third dword contains the same value as the first dword and the fourth dword the same value as the second dword.</li>
<li><kbd>hsubps</kbd>: Horizontal subtraction of single-precision values<br/>
Subtracts the single-precision floating-point value in the second dword of the destination operand from the first dword of the destination operand and the value of the fourth dword of the destination operand from the third dword, and stores the results into the first and second dwords and third and fourth dwords of the destination operand respectively.</li>
</ul>
<p>Upon completion of <kbd>hsubps</kbd> instruction, the content of the registers should be:</p>
<table>
<tbody>
<tr>
<td><strong>bits 96 - 127</strong></td>
<td><strong>bits 64 - 95</strong></td>
<td><strong>bits 32 - 63</strong></td>
<td><strong>bits 0 - 31</strong></td>
<td><strong>register name</strong></td>
</tr>
<tr>
<td>1979.0</td>
<td>16.0</td>
<td>2017.0</td>
<td>9.0</td>
<td>XMM0</td>
</tr>
<tr>
<td>1979.0</td>
<td>16.0</td>
<td>2017.0</td>
<td>129.0</td>
<td>XMM1</td>
</tr>
<tr>
<td>13992.5</td>
<td>13992.5</td>
<td>13992.5</td>
<td>13992.5</td>
<td>XMM2</td>
</tr>
</tbody>
</table>
<p>Content of XMM0 - XMM2 registers after addition and later subtraction of values</p>
<p>As we see, the XMM2 register contains the number of days between the two dates (the date of birth and the current date) minus 1, as the day of birth itself is not included (this problem will be solved in the calculation loop);</p>
<pre>movd xmm3, [dpy]       <em>; Load 1.0 into the lower double word of XMM3</em><br/>movlhps xmm3, xmm3     <em>; Duplicate it to the third double word of XMM3</em><br/>movsldup xmm3, xmm3    <em>; Duplicate it to the second and fourth double words of XMM3</em></pre>
<p>The preceding three lines set up the step value for our forecast by loading the double word stored at <kbd>dpy</kbd>, which is <kbd>1.0</kbd>, and propagate this value throughout the XMM3 register. We will be adding XMM3 to XMM2 for each new day of the forecast.</p>
<p>The following three lines are logically similar to the previous three; they set all four single precision floats of the XMM4 register to <em>2*PI</em>:</p>
<pre>movd xmm4, [pi_2]<br/>movlhps xmm4, xmm4<br/>movsldup xmm4, xmm4</pre>
<p>And the last step before entering the calculation loop: we load XMM1 with the lengths of the biorhythmic cycles and set the <kbd>eax</kbd> register to point to the location in the memory where we are going to store our output data (the forecast). Given the arrangement of data in the data section, the fourth single of the XMM1 register will be loaded with <em>2*PI</em>, but, since the fourth single is not going to be used in our calculations, we simply leave it as is. We could, however, zero it out with the value of <kbd>eax</kbd> by using the <kbd>pinsrd xmm1, eax, 3</kbd> instruction:</p>
<pre>movaps xmm1, xword[T]<br/>lea eax, [output]</pre>
<p>At last we have all the data set up and ready for actual calculation of biorhythmic values for a given range of dates. The registers XMM0 to XMM4 should now have the following values:</p>
<table>
<tbody>
<tr>
<td><strong>bits 96 - 127</strong></td>
<td><strong>bits 64 - 95</strong></td>
<td><strong>bits 32 - 63</strong></td>
<td><strong>bits 0 - 31</strong></td>
<td><strong>register name</strong></td>
</tr>
<tr>
<td>1979.0</td>
<td>16.0</td>
<td>2017.0</td>
<td>9.0</td>
<td>XMM0</td>
</tr>
<tr>
<td>6.2831802</td>
<td>33.0</td>
<td>28.0</td>
<td>23.0</td>
<td>XMM1</td>
</tr>
<tr>
<td>13992.5</td>
<td>13992.5</td>
<td>13992.5</td>
<td>13992.5</td>
<td>XMM2</td>
</tr>
<tr>
<td>1.0</td>
<td>1.0</td>
<td>1.0</td>
<td>1.0</td>
<td>XMM3</td>
</tr>
<tr>
<td>6.2831802</td>
<td>6.2831802</td>
<td>6.2831802</td>
<td>6.2831802</td>
<td>XMM4</td>
</tr>
</tbody>
</table>


            

            
        
    

        

                            
                    <h1 class="header-title">Calculation loop</h1>
                
            
            
                
<p>Once all the preparations are done, the calculation loop in which we generate our forecast is fairly simple. First of all we increment the number of days value, which has a dual purpose--during the first iteration, it solves the problem of the day of birth not being included and advances the current date one day during the remaining iterations.</p>
<p>The second instruction copies the XMM4 register to XMM0, which will be used for most of our calculations, and multiplies it with the number of days in XMM2 by the execution of the third instruction--which actually calculates the (<em>2*PI*t</em>) part of the formula.</p>
<p>The fourth instruction completes the calculation of the value we need the sine of, by division of XMM0 by lengths of biorhythmic periods:</p>
<pre>.calc_loop:<br/>   addps xmm2, xmm3    <em>; Increment the number of days by 1.0</em><br/>   movaps xmm0, xmm4   <em>; Set XMM0 to contain 2*PI values</em><br/>   mulps xmm0, xmm2    <em>; Actually do the 2*PI*t</em><br/>   divps xmm0, xmm1    <em>; And complete by (2*PI*t)/T</em></pre>
<p>Now we need to calculate the sine for the resulting values, which is a bit problematic due to the algorithm we are going to use for sine computation and the relatively large numbers. The solution is simple--we need to normalize the values so they fit the (<em>0.0, 2*PI</em>) range. This is implemented by the <kbd>adjust()</kbd> procedure:</p>
<pre>   call adjust        <em>; Adjust values for sine computations</em></pre>
<p>Having adjusted the values in XMM0 (ignore the value of the fourth part of XMM0 as it is irrelevant), we may now compute sine for each of the first three single-precision float parts of the register:</p>
<pre>   call sin_taylor_series  <em>; Compute sine for each value</em></pre>
<p>We store computed sine values to a table pointed by the <kbd>eax</kbd> register (since the table is aligned on a 16-bytes boundary, we are safe to use the <kbd>movaps</kbd> instruction, which is slightly faster than its <kbd>movups</kbd> counterpart). Then, we advance the table pointer by 16 bytes, decrement ECX, and keep looping while ECX is not 0 with the <kbd>loop</kbd> instruction.</p>
<p>When ECX reaches <kbd>0</kbd>, we simply terminate the process:</p>
<pre>   movaps [eax], xmm0     <em>; Store the result of current iteration</em><br/><br/>   add eax, 16<br/>   loop .calc_loop<br/><br/><br/>   push 0<br/>   call [exitProcess]</pre>
<p>The table, by the end of the loop, should contain the following values:</p>
<table style="border-collapse: collapse;width: 992px;height: 1542px">
<tbody>
<tr style="height: 15.0pt">
<td style="width: 48pt;height: 15.0pt">
<div><strong>Date</strong></div>
</td>
<td style="width: 48pt;height: 15.0pt">
<div><strong>Physical (P)</strong></div>
</td>
<td style="width: 48pt">
<div><strong>Emotional (S)</strong></div>
</td>
<td style="width: 48pt">
<div><strong>Intellectual (I)</strong></div>
</td>
<td style="width: 48pt">
<div><strong>Irrelevant</strong></div>
</td>
</tr>
<tr style="height: 15.0pt">
<td style="width: 48pt;height: 15.0pt">May 9<sup>th</sup>, 2017</td>
<td style="width: 48pt;height: 15.0pt">0.5195959</td>
<td style="width: 48pt">-0.9936507</td>
<td style="width: 48pt">0.2817759</td>
<td style="width: 48pt">-NAN</td>
</tr>
<tr style="height: 15.0pt">
<td style="height: 15.0pt">May 10<sup>th</sup>, 2017</td>
<td style="height: 15.0pt">0.2695642</td>
<td>-0.9436772</td>
<td>0.4582935</td>
<td>-NAN</td>
</tr>
<tr style="height: 15.0pt">
<td style="height: 15.0pt">May 11<sup>th</sup>, 2017</td>
<td style="height: 15.0pt">-8.68E-06</td>
<td>-0.8462944</td>
<td>0.6182419</td>
<td>-NAN</td>
</tr>
<tr style="height: 15.0pt">
<td style="height: 15.0pt">May 12<sup>th</sup>, 2017</td>
<td style="height: 15.0pt">-0.2698165</td>
<td>-0.7062123</td>
<td>0.7558383</td>
<td>-NAN</td>
</tr>
<tr style="height: 15.0pt">
<td style="height: 15.0pt">May 13<sup>th</sup>, 2017</td>
<td style="height: 15.0pt">-0.5194022</td>
<td>-0.5301577</td>
<td>0.8659862</td>
<td>-NAN</td>
</tr>
<tr style="height: 15.0pt">
<td style="height: 15.0pt">May 14<sup>th</sup>, 2017</td>
<td style="height: 15.0pt">-0.7308638</td>
<td>-0.3262038</td>
<td>0.9450649</td>
<td>-NAN</td>
</tr>
<tr style="height: 15.0pt">
<td style="height: 15.0pt">May 15<sup>th</sup>, 2017</td>
<td style="height: 15.0pt">-0.8879041</td>
<td>-0.1039734</td>
<td>0.9898189</td>
<td>-NAN</td>
</tr>
<tr style="height: 15.0pt">
<td style="height: 15.0pt">May 16<sup>th</sup>, 2017</td>
<td style="height: 15.0pt">-0.9790764</td>
<td>0.1120688</td>
<td>0.9988668</td>
<td>-NAN</td>
</tr>
<tr style="height: 15.0pt">
<td style="height: 15.0pt">May 17<sup>th</sup>, 2017</td>
<td style="height: 15.0pt">-0.9976171</td>
<td>0.3301153</td>
<td>0.9718016</td>
<td>-NAN</td>
</tr>
<tr style="height: 15.0pt">
<td style="height: 15.0pt">May 18<sup>th</sup>, 2017</td>
<td style="height: 15.0pt">-0.9420508</td>
<td>0.5320629</td>
<td>0.909602</td>
<td>-NAN</td>
</tr>
<tr style="height: 15.0pt">
<td style="height: 15.0pt">May 19<sup>th</sup>, 2017</td>
<td style="height: 15.0pt">-0.8164254</td>
<td>0.7071083</td>
<td>0.8145165</td>
<td>-NAN</td>
</tr>
<tr style="height: 15.0pt">
<td style="height: 15.0pt">May 20<sup>th</sup>, 2017</td>
<td style="height: 15.0pt">-0.6299361</td>
<td>0.8467072</td>
<td>0.6899831</td>
<td>-NAN</td>
</tr>
<tr style="height: 15.0pt">
<td style="height: 15.0pt">May 21<sup>st</sup>, 2017</td>
<td style="height: 15.0pt">-0.3954292</td>
<td>0.9438615</td>
<td>0.5407095</td>
<td>-NAN</td>
</tr>
<tr style="height: 15.0pt">
<td style="height: 15.0pt">May 22<sup>nd</sup>, 2017</td>
<td style="height: 15.0pt">-0.128768</td>
<td>0.9937283</td>
<td>0.3714834</td>
<td>-NAN</td>
</tr>
<tr style="height: 15.0pt">
<td style="height: 15.0pt">May 23<sup>rd</sup>, 2017</td>
<td style="height: 15.0pt">0.1362932</td>
<td>0.9936999</td>
<td>0.1892722</td>
<td>-NAN</td>
</tr>
<tr style="height: 15.0pt">
<td style="height: 15.0pt">May 24<sup>th</sup>, 2017</td>
<td style="height: 15.0pt">0.3983048</td>
<td>0.9438586</td>
<td>-8.68E-06</td>
<td>-NAN</td>
</tr>
<tr style="height: 15.0pt">
<td style="height: 15.0pt">May 25<sup>th</sup>, 2017</td>
<td style="height: 15.0pt">0.6310154</td>
<td>0.8467024</td>
<td>-0.18929</td>
<td>-NAN</td>
</tr>
<tr style="height: 15.0pt">
<td style="height: 15.0pt">May 26<sup>th</sup>, 2017</td>
<td style="height: 15.0pt">0.8170633</td>
<td>0.7069295</td>
<td>-0.371727</td>
<td>-NAN</td>
</tr>
<tr style="height: 15.0pt">
<td style="height: 15.0pt">May 27<sup>th</sup>, 2017</td>
<td style="height: 15.0pt">0.9422372</td>
<td>0.5320554</td>
<td>-0.5407244</td>
<td>-NAN</td>
</tr>
<tr style="height: 15.0pt">
<td style="height: 15.0pt">May 28<sup>th</sup>, 2017</td>
<td style="height: 15.0pt">0.9976647</td>
<td>0.3303373</td>
<td>-0.6901718</td>
<td>-NAN</td>
</tr>
</tbody>
</table>


            

            
        
    

        

                            
                    <h1 class="header-title">Adjustment of sine input values</h1>
                
            
            
                
<p>As we have seen, using SSE instructions is quite convenient and effective; although, as we were mostly loading data from memory to registers and moving it within the registers, we have not been able to see its actual effectiveness yet. There are two procedures called from the calculation loop that perform the actual computations. One of them is the <kbd>adjust()</kbd> procedure.</p>
<p>Due to the overall simplicity of the algorithm, and since each of the two procedures is called from exactly one place, we are not following any specific calling convention; instead, we're using the XMM0 register for passing the floating point values and the ECX register for passing integer parameters.</p>
<p>In the case of the <kbd>adjust()</kbd> procedure, we only have one parameter, which is already loaded into the XMM0 register, so we simply call the procedure:</p>
<pre><em>;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</em><br/><em>;</em><br/><em>; Value adjustment before calculation of SIN()</em><br/><em>; Parameter is in XMM0 register</em><br/><em>; Return value is in XMM0 register</em><br/><em>;-----------------------------------------------------</em><br/>adjust:<br/>   push ebp<br/>   mov ebp, esp<br/>   sub esp, 16 * 2      <em>; Create the stack frame for local variables</em></pre>
<p>This is a standard way to create a stack frame for local variables and temporary storage of non-general-purpose registers used in the procedure by saving the stack pointer ESP/RSP in EBP/RBP registers (we are free to use other general-purpose registers). General-purpose registers may be saved on stack by issuing a push instruction right after the allocation of space for local variables. The allocation of space for local variables is performed by subtracting the overall size of variables from the ESP/RSP register.</p>
<p>Addressing the allocated space is shown in the following code:</p>
<pre>   movups [ebp - 16], xmm1      <em>; Store XMM1 and XMM2 registers</em><br/>   movups [ebp - 16 * 2], xmm2</pre>
<p>In the preceding two lines, we temporarily store the content of the XMM1 and XMM2 registers as we are going to use them, but we need to preserve their values.</p>
<p>The adjustment of the input values is very simple and may be expressed by the following code in C:</p>
<pre>return v - 2*PI*floorf(v/(2*PI));</pre>
<p>However, in C, we would have to call this function for every value (unless we use intrinsic functions), while in Assembly, we may adjust all three simultaneously with a few simple SSE instructions:</p>
<pre>movd xmm1, [pi_2]        <em>; Load singles of the XMM1 register with 2*PI</em><br/>movlhps xmm1, xmm1<br/>movsldup xmm1, xmm1</pre>
<p>We are already familiar with the above sequence, which loads a double word into an XMM register and duplicates it to every single-precision float part of it. Here, we load <em>2*PI</em> into XMM1.</p>
<p>The following algorithm performs the actual calculations:</p>
<ul>
<li>We duplicate the input parameter into the XMM2 register</li>
<li>Divide its singles by <em>2*PI</em></li>
<li>Round down the result (SSE has no floor or ceiling instructions, instead we may use <kbd>roundps</kbd> and specify the rounding mode in the third operand; in our case, we instruct the processor to, roughly speaking, round down)</li>
<li>Multiply rounded down results by <em>2*PI</em></li>
<li>Subtract them from the initial value and get results that fit into the (<em>0.0, 2*PI</em>) range</li>
</ul>
<p>and the Assembly implementation thereof is:</p>
<pre>   movaps xmm2, xmm0           <em>; Move the input parameter to XMM2</em><br/>   divps xmm2, xmm1            <em>; Divide its singles by 2*PI</em><br/>   roundps xmm2, xmm2, 1b      <em>; Floor the results</em><br/>   mulps xmm2, xmm1            <em>; Multiply floored results by 2*PI</em><br/>   subps xmm0, xmm2            <em>; Subtract resulting values from the  </em><br/><em>                               ; input parameter</em><br/><br/>   movups xmm2, [ebp - 16 * 2] <em>; Restore the XMM2 and XMM1 registers</em><br/>   movups xmm1, [ebp - 16]<br/><br/>   mov esp, ebp                <em>; "Destroy" the stack frame and return</em><br/>   pop ebp<br/>   ret</pre>
<p>The result of the last operation is already in XMM0, so we simply return from procedure to our calculation loop.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Computing sine</h1>
                
            
            
                
<p>We hardly ever think about how sine or cosine are calculated without actually having a right-angled triangle with known lengths of each of the cathetus and the hypotenuse. There are at least two approaches to make those computations in a fast and efficient way:</p>
<ul>
<li><strong>CORDIC algorithm</strong>: This stands for <strong>COordinate Rotation DIgital Computer</strong>. This one is implemented in simple calculators or primitive hardware devices.</li>
<li><strong>Taylor series</strong>: A fast approximation algorithm. It does not provide the exact value, but is definitely enough for our needs.</li>
</ul>
<p>LIBC on the other hand uses a different algorithm, which we could implement here, but it would be much more than a simple example. Therefore, what we are using in our code is a simple implementation of the simplest approximation algorithm, which provides us with a nice precision (much nicer than we need in this program) of up to the sixth digit after the point--the Taylor series for trigonometric functions (also known as Maclaurin series).</p>
<p>The formula for sine computation using the Taylor series is as follows:</p>
<div><em>sin(x) = x - x<sup>3</sup>/3! + x<sup>5</sup>/5! - x<sup>7</sup>/7! + x<sup>9</sup>/9! ...</em></div>
<p>Here, the ellipsis denote an infinite function. However, we do not need to run it forever to obtain values of satisfactory precision (after all, we are only interested in 2 digits after the point), instead, we will run it for 8 iterations.</p>
<p>Just as with the <kbd>adjust()</kbd> procedure, we will not follow any specific calling convention and, since the parameter we need to compute sine for is already in XMM0, we will simply leave it there. The head of the the <kbd>sin_taylor_series</kbd> procedure does not contain anything new for us:</p>
<pre><em>;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</em><br/><em>;</em><br/><em>; Calculation of SIN() using the Taylor Series</em><br/><em>; approximation:</em><br/><em>; sin(x) = x - x^3/3! + x^5/5! - x^7/7! + x^9/9! ...</em><br/><em>; Values to calculate the SIN() of are in XMM0 register</em><br/><em>; Return values are in XMM0 register</em><br/><em>;-----------------------------------------------------</em><br/>sin_taylor_series:<br/>   push ebp                       <em>; Create stack frame for 5 XMM registers</em><br/>   mov ebp, esp<br/>   sub esp, 5 * 16<br/>   push eax ecx                   <em>; Temporarily store EAX and ECX</em><br/>   xor eax, eax                   <em>; and set them to 0</em><br/>   xor ecx, ecx<br/><br/>   movups [ebp - 16], xmm1        <em>; Temporarily store XMM1 to XMM5 on stack or, to be more</em><br/>   movups [ebp - 16 * 2], xmm2    <em>; precise, in local variables.</em><br/>   movups [ebp - 16 * 3], xmm3<br/>   movups [ebp - 16 * 4], xmm4<br/>   movups [ebp - 16 * 5], xmm5<br/><br/>   movaps xmm1, xmm0              <em>; Copy the parameter to XMM1 and XMM2</em><br/>   movaps xmm2, xmm0<br/><br/>   mov ecx, 3                     <em>; Set ECX to the first exponent</em></pre>
<p>The following computation loop is simple and does not contain any instructions that we have not met yet. However, there are two procedure calls taking two parameters each. Parameters are passed with the XMM0 register (three single-precision floating-point numbers) and the ECX register containing the currently used value of the exponent:</p>
<pre><br/>.l1:<br/>   movaps xmm0, xmm2     <em>; Exponentiate the initial parameter</em><br/>   call pow<br/>   movaps xmm3, xmm0<br/><br/>   call fact             <em>; Calculate the factorial of current exponent</em><br/>   movaps xmm4, xmm0<br/><br/>   divps xmm3, xmm4      <em>; Divide the exponentiated parameter by the factorial of the exponent</em><br/>   test eax, 1           <em>; Check iteration for being odd number, add the result to accumulator</em><br/><em>                         ; subtract otherwise</em><br/>   jnz .plus<br/>   subps xmm1, xmm3<br/>   jmp @f<br/>.plus:<br/>   addps xmm1, xmm3<br/>@@:                     <em>; Increment current exponent by 2</em><br/>   add ecx, 2           <br/>   inc eax<br/>   cmp eax, 8           <em>; and continue till EAX is 8</em><br/>   jb .l1<br/><br/>   movaps xmm0, xmm1    <em>; Store results into XMM0</em></pre>
<p>All computations have completed and we now have sine values for the three inputs. For the first iteration, the inputs in XMM0 would be as follows:</p>
<table>
<tbody>
<tr>
<td><strong>bits 96 - 127</strong></td>
<td><strong>bits 64 - 95</strong></td>
<td><strong>bits 32 - 63</strong></td>
<td><strong>bits 0 - 31</strong></td>
<td><strong>register name</strong></td>
</tr>
<tr>
<td>(irrelevant)</td>
<td>0.28564453</td>
<td>4.8244629</td>
<td>2.5952148</td>
<td>XMM0</td>
</tr>
</tbody>
</table>
<p>Also, the result of our <kbd>sin()</kbd> approximation with eight iterations of Taylor series is as follows:</p>
<table>
<tbody>
<tr>
<td><strong>bits 96 - 127</strong></td>
<td><strong>bits 64 - 95</strong></td>
<td><strong>bits 32 - 63</strong></td>
<td><strong>bits 0 - 31</strong></td>
<td><strong>register name</strong></td>
</tr>
<tr>
<td>(irrelevant)</td>
<td>0.28177592</td>
<td>-0.99365967</td>
<td>0.51959586</td>
<td>XMM0</td>
</tr>
</tbody>
</table>
<p>This shows a perfect (at least for our needs) level of approximation. Then, we restore the previously saved XMM registers and return to caller procedure:</p>
<pre>   movups xmm1, [ebp - 16]<br/>   movups xmm2, [ebp - 16 * 2]<br/>   movups xmm3, [ebp - 16 * 3]<br/>   movups xmm4, [ebp - 16 * 4]<br/>   movups xmm5, [ebp - 16 * 5]<br/><br/>   pop ecx eax<br/>   mov esp, ebp<br/>   pop ebp<br/>   ret</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Exponentiation</h1>
                
            
            
                
<p>We make use of exponentiation in our <kbd>sin_taylor_series</kbd> procedure, an algorithm which is not as trivial as it may seem when it comes to real numbers used as exponents; however, we are quite lucky because the Taylor series only uses natural numbers for that purpose, but, it is worth mentioning that, should we need larger exponents, the algorithm would have been too slow. Therefore, our implementation of an exponentiation algorithm is as basic as it gets--we simply multiply the parameter in XMM0 by itself ECX-1 times. ECX is decremented once because there is no need to calculate <kbd>x<sup>1</sup></kbd>:</p>
<pre><em>;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</em><br/><em>;</em><br/><em>; Trivial exponentiation function</em><br/><em>; Parameters are:</em><br/><em>; Values to exponentiate in XMM0</em><br/><em>; Exponent is in ECX</em><br/><em>; Return values are in XMM0</em><br/><em>;-----------------------------------------------------</em><br/>pow:<br/>   push ebp<br/>   mov ebp, esp<br/>   sub esp, 16<br/><br/>   push ecx<br/>   dec ecx                    <em>; The inputs are already x1 so we decrement the exponent</em><br/>   movups [ebp - 16], xmm1<br/><br/>   movaps xmm1, xmm0          <em>; We will be mutliplying XMM0 by XMM1</em><br/>.l1:<br/>   mulps xmm0, xmm1<br/>   loop .l1<br/><br/>   movups xmm1, [ebp - 16]<br/>   pop ecx<br/>   mov esp, ebp<br/>   pop ebp<br/>   ret</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Factorials</h1>
                
            
            
                
<p>We also make use of factorials as we divide exponentiated values by a factorial of exponents thereof. The factorial of a given number <kbd>n</kbd> is the product of all positive integers less than or equal to the given number <kbd>n</kbd>:</p>
<pre><em>;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</em><br/><em>;</em><br/><em>; Simple calculation of factorial</em><br/><em>; Parameter is in ECX (number to calculate the factorial of)</em><br/><em>; Return value is in XMM0 register</em><br/><em>;-----------------------------------------------------</em><br/>fact:<br/>   push ebp<br/>   mov ebp, esp<br/>   sub esp, 16 * 3<br/><br/>   push ecx<br/>   movups [ebp - 16], xmm1<br/>   movups [ebp - 16 * 2], xmm2<br/>   mov dword[ebp - 16 * 3], 1.0<br/>   movd xmm2, [ebp - 16 * 3]<br/>   movlhps xmm2, xmm2<br/>   movsldup xmm2, xmm2<br/>   movaps xmm0, xmm2<br/>   movaps xmm1, xmm2<br/><br/>.l1:<br/>   mulps xmm0, xmm1<br/>   addps xmm1, xmm2<br/>   loop .l1<br/><br/>   movups xmm2, [ebp - 16 * 2]<br/>   movups xmm1, [ebp - 16]<br/>   pop ecx<br/>   mov esp, ebp<br/>   pop ebp<br/>   ret</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">AVX-512</h1>
                
            
            
                
<p>This chapter would not have been complete without mentioning AVX-512 - Advanced Vector Extensions 512-bit. It, in fact, consists of multiple extensions, while only the core one - AVX-512F ("F" stands for foundation) is mandatory for all processors. AVX-512 does not only add new instructions, but greatly enhances the implementation of parallel (vectored) computations, allowing calculations to be performed over vectors of single or double-precision floating point values up to 512 bits long. Also, 32 new 512-bit registers are introduced (ZMM0 - ZMM31) and with its ternary logic it resembles dedicated platforms.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>The example code in this chapter was designed for the demonstration of the parallel data processing capabilities of modern Intel-based processors. Of course, the technology being used herein is far from able to provide the power of architectures such as CUDA, but it is definitely able to significantly speed up certain algorithms. While the algorithm we worked on here is very simple and hardly requires any optimization at all, as it could be implemented with FPU instructions alone and we would hardly notice any difference, it still illustrates the way in which multiple data may be processed simultaneously. A much better application could be solving an <em>n</em>-body problem, as SSE allows simultaneous computation of all vectors in a 3 dimensional space or even the implementation of a multilayer perceptron (one of many types of artificial neural networks) as it could have made it possible to process several neurons at once or; if the network is small enough, host them all in available XMM registers without the need to move data from/to memory. Especially keeping in mind the fact that sometimes procedures that seem to be quite complex, when implemented with SSE, may still be faster than a single FPU instruction.</p>
<p>Now that we know about at least one technology that may make our life easier, we will learn about the way assemblers can, if not simplify, then definitely ease the work of Assembly developer--macro instructions. Similar to macros in C or any other programming language supporting such features, macro instructions can have a significantly positive impact, allowing the replacement of a series of instructions with a single macro instruction, iteratively and/or conditionally assemble or skip certain sequences, or even create new instructions if the assembler is not supporting instructions we need (never happened to me yet, but "never say never").</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    </body></html>