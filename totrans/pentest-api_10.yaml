- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Secure Coding Practices for APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome to the end of our book, which matches the beginning of your **Application
    Programming Interface** (**API**) pentesting journey! If you’ve been reading this
    book from [*Chapter 1*](B19657_01.xhtml#_idTextAnchor014), we’ve been together
    for quite a while, covering and learning about different aspects of APIs in their
    most diverse forms, sticking with penetration techniques but still having an eye
    on what application owners and developers should pay attention to before releasing
    their APIs. An API opens the door of applications, services, and entire businesses
    to the world. This door represents an immense responsibility for a software and
    is surely extensible for all the infrastructure that supports it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The upcoming sections bring recommendations when coding to build APIs. You
    will find tips and practices in some modern programming languages and technologies,
    the ones that are more applied when creating APIs: Golang, GraphQL, Java, JavaScript,
    and Python. All major problems that were tackled in this book are covered. As
    you may already know, security is about layered protection. There’s no one-size-fits-all.
    We should pay attention to the eventual attack surface we are creating when coding.'
  prefs: []
  type: TYPE_NORMAL
- en: This book is about attacking, but it’s ethical enough to discuss the prevention
    of attacks too. It doesn’t hurt to say that. At the end of the day, we are security
    professionals, and our main intent is to reinforce the software we are testing
    for the sake of reducing the chances of an invasion or data leakage.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The importance of secure coding practices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing secure authentication mechanisms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validating and sanitizing user input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing proper error handling and exception management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Best practices for data protection and encryption
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we are not going to do any practical exercise in this chapter, there are
    no technical requirements. If you, however, feel compelled to put the code into
    practice, be my guest. As the saying goes, practice makes perfect. Just go for
    it and enjoy it.
  prefs: []
  type: TYPE_NORMAL
- en: The importance of secure coding practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I’m not trying to teach your grandmother to suck eggs. Not at all. However,
    as I like to say in person and while writing this book, it never hurts to emphasize
    concepts and ideas that are paramount to something. Putting API-secure coding
    into practice is important because of the intricate and complex role APIs play
    in software development. They act as links between diverse applications and services,
    making them able to talk to each other and exchange data. This feature-rich scenario
    results in a situation in which the vulnerabilities embedded in some API may be
    explored (or, as is most commonly said, exploited), allowing unauthorized data
    access, privilege escalation, service disruption, or system criminal ownership,
    and sometimes resulting in data ransom. Thus, secure coding practices aid in mitigating
    these risks by increasing API robustness against common threats, such as injection
    (SQL or NoSQL), **Cross-site Scripting** (**XSS**), and **Man-in-the-middle**
    (**MitM**).
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, these practices collaborate to sustain the business’ trust and reputation
    among its customers. Nowadays, data leaks and security incidents may impose significant
    damages on companies, which include but are not limited to financial losses, legal
    penalties (some due to compliance mechanisms), and cracks in the company’s reputation.
    Customers and regular users expect not only that the services provided by APIs
    work smoothly and are always available but also that their data is correctly handled
    and protected.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are some secure coding methodologies that can be adopted by companies
    to help them establish a decent **Software Development Life Cycle** (**SDLC**).
    If you haven’t heard about this yet, it’s just a process that is applicable when
    software is being developed. Such a process has stages, such as planning, designing,
    coding, testing, deployment, and maintenance. With the help of an SDLC, the software
    progresses in each of the phases, which increases the efficiency of project management
    as well as producing high-quality software as a result. Here, you find a humble
    list of SDLC methodologies:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Building Security in Maturity Model** (**BSIMM**): Originally a part of the
    **Software Assurance Maturity Model** (**SAMM**), BSIMM has transitioned from
    offering prescriptive guidance to taking a descriptive approach and is regularly
    updated to reflect the latest best practices. Rather than suggesting specific
    actions, BSIMM outlines the activities and practices of its member organizations.
    More information can be found at [https://www.synopsys.com/glossary/what-is-bsimm.html](https://www.synopsys.com/glossary/what-is-bsimm.html).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Microsoft Secure Development Life Cycle** (**SDL**): This prescriptive approach
    addresses a wide range of security concerns and offers organizations guidance
    on achieving more secure coding practices. It assists in developing software that
    complies with regulatory standards and helps reduce costs. More information can
    be found at [https://www.microsoft.com/en-us/securityengineering/sdl](https://www.microsoft.com/en-us/securityengineering/sdl).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**OWASP Software Assurance Maturity Model** (**SAMM**): SAMM is an open source
    initiative that uses a prescriptive methodology to incorporate security into the
    SDLC. It is maintained by OWASP and benefits from contributions by companies of
    various sizes and sectors. More information can be found at [https://owasp.org/www-project-samm/](https://owasp.org/www-project-samm/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Demonstrating a commitment to security through rigorous coding practices can
    help build and maintain trust with stakeholders. It also shows regulatory bodies
    that the company is serious about compliance with data protection laws and industry
    standards, which can prevent legal issues down the line. Another helpful resource
    is the OWASP Developer Guide ([https://owasp.org/www-project-developer-guide/](https://owasp.org/www-project-developer-guide/)),
    which provides a fairly complete list of definitions and guidelines on how to
    generally increase code security. When this book was being written, the guide
    was on version `4.1.0`. Of course, do not ever forget to check the OWASP Top Ten
    API, which is available at [https://owasp.org/API-Security/editions/2023/en/0x11-t10/](https://owasp.org/API-Security/editions/2023/en/0x11-t10/).
    The current release is from 2023 and it details the ten most dangerous threats
    to APIs. We discussed them in *Chapters 1* and *3*.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, secure coding practices help ensure the long-term sustainability and
    scalability of software systems. As applications grow and evolve, maintaining
    a secure foundation becomes increasingly complex. Early adoption of secure coding
    practices helps create a culture of security within development teams, making
    it easier to identify and fix vulnerabilities before they become significant issues.
    This proactive approach to security can save time and resources by reducing the
    need for extensive security patches and mitigating the impact of potential security
    breaches. In turn, this leads to more stable, resilient applications that can
    adapt to new challenges and threats in the ever-evolving digital landscape. Let’s
    start discussing the various relevant topics.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing secure authentication mechanisms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We covered attacks on secure authentication mechanisms in [*Chapter 4*](B19657_04.xhtml#_idTextAnchor056).
    Authentication is a crucial component of API security, ensuring that only authorized
    users can access protected resources. Implementing secure authentication mechanisms
    requires careful consideration of various factors. For instance, using strong,
    unique passwords and hashing them with modules such as `bcrypt` in Python can
    significantly enhance security. Avoid storing passwords in plaintext or using
    weak hashing algorithms such as MD5\. In Java, libraries such as Spring Security
    provide robust authentication mechanisms, including support for OAuth2 and JWTs.
    An insecure implementation might directly accept user credentials and return a
    token without proper validation, making it vulnerable to attacks. Instead, developers
    should enforce `bcrypt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In JavaScript, especially in Node.js environments, using libraries such as
    `Passport.js` can help manage authentication effectively. However, ensure that
    tokens are stored securely, preferably using `HttpOnly` cookies, to prevent XSS
    attacks. Similarly, in Golang, using middleware such as `gorilla/sessions` to
    handle session management securely is advisable. Flaws in authentication mechanisms
    often arise from improper session management or insecure token storage. Developers
    should ensure that tokens are rotated regularly and that sessions have a timeout
    to mitigate the risk of session hijacking. In GraphQL, make sure to limit the
    query complexity and depth to prevent abuse. Failing to do this might expose sensitive
    user details in error messages, which should be sanitized and kept minimal. The
    following JavaScript code replaces an insecure way of storing tokens by applying
    httpOnly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we’ll talk about how to properly manipulate user input.
  prefs: []
  type: TYPE_NORMAL
- en: Validating and sanitizing user input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We covered attacks leveraging user input in [*Chapter 5*](B19657_05.xhtml#_idTextAnchor078).
    Validating and sanitizing user input is paramount to prevent injection attacks,
    such as SQL injection, XSS, and command injection. In Python, frameworks such
    as `Django` and `Flask` provide built-in validation tools, but developers must
    ensure that they use them correctly. For instance, relying on raw SQL queries
    without parameterized inputs can lead to SQL injection. Instead, use **Object
    Relational Mapper** (**ORM**) methods that automatically handle parameterization.
    The Python code that follows shows the slight difference of using parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In Java, using libraries such as `Hibernate` can help prevent injection attacks
    by utilizing **Hibernate Query Language** (**HQL**) or **Java Persistence Query
    Language** (**JPQL**), which are inherently safe when used properly. However,
    developers must avoid concatenating strings to build queries. The Java excerpt
    that follows applies parameterized queries with HQL replacing the original or
    insecure query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In JavaScript, especially with Node.js, developers should use ORM libraries
    such as `Sequelize` or `Mongoose`, which support parameterized queries. Additionally,
    input validation libraries such as `Joi` can help enforce schema validation. However,
    a common mistake is failing to validate input from all sources, including headers,
    cookies, and query parameters. Look at the snippet that follows, which shows how
    to create a parameterized query with `Sequelize`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Golang developers should use libraries such as `validator` to enforce strict
    input validation rules. For example, a flawed input validation might accept unchecked
    user input directly into the application logic, leading to potential vulnerabilities.
    Instead, sanitize and validate all inputs rigorously before processing them. The
    following code uses Golang’s `sql` package to send a parameterized query to a
    database. The `db` variable is generated from this package as well (with `sql.Open()`).
    The difference is quite subtle in the eyes of an attentive reader (or human security
    auditor) but it is impactful in the final result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'GraphQL poses unique challenges for input validation due to its flexible query
    structure. Developers should define strict schemas and use validation middleware
    to ensure that only valid inputs are processed. For instance, an insecure GraphQL
    endpoint might accept arbitrary inputs, leading to resource exhaustion or other
    attacks. By enforcing strict type definitions and validation rules, developers
    can mitigate these risks effectively. The next JavaScript excerpt compares an
    insecure strategy with a secure one. Observe how `user` is internally defined
    with the help of a middleware:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, you’ll learn the best practices for how to correctly handle
    errors and exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing proper error handling and exception management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We covered attacks with bad error and exception handling in [*Chapter 6*](B19657_06.xhtml#_idTextAnchor102).
    Proper error handling and exception management are critical for maintaining the
    security and stability of APIs. In Python, developers should use `try-except`
    blocks to handle exceptions gracefully and avoid exposing stack traces to the
    client. A common flaw is returning detailed error messages that reveal internal
    logic, which can be exploited by attackers. Instead, provide generic error messages
    and log detailed errors server-side. Do not forget to rotate and encrypt such
    logs. Also, restrict access to the logs only to people and applications that have
    legitimate reasons. The following code block shows two ways of handling exceptions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Java developers can leverage the equivalent `try-catch` blocks and custom exception-handling
    mechanisms provided by frameworks such as `Spring` to manage errors securely.
    Avoid exposing sensitive information in exception messages and use logging frameworks
    such as `Logback` or `SLF4J` to log errors securely. The implementation that follows
    is equivalent to the previous one, but in Java, it is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In JavaScript, using global error handling middleware in `Express.js` can help
    catch unhandled exceptions and prevent application crashes. However, a common
    mistake is logging errors directly to the console, which can be a security risk.
    Instead, use secure logging mechanisms and ensure that logs do not contain sensitive
    information. Look at how this could be implemented:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Golang developers should use **defer-recover patterns** to handle panics and
    ensure that the application does not crash unexpectedly. For example, an insecure
    implementation might panic and expose sensitive data in the response. By recovering
    from panics and returning a generic error message, developers can enhance security.
    Observe in the next code snippet two ways of using a deferred function. They show
    how panic messages are generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, in GraphQL, error handling should be implemented carefully to avoid
    revealing internal schema details. Use custom error classes and middleware to
    catch and handle errors gracefully. An insecure GraphQL implementation might return
    detailed error messages that expose field names or other schema details, making
    it easier for attackers to craft malicious queries. By implementing proper error
    handling and sanitizing error messages, developers can protect their APIs from
    exploitation. The JavaScript code follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we’ll discuss the best practices for data protection.
  prefs: []
  type: TYPE_NORMAL
- en: Best practices for data protection and encryption
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We covered attacks accessing data in unauthorized ways in [*Chapter 8*](B19657_08.xhtml#_idTextAnchor131).
    Data protection and encryption are essential for securing sensitive information
    transmitted via APIs. In Python, using libraries such as `cryptography` to encrypt
    data at rest and in transit is crucial. For instance, encrypting sensitive information
    such as passwords and personal data before storing it in the database can prevent
    unauthorized access. Observe the following code that applies the `cryptography`
    library to make use of Fernet tokens and keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In Java, leveraging the **Java Cryptography Architecture** (**JCA**) provides
    robust encryption mechanisms. However, developers must avoid using outdated encryption
    algorithms such as DES or RC4\. Instead, it’s better to use modern algorithms
    such as AES with appropriate key management practices. Observe the example that
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'JavaScript developers should use libraries such as `crypto` in Node.js to implement
    encryption and decryption routines securely. For example, an insecure implementation
    might use hardcoded encryption keys or weak algorithms. Instead, use environment
    variables to store keys securely and implement key rotation policies. Look at
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, the JavaScript code leverages environment variables
    to store some sensitive data. Such data may be controlled by a `.env` file, which
    is an approach followed by many modern programming languages. This file simply
    has associations between variables and their contents and usually lies in the
    very same directory where the source code is. Of course, it’s not the best solution
    whatsoever, but it’s definitely better than hardcoding the key into the logic.
    Another solution when you have a secrets manager at hand (either a local one or
    a service provided by a public cloud player) is to store all sensitive data there
    and then. This can be done using an ephemeral session by assuming a role with
    the necessary permissions; you simply access such a manager and then retrieve
    the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Golang, using packages such as `crypto/aes` for encryption and ensuring
    proper key management can enhance data security. A common flaw is failing to secure
    keys or using weak keys, which can be mitigated by following the best practices
    for key management. The excerpt that follows demonstrates what is being said:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'GraphQL poses unique challenges for data protection, especially when dealing
    with sensitive queries and mutations. Implementing field-level encryption and
    ensuring that sensitive data is encrypted before being returned in responses is
    crucial. For instance, an insecure GraphQL implementation might return sensitive
    data without encryption, exposing it to potential interception. By encrypting
    sensitive fields and using secure transport protocols such as HTTPS, developers
    can protect data effectively. The following JavaScript block shows how to return
    sensitive data only after correctly encrypting it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In conclusion, secure coding practices for APIs are fundamental to building
    robust and secure APIs and applications. By implementing secure authentication
    mechanisms, validating and sanitizing user input, handling errors properly, and
    protecting data through encryption, developers can significantly enhance the security
    of their APIs. These practices, combined with continuous security testing and
    monitoring, can help mitigate risks and protect sensitive information from potential
    threats.
  prefs: []
  type: TYPE_NORMAL
- en: As we’ve seen several times in this book, there’s no one-size-fits-all solution.
    No single technique or principle will protect the whole API. Secure coding best
    practices are a vital part of the protection universe, but they must be combined
    with a secure API architecture design and be followed by continuous monitoring
    and checking, triggering general verifications every time a major change is needed
    in the code or the data flow.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered important actions that should be taken toward avoiding
    major incidents in different aspects that were covered throughout previous chapters.
    We learned tips on how to better code APIs for the sake of reducing risks in authentication
    mechanisms, user input, error handling and exception management, and data protection.
  prefs: []
  type: TYPE_NORMAL
- en: In general, we learned that it’s about leveraging widely used open source libraries
    that implement secure mechanisms or open algorithms, combined with some practices
    such as avoiding hardcoding important things in the logic and continuously monitoring
    the activities. Never reinvent the wheel. Avoid obscure solutions as much as possible.
    In the end, if neither you nor the community nor a compliance authority can audit
    such a product or service, it’s nearly impossible to truly know what’s going on
    behind the scenes, as we learned in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, we learned that it’s important for developers and development managers
    to discuss, in their companies, the possibility of adopting a secure coding methodology.
    They are especially useful when you are completely clueless about where to start
    to transform your API software into something more secure.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, I hope you enjoyed reading this book as much as I did writing it. This
    is my very first book; hopefully it’s the first of many more to come.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Python `bcrypt`, a hashing alternative module: [https://pypi.org/project/bcrypt/](https://pypi.org/project/bcrypt/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Python `scrypt`, a more mature implementation of encryption library: [https://pypi.org/project/scrypt/](https://pypi.org/project/scrypt/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Java Spring, a major framework for Java: [https://spring.io/](https://spring.io/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Java Spring Security, a framework for protecting applications written in Java
    Spring: [https://spring.io/projects/spring-security](https://spring.io/projects/spring-security)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'JavaScript Passport.js, an authentication middleware for Node.js: [https://www.passportjs.org/](https://www.passportjs.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Gorilla Sessions, a Golang package that provides cookie and filesystem sessions
    for applications: [https://github.com/gorilla/sessions](https://github.com/gorilla/sessions)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Python Django, a framework for building modern Python applications and APIs:
    [https://www.djangoproject.com/](https://www.djangoproject.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Python Flask, another framework, which is lighter than Django: [https://flask.palletsprojects.com/en/](https://flask.palletsprojects.com/en/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Java Hibernate, a library that facilitates and protects data handling: [https://hibernate.org/](https://hibernate.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Java HQL, the query language behind Hibernate: [https://docs.jboss.org/hibernate/orm/3.3/reference/en/html/queryhql.html](https://docs.jboss.org/hibernate/orm/3.3/reference/en/html/queryhql.html).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Java JPQL, a query language used for data persistence: [https://openjpa.apache.org/builds/1.2.3/apache-openjpa/docs/jpa_langref.html](https://openjpa.apache.org/builds/1.2.3/apache-openjpa/docs/jpa_langref.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'JavaScript Sequelize, an ORM for Node.js: [https://sequelize.org/](https://sequelize.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'JavaScript Mongoose, an intelligent and elegant way to deal with data on Node.js
    when connecting with MongoDB: [https://mongoosejs.com/docs/](https://mongoosejs.com/docs/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Joi, a tool that helps you validate data when coding in JavaScript: [https://joi.dev/](https://joi.dev/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Golang Package Validator, an aid to valid user input before taking it into
    consideration: [https://pkg.go.dev/github.com/go-playground/validator/](https://pkg.go.dev/github.com/go-playground/validator/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Golang SQL Package, which should be used when interacting with SQL databases
    rather than directly sending queries to them: [https://pkg.go.dev/database/sql](https://pkg.go.dev/database/sql)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Java Logback, a framework to correctly handle logging: [https://logback.qos.ch/](https://logback.qos.ch/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Simple Log Facade for Java, a wrapper for logging frameworks such as Logback:
    [https://www.slf4j.org/](https://www.slf4j.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'JavaScript Express.js, a minimal web framework: [https://expressjs.com/](https://expressjs.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Python cryptography, a module to facilitate encryption activities: [https://pypi.org/project/cryptography/](https://pypi.org/project/cryptography/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Java Cryptography Architecture, a reference and set of implementations for
    dealing with cryptographic primitives with the language (the current version is
    22): [https://docs.oracle.com/en/java/javase/22/security/java-cryptography-architecture-jca-reference-guide.html](https://docs.oracle.com/en/java/javase/22/security/java-cryptography-architecture-jca-reference-guide.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Golang crypto, a package that handles encryption and hashing tasks: [https://pkg.go.dev/crypto](https://pkg.go.dev/crypto)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A blog post discussing what`.env` is and how it can be leveraged to grant some
    protection to sensitive data: [https://platform.sh/blog/we-need-to-talk-about-the-env/](https://platform.sh/blog/we-need-to-talk-about-the-env/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
