["```\nmov  eax, 4      *; 4 is the number of sys_write system call*\nmov  ebx, 1      *; 1 is the stdout file number*\nlea  ecx, [msg]  *; msg is the label (address) of the string to write*\nmov  edx, len    *; length of msg in bytes*\nint  0x80        *; make syscall* \n```", "```\nmov  rax, 1      *; 1 is the number of sys_write on 64-bit Linux*\nmov  rdi, 1      *; 1 is the stdout file number*\nmov  rsi, msg    *; msg is the label (address) of the string*\nmov  rdx, len    *; length of msg in bytes*\nsyscall          *; make the system call*\n```", "```\n_KiIntSystemCall:\n   lea  edx, [esp + 8]      *; Load EDX with pointer to the parameter block*\n   int  0x2e                *; make system call*\n```", "```\n_KiFastSystemCall:\n   mov  edx, esp            *; Load EDX with stack pointer so that kernel*\n                            *; may access the parameter block on stack*\n   sysenter                 *; make system call*\n```", "```\n*; First we need to tell the assembler that*\n*; we expect an object file compatible with MS linker*\nformat MS COFF\n\n*; Then specify the external API we need*\n*; extrn means that the procedure is not in this file*\n*; the 4 after the '@' specifies size of procedure parameters*\n*; in bytes*\n*; ExitProcess is a label and dword is its size* \nextrn '__imp__ExitProcess@4' as ExitProcess:dword\nextrn '__imp__GetStdHandle@4' as GetStdHandle:dword\nextrn '__imp__WriteConsoleA@20' as WriteConsole:dword\n\n*; And, of course, our \"crypto API\"*\nextrn '_GetPointers' as GetPointers:dword\n\n*; Define a constant for GetStdHandle()*\nSTD_OUTPUT_HANDLE   equal -11\n\n*; and a structure to ease the access to \"crypto functions\"*\nstruc crypto_functions\n{\n   .f_set_data_pointer  dd ?\n   .f_set_data_length   dd ?\n   .f_encrypt           dd ?\n   .f_decrypt           dd ?\n}\n\n*; The following structure makes it a bit easier* \n*; to manipulate strings and sizes thereof*\nstruc string [s]\n{\n   common\n   .      db s\n   .length = $ - .\n}\n```", "```\nsection '.data' data readable writeable\n   *; We will store the STDOUT handle here*\n   stdout        dd ?\n\n   *; This buffer contains the message we will operate on*\n   buffer        string 'Hello from object file!', 0x0a, 0x0d\n\n   *; Progress messages*\n   msg1          string 'Encrypted', 0x0a, 0x0d\n   msg2          string 'Decrypted', 0x0a, 0x0d\n\n   *; This one is required by the WriteConsole procedure*\n   bytesWritten  dd ?\n```", "```\nsection '.text' code readable executable\n   *; We need the entry point to be accessible to the linker,*\n *; therefore we make it \"public\"*\n   public _start\n\n_start:\n   *; The first step would be obtaining the STDOUT handle*\n   push  STD_OUTPUT_HANDLE\n   *; Since we are linking against a DLL, the GetStdHandle* \n *; label would refer to a location in the import section* \n *; which the linker will create for us. Hence we make an*\n *; indirect call*\n   call  [GetStdHandle]\n   *; Store the handle*\n   mov   [stdout], eax\n\n   *; Print the message*\n   push  0 bytesWritten buffer.length buffer eax\n   call  [WriteConsole]\n\n   *; Let's play with encryption a bit*\n *; First get the procedure pointers. Since the GetPointers()*\n *; is in another object file, it would be statically linked,*\n *; therefore we make a direct call*\n   call  GetPointers\n   *; Store the pointer to the crypto_functions structure in EBX*\n   mov   ebx, eax\n```", "```\n   virtual at ebx\n      funcs  crypto_functions\n   end virtual\n```", "```\n *; Set the pointer to data and its length*\n   push  buffer\n   call  [funcs.f_set_data_pointer] *; Equivalent to 'call [ebx]'*\n   push  buffer.length\n   call  [funcs.f_set_data_length]\n\n   *; We have to restore the stack pointer due to the* \n *; fact that the above two procedures are in accordance*\n *; with the cdecl calling convention*\n   add   esp, 8\n\n   *; Encrypt the content of the buffer*\n   call  [funcs.f_encrypt]\n\n   *; Print progress message*\n   push  0 bytesWritten msg1.length msg1 [stdout]\n   call  [WriteConsole]\n\n   *; Decrypt the content of the buffer*\n   call  [funcs.f_decrypt]\n\n   *; Print another progress message*\n   push  0 bytesWritten msg2.length msg2 [stdout]\n   call  [WriteConsole]\n\n   *; Print the content of the buffer in order to verify*\n *; decryption*\n   push  0 bytesWritten buffer.length buffer [stdout]\n   call  [WriteConsole]\n\n   *; All is fine and we are free to exit*\n   push  0\n   call  [ExitProcess]\n```", "```\nlink /entry:start /subsystem:console obj_win.obj \"c:\\Program Files\\Microsoft SDKs\\Windows\\v7.0A\\Lib\\kernel32.lib\" crypto_w32.obj\n```", "```\nHello from object file!\nEncrypted\nDecrypted\nHello from object file!\n```", "```\ninclude 'win32a.inc'\n```", "```\nsection '.idata' import data readable writeable\n\n   *; Tell the assembler which libraries we are interested in*\n   library kernel,'kernel32.dll',\\\n           crypto,'crypto_w32.dll'\n\n   *; Specify procedures we need from kernel32.dll*\n   import kernel,\\\n      GetStdHandle, 'GetStdHandle',\\\n      WriteConsole, 'WriteConsoleA',\\\n      ExitProcess, 'ExitProcess'\n\n   *; And, finally, tell the assembler we are also*\n *; interested in our crypto engine*\n   import crypto,\\\n      GetPointers, 'GetPointers'\n```", "```\nformat ELF\n\n*; As we want GCC to take care of all the startup code*\n*; we will call our procedure \"main\" instead of _start,*\n*; otherwise we would be using LD instead of GCC and* \n*; would have to specify all runtime libraries manually.*\npublic main\n\n*; The following function is linked from libc*\nextrn printf\n\n*; And this one is from our crypto library*\nextrn GetPointers\n```", "```\nstruc crypto_functions\n{\n   .f_set_data_pointer dd ?\n   .f_set_data_length  dd ?\n   .f_encrypt          dd ?\n   .f_decrypt          dd ?\n}\n\nstruc string [s]\n{\n   common\n   .                   db s\n   .length = $ - .\n   .terminator         db 0\n}\n```", "```\nsection '.data' writeable\n   buffer  string  'Hello from ELF linked from objects!', 0x0a\n   msg1    string  'Encrypted', 0x0a\n   msg2    string  'Decrypted', 0x0a\n```", "```\nsection '.text' executable\n\n*; Remember that we are using GCC for linking, hence the name is*\n*; main, rather than _start*\nmain:\n   *; Print the content of the buffer to stdout*\n *; As all procedures (except crypto procedures) would be*\n *; statically linked, we are using direct calls*\n   push  buffer\n   call  printf\n   *; Restore stack as printf() is a cdecl function*\n   add   esp, 4\n\n   *; Get pointers to cryptographic procedures*\n   call  GetPointers\n   mov   ebx, eax\n\n   *; We will use the same trick to ease our access to cryptography*\n *; procedures by defining a virtual structure*\n   virtual at ebx\n      funds   crypto_functions\n   end virtual\n\n   *; Right now we will push parameters for all subsequent procedure*\n *; calls onto the stack in reverse order (parameter for the last* \n *; call is pushed first*\n   push  0 buffer msg2 msg1 buffer.length buffer\n\n   *; Set crypto library's data pointer*\n *; Crypto procedures are not available at link time, hence not*\n *; statically linked. Instead we obtain pointers thereof and this* \n *; is the reason for indirect call*\n   call  [funcs.f_set_data_pointer]\n   *; Restore stack*\n   add   esp, 4\n\n   *; Set size of the data buffer*\n   call  [funcs.f_set_data_length]\n   add   esp, 4\n\n   *; Encrypt the buffer. As this procedure has no parameter, there*\n *; is no reason to do anything to stack following this call*\n   call  [funcs.f_encrypt]\n\n   *; Print msg1*\n   call  printf\n   add   esp, 4\n\n   *; Decrypt the buffer back*\n   call  [funcs.f_decrypt]\n\n   *; Print msg2*\n   call  printf\n   add   esp, 4\n\n   *; Print the content of the buffer to ensure correct decryption*\n   call  printf\n   add   esp, 4\n\n   *; All is done, so we may safely exit*\n   pop   eax\n   ret\n```", "```\ngcc -o o_lin o_lin.o crypto_32.o\n***# If you are on a 64-bit system then*** \ngcc -o o_lin o_lin.o crypto_32.o -m32\n```", "```\nformat ELF executable 3    *; The 3 may be omitted if on Linux* \n\n*; Include this in order to be able to create import section*\ninclude 'linux_include/import32.inc'\n\n*; We have to specify the entry point for the executable*\nentry _start\n```", "```\n*; The content of the data section is the same as in object file*\n*; source. The section itself is declared in a different way (in*\n*; fact, although, an ELF file is divided into sections, it is* \n*; treated a bit differently when in memory - it is divided into*\n*; segments)*\nsegment readable writeable\n   buffe  string 'Hello from dynamically linked ELF!', 0x0a\n   msg1   string 'Encrypted', 0x0a\n   msg2   string 'Decrypted', 0x0a\n```", "```\nsegment interpreter writeable\n   db '/lib/ld-linux.so.2',0\n```", "```\n*; In our example we only need to libraries - libc for*\n*; printf() and exit() (and we will use exit() this time)*\n*; and crypto_32.so for our cryptographic core.*\nneeded\\\n   'libc-2.19.so',\\\n   'crypto_32.so'\n\n*; Then we specify requested procedures*\nimport\\\n   printf,\\\n   exit,\\\n   GetPointers\n```", "```\nsegment executable readable\n_start:\n```", "```\npush  buffer\ncall  [printf]\nadd   esp, 4\n\ncall  [GetPointers]\nmov   ebx, eax\n\nvirtual at ebx\n   funcs  crypto_functions\nend virtual\n\npush  0 buffer msg2 msg1 buffer.length buffer\n\n*; All procedures are cdecl, so we have to adjust* \n*; the stack pointer upon return from procedures*\n*; with parameters*\n\ncall  [funcs.f_set_data_pointer]\nadd   esp, 4\n\ncall  [funcs.f_set_data_length]\nadd   esp, 4\n\ncall  [funcs.f_encrypt]\n\ncall  [printf]\nadd   esp, 4\n\ncall  [funcs.f_decrypt]\n\ncall  [printf]\nadd   esp, 4\n\ncall  [printf]\nadd   esp, 4\n\ncall  [exit]\n```", "```\npop  eax\nret\n```", "```\ncal  [exit]\n```", "```\nfasm  so_lin.asm\n./so_lin\n```"]