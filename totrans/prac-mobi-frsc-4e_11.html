<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Android Data Extraction Techniques</h1>
                </header>
            
            <article>
                
<p>Using any of the screen lock bypass techniques explained in <a href="b1621e6e-80a3-495e-a288-c8db601149f8.xhtml" target="_blank">Chapter 8</a><a href="" target="_blank"/>, <em>Android Forensic Setup and Pre-Data Extraction Techniques</em>, an examiner can try to access a locked device. Once the device is accessible, the next task is to extract the information present on the device. This can be achieved by applying various data extraction techniques to the Android device.</p>
<p>This chapter will help you to identify the sensitive locations present on an Android device and explain various logical and physical techniques that can be applied to the device to extract the necessary information.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Understanding data extraction techniques</li>
<li>Manual data extraction</li>
<li>Logical data extraction</li>
<li>Physical data extraction, which covers imaging an Android device and SD card, JTAG, and chip-off techniques</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding data extraction techniques</h1>
                </header>
            
            <article>
                
<p>Data residing on an Android device may be an integral part of civil, criminal, or internal investigations done as part of a corporate company's internal probe. While dealing with investigations involving Android devices, you, as the forensic examiner, need to be mindful of the issues that need to be taken care of during the forensic process; this includes determining whether root access is permitted (via consent or legal authority) and what data can be extracted and analyzed during the investigation. For example, in a criminal case involving stalking, the court may only allow SMS, call logs, and photos to be extracted and analyzed on the Android device belonging to the suspect. In this case, it may make the most sense to logically capture only those specific items. However, it is best to obtain a full physical data extraction from the device and only examine the areas admissible by the court. You never know where your investigation may lead and it is best to obtain as much data from the device as possible immediately, rather than wishing you had a full image should the scope of consent change. Data extraction techniques on an Android device can be classified into three types:</p>
<ul>
<li>Manual data extraction</li>
<li>Logical data extraction</li>
<li>Physical data extraction</li>
</ul>
<p>As described in <a href="" target="_blank">Chapter 1</a>, <em>Introduction to Mobile Forensics</em>, manual extraction involves browsing through the device normally and capturing any valuable information, while logical extraction deals with accessing the filesystem, and physical extraction is about extracting a bit-by-bit image of the device. The extraction methods for each of these types will be described in detail in the following sections.</p>
<div class="packt_infobox">Some methods may require the device to be rooted to fully access the data. Each method has different implications and their success rates will depend on the tool and method used as well as the device's make and model.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Manual data extraction</h1>
                </header>
            
            <article>
                
<p>This method of extraction involves you utilizing the normal user interface of the mobile device to access content present in the memory. You will browse through the device normally by accessing different menus to view details such as call logs, text messages, and IM chats. The content of each screen is captured by taking pictures and can be presented as evidence.</p>
<p>The main drawback of this type of examination is that only the files that are accessible via the operating system (in UI mode) can be investigated. Care must be taken when manually examining the device, as it's easy to press the wrong button and erase or add data. Manual extraction should be used as the last resort to verify findings extracted using one of the other methods. Certain circumstances may warrant you to conduct a manual examination as the first step. This may include cases of life or death situations or missing persons where a quick scan of the device may lead the police to the individual.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Logical data extraction</h1>
                </header>
            
            <article>
                
<p>Logical data extraction techniques extract the data present on the device by interacting with the operating system and accessing the filesystem. These techniques are significant because they provide valuable data, work on most devices, and are easy to use. Once again, the concept of rooting comes into the picture while extracting the data. Logical techniques do not actually require root access for data extraction. However, having root access on a device allows you to access all of the files present on a device. This means that some data may be extracted on a non-rooted device while root access will open the device and provide access to all of the files present on the device. Hence, having root access to a device would greatly influence the amount and kind of data that could be extracted through logical techniques. The following sections explain various techniques that can be used to extract data logically from an Android device.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">ADB pull data extraction</h1>
                </header>
            
            <article>
                
<p>As seen earlier, <kbd>adb</kbd> is a command-line tool that helps you to communicate with a device to retrieve information. Using <kbd>adb</kbd>, you can extract data from all of the files on the device or just the relevant files in which you are interested. This is the most widely used technique as part of logical extraction. </p>
<p>To access an Android device through <kbd>adb</kbd>, the USB debugging option must be enabled. From Android 4.2.2, due to secure USB debugging, the host connecting to the device should also be authorized. If the device is locked and USB debugging is not enabled, try to bypass the screen lock using the techniques explained in <a href="b1621e6e-80a3-495e-a288-c8db601149f8.xhtml" target="_blank">Chapter 8</a>, <em>Android Forensic Setup and Pre-Data Extraction Techniques</em>.</p>
<p>As a forensic examiner, it's important for you to know how the data is stored on the Android device and to understand where important and sensitive information is stored so that the data can be extracted accordingly. Application data often contains a wealth of user data that may be relevant to the investigation. All files pertaining to applications of interest should be examined for relevance, as will be explained in <a href="5bb0cc1b-d89c-408a-b2c9-6b946519151d.xhtml" target="_blank">Chapter 10</a>, <em>Android Data Analysis and Recovery</em>. The application data can be stored in one of the following locations:</p>
<ul>
<li><strong>Shared preferences</strong>: This stores data in key-value pairs in a lightweight XML format. Shared preference files are stored in the <kbd>shared_pref</kbd> folder of the application <kbd>/data</kbd> directory.</li>
<li><strong>Internal storage</strong>: This stores data that is private and is present in the device's internal memory. Files saved to the internal storage are private and cannot be accessed by other applications.</li>
<li><strong>External storage</strong>: This stores data that is public in the device's external memory, which does not usually enforce security mechanisms. This data is available in the <kbd>/sdcard</kbd> directory.</li>
<li><strong>SQLite database</strong>: This data is available in the <kbd>/data/data/PackageName/</kbd> database. It is usually stored with the <kbd>.db</kbd> file extension. The data present in a SQLite file can be viewed using the SQLite browser (<a href="https://sourceforge.net/projects/sqlitebrowser/" target="_blank"><span class="URLPACKT">https://sourceforge.net/projects/sqlitebrowser/</span></a>) or by executing the necessary SQLite commands on the respective files.</li>
</ul>
<p>Every Android application stores data on the device using one or more of the preceding data storage options. So, the Contacts application would store all of the information about the contact details in the <kbd>/data/data</kbd> folder under its package name. Note that <kbd>/data/data</kbd> is a part of your device's internal storage, where all of the apps are installed under normal circumstances. Some application data will reside on the SD card and in the <kbd>/data/data</kbd> partition. Using <kbd>adb</kbd>, we can pull the data present in this partition for further analysis using the <kbd>adb pull</kbd> command. Once again, it's important to note that this directory is only accessible on a rooted phone.</p>
<div class="packt_infobox">In Android 7.0 (Nougat), a new storage type called device encrypted storage has been introduced to allow apps to store certain kinds of data in this storage. As a result of this, you will notice new file paths such as <kbd>misc_de</kbd>, <kbd>misc_ce</kbd>, <kbd>system_de</kbd>, and <kbd>system_ce</kbd> under the <kbd>/data</kbd> folder. From a forensic perspective, this is a very important change because what this also means is that, on devices running Android Nougat, <kbd>/data/data</kbd> is <em>not</em> the only location where artifacts are stored, for example,<br/>
SMS data location on old devices: <kbd>/data/com.android.providers.telephony/databases/smsmms.db</kbd> and SMS data location on Nougat devices: <kbd>/user_de/0/com.android.providers.telephony/databases/smsmms.db</kbd>.<br/>
 </div>
<p>On a rooted phone, the <kbd>adb pull</kbd> command on the <kbd>databases</kbd> folder of the Dropbox app can be executed as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1100 image-border" src="assets/3731c5c6-0015-457d-9ed0-ce4ae1dc9bd0.png" style="width:51.08em;height:9.83em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">The adb pull command</div>
<p>Similarly, on a rooted phone, the entire <kbd>/data</kbd> folder can be pulled in this manner. As shown in the following screenshot, the complete <kbd>/data</kbd> directory on the Android device can be copied to the local directory on the machine. The entire <kbd>data</kbd> directory was extracted in 97 seconds. The extraction time will vary depending on the amount of data residing in <kbd>/data</kbd>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/c118d6b7-a15a-42f1-9b7a-1224ace5a3a2.png" style="width:31.17em;height:19.50em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">The /data directory extracted to a forensic workstation</div>
<p>On a non-rooted device, a <kbd>pull</kbd> command on the <kbd>/data</kbd> directory does not extract the files, as shown in the following output, since the shell user does not have permission to access those files:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/6f175857-1f6f-4e06-bbaa-93cb07465527.png" style="width:32.17em;height:2.83em;"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">ADB pull command on non-rooted device</div>
<p>The data copied from a rooted phone through the preceding process maintains its directory structure, hence allowing an investigator to browse through the necessary files to gain access to the information. By analyzing the data of the respective applications, a forensic expert can gather critical information that can influence the outcome of the investigation. Note that examining the folders natively on your forensic workstation will alter the dates and times of the content. You should make a copy of the original output to use for a date/time comparison.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using SQLite Browser to view the data</h1>
                </header>
            
            <article>
                
<p>SQLite Browser is a tool that can help during the course of analyzing extracted data. SQLite Browser allows you to explore database files with the following extensions: <kbd>.sqlite</kbd>, <kbd>.sqlite3</kbd>, <kbd>.sqlitedb</kbd>, <kbd>.db</kbd>, and <kbd>.db3</kbd>. The main advantage of using SQLite Browser is that it shows data in a table form.</p>
<p>Navigate to <span class="packt_screen">File</span> | <span class="packt_screen">Open Database</span> to open a <kbd>.db</kbd> file using SQLite Browser. As shown in the following screenshot, there are three main tabs: <span class="packt_screen">Database Structure</span>, <span class="packt_screen">Browse Data</span>, and <span class="packt_screen">Execute SQL</span>. The <span class="packt_screen">Browse Data</span> tab allows you to see the information present in different tables within the <kbd>.db</kbd> files.</p>
<p>We will be mostly using this tab during our analysis. Alternatively, tools such as Oxygen Forensic SQLite Viewer can also be used for the same purpose. Recovering deleted data from database files is possible and will be explained in <a href="5bb0cc1b-d89c-408a-b2c9-6b946519151d.xhtml" target="_blank">Chapter 10</a>, <em>Android Data Analysis</em> <em>and Recovery</em>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/a8857866-309c-4595-ac02-07cdf0e51b93.png" style="width:31.17em;height:23.17em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">SQLite Browser</div>
<p>The following sections throw light on identifying important data and manually extracting various details from an Android phone. Gaining access to the Terminal on Android has been covered in earlier chapters. In the following section, we will directly jump into gaining device information from there. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Extracting device information</h1>
                </header>
            
            <article>
                
<p>Knowing the details of your Android device, such as the model, version, and more, will aid your investigation. For example, when the device is physically damaged and this prohibits the examination of the device information, you can grab details about the device by executing the following command under the <kbd>/system</kbd> folder:</p>
<pre># cat build.prop</pre>
<p>This can be seen in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1101 image-border" src="assets/3378156a-13cf-440a-96e5-77ec39ed16f2.png" style="width:23.83em;height:31.25em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">The build.prop file</div>
<p>After extracting device information, we will now extract call logs.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Extracting call logs</h1>
                </header>
            
            <article>
                
<p>Accessing the call logs of a phone is often required during an investigation to confirm certain events. The information about call logs is stored in the <kbd>contacts2.db</kbd> file located at <kbd>/data/data/com.android.providers.contacts/databases/</kbd>. As mentioned earlier, you can use SQLite Browser to see the data present in this file after extracting it to a local folder on the forensic workstation. Let's see how to extract call logs by following these steps:</p>
<ol>
<li>As shown in the following screenshot, using the <kbd>adb pull</kbd> command, the necessary <kbd>.db</kbd> files can be extracted to a folder on the forensic workstation:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1102 image-border" src="assets/e701571d-1308-4ed6-b4e5-599300752f2b.png" style="width:37.25em;height:12.67em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">The contacts2.db file copied to a local folder</div>
<ol start="2">
<li>Note that applications used to make calls can store call log details in the respective application folder. All communication applications must be examined for call log details, as follows:</li>
</ol>
<pre style="padding-left: 90px"><strong>C:\android-sdk-windows\platform-tools&gt;adb.exe pull</strong>
<strong>/data/data/com.android.providers.contacts </strong><strong>C:temp</strong> </pre>
<p style="padding-left: 60px">This will give the following output:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1103 image-border" src="assets/a311a289-ac04-46a8-a94d-80f7913be712.png" style="width:68.00em;height:15.75em;"/></p>
<ol start="3">
<li>Now, open the <kbd>contacts2.db</kbd> file using SQLite Browser (by navigating to <span class="packt_screen">File</span> | <span class="packt_screen">Open Database</span>) and browse through the data present in different tables. The <span class="packt_screen">calls</span> table present in the <kbd>contacts2.db</kbd> file provides information about the call history. The following screenshot highlights the call history along with the name, number, duration, and date:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1104 image-border" src="assets/6b0a7aa8-f098-4985-8614-d7bf30bdc610.png" style="width:36.33em;height:9.75em;"/></p>
<p class="packt_figure CDPAlignLeft CDPAlign">On devices running Android 7.0 (Nougat), call log data has been moved out of the <kbd>contacts2.db</kbd> file. On these devices, call log data can be accessed at <kbd>/data/com.android.providers.contacts/databases/calllog.db</kbd></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Extracting SMS/MMS</h1>
                </header>
            
            <article>
                
<p>During the course of an investigation, you may be asked to retrieve the text messages that were sent by and delivered to a particular mobile device. Hence, it is important to understand where the details are stored and how to access the data. The <kbd>mmssms.db</kbd> file, which is present under <kbd>/data/data/com.android.providers.telephony/databases</kbd>, contains the necessary details. As with call logs, you must ensure that applications capable of messaging are examined for relevant message logs by using the following command:</p>
<pre>adb.exe pull /data/data/com.android.providers.telephony C:\temp</pre>
<p>This will give the following output:</p>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref"><img src="assets/953d91f5-744b-4ed9-93d8-710bdfe854eb.png" style="width:54.08em;height:12.00em;"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref"><br/>
Extracting SMS data</div>
<p>The phone number can be seen under the <span class="packt_screen">address</span> column and the corresponding text message can be seen under the <span class="packt_screen">body</span> column, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/8eb6323e-c01c-4c6e-afe6-46793be9d519.png" style="width:37.50em;height:5.42em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">The calls table in the contacts2.db file</div>
<p>We will now extract browser history information.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Extracting browser history information</h1>
                </header>
            
            <article>
                
<p>Extracting browser history information is one task that is often required of a forensic examiner. Apart from the default Android browser, different browser applications can be used on an Android phone, such as Firefox Mobile and Google Chrome. All of these browsers store their browser history in the SQLite <kbd>.db</kbd> format. For our example, we are extracting data from the default Android browser to our forensic workstation. This data is located at <kbd>/data/data/com.android.browser</kbd>. The file named <kbd>browser2.db</kbd> contains the browser history details. The following screenshot shows the browser data, as represented by <span class="packt_screen">Oxygen Forensic SQLite Viewer</span>. Note that the trial version will hide certain information:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/0e1c3bcb-e0e5-418f-884f-dd545c30ab6d.png" style="width:55.33em;height:24.58em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">The browser2.db file in Oxygen Forensic SQLite Viewer</div>
<div class="packt_infobox">Please note that the aforementioned behavior might change if the browser's incognito mode is used.</div>
<p>Several details covered in the preceding section are not stored on the device if the browser's incognito mode is used. Next, we will be analyzing social networking and IM chats.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Analysis of social networking/IM chats</h1>
                </header>
            
            <article>
                
<p>Social networking and IM chat applications such as Facebook, Twitter, and WhatsApp reveal sensitive data that could be helpful during the investigation of any case. The analysis is pretty much the same as with any other Android application. Download the data to a forensic workstation and analyze the <kbd>.db</kbd> files to find out whether you can unearth any sensitive information. For example, let's look at the Facebook application and try to see what data can be extracted.</p>
<p>First, we extract the <kbd>/data/data/com.facebook.katana</kbd> folder and navigate to the <kbd>databases</kbd> folder. The <kbd>fb.db</kbd> file present under this folder contains the information that is associated with the user's account. The <kbd>friends_data</kbd> table contains information about the user's friends' names, along with their phone numbers, email IDs, and dates of birth, as shown in the following screenshot. Similarly, other files can be analyzed to find out whether any sensitive information can be gathered:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/31287bf1-f5b4-47b0-a513-3976365b6902.png" style="width:72.50em;height:24.25em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">The fb.db file in SQLite Browser</div>
<p>Similarly, by analyzing the data present in the <kbd>/data/data</kbd> folder, information about the geolocation, calendar events, user notes, and more can be grabbed.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">ADB backup extraction</h1>
                </header>
            
            <article>
                
<p>Starting from Android 4.0, Google implemented the <kbd>adb backup</kbd> functionality, which allows users to back up application data to a computer using the <kbd>adb</kbd> tool. This process does not require root access and, hence, can be very useful during forensic examination. The main drawback is that it does not back up every application installed on the device. The backup feature is application dependent, as the owner of the application can choose to allow backups. Backups are allowed by default, but the developer can disable it if they want to. Hence, most third-party apps have this enabled and the <kbd>adb backup</kbd> command will work for them. Here is the syntax for the <kbd>adb backup</kbd> command:</p>
<pre><strong>adb backup [-f &lt;file&gt;] [-apk|-noapk] [-shared|-noshared] [-all] [-system|nosystem] [&lt;packages...&gt;]</strong></pre>
<p>Let's discuss this in detail:</p>
<ul>
<li><kbd>-f</kbd>: This is used to choose where the backup file will be stored. If not specified, it defaults to <kbd>backup.ab</kbd> in the present working directory.</li>
<li><kbd>[-apk|noapk]</kbd>: This is used to choose whether or not to back up the <kbd>.apk</kbd> file. The default is <kbd>-noapk</kbd>.</li>
<li><kbd>[-obb|-noobb]</kbd>: This is used to choose whether or not to back up the <kbd>.obb</kbd> (APK expansion) files. It defaults to <kbd>-noobb</kbd>.</li>
<li><kbd>[-shared|-noshared]</kbd>: This is used to choose whether or not to back up data from shared storage and the SD card. The default is <kbd>-noshared</kbd>.</li>
<li><kbd>[-all]</kbd>: This includes all applications for which backups are enabled.</li>
<li><kbd>[-system|-nosystem]</kbd>: This is used to choose whether or not to include system applications. It defaults to <kbd>-system</kbd>.</li>
<li><kbd>[&lt;packages&gt;]</kbd>: This is used to list a specific package name to be backed up.</li>
</ul>
<p>Once the device is connected to the workstation and <kbd>adb</kbd> can access it, run the <kbd>adb backup -shared -all</kbd> command, as shown in the following screenshot:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/a06189c7-2d38-40fa-9af4-d6164ebb7f9c.png" style="width:22.75em;height:3.92em;"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">The adb backup command</div>
<p>Once the command is run, the user then needs to approve the permission on the device, as shown in the following screenshot. For this reason, if the device is screen locked, it's not possible to make a backup:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/0589699a-734b-4c0a-b2fc-868070038f61.png" style="width:15.17em;height:24.50em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Backup permission on the device</div>
<p>An Android backup file is stored as a <kbd>.ab</kbd> file and, by default, it is stored in the <kbd>platform- tools</kbd> folder of the Android SDK. There are free tools, such as Android Backup Extractor, that can convert the <kbd>.ab</kbd> file into a <kbd>.tar</kbd> file, which can then be viewed. Android Backup Extractor can be downloaded from <a href="https://sourceforge.net/projects/adbextractor/" target="_blank"><span class="URLPACKT">https://sourceforge.net/projects/adbextractor/</span></a>. This tool is a Java-based application, so ensure that Java is installed on the workstation before using the tool. To convert the backup file into <kbd>.tar</kbd> format, issue the following command:</p>
<pre><strong>java -jar abe.jar unpack backup.ab backup.tar</strong></pre>
<p>This will automatically create a file with the <kbd>.tar</kbd> extension, which can then be viewed easily using Archive tools such as WinRAR or 7Zip. However, note that if the password was entered on the device when the backup was created, the file will be encrypted and, therefore, you'll need to provide the password as an argument in the preceding command. The backup file contains two main folders—<kbd>apps</kbd> and <kbd>shared</kbd>. The <kbd>apps</kbd> folder contains all of the information that is present under <kbd>/data/data</kbd> for the applications included in the backup. The <kbd>shared</kbd> folder contains all of the data present on the SD card.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">ADB dumpsys extraction</h1>
                </header>
            
            <article>
                
<p>The <kbd>adb dumpsys</kbd> command allows you to gather information about services and applications running on the system. The <kbd>adb shell dumpsys</kbd> command gives diagnostic output for all system services. The <kbd>dumpsys</kbd> command does not require root privileges to be executed and requires only USB debugging to be enabled as with any other <kbd>adb</kbd> command. As shown in the following screenshot, to see the list of all the services that you can use with <kbd>dumpsys</kbd>, run the <kbd><span><span>adb.exe shell service list</span></span></kbd> command:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1106 image-border" src="assets/b00b1090-9432-4e58-93f8-eb5fb55eb31e.png" style="width:48.83em;height:17.17em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">The dumpsys service list command</div>
<p>Analyzing certain <kbd>dumpsys</kbd> services, such as Wi-Fi, user, and notification, can be helpful in certain scenarios. Here are some of the interesting cases where running the <kbd>dumpsys</kbd> command could be helpful during forensic analysis:</p>
<p>The <kbd>dumpsys iphonesubinfo</kbd> service can be used to get information about a device ID or the IMEI number, as shown in the following screenshot:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/310dee13-d763-488c-b4c7-3227abebd8d1.png" style="width:35.58em;height:5.25em;"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">The dumpsys command showing the IMEI number</div>
<p>The <kbd>dumpsys wifi</kbd> service gives information about Wi-Fi points accessed by the user. It shows the SSIDs of the connections that have been saved. This information can be used to pin down the user to a particular location. Here is the <kbd>adb dumpsys</kbd> command, which gives this information:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1107 image-border" src="assets/7705ecd1-0ce6-4014-aeaf-d565e858aceb.png" style="width:31.17em;height:16.92em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">The dumpsys command showing the last connected Wi-Fi details</div>
<p>The <kbd>dumpsys usagestats</kbd> service gives information about recently used applications, along with their date of usage. For example, the following screenshot shows that no apps were used on February 1, 2016, but on January 31, 2016, the Google Chrome browser was used and there was an attempt to back up the phone data:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1108 image-border" src="assets/f7d95867-0cf2-4901-82f6-5149ccab2e1b.png" style="width:41.33em;height:15.42em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">The dumpsys command showing recently used apps</div>
<p>Observe that against <kbd>Date 20160201, android: 0</kbd> times denotes that no apps were used. But for <kbd>Date: 20160131, android: 1 times</kbd> confirms that one app was used and the later sections provide more details on what app was used and so on. Depending on the case being investigated, the forensic analyst needs to figure out whether any of the <kbd>dumpsys</kbd> commands can be of use. Running a <kbd>dumpsys</kbd> command immediately after a device seizure can be extremely helpful later on. By running the <kbd>adb shell dumpsys</kbd> command, you can record all of the <kbd>dumpsys</kbd> service information.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using content providers</h1>
                </header>
            
            <article>
                
<p>In Android, the data of one application cannot be accessed by another application under normal circumstances. However, Android provides a mechanism through which data can be shared with other applications. This is precisely achieved through the use of content providers. Content providers present data to external applications in the form of one or more tables. These tables are no different from the tables found in a relational database. They can be used by applications to share data, usually through the URI addressing scheme. They are used by other applications that access the provider using a provider-client object. During the installation of an app, the user determines whether or not the app can gain access to the requested data (content providers). For instance, contacts, SMS/MMS, and a calendar are examples of content providers.</p>
<p>Hence, by taking advantage of this, we can create an app that can grab all of the information from all of the available content providers. This is precisely how most commercial forensic tools work. The advantage of this method is that it can be used on both rooted and non-rooted devices. For our example, we use AFLogical, which takes advantage of the content provider mechanism to gain access to the information. This tool extracts the data and saves it to an SD card in CSV format. The following steps extract the information from an Android device using AFLogical Open Source Edition 1.5.2:</p>
<ol>
<li>Download AFLogical OSE 1.5.2 from <a href="https://github.com/nowsecure/android-forensics/downloads" target="_blank"><span class="URLPACKT">https://github.com/nowsecure/android-forensics/downloads</span></a>.</li>
</ol>
<div class="packt_infobox">The AFLogical LE edition is capable of extracting a large amount of information and requires registration via forensics using an active law enforcement or government agency email address. AFLogical OSE can pull all available MMSes, SMSes, contacts, and call logs.</div>
<ol start="2">
<li>Ensure that USB debugging mode is enabled and connect the device to the workstation.</li>
</ol>
<ol start="3">
<li>Verify that the device is identified by issuing the <kbd>adb.exe devices</kbd> command:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1109 image-border" src="assets/9bf7260b-c029-4047-ade4-82af65b65d1a.png" style="width:21.50em;height:3.25em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Identify connected device</div>
<ol start="4">
<li>Save the AFLogical OSE app in the home directory and issue the <kbd>adb.exe install AFLogical-OSE_1.5.2.apk</kbd> command to install it on the device:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1110 image-border" src="assets/1320ae1a-9c10-46e4-8e94-2f9aa414bfa8.png" style="width:30.42em;height:3.92em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Installing AFLogical app</div>
<ol start="5">
<li>Once the application is installed, you can run it directly from the device and click on the <span class="packt_screen">Capture</span> button present at the bottom of the app, as shown in the following screenshot:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1111 image-border" src="assets/c5a35c3a-3deb-41c7-8b33-e553d6f7884d.png" style="width:9.33em;height:11.42em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">The AFLogical OSE app</div>
<ol start="6">
<li>The app starts extracting data from the respective content providers and, once the process is complete, a message will be displayed, as shown in the following screenshot:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/77e3267f-4820-4e69-a728-e331fd6c33f5.png" style="width:12.58em;height:4.50em;"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Message displayed after the extraction is complete</div>
<ol start="7">
<li>The extracted data is saved to the SD card of the device in a directory named <kbd>forensics</kbd>. The extracted information is stored in CSV files, as shown in the following screenshot. The CSV files can be viewed using any editor:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/6aa8734c-bdf1-40a2-a472-c471c6170ea0.png" style="width:35.50em;height:18.08em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Files extracted using AFLogical OSE</div>
<ol start="8">
<li>The <kbd>info.xml</kbd> file present in the same directory provides information about the device, including the IMEI number, IMSI number, Android version, information about installed applications, and so on.</li>
</ol>
<div class="packt_infobox">However, note that third-party app installation should be allowed (by selecting the <span class="packt_screen">Unknown Sources</span> option) on the device for this to work. Other tools that can help during an investigation to logically extract data will be covered in <a href="882decf1-336b-416f-98ab-dadecc71efef.xhtml" target="_blank">Chapter 11</a>, <em>Android App Analysis, Malware, a</em><em>nd Reverse Engineering</em>.</div>
<p>This section covered various logical acquisition techniques. We will now look into physical data extraction techniques. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Physical data extraction</h1>
                </header>
            
            <article>
                
<p>Physical extraction refers to the process of obtaining an exact bit-by-bit image of a device. It is important to understand that a bit-by-bit image is not the same as copying and pasting the contents of a device. If we copy and paste the contents of a device, it will only copy the available files, such as visible files, hidden files, and system-related files. This method is considered a logical image. With this method, deleted files and files that are not accessible are not copied by the <kbd>copy</kbd> command. Deleted files can be recovered (based on the circumstances) using certain techniques, which we will see in the following chapters. Unlike logical extraction, physical extraction is an exact copy of the device's memory and includes more information, such as the slack space and unallocated space.</p>
<p>Android data extraction through physical techniques is commonly performed using the <kbd>dd</kbd> command, while other advanced techniques such as JTAG and chip-off are also available, but are usually hard to implement and require great precision and experience to try them on real devices during the course of an investigation. As with any other technique, if an individual performs these procedures incorrectly, data on the device can be corrupted or become irretrievable, thereby making it non-admissible in a court of law. JTAG and chip-off techniques are covered in detail in the following sections. However, extracting data through the <kbd>dd</kbd> command requires root access. The following sections provide an overview of various techniques that can be used to perform physical extraction.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Imaging an Android phone</h1>
                </header>
            
            <article>
                
<p>Imaging a device is one of the most important steps in mobile device forensics. When possible, it's imperative to obtain a physical image of an Android device before performing any techniques to extract the data directly from the device. In forensics, this process of obtaining a physical acquisition is commonly called <em>imaging the device</em>. The terms physical image, forensic image, and raw image are often used to refer to the image captured through this process. Let's first revisit how imaging is done on a desktop computer as it helps us to correlate and realize the problems associated with imaging Android devices. Let's assume that a desktop computer, which is not powered on, is seized from a suspect and sent for forensic examination. In this case, a typical forensic examiner would remove the hard disk, connect it to a write blocker, and obtain a bit-by-bit forensic image using any of the available tools. The original hard disk is then safely protected during the forensic imaging of the data.</p>
<p>With an Android device, all of the areas that contain data cannot be easily removed. Also, if the device is active at the time of receiving it for examination, it is not possible to analyze the device without making any changes to it, because any interaction would change the state of the device.</p>
<p>An Android device may have two file storage areas: internal and external storage. Internal storage refers to the built-in non-volatile memory. External storage refers to the removable storage medium, such as a micro SD card. However, it's important to note that some devices do not have a removable storage medium such as an SD card, but they divide the available permanent storage space into internal and external storage. Hence, it's not always true that external storage is removable. When a removable SD card is present, a forensic image of the memory card has to be obtained. As discussed in <a href="eb3f20e0-270d-4e7d-bb69-3bfd1e707f38.xhtml" target="_blank">Chapter 7</a>, <em>Understanding Android</em>, these removable cards are generally formatted with the FAT32 filesystem. Some mobile device acquisition methods will acquire the SD card through the Android device. This process, while useful, will be slow due to the speed limitations of USB phone cables.</p>
<p>Android, by default, does not provide access to internal directories and system-related files. This restricted access is to ensure the security of the device. For instance, the <kbd>/data/data</kbd> folder is not accessible on a non-rooted device. This folder is especially of interest to us because it stores most of the user-created data and many applications write valuable data into this folder. Hence, to obtain an image of the device, we need to root the Android device. Rooting a device gives us superuser privileges and access to all of the data. It is important to realize that this book has been stressing that all of the steps taken should be forensically sound and should not make changes to the device whenever possible. Rooting an Android device will make changes to it and should be tested on any device that you have not previously investigated. Rooting is common for Android devices, but getting root access could alter the device in a manner that renders the data changed or<span>—</span>worse yet—wiped. Some Android devices, such as the Nexus 4 and 5, may force the data partition to be wiped before allowing root access. This negates the need to root the device to gain access because all of the user data is lost during the process. Just remember that, while rooting provides access to more data when successfully done, it can also wipe data or destroy the phone. Hence, you must ensure that you have consent or legal rights to manipulate an Android device before proceeding with the root. As rooting techniques have been discussed in <a href="b1621e6e-80a3-495e-a288-c8db601149f8.xhtml" target="_blank">Chapter 8</a>, <em>Android Forensic Setup and Pre-Data Extraction Techniques</em>, we will proceed with the example assuming that the device is rooted.</p>
<p>The following is a step-by-step process to obtain a forensic image of a rooted Android device:</p>
<ol>
<li>Connect the Android device to the workstation and verify that the device is identified by issuing the <kbd>adb devices</kbd> command, as shown here:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1112 image-border" src="assets/fb713f1a-4310-4b65-b740-5259e1d54a4b.png" style="width:23.25em;height:3.50em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Identify connected devices</div>
<ol start="2">
<li>Once the <kbd>adb</kbd> access is ready, the partitions can be acquired from the Android device using the following steps:
<ul>
<li><strong>Using the</strong> <kbd>dd</kbd> <strong>command</strong>: The <kbd>dd</kbd> command can be used to create a raw image of the device. This command helps us to create a bit-by-bit image of the Android device by copying low-level data.</li>
<li><strong>Inserting a new SD card</strong>: Insert a new SD card into the device to copy the image file to this card. Make sure that this SD card is wiped and does not contain any other data. You might also need to testify that no additional data is present on the drive. </li>
<li><strong>Executing the command</strong>: The filesystem of an Android device is stored in different locations within the <kbd>/dev</kbd> partition. A simple <kbd>mount</kbd> command on a Samsung Galaxy S3 phone returns the following output:</li>
</ul>
</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1113 image-border" src="assets/a7a902ef-2668-4aaf-9c42-c1ce2dd44c16.png" style="width:33.58em;height:14.50em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">mount command output on an Android device</div>
<ol start="3">
<li>From the preceding output, we can identify the blocks where the <kbd>/system</kbd>, <kbd>/data</kbd>, and <kbd>/cache</kbd> partitions are mounted. Although it's important to image all of the files, most of the data is present in the <kbd>/data</kbd> and <kbd>/system</kbd> partitions. When time allows, all partitions should be acquired for completeness. Once this is done, execute the following command to image the device:</li>
</ol>
<pre style="padding-left: 60px"><strong>dd if=/dev/block/mmcblk0p12 of=/sdcard/tmp.image</strong></pre>
<p>In the preceding example, the data partition of a Samsung Galaxy S3 was used (where <kbd>if</kbd> is the input file and <kbd>of</kbd> is the output file).</p>
<p>The preceding command will make a bit-by-bit image of the <kbd>mmcblk0p12</kbd> file (data partition) and copy the image file to an SD card. Once this is done, the <kbd>dd</kbd> image file can be analyzed using the available forensic software.</p>
<div class="packt_infobox">You must ensure that the SD card has enough storage space to contain the data partition image. Other methods are available to acquire data from rooted devices.</div>
<p>If the image cannot be written to the SD card directly, you can use the <kbd>netcat</kbd> command to write the output directly to the machine. The <kbd>netcat</kbd> tool is a Linux-based tool used for transferring data over a network connection. Android devices do not usually come with <kbd>netcat</kbd> installed. Let's see how to use this command in the following steps:</p>
<ol>
<li>To check whether <kbd>netcat</kbd> is installed, simply open the ADB shell and type <kbd>nc</kbd>. If it returns saying <span class="packt_screen">nc is not found</span>, <kbd>netcat</kbd> will have to be installed manually on the device. You can download <kbd>netcat</kbd> compiled for Android at <a href="https://sourceforge.net/projects/androidforensics-netcat/files/" target="_blank"><span class="URLPACKT">https://sourceforge.net/projects/androidforensics-netcat/files/</span></a>.</li>
<li>Push <kbd>netcat</kbd> on to the device using the following command on your computer:</li>
</ol>
<pre style="padding-left: 60px"><strong>adb push nc /dev/Case_Folder/nc</strong></pre>
<p style="padding-left: 60px">The command should have created <kbd>Case_Folder</kbd> in <kbd>/dev</kbd> and <kbd>nc</kbd> should be in it.</p>
<ol start="3">
<li>Now, we need to give it permission to execute from the ADB shell. This can be done as follows:</li>
</ol>
<pre style="padding-left: 60px"><strong>chomd +x /dev/Case_Folder/nc</strong></pre>
<ol start="4">
<li>Open two Terminal windows with the ADB shell open in one of them. The other will be used to listen to the data being sent from the device. Now, we need to enable port forwarding over ADB from your computer:</li>
</ol>
<pre style="padding-left: 60px"><strong>adb forward tcp:9999 tcp:9999</strong></pre>
<p><kbd>9999</kbd> is the port we chose to use for <kbd>netcat</kbd>; it can be any arbitrary port number between <kbd>1023</kbd> and <kbd>65535</kbd> on a Linux or Mac system (<kbd>1023</kbd> and below are reserved for system processes and require root permission to use them). In the other Terminal window, run the following:</p>
<pre><strong>nc 127.0.0.1 9999 &gt; data_partition.img</strong></pre>
<p>The <kbd>data_partition.img</kbd> file should now be created in the current directory of your computer. When the data is finished transferring, <kbd>netcat</kbd> will terminate in both terminals and return to Command Prompt. The process can take a significant amount of time depending on the size of the image.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Imaging a memory (SD) card</h1>
                </header>
            
            <article>
                
<p>There are many tools available that can image a memory card. The following example uses <kbd>WinHex</kbd> to create a raw disk image of the SD card. The following is the step-by-step process with which to image a memory card using WinHex:</p>
<ol>
<li><strong>Connecting the memory card</strong>: Remove the SD card from the memory slot and use a card reader to connect the memory card to the forensic workstation.</li>
<li><strong>Write-protect the card</strong>: Open the disk using WinHex. Navigate to <span class="packt_screen">Options</span> | <span class="packt_screen">Edit Mode</span> and select <span class="packt_screen">Read-only Mode (=write-protected mode)</span>, as shown in the following screenshot. This is to make sure that the device is write-protected and no data can be written on it:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/8c84dc71-82dc-40a6-9299-c287d2f8fc20.png" style="width:24.92em;height:10.58em;"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">WinHex view of Edit Mode (left) and WinHex Read-only Mode enabled (right)</div>
<ol start="3">
<li><strong>Calculating the hash value</strong>: Calculate the hash value of the memory card to make sure that no changes are made at any point during the investigation. Navigate to <span class="packt_screen">Tools</span> | <span class="packt_screen">Compute hash</span> and choose any hashing algorithm.</li>
</ol>
<ol start="4">
<li><strong>Creating the image of the disk</strong>: Navigate to <span class="packt_screen">File</span> | <span class="packt_screen">Create Disk Image</span>, as shown in the following screenshot. Select the raw image option (<kbd>.dd</kbd>) to create an image. This completes the imaging of the memory card:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/0e6cc2f1-a0ca-47a2-958a-f71bafa8e538.png" style="width:14.67em;height:11.33em;"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">The WinHex disk image option</div>
<p>Once a forensic image is obtained using any of the methods described previously, it needs to be analyzed to extract the relevant information. There are several commercial tools, such as Cellebrite <span>and</span><span> </span><span>XRY,</span> <span>that can analyze image files. Analyzing Android images is covered in detail in</span> <a href="" target="_blank">Chapter 10</a><span>,</span> <em>Android Data Analysis and Recovery</em><span>.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Joint Test Action Group</h1>
                </header>
            
            <article>
                
<p><strong>Joint Test Action Group</strong> (<strong>JTAG</strong>) involves using advanced data acquisition methods, which involve connecting to specific ports on the device and instructing the processor to transfer the data stored on the device. Using this method, a full physical image of a device can be acquired. It is always recommended to first try out the other techniques mentioned earlier, as they are easy to implement and require less effort. An analyst must be experienced and properly trained before attempting JTAG as the device may be damaged if not handled properly.</p>
<p>The JTAG process usually involves the following forensic steps:</p>
<ol>
<li>In JTAG, the device <strong>Test Access Ports</strong> (<strong>TAPs</strong>) are used to access the CPU of the device. Identifying the TAPs is the primary and most important step. TAPs are identified and the connection is traced to the CPU to find out which pad is responsible for each function. Although device manufacturers document resources about the JTAG schematics of a particular device, they are not released for general viewing. A good site for JTAG on an Android device is <a href="https://forensicswiki.xyz/wiki/index.php?title=JTAG_Forensics" target="_blank">https://forensicswiki.xyz/wiki/index.php?title=JTAG_Forensics</a>.</li>
<li>Wire leads are then soldered to appropriate connector pins and the other end is connected to the device that can control the CPU, as shown in the following photograph (published by Jim Swauger at <a href="http://www.binaryintel.com/services/jtag-chip-off-forensics/jtag-forensics/" target="_blank">http://www.binaryintel.com/services/jtag-chip-off-forensics/jtag-forensics/</a> ). JTAG jigs can be used to forgo soldering for certain devices. The use of a jig or JTAG adapter negates the need to solder, as it connects the TAPs to the CPU:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1114 image-border" src="assets/5acf214d-c2d8-4d2d-bb02-2f5165131b1d.png" style="width:25.17em;height:18.33em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">The JTAG setup</div>
<ul>
<li>Once the preceding steps are complete, power must be applied to boot the CPU. The voltage that must be applied depends on the specifications released by the hardware manufacturer. Do not apply a voltage beyond the number given in the specification.</li>
</ul>
<ul>
<li>After applying the power, a full binary memory dump of the NAND flash can be extracted.</li>
<li>Analyze the extracted data using the forensic techniques and tools learned in this book. A raw <kbd>.bin</kbd> file will be obtained during the acquisition; most forensic tools support the ingestion and analysis of this image format.</li>
</ul>
<p>JTAG may sound complicated (perhaps it is), but it serves many useful purposes and three advantages are listed here:</p>
<ul>
<li>The main advantage of this technique is that it works even if the device is not powered on.</li>
<li>It does not require root, ADB, or USB debugging.</li>
<li>It can be used to recover device PINs/passwords and so can image the entire flash memory and recover/crack password files.</li>
</ul>
<p>It is also important to understand that the JTAG technique should not result in the loss of functionality of the device. If reassembled properly, the device should function without any problems. Although the JTAG technique is effective in extracting data, only experienced and qualified personnel should attempt it. Any error in soldering the JTAG pads or applying the wrong voltage could severely damage the device.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The chip-off technique</h1>
                </header>
            
            <article>
                
<p>Chip-off, as the name suggests, is a technique where the NAND flash chips are removed from the device and examined to extract information. Hence, this technique will work even when the device is passcode-protected and USB debugging is not enabled. Unlike the JTAG technique, where the device functions normally after examination, the chip-off technique usually results in the destruction of the device, that is, it is more difficult to reattach the NAND flash to the device after examination. The process of reattaching the NAND flash to the device is called re-balling and requires training and practice.</p>
<p>Chip-off techniques usually involve the following forensic steps:</p>
<ol>
<li>All of the chips on the device must be researched to determine which chip contains user data.</li>
<li>Once determined, the NAND flash is physically removed from the device. This can be done by applying heat to desolder the chip:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/29816483-c302-4e11-be48-9cb6ba0517b8.png" style="width:24.25em;height:32.42em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref"><span>Chip-off technique<br/>
Source: http://www.binaryintel.com/services/jtag-chip-off-forensics/chip-off_forensics/</span></div>
<ol start="3">
<li>This is a very delicate process and must be done with great care, as it may result in damaging the NAND flash.</li>
<li>The chip is then cleaned and repaired to make sure that the connectors are present and functioning.</li>
</ol>
<ol start="5">
<li>Using specialized hardware device adapters, the chip can now be read. This is done by inserting the chip into the hardware device, that supports the specific NAND flash chip. In this process, raw data is acquired from the chip, resulting in a <kbd>.bin</kbd> file.</li>
<li>The data acquired can now be analyzed using forensic techniques and the tools described earlier.</li>
</ol>
<p>The chip-off technique is most helpful when a device is damaged severely, locked, or otherwise inaccessible. However, the application of this technique requires not only expertise but also costly equipment and tools. There is always a risk of damaging the NAND flash while removing it and, hence, it is recommended to try out the logical techniques first to extract any data.</p>
<p>While root access is a must to perform any of the techniques discussed earlier, it must be noted here that, at the time of writing this book, none of these techniques would work on devices that have <strong>Full Disk Encryption</strong> (<strong>FDE</strong>) enabled. As discussed in <a href="eb3f20e0-270d-4e7d-bb69-3bfd1e707f38.xhtml" target="_blank">Chapter 7</a>, <em>Understanding Android</em>, Google has mandated the use of FDE for most devices starting from Android 6.0. Although some techniques were demonstrated and published for decrypting full disk encryption, they are device-specific and are not widely applicable.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>This chapter covered various manual, logical, and physical data extraction techniques. We learned when and how to apply these techniques during the course of an investigation. Logical techniques extract data by interacting with the device using tools such as ADB. Physical techniques, on the other hand, access a larger set of data; they are complex and require a great deal of expertise to perform. Imaging a device produces a bit-by-bit image of the device, which is later analyzed using tools. Imaging a device is one of the primary steps to ensure that the data on the device is not modified. Android 7.0 and above poses a new challenge to forensic investigators by bringing in new security features and file paths that may limit acquisition. With this knowledge, you can perform device acquisition to extract relevant data from an Android device. </p>
<p>In the next chapter, we will see how to extract relevant data such as call logs, text messages, and browsing history from an image file. We will also cover data recovery techniques, using which we can recover data deleted from a device.</p>


            </article>

            
        </section>
    </body></html>