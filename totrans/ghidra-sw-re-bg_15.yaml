- en: '*Chapter 12*: Analyzing Processor Modules'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will address how to incorporate new processor modules in
    Ghidra. This is an advanced topic that involves learning the **Specification Language
    for Encoding and Decoding for Ghidra** (**SLEIGH**) so that we can specify the
    language, disassembling the code, performing function identification via prologue
    and epilogue byte pattern matching, stack frame creation, and function cross-references
    generation.
  prefs: []
  type: TYPE_NORMAL
- en: During this chapter, you will acquire extremely useful skills for breaking down
    advanced reverse engineering protections. You will do this by implementing a virtual
    machine so that the adversary (you) will have to apply reverse engineering to
    the virtual machine before reverse engineering the original binary. There are
    several examples of malware (such as ZeusVM, KINS, and so on) and powerful software
    protection that's mostly based on virtualization (such as VMProtect, Denuvo, and
    more).
  prefs: []
  type: TYPE_NORMAL
- en: SLEIGH and SLED
  prefs: []
  type: TYPE_NORMAL
- en: 'SLEIGH, the Ghidra processor specification language, has its origins in the
    **Specification Language for Encoding and Decoding** (**SLED**), which describes
    abstract, binary, and assembly language representations of machine instructions.
    If you want to learn more about SLEIGH, which is a broad topic, check out the
    following link: [https://ghidra.re/courses/languages/html/sleigh.html](https://ghidra.re/courses/languages/html/sleigh.html).
    If you want to learn more about SLED, check out the following link: [https://www.cs.tufts.edu/~nr/pubs/specifying.html](https://www.cs.tufts.edu/~nr/pubs/specifying.html).'
  prefs: []
  type: TYPE_NORMAL
- en: We will start by providing an overview of the extensive list of existing Ghidra
    processor modules and how they are used by Ghidra. Finally, we will analyze the
    **x86 processor module** from a Ghidra developer perspective. The loader under
    analysis is responsible for enabling Ghidra so that we can understand its x86
    architecture and variants (for example, 16-bit real mode). As we did in the previous
    chapter, we will look at a real-world example to help us with this.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the existing Ghidra processor modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Ghidra processor module skeleton
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing Ghidra processors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The technical requirements for this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Java JDK 11 for x86_64 (available here): [https://adoptopenjdk.net/releases.html?variant=openjdk11&jvmVariant=hotspot](https://adoptopenjdk.net/releases.html?variant=openjdk11&jvmVariant=hotspot)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Eclipse IDE for Java developers (any version supporting JDK 11 available here:
    [https://www.eclipse.org/downloads/](https://www.eclipse.org/downloads/)) since
    it is the IDE that''s officially integrated and supported by Ghidra.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This book's GitHub repository, which contains all the necessary code for this
    chapter ([https://github.com/PacktPublishing/Ghidra-Software-Reverse-Engineering-for-Beginners/tree/master/Chapter12](https://github.com/PacktPublishing/Ghidra-Software-Reverse-Engineering-for-Beginners/tree/master/Chapter12)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Check out the following link to see the Code in Action video: [https://bit.ly/2VQjNFt](https://bit.ly/2VQjNFt)'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the existing Ghidra processor modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will provide an overview of Ghidra''s processor modules
    from a user perspective. Ghidra provides support for a lot of processor architectures.
    You can find a list of supported architectures by listing the directories included
    in the `Ghidra/Processors/` directory of both the Ghidra distribution and Ghidra''s
    GitHub repository (https://github.com/NationalSecurityAgency/ghidra/tree/master/Ghidra/Processors),
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.1 – Listing Ghidra''s processor modules (partial list)'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16207_12_001.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.1 – Listing Ghidra's processor modules (partial list)
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing this book, Ghidra supports the following list of processors:`6502`,
    `68000`, `6805`, `8048`, `8051`, `8085`, `AARCH64`, `ARM`, `Atmel`, `CP1600`,
    `CR16`, `DATA`, `Dalvik`, `HCS08`, `HCS12`, `JVM`, `M8C`, `MCS96`, `MIPS`, `PA-RISC`,
    `PIC`, `PowerPC`, `RISCV`, `Sparc`, `SuperH`, `SuperH4`, `TI_MSP430`, `Toy`, `V850`,
    `Z80`, `tricore`, and `x86`.If we compare this list with IDA Professional Edition
    processor support, we'll notice that IDA supports more processors, even though
    it doesn't provide Ghidra support. But if we compare Ghidra with IDA Home Edition,
    then we'll notice that Ghidra supports more architectures, including very common
    architectures such as Dalvik (the discontinued virtual machine used by Android)
    and **Java Virtual Machine** (**JVM**).
  prefs: []
  type: TYPE_NORMAL
- en: 'Using loading a binary for the x86 architecture as an example, you will probably
    remember from [*Chapter 11*](B16207_11_Final_SK_ePub.xhtml#_idTextAnchor194),
    *Incorporating New Binary Formats*, that, when loading a file, you can choose
    what language it will appear in by clicking on the ellipses button (**…**) next
    to **Language**, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.2 – Default language variant when importing a PE file'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16207_12_002.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.2 – Default language variant when importing a PE file
  prefs: []
  type: TYPE_NORMAL
- en: 'Once I''d done this, I unchecked **Show Only Recommended Language/Compiler
    Specs** to show all the languages and compilers that are available. By doing this,
    I can see that the x86 processor module implements eight variants:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.3 – Choosing the appropriate language variant when importing a
    file'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16207_12_003.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.3 – Choosing the appropriate language variant when importing a file
  prefs: []
  type: TYPE_NORMAL
- en: Let's analyze the structure of a processor module to understand how these variants
    are relevant to the `tree` command to provide an overview of the directory structure
    of the x86 processor and analyzer.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `data` directory contains the x86 processor module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, there are three children folders implementing it:'
  prefs: []
  type: TYPE_NORMAL
- en: '`languages`: This is responsible for implementing the x86 processor using different
    kinds of files, all of which will be explained later (`*.sinc`, `*.pspec`, `*.gdis`,
    `*.dwarf`, `*.opinion`, `*.slaspec`, `*.spec`, and `*.ldefs`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`manuals`: The processor''s manual documentation is stored here using the `*.idx`
    Ghidra format. This indexes the original PDF''s information, thus allowing you
    to query the documentation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`patterns`: Byte patterns are stored in XML files and used to determine whether
    the importing file was developed for the x86 architecture.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `src` directory contains the x86 analyzer. You probably remember analyzer
    extensions from the *The Ghidra Extension Module Skeleton* section of [*Chapter
    4*](B16207_04_Final_SK_ePub.xhtml#_idTextAnchor063)*, Using Ghidra Extensions*.
    These kinds of extensions allow us to extend Ghidra''s code analysis functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The main file of the analyzer extension is the `X86Analyzer` Java class file
    (full path: `Ghidra\Processors\x86\src\main\java\ghidra\app\plugin\core\analysis\X86Analyzer.java`).
    This class extends from `ConstantPropagationAnalyzer` (full path: `Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/analysis/ConstantPropagationAnalyzer.java`),
    which itself extends from `AbstractAnalyzer` (the class you must directly or indirectly
    extend from when writing analyzer extensions).'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you learned about existing processors and analyzers and how
    their source code is structured. In the next section, we will explore how to create
    a new processor module.
  prefs: []
  type: TYPE_NORMAL
- en: Overviewing the Ghidra processor module skeleton
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will look at the Ghidra processor module skeleton. This
    skeleton will be a little bit different because processor modules are not written
    in Java. Instead, the processor modules are written in SLEIGH, which is the Ghidra
    processor specification language.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the processor module development environment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before you can create a new processor module, you will need to set up an environment:'
  prefs: []
  type: TYPE_NORMAL
- en: Install the Java JDK for x86_64, as explained in [*Chapter 3*](B16207_03_Final_SK_ePub.xhtml#_idTextAnchor041),
    *Ghidra Debug Mode*, in the *Installing Java JDK* section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install the Eclipse IDE for Java developers, as explained in [*Chapter 3*](B16207_03_Final_SK_ePub.xhtml#_idTextAnchor041),
    *Ghidra Debug Mode*, in the *Installing Eclipse IDE* section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install the `GhidraDev` plugin for Eclipse, as explained in [*Chapter 3*](B16207_03_Final_SK_ePub.xhtml#_idTextAnchor041),
    *Ghidra Debug Mode*, in the *Installing GhidraDev* section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Additionally, in the same way you installed `GhidraDev`, since you will need
    to work with SLEIGH to develop the processor's specifications, it is highly recommended
    that you also install `GhidraSleighEditor`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `GhidraSleighEditor` installation process is the same as for `GhidraDev`
    since both are Eclipse plugins. It is a ZIP file that can be installed from the
    Eclipse IDE, and both the straightforward installation guide (`GhidraSleighEditor_README.html`)
    and the plugin installer (`GhidraSleighEditor-1.0.0.zip`) are available in the
    `Extensions\Eclipse\GhidraSleighEditor` directory of your Ghidra installation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.4 – GhidraSleighEditor plugin for the Eclipse IDE'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16207_12_004.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.4 – GhidraSleighEditor plugin for the Eclipse IDE
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will learn how to create a processor module skeleton.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a processor module skeleton
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As you probably remember from [*Chapter 4*](B16207_04_Final_SK_ePub.xhtml#_idTextAnchor063),
    *Using Ghidra Extensions*, to create a processor module, you must click on `ProcessorModuleProject`,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.5 – Creating a Ghidra project'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16207_12_005.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.5 – Creating a Ghidra project
  prefs: []
  type: TYPE_NORMAL
- en: 'After clicking on **Next >**, only check the last option – **Processor – Enables
    disassembly/decompilation of a processor/architecture** – in order to create a
    processor module skeleton:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.6 – Configuring the Ghidra project so that it includes the processor
    module skeleton'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16207_12_006.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.6 – Configuring the Ghidra project so that it includes the processor
    module skeleton
  prefs: []
  type: TYPE_NORMAL
- en: 'After clicking on **Finish**, you will see the processor skeleton in the **Package
    Explorer** section of Eclipse:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.7 – The processor module skeleton'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16207_12_007.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.7 – The processor module skeleton
  prefs: []
  type: TYPE_NORMAL
- en: 'All the files that compose the skeleton are stored in the `data\languages`
    directory. Since each file has its own specification goal, let''s look at them
    in more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '`skel.cspec`: As its name suggests, this is a compiler specification file.
    It allows us to encode information that is specific to the compiler that''s necessary
    when dissembling and analyzing a binary. You can find out more by going to [https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Features/Decompiler/src/main/doc/cspec.xml](https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Features/Decompiler/src/main/doc/cspec.xml).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`skel.ldefs`: According to the extension, this is the definition of the processor
    language.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`skel.opinion`: As you probably remember from the previous chapter, opinion
    files contain constraints that allow us to determine whether the file can be loaded
    or not by the importer. You can find out more by going to [https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Framework/SoftwareModeling/data/languages/Steps%20to%20creation%20of%20Format%20Opinion.txt](https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Framework/SoftwareModeling/data/languages/Steps%20to%20creation%20of%20Format%20Opinion.txt).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`skel.pspec`: As its name suggests, this file is a processor specification
    file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`skel.sinc`: As its name suggests, this is a SLEIGH file that specifies the
    language instructions of a processor (for example, the `mov` assembly language
    instruction if x86 must be defined here).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`skel.slaspec`: This is the SLEIGH language specification and allows us to
    specify the processor (for example, registers, flags, and so on).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we mentioned previously, SLEIGH is a broad topic, so if you want to learn
    more, please read the documentation available in your Ghidra distribution (`docs\languages\html\sleigh.html`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you have installed the SLEIGH editor, you can edit all the aforementioned
    files by right-clicking the target file, choosing **Open With** | **Other…**,
    and then choosing **Sleigh Editor**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.8 – Opening a file in Eclipse using the Other… editor'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16207_12_008.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.8 – Opening a file in Eclipse using the Other… editor
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want, you can also take this as an opportunity to associate the `*.cspec`
    files by checking the **Use it for all ''*.cspec'' files** option before clicking
    **OK**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.9 – Choosing Sleigh Editor for opening a file in Eclipse'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16207_12_009.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.9 – Choosing Sleigh Editor for opening a file in Eclipse
  prefs: []
  type: TYPE_NORMAL
- en: 'Choose **No** when you''re asked to convert the project into an Xtext project.
    Also, take this opportunity to make your computer remember this decision by checking
    the **Remember my decision** checkbox, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.10 – Converting the project into an Xtext project dialog'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16207_12_010.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.10 – Converting the project into an Xtext project dialog
  prefs: []
  type: TYPE_NORMAL
- en: We started this section by providing an overview of an existing processor module
    (x86 processor) and analyzing it from a Ghidra user perspective. You superficially
    explored the code files that comprise it in order to understand the big picture
    of processor modules. After that, you learned how to set up a processor module
    development environment and a processor module skeleton so that you can start
    developing a new one.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will explore how the x86 processor we looked at in the
    first section of this chapter, *Existing processor modules*, was implemented to
    zoom into the details of its implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Developing Ghidra processors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As you know, Ghidra processor module development involves many different files
    that are located in the `data` directory of the module. These files are listed
    in the manifest ([https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Processors/x86/certification.manifest](https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Processors/x86/certification.manifest)):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.11 – Partial dump of certification.manifest'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16207_12_011.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.11 – Partial dump of certification.manifest
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will look at Ghidra's processor documentation files
    and their relationship to the official processor documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Documenting processors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `manuals` directory of the x86 processor stores the `x86.idx` file ([https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Processors/x86/data/manuals/x86.idx](https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Processors/x86/data/manuals/x86.idx)),
    which contains an indexed version of the official instruction set reference for
    such an architecture ([https://software.intel.com/sites/default/files/managed/a4/60/325383-sdm-vol-2abcd.pdf](https://software.intel.com/sites/default/files/managed/a4/60/325383-sdm-vol-2abcd.pdf)).
    This indexed version allows Ghidra to access such information when retrieving
    instruction information from Ghidra''s GUI during reversing. The following code
    snippet is of a few lines that can be found at the beginning of the `x86.idx`
    file. They relate to processor instructions and their documentation pages (for
    example, line `01` relates to the `AAA` processor instruction, which can be found
    on page `120` of the official documentation):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will learn how to write signatures so that Ghidra can
    identify functions and code snippets for this architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying functions and code using patterns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is also a `patterns` directory where patterns specified in XML language
    are used for function and code identification. The directory does this by taking
    different compilers into account. The format of a file of patterns (for example,
    [https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Processors/x86/data/patterns/x86gcc_patterns.xml](https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Processors/x86/data/patterns/x86gcc_patterns.xml))
    is an XML file that starts and ends with the `patternlist` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: You can add patterns that allow the analyzer to identify functions and code.
    In the following example, which has been taken from the x86 GCC patterns file
    (`x86gcc_patterns.xml`), we can see that a pattern was included using the `pattern`
    tag. The pattern itself is written as a hexadecimal byte representation. To aid
    in your understanding of this, a comment has been added to the right of this,
    indicating what those bytes mean (in this case, this is the prologue of a function).
  prefs: []
  type: TYPE_NORMAL
- en: 'After the `data` section, we have two tags: `codeboundary` and `possiblefuncstart`.
    The position of these tags is important because, since they are located after
    the `data` section, the meanings of `codeboundary` and `possiblefuncstart` must
    be understood from the pattern indicated in the `data` section onward. `codeboundary`
    indicates that the code starts or ends (it is a boundary), while `possiblefuncstart`
    indicates that the bytes matching the pattern may be at the start of a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use `patternpairs` to define two patterns that are usually found
    together, one preceding the other. These patterns are called `prepatterns` and
    `postpatterns`, respectively. For instance, it is quite common for the end of
    a function (`prepattern`, specified on line `03`) to precede the start of another
    function (`postpattern`, specified on line `09`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will learn how to specify the assembly language for
    such a processor using **Debugging With Attributed Record Formats** (**DWARF**).
  prefs: []
  type: TYPE_NORMAL
- en: Specifying the language and its variants
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Inside the `languages` directory, we have a bunch of files with different names
    (every name implements a variant of the language) and different extensions (every
    extension if responsible for specifying the language at hand). Let's analyze the
    x86 files that implement the x86 variant of the processor (there are other variants
    as well, such as x86-64 and x86-16).
  prefs: []
  type: TYPE_NORMAL
- en: x86.dwarf
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This file describes the registers of the architecture using mappings between
    Ghidra names and DWARF register numberings. DWARF is a standardized debugging
    data format. DWARF mappings are described by the **Application Binary Interface**
    (**ABI**) of the architecture (available here: [https://www.uclibc.org/docs/psABI-i386.pdf](https://www.uclibc.org/docs/psABI-i386.pdf)).
    The Ghidra DWARF file looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, apart from matching the Ghidra register names with DWARF numbers,
    attributes are also used to specify the ESP register''s purpose in the x86 architecture
    as a stack pointer (the `stackpointer` attribute):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Attributes can also be used to abbreviate code. For instance, they can be used
    to declare eight registers at a time. Registers `XMM0` to `XMM7` are declared
    using a single line of code via the `auto_count` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: This XML consists of mapping registers. In the next section, we will learn how
    to define the x86 processor language.
  prefs: []
  type: TYPE_NORMAL
- en: DWARF Debugging Format
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to learn more about DWARF, go to the official website: [http://dwarfstd.org/](http://dwarfstd.org/).'
  prefs: []
  type: TYPE_NORMAL
- en: x86.ldefs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This file defines the x86 processor language and its variants. All languages
    are specified inside `language_definitions` tags (lines `00` and `19`). For instance,
    the default variant of the x86 language (line `04`) that corresponds to the x86
    architecture (line `01`) for 32-bit machines (line `03`) using little endian (line
    `02`) and shown to the user as `x86:LE:32:default` (line `09`) is fully specified
    between lines `01` and `18` (the language tags). Its specification can also include
    the name of the processor variant in external tools (lines `12`-`16`).
  prefs: []
  type: TYPE_NORMAL
- en: 'It also references some external files: `x86.sla` (SLEIGH language specification
    file) on line `06`), `x86.pspec` (processor specification file) on line `07`,
    `x86.idx` (x86 architecture indexed manual) on line `08`, and `x86.dwarf` (DWARF
    registry mapping file) on line `16`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will learn about the processor specifications that are
    relevant when importing a file.
  prefs: []
  type: TYPE_NORMAL
- en: x86.opinion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This file contains constraints that allow us to determine whether the file
    can be loaded by the importer. For instance, the constraints for `PE` files (line
    `01`) in the case of the `windows` compiler (line `02`) are the constraints that
    are specified between lines `03`-`10`. Each has its own primary value that can
    be queried using the `opinion` query service when you''re loading a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will learn how to specify some necessary information
    about compilers targeting the architecture.
  prefs: []
  type: TYPE_NORMAL
- en: x86.pspec
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The compiler specification file allows us to encode information that is specific
    to the compiler and is necessary when dissembling and analyzing a binary (for
    example, the program counter on line `08`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will learn how to specify the processor architecture
    using the SLEIGH language.
  prefs: []
  type: TYPE_NORMAL
- en: x86.slaspec
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The SLEIGH language specification allows us to specify the processor. In this
    case, the implementation is split into many files that are included in `x86.slapec`.
    In this case, we are interested in `ia.sinc`, which implements an x86 32-bit variant
    of this language:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to write your own language, then you will need to learn more about
    SLEIGH (https://ghidra.re/courses/languages/html/sleigh.html). The following is
    a snippet of `ia.sinc` that allows us to implement matching between the x86 32-bit
    swap instruction and the PCode swap operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: In this section, you learned how Ghidra's x86 processor module is structured
    and some of the details of its implementation. These can be useful if you're planning
    to develop your own Ghidra processor module. It is up to you if you wish to continue
    learning about SLEIGH, which is a broad and interesting topic.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about the built-in Ghidra processors and their
    variants. You also learned what these processors look like when you're importing
    files using Ghidra.
  prefs: []
  type: TYPE_NORMAL
- en: You also learned about the skills you need to use for Ghidra processor module
    development and the SLEIGH language, which is used more for specifying than programming.
    By learning about this, you learned why processor modules are special. You were
    then introduced to processor module development by getting hands-on and analyzing
    the 32-bit processor variant of the x86 architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you learned about the URL resources that you can use if you want to
    learn more about the SLEIGH specification language and write your own processor
    modules.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to contribute to the Ghidra project via
    collaborating and how to be part of the community.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the difference between a processor module and an analyzer module?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When writing patterns, is the tag's position important?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between language and language variants?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Please refer to the following links to find out more about the topics that
    were covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'SLEIGH documentation:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://ghidra.re/courses/languages/html/sleigh.html](https://ghidra.re/courses/languages/html/sleigh.html)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Ghidra decompiler documentation:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/NationalSecurityAgency/ghidra/tree/master/Ghidra/Features/Decompiler/src/main/doc](https://github.com/NationalSecurityAgency/ghidra/tree/master/Ghidra/Features/Decompiler/src/main/doc)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
