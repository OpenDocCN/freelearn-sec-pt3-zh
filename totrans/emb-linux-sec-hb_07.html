<html><head></head><body><div><div><p>&#13;
			<h1 id="_idParaDest-115" class="chapter-number"><a id="_idTextAnchor230"/>7</h1>&#13;
			<h1 id="_idParaDest-116"><a id="_idTextAnchor231"/>The Trusted Platform Module</h1>&#13;
			<p>Commonly just called <strong class="bold">TPM</strong>, short for <strong class="bold">Trusted Platform Module</strong>, this security-focused microcontroller <a id="_idIndexMarker300"/>chipset uses advanced cryptography to store critical or sensitive information. This could be in the form of credentials, passwords, biometrics, encryption keys, or other very sensitive data.</p>&#13;
			<p>The exercises in this chapter will challenge your perceptions of what can or should be automated in an appliance. In this chapter, we will build upon methodologies to leverage this tool to further automate your encrypted passphrase authentication within your solutions, as initially introduced in <a href="B22104_06.xhtml#_idTextAnchor213"><em class="italic">Chapter 6</em></a>. TPM, when leveraged properly, can<a id="_idTextAnchor232"/> become<a id="_idTextAnchor233"/> your enabler to a higher level of security and positive end-user experience. That said, TPM is not without its drawbacks and eccentric warts. It is notoriously not user-friendly and, sometimes, some of its registers can be unreliable. Whether or not this is a hardware or software issue, I know not. Regardless, I will demonstrate how to manipulate it for success.</p>&#13;
			<p>Whether you choose to leverage TPM or not is not a simple decision to make. Weigh the pros and cons. It can truly take your appliance to the next level if you let it. This chapter will have the following headings:</p>&#13;
			<ul>&#13;
				<li>What is TPM?</li>&#13;
				<li>Configuring TPM by example</li>&#13;
			</ul>&#13;
			<p>Let’s get started.<a id="_idTextAnchor234"/></p>&#13;
			<h1 id="_idParaDest-117"><a id="_idTextAnchor235"/>What is TPM?</h1>&#13;
			<p>Beyond being one of hundreds of chips on your motherboard that most people could never identify, TPM is rapidly becoming a mission-essential tool for most operating systems. As<a id="_idTextAnchor236"/> of this book’s writing, the average Linux system does not even require you to have TPM activated. Other operating systems, such as Microsoft Windows 11, actually require it for the operating system to be installed.</p>&#13;
			<p>TPM provides mechanisms to securely store a variety of information securely. These objects can be (but are not limited to) license keys, user credentials, encryption keys, or other types of data that provide for the consumption of said data without user interactions.</p>&#13;
			<p>There are <a id="_idIndexMarker301"/>different types of TPM implementation – firmware, discrete, and integrated TPM. TPM can also be done via software (aka virtual TPM) but it can possibly be worked around since it has no more protection than any other software programs running on top of your operating system. Avoid software TPM unless it’s a last resort.</p>&#13;
			<p><strong class="bold">Firmware TPMs</strong> take <a id="_idIndexMarker302"/>advantage <a id="_idIndexMarker303"/>of the system CPU’s trusted execution functions. This, by default, creates what is known as a <strong class="bold">trust anchor</strong> for<a id="_idIndexMarker304"/> that system. These can only be cleared by being physically present at the console and cleared out via setting in<a id="_idIndexMarker305"/> the <strong class="bold">UEFI BIOS</strong>. These ar<a id="_idTextAnchor237"/>e the most commonly found – in my opinion, the most reliable as well.</p>&#13;
			<p><strong class="bold">Discrete TPM<a id="_idTextAnchor238"/>s</strong> are<a id="_idIndexMarker306"/> similar to firmware-based<a id="_idIndexMarker307"/> TPMs except that they are controlled outside of the UEFI BIOS through other APIs and software. Discrete TPMs leverage functionality within your CPU itself rather than the firmware. If you replace your CPU or change your operating system, you will lose all the TPM data previously stored. Otherwise, these are virtually just as good as those in one’s firmware.</p>&#13;
			<p>Finally, there<a id="_idIndexMarker308"/> are the <strong class="bold">integrated TPMs</strong>; these <a id="_idIndexMarker309"/>are chipsets that perform many functions but also have the TPM functionality built in. This type of TPM functionality is the least common in the field.</p>&#13;
			<p>I’ve been asked <em class="italic">“Is using one over the others leaving oneself vulnerable?”</em>. The short and correct answer is that not using any TPM solution is what may leave one’s solution vulnerable. All TPM implementations work. Which you choose is solely based on your own criteria and what is available for your chosen platform.</p>&#13;
			<p>Currently, the gold standard is TPM version 2.0. TPM 2.0 is feature-rich and can store multiple keys and values. It is found virtually on all the latest servers, PCs, and laptops. Its algorithms and built-in cryptography are impressive.</p>&#13;
			<p>Older systems may have the earlier implementation of TPM 1.2. This version has limited capacity and lesser-strength cryptography, yet it is leaps and bounds better than not having anything.</p>&#13;
			<p>Most government requirements standards globally set TPM 1.2 as a minimum requirement for any system that touches sensitive data. Of course, TPM 2.0 is requisite on the most sensitive platforms.</p>&#13;
			<p>Let’s now move on to a brief histor<a id="_idTextAnchor239"/>y of TPM.</p>&#13;
			<h2 id="_idParaDest-118"><a id="_idTextAnchor240"/>The history of TPM</h2>&#13;
			<p>I’ll summarize<a id="_idIndexMarker310"/> a quick historical overview for you, and I’ll intentionally keep it brief and spare you any drudgery. TPM was the result of brainstorming by a technology industry think tank called <em class="italic">Trusted Computing Group</em> back in 2009. This concept was turned into a global standard by the <strong class="bold">International Organization for Standardization</strong> (<strong class="bold">ISO</strong>) in<a id="_idIndexMarker311"/> conjunction with the <strong class="bold">International Electrotechnical Commission</strong> (<strong class="bold">IEC</strong>). Hence, TPM<a id="_idIndexMarker312"/> was born as <em class="italic">ISO/IEC 11889:2009</em>.</p>&#13;
			<p>TPM 1.2 became a global standard back in 2011 and reigned for many years. It was only replaced by TPM 2.0 in 2019 as the <em class="italic">ISO/IEC 11889:2015</em> publication. Sadly, it is now considered insufficient and obsolete by most security organizations. I still say using a TPM 1.2 module is better than using nothing. So clearly, you can make your own decisions.</p>&#13;
			<p>Here’s a graphical <a id="_idIndexMarker313"/>description of how TPM works (credit, Wikipedia, <a href="https://upload.wikimedia.org/wikipedia/commons/thumb/b/be/TPM.svg/2880px-TPM.svg.png">https://upload.wikimedia.org/wikipedia/commons/thumb/b/be/TPM.svg/2880px-TPM.svg.png</a>):</p>&#13;
			<div>&#13;
				<div>&#13;
					<img src="img/B22104_07_1.jpg" alt="Figure 7.1 – TPM description" width="1209" height="815"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.1 – TPM description</p>&#13;
			<p>TPM 2.0 is still, as <a id="_idIndexMarker314"/>of this book’s publishing, the global standard. The exercises in this chapter will solely focus on TPM version 2.0. So, let’s move on to those e<a id="_idTextAnchor241"/>xercises now.</p>&#13;
			<h1 id="_idParaDest-119"><a id="_idTextAnchor242"/>Configuring TPM by example</h1>&#13;
			<p>In this <a id="_idIndexMarker315"/>exercise, we’ll implement the automation of a storage volume’s decryption by storing an encryption passphrase within the TPM securely. Doing such in a real-world appliance makes your solution more secure and prevents having to share the encryption passphrase with the public, hence, by nature, making your solution vastly more secure.</p>&#13;
			<p class="callout-heading">Requirements for the exercise</p>&#13;
			<p class="callout">For this lab, I installed Fedora40 (Workstation Edition) onto bare-metal hardware. During this installation, I created a 500 MiB encrypted XFS filesystem mounted onto <code>/data</code>. I used <code>TPMmaster2024</code> as the encryption key.</p>&#13;
			<p>Here’s what <a id="_idIndexMarker316"/>that setup looked like during the creation process:</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B22104_07_2.jpg" alt="Figure 7.2 – Encrypted filesystem setup during Fedora installation" width="1211" height="1123"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.2 – Encrypted filesystem setup during Fedora installation</p>&#13;
			<p>Upon completion of <a id="_idIndexMarker317"/>the installation, when the system boots, we are prompted to enter the <strong class="bold">LUKS key</strong> in <a id="_idIndexMarker318"/>order to boot and mount that filesystem:</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B22104_07_3.jpg" alt="Figure 7.3 – Entering the LUKS key manually at boot" width="1650" height="82"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.3 – Entering the LUKS key manually at boot</p>&#13;
			<p>For this exercise, I reco<a id="_idTextAnchor243"/>mmend you add a really small LUKS encrypted partition to an existing test machine without doing a complete reinstall. It’s up to you. In my example, I’ve used a non-system partition/filesystem, but in production, you would be encrypting almost everything except for <code>/boot</code> and the<a id="_idTextAnchor244"/> EFI partition.</p>&#13;
			<h2 id="_idParaDest-120"><a id="_idTextAnchor245"/>Exercise – enabling TPM 2 in conjunction with LUKS encryption</h2>&#13;
			<p>First, let’s <a id="_idIndexMarker319"/>ensure that your system actually has the correct hardware. We’ll browse the logs to see whether a TPM 2.0 module was found at the last boot cycle. If this doesn’t return good results, you may not have the requisite hardware for this exercise:</p>&#13;
			<pre class="console">&#13;
$ sudo dmesg | grep TPM</pre>			<p>The output for this command can be somewhat lengthy, so I will not be displaying all of the possible output here for this instance. The key thing to observe in the output you get from running the command is <code>TPM2</code>:</p>&#13;
			<pre class="console">&#13;
[    0.011277] ACPI: TPM2 0x000000009AECAF08 000034 (v04 LENOVO TC-M1U   00001450 AMI  00000000)&#13;
[    0.011320] ACPI: Reserving TPM2 table memory at [mem 0x9aecaf08-0x9aecaf3b]&#13;
[    1.105253] tpm_tis MSFT0101:00: 2.0 TPM (device-id 0x1B, rev-id 16)&#13;
[    1.726489] systemd[1]: systemd 255.6-1.fc40 running in system mode (+PAM +AUDIT +SELINUX -APPARMOR +IMA +SMACK +SECCOMP -GCRYPT +GNUTLS +OPENSSL +ACL +BLKID +CURL +ELFUTILS +FIDO2 +IDN2 -IDN -IPTC +KMOD +LIBCRYPTSETUP +LIBFDISK +PCRE2 +PWQUALITY +P11KIT +QRENCODE +TPM2 +BZIP2 +LZ4 +XZ +ZLIB +ZSTD +BPF_FRAMEWORK +XKBCOMMON +UTMP +SYSVINIT default-hierarchy=unified)&#13;
[    4.604247] systemd[1]: systemd 255.6-1.fc40 running in system mode (+PAM +AUDIT +SELINUX -APPARMOR +IMA +SMACK +SECCOMP -GCRYPT +GNUTLS +OPENSSL +ACL +BLKID +CURL +ELFUTILS +FIDO2 +IDN2 -IDN -IPTC +KMOD +LIBCRYPTSETUP +LIBFDISK +PCRE2 +PWQUALITY +P11KIT +QRENCODE +TPM2 +BZIP2 +LZ4 +XZ +ZLIB +ZSTD +BPF_FRAMEWORK +XKBCOMMON +UTMP +SYSVINIT default-hierarchy=unified)&#13;
[    5.477528] systemd[1]: systemd-pcrextend.socket - TPM2 PCR Extension (Varlink) was skipped because of an unmet condition check (ConditionSecurity=measured-uki).&#13;
[    5.507674] systemd[1]: systemd-pcrmachine.service - TPM2 PCR Machine ID Measurement was skipped because of an unmet condition check (ConditionSecurity=measured-uki).&#13;
[    5.508733] systemd[1]: systemd-tpm2-setup-early.service - TPM2 SRK Setup (Early) was skipped because of an unmet condition check (ConditionSecurity=measured-uki).</pre>			<p class="callout-heading">Important note</p>&#13;
			<p class="callout">If you didn’t get any <code>TPM2</code> output, it’s probably safe to say that your lab hardware is insufficient for the exercises in this chapter.</p>&#13;
			<p>Now that <a id="_idIndexMarker320"/>we’ve established you have a TPM version 2.0 module, let’s ensure it is set up properly in the UEFI BIOS. Reboot your machine, interrupt the boot process so that you can enter the UEFI BIOS setup, and then go to your TPM configuration:</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B22104_07_4.jpg" alt="Figure 7.4 – UEFI BIOS – setting up TPM" width="1628" height="651"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.4 – UEFI BIOS – setting up TPM</p>&#13;
			<p>You may <a id="_idIndexMarker321"/>have more than one option for TPM; if so, choose <strong class="bold">Firmware TPM</strong> over <strong class="bold">Discrete TPM</strong>. Set the chipset to <strong class="bold">Enabled</strong>, and to ensure that there’s nothing legacy left inside the chip, clear it before proceeding. Do not forget to save and exit your UEFI BIOS (and reboot).</p>&#13;
			<p>Let’s install the packages we’ll need to automate the decryption process leveraging our TPM:</p>&#13;
			<pre class="console">&#13;
$ sudo dnf install -y clevis clevis-luks clevis-dracut clevis-systemd clevis-pin-tpm2</pre>			<p>The output for this is rather lengthy, so I have truncated what is displayed. What is important is that your package installations are completed successfully:</p>&#13;
			<pre class="console">&#13;
Installed:&#13;
  clevis-20-2.fc40.x86_64               clevis-dracut-20-2.fc40.x86_64    clevis-luks-20-2.fc40.x86_64&#13;
  clevis-pin-tpm2-0.5.3-5.fc40.x86_64   clevis-systemd-20-2.fc40.x86_64   jose-13-1.fc40.x86_64&#13;
  libjose-13-1.fc40.x86_64              libluksmeta-9-22.fc40.x86_64      luksmeta-9-22.fc40.x86_64&#13;
Complete!</pre>			<p>We’re not done yet. There are more packages that we must ensure are installed properly:</p>&#13;
			<pre class="console">&#13;
$ sudo dnf install -y tpm2-tss tpm2-tools tpm2-abrmd tpm2-pkcs11</pre>			<p>The <a id="_idIndexMarker322"/>output for this command is rather verbose, so I have truncated it to only show what I recommend that you check for on your execution (i.e., the package installations completed successfully – please note that some packages may already have been installed previously depending on how you configured your lab machine):</p>&#13;
			<pre class="console">&#13;
Installed:&#13;
  tpm2-abrmd-3.0.0-5.fc40.x86_64                 tpm2-abrmd-selinux-2.3.1-10.fc40.noarch&#13;
  tpm2-pkcs11-1.9.0-5.fc40.x86_64&#13;
Complete!</pre>			<p>Next, we’ll need to determine the exact device name for our encrypted device:</p>&#13;
			<pre class="console">&#13;
$ lsblk</pre>			<p>This command is rather important in its lengthy output as it will guide you as to how your disks <a id="_idIndexMarker323"/>are carved out and the sizes of filesystems:</p>&#13;
			<p class="callout-heading">Important note</p>&#13;
			<p class="callout">Your system’s output might vary from the results I have – make note of how your disks are carved out. This will be important in this exercise.</p>&#13;
			<pre class="console">&#13;
NAME                                          MAJ:MIN RM   SIZE RO TYPE  MOUNTPOINTS&#13;
sda                                             8:0    0 476.9G  0 disk&#13;
├─sda1                                          8:1    0   200M  0 part  /boot/efi&#13;
├─sda2                                          8:2    0     3G  0 part  /boot&#13;
├─sda3                                          8:3    0    50G  0 part  /&#13;
├─sda4                                          8:4    0    64G  0 part  [SWAP]&#13;
├─sda5                                          8:5    0    50G  0 part  /var&#13;
├─sda6                                          8:6    0    50G  0 part  /usr&#13;
├─sda7                                          8:7    0    50G  0 part  /home&#13;
└─sda8                                          8:8    0   500M  0 part&#13;
  └─luks-463aba53-7189-4920-a128-b4db2a314848 253:0    0   484M  0 crypt /data&#13;
zram0                                         252:0    0     8G  0 disk  [SWAP]</pre>			<p>So, for example, my block device is <code>/dev/sda8</code> (please note that yours will be different).</p>&#13;
			<p>We’ll take that information and feed it into the next command, which will bind our key into TPM:</p>&#13;
			<pre class="console">&#13;
$ sudo clevis luks bind -d /dev/sda8 tpm2 '{"hash":"sha256","key":"rsa","pcr_bank":"sha256","pcr_ids":"6,7"}'</pre>			<p>Please<a id="_idIndexMarker324"/> note that this command will ask you to authenticate to use elevated permissions. Then, it will ask you to confirm the existing LUKS passphrase you wish to use to automatically decrypt the volume:</p>&#13;
			<pre class="console">&#13;
[sudo] password for mstonge:&#13;
Enter existing LUKS password:</pre>			<p>Now, let’s tell <code>systemd</code> to always use the TPM2 module first when trying to access that drive:</p>&#13;
			<pre class="console">&#13;
$ sudo systemctl enable clevis-luks-askpass.path --now&#13;
$ sudo systemd-cryptenroll --tpm2-device=auto --tpm2-pcrs=6+7 /dev/sda8</pre>			<p>This command will ask you to confirm the existing LUKS passphrase:</p>&#13;
			<pre class="console">&#13;
 Please enter current passphrase for disk /dev/sda8: •••••••••••••&#13;
New TPM2 token enrolled as key slot 2.</pre>			<p>All right, we’re not done yet. We’ll use <code>dracut</code> to regenerate the proper settings for booting.</p>&#13;
			<pre class="console">&#13;
$ sudo dracut -fv --regenerate-all</pre>			<p>Again, the output for this will be exhaustingly extensive, but I do ask that you pay close attention to your own output results. Here, I will truncate my results and only highlight the end state:</p>&#13;
			<pre class="console">&#13;
dracut[I]: *** Stripping files ***&#13;
dracut[I]: *** Stripping files done ***&#13;
dracut[I]: *** Creating image file '/boot/initramfs-6.8.5-301.fc40.x86_64.img' ***&#13;
dracut[I]: Using auto-determined compression method 'pigz'&#13;
dracut[I]: *** Creating initramfs image file '/boot/initramfs-6.8.5-301.fc40.x86_64.img' done ***</pre>			<p>Now we’ve<a id="_idIndexMarker325"/> configured the new booting parameters and kernel image, it’s time to reboot your system. If all goes well, you will <em class="italic">not</em> be prompted to enter your LUKS password (it’ll be done for you automatically thanks to TPM):</p>&#13;
			<pre class="console">&#13;
$ sudo systemctl reboot</pre>			<p class="callout-heading">Important note</p>&#13;
			<p class="callout">TPM2 can be rather problematic. Depending on your system, it’s common to have to rebind LUKS passphrases with <code>clevis</code> after some patching cycles.</p>&#13;
			<p>TPM is known to be troublesome, if not uncooperative, to Linux. Many Linux developers are working hard to iron out the issues. I suspect that, in the near future, as these issues are resolved, we’ll see some distributions forcing TPM2 usage in the same manner that Windows does today.</p>&#13;
			<p>I trust you enjoyed this platform exercise module. (See what I did there? Dad jokes – sorry, hahaha!)</p>&#13;
			<h1 id="_idParaDest-121"><a id="_idTextAnchor246"/>Summary</h1>&#13;
			<p>In this chapter, we covered TPM, its versions, and its history. I kept it brief in order to not bore you to death. The point of this book is to help you understand how to make things more secure rather than being an anthology of technological evolution.</p>&#13;
			<p>You got a rare glimpse into how this understated TPM technology can aid you in automating your appliance’s security. Although TPM is an imperfect solution, it has its merits and its risks. More importantly, you should consider implementing TPM to automate your encrypted filesystems with your product.</p>&#13;
			<p>In our next chapter, we’ll go even deeper into disk encryption functionality. Let’s move on.</p>&#13;
			<h1 id="_idParaDest-122"><a id="_idTextAnchor247"/>Join our community on Discord</h1>&#13;
			<p>Join our community’s Discord space for discussions with the authors and other readers:</p>&#13;
			<p><a href="https://packt.link/embeddedsystems">https://packt.link/embeddedsystems</a></p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B22104_Discord_QR.jpg" alt="" width="150" height="150"/>&#13;
				</p>&#13;
			</div>&#13;
		</div>&#13;
	</div></div></body></html>