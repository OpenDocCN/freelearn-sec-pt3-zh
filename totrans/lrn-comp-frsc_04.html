<html><head></head><body>
  <div><h1 class="chapterNumber">4</h1>
    <h1 id="_idParaDest-80" class="chapterTitle">Computer Systems</h1>
    <p class="normal">As we discussed in previous chapters, digital forensic investigators must control the environment they operate in. The diversity of computer hardware, operating systems, and filesystems requires the digital forensic investigator to have a firm understanding of all the different and potential configurations they may encounter. This requires the digital forensic investigator to have procedures or controls to protect the integrity of digital evidence and the processes used to examine it. If you do not understand the boot process and how the system reacts when it starts or which filesystem is used on storage devices, you could make a fatal mistake. In addition, you must understand how they work together. Failure to understand these essential components could lead you to alter the digital evidence. You will also find that you will be less effective when you testify in judicial or administrative proceedings.</p>
    <p class="normal">In this chapter, we will cover the following topics:</p>
    <ul>
      <li class="bulletList">Understanding the boot process </li>
      <li class="bulletList">Understanding filesystems</li>
      <li class="bulletList">Understanding the NTFS filesystem</li>
    </ul>
    <h1 id="_idParaDest-81" class="heading-1">Understanding the boot process</h1>
    <p class="normal">To control the <a id="_idIndexMarker334"/>environment as we start our investigation, we must understand the environment. Here, digital evidence is being stored, created, and accessed. In most cases, this will be a computer system. I use the term “computer system,” which comprises the operating system, the filesystem, and the hardware bundled together to create a computer. To be effective, you must understand the physical media the data is stored on, the filesystem used on the storage device, and how that data is tracked and accessed while on the storage device. </p>
    <p class="normal">Once you understand the process, you can then implement controls to protect the integrity of the digital evidence.</p>
    <p class="normal">So, what is the boot process? When you push the power button and electricity energizes the system, commands are issued. As it executes the commands, the system is taking steps (like on a ladder) to achieve the goal of a running operating system. If something breaks any of those steps, the system will not load.</p>
    <p class="normal">The first step<a id="_idIndexMarker335"/> is the <strong class="keyWord">Power-On Self-Test</strong> (<strong class="keyWord">POST</strong>); the CPU will <a id="_idIndexMarker336"/>access <a id="_idIndexMarker337"/>the <strong class="keyWord">Read-Only Memory</strong> (<strong class="keyWord">ROM</strong>) and the <strong class="keyWord">Basic Input/Output System</strong> (<strong class="keyWord">BIOS</strong>) and test essential motherboard functions. This is where you hear the beep sound when you turn the power on to the computer system. If there is an error, the system will notify you of the error through beep codes. If you do not have the motherboard manual, a Google search will help determine the meaning of the specific beep code.</p>
    <p class="normal">Once the <strong class="keyWord">POST</strong> test has been successfully completed, the BIOS is activated and executed. Note that the system has not accessed the storage media. This is because all the program executions occur at the motherboard level and not in the storage devices. The user can <a id="_idIndexMarker338"/>access the BIOS by using the correct key combination displayed on the screen.</p>
    <div><p class="normal"><strong class="keyWord">Note</strong></p>
      <p class="normal">The time allowed for you to hit the correct key can sometimes be relatively short. If you are unsuccessful, the system will continue booting and accessing the storage device. If you are trying to access the suspect’s computer system, disengage the storage devices if they are accessible before starting the process. This will ensure that you are not booting to the suspect’s storage device and destroying evidence. </p>
    </div>
    <p class="normal">The BIOS will have the basic information of the system: the amount of RAM, the type of CPU, information about the attached drives, and the system date and time. The easiest way to document this information is to photograph it as it is displayed on the screen. This is also where you can change the boot sequence. Typically, the system checks the CD/DVD first and then the designated hard drive. This is where you would be able to change the setting of the boot device when we create the boot media later in the chapter. Changing the boot device tells the BIOS to access the device we provide and not the suspect’s device.</p>
    <p class="normal">In 2010, the BIOS function was replaced by the <strong class="keyWord">Unified Extensible Firmware Interface</strong> (<strong class="keyWord">UEFI</strong>). It<a id="_idIndexMarker339"/> provides the same service as the BIOS, but has been enhanced, as follows:</p>
    <ul>
      <li class="bulletList">By providing better security at the preboot process</li>
      <li class="bulletList">Faster startup</li>
      <li class="bulletList">Will support drives larger than 2 TB</li>
      <li class="bulletList">Support for 64-bit device drivers</li>
      <li class="bulletList">Support<a id="_idIndexMarker340"/> for the <strong class="keyWord">GUID Partition Table</strong> (<strong class="keyWord">GPT</strong>)</li>
    </ul>
    <p class="normal">The Secure Boot feature allows us to use authenticated operating systems when booting the computer system. This can be an issue if you attempt to use an alternative booting device.</p>
    <p class="normal">As you can<a id="_idIndexMarker341"/> see in the following diagram, once the power is turned on and it has completed the POST test, depending on the system, it may boot with the BIOS, or it may boot with the UEFI scheme:</p>
    <figure class="mediaobject"><img src="img/B18329_04_01.png" alt="Figure 4.1 – Boot process "/></figure>
    <p class="packt_figref">Figure 4.1: Boot process</p>
    <p class="normal">The BIOS will look for the <strong class="keyWord">Master Boot Record</strong> (<strong class="keyWord">MBR</strong>) of the boot device. The MBR is located at sector <a id="_idIndexMarker342"/>zero and holds information about the partitions, the filesystems, and the boot loader code for the installed operating system. Once the MBR is found in the boot loader and activated, control is then passed over to the operating system to complete the booting process.</p>
    <p class="normal">The UEFI will look for the GPT; the GPT will have a protective MBR to ensure legacy systems will not mistakenly read this as being unpartitioned and overwrite the data. It will also contain the partition entries and backup partition table header. A GPT disk can contain up to 128 partitions for a Windows operating system. Like in the BIOS scheme, once the active partition and boot loader have been found, the operating system will take over the booting process.</p>
    <p class="normal">Since you <a id="_idIndexMarker343"/>now understand the boot process, we still want to control the boot environment by creating forensic boot media, which we will discuss next. </p>
    <h2 id="_idParaDest-82" class="heading-2">Forensic boot media</h2>
    <p class="normal">It is a <a id="_idIndexMarker344"/>widespread <a id="_idIndexMarker345"/>practice to remove the hard drive from the system to create a forensic image. However, sometimes, the investigator cannot remove the storage device from the system, and they need to create a forensic image of the storage device. To accomplish this task, you need to use a bootable CD/DVD or USB device to create a forensic environment to create a forensic image.</p>
    <p class="normal">Using boot media, you will want to ensure that it will create that sound forensic environment and not cause any changes to the source device. As we discussed during the boot process, we want to intercept any potential changes to that source device, and we want to have the system boot inside an environment we control. While it is still possible to boot using a CD/DVD, finding systems without an optical drive is becoming more common. Without an optical drive, we must use a boot USB device to create a sound forensic environment to access the storage device.</p>
    <p class="normal">Linux is a standard operating system that is used to create a USB-based (live) operating system to create the forensic environment needed to examine these devices. As discussed in <em class="chapterRef">Chapter 3</em>, <em class="italic">Acquisition of Evidence</em>, PALADIN is one such tool. It is freely available to download and purchase if you wish to have it preinstalled on a USB device. Sumuri also provides some limited technical support in the operation of PALADIN.</p>
    <p class="normal">There is also a Windows-based bootable environment known as <strong class="keyWord">WinFE</strong> (<strong class="keyWord">Windows Forensic Environment</strong>). WinFE <a id="_idIndexMarker346"/>was developed by Troy Larson in 2008 and has spawned other tools such as Mini-WinFE, which was developed by Brett Shavers and Misty (<a href="http://reboot.pro/files/file/375-mini-winfe/">http://reboot.pro/files/file/375-mini-winfe/</a>). The benefit of using the Windows bootable environment is that you now have Windows-based forensic tools. It is possible to run X-Ways or FTK Imager from this secure environment. I would not recommend using a tool that is resource-heavy. What I mean is that some forensic suites such as EnCase Forensic or FTK require significant resources to run effectively. X-Ways can be run from a USB device, as can some artifact-specific tools like RegRipper. </p>
    <p class="normal">As with any tool or procedure, you must validate it to ensure you are getting the expected results. This means that before you go out into the field and boot a suspect’s computer utilizing a forensic USB device, you must test it in the laboratory environment to ensure no changes are made. </p>
    <p class="normal">Some of the challenges that you, as the examiner, need to be <a id="_idIndexMarker347"/>concerned <a id="_idIndexMarker348"/>with when using a bootable USB device include the following:</p>
    <ul>
      <li class="bulletList">Ensuring the system will boot to the device and not the internal hard drive by changing the boot order in the BIOS</li>
      <li class="bulletList">In some systems, it’s difficult to access the BIOS in the time provided during the boot process</li>
      <li class="bulletList">Ensuring the system can boot to a USB device – some older systems cannot</li>
      <li class="bulletList">Knowing which filesystems the bootable device can write-protect and which ones it cannot</li>
      <li class="bulletList">Dealing with the secure boot feature of the UEFI boot process</li>
    </ul>
    <p class="normal">As mentioned earlier, secure boot is a security feature of the UEFI process that allows trusted operating systems to boot the system. Therefore, if we want to use a bootable forensic operating system, the secure boot feature must be disabled.</p>
    <p class="normal">You must enter the UEFI environment by pressing the catch key, such as <em class="keystroke">F2</em> or <em class="keystroke">F12</em> (this will vary depending on the computer manufacturer). Once you have entered the setup utility, navigate to the <strong class="keyWord">Security</strong> menu (this might vary depending on the computer manufacturer) and disable the secure boot option. Some Linux distributions and WinFE have received signed status and will boot a secure boot-enabled system.</p>
    <p class="normal">You must document your steps as you go through this process. For example, if you miss hitting the catch key and start the boot process in the host operating system, you must document that it occurred. Even beginning a partial boot will change the timestamps and make entries in various logs in the operating system.</p>
    <p class="normal">Now that <a id="_idIndexMarker349"/>you<a id="_idIndexMarker350"/> understand what a bootable forensic device is let’s go ahead and create one in the next section. </p>
    <h3 id="_idParaDest-83" class="heading-3">Creating a bootable forensic device</h3>
    <p class="normal">To create a bootable <a id="_idIndexMarker351"/>forensic device, you will need a USB (I recommend using an 8 GB, or larger, device) and an ISO file for the operating system you wish to install. I will demonstrate using an ISO for PALADIN and free software <a id="_idIndexMarker352"/>called Rufus (<a href="https://rufus.ie/">https:/rufus.ie/</a>). Rufus is a utility used to create bootable USB devices.</p>
    <p class="normal">Once you download Rufus, execute the executable and the program will run:</p>
    <figure class="mediaobject"><img src="img/B18329_04_02.png" alt="Graphical user interface, application  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 4.2: Rufus</p>
    <p class="normal">Something similar to the preceding screenshot (Rufus) will appear, and you will have to select the appropriate choice from the drop-down menus:</p>
    <ul>
      <li class="bulletList"><strong class="screenText">Device</strong>: This is the destination. It is the USB device you want to host the bootable operating system on.</li>
      <li class="bulletList"><strong class="screenText">Boot selection</strong>: This will be the “live” operating system. Here, I am using an ISO file for PALADIN 7.04.</li>
      <li class="bulletList"><strong class="screenText">Partition scheme</strong>: You have a choice of using MBR or GPT. Using MBR will give you greater flexibility in the devices you can boot.</li>
      <li class="bulletList"><strong class="screenText">Target system</strong>: With the MBR selection for the partition scheme, you can use the device on either a BIOS or UEFI system. If you select GPT for the partition scheme, you can only target UEFI systems.</li>
    </ul>
    <p class="normal">Under <strong class="screenText">Format Options</strong>, accept the default values and then click on the <strong class="screenText">START</strong> button. Once the program completes, you will have a fully functioning, bootable forensic environment.</p>
    <p class="normal">We have <a id="_idIndexMarker353"/>created a forensic boot environment; let’s discuss the storage media you will encounter. We will now discuss hard drives. </p>
    <h2 id="_idParaDest-84" class="heading-2">Hard drives</h2>
    <p class="normal">The term “physical <a id="_idIndexMarker354"/>drive storage device” refers to the hard disk <a id="_idIndexMarker355"/>drive itself. That is a physical device that contains platters or solid-state storage that holds data. The term “logical device/volume/partition” refers to the formatting of the physical device. A physical device can contain one or more logical devices/volumes/partitions. It is a common misconception that the term “C drive” refers to the physical device when, in actuality, it refers to a logical partition on the physical device.</p>
    <p class="normal">Several components make up the interior of the hard drive (as shown in the following figure). If you were to open the case, you would find the hard drive comprised of one or more platters. One or more platters could be stacked together with a spindle in the center. The platters, made of a metal alloy or glass, are coated with a magnetic substance in which the heads magnetically encode information on the platters. The heads can write data on both sides of the platter. The spindles of the hard disk cause the disks to rotate at thousands of revolutions per minute; the faster the spindle causes the platters to spin, the higher the efficiency of accessing the data encoded on the platters. To read or write data to the platters, the heads are positioned less than <strong class="keyWord">.1</strong> microns from the platter’s surface. Additionally, the actuator controls the heads; it swings across the platter, placing the head in the correct position to read/write the data. </p>
    <p class="normal">The storage devices are manufactured with tight tolerances and can be damaged by sudden sharp movement or<a id="_idIndexMarker356"/> a mechanical <a id="_idIndexMarker357"/>shock:</p>
    <figure class="mediaobject"><img src="img/B18329_04_03.png" alt="A picture containing text  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 4.3: Hard drive</p>
    <p class="normal">A hard drive can <a id="_idIndexMarker358"/>have different interfaces, for example, you may run into some of the following:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Small Computer System Interface (SCSI)</strong>: An older <a id="_idIndexMarker359"/>standard that is typically seen in the corporate environment. Limited to 16 chained devices and will have a terminator at the end of the chain.</li>
      <li class="bulletList"><strong class="keyWord">Integrated Drive Electronics (IDE/EIDE)</strong>: An <a id="_idIndexMarker360"/>old standard but may still be found in older consumer computer systems.</li>
      <li class="bulletList"><strong class="keyWord">Serial Advanced Technology Attachment (SATA)</strong>: A<a id="_idIndexMarker361"/> current standard found in many consumer and commercial environments.</li>
      <li class="bulletList"><strong class="keyWord">Serial Attached SCSI (SAS)</strong>: A current<a id="_idIndexMarker362"/> standard that is typically found in commercial environments.</li>
    </ul>
    <p class="normal"><strong class="keyWord">Solid state drives</strong> (<strong class="keyWord">SSDs</strong>) are<a id="_idIndexMarker363"/> storage devices that contain no moving parts. Instead, they are made up of memory chips. As we discussed earlier, a traditional hard drive has several moving parts in which to read/write data to the spinning platters. With an SSD storage device, all the data is stored in memory chips, allowing for the following:</p>
    <ul>
      <li class="bulletList">Less weight</li>
      <li class="bulletList">Increased reliability</li>
      <li class="bulletList">Improved data access speed</li>
      <li class="bulletList">Reduced power consumption</li>
    </ul>
    <p class="normal">For an SSD to function reliably, there are several operations controlled by the firmware of the device. These functions are as follows:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Wear leveling</strong>: This<a id="_idIndexMarker364"/> spreads the writes across the different chips so that it uses the chips at the same rate.</li>
      <li class="bulletList"><strong class="keyWord">Trim</strong>: This will wipe the unallocated space of the device.</li>
      <li class="bulletList"><strong class="keyWord">Garbage collection</strong>: As the firmware scans the memory modules, it may identify pages within the data blocks that have been deleted. The firmware will move the allocated pages to a new block and will wipe the data block so that it can reuse the blocks. The firmware can only delete data in blocks.</li>
    </ul>
    <p class="normal">The real-world<a id="_idIndexMarker365"/> effect on forensics is that we can no longer recover data that is or was in unallocated space. Since these operations are conducted at the firmware layer, these operations start automatically as soon as power is given to the device.</p>
    <h3 id="_idParaDest-85" class="heading-3">Drive geometry</h3>
    <p class="normal">The drive geometry <a id="_idIndexMarker366"/>of a platter drive details how data is stored on the device; the drive geometry defines the number of heads, the number of tracks, the cylinders, and the sectors per track. The manufacturer performs what it refers to as a low-level format, which creates the basic structure of the disk by defining the sectors and tracks. A track is a circular path on the platter’s surface, as indicated in the following diagram. The red circle (<strong class="keyWord">A</strong>) is a single track, and each side of the platter will have its own set of tracks. They then subdivide the track into sectors. A sector (<strong class="keyWord">B</strong>) is the smallest storage unit on the device. </p>
    <p class="normal">Initially, a sector used to be 512 bytes in size; however, newer disks are being formatted with a sector size of 4,096 bytes: </p>
    <figure class="mediaobject"><img src="img/B18329_04_04.png" alt=""/></figure>
    <p class="packt_figref">Figure 4.4: Drive diagram</p>
    <p class="normal">The platters have an addressing scheme to locate the data; originally, <strong class="keyWord">Cylinder, Head, Sector</strong> (<strong class="keyWord">CHS</strong>) was <a id="_idIndexMarker367"/>used. <strong class="keyWord">Cylinder</strong> refers to the vertical axis of the same sectors on all the platters. <strong class="keyWord">Head</strong> refers to the read/write heads; each platter has two heads. Finally,<strong class="keyWord"> sector</strong> refers to the number of sectors per track. This addressing scheme worked for large-capacity hard drives; however, as the storage capacity increased, the <a id="_idIndexMarker368"/>CHS scheme could not scale because of file size limitations, so <strong class="keyWord">Logical Block Addressing</strong> (<strong class="keyWord">LBA</strong>) was created. With the LBA scheme, you can address the sectors with a sector number starting from zero.</p>
    <p class="normal">So, we have<a id="_idIndexMarker369"/> discussed the physical components of the device. We will now dive deeper and examine some of the internal aspects. </p>
    <h2 id="_idParaDest-86" class="heading-2">MBR (Master Boot Record) partitions</h2>
    <p class="normal">Three steps <a id="_idIndexMarker370"/>are required before the <a id="_idIndexMarker371"/>computer system can use the storage device. First, we have discussed the low-level format conducted by the manufacturer, but now we will discuss partitioning.</p>
    <p class="normal">Partitioning occurs when we divide the physical device into logical segments called “volumes.” With the MBR partitioning scheme, we are restricted to four primary partitions. For example, with one physical device, you can have a primary partition used to host the Windows operating system. You can also have a second primary partition that hosts a Linux operating system. Note that you must have a primary partition to boot into an operating system. When a user selects the booted operating system, this is known as <a id="_idIndexMarker372"/>the <strong class="keyWord">active partition</strong>.</p>
    <p class="normal">To get around the partition limit, developers created the extended partition. One of the four partition records is designated as an extended partition, which can then be divided into logical volumes. </p>
    <p class="normal">As we discussed previously, we can find the MBR at sector zero. The MBR contains the information needed by the system to boot. The MBR will be in sector zero, so it will be no longer than 512 bytes. The partition table will show us which partition is the active partition. Once <a id="_idIndexMarker373"/>the<a id="_idIndexMarker374"/> starting sector of the active partition is located, the boot process will continue:</p>
    <figure class="mediaobject"><img src="img/B18329_04_05.png" alt=""/></figure>
    <p class="packt_figref">Figure 4.5: MBR map</p>
    <p class="normal">The preceding MBR map depicts sector zero of a hard disk. This is the MBR for the physical disk. The first 440 bytes are highlighted; this is the boot code. The next 4 bytes are the disk signature and identify the disk to the operating system. The following 64 bytes comprise the partition table. Each 16-byte entry refers to a specific partition. Remember, it restricts us to 4 primary partitions utilizing the MBR partitioning scheme. The final 2 bytes is the signature for the MBR. It identifies the ending of the MBR and will be the last 2 bytes of the sector.</p>
    <p class="normal">In the following table, I have extracted the four partition tables and reformatted the hex values for easier reading. The first byte will designate which partition is the active partition. A value of <code class="inlineCode">x/80</code> identifies the active bootable partition. </p>
    <p class="normal">A value of <code class="inlineCode">x/00</code> shows the non-active (bootable) partition: </p>
    <figure class="mediaobject"><img src="img/B18329_04_06.png" alt=""/></figure>
    <p class="packt_figref">Figure 4.6: Partition tables</p>
    <p class="normal">Typically, you would see the first partition marked as the active partition; in this case, it is the <a id="_idIndexMarker375"/>second<a id="_idIndexMarker376"/> partition, which is bootable. The next 3 bytes represent a starting sector for the CHS calculation. So, when we examine the partition table, we can see that the physical device has partition 0 and partition 1. The entries for partitions 2 and 3 are zeroed out. This tells us that there are only two partitions on this physical device.</p>
    <p class="normal">The fifth byte represents the filesystem on the partition. For partition 0, we can see the hex value of <strong class="keyWord">DE,</strong> which tells us that it is part of the Dell PowerEdge Server utilities. Partition 1 has a hex value of <strong class="keyWord">07</strong>, which shows the NTFS filesystem. </p>
    <p class="normal">If I found the hexadecimal values of <strong class="keyWord">05</strong> or <strong class="keyWord">0f</strong>, that would show an extended partition. We would then have to look into the extended boot records of the extended partitions.</p>
    <div><p class="normal"><strong class="keyWord">Note</strong></p>
      <p class="normal">You can find a <a id="_idIndexMarker377"/>full list of partition identifiers at <a href="https://www.win.tue.nl/~aeb/partitions/partition_types-1.html">https://www.win.tue.nl/~aeb/partitions/partition_types-1.html</a>.</p>
    </div>
    <p class="normal">The next 3 bytes are the values for the ending sector of the CHS calculation. The next 4 bytes show the starting sector of the partition, and the last 4 bytes show the size of the partition.</p>
    <p class="normal">The sector values used in the CHS calculation are legacy values for older storage devices. The values showing the start sector and the total number of sectors (partition size) are being used for the current drives using LBA.</p>
    <p class="normal">Each partition will<a id="_idIndexMarker378"/> have a <strong class="keyWord">Volume Boot Record</strong> (<strong class="keyWord">VBR</strong>) at sector zero of the partition. The system uses the VBR to boot the operating system in that volume. It is an operating system-specific artifact and is created when the partition is formatted. </p>
    <p class="normal">It will also appear on unpartitioned devices, such as removable media, for example, a USB or floppy disk.</p>
    <p class="normal">Primary <a id="_idIndexMarker379"/>partitions <a id="_idIndexMarker380"/>are not the only partitions that you may encounter; you can also encounter an extended partition, which is the subject of the next section. </p>
    <h3 id="_idParaDest-87" class="heading-3">Extended partitions</h3>
    <p class="normal">The limitation<a id="_idIndexMarker381"/> of the MBR of only allowing four primary partitions resulted in the creation of the extended primary partition. Here, it takes the place of one (and only one) primary partition and enables the user to create additional logical partitions over the four primary partitions.</p>
    <p class="normal">The following partition map illustrates the replacement of a primary partition with an extended partition:</p>
    <figure class="mediaobject"><img src="img/B18329_04_07.png" alt=""/></figure>
    <p class="packt_figref">Figure 4.7: Partition map</p>
    <p class="normal">The following diagram shows the extended partition. Here, the user has created multiple logical partitions within the extended partition boundary:</p>
    <figure class="mediaobject"><img src="img/B18329_04_08.png" alt="Diagram  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 4.8: Extended partition map</p>
    <p class="normal">The extended partition will not have a VBR. It <a id="_idIndexMarker382"/>will have an <strong class="keyWord">extended boot record</strong> (<strong class="keyWord">EBR</strong>), which will point to the first extended logical partition. The first extended logical partition will contain information about itself and a pointer to the next extended logical partition. In effect, this will create a daisy chain of pointers from one extended logical partition to<a id="_idIndexMarker383"/> the next.</p>
    <p class="normal">We have now covered the aspects relating to the MBR; let’s now go over the GPT-formatted aspects. </p>
    <h2 id="_idParaDest-88" class="heading-2">GPT partitions</h2>
    <p class="normal">A GUID <a id="_idIndexMarker384"/>is a <strong class="keyWord">globally unique identifier</strong> and uses a 128-bit hexadecimal <a id="_idIndexMarker385"/>value to identify different aspects of the computer system. A GUID comprises five groups and is formatted as <code class="inlineCode">00112233-4455-6677-8899-aabbccddeeff</code>, and, while there is no central authority to ensure uniqueness, it is doubtful that you would get a repeating GUID.</p>
    <p class="normal">RFC 4122 defines the five different <a id="_idIndexMarker386"/>GUIDs as follows:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Version 1</strong>: Date-time and MAC address: The system generates this version using both the current time and client MAC address. This means that if you have a version 1 GUID, you can figure out when it was created by inspecting the timestamp value.</li>
      <li class="bulletList"><strong class="keyWord">Version 2</strong>: DCE security: This version isn’t explicitly defined in RFC 4122, so it doesn’t have to be generated by compliant generators. It is like a version 1 GUID except that the first four bytes of the timestamp are replaced by the user’s POSIX UID or GID, and the upper byte of the clock sequence is replaced by either the POSIX UID or GID domain. (<strong class="keyWord">UID</strong> stands for <strong class="keyWord">User Identifier</strong>. <strong class="keyWord">POSIX</strong> stands for <strong class="keyWord">Portable Operating System Interface</strong>, which is a set of <a id="_idIndexMarker387"/>standards to ensure compatibility between operating systems.)</li>
      <li class="bulletList"><strong class="keyWord">Version 3</strong>: MD5 hash and namespace: This GUID is generated by taking a namespace (for example, a fully qualified domain name) and a name, converting it into bytes, concatenating it, and hashing it. Once it has specified the special bits such as version and variant, it then converts the resulting bytes into hexadecimal form. The special property regarding this version is that the GUIDs generated from the same name in the same namespace will be identical even if they were generated at different times.</li>
      <li class="bulletList"><strong class="keyWord">Version 4</strong>: Random: The system creates this GUID using random numbers. Of the 128 bits in a GUID, it reserves 6 for special use (version + variant bits) giving us 122 bits that can be filled at random.</li>
      <li class="bulletList"><strong class="keyWord">Version 5</strong>: SHA-1 hash<a id="_idIndexMarker388"/> and namespace: This version is identical to version 3 except that SHA-1 is used in the hashing step in place of MD5.</li>
    </ul>
    <p class="normal">The GPT is a partitioning scheme that is used for newer storage devices and is part of the new UEFI standard. The UEFI standard replaces the BIOS, while the GPT replaces the MBR partitioning scheme.</p>
    <p class="normal">The GPT <a id="_idIndexMarker389"/>petitioning<a id="_idIndexMarker390"/> scheme uses LBA, and a protective MBR is found in the physical sector zero. The protective MBR allows for some backward compatibility and helps to remove any issues when dealing with legacy utilities that do not recognize the GPT partitioning scheme. There is no boot code available in the protective MBR. As you can see in the following diagram, this is the first partition entry of the partition table of the protective MBR. The partition is identified by hex value <strong class="keyWord">EE</strong>, which shows it is a GPT partition disk, as shown in the following GPT hex:</p>
    <figure class="mediaobject"><img src="img/B18329_04_09.png" alt="Figure 4.9 – GPT hex "/></figure>
    <p class="packt_figref">Figure 4.9: GPT hex</p>
    <p class="normal">While the MBR contains the partition table within physical sector <code class="inlineCode">0</code>, GPT houses the partition table header at physical sector <code class="inlineCode">1</code>. The GPT header can be identified by the <strong class="keyWord">EFI</strong> signature of hexadecimal values <code class="inlineCode">45 46 49 20 50 41 52 54</code>, as shown in the following diagram:</p>
    <figure class="mediaobject"><img src="img/B18329_04_10.png" alt=""/></figure>
    <p class="packt_figref">Figure 4.10: EFI PART</p>
    <p class="normal">The following<a id="_idIndexMarker391"/> table <a id="_idIndexMarker392"/>shows the layout of the GPT header, which you can use to identify the layout of the desk:</p>
    <figure class="mediaobject"><img src="img/B18329_04_11.png" alt="Table  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 4.11: GPT header format</p>
    <p class="normal">The GPT <a id="_idIndexMarker393"/>partition<a id="_idIndexMarker394"/> entries are typically found in physical sector <code class="inlineCode">2</code>. The following diagram shows the GPT partition table entries:</p>
    <figure class="mediaobject"><img src="img/B18329_04_12.png" alt="Chart  Description automatically generated with medium confidence"/></figure>
    <p class="packt_figref">Figure 4.12: GPT sector 2</p>
    <p class="normal">Each partition<a id="_idIndexMarker395"/> entry <a id="_idIndexMarker396"/>is 128 bytes and provides information about the partitions. The following table shows the contents of the partition entries, which include the partition type GUID, the GUID that is unique to that specific partition, the starting and ending sectors, and the partition name in Unicode:</p>
    <figure class="mediaobject"><img src="img/B18329_04_13.png" alt="Figure 4.13 – GUID "/></figure>
    <p class="packt_figref">Figure 4.13: GUID</p>
    <p class="normal">A partition<a id="_idIndexMarker397"/> should hold all the data on the disk within the partition’s <a id="_idIndexMarker398"/>boundaries; however, there are spaces on the disk outside of the normal partition boundaries where a technical user may hide data. We will discuss those areas next. </p>
    <h2 id="_idParaDest-89" class="heading-2">Host Protected Area (HPA) and Device Configuration Overlay (DCO)</h2>
    <p class="normal">HPA and <a id="_idIndexMarker399"/>DCO are<a id="_idIndexMarker400"/> hidden areas on the hard drive created by the manufacturers. The manufacturer uses the HPA to store recovery and diagnostics tools and it cannot be changed or accessed by the user. The DCO allows the manufacturer to use standard parts to build different products. It will enable the creation of a standard set of sectors on a component to achieve uniformity. For example, the manufacturer might use one set of parts to create a 500 GB hard drive, and while using the same components, it can also create a 600 GB hard drive. Once again, the user would usually not have access to this location. However, some utilities are freely available and could be used by a user to access these locations and store data.</p>
    <p class="normal">The following screenshot shows you how an HPA may appear in X-Ways:</p>
    <figure class="mediaobject"><img src="img/B18329_04_14.png" alt=""/></figure>
    <p class="packt_figref">Figure 4.14: HPA 1</p>
    <p class="normal">The following screenshot shows you how an HPA may appear in FTK Imager: </p>
    <figure class="mediaobject"><img src="img/B18329_04_15.png" alt=""/></figure>
    <p class="packt_figref">Figure 4.15: HPA 2</p>
    <p class="normal">Let’s<a id="_idIndexMarker401"/> move <a id="_idIndexMarker402"/>on and discuss some potential filesystems that you may encounter. </p>
    <h1 id="_idParaDest-90" class="heading-1">Understanding filesystems</h1>
    <p class="normal">A hard drive can<a id="_idIndexMarker403"/> have multiple partitions on it, and, in each partition, there will be (in most cases) a filesystem. There might be hundreds of thousands to millions of files within a partition. The filesystem tracks where every file is and how much space is available within the partition boundaries. </p>
    <p class="normal">We discussed sectors earlier in the <em class="italic">Hard drives</em> section; they are the smallest units available to store data. The filesystem stores data based on clusters. Clusters are comprised of one or more sectors. A cluster is the smallest allocation unit the filesystem can write to. There are many filesystems available, and some are restricted to specific operating systems unless the user enables drivers that will allow the operating system to read the<a id="_idIndexMarker404"/> filesystem. </p>
    <p class="normal">We will now look at some of the common filesystems you may encounter.</p>
    <h2 id="_idParaDest-91" class="heading-2">The FAT filesystem</h2>
    <p class="normal">The <strong class="keyWord">File Allocation Table</strong> (<strong class="keyWord">FAT</strong>) filesystem <a id="_idIndexMarker405"/>has been around since the early days of home computing, and it is one of the few filesystems that nearly all operating systems can read. It is the de facto standard filesystem for removable devices.</p>
    <p class="normal">As time has gone by, the FAT filesystem has gone through numerous changes:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">FAT12</strong>: The first version was created in 1977 and used 12 bits (hence, the FAT12 designation) to address available clusters. This limited its use to only storage devices that could contain 4,096 clusters. It is rarely seen nowadays, but you might find it on a floppy diskette.</li>
      <li class="bulletList"><strong class="keyWord">FAT16</strong>: This was created in 1984 and used 16 bits (I see a pattern) to address the available clusters. It had the same issues as the FAT12, as it could not be scaled to be used with larger-capacity devices.</li>
      <li class="bulletList"><strong class="keyWord">VFAT</strong>: This was introduced with Windows 95 and added the Virtual File Allocation Table. It added the use <a id="_idIndexMarker406"/>of the <strong class="keyWord">long filename</strong> (<strong class="keyWord">LFN</strong>) and additional timestamps.</li>
      <li class="bulletList"><strong class="keyWord">FAT32</strong>: This uses 28 bits to address available clusters, theoretically allowing for a maximum volume size of 2.2 TB. Microsoft implemented restrictions that limited the volume size to 32 GB with a maximum file size of 4 GB. It is still in use today and can be found on most removable devices.</li>
    </ul>
    <p class="normal">We will discuss the FAT32 filesystem for the remainder of this section on the FAT filesystem.</p>
    <p class="normal">The FAT filesystem is laid out in two areas (as shown in the following diagram, Figure 4.16 – FAT areas):</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">System Area</strong>: This stores the volume boot record and FAT tables</li>
      <li class="bulletList"><strong class="keyWord">Data Area</strong>: This stores the root directory and files:</li>
    </ul>
    <figure class="mediaobject"><img src="img/B18329_04_16.png" alt="Figure 4.16 – FAT Areas "/></figure>
    <p class="packt_figref">Figure 4.16: FAT areas</p>
    <p class="normal">Next, we will <a id="_idIndexMarker407"/>discuss what falls under <strong class="keyWord">System Area</strong>.</p>
    <h3 id="_idParaDest-92" class="heading-3">Boot record</h3>
    <p class="normal">We have<a id="_idIndexMarker408"/> the <strong class="keyWord">VBR</strong> in the system area. We can find it in logical sector 0 (LS 0), the first sector within the partition boundaries. The boot process creates the VBR when the partition is formatted and contains information about the volume and boot code to continue the boot process for the operating system. If it is a primary partition, the VBR will consist of several sectors, typically sectors 0, 1, and 2, with a backup in sectors 6, 7, and 8. The VBR and backups are stored in a “reserve area,” which is typically 32 sectors before the first file allocation table begins:</p>
    <figure class="mediaobject"><img src="img/B18329_04_17.png" alt=""/></figure>
    <p class="packt_figref">Figure 4.17: VBR</p>
    <p class="normal">In the preceding diagram, we can see a volume boot sector, which helps to decipher the following information:</p>
    <ul>
      <li class="bulletList"><code class="inlineCode">x00</code>: We will find the jump instructions for the system to continue booting</li>
      <li class="bulletList"><code class="inlineCode">x03</code>: The OEM ID shows which operating system was used to format the device</li>
      <li class="bulletList"><code class="inlineCode">x0B</code>: Bytes per sector</li>
      <li class="bulletList"><code class="inlineCode">x0E</code>: Number of reserve sectors</li>
      <li class="bulletList"><code class="inlineCode">x10</code>: Number of FATs (this should be 2)</li>
      <li class="bulletList"><code class="inlineCode">x11</code>: Unused root entries (for FAT32, this should be 0 because the root directory is in the data area)</li>
      <li class="bulletList"><code class="inlineCode">x13</code>: Number of sectors (this will be 0 if the number of sectors exceeds 65,536)</li>
      <li class="bulletList"><code class="inlineCode">x15</code>: Media descriptor (<code class="inlineCode">xF8</code> will show a hard disk, while <code class="inlineCode">xF0</code> will show a removable device)</li>
      <li class="bulletList"><code class="inlineCode">x16</code>: Number <a id="_idIndexMarker409"/>of sectors per FAT (for FAT32, this should be 0)</li>
      <li class="bulletList"><code class="inlineCode">x18</code>: Number of sectors per track (this should be 63 for hard disks)</li>
      <li class="bulletList"><code class="inlineCode">x1A</code>: Number of heads (this should be 255 for hard disks)</li>
      <li class="bulletList"><code class="inlineCode">x1C</code>: Number of hidden sectors (the number of hidden sectors before the start of the FAT volume)</li>
      <li class="bulletList"><code class="inlineCode">x20</code>: Number of total sectors (that is, the total sectors for the volume)</li>
      <li class="bulletList"><code class="inlineCode">x24</code>: Logical sectors per FAT</li>
      <li class="bulletList"><code class="inlineCode">x28</code>: Extended flags</li>
      <li class="bulletList"><code class="inlineCode">x2A</code>: FAT version</li>
      <li class="bulletList"><code class="inlineCode">x2C</code>: The starting root directory cluster (usually, cluster 2)</li>
      <li class="bulletList"><code class="inlineCode">x30</code>: Location of the filesystem information sector (typically, this is set to 1)</li>
      <li class="bulletList"><code class="inlineCode">x32</code>: Location of the backup sector(s) (usually, this is set to 6)</li>
      <li class="bulletList"><code class="inlineCode">x34</code>: Reserved (set to 0)</li>
      <li class="bulletList"><code class="inlineCode">x40</code>: Physical drive number (<code class="inlineCode">x80</code> for hard drives)</li>
      <li class="bulletList"><code class="inlineCode">x41</code>: Reserved</li>
      <li class="bulletList"><code class="inlineCode">x42</code>: Extended boot signature (this should be <code class="inlineCode">x29</code>)</li>
      <li class="bulletList"><code class="inlineCode">x43</code>: Volume serial number (a 32-bit value is usually generated from the date and time; this can track removable devices)</li>
      <li class="bulletList"><code class="inlineCode">x47</code>: Volume label (this might not be accurate; different OSes may not use this field)</li>
      <li class="bulletList"><code class="inlineCode">x52</code>: Filesystem type</li>
    </ul>
    <p class="normal">Next, we <a id="_idIndexMarker410"/>will take a look at the file allocation table.</p>
    <h3 id="_idParaDest-93" class="heading-3">File allocation table</h3>
    <p class="normal">The next<a id="_idIndexMarker411"/> component of the FAT filesystem is the file allocation table, which immediately follows the VBR. There are two file allocation tables (FAT1 and FAT2) by default. FAT2 is a duplicate of FAT1.</p>
    <p class="normal">The purpose of the file allocation table is to track the clusters and track which files occupy which clusters. Each cluster is represented within the file allocation table starting with cluster 0. The file allocation table uses 4 bytes (32 bits) per cluster entry. The file allocation table will use the following entries to represent the cluster’s current status:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Unallocated</strong>: <code class="inlineCode">x0000 0000</code></li>
      <li class="bulletList"><strong class="keyWord">Allocated</strong>: The next cluster that is used by the file (for example, it represents cluster 7 as <code class="inlineCode">x0700 0000</code>)</li>
      <li class="bulletList"><strong class="keyWord">Allocated</strong>: The last cluster that is used by the file (<code class="inlineCode">xFFFF FFF8</code>)</li>
      <li class="bulletList"><strong class="keyWord">Bad cluster</strong>: Not available for use (<code class="inlineCode">xFFFF FFF7</code>)</li>
    </ul>
    <p class="normal">A cluster is the smallest allocation unit the filesystem can address. A sector is the smallest allocation unit on the disk. A cluster is made up of one or more sectors. It is very easy to get confused if you are co-mingling those terms. Consider the following cluster example:</p>
    <figure class="mediaobject"><img src="img/B18329_04_18.png" alt="Figure 4.18 – Cluster example "/></figure>
    <p class="packt_figref">Figure 4.18: Cluster example</p>
    <p class="normal">As users add files to the data area, the system will update the file allocation table. A file may occupy one or more clusters. Additionally, the clusters may not be sequential, so you could have the data of a file spread in different physical locations on the disk; we typically refer to this as fragmentation.</p>
    <p class="normal">In the following diagram, we can see a representation of the file allocation table; in this scenario, we have a single file occupying three clusters: <strong class="keyWord">Cluster 4</strong>, <strong class="keyWord">Cluster 5</strong>, and <strong class="keyWord">Cluster 6</strong>. You can see that <strong class="keyWord">Cluster 4</strong> is pointing to <strong class="keyWord">Cluster 5</strong> and <strong class="keyWord">Cluster 5</strong> is pointing to <strong class="keyWord">Cluster 6</strong>. <strong class="keyWord">Cluster 6</strong> has<a id="_idIndexMarker412"/> the hexadecimal value for <strong class="keyWord">end of file</strong> (<strong class="keyWord">EOF</strong>):</p>
    <figure class="mediaobject"><img src="img/B18329_04_19.png" alt="Figure 4.19 – Non-fragmented file entry "/></figure>
    <p class="packt_figref">Figure 4.19: Non-fragmented file entry</p>
    <p class="normal">In the following diagram, we can see a similar representation of the file allocation table with some changes. We now have two files, with File 1 occupying clusters <strong class="keyWord">4</strong> and <strong class="keyWord">6</strong>. We can see that <strong class="keyWord">Cluster 4</strong> is pointing to the next cluster containing the file data, which is <strong class="keyWord">Cluster 6</strong>. This is an example of file fragmentation. File 2 is wholly contained within the cluster boundaries of <strong class="keyWord">Cluster 5</strong>. </p>
    <p class="normal"><strong class="keyWord">Cluster 5</strong> will not point to a subsequent cluster; instead, it has the EOF hexadecimal value:</p>
    <figure class="mediaobject"><img src="img/B18329_04_20.png" alt="Diagram  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 4.20:Fragmented file entry</p>
    <p class="normal">We have covered<a id="_idIndexMarker413"/> the system area of the FAT; we will now discuss the data area of the FAT filesystem. </p>
    <h2 id="_idParaDest-94" class="heading-2">Data area</h2>
    <p class="normal">The root<a id="_idIndexMarker414"/> directory is housed in the data<a id="_idIndexMarker415"/> area because, when the system stored it in the system area, it could not grow enough to work with larger-capacity devices. The critical component of the root directory is the directory entry. If there is a file, directory, or subdirectory, there will be a corresponding directory entry. </p>
    <p class="normal">Each directory entry is 32 bytes in length and helps track the file’s name, starting cluster, and file size in bytes.</p>
    <p class="normal">In the following diagram, we can see a FAT32 directory with multiple file entries. The filesystem will stop looking for file entries when it runs into a hexadecimal <code class="inlineCode">00</code>, and all values following the hexadecimal <code class="inlineCode">00</code> will be ignored:</p>
    <figure class="mediaobject"><img src="img/B18329_04_21.png" alt=""/></figure>
    <p class="packt_figref">Figure 4.21: FAT directory entry</p>
    <p class="normal">In the following <a id="_idIndexMarker416"/>FAT directory map, we <a id="_idIndexMarker417"/>can see the layout of the directory entry and a <strong class="keyWord">short filename</strong> (<strong class="keyWord">SFN</strong>) directory<a id="_idIndexMarker418"/> entry with the specific offsets highlighted:</p>
    <figure class="mediaobject"><img src="img/B18329_04_22.png" alt="Graphical user interface, application, table  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 4.22: FAT directory map</p>
    <p class="normal">If the first byte is <code class="inlineCode">xE5</code>, then the filesystem will consider that entry as deleted. The remaining bytes of the file or directory name will remain, as will the other metadata.</p>
    <p class="normal">The short filename must conform to the specifications as follows:</p>
    <ul>
      <li class="bulletList">Eight characters are allowed; if there are less than eight characters, then the name will be padded with <code class="inlineCode">x20</code>.</li>
      <li class="bulletList">Three characters are allocated for the file extension (if there are less than three characters, then the name will be padded with <code class="inlineCode">x20</code>).</li>
      <li class="bulletList">Spaces and the following characters are not permitted: <strong class="keyWord">“+ * , . / : ; &lt; = &gt; ?[\]|</strong>.</li>
    </ul>
    <p class="normal">The directory entry will always be stored in uppercase. The attribute byte (offset <code class="inlineCode">x0B</code>) is considered a packed byte, which means the different values have different meanings.</p>
    <p class="normal">The following diagram shows that bit values in the <code class="inlineCode">Attribute</code> flag can be combined, and the resulting hex value will reflect the <a id="_idIndexMarker419"/>combinations. If a file had the <strong class="keyWord">READ ONLY</strong> flag and<a id="_idIndexMarker420"/> the <strong class="keyWord">HIDDEN</strong> flag, then that would give us a value of <code class="inlineCode">0000 0011</code>, and, when converted<a id="_idIndexMarker421"/> to <a id="_idIndexMarker422"/>hexadecimal, we <a id="_idIndexMarker423"/>get the value of <code class="inlineCode">x03</code>:</p>
    <figure class="mediaobject"><img src="img/B18329_04_23.png" alt="Figure 4.23 – Packed byte "/></figure>
    <p class="packt_figref">Figure 4.23: Packed byte</p>
    <p class="normal">When we look at the example at the bottom of the preceding FAT directory map, we find the hexadecimal value of 20 at the offset <code class="inlineCode">x0B</code>; when we convert the hexadecimal into binary, we get <code class="inlineCode">0010 0000</code>. This tells us that the file is an archive.</p>
    <p class="normal">We can also<a id="_idIndexMarker424"/> encounter an <strong class="keyWord">LFN</strong>; the<a id="_idIndexMarker425"/> technique <a id="_idIndexMarker426"/>for handling an LFN is a little bit more complicated. We will discuss LFNs in the next section. </p>
    <h2 id="_idParaDest-95" class="heading-2">Long filenames</h2>
    <p class="normal">When a user <a id="_idIndexMarker427"/>creates an LFN, the system will generate an alias that conforms to the SFN standard. It will format the alias so that the first three characters will become the extension after the file extension dot. The first six characters will be converted to uppercase and used for the alias. The alias will then add a <strong class="keyWord">~</strong> character with a number following it. It will start with the number 1 and increase incrementally if additional files have the same alias name.</p>
    <p class="normal">The following diagram shows a directory entry for a file with an LFN; the filename is <code class="inlineCode">long filename.txt</code>:</p>
    <figure class="mediaobject"><img src="img/B18329_04_24.png" alt=""/></figure>
    <p class="packt_figref">Figure 4.24: LFN</p>
    <p class="normal">Since this is an LFN, the filesystem will create additional directory entries. In this specific case, there will be two additional directory entries to facilitate the use of the LFN. The first byte of each additional directory entry is the sequence byte. The right nibble is the sequence number. As we look at the directory entry depicted in the preceding diagram, the directory entry above the SFN entry has a hexadecimal value of <code class="inlineCode">x01</code>. Here, the value of <code class="inlineCode">1</code> tells us that this is the first value in the sequence. When we move up to the second directory entry, we can see that it has a hexadecimal value of <code class="inlineCode">x42</code>, the right nibble informs us this is the second directory entry for this LFN file. The left nibble of the value, <code class="inlineCode">4</code>, tells us this is the last directory entry for the file. In each of the LFN directory entries, you will find that the attribute byte is <code class="inlineCode">x0F</code>.</p>
    <p class="normal">But what happens when a file is deleted? Well, you may be able to recover the file and its associated <a id="_idIndexMarker428"/>metadata. In the next section, we will discuss recovering deleted files. </p>
    <h2 id="_idParaDest-96" class="heading-2">Recovering deleted files</h2>
    <p class="normal">When a file is <a id="_idIndexMarker429"/>deleted in the <a id="_idIndexMarker430"/>FAT filesystem, the data itself does not get changed. Instead, the first character of the directory entry will change to <code class="inlineCode">xE5</code>, and the file allocation table entries are reset to <code class="inlineCode">x00</code>. When the filesystem reads the directory entries and encounters <code class="inlineCode">xE5</code>, it will skip that entry and read from the subsequent entries.</p>
    <p class="normal">To recover deleted files, we need to reverse the filesystem’s process to delete the files. Remember, it has not changed the file contents, and they still physically reside in their assigned clusters. So we now need to reverse engineer the deletion and recreate the file entry and the entries in the file allocation table. To do this, we need to find the first cluster of the file, the file size, and the size of the clusters in the volume.</p>
    <p class="normal">In the following diagram, we have a directory entry showing that a file has been deleted. We can see <code class="inlineCode">xE5</code> at the start of the directory entry. (Note that this will require the use of a hex editor to make the changes.)</p>
    <p class="normal">Then, we must determine the starting cluster, <code class="inlineCode">x00</code><strong class="keyWord"> </strong><code class="inlineCode">x08</code> (but shown as <code class="inlineCode">x08 x00</code> in the diagram). This value refers to cluster number 8. Then, to determine the file size, take a look at the last 4 bytes, <code class="inlineCode">x27 x00 x00 x00</code> (remember that the FAT filesystem stores data in little-endian, which means the least-significant byte is on the left, so we would read that value as <code class="inlineCode">x00 x00 x00 x27</code>, and when we convert it into a decimal, we have a value of 39 bytes for the file size):</p>
    <figure class="mediaobject"><img src="img/B18329_04_25.png" alt=""/></figure>
    <p class="packt_figref">Figure 4.25: Deleted entry</p>
    <p class="normal">Now we must determine how many sectors make up a cluster and what the sector size is. You will need to go to the boot record to get that information. The boot record shows us that there are 512 bytes per sector, and there are 8 sectors per cluster, which gives us a cluster size of 4,096 bytes (as shown in the following diagram):</p>
    <figure class="mediaobject"><img src="img/B18329_04_26.png" alt="Figure 4.26 – Boot record "/></figure>
    <p class="packt_figref">Figure 4.26: Boot record</p>
    <p class="normal">This means that our file will only occupy a single cluster. We then go to the file allocation table<a id="_idIndexMarker431"/> and look at the <a id="_idIndexMarker432"/>entry for cluster 8 and see that it is zeroed out: </p>
    <figure class="mediaobject"><img src="img/B18329_04_27.png" alt=""/></figure>
    <p class="packt_figref">Figure 4.27: Deleted FAT</p>
    <p class="normal">To recover the deleted file, perform the following steps:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">You need to change the entry in the file allocation table from <code class="inlineCode">x0000 0000</code> to <code class="inlineCode">xFFFF FFF8</code> or <code class="inlineCode">xFFFF FF0F</code>. If this were a larger file, you would need to change the file allocation table entry to point to the next cluster until you reach the last cluster and the end of the file size. As you are rechaining the entries, if you come to an entry marked as allocated when expecting to find the entry unallocated, you may be dealing with a fragmented file. Another alternative is when the clusters were made available to the filesystem. The system placed a new file in the now-available sectors, which would cause the data to be overwritten. There are not many options available if you run into either one of these situations. If the data is overwritten, then you are stuck. If it is fragmented, you must guess where the next cluster will be, which is not very likely with a large-capacity device.</li>
      <li class="numberedList">The next step is to return to the directory entry and replace <code class="inlineCode">xE5</code> with another character. When replacing the <code class="inlineCode">xE5</code> character of the filename in the directory entry, be careful not to guess what the character is. If you select the incorrect character, you could change the meaning or create a bias with the new filename, which would be improper. When recovering a deleted file, it is recommended that you replace that first character with an underscore or a dash, so there is no misunderstanding about the filename.</li>
    </ol>
    <p class="normal">When recovering a file with an LFN, it is essential to relink the LFN to the SFN. This is because when the additional directories are created to accommodate the LFN, the system creates a checksum based on the data of the SFN. Therefore, when you change the <code class="inlineCode">xE5</code> value on the SFN entry, you also want to use the same replacement character for the subsequent <code class="inlineCode">xE5</code> entries for the LFN directory entries. You link the LFN to the SFN because the SFN directory entry contains information such as the date and time, the starting cluster, and the file size.</p>
    <p class="normal">It is still<a id="_idIndexMarker433"/> possible to recover scraps of <a id="_idIndexMarker434"/>data that existed on the disk but no longer have any artifacts in the filesystem. This information will be stored in slack space, discussed in the next section. </p>
    <h2 id="_idParaDest-97" class="heading-2">Slack space</h2>
    <p class="normal">Now is the time<a id="_idIndexMarker435"/> to bring up slack space. Remember<a id="_idIndexMarker436"/> that the smallest unit the filesystem can write to is a cluster and that clusters are made up of one or more sectors. I keep repeating this because I have seen people who are new to the field get confused about the difference between the two. This is important because files come in a variety of sizes; almost no files will conveniently fit within the cluster boundaries. So, you will have files that spill over into the next cluster. The space between the end of the logical file and the cluster boundary is called “file slack.” This slack space can contain data from the previous file. Until it is overwritten, that data will remain for you to examine.</p>
    <p class="normal">You might find evidence of documents, digital images, chat history, or emails; any data that has been stored on the device, you may find remnants in slack space after the user has deleted the file.</p>
    <p class="normal">This concludes the <em class="italic">FAT filesystems</em> section; next up is NTFS. </p>
    <h1 id="_idParaDest-98" class="heading-1">Understanding the NTFS filesystem</h1>
    <p class="normal">The <strong class="keyWord">New Technology File System</strong> (<strong class="keyWord">NTFS</strong>) is the <a id="_idIndexMarker437"/>default filesystem for Microsoft Windows operating systems. FAT32 had some significant shortcomings, which required a more reliable and efficient filesystem, along with additional administrative improvements to help Microsoft remain viable in a corporate environment. They initially designed NTFS for a server environment; however, as the hard drive capacity has increased, it is now the default filesystem in the commercial and consumer market for the Windows operating system.</p>
    <p class="normal">NTFS is far more complicated than the FAT filesystem; however, the overall purpose remains the same:</p>
    <ul>
      <li class="bulletList">To record the metadata of a file, that is, the filename, the date timestamps, and the file size</li>
      <li class="bulletList">To mark the clusters the file occupies</li>
      <li class="bulletList">To record which clusters are allocated and which clusters are unallocated</li>
    </ul>
    <p class="normal">The NTFS filesystem comprises the following system files:</p>
    <figure class="mediaobject"><img src="img/B18329_04_28.png" alt=""/></figure>
    <p class="packt_figref">Figure 4.28: NTFS table</p>
    <p class="normal">To identify a<a id="_idIndexMarker438"/> partition with NTFS, we need to look at the MBR or the GPT, depending on which formatting scheme was used. In the following diagram, we can see the MBR for the hard drive and the partition table highlighted after the boot code:</p>
    <figure class="mediaobject"><img src="img/B18329_04_29.png" alt=""/></figure>
    <p class="packt_figref">Figure 4.29: NTFS MBR</p>
    <p class="normal">Looking at the partition table, we can see that there is a single partition, and, at offset decimal <code class="inlineCode">11</code> from the start of the partition table, we can see the hexadecimal value of <code class="inlineCode">07</code>. As we discussed earlier in this chapter, this is the filesystem identification for NTFS.</p>
    <p class="normal">With an NTFS-formatted partition, there is no system or data area like we saw with a FAT-formatted partition. Everything in NTFS is considered a file to include the system data. When we look at the VBR, we can see that it contains information for the system to continue <a id="_idIndexMarker439"/>the boot process: </p>
    <figure class="mediaobject"><img src="img/B18329_04_30.png" alt=""/></figure>
    <p class="packt_figref">Figure 4.30: NTFS VBR</p>
    <p class="normal">The information in the VBR is a file; the <code class="inlineCode">$Boot</code> record contains all the information that we would expect to find in the VBR. The following <code class="inlineCode">$Boot</code> diagram shows the data structure for the <code class="inlineCode">$Boot</code> file:</p>
    <figure class="mediaobject"><img src="img/B18329_04_31.png" alt=""/></figure>
    <p class="packt_figref">Figure 4.31: $Boot record</p>
    <p class="normal">Arguably, the <a id="_idIndexMarker440"/>most important system file in the NTFS filesystem is the <code class="inlineCode">$MFT</code> (master file table). The MFT tracks all the files in the volume to include itself. It tracks each file within the MFT through file entries called a file record. Each file record is uniquely numbered and is 1,024 bytes. Each file record starts with a header, with the ASCII text <strong class="keyWord">“FILE”</strong>, and has an EOF marker of hexadecimal <code class="inlineCode">FF FF FF FF</code>. A new file record is created when files are added to the volume. If a file has been deleted, the record will zero out and make it available for reuse. The MFT will look for an empty file record and use it before creating a new record. The file record can be reused rather quickly, which would overwrite the previous data in the file record. </p>
    <p class="normal">As shown in the following NTFS file record example, we can see a file record and file header starting with the ASCII values of <strong class="keyWord">FILE</strong>. If the record were corrupted or had an error, you would see the ASCII value of <strong class="keyWord">BAAD</strong>. The file header is <code class="inlineCode">56</code> bytes:</p>
    <figure class="mediaobject"><img src="img/B18329_04_32.png" alt=""/></figure>
    <p class="packt_figref">Figure 4.32: NTFS file record</p>
    <p class="normal">In the following <a id="_idIndexMarker441"/>NTFS file record map, we can see the data structure of a file record header:</p>
    <figure class="mediaobject"><img src="img/B18329_04_33.png" alt="Figure 4.33 – NTFS file record map "/></figure>
    <p class="packt_figref">Figure 4.33: NTFS file record map</p>
    <p class="normal">The file record <a id="_idIndexMarker442"/>also contains defined data blocks called file attributes. These store specific types of information about the file. The following file attributes table shows several common file attributes that you are likely to see in almost every record:</p>
    <figure class="mediaobject"><img src="img/B18329_04_34.png" alt=""/></figure>
    <p class="packt_figref">Figure 4.34: File attributes table</p>
    <p class="normal">Let’s look at each of these attributes in detail.</p>
    <p class="normal"><strong class="keyWord">$Standard_Information Attribute (0x10)</strong>: The file attributes follow the file header and contain<a id="_idIndexMarker443"/> information about the file and, sometimes, the actual file itself. The following diagram depicts a file attribute. The first four bytes show the attribute type; in this case, it is the $10 Standard Information Attribute, which contains general information, flags, accessed, written, and created times, the owner, and security ID. It is identified by the hexadecimal header: <code class="inlineCode">x/10 00 00 00</code>. The file attribute <a id="_idIndexMarker444"/>map contains the decoded values:</p>
    <figure class="mediaobject"><img src="img/B18329_04_35.png" alt=""/></figure>
    <p class="packt_figref">Figure 4.35: $Standard_Information Attribute </p>
    <p class="normal">Here is a map of the values you will find in the attribute:</p>
    <figure class="mediaobject"><img src="img/B18329_04_36.png" alt="Figure 4.36 – File attribute map "/></figure>
    <p class="packt_figref">Figure 4.36: File attribute map</p>
    <p class="normal"><strong class="keyWord">$File_Name Attribute (0x30)</strong>: The <a id="_idIndexMarker445"/>next<a id="_idIndexMarker446"/> attribute is the <code class="inlineCode">$30</code> File_Name Attribute. This attribute stores the name of the file attribute and is always resident. The maximum filename length is 255 Unicode characters. It is identified by the hexadecimal header of <code class="inlineCode">x/ 30 00 00 00</code>:</p>
    <figure class="mediaobject"><img src="img/B18329_04_37.png" alt=""/></figure>
    <p class="packt_figref">Figure 4.37: $File_Name Attribute</p>
    <p class="normal">The following is <a id="_idIndexMarker447"/>a map of the values you will find in the attribute:</p>
    <figure class="mediaobject"><img src="img/B18329_04_38.png" alt="Figure 4.38 – Filename attribute map "/></figure>
    <p class="packt_figref">Figure 4.38: Filename attribute map</p>
    <p class="normal"><strong class="keyWord">$Data Attribute (0x80)</strong>: The <a id="_idIndexMarker448"/>following attribute for this entry is the <code class="inlineCode">$80</code> Data Attribute. The data attribute contains the file’s contents or points to where the contents are in the volume. This attribute is the file data itself.</p>
    <p class="normal">If the data attribute is resident, we only see the attribute header and the resident content header. The resident content of the attribute is the file’s data. Only tiny files have a resident data attribute. We will discuss resident versus non-resident data later on in this chapter.</p>
    <p class="normal">You may find multiple data attributes per file. In this record, the second $80 Data Attribute, Dropbox, has<a id="_idIndexMarker449"/> added some information to the file:</p>
    <figure class="mediaobject"><img src="img/B18329_04_39.png" alt=""/></figure>
    <p class="packt_figref">Figure 4.39: $Data Attribute</p>
    <p class="normal">The following is a map of the values you will find in the attribute:</p>
    <figure class="mediaobject"><img src="img/B18329_04_40.png" alt="Figure 4.40 – Data attribute map "/></figure>
    <p class="packt_figref">Figure 4.40: Data attribute map</p>
    <p class="normal">When examining the <code class="inlineCode">$Data Attribute 0x80</code>, the filesystem may store the file’s contents<a id="_idIndexMarker450"/> within the MFT file record itself. Since the file record is 1,024 bytes long, it would have to be a tiny file. When the data content of the file fits within the file record, it is called “resident data”:</p>
    <figure class="mediaobject"><img src="img/B18329_04_41.png" alt="Graphical user interface, application  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 4.41: Resident data file</p>
    <p class="normal">In the current example, we have a file named <code class="inlineCode">resident.txt</code> that is 23 bytes. This is smaller than the 1,024 bytes of the file record. To look at the data of the file, we need to look at the <code class="inlineCode">$Data Attribute 0x80</code> of the file record, as follows:</p>
    <figure class="mediaobject"><img src="img/B18329_04_42.png" alt=""/></figure>
    <p class="packt_figref">Figure 4.42: Resident data example</p>
    <p class="normal">On examining the attribute, we can see the ASCII and hex representation of the file content we observed in the preceding resident data example. When dealing with a non-resident file, such as the one depicted in the following diagram, we can see that the <code class="inlineCode">nonresident.txt</code> file, which<a id="_idIndexMarker451"/> is 145 KB in size, is larger than the 1,024-byte file record:</p>
    <figure class="mediaobject"><img src="img/B18329_04_43.png" alt="Graphical user interface, text, application  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 4.43: Non-resident data</p>
    <p class="normal">When you look at the <code class="inlineCode">$Data Attribute 0x80</code> of the file, as shown in the preceding diagram, we do not see the contents of the file, but we have pointers to the location of the file within the volume boundaries. We consider this to be non-resident content. Once the content of the attribute becomes non-resident, it can never become resident again. We commonly refer to the pointers in the file record of the attribute as a “run list” for the data runs of the non-resident data:</p>
    <figure class="mediaobject"><img src="img/B18329_04_44.png" alt=""/></figure>
    <p class="packt_figref">Figure 4.44: Non-resident data example</p>
    <p class="normal">You can have a single data run, or multiple data runs, within the <code class="inlineCode">$Data Attribute</code> <code class="inlineCode">0x80</code>. Deciphering the run list for the data runs can be tricky. In the following run list, we have the <code class="inlineCode">$Data Attribute 0x80</code> with<a id="_idIndexMarker452"/> two run lists:</p>
    <figure class="mediaobject"><img src="img/B18329_04_45.png" alt=""/></figure>
    <p class="packt_figref">Figure 4.45: Run list</p>
    <p class="normal">If the file is not fragmented, then you will have one run list pointing to the data run in the volume. If the file is fragmented (which is very common), then you will have multiple run lists providing information about the starting cluster for each fragment. I have taken the two run lists highlighted in the preceding list and created the following chart:</p>
    <figure class="mediaobject"><img src="img/B18329_04_46.png" alt="Figure 4.46 – Run list map "/></figure>
    <p class="packt_figref">Figure 4.46: Run list map</p>
    <p class="normal">The first run list comprises the hexadecimal values of <code class="inlineCode">31 07 E8 E3 48</code>. Take the first byte of the header (<code class="inlineCode">x/31</code>) and add the left and right nibbles (3+1 = 4). 4 is the number of bytes in the run list entry (this is <code class="inlineCode">x/07 E8 E3 48</code>). </p>
    <p class="normal">The right nibble (<code class="inlineCode">x/1</code>) tells us that 1 byte represents the number of clusters being used for this <a id="_idIndexMarker453"/>fragment. We find a value of <code class="inlineCode">x/07</code> in the length field, which represents 7 clusters for this fragment. The left nibble (<code class="inlineCode">x/3</code>) informs us that 3 bytes (<code class="inlineCode">x/E8 E3 48</code>) will represent the logical starter cluster of the fragment. At the end of the first run, we have a second run list of <code class="inlineCode">x/31 14 44 47 17</code>. </p>
    <p class="normal">Like the prior run list, we take the first byte of the header (<code class="inlineCode">x/31</code>) and add the left and right nibbles (3+1 = 4). 4 is the number of bytes in the run list entry (which is <code class="inlineCode">x/14 44 47 17</code>). The right nibble (<code class="inlineCode">x/1</code>) tells us that 1 byte represents the number of clusters being used for this fragment. We find a value of <code class="inlineCode">x/14</code> in the length field, which represents 20 clusters for this fragment. </p>
    <p class="normal">The left nibble (<code class="inlineCode">x/3</code>) informs us that 3 bytes (<code class="inlineCode">x/44 47 17</code>) will represent the offset from the previous run list cluster. This process will keep going until the system hits <code class="inlineCode">x/ 00 00 00 00</code>, which shows the end of the run lists. </p>
    <p class="normal">That concludes our adventure into the world of NTFS. If you find yourself with a headache, you are not alone! This is just the basics of the filesystem. You can find entire books that have been written about NTFS, if you want to go into much greater detail. </p>
    <h1 id="_idParaDest-99" class="heading-1">Summary</h1>
    <p class="normal">In this chapter, we looked at how physical disks are constructed and prepared in order to store data. We discussed different partition schemes and how they address the creation of logical partitions. We also learned how filesystems differ and how data is organized.</p>
    <p class="normal">In the next chapter, we will learn about the computer investigative process and how to analyze timelines, analyze media, and perform string searching for data.</p>
    <h1 id="_idParaDest-100" class="heading-1">Questions</h1>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Newer computer systems utilize the BIOS booting method.<ol class="alphabeticList" style="list-style-type: lower-alpha;">
          <li class="alphabeticList" value="1">True</li>
          <li class="alphabeticList">False</li>
        </ol>
      </li>
      <li class="numberedList">A UEFI-based computer system will utilize ____________ to boot from.<ol class="alphabeticList" style="list-style-type: lower-alpha;">
          <li class="alphabeticList" value="1">MBR</li>
          <li class="alphabeticList">VBR</li>
          <li class="alphabeticList">GPT</li>
          <li class="alphabeticList">LSD</li>
        </ol>
      </li>
      <li class="numberedList">A cluster is the smallest storage unit on a hard drive.<ol class="alphabeticList" style="list-style-type: lower-alpha;">
          <li class="alphabeticList" value="1">True</li>
          <li class="alphabeticList">False</li>
        </ol>
      </li>
      <li class="numberedList">An MBR-formatted disk can have more than four primary partitions.<ol class="alphabeticList" style="list-style-type: lower-alpha;">
          <li class="alphabeticList" value="1">True</li>
          <li class="alphabeticList">False</li>
        </ol>
      </li>
      <li class="numberedList">A FAT32-formatted partition is laid out in two areas: a system area and a ___________ area.<ol class="alphabeticList" style="list-style-type: lower-alpha;">
          <li class="alphabeticList" value="1">Disk</li>
          <li class="alphabeticList">Doughnut</li>
          <li class="alphabeticList">Data</li>
          <li class="alphabeticList">Designer</li>
        </ol>
      </li>
      <li class="numberedList">In a FAT32-formatted partition, the root directory is in the system area.<ol class="alphabeticList" style="list-style-type: lower-alpha;">
          <li class="alphabeticList" value="1">True</li>
          <li class="alphabeticList">False</li>
        </ol>
      </li>
      <li class="numberedList">In a NTFS-formatted partition, the filename is stored in the _______________ attribute.<ol class="alphabeticList" style="list-style-type: lower-alpha;">
          <li class="alphabeticList" value="1">Standard information</li>
          <li class="alphabeticList">Filename</li>
          <li class="alphabeticList">Data</li>
          <li class="alphabeticList">Security descriptor</li>
        </ol>
      </li>
    </ol>
    <p class="normal">The answers can be found at the end of the book under <em class="italic">Assessment</em>. </p>
    <h1 id="_idParaDest-101" class="heading-1">Further reading</h1>
    <p class="normal">Carrier, B. <em class="italic">File System Forensic Analysis</em>. Addison-Wesley, Reading, PA., Mar. 2005 (available at <a href="https://www.kobo.com/us/en/ebook/file-system-forensic-analysis-1">https://www.kobo.com/us/en/ebook/file-system-forensic-analysis-1</a>).</p>
    <h1 id="_idParaDest-102" class="heading-1">Join our community on Discord</h1>
    <p class="normal">Join our community’s Discord space for discussions with the author and other readers:</p>
    <p class="normal"><a href="https://packt.link/CyberSec">https://packt.link/CyberSec</a></p>
    <p class="normal"><img src="img/QR_Code3852467292877112093.png" alt=""/></p>
  </div>
</body></html>