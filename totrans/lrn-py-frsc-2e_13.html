<html><head></head><body>
        

                            
                    <h1 class="header-title">Coming Full Circle</h1>
                
            
            
                
<p>In this chapter, we will revisit the scripts we've built in the previous chapters to create a prototype forensic framework. This framework will accept an input directory, such as the root folder of a mounted image, and run our plugins against the files to return a series of spreadsheet reports for each plugin.</p>
<p>Up to this point, we've developed standalone scripts in each chapter, never building upon the work in the previous chapters. By developing a framework, we will illustrate how to bring these scripts together and execute them in one context.</p>
<p>In <a href="5844a835-314a-474b-9c28-60880408629d.xhtml" target="_blank">Chapter 8</a>, <em>The Media Age</em>, we created a miniature framework for parsing various types of embedded metadata. We will borrow from that design and add object-oriented programming to it. Using classes simplifies our framework by creating an abstract object for plugins and writers.</p>
<p>Additionally, in our framework, we will showcase the use of a few external libraries that serve an aesthetic purpose rather than functional. These are colorama and FIGlet, which allow us to easily print colored text to standard out and create ASCII art, respectively. In addition, our framework  requires all of the third-party modules that we used in the previous chapters.</p>
<p>The following topics will be discussed in this chapter:</p>
<ul>
<li>Framework fundamentals, challenges, and structure</li>
<li>Adding aesthetic touches to our programs with Colorama and FIGlet</li>
</ul>
<p>The code for this chapter was developed and tested using Python 2.7.15 and Python 3.7.1.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Frameworks</h1>
                
            
            
                
<p>Why build a framework? The question could be, why develop a script at all? Frequently, we perform the same series of steps for a given piece of evidence. For example, we commonly prepare reports for LNK, prefetch, and jumplist files, examine registry keys, and establish external device and network activity to answer forensic questions. As we've seen, we can develop a script to parse these artifacts for us and display the data in a format that's conducive for rapid analysis. Why not write a series of scripts, each responsible for one artifact, and then control them with a singular script, to execute all at once and hence further automate our analysis?</p>
<p>A framework can be developed to run a series of scripts and parse multiple artifacts at once. The output of such a framework could be a series of analysis-ready spreadsheets. This allows the examiner to skip the same tedious series of steps and start answering meaningful questions about the evidence.</p>
<p>Frameworks typically have three main components:</p>
<ul>
<li>A main controller</li>
<li>Plugins</li>
<li>Writers</li>
</ul>
<p>The main controller isn't very different from our <kbd>main()</kbd> functions and essentially calls a series of plugins on some input, which parse specific artifacts, store the returned results, and then send the results to a writer for output. Our plugins are scripts that perform a specific task, for example, a script that parses <kbd>UserAssist</kbd> artifacts. Writers, similar to our <kbd>csv_writer()</kbd> functions, take the output from our plugins and write it out to disk. While this seems like a fairly straightforward process, developing frameworks is more complex than developing a single script. This is because we have to worry about building a simple yet efficient structure and keeping data standardized between plugins.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Building a framework to last</h1>
                
            
            
                
<p>A challenge when developing frameworks is how to keep the code simple and efficient while continuously adding more functionality to the framework. You might find that while the structure of the framework made sense initially, it doesn't support the needs of your increasingly complex framework, requiring you to rethink and rebuild the internals of the framework. Unfortunately, there's no magical way to future-proof your framework and will likely require multiple revisions during its development cycle.</p>
<p>This is no different from normal script development. In the early chapters of this book, we iterated through multiple versions of a script. We did this to illustrate the iterative build process you'll discover during development. This same iterative process can be applied at a larger scale for frameworks. While we are not highlighting that process in this chapter, keep in mind that you may need to rewrite the framework developed here might need to be rewritten if more plugins are later added and  efficiency starts to lag. Development by iteration allows us to continuously improve on our original design to create a stable and efficient program.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Data standardization</h1>
                
            
            
                
<p>One of the biggest challenges when developing a framework is data standardization. What that means is standardizing the input and output data for each plugin to keep things simple. For example, imagine one plugin that returns a list of dictionaries and another that returns just a list. To process these results correctly, you would need to include logic in your writers to handle both scenarios. It pays to implement each plugin in such a way that they return the same data structures. This helps keep your code simple by minimizing additional logic for a variety of special cases.</p>
<p>That said, there may very well be special scenarios you need to consider for each plugin. In our framework, for example, we'll see that some plugins return a list of dictionaries, whereas others return a single dictionary. Consider <kbd>setupapi_parser.py</kbd> from <a href="f5b49c85-69ce-4f37-b62d-7f2934e8d30e.xhtml" target="_blank">Chapter 3</a>, <em>Parsing Text Files</em>—for a moment, it can identify multiple distinct USB devices and generate a dictionary for each one, whereas our <kbd>exif_parser.py</kbd> only returns one dictionary containing the embedded metadata within a single file. In this case, rather than trying to rewrite the plugins to comply with our rule, we leverage logic to handle additional recursion.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Forensic frameworks</h1>
                
            
            
                
<p>There are a lot of forensic frameworks and plenty of these are open source, allowing anyone to contribute to their development. These frameworks are great, not only to contribute to, but to see how experienced developers structure their frameworks. Some popular open source forensic frameworks include the following:</p>
<ul>
<li><strong>Volatility</strong>: A memory forensic framework (<a href="http://github.com/volatilityfoundation/volatility">http://github.com/volatilityfoundation/volatility</a>)</li>
<li><strong>Plaso</strong>: A artifact timelining tool (<a href="http://github.com/log2timeline/plaso">http://github.com/log2timeline/plaso</a>)</li>
<li><strong>GRR ( short for Google Rapid Response)</strong>: An agent-based analysis and response framework for remote forensic analysis (<a href="http://github.com/google/grr">http://github.com/google/grr</a>)</li>
</ul>
<p>Contributing on an actively developing project, whether it's a framework or not, is a great way of actively learning good programming techniques and developing connections for collaboration on future projects.</p>
<p>Make sure to read contribution rules before developing for any project.</p>
<p>Enough has been said about frameworks: let's discuss the third-party modules we'll use to enhance the aesthetics of our framework.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Colorama</h1>
                
            
            
                
<p>The <kbd>colorama</kbd> module (version 0.4.1) allows us to easily create colored Terminal text. We're going to use this to highlight good and bad events to the user. For example, when a plugin completes without errors, we display that with a green font. Similarly, we will print encountered errors in red. The colorama module can be installed with pip:</p>
<pre><strong>pip install colorama==0.4.1 </strong> </pre>
<p>Traditionally, printing colored text to the Terminal is achieved by a series of escape characters on Linux or macOS systems. This, however, won't work for Windows operating systems. The following are examples of ANSI escape characters being used to create colored text in Linux or macOS Terminals:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-745 image-border" src="img/a30091c6-ff83-4ba5-9608-ddce5b4a343c.png" style="width:44.33em;height:10.08em;"/></p>
<p>The color format is the escape character, <kbd>\033</kbd>, followed by an open bracket and then the desired color code. We can change the background color in addition to the foreground color and even do both at the same time by separating the codes with a semicolon. The color code, <kbd>31m</kbd>, sets the foreground text to red. The color code, <kbd>47m</kbd>, sets the background to white. Notice in the second example, in the preceding screenshot, <kbd>m</kbd> designates the end of the color codes and should therefore only follow the final color code.</p>
<p>We can use the <kbd>colorama</kbd> and <kbd>call</kbd> built-in variables, which are aliases for the desired ANSI codes. This makes our code more readable and best of all works with Windows Command Prompts after calling <kbd>colorama.init()</kbd> at the beginning of your script:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-746 image-border" src="img/9233c4f6-e48e-4673-b06d-289ae393dcb2.png" style="width:43.33em;height:12.58em;"/></p>
<p>The <kbd>colorama</kbd> module has three main formatting options: <kbd>Fore</kbd>, <kbd>Back</kbd>, and <kbd>Style</kbd>. These allow us to make changes to the foreground or background text color and its style, respectively. The colors available for the foreground and background include: black, red, green, yellow, blue, magenta, cyan, and white.</p>
<p>It's possible to change other text properties using ANSI escape characters, such as if we wanted to make the text dimmer or brighter. ANSI color codes and other information on the <kbd>colorama</kbd> library is available at  <a href="https://pypi.python.org/pypi/colorama">https://pypi.python.org/pypi/colorama</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">FIGlet</h1>
                
            
            
                
<p>FIGlet, and its Python extension, <kbd>pyfiglet</kbd> (version 0.8.post0), is a simple way of generating ASCII art. All we need to do is supply FIGlet with a string of our choice and a font style, which dictates the design of our text. We'll use this module to print the title of our framework at the beginning of the program's execution to give it some personality. We can use pip to install pyfiglet:</p>
<pre><strong>pip install pyfiglet==0.8.post0</strong></pre>
<p>To use FIGlet, we need to create a FIGlet object and specify the type of font we would like to use. We then call the object's <kbd>renderText</kbd> method, along with the string to style. A full list of fonts is available at <a href="http://www.figlet.org/examples.html">http://www.figlet.org/examples.html</a>:</p>
<pre><strong>&gt;&gt;&gt; from pyfiglet import Figlet</strong> <br/><strong>&gt;&gt;&gt; f = Figlet(font='banner')</strong> <br/><strong>&gt;&gt;&gt; print(f.renderText('Forensics'))</strong> 
<strong>#######                                                    </strong> 
<strong>#        ####  #####  ###### #    #  ####  #  ####   ####  </strong> 
<strong>#       #    # #    # #      ##   # #      # #    # #      </strong> 
<strong>#####   #    # #    # #####  # #  #  ####  # #       ####  </strong> 
<strong>#       #    # #####  #      #  # #      # # #           # </strong> 
<strong>#       #    # #   #  #      #   ## #    # # #    # #    # </strong> 
<strong>#        ####  #    # ###### #    #  ####  #  ####   #### </strong> </pre>
<p>With the necessary third-party modules introduced, let's start walking through the framework code itself.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Exploring the framework – framework.py</h1>
                
            
            
                
<p>Our framework takes some input directory, recursively indexes all of its files, runs a series of plugins to identify forensic artifacts, and then writes a series of reports into a specified output directory. The idea is that the examiner could mount a <kbd>.E01</kbd> or <kbd>.dd</kbd> file using a tool such as FTK Imager and then run the framework against the mounted directory.</p>
<p>The layout of a framework is an important first step in achieving a simplistic design. We recommend placing writers and plugins in appropriately labeled subdirectories under the framework controller. Our framework is laid out in the following manner:</p>
<pre>  |-- framework.py <br/>  |-- requirements.txt <br/>  |-- plugins <br/>      |-- __init__.py <br/>      |-- exif.py <br/>      |-- id3.py <br/>      |-- office.py <br/>      |-- pst_indexer.py <br/>      |-- setupapi.py <br/>      |-- userassist.py <br/>      |-- wal_crawler.py <br/>      |-- helper <br/>          |-- __init__.py <br/>          |-- utility.py <br/>          |-- usb_lookup.py <br/>  |-- writers <br/>      |-- __init__.py <br/>      |-- csv_writer.py <br/>      |-- xlsx_writer.py <br/>      |-- kml_writer.py </pre>
<p>Our <kbd>framework.py</kbd> script contains the main logic of our framework-handling the input and output values for all of our plugins. The <kbd>requirements.txt</kbd> file contains one third-party module on each line used by the framework. In this format, we can use this file with <kbd>pip</kbd> to install all of the listed modules. <kbd>pip</kbd> will attempts to install the latest version of the module unless a version is specified immediately following the module name and two equal to signs (that is, <kbd>colorama==0.4.1</kbd>). We can install third-party modules from our <kbd>requirements.txt</kbd> file using the following code:</p>
<pre><strong>pip install -r requirements.txt</strong> </pre>
<p>The plugins and writers are stored in their own respective directories with an <kbd>__init__.py</kbd> file to ensure that Python can find the directory. Within the plugins directory are seven initial plugins our framework will support. The plugins we'll include are as follows:</p>
<ul>
<li>The EXIF, ID3, and Office embedded metadata parsers from <a href="5844a835-314a-474b-9c28-60880408629d.xhtml" target="_blank">Chapter 8</a>, <em>The Media Age</em></li>
<li>The PST parser from <a href="90da6f73-2678-4460-8cfb-b388db40a6c3.xhtml" target="_blank">Chapter 11</a>, <em>Parsing Outlook PST Containers</em></li>
<li>The Setupapi parser from <a href="f5b49c85-69ce-4f37-b62d-7f2934e8d30e.xhtml" target="_blank">Chapter 3</a>, <em>Parsing Text Files</em></li>
<li>The UserAssist parser from <a href="59414e87-5820-4942-bd47-aba762dd9f14.xhtml" target="_blank">Chapter 6</a>, <em>Extracting Artifacts from Binary Files</em></li>
<li>The WAL file parser from <a href="f4d95d98-e057-4ad3-b737-4fd72a810e27.xhtml" target="_blank">Chapter 12</a>, <em>Recovering Transient Database Records</em></li>
</ul>
<p>There's also a <kbd>helper</kbd> directory containing some helper scripts that are required by some of the plugins. There are currently three supported output formats for our framework: CSV, XLSX, and KML. Only the <kbd>exif</kbd> plugin will make use of <kbd>kml_writer</kbd> to create a Google Earth map with plotted EXIF GPS data, as we saw in <a href="5844a835-314a-474b-9c28-60880408629d.xhtml" target="_blank">Chapter 8</a>, <em>The Media Age</em>.</p>
<p>Now that we understand the how, why, and layout of our framework, let's dig into some code. On lines 2 through 11, we import the modules we plan to use. Note that this is only the list of modules that are required in this immediate script. It doesn't include the dependencies required by the various plugins. Plugin-specific imports are made in their respective scripts.</p>
<p>Most of these imports should look familiar from the previous chapters, with the exception of the new additions of <kbd>colorama</kbd> and <kbd>pyfiglet</kbd>. On lines 7 and 8, we import our plugins and writers subdirectories, which contain the scripts for our plugins and writers. The <kbd>colorama.init()</kbd> call on line 13 is a prerequisite that allows us to print colored text to the Windows Command Prompt:</p>
<pre>002 from __future__ import print_function<br/>003 import os<br/>004 import sys<br/>005 import logging<br/>006 import argparse<br/>007 import plugins<br/>008 import writers<br/>009 import colorama<br/>010 from datetime import datetime<br/>011 from pyfiglet import Figlet<br/>012 <br/>013 colorama.init()</pre>
<p>On line 49, we define our <kbd>Framework</kbd> class. This class will contain a variety of methods, all of which handle the initialization and execution of the framework. The <kbd>run()</kbd> method acts as our typical main function and calls the <kbd>_list_files()</kbd> and <kbd>_run_plugins()</kbd> methods. The <kbd>_list_files()</kbd> method walks through files in the user-supplied directory and, based upon the name or extension, adds the file to a plugin-specific processing list. Then, the <kbd>_run_plugins()</kbd> method takes these lists and executes each plugin, stores the results, and calls the appropriate writer:</p>
<pre>049 class Framework(object): <br/>... <br/>051     def __init__(): <br/>... <br/>061     def run(): <br/>... <br/>074     def _list_files(): <br/>... <br/>115     def _run_plugins(): </pre>
<p>Within the <kbd>Framework</kbd> class are two subclasses: <kbd>Plugin</kbd> and <kbd>Writer</kbd>. The <kbd>Plugin</kbd> class is responsible for actually running the plugin, logging when it completes, and sending data to be written. The <kbd>run()</kbd> method repeatedly executes each function for every file in the plugin's processing list. It appends the returned data to a list, mapped to the key in a dictionary. This dictionary also stores the desired field names for the spreadsheet. The <kbd>write()</kbd> method creates the plugin specific output directory and, based on the type of output specified, makes appropriate calls to the <kbd>Writer</kbd> class:</p>
<pre>207     class Plugin(object): <br/>... <br/>209         def __init__(): <br/>... <br/>215         def run(): <br/>... <br/>236         def write(): </pre>
<p>The <kbd>Writer</kbd> class is the simplest class of the three. Its <kbd>run()</kbd> method simply executes the desired writers with the correct input:</p>
<pre>258     class Writer(object): <br/>... <br/>260         def __init__(): <br/>... <br/>271         def run(): </pre>
<p>As with all of our scripts, we use <kbd>argparse</kbd> to handle command-line switches. On lines 285 and 287, we create two positional arguments for our input and output directories. The two optional arguments on lines 288 and 290 specify XLSX output and the desired log path, respectively:</p>
<pre>279 if __name__ == '__main__':<br/>280 <br/>281     parser = argparse.ArgumentParser(description=__description__,<br/>282                                 epilog='Developed by ' +<br/>283                                 __author__ + ' on ' +<br/>284                                 __date__)<br/>285     parser.add_argument('INPUT_DIR',<br/>286         help='Base directory to process.')<br/>287     parser.add_argument('OUTPUT_DIR', help='Output directory.')<br/>288     parser.add_argument('-x', help='Excel output (Default CSV)',<br/>289         action='store_true')<br/>290     parser.add_argument('-l',<br/>291         help='File path and name of log file.')<br/>292     args = parser.parse_args()</pre>
<p>We can see our first use of the <kbd>colorama</kbd> library on line 297. If the supplied input and output directories are files, we print a red error message to the console. For the rest of our framework, we use error messages displayed in red text and success messages in green:</p>
<pre>294     if(os.path.isfile(args.INPUT_DIR) or<br/>295             os.path.isfile(args.OUTPUT_DIR)):<br/>296         msg = 'Input and Output arguments must be directories.'<br/>297         print(colorama.Fore.RED + '[-]', msg)<br/>298         sys.exit(1)</pre>
<p>On line 300, we check whether the optional directory path was supplied for the log file. If so, we create these directories (if they don't exist), and store the filename for the log in the <kbd>log_path</kbd> variable:</p>
<pre>300     if args.l:<br/>301         if not os.path.exists(args.l):<br/>302             os.makedirs(args.l) # create log directory path<br/>303         log_path = os.path.join(args.l, 'framework.log')<br/>304     else:<br/>305         log_path = 'framework.log'</pre>
<p>On lines 307 and 309, we create our <kbd>Framework</kbd> object and then call its <kbd>run()</kbd> method. We pass the following arguments into the <kbd>Framework</kbd> constructor to instantiate the object: <kbd>INPUT_DIR</kbd>, <kbd>OUTPUT_DIR</kbd>, <kbd>log_path</kbd>, and <kbd>excel</kbd>. In the next section, we inspect the <kbd>Framework</kbd> class in greater detail:</p>
<pre>307     framework = Framework(args.INPUT_DIR, args.OUTPUT_DIR,<br/>308     log_path, excel=args.x)<br/>309     framework.run()</pre>
<p>The following flow chart highlights how the different methods in the <kbd>framework.py</kbd> script interact. Keep in mind that this flow chart only shows interactions within the immediate script and doesn't account for the various plugin, writer, and utility scripts:</p>
<div><img src="img/97d8fbb0-fb28-4318-9f48-7421e0049564.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Exploring the Framework object</h1>
                
            
            
                
<p>We developed our framework with an object-oriented programming design in mind. This allows us to create compartmentalized and reusable objects. Within our <kbd>Framework</kbd> object are the <kbd>Plugin</kbd> and <kbd>Writer</kbd> objects, which we explored in the proceeding sections. The <kbd>Framework</kbd> class is defined on line 49 and extends the <kbd>object</kbd> class. In Python 2.X, inheriting from an object that replaces the previous tradition of inheriting nothing has become standard in Python 3.X:</p>
<pre>049 class Framework(object): </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Understanding the Framework __init__() constructor</h1>
                
            
            
                
<p>The <kbd>__init__()</kbd> method for the framework is defined on line 51. In this constructor, we assign the arguments passed to the constructor as instance variables. We also configure the logging module on line 55. Let's look at the <kbd>run()</kbd> method, which, as we saw, is called immediately after the <kbd>Framework</kbd> object is instantiated:</p>
<pre>051     def __init__(self, input_directory, output_directory, log,<br/>052     **kwargs):<br/>053         self.input = input_directory<br/>054         self.output = output_directory<br/>055         logging.basicConfig(filename=log, level=logging.DEBUG,<br/>056                         format=('%(asctime)s | %(levelname)s | '<br/>057                         '%(message)s'), filemode='a')<br/>058         self.log = logging.getLogger(log)<br/>059         self.kwargs = kwargs</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating the Framework run() method</h1>
                
            
            
                
<p>The <kbd>run()</kbd> method, defined on line 61, executes the entire logic of our framework in a few lines of code. Lines 62 through 68 simply print and log startup information for debugging purposes. Notice the use of <kbd>Figlet</kbd> on lines 65 and 66 to print our framework's title to the console:</p>
<pre>061     def run(self):<br/>062         msg = 'Initializing framework'<br/>063         print('[+]', msg)<br/>064         self.log.info(msg)<br/>065         f = Figlet(font='doom')<br/>066         print(f.renderText('Framework'))<br/>067         self.log.debug('System ' + sys.platform)<br/>068         self.log.debug('Version ' + sys.version) </pre>
<p>On line 69, we check to see whether the output directory exists. If it doesn't, we create it using the <kbd>os.makedirs()</kbd> method. Finally, on lines 71 and 72, we call the <kbd>_list_files()</kbd> and <kbd>_run_plugins()</kbd> methods to index the input directory files and run our plugins against them:</p>
<pre>069         if not os.path.exists(self.output):<br/>070             os.makedirs(self.output)<br/>071         self._list_files()<br/>072         self._run_plugins() </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Iterating through files with the Framework _list_files() method</h1>
                
            
            
                
<p>The <kbd>_list_files()</kbd> method is used to iterate through each file in the input directory recursively. It stores the files into a processing list for a plugin based on the file's name or extension. One drawback to this approach is that we're relying on file extensions to be correct rather than using the file signatures themselves. We could implement this functionality into the framework by using struct to check each file's signature, as we've done in the previous chapters.</p>
<p>Notice that the <kbd>_list_files()</kbd> method has a single leading underscore. This is Python's way of declaring an internal method. What it means here is that we're declaring that the <kbd>_list_files()</kbd> method shouldn't be imported and, generally, shouldn't be directly called by the user. For instance, we should not call <kbd>Framework</kbd>. <kbd>_list_files()</kbd> on our <kbd>Framework</kbd> object after we instantiated it on line 309. Instead, we can call the <kbd>run()</kbd> method, which in turn calls the <kbd>_list_files()</kbd> method.</p>
<p>The <kbd>_list_files()</kbd> method is defined on line 74 and prints and logs the current execution status. On lines 79 through 85, we create a series of lists specific to each plugin. These lists are used to store any file identified as compatible with a plugin for later processing:</p>
<pre>074     def _list_files(self):<br/>075         msg = 'Indexing {}'.format(self.input)<br/>076         print('[+]', msg)<br/>077         logging.info(msg)<br/>078 <br/>079         self.wal_files = []<br/>080         self.setupapi_files = []<br/>081         self.userassist_files = []<br/>082         self.exif_metadata = []<br/>083         self.office_metadata = []<br/>084         self.id3_metadata = []<br/>085         self.pst_files = []</pre>
<p>Starting on line 87, we use the <kbd>os.walk()</kbd> method that we used in the previous chapters to iterate over the input directory. For each file, we create two variables, one for the name of the current file and another for the extension of the current file:</p>
<pre>087         for root, subdir, files in os.walk(self.input,<br/>088         topdown=True):<br/>089             for file_name in files:<br/>090                 current_file = os.path.join(root, file_name)<br/>091                 if not os.path.isfile(current_file):<br/>092                     logging.warning((u'Could not parse file {}...'<br/>093                     ' Skipping...').format((current_file)))<br/>094                     continue<br/>095                 ext = os.path.splitext(current_file)[1].lower()</pre>
<p>Using our <kbd>current_file</kbd> and <kbd>ext</kbd> variables, we use a series of conditional statements to identify files for our plugins. For example, on line 96, we check whether the file contains <kbd>ntuser.dat</kbd> in its name as this most likely identifies it as a user's registry hive and is appended to our <kbd>userassist_files</kbd> list.</p>
<p>Similarly, on line 100, anything ending in <kbd>.jpeg</kbd> or <kbd>.jpg</kbd> is most likely a photo with EXIF embedded metadata and is appended to our <kbd>exif_metadata</kbd> list. If the current file doesn't meet any of our requirements, then we can't parse it with our current plugins, and we use <kbd>continue</kbd> to start the next loop:</p>
<pre>096                 if current_file.lower().endswith('ntuser.dat'):<br/>097                     self.userassist_files.append(current_file)<br/>098                 elif 'setupapi.dev.log' in current_file.lower():<br/>099                     self.setupapi_files.append(current_file)<br/>100                 elif ext == '.jpeg' or ext == '.jpg':<br/>101                     self.exif_metadata.append(current_file)<br/>102                 elif(ext == '.docx' or<br/>103                         ext == '.pptx' or<br/>104                         ext == '.xlsx'):<br/>105                     self.office_metadata.append(current_file)<br/>106                 elif ext == '.mp3':<br/>107                     self.id3_metadata.append(current_file)<br/>108                 elif ext == '.pst' or ext == '.ost':<br/>109                     self.pst_files.append(current_file)<br/>110                 elif ext.endswith('-wal'):<br/>111                     self.wal_files.append(current_file)<br/>112                 else:<br/>113                     continue</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Developing the Framework _run_plugins() method</h1>
                
            
            
                
<p>The <kbd>_run_plugins()</kbd> is another internal method and handles the logic for calling each plugin and then sending the returned results to the appropriate writer. There are two twists in handling each plugin. We highlight these different twists for two plugins. We won't cover the other five plugins to cut down on explaining the same code.</p>
<p>The first plugin example is the <kbd>wal_crawler</kbd> plugin. On line 117, we check whether we need to create a <kbd>Plugin</kbd> object for the <kbd>wal_crawler</kbd> at all because if the <kbd>wal_files</kbd> list is empty, there'll be nothing to run the plugin against. If it isn't empty, we create a <kbd>Plugin</kbd> object on line 118.</p>
<p>Next, we create <kbd>wal_output</kbd>, which stores our plugin's output directory. On line 121, we call the <kbd>run()</kbd> method of the <kbd>Plugin</kbd> class and then, based on whether the <kbd>excel</kbd> output option is specified, <kbd>write()</kbd> the results of the plugin, passing along the <kbd>excel</kbd> keyword argument, if necessary.</p>
<p>Recall that the <kbd>wal_crawler</kbd> script returns a list of dictionaries where each dictionary contains a cells worth of data. When we call the plugin, we put the results in yet another list. By default, the writers expect just a list of dictionaries to iterate over and write the appropriate report. Because we append a list of dictionaries to yet another list, we need to tell the writer that it needs another <kbd>for</kbd> loop to access the list of dictionaries. We do this by passing the recursion keyword argument to the plugin's <kbd>write()</kbd> method. We set the <kbd>recursion</kbd> value to <kbd>1</kbd>,  to mark it as enabled:</p>
<pre>115     def _run_plugins(self):<br/>116         # Run Wal Crawler<br/>117         if len(self.wal_files) &gt; 0:<br/>118             wal_plugin = Framework.Plugin('wal_crawler',<br/>119             self.wal_files, self.log)<br/>120             wal_output = os.path.join(self.output, 'wal')<br/>121             wal_plugin.run(plugins.wal_crawler.main)<br/>122             if self.kwargs['excel'] is True:<br/>123                 wal_plugin.write(wal_output, recursion=1, excel=1)<br/>124             else:<br/>125                 wal_plugin.write(wal_output, recursion=1)</pre>
<p>Unlike in the previous example, our ID3 metadata script returns a single dictionary, which is appended to a list. In these scenarios, we don't need to specify the <kbd>recursion</kbd> keyword argument, as seen on lines 190 and 193. Beyond this single difference, the plugin is handled in the same fashion as the previous plugin.</p>
<p>Remember one goal of our framework is to be able to disable or add a new plugin in as few lines of code as possible.</p>
<p>This increases the simplicity of the framework, making it far easier to maintain. We've tried to maintain that here by keeping the logic consistent and using keyword arguments to handle slight variations:</p>
<pre>182         # Run ID3 metadata parser<br/>183         if len(self.id3_metadata) &gt; 0:<br/>184             id3_metadata_plugin = Framework.Plugin('id3_metadata',<br/>185             self.id3_metadata, self.log)<br/>186             id3_metadata_output = os.path.join(self.output,<br/>187                 'metadata')<br/>188             id3_metadata_plugin.run(plugins.id3.main)<br/>189             if self.kwargs['excel'] is True:<br/>190                 id3_metadata_plugin.write(id3_metadata_output,<br/>191                     excel=1)<br/>192             else:<br/>193                 id3_metadata_plugin.write(id3_metadata_output)</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Exploring the Plugin object</h1>
                
            
            
                
<p>On line 207, we have the beginning of the <kbd>Plugin</kbd> subclass. This class contains the <kbd>run()</kbd> and <kbd>write()</kbd> methods, which are used to handle the execution of each plugin as well as the calls to the writers:</p>
<pre>207     class Plugin(object): </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Understanding the Plugin __init__() constructor</h1>
                
            
            
                
<p>The <kbd>Plugin</kbd> constructor method is fairly straightforward. We create instance variables for the plugin name, the files to process, the log, and a dictionary containing the results of the plugin. The results dictionary contains a data list, which stores the actual results returned from each plugin call. The headers key will eventually have a list storing the field names to use in the writers:</p>
<pre>209         def __init__(self, plugin, files, log):<br/>210             self.plugin = plugin<br/>211             self.files = files<br/>212             self.log = log<br/>213             self.results = {'data': [], 'headers': None} </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Working with the Plugin run() method</h1>
                
            
            
                
<p>The <kbd>run()</kbd> method defined on line 215 is responsible for executing the plugin against each file stored in the plugin's list. In addition, this method prints out various status messages pertaining to the execution of the plugin.</p>
<p>The function argument passed into the <kbd>run()</kbd> method is the name of the entry-point method in the plugin. We call this entry-point for each file in the plugin's file list. For example, the <kbd>wal_crawler</kbd> plugin's entry-point method is <kbd>plugins.wal_crawler.main</kbd>:</p>
<pre>215         def run(self, function):<br/>216             msg = 'Executing {} plugin'.format(self.plugin)<br/>217             print(colorama.Fore.RESET + '[+]', msg)<br/>218             self.log.info(msg)</pre>
<p>On line 220, we begin to iterate through each file in the plugin's file list. On line 222, we call the function variable and supply it with the file to process. This restricts all of our plugins to comply with a single file as its input. Some of the modifications we made to our existing plugins involved modifying their required arguments to work within the bounds of the framework. For example, in the previous chapters, we may have passed in an output file or directory as one of the script's arguments. However, now, the writers, a separate part of the framework, handle the output and so the plugins only need to focus on processing and returning the data to the framework.</p>
<p>Notice that the function call is wrapped around try and except. In the plugins themselves, you can see that we raise <kbd>TypeError</kbd> when we encounter an error in the plugin; in the case of an error, the plugin logs the actual error while the framework continues to process the next file.</p>
<p>On lines 223 and 224, we append the returned results from the plugin to the data list and set the headers for the plugin. The returned headers list is a constant list of field names that's set whenever the plugin returns successfully:</p>
<pre>220             for f in self.files:<br/>221                 try:<br/>222                     data, headers = function(f)<br/>223                     self.results['data'].append(data)<br/>224                     self.results['headers'] = headers<br/>225 <br/>226                 except TypeError:<br/>227                     self.log.error(('Issue processing {}. '<br/>228                         'Skipping...').format(f))<br/>229                     continue</pre>
<p>Finally, on lines 231 through 234, we print out and log the successful completion of the plugin, including the current time to the user:</p>
<pre>231             msg = 'Plugin {} completed at {}'.format(self.plugin,<br/>232             datetime.now().strftime('%m/%d/%Y %H:%M:%S'))<br/>233             print(colorama.Fore.GREEN + '[*]', msg)<br/>234             self.log.info(msg)</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Handling output with the Plugin write() method</h1>
                
            
            
                
<p>The <kbd>write()</kbd> method is first defined on line 236. This method creates the plugin-specific output directory and call the appropriate writer to create the plugin report. On lines 241 and 242, after printing out a status message to the user, we create the plugin output directory if it doesn't already exist:</p>
<pre>236         def write(self, output, **kwargs):<br/>237             msg = 'Writing results of {} plugin'.format(<br/>238             self.plugin)<br/>239             print(colorama.Fore.RESET + '[+]', msg)<br/>240             self.log.info(msg)<br/>241             if not os.path.exists(output):<br/>242                 os.makedirs(output)</pre>
<p>On line 243, we check to see whether the <kbd>excel</kbd> keyword argument was specified in the function call. If it was, we call <kbd>xlsx_writer</kbd> and pass the output directory, the desired filename, field names, and the data to write.</p>
<p>If the <kbd>excel</kbd> keyword argument isn't supplied, the default <kbd>csv_writer</kbd> is called instead. This function takes the same arguments as <kbd>xlsx_writer</kbd>. On line 253, we check whether the plugin name is <kbd>exif_metadata</kbd>. If so, we call <kbd>kml_writer</kbd> to plot the Google Earth GPS data:</p>
<pre>243             if 'excel' in kwargs.keys():<br/>244                 Framework.Writer(writers.xlsx_writer.writer,<br/>245                     output, self.plugin + '.xlsx',<br/>246                     self.results['headers'],<br/>247                     self.results['data'], **kwargs)<br/>248             else:<br/>249                 Framework.Writer(writers.csv_writer.writer,<br/>250                     output, self.plugin + '.csv',<br/>251                     self.results['headers'],<br/>252                     self.results['data'], **kwargs)<br/>253             if self.plugin == 'exif_metadata':<br/>254                 Framework.Writer(writers.kml_writer.writer,<br/>255                     output, '', self.plugin + '.kml',<br/>256                     self.results['data'])</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Exploring the Writer object</h1>
                
            
            
                
<p>The <kbd>Writer</kbd> object is defined on line 258. This class is responsible for creating the report for each plugin. The class has one main method, <kbd>run()</kbd>, which simply calls the writer that was described in the <kbd>plugin.write</kbd> method:</p>
<pre>258     class Writer(object): </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Understanding the Writer __init__() constructor</h1>
                
            
            
                
<p>The constructor method instantiates session variables, including the output filename of the report, the header, and the data to be written. If the <kbd>recursion</kbd> keyword argument is present, we set the session variable before calling the <kbd>run()</kbd> method:</p>
<pre>260         def __init__(self, writer, output, name, header, data,<br/>261         **kwargs):<br/>262             self.writer = writer<br/>263             self.output = os.path.join(output, name)<br/>264             self.header = header<br/>265             self.data = data<br/>266             self.recursion = None<br/>267             if 'recursion' in kwargs.keys():<br/>268                 self.recursion = kwargs['recursion']<br/>269             self.run()</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Understanding the Writer run() method</h1>
                
            
            
                
<p>The <kbd>run()</kbd> method is very straightforward. Based on whether recursion was specified, we call the specified writer, passing along the <kbd>recursion</kbd> keyword argument:</p>
<pre>271         def run(self):<br/>272             if self.recursion:<br/>273                 self.writer(self.output, self.header, self.data,<br/>274                     recursion=self.recursion)<br/>275             else:<br/>276                 self.writer(self.output, self.header, self.data)</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Our Final CSV writer – csv_writer.py</h1>
                
            
            
                
<p>Each writer essentially works in the same manner. Let's briefly discuss the <kbd>csv_writer</kbd> method before discussing the more complex <kbd>xlsx_writer</kbd> script. Depending on whether the framework is run with Python 2.X or 3.X, we import the native <kbd>csv</kbd> or <kbd>unicodecsv</kbd> modules to handle Unicode strings. The <kbd>unicodecsv</kbd> module was first introduced in <a href="a4ae250a-8aa8-49b9-8fd6-0cac51975f11.xhtml" target="_blank">Chapter 5</a>, <em>Databases in Python</em>:</p>
<pre>001 from __future__ import print_function<br/>002 import sys<br/>003 import os<br/>004 if sys.version_info[0] == 2:<br/>005     import unicodecsv as csv<br/>006 elif sys.version_info[0] == 3:<br/>007     import csv </pre>
<p>Our writer is very simple. On line 61, we create a <kbd>csv.DictWriter</kbd> object and pass it the output filename and headers list. As always, we indicate to the writer to ignore the case where they are keys that are not specified in the supplied headers:</p>
<pre>038 def writer(output, headers, output_data, **kwargs):<br/>039     """<br/>040     The writer function uses the csv.DictWriter module to write<br/>041     list(s) of dictionaries. The DictWriter can take a fieldnames<br/>042     argument, as a list, which represents the desired order of<br/>043     columns.<br/>044     :param output: The name of the output CSV.<br/>045     :param headers: A list of keys in the dictionary that<br/>046     represent the desired order of columns in the output.<br/>047     :param output_data: The list of dictionaries containing<br/>048     embedded metadata.<br/>049     :return: None<br/>050     """<br/>051 <br/>052     if sys.version_info[0] == 2:<br/>053         csvfile = open(output, "wb")<br/>054     elif sys.version_info[0] == 3:<br/>055         csvfile = open(output, "w", newline='',<br/>056             encoding='utf-8')<br/>057 <br/>058     with csvfile:<br/>059         # We use DictWriter instead of writer to write<br/>060         # dictionaries to CSV.<br/>061         w = csv.DictWriter(csvfile, fieldnames=headers,<br/>062             extrasaction='ignore')</pre>
<p>With the <kbd>DictWriter</kbd> object created, we can use the built-in <kbd>writerheader()</kbd> method to write our field names as the first row of the spreadsheet. Notice that we wrap this in a try and except, something we haven't done in the past. Imagine a scenario where there's only one file for a plugin to process and it encounters and error and returns prematurely. In this case, the headers list will be none, which will cause an error. This last check allows us to exit writing invalid output files for this scenario:</p>
<pre>064         # Writerheader writes the header based on the supplied<br/>065         # headers object<br/>066         try:<br/>067             w.writeheader()<br/>068         except TypeError:<br/>069             print(('[-] Received empty headers...\n'<br/>070                 '[-] Skipping writing output.'))<br/>071             return</pre>
<p>Next, on line 73, if the <kbd>recursion</kbd> keyword argument was supplied, we use two <kbd>for</kbd> loops before calling the <kbd>writerow</kbd> method on the dictionaries. Otherwise, on line 79, we only need to use one <kbd>for</kbd> loop to access the data to write:</p>
<pre>073         if 'recursion' in kwargs.keys():<br/>074             for l in output_data:<br/>075                 for data in l:<br/>076                     if data:<br/>077                         w.writerow(data)<br/>078         else:<br/>079             for data in output_data:<br/>080                 if data:<br/>081                     w.writerow(data)</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">The writer – xlsx_writer.py</h1>
                
            
            
                
<p>The <kbd>xlsx_writer</kbd> function is a slightly modified version of <kbd>xlsx_writer</kbd>, which we created in <a href="59414e87-5820-4942-bd47-aba762dd9f14.xhtml" target="_blank">Chapter 6</a>, <em>Extracting Artifacts from Binary Files</em>. We use the same <kbd>xlsxwriter</kbd> third-party module to handle the excel output. On line 32, we use list comprehension to create a list of capitalized alphabetical characters from <kbd>A</kbd> to <kbd>Z</kbd>. We're going to use this list to designate the column letter based on the supplied headers length. This method works as long as there are less than 26 field names, which for the current set of plugins is true:</p>
<pre>001 from __future__ import print_function<br/>002 import xlsxwriter<br/>...<br/>032 ALPHABET = [chr(i) for i in range(ord('A'), ord('Z') + 1)]</pre>
<p>On line 44, we create the <kbd>xlsxwriter</kbd> workbook and supply the output filename to save it as. Before going any further, we check whether the supplied headers are equal to none. This check is necessary, just as in <kbd>csv_writer</kbd>, to avoid writing invalid data from a bad call to the writer. On line 52, we set <kbd>title_length</kbd> equal to the letter that the right-most column will be, in case there are more than 26 columns. We've currently set the right-most value to be <kbd>Z</kbd>:</p>
<pre>035 def writer(output, headers, output_data, **kwargs):<br/>036     """<br/>037     The writer function writes excel output for the framework<br/>038     :param output: the output filename for the excel spreadsheet<br/>039     :param headers: the name of the spreadsheet columns<br/>040     :param output_data: the data to be written to the excel<br/>041     spreadsheet<br/>042     :return: Nothing<br/>043     """<br/>044     wb = xlsxwriter.Workbook(output)<br/>045 <br/>046     if headers is None:<br/>047         print('[-] Received empty headers... \n'<br/>048             '[-] Skipping writing output.')<br/>049         return<br/>050 <br/>051     if len(headers) &lt;= 26:<br/>052         title_length = ALPHABET[len(headers) - 1]<br/>053     else:<br/>054         title_length = 'Z'</pre>
<p>Next, on line 56, we create our worksheet. In a similar fashion to the <kbd>csv_writer</kbd> function, if recursion is specified, we loop through the list, adding a worksheet for each additional list to prevent them from writing over each other. We then use list comprehension to quickly order the dictionary values based on the order of the field names. In <kbd>csv_writer</kbd>, the <kbd>writerow</kbd> method from the <kbd>DictWriter</kbd> object orders the data automatically. For <kbd>xlsx_writer</kbd>, we need to use list comprehension to recreate that same effect:</p>
<pre>056     ws = add_worksheet(wb, title_length)<br/>057 <br/>058     if 'recursion' in kwargs.keys():<br/>059         for i, data in enumerate(output_data):<br/>060             if i &gt; 0:<br/>061                 ws = add_worksheet(wb, title_length)<br/>062             cell_length = len(data)<br/>063             tmp = []<br/>064             for dictionary in data:<br/>065                 tmp.append(<br/>066                 [str(dictionary[x]) if x in dictionary.keys() else '' for x in headers]<br/>067                 )</pre>
<p>On line 69, we create a table from <kbd>A3</kbd> to <kbd>XY</kbd>, where <kbd>X</kbd> is the alphabet character representing the length of the field names list and <kbd>Y</kbd> is the length of the <kbd>output_data</kbd> list. For example, if we have a dataset that has six field names and 10 entries, we want our table to span from <kbd>A3</kbd> to <kbd>F13</kbd>. In addition, we pass along the ordered data and specify each column using list comprehension once again to specify a dictionary with one key-value pair for each header:</p>
<pre>069             ws.add_table(<br/>070                 'A3:' + title_length + str(3 + cell_length),<br/>071                 {'data': tmp,<br/>072                 'columns': [{'header': x} for x in headers]})</pre>
<p>On line 74, we handle the scenario where we don't supply the <kbd>recursion</kbd> keyword argument. In this case, we handle the same execution minus the additional <kbd>for</kbd> loop. Lastly, on line 84, we close the workbook:</p>
<pre>074     else:<br/>075         cell_length = len(output_data)<br/>076         tmp = []<br/>077         for data in output_data:<br/>078             tmp.append([str(data[x]) if x in data.keys() else '' for x in headers])<br/>079         ws.add_table(<br/>080             'A3:' + title_length + str(3 + cell_length),<br/>081             {'data': tmp,<br/>082             'columns': [{'header': x} for x in headers]})<br/>083 <br/>084     wb.close()</pre>
<p>The <kbd>add_worksheet()</kbd> method is called on lines 56 and 61. This function is used to create the worksheet and writes the first two rows of the spreadsheet. On line 96, we create the <kbd>title_format</kbd> style, which contains the text properties we want for our two title rows. On lines 101 and 103, we create both of our title rows. Currently, the values of these title rows are hardcoded but could be programmed into the framework by adding them as optional switches in <kbd>argparse</kbd>:</p>
<pre>087 def add_worksheet(wb, length, name=None):<br/>088     """<br/>089     The add_worksheet function creates a new formatted worksheet<br/>090     in the workbook<br/>091     :param wb: The workbook object<br/>092     :param length: The range of rows to merge<br/>093     :param name: The name of the worksheet<br/>094     :return: ws, the worksheet<br/>095     """<br/>096     title_format = wb.add_format({'bold': True,<br/>097     'font_color': 'black', 'bg_color': 'white', 'font_size': 30,<br/>098     'font_name': 'Arial', 'align': 'center'})<br/>099     ws = wb.add_worksheet(name)<br/>100 <br/>101     ws.merge_range('A1:' + length + '1', 'XYZ Corp',<br/>102         title_format)<br/>103     ws.merge_range('A2:' + length + '2', 'Case ####',<br/>104         title_format)<br/>105     return ws </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Changes made to plugins</h1>
                
            
            
                
<p>We've discussed the framework, its subclasses, and the two main writer scripts. What about the changes we had to make to the plugin scripts from previous chapters? For the most part, their core functionality is unchanged. Modifications we made include removing printing and logging statements, deleting the <kbd>argparse</kbd> and log setup sections, and removing unnecessary functions such as the script's output writer (since the framework handles that).</p>
<p>Instead of walking through each plugin, we invite you to view the source files yourself and compare. You'll see that these files are mostly the same from the previous scripts. Keep in mind that when we originally wrote these scripts, we had it in the back of our minds that they would eventually be added to a framework. While the similarity between the framework and non-framework versions of the scripts was intentional, it was necessary to still make modifications to get everything working correctly.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Executing the framework</h1>
                
            
            
                
<p>To run the framework, at a minimum, we need to supply an input and output directory. Optionally, we can provide arguments for the desired log output path and enable XLSX output rather than the default CSV. The first example and the following screenshot highlight the minimum arguments to run the framework. The second example shows the additional switches we can call with our framework:</p>
<pre><strong>python framework.py /mnt/evidence ~/Desktop/framework_output</strong> 
<strong>python framework.py /mnt/evidence ~/Desktop/framework_output -l ~/Desktop/logs -x</strong> </pre>
<p>Upon running the framework, the user will be presented with a variety of output text detailing the execution status of the framework:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-724 image-border" src="img/61a8605b-78c2-4f27-b25a-6620e3231008.png" style="width:44.83em;height:29.08em;"/></p>
<p>As each plugin successfully processes, a report is generated in the plugin's output folder. We decided to organize the output by storing each plugin report in a separate folder to allow the examiner to drill down to their plugin of interest easily:</p>
<div><img src="img/6cbccc55-d556-47ca-8de1-5a0d4d095883.png" style="width:41.50em;height:18.83em;"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Additional challenges</h1>
                
            
            
                
<p>There are a lot of potential opportunities for improvement with our framework. Obviously, we could continue to add more plugins and writers to the framework. For example, while we have the beginning of USB device artifacts with the <kbd>Setupapi</kbd> plugin, it could be expanded by parsing various USB pertinent registry keys using the <kbd>Registry</kbd> module from <a href="59414e87-5820-4942-bd47-aba762dd9f14.xhtml" target="_blank">Chapter 6</a>, <em>Extracting Artifacts from Binary Files</em>. Alternatively, consider adding other scripts we've already created. For instance, it might be useful to generate an active file listing using the script from <a href="a4ae250a-8aa8-49b9-8fd6-0cac51975f11.xhtml" target="_blank">Chapter 5</a>, <em>Databases in Python</em>. This would allow us to monitor what files have been processed by the framework.</p>
<p>Additionally, adding novel sources of user activity artifacts, such as a prefetch parser would enhance the intrinsic value of the framework. The file format for prefetch files is described at <a href="http://forensicswiki.org/wiki/Windows_Prefetch_File_Format">http://forensicswiki.org/wiki/Windows_Prefetch_File_Format</a>. As with any binary file, we recommend using the struct module to parse the file.</p>
<p>Finally, for those looking for a challenge, consider adding <kbd>E01</kbd> and <kbd>dd</kbd> support by using <kbd>libewf</kbd> (<a href="https://github.com/libyal/libewf">https://github.com/libyal/libewf</a>) or <kbd>libtsk</kbd> (<a href="https://github.com/py4n6/pytsk">https://github.com/py4n6/pytsk</a>). This would get rid of the need to mount the image file before running the framework against it. This would be more of an undertaking and will likely require a rewrite of the framework. However, the harder the challenge, the more you'll get out of it once complete. </p>
<p>An example of this implementation is available in the Python Digital Forensics Cookbook by Packt, which is available at <a href="https://www.packtpub.com/networking-and-servers/python-digital-forensics-cookbook">https://www.packtpub.com/networking-and-servers/python-digital-forensics-cookbook</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>This is the final chapter, where we learned how to develop our own forensic framework using scripts we've previously built. This is the first step to building your very own automated forensic solution, greatly increasing your lunch break, or for the more serious, efficiency. We've learned how to balance code complexity with efficiency to develop a sustainable framework to help us to answer investigative questions. The code for this project can be downloaded from GitHub or Packt, as described in the <em>Preface</em>.</p>
<p>At the outset of this book, we wanted to teach investigators the advantages of Python by showing increasingly complex scripts. Throughout this process, we've introduced common techniques, best practices, and a myriad of first and third-party modules. We hope that, at this point, you're comfortable with developing your own scripts and understand the fundamentals of Python and are well on your way to becoming a forensic developer.</p>
<p>As we close out of this book, we wanted to list a few recommendations. If you haven't done so, please attempt to solve the various challenges. Some are fairly straightforward while others are more difficult, but in any case, they will help you develop your skills further. Additionally, go beyond just following along with the code provided with this book. Find a problem or task that's frequently encountered and script it from scratch. And, as always, ask friends, use the internet, read additional books, and collaborate with others to continue learning. Our capacity to learn is only waylaid by our lack of effort to pursue it.</p>


            

            
        
    </body></html>