- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Crash Course in Assembly and Programming Basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before diving deeper into the malware world, we need to have a complete understanding
    of the core of the machines we are analyzing malware on. For reverse engineering
    purposes, it makes sense to focus largely on the architecture and the **operating
    system** (**OS**) it supports. Of course, multiple devices and modules comprise
    a system, but it is mainly these two that define a set of tools and approaches
    that are used during the analysis. The physical representation of any architecture
    is a processor. A processor is like the heart of any smart device or computer
    in that it keeps it alive.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will cover the basics of the most widely used architectures,
    from the well-known x86 and x64 **Instruction Set Architectures** (**ISAs**) to
    solutions that power multiple mobile and **Internet of Things** (**IoT**) devices,
    which are often misused by malware families, such as Mirai. This will set the
    tone for your journey into malware analysis, as static analysis is impossible
    without understanding assembly instructions. Although modern decompilers are becoming
    better and better, they don’t exist for all platforms that are targeted by malware.
    Besides, they will probably never be able to handle obfuscated code. Don’t be
    daunted by the complexity of assembly; it just takes time to get used to it, and
    after a while, it becomes possible to read it like any other programming language.
    While this chapter provides a starting point, it always makes sense to deepen
    your knowledge by practicing and exploring further.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Basics of informatics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Architectures and their assembly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Becoming familiar with x86 (IA-32 and x64)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring ARM assembly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basics of MIPS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Covering the SuperH assembly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with SPARC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moving from assembly to high-level programming languages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basics of informatics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we dive deeper into the internals of the various architectures, now is
    a good time to revise the numeral systems, which will lay a foundation for understanding
    both data types and bitwise operations.
  prefs: []
  type: TYPE_NORMAL
- en: Numeral systems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In our daily life, we use the decimal system with digits from 0 to 9, which
    gives us 10 different 1-digit options in total. There is a good reason for that
    – most of us as human beings have 10 fingers on our hands in total, which are
    always in front of us and are great tools for counting. However, from a data science
    point of view, there is nothing particular about the number 10\. Using another
    base would allow us to store information much more efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: 'The absolute minimum required to store some information is two different values:
    yes or no, true or false, and so on. This lays a foundation for the binary numeral
    system that uses only two digits: 0 and 1\. The way we use it is the same as in
    the case of decimal: every time we reach the maximum digit on the right, we drop
    it to 0 and increment the next digit to the left from it while following the same
    logic. Therefore, *0, 1, 2, 3, 4, ... 9, 10, 11, ...* becomes *0, 1, 10, 11, 100,
    ..., 1001, 1010, 1011, ...* and so on. This approach makes it possible to efficiently
    encode big amounts of information to be read automatically by machines. Examples
    include magnetic tapes and floppy disks (lack or presence of magnetization), CD/DVD/BD
    (lack or presence of the indentation read by a laser), and flash memory (lack
    or presence of the electric charge). To not mix up binary values with decimals,
    it is common to use the “b” suffix for binary values (for example, 1010b).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if we want to work with groups of binary digits, we need to choose the
    size of the group. The group of 3 (from 000 to 111) would give 2^3 = 8 possible
    combinations of 0 and 1, allowing us to encode eight different numbers. Similarly,
    the group of 4 (from 0000 to 1111) would give 2^4 = 16 possible combinations.
    This is why octal and hexadecimal systems started to be used: they allow you to
    efficiently convert binary numbers. The octal system uses the base of 8, which
    means it can use digits from 0 to 7\. The hexadecimal system supports 16 digits,
    which were encoded using digits 0 to 9, followed by the first six letters of the
    English alphabet: A to F. Here, hexadecimal A stands for decimal 10, B stands
    for 11, and so on up to the maximum possible value of F, which stands for decimal
    15\. The way we use them is the same as for decimal and binary numeral systems:
    once the maximum digit on the right is reached, the next value would have dropped
    back to 0 and the digit to the left from it incremented while following the same
    logic. In this case, a decimal sequence such as *14, 15, 16, 17* will be represented
    as *E, F, 10, 11* in hexadecimal. To not confuse hexadecimal numbers with decimals,
    you can use the “0x” and “\x” prefixes or the “h” suffix to mark hexadecimal numbers
    (for example, 0x33, \x73, and 70h).'
  prefs: []
  type: TYPE_NORMAL
- en: Converting binary values into hexadecimal is extremely easy. The whole binary
    value should be split into groups of four digits, where each group will represent
    a single hexadecimal digit. For example, 0001b = 1h and 00110001b comprising 0011b
    = 3h and 0001b = 1h gives us 31h.
  prefs: []
  type: TYPE_NORMAL
- en: Now, it is time to learn how different data types are encoded using this approach.
  prefs: []
  type: TYPE_NORMAL
- en: Basic data units and data types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we know, the smallest data storage unit should be able to store two different
    values – a 0 or a 1; that is, a single digit in the binary numeral system. This
    unit is called a **bit**. A group of 8 bits comprises a **byte**. A single byte
    can be used to encode all possible combinations of zeroes and ones from 00000000b
    to 11111111b, which gives us 2^8 = 256 different variants in total, from 0x0 to
    0xFF. Other widely used data units are **word** (2 bytes), **dword** (4 bytes),
    and **qword** (8 bytes).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s talk about how we can encode the data that’s stored using these
    data units. Here are some of the most common primitive data types found in various
    programming languages:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Boolean**: A binary data type that can only store two possible values: true
    or false.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integer**: This stores whole numbers. The size varies. In some cases, it
    can be specified as a suffix defining the number of bits (int16, int32, and so
    on).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Unsigned**: All bits are dedicated to storing the numeric value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Signed**: The most significant bit (the top left) is dedicated to storing
    the sign, 0 for plus and 1 for minus. So 0xFFFFFFFF = -1.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Short** and **long**: These data types are integers that are smaller or bigger
    than the standard integer, respectively. The size is 2 bytes for short and 4 or
    8 bytes for long.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Float** and **double**: These data types are designed to store floating-point
    numbers (values that can have fractions). They are pretty much never used in malware.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Char**: Generally used to store characters of strings, each value has a size
    of 1 byte.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**String**: A group of bytes that defines human-readable strings. It can utilize
    one or multiple bytes per character, depending on the encoding.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ASCII**: Defines the mappings between characters (letters, numbers, punctuation
    signs, and so on) and the byte values. It uses 7 bits per character:![Figure 2.1
    – ASCII table'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '](img/Figure_2.1_B18500.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 2.1 – ASCII table
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.1 – ASCII table
  prefs: []
  type: TYPE_NORMAL
- en: '**Extended ASCII**: Utilizes 8 bits per character, where the first half (0x0-0x7F)
    is equal to the ASCII table and the rest depend on the code page (for example,
    Windows-1252 encoding).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**UTF8**: This is a Unicode encoding that uses 1 to 4 bytes per character.
    It’s commonly used in the *nix world. The beginning matches the ASCII table.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**UTF16**: This is a Unicode encoding that uses 2 or 4 bytes per character.
    The order of the bytes depends on the endianness.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Little Endian**: The least significant byte goes to the lowest address (UTF16-LE,
    the default Unicode encoding used by the Windows OS; the corresponding strings
    are known as Wide strings there).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Big Endian**: The most significant byte goes to the lowest address (UTF16-BE):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 2.2 – Example of a UTF16-LE string'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.2_B18500.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.2 – Example of a UTF16-LE string
  prefs: []
  type: TYPE_NORMAL
- en: Apart from knowing how the data can be stored using bits, it is also important
    to understand bitwise operations as they have multiple applications in assembly.
  prefs: []
  type: TYPE_NORMAL
- en: Bitwise operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Bitwise operations operate at the bit level and can be unary, which means they
    only require one operand, and binary, which means they work with two operands
    and apply the corresponding logic to each pair of the aligned bits. Because they
    are fast to perform, bitwise operations have found multiple applications in machine
    code. Let’s look at the most important ones.
  prefs: []
  type: TYPE_NORMAL
- en: AND (&)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here, the result bit will only be set (become equal to 1) if both corresponding
    operand bits are equal to 1\.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '*10110111b*'
  prefs: []
  type: TYPE_NORMAL
- en: '*AND*'
  prefs: []
  type: TYPE_NORMAL
- en: '*11001001b*'
  prefs: []
  type: TYPE_NORMAL
- en: '*=*'
  prefs: []
  type: TYPE_NORMAL
- en: '*10000001b*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The most common application of this operation in assembly is to separate part
    of the provided hexadecimal value (operand #1) by using a mask (operand #2) and
    nullify the rest. It is based on two features of this operation:'
  prefs: []
  type: TYPE_NORMAL
- en: If one operand’s bit is set to 0, the result will always be 0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If one operand’s bit is set to 1, the result will be equal to another operand’s
    bit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Therefore, *0x12345678 & 0x000000FF = 0x00000078* (as 0xFF = 11111111b).
  prefs: []
  type: TYPE_NORMAL
- en: OR (|)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this case, the result bit will be equal to 1 if any of the corresponding
    operand bits are equal to 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '*10100101b*'
  prefs: []
  type: TYPE_NORMAL
- en: '*OR*'
  prefs: []
  type: TYPE_NORMAL
- en: '*10001001b*'
  prefs: []
  type: TYPE_NORMAL
- en: '*=*'
  prefs: []
  type: TYPE_NORMAL
- en: '*10101101b*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, the common application of this operation is setting bits by mask while
    preserving the rest of the value. It is based on the following features of this
    operation:'
  prefs: []
  type: TYPE_NORMAL
- en: If one operand’s bit is set to 0, the result will be equal to another operand’s
    bit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If one operand’s bit is set to 1, the result will always be 1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This way, *0x12345678 & 0x000000FF = 0x123456FF* (again, as *0xFF = 11111111b*).
  prefs: []
  type: TYPE_NORMAL
- en: XOR (^)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here, the result bit will only be 1 if the corresponding operands’ bits are
    different. Otherwise, the result is 0.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '*11101001b*'
  prefs: []
  type: TYPE_NORMAL
- en: '*XOR*'
  prefs: []
  type: TYPE_NORMAL
- en: '*10011100b*'
  prefs: []
  type: TYPE_NORMAL
- en: '*=*'
  prefs: []
  type: TYPE_NORMAL
- en: '*01110101b*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two very common applications of this operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Nullification**: This is based on the principle that if we use the same value
    for both operands, all its bits will meet equal bits, so the whole result will
    be 0.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Encryption**: This is based on the fact that applying this operation twice
    with the same key as one of the operands restores the original value. The actual
    property it is based on is that if one of the operands is 0, the result will be
    equal to another operand, and this is exactly what happens in the end:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*plain_text ^ key = encrypted_text*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*encrypted_text ^ key = (plain_text ^ key) ^ key = plain_text ^ (key ^ key)
    = plain_text ^ 0 = plain_text*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Now let’s look at the NOT (~) operation.
  prefs: []
  type: TYPE_NORMAL
- en: NOT (~)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Unlike the previous operations, this operation is unary and requires only one
    operand, flipping all its bits to the opposite ones.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '*NOT*'
  prefs: []
  type: TYPE_NORMAL
- en: '*11001010b*'
  prefs: []
  type: TYPE_NORMAL
- en: '*=*'
  prefs: []
  type: TYPE_NORMAL
- en: '*00110101b*'
  prefs: []
  type: TYPE_NORMAL
- en: The common application of this operation is to change the sign of signed integer
    values to the opposite one (for example, -3 to 3 or 5 to -5). The formula, in
    this case, will be *~value + 1*.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s take a look at bit shifts.
  prefs: []
  type: TYPE_NORMAL
- en: Logical shift (<< or >>)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This operation requires the direction (left or right) to be specified, along
    with the actual value to change and the number of shift positions. During the
    shift, each bit of the original value will move to the left or right on the number
    of positions specified; the empty spaces on the opposite side are filled in with
    zeroes. All bits shifted outside of the data unit are lost.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '*10010011b >> 1 = 01001001b*'
  prefs: []
  type: TYPE_NORMAL
- en: '*10010011b << 2 = 01001100b*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two common applications of this operation:'
  prefs: []
  type: TYPE_NORMAL
- en: Moving the data to a particular part of the register (as you’ll see shortly)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiplication (shift left) or division (shift right) by a power of two for
    every shift position
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Circular shift (Rotate)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This bitwise shift is very similar to the logical shift with one important difference
    – all the bits shifted out on one side of the data unit will appear on the opposite
    side.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '*10010011b ROR 1 = 11001001b*'
  prefs: []
  type: TYPE_NORMAL
- en: '*10010011b ROL 2 = 01001110b*'
  prefs: []
  type: TYPE_NORMAL
- en: Because, unlike logical shift, the operation is reversible and the data is not
    lost, it can be used in cryptography algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: Other types of shifts, such as arithmetic shift or rotate with carrying, are
    present much more rarely in the assembly in general and in malware in particular,
    so they are outside the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Now, it is finally time to start learning more about various architectures and
    their assembly instructions.
  prefs: []
  type: TYPE_NORMAL
- en: Architectures and their assembly
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Simply put, the processor, also known as the **central processing unit** (**CPU**),
    is quite similar to a calculator. If you look at the instructions (whatever the
    assembly language is), you will find many of them dealing with numbers and doing
    some calculations. However, multiple features differentiate processors from usual
    calculators. Let’s look at some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: Modern processors support a much bigger memory space compared to traditional
    calculators. This memory space allows them to store billions of values, which
    makes it possible to perform more complex operations. Additionally, they have
    multiple fast and small memory storage units embedded inside the processors’ chips
    called registers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Processors support many instruction types other than arithmetic instructions,
    such as changing the execution flow based on certain conditions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Processors can work in conjunction with other peripheral devices such as speakers,
    microphones, hard disks, graphics cards, and others.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Armed with such features and coupled with great flexibility, processors became
    the go-to universal machines to power various advanced modern technologies such
    as machine learning. In the following sections, we will explore these features
    before diving deeper into different assembly languages and how these features
    are manifested in these languages’ instruction sets.
  prefs: []
  type: TYPE_NORMAL
- en: Registers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Even though processors have access to a huge memory space that can store billions
    of values, this storage is provided by separate RAM devices, which makes it longer
    for the processors to access the data. So, to speed up the processor operations,
    they contain small and fast internal memory storage units called registers.
  prefs: []
  type: TYPE_NORMAL
- en: Registers are built into the processor chip and can store the immediate values
    that are needed while performing calculations and data transfers from one place
    to another.
  prefs: []
  type: TYPE_NORMAL
- en: 'Registers may have different names, sizes, and functions, depending on the
    architecture. Here are some of the types that are widely used:'
  prefs: []
  type: TYPE_NORMAL
- en: '**General-purpose registers**: These are registers that are used to temporarily
    store arguments and results for various arithmetic, bitwise, and data transfer
    operations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stack and frame pointers**: These point to the top and a certain fixed point
    of the stack (as you’ll see shortly).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Instruction pointer/program counter**: The instruction pointer is used to
    point to the next instruction to be executed by the processor.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Memory plays an important role in the development of all the smart devices that
    we use nowadays. The ability to manage lots of values, text, images, and videos
    on a fast and volatile memory allows CPUs to process more information and, eventually,
    perform more complicated operations, such as displaying graphical interfaces in
    3D and virtual reality.
  prefs: []
  type: TYPE_NORMAL
- en: Virtual memory
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In modern OSs, whether they are 32-bit or 64-bit based, the OS creates an isolated
    virtual memory (in which its pages are mapped to the physical memory pages) for
    each process. Applications are only supposed to have the ability to access their
    virtual memory. They can read and write code and data and execute instructions
    located in virtual memory. Each memory range that comprises virtual memory pages
    has a set of permissions, also known as protection flags, assigned to it, which
    represents the types of operations the application is allowed to perform on it.
    Some of the most important of them are READ, WRITE, and EXECUTE, as well as their
    combinations.
  prefs: []
  type: TYPE_NORMAL
- en: 'For an application to attempt to access a value stored in memory, it needs
    its virtual address. Behind the scenes, the **Memory Management Unit** (**MMU**)
    and the OS are transparently mapping these virtual addresses to physical addresses
    that define where the values are stored in hardware:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.3 – Virtual memory addresses'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.3_B18500.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.3 – Virtual memory addresses
  prefs: []
  type: TYPE_NORMAL
- en: To save the space that’s required to store and use addresses of values, the
    concept of the stack has been developed.
  prefs: []
  type: TYPE_NORMAL
- en: Stack
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A stack is a pile of objects. In computer science, the stack is a data structure
    that helps save different values of the same size in memory in a pile structure
    using the principle of **Last In First Out** (**LIFO**).
  prefs: []
  type: TYPE_NORMAL
- en: The top of the stack (where the next element will be placed) is pointed to by
    a dedicated stack pointer, which will be discussed in greater detail shortly.
  prefs: []
  type: TYPE_NORMAL
- en: A stack is common among many assembly languages and it may serve multiple purposes.
    For example, it may help in solving mathematical equations, such as *X = 5*6 +
    6*2 + 7(4 + 6)*, by temporarily storing each calculated value and later pulling
    them back to calculate the sum of all of them and saving them in a variable, *X*.
  prefs: []
  type: TYPE_NORMAL
- en: Another application for the stack is to pass arguments to functions and store
    local variables. Finally, on some architectures, a stack can also be used to save
    the address of the next instruction before calling a function. This way, once
    this function finishes executing, it is possible to pop this return address back
    from the top of the stack and transfer control to where it was called from to
    continue the execution.
  prefs: []
  type: TYPE_NORMAL
- en: While the stack pointer is always pointing to the current top of the stack,
    the frame pointer is storing the address of the top of the stack at the beginning
    of the function to make it possible to access passed arguments and local variables,
    and also restore the stack pointer value at the end of the routine. We will cover
    this in greater detail when we talk about calling conventions for different architectures.
  prefs: []
  type: TYPE_NORMAL
- en: Instructions (CISC and RISC)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Instructions are machine code represented in the form of bytes that CPUs can
    understand and execute. For us humans, reading bytes is extremely problematic,
    which is why we developed assemblers to convert assembly code into instructions
    and disassemblers to be able to read it back.
  prefs: []
  type: TYPE_NORMAL
- en: 'Two big groups of architectures define assembly languages that we will cover
    in this section: **Complex Instruction Set Computer** (**CISC**) and **Reduced
    Instruction Set Computer** (**RISC**).'
  prefs: []
  type: TYPE_NORMAL
- en: Without going into too many details, the main difference between CISC assemblies,
    such as Intel IA-32 and x64, and RISC assembly languages associated with architectures
    such as ARM is the complexity of their instructions.
  prefs: []
  type: TYPE_NORMAL
- en: CISC assembly languages have more complex instructions. They generally focus
    on completing tasks using as few lines of assembly instructions as possible. To
    do that, CISC assembly languages include instructions that can perform multiple
    operations, such as *mul* in Intel assembly, which performs data access, multiplication,
    and data store operations in one go.
  prefs: []
  type: TYPE_NORMAL
- en: In the RISC assembly language, assembly instructions are simple and generally
    perform only one operation each. This may lead to more lines of code to complete
    a specific task. However, it may also be more efficient, as this omits the execution
    of any unnecessary operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Overall, we can split all the instructions, regardless of the architecture,
    into several groups:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Data manipulation**: This comprises arithmetic and bitwise operations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data transfer**: Allows data that may involve registers, memory, and immediate
    values to be moved.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Control flow**: This makes it possible to change the order the instructions
    are executed in. In every assembly language, there are multiple comparison and
    control flow instructions, which can be divided into the following categories:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Unconditional**: This type of instruction forcefully changes the flow of
    the execution to another address (without any given condition).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Conditional**: This is like a logical gate that switches to another branch
    based on a given condition (such as equal to zero, greater than, or less than),
    as shown in the following diagram:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 2.4 – An example of a conditional jump'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.4_B18500.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.4 – An example of a conditional jump
  prefs: []
  type: TYPE_NORMAL
- en: '**Subroutine call**: These instructions change the execution to another function
    and save the return address to be restored later when necessary.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, it is time to learn about the most common instructions that you may see
    when performing reverse engineering. Becoming able to read them fluently and understand
    the meaning of groups of them is an important step in the journey of becoming
    a professional malware analyst.
  prefs: []
  type: TYPE_NORMAL
- en: Becoming familiar with x86 (IA-32 and x64)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Intel x86 (including both 32 and 64-bit versions) is the most common architecture
    used in PCs. It powers various types of workstations and servers, so it comes
    as no surprise that most of the malware samples we have at the moment support
    it. The 32-bit version of it, IA-32, is also commonly referred to as i386 (succeeded
    by i686) or even simply x86, while the 64-bit version, x64, is also known as x86-64
    or AMD64\. x86 is a CISC architecture, and it includes multiple complex instructions
    in addition to simple ones. In this section, we will introduce the most common
    of them and cover how the functions are organized.
  prefs: []
  type: TYPE_NORMAL
- en: Registers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following table shows the relationship between the registers in the IA-32
    and x64 architectures:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.5 – IA-32 and x64 architectures'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.5_B18500.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.5 – IA-32 and x64 architectures
  prefs: []
  type: TYPE_NORMAL
- en: The registers that are used in the x86 architectures (the 8 to r15 registers)
    are only available in x64, not IA-32, and the spl, bpl, sil, and dil registers
    can only be accessed in x64.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing to mention is that there may be multiple interpretations of
    what registers should be called **general-purpose registers** (**GPRs**) and which
    are not since most of them may serve some particular purpose.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first four registers (**rax/eax**, **rbx/ebx**, **rcx/ecx**, and **rdx/edx**)
    are GPRs. Some of them have special use cases for certain instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '**rax/eax**: This is commonly used to store the result of some operations and
    the return values of functions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**rcx/ecx**: This is used as a counter register in instructions that’s responsible
    for repeating actions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**rdx/edx**: This is used in multiplication and division to extend the result
    or the dividend, respectively.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In x64, the registers from r8 to r15 were added to the list of available GPRs.
  prefs: []
  type: TYPE_NORMAL
- en: '**rsi/esi** and **rdi/edi** are mostly used to define addresses when copying
    groups of bytes in memory. The rsi/esi register always plays the role of the source,
    while the rdi/edi register plays the role of the destination. Both registers are
    non-volatile and are also GPRs.'
  prefs: []
  type: TYPE_NORMAL
- en: The **rsp/esp** register is used as a stack pointer, which means it always points
    to the top of the stack. Its value decreases when a value is getting pushed to
    the stack, and increases when a value is getting pulled out from the stack.
  prefs: []
  type: TYPE_NORMAL
- en: The **rbp/ebp** register is mainly used as a base pointer that indicates a fixed
    place within the stack. It helps access the function’s local variables and arguments,
    as we will see later in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Special registers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are two special registers in the x86 assembly, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**rip/eip**: This is an instruction pointer that points to the next instruction
    to be executed. It cannot be accessed directly but there are special instructions
    that work with it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**rflags/eflags/flags**: This register contains the current state of the processor.
    Its flags are affected by the arithmetic and logical instructions, including comparison
    instructions such as *cmp* and *test*, and it’s used with conditional jumps and
    other instructions as well. Here are some of its flags:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Carry flag** (**CF**): This flag is set when an arithmetic operation goes
    out of bounds, as follows:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mov al, FFh ; al = 0xFF & CF = 0`'
  prefs: []
  type: TYPE_NORMAL
- en: '`add al, 1 ; al = 0 & CF = 1`'
  prefs: []
  type: TYPE_NORMAL
- en: '**Zero flag** (**ZF**): This flag is set when the arithmetic or a logical operation’s
    result is zero. This can also be set by comparison instructions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Direction flag** (**DF**): This indicates whether certain instructions such
    as *lods*, *stos*, *scas*, and *movs* (as you’ll see shortly) should go to higher
    addresses (when not set) or to lower addresses (when set).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sign flag** (**SF**): This flag indicates that the result of the operation
    is negative.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Overflow flag** (**OF**): This flag indicates that an overflow occurred in
    an operation, leading to a change in the sign (only for signed numbers), as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mov cl, 7Fh ; cl = 0x7F (127) & OF = 0`'
  prefs: []
  type: TYPE_NORMAL
- en: '`inc cl ; cl = 0x80 (-128) & OF = 1`'
  prefs: []
  type: TYPE_NORMAL
- en: There are other registers as well, such as the MMX and FPU registers (and instructions
    to work with them), but they are rarely used in malware, so they are outside the
    scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: The instruction structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many x86 assemblers, such as MASM and NASM, as well as disassemblers, use Intel
    syntax. In this case, the common structure of its instructions is *opcode*, *dest*,
    *src*.
  prefs: []
  type: TYPE_NORMAL
- en: '*dest* and *src* are commonly referred to as **operands**. Their numbers can
    vary from 0 to 3, depending on the instruction. Another option would be **GNU
    Assembler** (**GAS**), which uses the AT&T syntax and swaps *dest* and *src* for
    representation. Throughout this book, we will use Intel syntax.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s dive deeper into the meaning of each part of the instruction.
  prefs: []
  type: TYPE_NORMAL
- en: opcode
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`n``op`, `pushad`, `popad`, and `movsb`.'
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: '`pushad` and `popad` are not available in x64.'
  prefs: []
  type: TYPE_NORMAL
- en: dest
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*dest* represents the destination, or where the result of the operation will
    be saved, and can also become part of the calculations themselves, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '`add eax, ecx ; eax = (eax + ecx)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`sub rdx, rcx ; rdx = (rdx - rcx)`'
  prefs: []
  type: TYPE_NORMAL
- en: '*dest* could look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**REG**: A register, such as eax or edx.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**r/m**: A place in memory, such as the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*DWORD PTR [00401000h]*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*BYTE PTR [EAX + 00401000h]*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*WORD PTR [EDX*4 + EAX+ 30]*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The stack is also a place in memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '*DWORD PTR [ESP+4]*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*DWORD PTR [EBP-8]*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: src
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*src* represents the source or another value in the calculations, but it is
    not used to save the results there afterward. It may look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`add rcx, r8`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`add ecx, DWORD PTR [00401000h]`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here, we are adding the value of the size of DWORD located at the 00401000h
    address to ecx.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mov eax, 00100000h`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For instructions with a single operand, it may play a role of both a source
    and a destination:'
  prefs: []
  type: TYPE_NORMAL
- en: '`inc eax`'
  prefs: []
  type: TYPE_NORMAL
- en: '`dec ecx`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Or, it could be only the source or the destination. This is the case for the
    following instructions, which save the value on the stack and then pull it back:'
  prefs: []
  type: TYPE_NORMAL
- en: '`push rdx`'
  prefs: []
  type: TYPE_NORMAL
- en: '`pop rcx`'
  prefs: []
  type: TYPE_NORMAL
- en: The instruction set
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will cover the most important instructions required to start
    reading the assembly.
  prefs: []
  type: TYPE_NORMAL
- en: Data manipulation instructions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Some of the most common arithmetic instructions are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Table_2.1_B18500.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: For multiplication and division, which treat operands as signed integers, the
    corresponding instructions will be `imul` and `idiv`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following instructions represent logical/bitwise operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Table_2.2_B18500.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Lastly, the following instructions represent bitwise shifts and rotations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Table_2.3_B18500.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To learn more about the potential applications of bitwise operations, please
    read [*Chapter 1*](B18500_01.xhtml#_idTextAnchor014), *Cybercrime, APT Attacks,
    and Research Strategies*.
  prefs: []
  type: TYPE_NORMAL
- en: Data transfer instructions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The most basic instruction for moving the data is `mov`, which copies a value
    from *src* to *dest*. This instruction has multiple forms, as shown in the following
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Table_2.4_B18500.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here are the instructions related to the stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Table_2.5_B18500.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here are the string manipulation instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Table_2.6_B18500.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: If the DF bit in the EFLAGS register is 0, these instructions will increase
    the value of the rdi/edi or rsi/esi register by the number of bytes used (1, 2,
    4, or 8) and decrease if the DF bit is set (equals 1).
  prefs: []
  type: TYPE_NORMAL
- en: Control flow instructions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'These instructions change the value of the rip/eip register so that the instructions
    to be executed next may not be the next ones sequentially. The most important
    unconditional redirections are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Table_2.7_B18500.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To implement the condition, some form of comparison needs to be used. There
    are dedicated instructions for that:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Table_2.8_B18500.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following table shows some of the most important conditional redirections
    based on the result of this comparison:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Table_2.9_B18500.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now, let’s talk about how values can be passed to functions and accessed there.
  prefs: []
  type: TYPE_NORMAL
- en: Arguments, local variables, and calling conventions (in x86 and x64)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Arguments can be passed to functions in various ways. These ways are called
    **calling conventions**. In this section, we will cover the most common ones.
    We will start with the **standard call** (**stdcall**) convention, which is commonly
    used in IA-32, and then cover the differences between it and other conventions.
  prefs: []
  type: TYPE_NORMAL
- en: stdcall
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The stack, together with the rsp/esp and rbp/ebp registers, does most of the
    work when it comes to arguments and local variables. The `call` instruction saves
    the return address at the top of the stack before transferring the execution to
    the new function, while the `ret` instruction at the end of the function returns
    the execution to the caller function using the return address saved in the stack.
  prefs: []
  type: TYPE_NORMAL
- en: Arguments
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In stdcall, the arguments are pushed in the stack from the last argument to
    the first *(right to left)*, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `Func01` function, the arguments could be accessed by `esp`, but it
    would be hard to always adjust the offset with every next value that’s pushed
    or pulled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Fortunately, modern static analysis tools, such as `ebp`. First, the called
    function needs to save the current `esp` in the `ebp` register and then access
    it, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'At the end of the called function, it returns the original values of `ebp`
    and `esp`, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As it’s a common function epilogue, Intel created a special instruction for
    it, called
  prefs: []
  type: TYPE_NORMAL
- en: '`leave`, so it became as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Local variables
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'For local variables, the called function allocates space for them by decreasing
    the value of the `esp` register. To allocate space for two variables of four bytes
    each, use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, the end of the function will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The following figure exemplifies how the stack change looks at the beginning
    and the end of the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.6 – An example of a stack change at the beginning and the end of
    the function'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.6_B18500.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.6 – An example of a stack change at the beginning and the end of the
    function
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, if there are arguments, the `ret` instruction cleans the stack,
    given the number of bytes to pull out from the top of the stack, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: cdecl
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*cdecl* (which stands for C declaration) is another calling convention that
    was used by many C compilers in x86\. It’s very similar to stdcall, with the only
    difference being that the caller cleans the stack after the callee function (the
    called function) returns, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: fastcall
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *fastcall* calling convention is also widely used by different compilers,
    including the Microsoft C++ compiler and GCC. This calling convention passes the
    first two arguments in ecx and edx and passes the remaining arguments through
    the stack. Again, it is only used in the 32-bit version of x86.
  prefs: []
  type: TYPE_NORMAL
- en: thiscall
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For object-oriented programming and non-static member functions (such as the
    classes’ functions), the C compiler needs to pass the address of the object whose
    attribute will be accessed or manipulated using it as an argument.
  prefs: []
  type: TYPE_NORMAL
- en: In the GCC compiler, *thiscall* is almost identical to the cdecl calling convention
    and it passes the current object’s address (that is, *this*) as the first argument.
    But in the Microsoft C++ compiler, it’s similar to stdcall and passes the object’s
    address in ecx. It’s common to see such patterns in some object-oriented malware
    families.
  prefs: []
  type: TYPE_NORMAL
- en: Borland register
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This convention can be commonly seen in malware written in the Delphi programming
    language. The first three arguments are passed through the eax, edx, and ecx registers
    while the rest go through the stack. However, unlike other conventions, they are
    passed in the opposite order – *from left to right*. If necessary, it will be
    the callee (called function) who cleans up the stack.
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft x64 calling convention
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In x64, the calling conventions are more dependent on the registers. For Windows,
    the caller function passes the first four arguments to the registers in the following
    order: rcx, rdx, r8, r9\. The rest are passed through the stack. The calling function
    (caller) cleans the stack in the end (if necessary).'
  prefs: []
  type: TYPE_NORMAL
- en: System V AMD64 ABI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For other 64-bit OSs such as Linux, FreeBSD, or macOS, the first six arguments
    are passed to the registers in this order: rdi, rsi, rdx, rcx, r8, r9\. The remaining
    get passed through the stack. Again, it is the caller who cleans the stack in
    the end, if necessary. This is the only way to do this on 64-bit OSs.'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring ARM assembly
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most of you are probably more familiar with the x86 architecture, which implements
    the CISC design. So, you may be wondering, *why do we need something else?* The
    main advantage of RISC architectures is that the processors that implement them
    generally require fewer transistors, which eventually makes them more energy and
    heat-efficient and reduces the associated manufacturing costs, making them a better
    choice for portable devices. We have started our introduction to RISC architectures
    with ARM for a good reason – at the time of writing, this is the most widely used
    architecture in the world.
  prefs: []
  type: TYPE_NORMAL
- en: 'The explanation is simple – processors that implement it can be found on multiple
    mobile devices and appliances such as phones, video game consoles, or digital
    cameras, heavily outnumbering PCs. For this reason, multiple IoT malware families
    and mobile malware that target Android and iOS platforms have payloads for the
    ARM architecture; an example can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.7 – Disassembled IoT malware targeting ARM-based devices'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.7_B18500.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.7 – Disassembled IoT malware targeting ARM-based devices
  prefs: []
  type: TYPE_NORMAL
- en: Thus, to analyze them, it is necessary to understand how ARM works.
  prefs: []
  type: TYPE_NORMAL
- en: ARM originally stood for Acorn RISC Machine, and later for Advanced RISC Machine.
    Acorn was a British company considered by many as the British Apple, producing
    some of the most powerful PCs of that time. It was later split into several independent
    entities, with Arm Holdings (currently owned by SoftBank Group) supporting and
    extending the current standard.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple OSs support it, including Windows, Android, iOS, various Unix/Linux
    distributions, and many other lesser-known embedded OSs. The support for a 64-bit
    address space was added in 2011 with the release of the ARMv8 standard.
  prefs: []
  type: TYPE_NORMAL
- en: 'Overall, the following ARM architecture profiles are available:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Application profiles (suffix A, for example, the Cortex-A family**): These
    profiles implement a traditional ARM architecture and support a virtual memory
    system architecture based on am MMU. These profiles support both ARM and Thumb
    instruction sets (as discussed later).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Real-time profiles (suffix R, for example, the Cortex-R family):** These
    profiles implement a traditional ARM architecture and support a protected memory
    system architecture based on a **Memory Protection Unit** (**MPU**).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Microcontroller profiles (suffix M, for example, the Cortex-M family)**:
    The profiles implement a programmers’ model and are designed to be integrated
    into **Field Programmable Gate Arrays** (**FPGAs**).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each family has its corresponding set of associated architectures (for example,
    the Cortex-A 32-bit family incorporates the ARMv7-A and ARMv8-A architectures),
    which, in turn, incorporates several cores (for example, the ARMv7-R architecture
    incorporates Cortex-R4, Cortex-R5, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: Basics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will cover both the original 32-bit and the newer 64-bit
    architectures. Multiple versions were released over time, starting from the ARMv1\.
    In this book, we will focus on the recent versions of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'ARM is a load-store architecture; it divides all instructions into the following
    two categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Memory access**: Move data between memory and registers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Arithmetic Logic Unit (ALU) operations**: Do computations involving registers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ARM supports the addition, subtraction, and multiplication arithmetic operations,
    though some new versions, starting from ARMv7, also support division. It also
    supports big-endian order but uses little-endian order by default.
  prefs: []
  type: TYPE_NORMAL
- en: '16 registers are visible at any time on the 32-bit ARM: R0-R15\. This number
    is convenient as it only takes 4 bits to define which register is going to be
    used. Out of them, 13 (sometimes referred to as 14, including R14 or 15, also
    including R13) are general-purpose registers: R13 and R15 each have a special
    function, while R14 can take it occasionally. Let’s have a look at them in greater
    detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '**R0-R7**: Low registers are the same in all CPU modes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**R8-R12**: High registers are the same in all CPU modes except the **Fast
    Interrupt Request** (**FIQ**) mode, which is not accessible by 16-bit instructions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**R13 (also known as SP**): This is a stack pointer that points to the top
    of the stack. Each CPU mode has a version of it. It is discouraged to use it as
    a GPR.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BL` (Branch with Link) or `BLX` (Branch with Link and eXchange) instructions
    are executed. It can also be used as a GPR if the return address is stored on
    the stack. Each CPU mode has a version of it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**R15 (also known as PC)**: This is a program counter that points to the currently
    executed command. It’s not a GPR.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Altogether, there are 30 general-purpose 32-bit registers on most of the ARM
    architectures overall, including the same name instances in different CPU modes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Apart from these, there are several other important registers, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Application Program Status Register** (**APSR**): This stores copies of the
    ALU status flags, also known as condition code flags. On later architectures,
    it also holds the Q (saturation) and the greater than or equal to (GE) flags.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Current Program Status Register** (**CPSR**): This contains APSR as well
    as bits that describe a current processor mode, state, endianness, and some other
    values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Saved Program Status Registers** (**SPSR**): This stores the value of CPSR
    when the exception is taken so that it can be restored later. Each CPU mode has
    a version of it, except the user and system modes, as they are not exception-handling
    modes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The number of **Floating-Point Registers** (**FPRs**) for a 32-bit architecture
    may vary, depending on the core. There can be up to 32 in total.
  prefs: []
  type: TYPE_NORMAL
- en: ARMv8 (64-bit) has 31 general-purpose X0-X30 (the R0-R30 notation can also be
    found) and 32 FPRs accessible at all times. The lower part of each register has
    the W prefix and can be accessed as W0-W30.
  prefs: []
  type: TYPE_NORMAL
- en: 'Several registers have a particular purpose, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Table_2.10_B18500.jpg)'
  prefs: []
  type: TYPE_IMG
- en: ARMv8 defines four exception levels (EL0-EL3), and each of the last three registers
    gets a copy of each; ELR and SPSR don’t have a separate copy of EL0.
  prefs: []
  type: TYPE_NORMAL
- en: There is no register called X31 or W31; the number 31 in many instructions represents
    either the zero register, ZR (WZR/XZR), or SP (for stack-related operations).
    X29 can be used as a frame pointer (which stores the original stack position),
    while X30 can be used as a link register (which stores a return value from the
    functions).
  prefs: []
  type: TYPE_NORMAL
- en: Regarding the calling convention, R0-R3 on the 32-bit ARM and X0-X7 on the 64-bit
    ARM are used to store argument values passed to functions with the remaining arguments
    passed through the stack – if necessary, R0-R1 and X0-X7 (and X8, also known as
    XR indirectly) to hold return results. If the type of the returned value is too
    big to fit them, then space needs to be allocated and returned as a pointer. Apart
    from this, R12 (32-bit) and X16- X17 (64-bit) can be used as intra-procedure-call
    scratch registers (by so-called veneers and procedure linkage table code) and
    R9 (32-bit) and X18 (64-bit) can be used as platform registers (for OS-specific
    purposes) if needed; otherwise, they are used the same way as other temporaries.
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned previously, several CPU modes are implemented according to the
    official documentation, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Table_2.11_B18500.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Instruction sets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Several instruction sets are available for ARM processors: ARM and Thumb. A
    processor that is executing ARM instructions is said to be operating in the ARM
    state and vice versa. ARM processors always start in the ARM state; then, a program
    can switch to the Thumb state by using a BX instruction. **Thumb Execution Environment**
    (**ThumbEE**) was introduced relatively recently in ARMv7 and is based on Thumb,
    with some changes and additions to facilitate dynamically generated code.'
  prefs: []
  type: TYPE_NORMAL
- en: ARM instructions are 32 bits long (for both AArch32 and AArch64), while Thumb
    and ThumbEE instructions are either 16 or 32 bits long (originally, almost all
    Thumb instructions were 16-bit, while Thumb-2 introduced a mix of 16 and 32-bit
    instructions).
  prefs: []
  type: TYPE_NORMAL
- en: 'All instructions can be split into the following categories according to the
    official documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Table_2.12_B18500.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To interact with the OS, *syscalls* can be accessed using the `SWI`) instruction,
    which was later renamed the `SVC`) instruction.
  prefs: []
  type: TYPE_NORMAL
- en: 'See the official ARM documentation to get the exact syntax for any instruction.
    Here is an example of how it may look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, the *{cond}* code will be a condition code. Several condition
    codes are supported by ARM, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**EQ**: Equal to'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**NE**: Not equal to'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CS/HS**: Carry set or unsigned higher or both'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CC/LO**: Carry clear or unsigned lower'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**MI**: Negative'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PL**: Positive or zero'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**VS**: Overflow'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**VC**: No overflow'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**HI**: Unsigned higher'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**LS**: Unsigned lower or both'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GE**: Signed greater than or equal to'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**LT**: Signed less than'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GT**: Signed greater than'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**LE**: Signed less than or equal to'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**AL**: Always (normally omitted)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**imm:** It stands for the immediate value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let's look at the basics of MIPS.
  prefs: []
  type: TYPE_NORMAL
- en: Basics of MIPS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Microprocessor without Interlocked Pipelined Stages** (**MIPS**) was developed
    by MIPS Technologies (formerly MIPS computer systems). Similar to ARM, at first,
    it was a 32-bit architecture with 64-bit functionality added later. Taking advantage
    of the RISC ISA, MIPS processors are characterized by their low power and heat
    consumption. They can often be found in multiple embedded systems, such as routers
    and gateways. Several video game consoles such as Sony PlayStation also incorporated
    them. Unfortunately, due to the popularity of this architecture, the systems that
    implement it became a target of multiple IoT malware families. An example can
    be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.8 – IoT malware targeting MIPS-based systems'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.8_B18500.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.8 – IoT malware targeting MIPS-based systems
  prefs: []
  type: TYPE_NORMAL
- en: As the architecture evolved, there were several versions of it, starting from
    MIPS I and going up to V, and then several releases of the more recent MIPS32/MIPS64\.
    MIPS64 remains backward compatible with MIPS32\. These base architectures can
    be further supplemented with optional architectural extensions, called **Application-Specific
    Extensions** (**ASEs**), and modules to improve performance for certain tasks
    that are generally not used by the malicious code much. MicroMIPS32/64 are supersets
    of the MIPS32 and MIPS64 architectures, respectively, with almost the same 32-bit
    instruction set and additional 16-bit instructions to reduce the code size. They
    are used where code compression is required and are designed for microcontrollers
    and other small embedded devices.
  prefs: []
  type: TYPE_NORMAL
- en: Basics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'MIPS supports bi-endianness. The following registers are available:'
  prefs: []
  type: TYPE_NORMAL
- en: 32 GPRs r0-r31 – 32-bit in size on MIPS32 and 64-bit in size on MIPS64.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A special-purpose PC register that can be affected only indirectly by some instructions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two special-purpose registers to hold the results of integer multiplication
    and division (HI and LO). These registers and their related instructions were
    removed from the base instruction set in the release of 6 and now exist in the
    **Digital Signal Processor** (**DSP**) module.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The reason behind 32 GPRs is simple – MIPS uses 5 bits to specify the register,
    so this way, we can have a maximum of 2^5 = 32 different values. Two of the GPRs
    have a particular purpose, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Register r0 (sometimes referred to as $0 or $zero) is a constant register and
    always stores zero, and provides read-only access. It can be used as a /dev/null
    analog to discard the output of some operation, or as a fast source of a zero
    value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: r31 (also known as $ra) stores the return address during the procedure call
    branch/jump and link instructions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Other registers are generally used for particular purposes, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**r1 (also known as $at)**: Assembler temporary – used when resolving pseudo-
    instructions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**r2-r3 (also known as $v0 and $v1)**: Values – hold return function values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**r4-r7 (also known as $a0-$a3)**: Arguments – used to deliver function arguments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**r8-r15 (also known as $t0-$t7/$a4-$a7 and $t4-$t7)**: Temporaries – the first
    four can also be used to provide function arguments in N32 and N64 calling conventions
    (another O32 calling convention only uses r4-r7 registers; subsequent arguments
    are passed on the stack).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**r16-r23 (also known as $s0-$s7)**: Saved temporaries – preserved across function
    calls.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**r24-r25 (also known as $t8-$t9)**: Temporaries.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**r26-r27 (also known as $k0-$k1)**: Generally reserved for the OS kernel.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**r28 (also known as $gp)**: Global pointer – points to the global area (data
    segment).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**r29 (also known as $sp)**: Stack pointer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**r30 (also known as $s8 or $fp)**: Saved value/frame pointer – stores the
    original stack pointer (before the function was called).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'MIPS also has the following co-processors available:'
  prefs: []
  type: TYPE_NORMAL
- en: '**CP0**: System control'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CP1**: FPU'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CP2**: Implementation-specific'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CP3**: FPU (has dedicated COP1X opcode type instructions)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The instruction set
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The majority of the main instructions were introduced in MIPS I and II. MIPS
    III introduced 64-bit integers and addresses, and MIPS IV and V improved floating-point
    operations and added a new set to boost the overall efficacy. Every instruction
    there has the same length – that is, 32 bits (4 bytes) – and all instructions
    start with an opcode that takes 6 bits. The three major instruction formats that
    are supported are R, I, and J:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Table_2.13_B18500.jpg)'
  prefs: []
  type: TYPE_IMG
- en: For the FPU-related operations, the analogous FR and FI types exist.
  prefs: []
  type: TYPE_NORMAL
- en: Apart from this, several other less common formats exist, mainly coprocessors
    and extension-related formats.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the documentation, registers usually have the following suffixes:'
  prefs: []
  type: TYPE_NORMAL
- en: Source (s)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Target (t)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Destination (d)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All instructions can be split into the following groups, depending on the functionality
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: '`JR`: Jump register (J format)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BLTZ`: Branch on less than zero (I format)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LB`: Load byte (I format)*   `SW`: Store word (I format)*   `ADDU`: Add unsigned
    (R format)*   `XOR`: Exclusive or (R format)*   `SLL`: Shift left logical (R format)*   `SYSCALL`:
    System call (custom format)*   `BREAK`: Breakpoint (custom format)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Floating-point instructions will have similar names for the same types of operations
    in most cases, such as `ADD.S`. Some instructions are more unique, such as Check
    for Equal (`C.EQ.D`).
  prefs: []
  type: TYPE_NORMAL
- en: As we can see here and later, the same basic groups can be applied to virtually
    any architecture, and the only difference will be in their implementation. Some
    common operations may get instructions to benefit from optimizations and, in this
    way, reduce the size of the code and improve performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'As the MIPS instruction set is pretty minimalistic, the assembler macros, known
    as pseudo instructions, also exist. Here are some of the most commonly used:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ABS`: Absolute value – translates into a combination of `ADDU`, `BGEZ`, and
    `SUB`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BLT`: Branch on less than – translates into a combination of `SLT` and `BNE`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BGT/BGE/BLE`: Similar to `BLT`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LI/LA`: Load immediate/address – translates into a combination of `LUI` and
    `ORI` or `ADDIU` for a 16-bit LI'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MOVE`: Moves the content of one register into another – translates into `ADD/ADDIU`
    with a zero value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NOP`: No operation – translates into `SLL` with zero values'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NOT`: Logical NOT – translates into `NOR`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Diving deep into PowerPC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**PowerPC** stands for **Performance Optimization With Enhanced RISC—Performance
    Computing** and is sometimes spelled as PPC. It was created in the early 1990s
    by the alliance of Apple, IBM, and Motorola (commonly abbreviated as AIM). It
    was originally intended to be used in PCs and powered Apple products, including
    PowerBooks and iMacs, up until 2006\. The CPUs that implement it can also be found
    in game consoles such as Sony PlayStation 3, XBOX 360, and Wii, as well as in
    IBM servers and multiple embedded devices, such as car and plane controllers,
    and even in the famous ASIMO robot. Later, the administrative responsibilities
    were transferred to an open standards body, Power.org, where some of the former
    creators remained members, such as IBM and Freescale. The latter was separated
    from Motorola and later acquired by NXP Semiconductors. The OpenPOWER Foundation
    is a newer initiative by IBM, Google, NVIDIA, Mellanox, and Tyan that aims to
    facilitate collaboration in the development of this technology.'
  prefs: []
  type: TYPE_NORMAL
- en: PowerPC was mainly based on IBM POWER ISA. Later, a unified Power ISA was released,
    which combined POWER and PowerPC into a single ISA that is now used in multiple
    products under the Power Architecture umbrella term.
  prefs: []
  type: TYPE_NORMAL
- en: There are plenty of IoT malware families that have payloads for this architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Basics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Power ISA is divided into several categories; each category can be found
    in a certain part of the specification or book. CPUs implement a set of these
    categories, depending on their class; only the base category is an obligatory
    one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a list of the main categories and their definitions in the latest second
    standard:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Base**: Covered in Book I *(Power ISA User Instruction Set Architecture*)
    and Book II (*Power ISA Virtual Environment Architecture*)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Server**: Covered in Book III-S (*Power ISA Operating Environment Architecture
    –Server Environment*)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Embedded**: Covered in Book III-E (*Power ISA Operating Environment Architecture
    – Embedded Environment*)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are many more granular categories that cover aspects such as floating-point
    operations and caching for certain instructions.
  prefs: []
  type: TYPE_NORMAL
- en: Another book, Book VLE (*Power ISA Operating Environment Architecture – Variable
    Length Encoding (VLE) Instructions Architecture*), defines alternative instructions
    and definitions intended to increase the density of the code by using 16-bit instructions
    as opposed to the more common 32-bit ones.
  prefs: []
  type: TYPE_NORMAL
- en: Power ISA version 3 consists of three books with the same names as Books I to
    III of the previous standards, without distinctions between environments.
  prefs: []
  type: TYPE_NORMAL
- en: The processor starts in big-endian mode but can switch it by changing a bit
    in the **Machine State Register** (**MSR**) so that bi-endianness is supported.
  prefs: []
  type: TYPE_NORMAL
- en: 'Many sets of registers are documented in Power ISA, mainly grouped around either
    an associated facility or a category. Here is a basic summary of the most commonly
    used ones:'
  prefs: []
  type: TYPE_NORMAL
- en: 32 GPRs for integer operations, generally used by their number only (64-bit)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '64 **Vector Scalar Registers** (**VSRs**) for vector operations and floating-point
    operations:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 32 **Vector Registers** (**VRs**) as part of the VSRs for vector operations
    (128-bit)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 32 FPRs as part of the VSRs for floating-point operations (64-bit)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Special purpose fixed-point facility registers, such as the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed-point **exception register** (**XER**), which contains multiple status
    bits (64-bit)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Branch facility registers:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Condition Register (CR)**: Consists of eight 4-bit fields, CR0-CR7, involving
    things such as control flow and comparison (32-bit)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Link Register (LR)**: Provides the branch target address (64-bit)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Count Register (CTR)**: Holds a loop count (64-bit)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Target Access Register (TAR)**: Specifies the branch target address (64-bit)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Timer facility registers:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Time Base (TB)**: This is incremented periodically with the defined frequency
    (64-bit)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Other special-purpose registers from a particular category, including the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Accumulator** (**ACC**) (64-bit): The **Signal Processing Engine** (**SPE**)
    category'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Generally, functions can pass all arguments in registers for non-recursive calls;
    additional arguments are passed on the stack.
  prefs: []
  type: TYPE_NORMAL
- en: The instruction set
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Most of the instructions are 32-bit; only the VLE group is smaller to provide
    a higher code density for embedded applications. All instructions are split into
    the following three categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Defined**: All of the instructions are defined in the Power ISA books.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Illegal**: Available for future extensions of the Power ISA. Attempting to
    execute them will invoke the illegal instruction error handler.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reserved**: Allocated to specific purposes that are outside the scope of
    the Power ISA. Attempting to execute them will either result in an implemented
    action or invoke the illegal instruction error handler if the implementation is
    not available.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Bits 0 to 5 always specify the opcode, and many instructions also have an extended
    opcode. A large number of instruction formats are supported; here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: I-FORM [OPCD+LI+AA+LK]
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: B-FORM [OPCD+BO+BI+BD+AA+LK]
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Each instruction field has an abbreviation and meaning; it makes sense to consult
    the official Power ISA document to get a full list of them and their corresponding
    formats. In terms of I-FORM, they are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**OPCD**: Opcode'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**LI**: Immediate field used to specify a 24-bit signed two’s complement integer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**AA**: Absolute address bit'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**LK**: Link bit affecting the link register'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Instructions are also split into groups according to the associated facility
    and category, making them very similar to registers:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Branch instructions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`b/ba/bl/bla`: Branch'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bc/bca/bcl/bcla`: Branch conditional'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sc`: System call'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Fixed-point instructions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lbz`: Load byte and zero'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stb`: Store byte'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`addi`: Add immediate'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ori`: OR immediate'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Floating-point instructions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fmr`: Floating move register'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lfs`: Load floating-point single'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stfd`: Store floating-point double'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'SPE instructions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`brinc`: Bit-reversed increment'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Covering the SuperH assembly
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'SuperH, often abbreviated as SH, is a RISC ISA developed by Hitachi. SuperH
    went through several iterations, starting from SH-1 and moving up to SH-4\. The
    more recent SH-5 has two modes of operation, one of which is identical to the
    user-mode instructions of SH-4, while another, SHmedia, is quite different. Each
    family has a market niche:'
  prefs: []
  type: TYPE_NORMAL
- en: '**SH-1**: Home appliances'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SH-2**: Car controllers and video game consoles such as Sega Saturn'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SH-3**: Mobile applications such as car navigators'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SH-4**: Car multimedia terminals and video game consoles such as Sega Dreamcast'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SH-5**: High-end multimedia applications'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Microcontrollers and CPUs that implement it are currently produced by Renesas
    Electronics, a joint venture of the Hitachi and Mitsubishi Semiconductor groups.
    As IoT malware mainly targets SH-4-based systems, we will focus on this SuperH
    family.
  prefs: []
  type: TYPE_NORMAL
- en: Basics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In terms of registers, SH-4 offers the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 16 general registers R0-R15 (32-bit)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Seven control registers (32-bit):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Global Base Register** (**GBR**)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Status Register** (**SR**)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Saved Status Register** (**SSR**)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Saved Program Counter** (**SPC**)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Vector Base Counter** (**VBR**)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Saved General Register 15** (**SGR**)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Debug Base Register** (**DBR**) (only from the privileged mode)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Four system registers (32-bit):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**MACH/MACL**: Multiply-and-accumulate registers'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PR**: Procedure register'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PC**: Program counter'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**FPSCR**: Floating-point status/control register'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 32 FPU registers – that is, FR0-FR15 (also known as DR0/2/4/... or FV0/4/...)
    and XF0-XF15 (also known as XD0/2/4/... or XMTRX); two banks of either 16 single-precision
    (32-bit) or eight double-precision (64-bit) FPRs and **FPULs** (**floating-point
    communication registers**) (32-bit)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Usually, R4-R7 are used to pass arguments to a function with the result returned
    in R0\. R8-R13 are saved across multiple function calls. R14 serves as the frame
    pointer, while R15 serves as the stack pointer.
  prefs: []
  type: TYPE_NORMAL
- en: Regarding the data formats, in SH-4, a word takes 16 bits, a long word takes
    32 bits, and a quadword takes 64 bits.
  prefs: []
  type: TYPE_NORMAL
- en: 'Two processor modes are supported: user mode and privileged mode. SH-4 generally
    operates in user mode and switches to privileged mode in case of an exception
    or an interrupt.'
  prefs: []
  type: TYPE_NORMAL
- en: The instruction set
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SH-4 features an instruction set that is upward-compatible with the SH-1, SH-2,
    and SH-3 families. It uses 16-bit fixed-length instructions to reduce the program
    code’s size. Except for `BF` and `BT`, all branch instructions and `RTE` (the
    return from exception instruction) implement so-called delayed branches, where
    the instruction following the branch is executed before the branch destination
    instruction.
  prefs: []
  type: TYPE_NORMAL
- en: 'All instructions are split into the following categories (with some examples):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Fixed-point transfer instructions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MOV`: Move data (or particular data types specified)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SWAP`: Swap register halves'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Arithmetic operation instructions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SUB`: Subtract binary numbers'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CMP/EQ`: Compare conditionally (in this case, on equal to)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Logic operation instructions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AND`: Logical AND'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`XOR`: Exclusive logical OR'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Shift/rotate instructions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ROTL`: Rotate left'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SHLL`: Shift logical left'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Branch instructions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BF`: Branch if false'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`JMP`: Jump (unconditional branch)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'System control instructions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LDC`: Load to control register'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`STS`: Store system register'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Floating-point single-precision instructions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FMOV`: Floating-point move'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Floating-point double-precision instructions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FABS`: Floating-point absolute value'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Floating-point control instructions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LDS`: Load to FPU system register'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Floating-point graphics acceleration instructions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FIPR`: Floating-point inner product'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with SPARC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Scalable Processor Architecture** (**SPARC**) is a RISC ISA that was originally
    developed by Sun Microsystems (now part of the Oracle corporation). The first
    implementation was used in Sun’s own workstation and server systems. Later, it
    was licensed to multiple other manufacturers, one of them being Fujitsu. As Oracle
    terminated SPARC Design in 2017, all future development continued with Fujitsu
    as the main provider of SPARC servers.'
  prefs: []
  type: TYPE_NORMAL
- en: Several fully open source implementations of the SPARC architecture exist. Multiple
    OSs currently support it, including Oracle Solaris, Linux, and BSD systems, and
    multiple IoT malware families have dedicated modules for it as well.
  prefs: []
  type: TYPE_NORMAL
- en: Basics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'According to the Oracle SPARC architecture documentation, the implementation
    may contain between 72 and 640 general-purpose 64-bit R registers. However, only
    31/32 GPRs are immediately visible at any one time; eight are global registers,
    R[0] to R[7] (also known as g0-g7), with the first register, g0, hardwired to
    0; 24 are associated with the following register windows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Eight in registers in[0]-in[7] (R[24]-R[31])**: For passing arguments and
    returning results'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Eight local registers local[0]-local[7] (R[16]-R[23])**: For retaining local
    variables'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Eight out registers out[0]-out[7] (R[8]-R[15])**: For passing arguments and
    returning results'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `CALL` instruction writes its address into the out[7] (R[15]) register.
  prefs: []
  type: TYPE_NORMAL
- en: To pass arguments to the function, they must be placed in the out registers.
    When the function gains control, it will access them in its registers. Additional
    arguments can be provided through the stack. The result is placed in the first
    register, which then becomes the first out register when the function returns.
    The `SAVE` and `RESTORE` instructions are used in this switch to allocate a new
    register window and restore the previous one, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: SPARC also has 32 single-precision FPRs (32-bit), 32 double-precision FPRs (64-bit),
    and 16 quad-precision FPRs (128- bit), some of which overlap.
  prefs: []
  type: TYPE_NORMAL
- en: 'Apart from that, many other registers serve specific purposes, including the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**FPRS**: Contains the FPU mode and status information'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ancillary state registers (ASR 0, ASR 2-6, ASR 19-22, and ASR 24-28 are not
    reserved)**: These serve multiple purposes, including the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ASR 2**: **Condition Codes Register (CCR)**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ASR 5**: PC'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ASR 6**: FPRS'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ASR 19**: **General Status Register** (**GSR**)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Register-Window PR state registers** (**PR 9-14**): These determine the state
    of the register windows, including the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PR 9**: Current Window Pointer (CWP)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PR 14**: Window State (WSTATE)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Non-register-Window PR state registers (PR 0-3, PR 5-8, and PR 16)**: Visible
    only to software running in privileged mode'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 32-bit SPARC uses big-endianness, while 64-bit SPARC uses big-endian instructions
    but can access data in any order. SPARC also uses the notion of traps, which implement
    a transfer of control to privileged software using a dedicated table that may
    contain the first eight instructions (32 for some frequently used traps) of each
    trap handler. The base address of the table is set by software in a **Trap Base
    Address** (**TBA**) register.
  prefs: []
  type: TYPE_NORMAL
- en: The instruction set
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The instruction from the memory location, which is specified by the PC, is fetched
    and executed. Then, new values are assigned to the PC and the **Next Program Counter**
    (**NPC**), which is a pseudo-register.
  prefs: []
  type: TYPE_NORMAL
- en: 'Detailed instruction formats can be found in the individual instruction descriptions.
    Here are the basic categories of instructions supported, with examples:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Memory access:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LDUB`: Load unsigned byte'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ST`: Store'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Arithmetic/logical/shift integers:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ADD`: Add'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SLL`: Shift left logical'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Control transfer:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BE`: Branch on equal'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`JMPL`: Jump and link'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CALL`: Call and link'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RETURN`: Return from the function'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'State register access:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WRCCR`: Write CCR'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Floating-point operations:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FOR`: Logical OR for F registers'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Conditional move:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MOVcc`: Move if the condition is true for the selected condition code (cc)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Register window management:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SAVE`: Save the caller’s window'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FLUSHW`: Flush register windows'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FPSUB`: Partitioned integer subtraction for F registers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moving from assembly to high-level programming languages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Developers mostly don’t write in assembly. Instead, they write in higher-level
    languages, such as C or C++, and the compiler converts this high-level code into
    a low-level representation in assembly language. In this section, we will look
    at different code blocks represented in the assembly.
  prefs: []
  type: TYPE_NORMAL
- en: Arithmetic statements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s look at different C statements and how they are represented in the assembly.
    We will use Intel IA-32 for this example. The same concept applies to other assembly
    languages as well:'
  prefs: []
  type: TYPE_NORMAL
- en: 'X = 50 (assuming 0x00010000 is the address of the X variable in memory):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'X = Y + 50 (assuming 0x00010000 represents X and 0x00020000 represents Y):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'X = Y + (50 * 2):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'X = Y + (50 / 2):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'X = Y + (50 % 2) (% represents the modulo):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Hopefully, this explains how the compiler converts these arithmetic statements
    into assembly language.
  prefs: []
  type: TYPE_NORMAL
- en: If conditions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Basic *if* statements may look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If (X == 50) (assuming 0x0001000 represents the X variable):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If (X & 00001000b) (| represents the logical AND):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To understand the branching and flow redirection, let’s look at the following
    diagram, which shows how it’s manifested in pseudocode:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.9 – Conditional ﬂow redirection'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.9_B18500.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.9 – Conditional ﬂow redirection
  prefs: []
  type: TYPE_NORMAL
- en: 'To apply this branching sequence in assembly, the compiler uses a mix of conditional
    and unconditional jumps, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'IF.. THEN.. ENDIF:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'IF.. THEN.. ELSE.. ENDIF:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: While loop conditions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The *while* loop conditions are quite similar to *if* conditions in terms of
    how they are represented in assembly:'
  prefs: []
  type: TYPE_NORMAL
- en: '| While (X == 50) {…} | `1st_Block:``cmp dword ptr [00010000h], 50``jnz 2nd_Block
    ; if not true``…``jmp 1st_Block``2nd_Block:``…` |'
  prefs: []
  type: TYPE_TB
- en: '| Do {} While(X == 50) | `1st_Block:``…``cmp dword ptr [00010000h], 50``jz
    1st_Block ; if true` |'
  prefs: []
  type: TYPE_TB
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered the essentials of computer programming and described
    the universal elements that are shared between multiple CISC and RISC architectures.
    Then, we went through multiple assembly languages, including the ones behind Intel
    x86, ARM, MIPS, and others, and understood their application areas, which eventually
    shaped their design and structure. We also covered the fundamental basics of each
    of them, learned about the most important notions (such as the registers used
    and CPU modes supported), got an idea of how the instruction sets look, discovered
    what opcode formats are supported there, and explored what calling conventions
    are used. Finally, we went from the low-level assembly languages to their high-level
    representations in C or other similar languages and became familiar with a set
    of examples for universal blocks, such as if conditions and loops.
  prefs: []
  type: TYPE_NORMAL
- en: After reading this chapter, you should be able to read the disassembled code
    of different assembly languages and understand what high-level code it could represent.
    While not aiming to be completely comprehensive, the main goal of this chapter
    is to provide a strong foundation, as well as a direction that you can follow
    to deepen your knowledge before you analyze actual malicious code. It should be
    your starting point for learning how to perform static code analysis on different
    platforms and devices.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 3*](B18500_03.xhtml#_idTextAnchor084), *Basic Static and Dynamic
    Analysis for x86/x64*, we will start analyzing the actual malware for particular
    platforms. The instruction sets we have become familiar with will be used as languages
    that describe their functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Part 2 Diving Deep into Windows Malware
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With Windows remaining the most prevalent operating system for the PC, it is
    no surprise that the vast majority of existing malware families are focused on
    this platform. Moreover, the amount of attention and the high number of high-profile
    actors has led to Windows malware featuring multiple diverse and sophisticated
    techniques not common to other systems. Here, we will cover them in great detail
    and teach you how to analyze them using multiple real-world examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section are the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 3*](B18500_03.xhtml#_idTextAnchor084)*, Basic Static and Dynamic
    Analysis for x86/x64*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 4*](B18500_04.xhtml#_idTextAnchor238)*, Unpacking, Decryption, and
    Deobfuscation*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 5*](B18500_05.xhtml#_idTextAnchor446)*, Inspecting Process Injection
    and API Hooking*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 6*](B18500_06.xhtml#_idTextAnchor554)*, Bypassing Anti-Reverse Engineering
    Techniques*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 7*](B18500_07.xhtml#_idTextAnchor669)*, Understanding Kernel-Mode
    Rootkits*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
