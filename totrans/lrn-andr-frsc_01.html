<html><head></head><body><div><h1 class="header-title">Introducing Android Forensics</h1>
                
            
            
                
<p>Mobile forensics is a branch of digital forensics that is evolving in today's digital era and is constantly changing as new phones are released and operating systems are updated. Android forensics deals with extracting, recovering, and analyzing data present on an Android device through various techniques. Due to the open nature of the Android operating system, these forensic techniques and methods can apply to more than just mobile phones: refrigerators, vehicle entertainment units, televisions, watches, and many more devices run Android.</p>
<p>It's important to have a clear understanding of the platform and other fundamentals before we dive in and find out how to extract data. In this chapter, we'll cover the following:</p>
<ul>
<li>Mobile forensics</li>
<li>The mobile forensics approach</li>
<li>Challenges in mobile forensics</li>
<li>Android architecture</li>
<li>Android security</li>
<li>Android hardware components</li>
<li>Android boot process</li>
</ul>
<p>The world today is experiencing technological innovation like never before, and this growth is almost exponential in the field of mobile devices. Gartner, a technology research and advisory firm, in their forecasts published in January 2018, estimated that mobile phone shipments in 2017 totaled 2.28 billion units and would increase to 2.32 billion in 2018. This statistic alone reflects the unprecedented growth of mobile devices. Mobile phones have not only increased in number but also have become more sophisticated in terms of functionality. The increase of mobile phone subscribers from 1997 to 2018 is significantly high.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>You probably don't need to be told that smartphones are an increasingly large subset of mobile phones. The improvements in the computing power and data storage of these devices enable us to perform a wide range of activities, and we are increasingly becoming dependent on these mobile devices. Apart from performing routine tasks such as making calls and sending messages, and so on, these devices also support other activities such as sending emails, surfing the internet, recording videos, creating and storing documents, identifying locations with <strong>Global Positioning System</strong> (<strong>GPS</strong>) services, and managing business tasks. In other words, mobile devices are now repositories of sensitive personal information.</p>
<p>Quite often, the data sitting in a device is more valuable than the device itself. Imagine a case involving the smartphone of a suspected terrorist; how useful would it be for law enforcement to access every contact, call, SMS, or email that the suspect had sent or received? Or, perhaps even better, every location that the phone had been? While much of this data is generally available through the service provider, that often requires additional warrants or subpoenas and can take a significant amount of time. And consider third-party applications; WhatsApp chat content, for example, is end-to-end encrypted, and no amount of subpoenas to Facebook can recover that data. This book will show you how to recover data, such as WhatsApp chats, that may not be recoverable through any other method. The fact that mobile forensics played a crucial role in solving cases such as the 2010 Times Square car bombing attempt and Boston marathon bombings, reaffirms the increasing role of mobile forensics in solving many cases.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Mobile forensics</h1>
                
            
            
                
<p>Mobile device forensics is a branch of digital forensics that deals with extracting, recovering, and analyzing digital evidence or data from a mobile device under forensically sound conditions. Simply put, it deals with accessing the data stored on devices, which includes SMS, contacts, call records, photos, videos, documents, application files, browsing history, and so on, and recovering data deleted from devices using various forensic techniques. It is important that the process of recovering or accessing details from a device is forensically sound if it has to be admitted in a court of law and to maintain the integrity of the evidence. If the evidence has to be admitted in a court of law, it's important to work only on the image file and not on the original device itself.</p>
<p class="mce-root"/>
<div><p>The term <em>forensically sound</em> is often used in the digital forensics community to clarify the correct use of a particular forensic technology or methodology. Mobile forensics, especially Android forensics, is evolving fast, owing to the fact that it has a total the market share of 85 percent (as per market research firm, IDC).</p>
</div>
<p>As explained by Eoghan Casey, in his book <em>Digital Forensics and Investigation</em>, forensic soundness is not just about keeping the original evidence unaltered. Even the routine task of acquiring data from a hard drive using a hardware write blocker may cause alterations (for example, making a hidden area of the hard drive accessible) on the drive. One of the keys to forensic soundness is documentation. Documenting how the device is handled from the beginning is very important. Hence, an investigation can be considered forensically sound if the acquisition process preserves the original data and its authenticity and integrity can be validated. Evidence integrity checks ensure that the evidence has not been tampered  with from the time it was collected. Integrity checks are done by comparing the digital fingerprint of the evidence taken at the time of collection with the digital fingerprint of the evidence in its current state.</p>
<p>There is a growing need for mobile forensics due to several reasons, some of which include the following:</p>
<ul>
<li>Use of mobile phones to store personal information</li>
<li>Increased use of mobile phones to perform online activities</li>
<li>Use of mobile phones in several crimes</li>
</ul>
<p>Mobile forensics on a particular device is primarily dependent on the underlying operating system. Hence, we have different fields such as Android forensics, iOS forensics, and so on.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">The mobile forensics approach</h1>
                
            
            
                
<p>Once the data is extracted from a device, different methods of analysis are used based on the underlying case. As each investigation is distinct, it is not possible to have a single definitive procedure for all of the cases. However, the overall process can be broken down into five phases, as shown in the following diagram:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-546 image-border" src="img/25998d33-34b3-45b8-9a26-ad0847a4405e.png" style="width:17.67em;height:29.75em;" width="456" height="768"/></p>
<p>The following section discusses each phase in detail.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Investigation preparation</h1>
                
            
            
                
<p>This phase begins when a request for examination is received. It involves preparing all of the paperwork and forms required to document chain of custody, ownership information, device model, purpose, information that the requestor is seeking, and so on. Chain of custody refers to the chronological documentation or paper trail, showing the seizure, custody, control, transfer, analysis, and disposition of physical or electronic evidence. From the details submitted by the requestor, it's important to have a clear understanding of the objective for each examination.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Seizure and isolation</h1>
                
            
            
                
<p>Handling the device during seizure is one of the important steps while performing forensic analysis. The evidence is usually transported using anti-static bags, which are designed to protect electronic components against damage produced by static electricity. As soon as the device is seized, care should be taken to make sure that our actions don't result in any data modification on the device. At the same time, any opportunity that can aid the investigation should also not be missed. The following are some of the points that need to be considered while handling an Android device during this phase:</p>
<ul>
<li>With increasing user awareness of security and privacy, most devices now have screen lock enabled. During the time of seizure, if there is a chance (for instance, the phone is recovered unlocked), disable the passcode. Some of the devices don't ask the user to reenter the passcode while disabling the lock screen option.</li>
<li>If the device is unlocked, try to change the settings of the device to allow greater access to the device. The following are some of the settings that can be considered to achieve this:
<ul>
<li><strong>Enable USB debugging</strong>: Enabling this option gives greater access to the device through the <strong>Android Debug Bridge</strong> (<strong>ADB</strong>) connection. We are going to cover the ADB in detail in <a href="b81853c6-388b-4e15-b8dd-deb5c1b5b36d.xhtml" target="_blank">Chapter 2</a>, <em>Setting Up the Android Forensic Environment</em>. This will greatly aid the forensic investigator during the data extraction process. In Android devices, this option is usually found under Settings | Developer options, as shown in the following screenshot. On newer Android versions starting from 4.2, developer options are hidden by default. To enable them, navigate to Settings | About Phone (or <strong>Settings | System | About Phone</strong> on Android 8.0 or higher)and tap on the Build number seven times. </li>
<li><strong>Enable the Stay Awake setting</strong>: Enabling this option and charging the device will make the device stay awake; in other words, it doesn't get locked. In Android devices, this option is usually found under Settings | Developer options, as shown in the following screenshot:</li>
</ul>
</li>
</ul>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-539 image-border" src="img/38bd1af0-c2c8-4b6a-b8bb-170501540b49.png" style="width:23.42em;height:46.83em;" width="476" height="953"/></p>
<ul>
<li style="list-style-type: none">
<ul>
<li><strong>Increase screen timeout</strong>: This is the time for which the device will be active once it is unlocked. Depending on the device model, this time can be set up to 30 minutes. In most devices, it can be accessed under Settings | Display | Screen Timeout.</li>
</ul>
</li>
</ul>
<div><p>Please note that the location to access these items changes across different versions and models of Android phones and may not be available in all versions.</p>
</div>
<p>In mobile forensics, it is of crucial importance to protect the seized device so that our interaction with the evidence (or, for that matter, an attacker's attempt to remotely interact with the device) doesn't change the evidence. In computer forensics, we have software and hardware write blockers that can perform this function. But in mobile forensics, since we need to interact with the device to pull the data, these write blockers are not of any use. Another important aspect is that we also need to prevent the device from interacting with a wireless radio network. As mentioned earlier, there is a high probability that an attacker can issue remote wipe commands to delete all of the data including emails, applications, photos, contacts, and other files on the device.</p>
<p>The Android Device Manager and several other third party apps allow the phone to be remotely wiped or locked. This can be done by signing into the Google account that is configured on the mobile. Using this software, an attacker can also locate the device that could pose a security risk. For all of these reasons, isolating the device from all communication sources is very important.</p>
<div><p>Have you thought about remote wipe options without using the internet? <strong>Mobile Device Management</strong> (<strong>MDM</strong>) software, commonly used by companies to manage corporate devices, can provide remote wipe features just by sending an SMS. Isolating the device from all communication options is crucial.</p>
</div>
<p>To isolate the device from a network, we can put the device in Airplane mode if we have access to the device. Airplane mode disables a device's wireless transmission functions such as cellular radio, Wi-Fi, and Bluetooth. However, as Wi-Fi is now available in airplanes, some devices now allow Wi-Fi access in Airplane mode. The following screenshot shows the quick settings available by dragging down the top menu bar from the lock screen:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-540 image-border" src="img/786c71a1-7796-49eb-81bb-2a12aa009c3a.png" style="width:21.25em;height:42.50em;" width="657" height="1315"/></p>
<p>Note that these toggles are customizable and may not be available on every device; some devices may also require the device to be unlocked to make these changes.</p>
<p>An alternate solution would be to use a Faraday bag or RF isolation box, as both effectively block signals to and from the mobile phone. One concern with these isolation methods is that, once they're employed, it is difficult to work with the phone because you cannot see through it to use the touchscreen or keypad. For this reason, Faraday tents and rooms exist, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-357 image-border" src="img/a0a74bbc-b4c9-4eac-a022-fa5e6bb3f328.png" style="width:19.75em;height:14.83em;" width="1217" height="914"/></p>
<p> </p>
<p>Even after taking all of these precautions, certain automatic functions such as alarms can still trigger. If such a situation is encountered, it must be properly documented.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">The acquisition phase</h1>
                
            
            
                
<p>The acquisition phase refers to extraction of data from the device. Due to the inherent security features of mobile devices, extracting the data is not always straightforward. The extraction method is decided largely depending on the operating system, make, and model. The following are the types of acquisition methods that can be used to extract data from a device:</p>
<ul>
<li><strong>Manual acquisition</strong> is the simplest of all of the acquisition methods. The examiner uses the user interface of the phone to browse and investigate. No special tools or techniques are required here, but the limitation is that only the files and data visible through the normal user interface can be extracted. Data extracted through other methods can also be verified using this. It should be noted that this option can very easily modify data on the device (for instance, opening an unread SMS will mark it as read), so these changes should be documented as thoroughly as possible.</li>
<li><strong>Logical acquisition</strong>, also called <strong>logical extraction</strong>, generally refers to extracting the files that are present on a logical store such as a file system partition. This involves obtaining data types such as text messages, call history, and pictures from a phone. The logical extraction technique works by using the original equipment manufacturer <strong>Applications Programming Interfaces</strong> (<strong>APIs</strong>) for synchronizing the phone's contents with a computer. This technique usually involves extracting the following evidence:
<ul>
<li>Call logs</li>
<li>SMS</li>
<li>MMS</li>
<li>Browser history</li>
<li>People</li>
<li>Contact methods</li>
<li>Contacts extensions</li>
<li>Contacts groups</li>
<li>Contacts phones</li>
<li>Contacts setting</li>
<li>External Image Media (metadata)</li>
<li>External Image Thumbnail Media (metadata)</li>
<li>External Media, Audio, and Misc. (metadata)</li>
<li>External Videos (meta data)</li>
<li>MMSParts (includes full images sent via MMS)</li>
<li>Location details (GPS data)</li>
<li>Internet activity</li>
<li>Organizations</li>
<li>List of all applications installed and their versions</li>
<li>Social networking app data such as WhatsApp, Skype, and Facebook</li>
</ul>
</li>
<li><strong>File System acquisition</strong> is a logical procedure and generally refers to the extraction of a full file system from a mobile device. File system acquisition can sometimes help in recovering the contents (stored in SQLite files) that are deleted from the device.</li>
<li><strong>Physical acquisition</strong> involves making a bit-for-bit copy of an entire flash storage device, equivalent to a full image of a hard drive. The data extracted using this method is usually in the form of raw data (as a hexadecimal dump) that can then be further parsed to obtain file system information or human-readable data. Since all investigations are performed on this image, this process also ensures that an original evidence is not altered.</li>
</ul>


            

            
        
    </div>



  
<div><h1 class="header-title">Examination and analysis</h1>
                
            
            
                
<p>In this phase, different software tools are used to extract the data from the memory image. In addition to the tools, an investigator may also need the help of a hex editor, as tools do not always extract all of the data. There is no single tool that can be used in all cases. Hence, examination and analysis requires a sound knowledge of various file systems, file headers, and so on.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Reporting</h1>
                
            
            
                
<p>Documentation of the examination should be done throughout the process, noting down what was done in each phase. The following are a few points that might be documented by an examiner:</p>
<ul>
<li>The date and time the examination started</li>
<li>The physical condition of the phone</li>
<li>The status of the phone when received (ON/OFF)</li>
<li>The make, model, and operating system of the phone</li>
<li>Pictures of the phone and individual components</li>
<li>The tools used during the investigation (including the version number)</li>
<li>Data documented during the examination</li>
</ul>
<p>The data extracted from the mobile device should be clearly presented to the recipient so that it can be imported into other software for further analysis. In the case of civil or criminal cases, wherever possible, pictures of data as it existed on the cellular phone should be collected, as they are visually compelling to a jury.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Challenges in mobile forensics</h1>
                
            
            
                
<p>With the increased usage of Android devices and the wider array of communication platforms they support, the demand for forensic examination automatically has grown. While working with mobile devices, forensic analysts face a number of challenges. The following points shed light on some of the <strong>mobile forensics challenges</strong> faced today:</p>
<ul>
<li><strong>Preventing data alteration on the device</strong>: One of the fundamental rules to remember in forensics is to preserve the original evidence. In other words, the forensic techniques that are applied on a device to extract any information should not alter the data present on the device. However, this is usually not practical with respect to mobile forensics because simply switching on a device might also change certain state variables present on the device. With mobile devices, background processes always run, and a sudden transition from one state to another can result in the loss or modification of data. Hence, there's a chance that data may be altered either intentionally or unintentionally by the forensic analyst. Apart from this, there is a high possibility that an attacker (or the user) can remotely change or delete the contents of the device. As mobile phones use different communication channels (cellular, Wi-Fi, Bluetooth, infrared, and so on), the possibility of communicating through them should be eliminated. Features such as remote data wiping would enable an attacker to remotely wipe the entire device just by sending an SMS or by simply pressing a button that sends a wipe request to the Android device. Unlike computer forensics, mobile device forensics requires more than just isolating the device from the network, and <em>phones cannot always be left powered off during examination</em>.</li>
<li><strong>The wide range of operating systems and device models</strong>: The wide range of mobile operating systems available in the market makes the life of a forensic analyst more difficult. Although Android is the most dominant operating system in the mobile world, there are mobile devices that run on other operating systems including iOS, Blackberry, and Windows, that are often encountered during investigations. Also, for a given operating system, there are millions of mobile devices available that differ in OS versions, hardware, and various other features. Based on manufacturer, the approach to acquire forensic artifacts changes. To remain competitive, manufacturers release new models and updates so rapidly that it's hard to keep a track of all of them. Sometimes, within the same operating system the data storage options and file structures also change, making it even more difficult. There's no single tool that can work on all the available types of mobile operating systems. Hence, it is crucial for forensic analysts to remain updated on all of the latest changes and techniques, and to understand the underlying concepts in this book so they can succeed when the tools fail.</li>
<li>
<p><strong>Inherent security features</strong>: As the concept of privacy is increasingly gaining importance, mobile manufacturers are moving towards implementing robust security controls on devices, which complicates the process of gaining access to the data. For example, if the device is passcode protected, the forensic investigator has to first find a way to bypass the passcode. Similarly, full disk encryption mechanisms implemented on many modern devices prevent law enforcement agencies and forensic analysts from accessing the information on the device. Apple's iPhone encrypts all of the data present on the device by default using hardware keys built into the device. Beginning with Android Nougat, Android forces full disk encryption by default (though it can vary if the OS is modified by the manufacturer). At Google's 2017 I/O conference, they announced that 80% of Android 7.0 Nougat devices were encrypted and 70% used a secure lock screen. These numbers will likely continue to grow as encryption is forced by more manufacturers during the initial setup process. It is very difficult for an examiner to break these encryption mechanisms using techniques such as brute force.</p>
</li>
<li>
<p><strong>Legal issues</strong>: Mobile devices can be involved in crimes that span across the globe and can cross geographical boundaries. In order to tackle these multi-jurisdictional issues, the forensic examiner needs to be aware of the nature of the crime and regional laws.</p>
</li>
</ul>


            

            
        
    </div>



  
<div><h1 class="header-title">Android architecture</h1>
                
            
            
                
<p>Before we proceed with the internals of Android forensics, this section will introduce you to Android as an operating system and will cover various fundamental concepts that need to be understood to gain experience in the area of forensics.</p>
<p>Any operating system (desktop or mobile phone) assumes the responsibility for managing the resources of the system and provides a way for applications to talk to hardware or physical components in order to accomplish certain tasks. The Android operating system is no different. It powers mobile phones, manages memory and processes, enforces security, takes care of networking issues, and so on. Android is open source and most of the code is released under the Apache 2.0 license. Practically, this means mobile phone device manufacturers can access it, freely modify it, and use the software according to the requirements of any device. This is one of the primary reasons for its spread in popularity.</p>
<p>The Android operating system consists of a stack of layers running one above the other. Android architecture can be best understood by taking a look at what these layers are and what they do. The following screenshot (courtesy of <a href="http://developer.android.com">http://developer.android.com</a>), shows the various layers involved in the Android software stack:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-547 image-border" src="img/ac4d6da1-44b1-4485-bb5b-0b0fa9961f32.png" style="width:33.25em;height:48.58em;" width="1248" height="1824"/></p>
<p>Android architecture is in the form of a software stack comprising kernels, libraries, runtime environment, applications, middleware, and services. Each layer of the stack and elements within each layer, are integrated in a way to provide the optimal execution environment for mobile devices. The following sections focus on different layers of the Android stack, starting at the bottom with the Linux kernel.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">The Linux kernel</h1>
                
            
            
                
<p>The Android OS is built on top of the Linux kernel with some architectural changes made by Google. Linux was chosen as it is a portable platform that can be compiled easily on different hardware. The Linux kernel is positioned at the bottom of the software stack and provides a level of abstraction between the device hardware and the upper layers. It also acts as an abstraction layer between the software and hardware present on the device. To understand this better, consider the case of a camera click. What actually happens when you take a photo using the camera button on your mobile device? At some point, the hardware instruction (pressing a button) has to be converted into a software instruction (to take a picture and store it in the gallery). The kernel contains drivers that can facilitate this process. When the camera button click is detected, the instruction goes to the corresponding driver in the kernel, which sends the necessary commands to the camera hardware, similar to what occurs when a key is pressed on a keyboard. In simple terms, the drivers in the kernel control the underlying hardware. As shown in the previous screenshot, the kernel contains drivers related to Wi-Fi, Bluetooth, USB, audio, display, and so on.<br/>
<br/>
All of the core functionalities of Android, such as process management, memory management, security, and networking are managed by the Linux kernel. Linux is a proven platform when it comes to both security and process management. Android has leveraged the existing Linux open source OS to build a solid foundation for its ecosystem. Each version of Android has a different version of the underlying Linux kernel. Currently, Google requires devices shipped with the Android 8.0 Oreo OS to have at least Linux kernel version 4.4.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Hardware abstraction level</h1>
                
            
            
                
<p>The hardware abstraction level or HAL allows the higher level, Java API framework, to work with mobile device's hardware with help of standard interfaces. This can be done thanks to multiple library modules, which provide interfaces for different types of hardware components, like Bluetooth or camera.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Android Runtime</h1>
                
            
            
                
<p>Since Android 5.0 each application runs in its own process and with its own instance of the Android Runtime (ART). It allows run multiple virtual machines on low-memory devices by executing DEX (Dalvik Executable) files. It's important to note that prior to version 5.0 Dalvik was Android Runtime, so applications developed for Dalvik should work when running with ART.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Native C/C++ Libraries</h1>
                
            
            
                
<p>Many core Android system components and services, including those mentioned earlier, like HAL and ART, are built from native code, so they require native libraries written in C and C++. </p>


            

            
        
    </div>



  
<div><h1 class="header-title">Java API Framework</h1>
                
            
            
                
<p>Java API framework allows developers to create applications using modular system components and services as building blocks:</p>
<ul>
<li>View System allows to build application's user interface, and includes lists, grids, text boxes, buttons, and so on.</li>
<li>Resource Manager provides access to non-code components of an application, like localized strings, graphics and layout files.</li>
<li>Notification Manager allows applications to display custom alerts.</li>
<li>Activity Manager manages the lifecycle as applications, and their back stack - the order in which each activity is opened.</li>
<li>Content Providers allows applications to access other applications data, and share their own.</li>
</ul>
<p><a href="http://fp.edu.gva.es/av/pluginfile.php/745396/mod_imscp/content/2/1_overview_of_the_android_architecture.html"/></p>


            

            
        
    </div>



  
<div><h1 class="header-title">The application layer</h1>
                
            
            
                
<p>The topmost layer in the Android stack consists of applications (called <strong>apps</strong>), which are programs that users directly interact with. There are two kinds of apps, as discussed here:</p>
<ul>
<li><strong>System apps</strong>: These are applications that are pre-installed on the phone and are shipped along with the phone. Applications such as default browser, email client, and contacts are examples of system apps. These generally cannot be uninstalled or changed by the user as they are read-only on production devices, though some devices offer the ability to <em>disable</em> these applications. If a system application is disabled, the app and all of its data remain on the device on the system partition, the application icon is simply hidden from the user. These applications can usually be found in the <kbd>/system</kbd> partition. Until Android 4.4 Kit Kat, all apps present under <kbd>/system</kbd> were treated equally. Beginning in Android 4.4, apps installed in <kbd>/system/priv-app/</kbd> are treated as privileged applications and are granted permissions with protection-level signatureOrSystem to privileged apps.</li>
<li><strong>User installed apps</strong>: These are the applications that are downloaded and installed by the user from various distribution platforms such as Google Play. Google Play is the official app store for the Android operating system, where users can browse and download the applications. Based on December 2017 statistics from Statista, there are around 3.5 million Android apps in the Play Store. These apps are present under the <kbd>/data</kbd> partition. More information about how security is enforced between them is discussed in the following sections.</li>
</ul>


            

            
        
    </div>



  
<div><h1 class="header-title">Android security</h1>
                
            
            
                
<p>Android as a platform has certain features built into the architecture that ensure the security of users, applications, and data. Although they help in protecting the data, these security features sometimes prevent investigators from getting access to necessary data. From a forensic perspective, it is first important to understand the inherent security features so that a clear idea is established about what can be or cannot be accessed under normal circumstances. The security features and offerings that are incorporated aim to achieve three things:</p>
<ul>
<li>To protect user data</li>
<li>To protect system resources</li>
<li>To make sure that one application cannot access the data of another application</li>
</ul>
<p>The next sections provide an overview of the key security features in the Android operating system.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Security at OS level through the Linux kernel</h1>
                
            
            
                
<p>The Android operating system is built on top of the Linux kernel. Over the past few decades, Linux has evolved as a secure operating system trusted by many corporations across the world for its security. By having the Linux kernel at the heart of its platform, Android tries to ensure security at the OS level. Also, Android has built a lot of specific code into Linux to include certain features related to the mobile environment. With each Android release the kernel version also has changed. The following table shows Android versions and the corresponding Linux kernel version:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td>
<p><strong>Android version</strong></p>
</td>
<td>
<p><strong>Linux kernel version</strong></p>
</td>
</tr>
<tr>
<td>
<p>1.0</p>
</td>
<td>
<p>2.6.25</p>
</td>
</tr>
<tr>
<td>
<p>1.5</p>
</td>
<td>
<p>2.6.27</p>
</td>
</tr>
<tr>
<td>
<p>1.6</p>
</td>
<td>
<p>2.6.29</p>
</td>
</tr>
<tr>
<td>
<p>2.2</p>
</td>
<td>
<p>2.6.32</p>
</td>
</tr>
<tr>
<td>
<p>2.3</p>
</td>
<td>
<p>2.6.35</p>
</td>
</tr>
<tr>
<td>
<p>3.0</p>
</td>
<td>
<p>2.6.36</p>
</td>
</tr>
<tr>
<td>
<p>4.0</p>
</td>
<td>
<p>3.0.1</p>
</td>
</tr>
<tr>
<td>
<p>4.1</p>
</td>
<td>
<p>3.0.31</p>
</td>
</tr>
<tr>
<td>
<p>4.2</p>
</td>
<td>
<p>3.4.0</p>
</td>
</tr>
<tr>
<td>
<p>4.3</p>
</td>
<td>
<p>3.4.39</p>
</td>
</tr>
<tr>
<td>
<p>4.4</p>
</td>
<td>
<p>3.8</p>
</td>
</tr>
<tr>
<td>
<p>5.0</p>
</td>
<td>
<p>3.16.1</p>
</td>
</tr>
<tr>
<td>
<p>6.0</p>
</td>
<td>
<p>3.18.10</p>
</td>
</tr>
<tr>
<td>
<p>7.0</p>
</td>
<td>
<p>4.4.1</p>
</td>
</tr>
<tr>
<td>
<p>7.1</p>
</td>
<td>
<p>4.4.1</p>
</td>
</tr>
<tr>
<td>
<p>8.0</p>
</td>
<td>
<p>4.10</p>
</td>
</tr>
<tr>
<td>
<p>9.0</p>
</td>
<td>
<p>4.4.107, 4.9.84, and 4.14.42</p>
</td>
</tr>
</tbody>
</table>
<p><br/>
The Linux kernel provides Android with the following key security features:</p>
<ul>
<li>A user-based permissions model</li>
<li>Process isolation</li>
<li>Extensible mechanism for secure IPC</li>
</ul>


            

            
        
    </div>



  
<div><h1 class="header-title">Permission model</h1>
                
            
            
                
<p>Android implements a permission model for individual apps. Applications must declare which permissions (in the manifest file) they require. In older versions of Android, the user was presented with a full list of permissions requested by the application prior to installation.</p>
<p>Newer versions of Android prompt the user the first time each permission is required while the app is in use. This model allows a user to use an app without granting all permissions requested by the application, though functionality may be decreased.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Sample permission model in Android</h1>
                
            
            
                
<p>Unlike a desktop environment, this provides an opportunity for the user to know in advance what resources the application is seeking access to. In other words, user permission is a must to access any kind of critical resource on the device. By looking at the requested permission, the user is more aware of the risks involved in installing the application.</p>
<p>As mentioned before, developers have to identify the permissions in a file named <kbd>AndroidManifest.xml</kbd>. For example, if the application needs to access the internet, the permission <kbd>INTERNET</kbd> is specified using the following code in the <kbd>AndroidManifest.xml</kbd> file:</p>
<pre>&lt;manifest <br/>package="com.example.rohit"&gt;<br/>…<br/>&lt;uses-permission android:name="android.permission.INTERNET" /&gt;<br/>…<br/>&lt;/manifest&gt;</pre>
<p>Android permissions are categorized into four levels:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td>
<p><strong>Permission type</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p>Normal</p>
</td>
<td>
<p>This is the default value. These are low risk permissions and do not pose a risk to other applications, system, or user. This permission is automatically granted to the user without asking for user approval during installation.</p>
</td>
</tr>
<tr>
<td>
<p>Dangerous</p>
</td>
<td>
<p>These are the permissions that can cause harm to the system and other applications. Hence, user approval is necessary during installation.</p>
</td>
</tr>
<tr>
<td>
<p>Signature</p>
</td>
<td>
<p>These are automatically granted to a requesting app if that app is signed by the same certificate as the one that declared/created the permission. This level is designed to allow apps that are part of a suite, or otherwise related, to share data.</p>
</td>
</tr>
<tr>
<td>
<p>Signature/System</p>
</td>
<td>
<p>A permission that the system grants only to applications that are in the Android system image or that are signed with the same certificate as the application that declared the permission.</p>
</td>
</tr>
</tbody>
</table>
<p> </p>


            

            
        
    </div>



  
<div><h1 class="header-title">Application sandboxing</h1>
                
            
            
                
<p>In order to isolate applications from each other, Android takes advantage of the Linux user-based protection model. In Linux systems, each user is assigned a unique <strong>User ID</strong> (<strong>UID</strong>) and users are segregated so that one user does not have access to the data of another. All resources under a particular user are run with the same privileges. Similarly, each Android application is assigned a UID and is run as a separate process. What this means is that, even if an installed application tries to do something malicious, it can do it only within its context and with the permissions it has. This application sandboxing is done at the kernel level. The security between applications and the system at the process level is ensured through standard Linux facilities, such as user and group IDs that are assigned to applications. For example, the following screenshot referenced from <a href="http://www.ibm.com/developerworks/library/x-androidsecurity/">http://www.ibm.com/developerworks/library/x-androidsecurity/ </a>shows the sandbox mechanism:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-541 image-border" src="img/85c3ec30-bf50-4e51-822a-482bcd53a5ce.png" style="width:50.50em;height:32.25em;" width="1612" height="1030"/></p>
<p>By default, applications can't read or access the data of other applications and have limited access to the operating system. If Application A tries to read Application B's data, for example, the operating system protects against this because Application A does not have the appropriate user privileges. Since the application sandbox mechanism is implemented at the kernel level, it applies to both native applications and OS applications. Hence, the operating system libraries, application framework, application runtime, and all applications run within the Application Sandbox. Bypassing this sandbox mechanism would require compromising the security of the Linux kernel.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">SELinux in Android</h1>
                
            
            
                
<p>Starting with Android 4.3, <strong>Security-Enhanced Linux</strong> (<strong>SELinux</strong>) is supported by the Android security model. Android security is based on discretionary access control, which means applications can ask for permissions, and users can grant or deny those permissions. Hence, malware can create havoc on the phones by gaining permissions. Android uses SELinux to enforce mandatory access control that ensures applications work in isolated environments; this includes applications running as root or superuser. Hence, even if a user installs a malicious app, the malware cannot easily access the OS and corrupt the device. SELinux is used to enforce <strong>Mandatory Access Control</strong> (<strong>MAC</strong>) over all of the processes, including the ones running with root privileges. SELinux operates on the principle of <em>default denial</em>. Anything that isn't explicitly allowed is denied. SELinux can operate in one of two global modes: permissive mode, in which permission denials are logged but not enforced, and enforcing mode, in which denials are both logged and enforced. As per Google's documentation, in the Android 5.0 Lollipop release, Android moves to full enforcement of SELinux. This builds upon the permissive release of 4.3 and the partial enforcement of 4.4. In short, Android is shifting from enforcement on a limited set of crucial domains (<kbd>installd</kbd>, <kbd>netd</kbd>, <kbd>vold</kbd>, and <kbd>zygote</kbd>) to everything (more than 60 domains).</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Application signing</h1>
                
            
            
                
<p>All Android apps need to be digitally signed with a certificate before they can be installed on a device. The main purpose of using certificates is to identify the author of an app. These certificates do not need to be signed by a certificate authority, and Android apps often use self-signed certificates. The app developer holds the certificate's private key. Using the same private key, the developer can provide updates to their applications and share data between applications. In debug mode, developers can sign the app with a debug certificate generated by the Android SDK tools. You can run and debug an app signed in debug mode but the app cannot be distributed. To distribute an app, the app needs to be signed with your own certificate. The key store and the private key that are used during this process need to be secured by the developer as they are essential to push updates. The following screenshot shows the key store selection option that is displayed while exporting the application:</p>
<p class="mce-root"/>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-543 image-border" src="img/c6b549f6-c107-414d-b1ac-a8100aa8de57.png" style="width:36.17em;height:37.67em;" width="533" height="556"/></p>


            

            
        
    </div>



  
<div><h1 class="header-title">Secure inter-process communication</h1>
                
            
            
                
<p>As discussed in the previous sections, sandboxing of the apps is achieved by running apps in different processes with different Linux identities. System services run in separate processes and have more privileges. Hence, in order to organize data and signals between these processes, an <strong>Inter-Process Communication</strong> (<strong>IPC</strong>) framework is needed. In Android, this is achieved with the use of the Binder mechanism.</p>
<p>The Binder framework in Android provides the capabilities required to organize all types of communication between various processes. Android application components such as Intents and content providers are also built on top of this Binder framework. Using this framework, it is possible to perform a variety of actions such as invoking methods on remote objects as if they were local, synchronous and asynchronous method invocation, and sending file descriptors across processes. Let's suppose the application in Process A wants to use certain behavior exposed by a Service that runs in Process B. In this case, Process A is the client and Process B is the service. The communication model using Binder is shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-360 image-border" src="img/0158b37e-b70c-4644-83a4-d75b82adbf03.png" style="width:29.83em;height:18.42em;" width="1005" height="619"/></p>


            

            
        
    </div>



  
<div><h1 class="header-title">Binder communication model</h1>
                
            
            
                
<p>All communications between the processes using the Binder framework occur through the Linux kernel driver, <kbd>/dev/binder</kbd>. The permissions to this device driver are set to world readable and writable, meaning any application may write to and read from this device driver. All communications between client and server happen through proxies on the client side and stubs on the server side. The proxies and the stubs are responsible for sending and receiving the data and the commands sent over the Binder driver.</p>
<p>Each service (also called a Binder service) exposed using the Binder mechanism is assigned a token. This token is a 32-bit value and is unique across all processes in the system. A client can start interacting with the service after discovering this value, which can be done with the help of Binder's context manager. Basically, the context manager acts as a name service providing the handle of a service using the name of this service. In order to get this process working, each service must be registered with the context manager. Hence, a client needs to know only the name of a service to communicate.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The name is resolved by the context manager and the client receives the token that is later used for communicating with the service. The Binder driver adds the UID and the PID value of the sender process to each transaction. As discussed earlier, each application in the system has its own UID and hence this value is used to identify the calling party. The receiver of the call may check the obtained values and decide if the transaction should be completed. Hence, the security is enforced and the Binder token acts as a security token as it is unique across all of the processes.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Android hardware components</h1>
                
            
            
                
<p>Android is compatible with a wide range of hardware components. The Linux kernel made this easy, as Linux supports a large variety of hardware. This gives manufacturers a lot of flexibility as they can design based on their requirement without worrying about compatibility. This poses a significant challenge for forensic analysts during investigations. Hence, understanding the hardware components and device types will greatly help in understanding Android forensics.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Core components</h1>
                
            
            
                
<p>The components present in a device change from one manufacturer to another and from one model to another. However, there are some components that are found in most mobile devices. The following sections provide an overview of such commonly found components of an Android device.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Central Processing Unit (CPU)</h1>
                
            
            
                
<p>The CPU, also known as the processor, is responsible for executing everything that happens on a mobile device. It tells the device what to do and how to do it. Its performance is measured based on the number of tasks it can complete per second, known as a <strong>cycle</strong>. For example, a 1 GHz processor can process one billion cycles per second. The higher the capacity of the processor, the smoother the performance of the phone will be. When dealing with smartphones, we come across the following terminologies: ARM, x86 (Intel), MIPS, Cortex, and A5 or A7 or A9. ARM is the name of a company that licenses their architectures (branded Cortex) with different models coming up each year, such as the A series mentioned before. Based on these architectures, chip makers release their own series of chipsets (Snapdragon, Exynos, and so on) that are used in mobile devices. Newer smartphones are powered by dual-core, quad-core, and even octa-core processors.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Baseband processor</h1>
                
            
            
                
<p>Smartphones today support a variety of cellular protocols including GSM, 3G, 4G, and LTE. These protocols are complicated and require a large amount of CPU power to process data, generate packets, and transmit them to the network provider. To handle this process, smartphones now use a <em>baseband modem</em>, which is a separate chip included in smartphones that communicates with the main processor. These baseband modems have their own processor called the <em>baseband processor</em> and run their own operating system. The baseband processor manages several radio control functions such as signal generation, modulation, encoding, as well as frequency shifting. It can also manage the transmission of signals.</p>
<p>The baseband processor is generally located on the same circuit board as the CPU, but consists of a separate radio component.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Memory</h1>
                
            
            
                
<p>Android phones, just like normal computers, use two primary types of memory: RAM and ROM. Although most users are familiar with these concepts, there is some confusion, however, when it comes to mobile devices.</p>
<p>RAM stands for Random Access Memory. It is volatile, which means contents are deleted when the power is removed. RAM is very fast to access and is used primarily for the runtime memory of software applications (including the device's operating system and any applications). In other words, it is used by the system to load and execute the OS and other applications. The number of applications and processes that can be run simultaneously depends on this RAM size.</p>
<p>ROM (commonly referred to as <strong>Android ROM</strong>) stands for Read-Only Memory. It is non-volatile, which means it retains the contents even when the power is off. The Android ROM contains the boot loader, OS, all of the downloaded applications and their data, settings, and so on.</p>
<p>Note that the part of memory that is used for the boot loader and Android is normally locked and can only be changed through a firmware upgrade. The remaining part of the memory is termed by some of the manufacturers as <em>user memory</em>. The data of each application stored here will not be accessible to other applications. Once this memory gets filled up the device slows down. Both RAM and Android ROM are often manufactured into a single component known as a <strong>Multi-Chip Package</strong> (<strong>MCP</strong>).</p>


            

            
        
    </div>



  
<div><h1 class="header-title">SD Card</h1>
                
            
            
                
<p>The SD card has great significance with respect to mobile forensics because quite often data that is stored on it can be vital evidence and can be accessed even if the device is locked or encrypted. Many Android devices have a removable memory card commonly referred to as a <strong>Secure Digital</strong> (<strong>SD</strong>) card. This is in contrast to Apple's iPhone, which does not have any provision for SD cards. SD cards are non-volatile, which means data is stored in them even when they're powered off. SD cards use flash memory, a type of <strong>Electrically Erasable Programmable Read-Only Memory</strong> (<strong>EEPROM</strong>) that is erased and written in large blocks instead of individual bytes. Most of the multimedia data and large files are stored by the apps in an SD card. In order to interoperate with other devices, SD cards implement certain communication protocols and specifications.</p>
<p>In some mobiles, although an SD card interface is present, some portion of the onboard NAND memory (non-volatile) is carved out for creating an emulated SD card. This essentially means the SD card is not removable. Hence, forensic analysts need to check whether they are dealing with an actual SD card or an emulated SD card. SD memory cards come in several different sizes. The mini-SD card and micro-SD card contain the same underlying technology as the original SD memory card, but are smaller in size.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Display</h1>
                
            
            
                
<p>Mobile phone screens have progressed dramatically over the last few years. The following is a brief description of some of the widely used types of mobile screens.</p>
<ul>
<li><strong>TFT LCD</strong> stands for <strong>Thin Film Transistor Liquid Crystal Display</strong> and is the most common type of screen found in mobile phones. These screens have a light underneath them that shines through the pixels to make them visible.</li>
<li><strong>AMOLED</strong> stands for <strong>Active-Matrix Organic Light-Emitting Diode</strong>; this is a technology based on organic compounds and known for its best image quality while consuming low power. Unlike LCD screens, AMOLED displays don't need a backlight—each pixel produces its own light—so phones using them can potentially be thinner.</li>
</ul>
<p>These are described at <a href="http://www.in.techradar.com/news/phone-and-communications/mobile-phones/Best-phone-screen-display-tech-explained/articleshow/38997644.cms">http://www.in.techradar.com/news/phone-and-communications/mobile-phones/Best-phone-screen-display-tech-explained/articleshow/38997644.cms</a>.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Battery</h1>
                
            
            
                
<p>The battery is the lifeblood of a mobile phone and is one of the major consumer concerns with modern smartphones. The more you use the device and its components, the more battery is consumed. The following are different types of batteries used in mobile phones:</p>
<ul>
<li><strong>Lithium Ion</strong> (<strong>Li-Ion</strong>) batteries are the most popular batteries used in cell phones, as they are light and portable. They are well known for their high energy density and low maintenance. However, they are expensive to manufacture compared to other battery types.</li>
<li><strong>Lithium Polyme</strong><strong>r</strong> (<strong>Li-Poly</strong>) batteries have all of the attributes of a Lithium Ion battery but with ultra slim geometry and simplified packaging. They are the latest technology and found only in few mobile devices.</li>
<li><strong>Nickel Cadmium</strong> (<strong>NiCd</strong>) batteries are old technology batteries and suffer from memory effect. As a result, the overall capacity and life span of the battery are reduced. In addition to this, nickel cadmium batteries are made from toxic materials that are not environmentally friendly.</li>
<li><strong>Nickel Metal Hydride</strong> (<strong>NiMH</strong>) batteries are the same as nickel cadmium batteries, but can contain higher energy and can run for between 30 and 40 percent longer. They still suffer from memory effect but comparatively less than the <strong>Nickel Cadmium</strong> (<strong>NiCd</strong>) Batteries. They are widely used in mobile phones and are affordable.</li>
</ul>
<p>The battery type can be known by looking at the details present on its body.</p>
<p>Often, the SD card is located behind the battery. During forensic analysis, accessing a SD card may require removing the battery, which would power off the device. This can have certain implications that will be discussed in details in later chapters.</p>
<p>Apart from the components described previously, here are some of the other components that are well known:</p>
<ul>
<li><strong>Global Positioning System</strong> (<strong>GPS</strong>)</li>
<li>Wi-Fi</li>
<li><strong>Near Field Communication</strong> (<strong>NFC</strong>)</li>
<li>Bluetooth</li>
<li>Camera</li>
<li>Keypad</li>
<li>USB</li>
<li>Accelerometer and Gyroscope</li>
<li>Speaker</li>
<li>Microphone</li>
</ul>


            

            
        
    </div>



  
<div><h1 class="header-title">Android boot process</h1>
                
            
            
                
<p>Understanding the boot process of an Android device will help us to understand other forensic techniques that involve interacting with the device at various levels. When an Android device is first powered on, there is a sequence of steps that are executed, helping the device to load the necessary firmware, OS, application data, and so on into memory. The following information is compiled from the original post published at <a href="https://community.nxp.com/docs/DOC-102546">https://community.nxp.com/docs/DOC-102546</a>.</p>
<p>The following is the sequence of steps involved in the Android boot process:</p>
<ol>
<li>Boot ROM code execution</li>
<li>The bootloader</li>
<li>The Linux kernel</li>
<li>The init process</li>
<li>Zygote and Dalvik</li>
<li>The system server</li>
</ol>
<p>We will examine each of these steps in detail.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Boot ROM code execution</h1>
                
            
            
                
<p>Before the device is powered on, the device CPU will be in a state where no initializations have been done. Once the Android device is powered on, execution starts with the boot ROM code. This boot ROM code is specific to the CPU the device is using. As demonstrated in the following screenshot, this phase includes two steps, A and B:</p>
<ul>
<li><strong>Step A</strong>: When the boot ROM code is executed, it initializes the device hardware and tries to detect the boot media. Hence, the boot ROM code scans until it finds the boot media. This is almost similar to the BIOS function in the boot process of a computer.</li>
<li><strong>Step B</strong>: Once the boot sequence is established, the initial boot loader is copied to the internal RAM. After this, the execution shifts to the code loaded into RAM:</li>
</ul>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-361 image-border" src="img/644da025-9f5d-4e72-9424-6f284aefa490.png" style="width:36.67em;height:23.67em;" width="1309" height="845"/></p>


            

            
        
    </div>



  
<div><h1 class="header-title">The bootloader</h1>
                
            
            
                
<p>The bootloader is a small program that is executed before the operating system starts to function. Bootloaders are present in desktop computers, laptops, and mobile devices as well. In the Android boot loader, there are two stages—<strong>Initial Program Load</strong> (<strong>IPL</strong>) and <strong>Second Program Load</strong> (<strong>SPL</strong>). As shown in the following screenshot, this involves the three steps explained here:</p>
<ul>
<li><strong>Step A</strong>: IPL deals with detecting and setting up the external RAM.</li>
<li><strong>Step B</strong>: Once the external RAM is available, SPL is copied into the RAM and execution is transferred to it. SPL is responsible for loading the Android operating system. It also provides access to other boot modes such as fastboot and recovery. It initiates several hardware components such as the console, display, keyboard, file systems, virtual memory, and other features.</li>
<li><strong>Step C</strong>: SPL tries to look for the Linux kernel. It will load this from boot media and will copy it to the RAM. Once the boot loader is done with this process, it transfers the execution to the kernel:</li>
</ul>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-362 image-border" src="img/fb3bd857-755a-412c-8572-ae8d85df13a7.png" style="width:37.92em;height:24.50em;" width="1309" height="845"/></p>


            

            
        
    </div>



  
<div><h1 class="header-title">The Linux kernel</h1>
                
            
            
                
<p>The Linux kernel is the heart of the Android operating system and is responsible for process management, memory management, and enforcing security on the device. After the kernel is loaded, it mounts the <strong>root filesystem</strong> (<strong>rootfs</strong>) and provides access to system and user data:</p>
<ul>
<li><strong>Step A</strong>: When the memory management units and caches have been initialized, the system can use virtual memory and launch user space processes.</li>
<li><strong>Step B</strong>: The kernel will look in the <kbd>rootfs</kbd> for the <kbd>init</kbd> process and launch it as the initial user space process:</li>
</ul>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-363 image-border" src="img/c87e3f7e-b4e2-49d0-a159-2a42278e7aa8.png" style="width:36.67em;height:23.67em;" width="1309" height="845"/></p>


            

            
        
    </div>



  
<div><h1 class="header-title">The init process</h1>
                
            
            
                
<p>Init is the very first process that starts and is the root process of all other processes:</p>
<ul>
<li><strong>Step A</strong>: The Init process will look for a script named <kbd>init.rc</kbd>. This is a script that describes the system services, filesystem, and other parameters that need to be set up:
<ul>
<li><kbd>init</kbd> process can be found at: <kbd>&lt;android source&gt;/system/core/init</kbd>.</li>
<li><kbd>init.rc</kbd> can be found at: <kbd>&lt;android source&gt;/system/core/rootdir/init.rc</kbd>.</li>
</ul>
</li>
</ul>
<div><p>More details about the Android file hierarchy will be covered in <a href="615ae74c-4301-46e6-92f2-387637bebd38.xhtml" target="_blank">Chapter 3</a>, <em>Understanding Data Storage on Android Devices</em>.</p>
</div>
<ul>
<li><strong>Step B</strong>: The init process will parse the init script and launch the system service processes. At this stage, you will see the Android logo on the device screen:</li>
</ul>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-364 image-border" src="img/ef609777-8f64-46cc-bc66-7f5fb5d95e32.png" style="width:39.83em;height:25.75em;" width="1309" height="845"/></p>


            

            
        
    </div>



  
<div><h1 class="header-title">Zygote and Dalvik</h1>
                
            
            
                
<p>Zygote is one of the first init processes created after the device boots. It initializes the Dalvik virtual machine and tries to create multiple instances to support each Android process. As discussed in earlier sections, the Dalvik virtual machine is the virtual machine that executes Android applications written in Java.</p>
<p>Zygote facilitates using a shared code across the VM, hence, helping to save the memory and reduce the burden on the system. After this, applications can run by requesting new Dalvik virtual machines. Zygote registers a server socket for zygote connections and preloads certain classes and resources. This zygote loading process has been more clearly explained at <a href="https://elinux.org/Android_Zygote_Startup">https://elinux.org/Android_Zygote_Startup</a>:</p>
<ul>
<li><kbd>Load ZygoteInitclass</kbd>: This loads the <kbd>ZygoteInit</kbd> class.<em><br/></em> Source Code:<kbd><kbd>&lt;Android Source&gt; /frameworks/base/core/java/com/android/internal/os/ZygoteInit.java</kbd></kbd></li>
<li><kbd>registerZygoteSocket()</kbd>: This registers a server socket for <kbd>zygote</kbd> command connections.</li>
<li><kbd>preloadClasses()</kbd>: This is a simple text file containing a list of classes that need to be preloaded will be executed here. This file can be seen at this location: <kbd>&lt;Android Source&gt;/frameworks/base</kbd>.</li>
<li><kbd>preloadResources()</kbd>: This deals with native themes and layouts and everything that includes the <kbd>android.R</kbd> file will be loaded using this method:</li>
</ul>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-365 image-border" src="img/e1482f3a-027c-4a96-ab55-4123a9afed0a.png" style="width:40.33em;height:26.08em;" width="1309" height="845"/></p>


            

            
        
    </div>



  
<div><h1 class="header-title">System server</h1>
                
            
            
                
<p>All of the core features of the device such as telephony, network, and other important functions are started by the system server, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-366 image-border" src="img/5ef41db4-3b8b-46aa-af59-b025c5d1a26d.png" style="width:36.17em;height:24.50em;" width="1309" height="888"/></p>
<p>The following are some of the core services that get started in this process:</p>
<ul>
<li>Start Power Manager</li>
<li>Create Activity Manager</li>
<li>Start Telephony Registry</li>
<li>Start Package Manager</li>
<li>Set Activity Manager Service as System Process</li>
<li>Start Context Manager</li>
<li>Start System Context Providers</li>
<li>Start Battery Service</li>
<li>Start Alarm Manager</li>
<li>Start Sensor Service</li>
<li>Start Window Manager</li>
<li>Start Bluetooth Service</li>
<li>Start Mount Service</li>
</ul>
<p>The system sends a broadcast action called <kbd>ACTION_BOOT_COMPLETED</kbd>, which informs all the dependent processes that the boot process is complete. After this, the device displays the home screen and is ready to interact with the user.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>As explained earlier, several manufacturers use Android operating systems on their devices. Most of these device manufacturers customize the OS based on their hardware and other requirements. When a new version of Android is released, these device manufacturers have to port their custom software and tweaks to the latest version.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Summary</h1>
                
            
            
                
<p>Understanding Android architecture and security model is crucial to having a proper understanding of Android forensics. The inherent security features in Android OS such as application sandboxing and permission models safeguard the device from various threats and pose as an obstacle for forensic experts during an investigation. With this knowledge of Android internals, we will discuss more about what data is stored on the device and how it is stored in the next chapter.</p>


            

            
        
    </div>



  </body></html>