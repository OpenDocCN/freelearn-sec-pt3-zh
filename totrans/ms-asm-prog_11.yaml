- en: Oh, Almost Forgot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our journey approaches its end. However, it is important to make it clear that
    this book only covers the tip of the iceberg called Assembly programming and there
    is much more to learn ahead of you. The main idea of this book is to show you
    how powerful and easy it is to create software in Assembly language and how portable
    and convenient it may be.
  prefs: []
  type: TYPE_NORMAL
- en: There are a few topics that we have not touched over the course of the book,
    but which, nevertheless, deserve attention. One such topic is how we can keep
    our code protected from sneaky eyes. We will shortly see how some of the methods
    of protecting our code may be implemented by means of the Flat Assembler, without
    the need for third-party software.
  prefs: []
  type: TYPE_NORMAL
- en: Another topic, which in my eyes, is interesting and deserves some coverage,
    is how to write code that would be executed in kernel space. We will implement
    a small loadable kernel module for Linux.
  prefs: []
  type: TYPE_NORMAL
- en: Protecting the code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are numerous books, articles, and blog posts on how to better protect
    your code. Some of them are even useful and practical; however, most of them are
    dedicated to certain third-party tools or combinations thereof. We are not going
    to review any of those, neither books nor tools. Instead, we are about to see
    what we are able to do ourselves with the tools we already have.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, we have to assimilate the fact that there is no such thing as
    100% protection for our code. No matter what we do, the more valuable our code
    is, the higher is the possibility that it will be reverse engineered. We may use
    packers, protectors, and whatever other tools we may come up with, but at the
    end, they are all well known and will be bypassed one way or another. Thus, the
    final frontier is the code itself. To put it correctly, it is the way the code
    appears to a potential attacker. This is where the obfuscation comes into play.
  prefs: []
  type: TYPE_NORMAL
- en: The dictionary definition of the word *obfuscation* is the action of making
    something obscure, unclear, or unintelligible. It may be quite a powerful technique,
    whether in conjunction with other approaches or alone. I once had a chance to
    reverse engineer a program that used encryption extensively. This program was
    not protected with any third-party tool, instead there was a very nice and unclear
    (at first glance) game of bits and I have to admit--it was much more difficult
    to reverse engineer than it could have been if any tool like **Themida** was in
    place.
  prefs: []
  type: TYPE_NORMAL
- en: In this part of the chapter, we will see a primitive example of what obfuscation
    may look like by slightly enhancing the patch we made for our Windows-based executable
    with `gets()`. As obfuscation is not the primary topic of the book; we will not
    dive into much detail, but show how simple and tiny changes may make it a bit
    harder to understand the underlying logic of the code without dynamically watching
    it in a debugger.
  prefs: []
  type: TYPE_NORMAL
- en: The original code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s begin by taking a quick look at the original code of the procedure we
    planted into the executable as part of our patch. The code is quite straightforward
    and, knowing what we already know, is easy to read:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The code is rather simple and it is fairly difficult to find anything valuable
    to protect here. Since this is the situation, we will use this example to show
    how simply a `call` instruction may be implemented with other instructions in
    such a way that it would neither point to the callee nor resemble a procedure
    call at all.
  prefs: []
  type: TYPE_NORMAL
- en: The call
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are several ways to replace the `call` instruction with a sequence of
    instructions that would perform exactly the same action but would be treated by
    decompilers in a different manner. For example, the following code would do exactly
    what the `call` instruction does:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We may, as well, replace the following sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'with, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This would still yield the same result. However, we want our obfuscation to
    be a bit stronger; therefore, we proceed and create a macro.
  prefs: []
  type: TYPE_NORMAL
- en: The call obfuscation macro
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Prior to beginning with the obfuscation of the `call` instruction itself, we
    will define a utility macro called `random`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `random` macro generates a pseudo-random integer and returns it in the parameter
    variable. We will need this tiny portion of randomization in order to add some
    diversity to our `call` implementation occurrences. The macro itself (let us call
    it `f_call`) makes use of the EAX register; therefore, we would either take care
    of preserving this register before the `f_call` invocation or only use this macro
    with procedures returning a value in the EAX register as, otherwise, the value
    of the register would be lost. Also, it is only suitable for direct calls due
    to the way it handles the parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'At last, we come to the macro itself. As the best way to understand the code
    is to look at the code, let''s peer into the macro:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As we may see, there are no complex computations involved in this particular
    obfuscation attempt and, even more, the code is still readable and understandable,
    but let's replace the line `call fgets` in our `patch_section.asm` file with `f_call
    fgets`, recompile, and re-apply the patch to the executable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The new patch is significantly bigger--86 bytes instead of 35 bytes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5f288012-fe33-4246-80c1-b705e8fb5fba.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Copy these bytes and paste them into the `Legacy.exe` file at the `0x8e00`
    offset, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f337c9e8-c655-495c-b878-c236aa271c9a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Running the executable, we will obtain the same result as we did in the previous
    chapter, so no visible difference at this stage. However, let''s take a look at
    what the code looks like in the disassembler:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5d016d06-8da9-44af-b2cb-f9902cdd9762.png)'
  prefs: []
  type: TYPE_IMG
- en: We can't say that the code is heavily obfuscated here, but it should give you
    an idea of what may be done with the aid of relatively simple macros used with
    the Flat Assembler. The preceding example may still be read with a tiny effort,
    but the application of a few more obfuscation tricks would render it literally
    unreadable and almost irreversible without a debugger.
  prefs: []
  type: TYPE_NORMAL
- en: A bit of kernel space
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until this very moment, we were only working with user-space code, writing small
    applications. In this part of the chapter, however, we will implement a small
    and very simple **loadable kernel module** (**LKM**) for Linux.
  prefs: []
  type: TYPE_NORMAL
- en: A few years ago, I was engaged in an interesting project, where the objective
    was to spot the data processed by certain kernel module. The project was even
    more challenging due to the fact that, not only did I not have access to the kernel
    sources, I had no access to the kernel itself, not to mention that it was not
    an Intel platform. All I knew was the version of the kernel in question and the
    name and address of the target module.
  prefs: []
  type: TYPE_NORMAL
- en: I had to go a long and interesting way until I was able to build an LKM that
    was capable of doing the work I needed it to do. At the end, I was able to build
    an LKM written in C, but I would not have been myself if I did not try to write
    one in Assembly. It was an unforgettable experience, I have to admit. However,
    once the project was completed, I decided to try to implement a simple LKM on
    my development machine. Since the first module was written for a different platform
    and for a kernel of a different version and taking into account that I decided
    to pretend like I had no sources for my running kernel, I had to perform almost
    as much research and reverse engineering, even though I was writing a module for
    my own system.
  prefs: []
  type: TYPE_NORMAL
- en: LKM structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let me save you from going the same long way of digging for information, reversing
    the structure of other kernel modules and examining kernel sources in order to
    see how exactly a module is loaded. Instead, let us proceed directly to the structure
    of an LKM.
  prefs: []
  type: TYPE_NORMAL
- en: 'A loadable kernel module is, in fact, an ELF object file with a few additional
    sections and some information, which we neither meet in object files nor in executables
    created for user-space. We should point out at least five sections that we do
    not usually have in regular files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`.init.text`: This section contains all the code required for module initialization.
    In terms of Windows, for example, the content of this section may be compared
    to the `DllMain()` function and all the functions that it references. In terms
    of Linux, it may be considered a section containing constructors (Windows executables
    may have that too).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.exit.text`: This section contains all the code needed to be executed before
    the module is unloaded.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.modinfo`: This section contains information about the module itself, the
    version of kernel it is written for, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.gnu.linkonce.this_module`: This section contains the `this_module` structure,
    which, in turn, contains the name of the module and pointers to module initialization
    and de-initialization procedures. While the structure itself is a bit obscure
    for us in this case, we are interested in certain offsets only, which, in case
    of lack of sources, may be found with a reverse engineering tool such as IDA Pro.
    We may, however, check for offsets of the `.init.text` and `.exit.text` pointers
    within the structure, by running the `readelf` command in the terminal, as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Then, we see the offsets in the output:![](img/b736505f-a5ec-4439-b8dc-a5e258ad654b.png)As
    we see, the pointer to `.init.text` is at the offset `0x150` and the pointer to
    `.exit.text` is at the offset `0x248` into the `this_module` structure.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`__versions`: This section contains the names of external symbols prepended
    with their version numbers. This table is used by the kernel in order to verify
    compatibility of the module in question.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: LKM source
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The structure of an LKM is not a secret. It may be retrieved from Linux kernel
    sources, which are freely available and, therefore, we have no need to dig any
    deeper into it; instead, following Occam's Razor principle, let's move on to the
    implementation of the module.
  prefs: []
  type: TYPE_NORMAL
- en: 'As has been mentioned already, an LKM is an object file; therefore, we begin
    by creating a `lkm.asm` file and entering our code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Right after this, we are free to begin creating sections of an LKM.
  prefs: []
  type: TYPE_NORMAL
- en: .init.text
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This section contains the code required for successful initialization of an
    LKM. In our case, as we are not adding any functionality to the module, it could
    simply return, but as we need an indication of our LKM having loaded successfully,
    we will implement a tiny procedure, which will print a string into the system
    log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Rather simple, isn't it? We just print the string and return from this procedure.
  prefs: []
  type: TYPE_NORMAL
- en: .exit.text
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The content of this section is going to be even simpler (in our specific case).
    We simply return from the procedure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Since we did not allocate any resources nor load any modules or open any files,
    we simply return 0.
  prefs: []
  type: TYPE_NORMAL
- en: .rodata.str1.1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is a read-only data section and the only thing we have to put in it, is
    the string we are going to write to the system log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: .modinfo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we have to put certain information about the module of ours,
    such as license, dependencies, as well as the version of the kernel and supported
    options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are unsure about what to specify as `vermagic`, you may run the `modinfo`
    command on any of the modules found in the ``/lib/modules/`uname -r`/`` directory.
    For example, I run the following command on my system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4ef6f57f-f460-49ef-9dfb-ddc8b2229480.png)'
  prefs: []
  type: TYPE_IMG
- en: Once you have this information, you may simply copy the `vermagic` string and
    paste it into your code.
  prefs: []
  type: TYPE_NORMAL
- en: .gnu.linkonce.this_module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There''s nothing special to say here. This section contains only one structure--`this_module`,
    which is mostly filled with zeroes (as it is used by the LKM loader internally)
    except three fields:'
  prefs: []
  type: TYPE_NORMAL
- en: Name of the module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A pointer to the initialization procedure--`module_init`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A pointer to the de-initialization procedure--`module_cleanup`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These fields, in the case of this kernel version and this Linux distro, are
    located at offsets `0x18`, `0x150`, and `0x248`, respectively; therefore, the
    code would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This is all we had to take care of in this section.
  prefs: []
  type: TYPE_NORMAL
- en: __versions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The information in this section describes external symbols by version numbers
    and names thereof, and is used by the loader in order to ensure that the kernel
    and the LKM are using symbols of the same version, so there would not be any surprises.
    You may try to build a module without this section and it may even be loaded,
    but it is not suggested to do so. The loader refuses to load modules with invalid
    symbol versions, thus telling us that this information is not just for fun, but
    is used in order to prevent failures.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the time, I could not find reliable information on where to obtain version
    numbers for certain symbols, but it may be a good workaround, which is definitely
    sufficient for our small LKM, to simply search for symbol names prepended with
    the 8-byte version value (4 bytes on 32-bit systems), as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8e2f885d-d70b-41b9-8388-10e11570fe91.png)'
  prefs: []
  type: TYPE_IMG
- en: We only need two external symbols for our LKM, which are `module_layout` and
    `printk`. As you see in the preceding screenshot, the version of the `module_layout`
    symbol is `0x2AB9DBA5`. Taking the same approach for obtaining the version of
    the `printk` symbol, we get (so it is on my system, but it may differ on yours)
    `0x27E1A049`.
  prefs: []
  type: TYPE_NORMAL
- en: 'These entries are stored as an array of structures, where each structure contains
    two fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '`version number`: This is the 8-byte version identifier (4 bytes on 32-bit
    systems)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`symbol name`: This is the variable length string (up to 56 bytes) representing
    the name of the symbol'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Since we are talking about fixed-size fields here, it is natural to define
    a structure; however, since we do not want to name each and every structure for
    each and every symbol, we will use a macro:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Having defined the `__version` macro, we are ready to conveniently implement
    the `__versions` section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: That is it. Save the file and let's try to compile it and load.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the LKM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Testing the module is much more simple than writing one. The compilation is
    not different from the usual; we simply compile it with the Flat Assembler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Once our kernel module is compiled, we need to ensure that it has the executable
    attribute set by running the `chmod +x lkm.ko` command in the Terminal.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to load the LKM into the currently running kernel, we use the `insmode`
    command in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We will not be given any error unless there is a serious problem with the format
    of the LKM (for example, invalid symbol version(s)). If all went well, try to
    run the `dmesg` command in the terminal, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the `"<0> Here I am, gentlemen!"` string appearing at the end
    of the system log. If the string is not there, then, most likely, you have to
    reboot your system, but first try to unload the module by running the `rmmod`
    command in the Terminal, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: If all went well, then we will now be able to create Linux LKMs using pure Assembly.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have gone a long way. Beginning with an overview of the Intel architecture,
    we went through the implementation of different algorithms, although mostly simplified
    for the sake of understandability, and we finished with the implementation of
    a loadable kernel module for Linux.
  prefs: []
  type: TYPE_NORMAL
- en: The intention behind this final chapter was to draw your interest toward a couple
    of topics that lie outside the scope of the book and therefore could not get enough
    attention, but are still important one way or another. Although the obfuscation
    given in the beginning of the chapter is rather simple, it should have given you
    the general idea of how more complicated obfuscation schemes may be brought up
    with the basic tool provided by the Flat Assembler, the macro engine.
  prefs: []
  type: TYPE_NORMAL
- en: We dedicated some time to kernel programming in the second part of the chapter
    and, although the kernel module we have implemented is, perhaps, the most basic
    one possible, we have shown that even such aspects of programming as kernel development,
    aspects that many people consider very complicated even when viewed from a high-level
    language perspective, include nothing to be afraid of even when viewed from the
    top of the solid rock called Assembly language.
  prefs: []
  type: TYPE_NORMAL
- en: By now, you should have a strong enough base to let you keep going on easily
    and improving your Assembly programming skills and abilities, and I would like
    to wish you good luck in doing this.
  prefs: []
  type: TYPE_NORMAL
- en: Thank you!
  prefs: []
  type: TYPE_NORMAL
