- en: iOS Data Analysis and Recovery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A key aspect of iOS-device forensics is to examine and analyze the data acquired
    to interpret the evidence. In the previous chapters, you learned various techniques
    to acquire data from iOS devices. Any type of acquired image contains hundreds
    of data files that are often parsed by the tools described in earlier chapters.
    Even when the data is parsed by the forensic tool, a manual analysis may be required
    to uncover additional artifacts or to simply validate your findings.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will help you understand how data is stored on iOS devices, and
    it will walk you through the key artifacts that should be examined in each investigation
    to recover the most data possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Interpreting iOS timestamps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with SQLite databases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Key artifacts – important iOS database files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Property lists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other important files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recovering deleted SQLite records
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interpreting iOS timestamps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before examining the data, it is important to understand different timestamp
    formats that are used on iOS devices. Timestamps found on iOS devices are presented
    either in the *Unix timestamp* or *Mac absolute* *time* format. You, as the examiner,
    must ensure that the tools properly convert the timestamps. Access to the raw
    SQLite files will allow you to verify these timestamps manually. You'll learn
    how to decode each timestamp format in the next few sections.
  prefs: []
  type: TYPE_NORMAL
- en: Unix timestamps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Unix timestamp is the number of seconds that have elapsed since Unix epoch
    time, which started at midnight on January 1, 1970\. A Unix timestamp can be converted
    easily, using the `date` command on a Mac workstation or using an online Unix
    epoch converter, such as [https://www.epochconverter.com/](https://www.epochconverter.com/).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `date` command is shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You may come across Unix timestamps in a millisecond or nanosecond format as
    well. This is not a big problem; there are a number of online converters, such
    as [http://currentmillis.com/](http://currentmillis.com/), as highlighted in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3eefc99b-2294-439e-8675-d2e80c165d82.png)'
  prefs: []
  type: TYPE_IMG
- en: A Unix timestamp in milliseconds converted with http://currentmillis.com/
  prefs: []
  type: TYPE_NORMAL
- en: The Unix epoch is the most common format for iOS devices, but there are others
    as well, including Mac absolute time and WebKit/Chrome time.
  prefs: []
  type: TYPE_NORMAL
- en: Mac absolute time
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'iOS devices adopted the use of Mac absolute time with iOS 5\. Mac absolute
    time is the number of seconds that have elapsed since Mac epoch time, which started
    at midnight on January 1, 2001\. The difference between the Unix epoch time and
    the Mac time is exactly 978,307,200 seconds. It means you can easily convert the
    Mac time to the Unix epoch and use the same methods to finally convert it to a
    human-readable timestamp. Of course, there are a few online converters, such as [https://www.epochconverter.com/coredata](https://www.epochconverter.com/coredata),
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e52b9f80-162b-4bbb-a9cd-77c3312d6752.png)'
  prefs: []
  type: TYPE_IMG
- en: A Mac timestamp converted with https://www.epochconverter.com/coredata
  prefs: []
  type: TYPE_NORMAL
- en: Of course, there are offline tools for timestamp conversion as well. We'll introduce
    you to one of them in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: WebKit/Chrome time
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When analyzing iOS application data, especially for web browsers such as Google
    Chrome, Safari, and Opera, you may face another timestamp format—*WebKit/Chrome
    time*. This is the number of microseconds since midnight on January 1, 1601\.
    There is also an online converter for this: [https://www.epochconverter.com/webkit](https://www.epochconverter.com/webkit).'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you don''t like or don''t want to use online converters for some reason,
    you can also use a free tool: Digital Detective''s DCode. This tool can be used
    to convert timestamps in a number of different formats, including Unix time (both
    seconds and milliseconds), Mac absolute time, and WebKit/Chrome time, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/da4ab0d6-d97d-49c2-a5a6-2df65bec31bb.png)'
  prefs: []
  type: TYPE_IMG
- en: A WebKit/Chrome timestamp converted with DCode
  prefs: []
  type: TYPE_NORMAL
- en: Many commercial mobile forensic suites will easily convert extracted timestamps
    for you automatically, but in some cases, it's extremely important to validate
    it, so it's a must for you to clearly understand the timestamp formats.
  prefs: []
  type: TYPE_NORMAL
- en: Working with SQLite databases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SQLite is an open source, in-process library that implements a self-contained,
    zero-configuration, and transactional SQL database engine. This is a complete
    database with multiple tables, triggers, and views that are contained in a single
    cross-platform file. As SQLite is portable, reliable, and small, it is a popular
    database format that appears on many mobile platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Apple iOS devices, as with other smartphones and tablets, make heavy use of
    SQLite databases for data storage. Many of the built-in applications—such as Phone,
    Messages, Mail, Calendar, and Notes—store data in SQLite databases. Apart from
    this, third-party applications installed on the device also leverage SQLite databases
    for data storage.
  prefs: []
  type: TYPE_NORMAL
- en: SQLite databases are created with or without a file extension. They typically
    have the `.sqlitedb` or `.db` file extensions, but some databases are given other
    extensions as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Data in SQLite files is broken up into tables that contain the actual data.
    To access the data stored in the files, you need a tool that is able to read it.
    Most commercial mobile forensic tools—such as Belkasoft Evidence Center, Magnet
    AXIOM, and Cellebrite **Universal Forensic Extraction Device** (**UFED**) Physical
    Analyzer—provide support for the examination of SQLite databases. If you don''t
    own one of these tools, some good free tools are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**DB Browser for SQLite (DB4S)**: This can be downloaded from [http://sqlitebrowser.org/](http://sqlitebrowser.org/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SQLite command-line client**: This can be downloaded from [http://www.sqlite.org/](http://www.sqlite.org/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SQLiteStudio** ([https://sqlitestudio.pl](https://sqlitestudio.pl)): This
    is a free cross-platform SQLite manager with support for Windows 9x/2k/XP/2003/Vista/7/8/10,
    macOS, and Linux.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SQLiteSpy**: This is a free **graphical user interface** **(GUI)** tool for
    Windows. You can download it from [http](http://www.yunqa.de/delphi/doku.php/products/sqlitespy/index)[://www.yunqa.de/delphi/doku.php/products/sqlitespy/index](http://www.yunqa.de/delphi/doku.php/products/sqlitespy/index).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: macOS includes the SQLite command-line utility (`sqlite3`) by default. This
    command-line utility can be used to access individual files and run SQL queries
    against a database. In the following sections, we will use both the `sqlite3`
    command-line utility and other SQLite tools and browsers to retrieve data from
    various SQLite databases. Before retrieving the data, the basic commands that
    you will need to learn are explained in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to a database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Manual examination of iOS SQLite database files is possible with the use of
    free tools. The following is an example of how to examine a database using native
    Mac commands in the Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: Make sure that your device image is mounted as read-only to prevent changes
    being made to the original evidence.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To connect to an SQLite database from the command line, run the `sqlite3` command
    in the Terminal by entering your database file. This will give you an SQL prompt
    where you can issue SQL queries, as shown in the following code block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: To disconnect, use the `.exit` command. This exits the SQLite client and returns
    to the Terminal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next section will walk you through the analysis of databases, using `sqlite3`
    built-in commands.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring SQLite special commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once you connect to a database, you can use a number of built-in SQLite commands
    that are known as *dot commands* and that can be used to obtain information from
    the database files.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can obtain the list of special commands by issuing the `.help` command
    in the SQLite prompt. These are SQLite-specific commands, and they do not require
    a semicolon at the end. The most commonly used dot commands include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`.tables`: This lists all of the tables within a database. The following screenshot
    displays the list of tables found inside the `sms.db` database:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/d27252c6-e75f-4035-8f34-9be14da66735.png)'
  prefs: []
  type: TYPE_IMG
- en: '`.schema table-name`: This displays the `SQL CREATE` statement that was used
    to construct the table. The following screenshot displays the schema for the `handle`
    table from the `sms.db` database:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/6d00603a-79a1-44df-9c3b-2475eab6f5d9.png)'
  prefs: []
  type: TYPE_IMG
- en: '`.dump table-name`: This dumps the entire content of a table into SQL statements.
    The example in the following screenshot displays the dump of the `handle` table,
    which is found inside the `sms.db` database:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/3457bfe6-038b-4021-902c-452e24a4c31e.png)'
  prefs: []
  type: TYPE_IMG
- en: '`.output file-name`: This redirects the output to a file on the disk instead
    of showing it on the screen.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.headers on`: This displays the column title whenever you issue a `SELECT`
    statement.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.help`: This displays the list of available SQLite dot commands.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.exit`: This disconnects from the database and exits the SQLite command shell.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.mode`: This sets the output mode; it could be `.csv`, HTML, tabs, and so
    on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make sure that there is no space between the SQLite prompt and the dot command;
    otherwise, the entire command will be ignored.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring standard SQL queries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to the SQLite dot commands, standard SQL queries such as `SELECT`,
    `INSERT`, `ALTER`, and `DELETE` can be issued to SQLite databases on the command
    line. Unlike the SQLite dot commands, standard SQL queries expect a semicolon
    at the end of the command.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the databases that you will examine will contain only a reasonable number
    of records, so you can issue a `SELECT *` statement, which prints all of the data
    contained in the table. This will be covered in detail throughout this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing a database using commercial tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While a manual examination of iOS SQLite database files is possible with the
    use of free tools, most examiners prefer commercial support prior to digging manually
    into the files for examination. The following is an example of how to examine
    a database using SQLite, which is included in Belkasoft Evidence Center.
  prefs: []
  type: TYPE_NORMAL
- en: 'To open and analyze a database, you just need to follow a few simple steps,
    listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: Launch Belkasoft Evidence Center and navigate to View | SQLite Viewer, and choose
    the database file you want to examine.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once the database is chosen, it''s immediately opened with SQLite Viewer and
    is ready to be examined, as illustrated in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a9651922-7915-4392-87cf-313d624572e9.png)'
  prefs: []
  type: TYPE_IMG
- en: sms.db database opened with Belkasoft Evidence Center's SQLite Viewer
  prefs: []
  type: TYPE_NORMAL
- en: 'Why does an examiner need to use such commercial viewers instead of free and
    open-source ones? For example, this particular viewer supports even damaged or
    partially overwritten SQLite databases. What''s more, the tool supports the extraction
    of data from freelists, **Write-Ahead Log** (**WAL**), and unallocated space,
    as illustrated in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/edf93e65-d1c8-4d11-bb26-005c4afa01e6.png)'
  prefs: []
  type: TYPE_IMG
- en: Unallocated space of the database as seen in Belkasoft Evidence Center's SQLite
    Viewer
  prefs: []
  type: TYPE_NORMAL
- en: Of course, there are some free and open source tools available for SQLite data
    recovery. You'll learn more about such tools in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Key artifacts – important iOS database files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Filesystems and backups that you extracted as per the instructions in [Chapter
    3](6bdeccbc-e651-43f3-b5ed-4e6d071adec6.xhtml)*, Data Acquisition from iOS Devices,* and
    [Chapter 4](f082adcc-6892-4e66-80cc-49b9752cb56a.xhtml)*,* *Data Acquisition from
    iOS Backups,* should contain the following SQLite databases that may be important
    to your investigation. If these files are not recovered, make sure that you acquired
    the iOS device correctly. The files that are shown in the following sections are
    extracted via logical acquisition from a device running iOS. As Apple adds new
    features to the built-in applications with every iOS release, the format of the
    files may vary for different iOS versions.
  prefs: []
  type: TYPE_NORMAL
- en: Address book contacts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The address book contains a wealth of information about the owner''s personal
    contacts. With the exception of third-party applications, the address book contains
    contact entries for all of the contacts that are stored on the device. The address
    book database can be found at `/HomeDomain/Library/AddressBook.sqlitedb`. The
    `AddressBook.sqlitedb` file contains several tables, of which the following three
    are of particular interest:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ABPerson`: This contains the name, organization, notes, and more for each
    contact.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ABMultiValue`: This contains phone numbers, email addresses, website **Uniform
    Resource Locators** (**URLs**), and more for the entries in the `ABPerson` table.
    The `ABMultiValue` table uses a `record_id` file to associate the contact information
    with a `ROWID` from the `ABPerson` table.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ABMultiValueLabel`: This table contains labels to identify the kind of information
    stored in the `ABMultiValue` table.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some of the data stored within the `AddressBook.sqlitedb` file could be from
    third-party applications. You should manually examine the application file folders
    to ensure that all the contacts are accounted for and examined.
  prefs: []
  type: TYPE_NORMAL
- en: 'While all the following commands can be run natively on a Mac, we are going
    to use DB4S to examine the most common databases found on iOS devices. This is
    a free tool that simplifies the process and provides a clear view of the data
    to you. Once the database is loaded, you can draft queries to examine the data
    most relevant to you and export the address book into a `.csv` file named `AddressBook.csv`,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/51361ad5-b90c-4a2a-9e91-8eee6bc2c0f6.png)'
  prefs: []
  type: TYPE_IMG
- en: The AddressBook.sqlitedb file in DB4S
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding screenshot, you can see the suggested query to parse data from
    both the `ABPerson` and `ABMultiValue` tables.
  prefs: []
  type: TYPE_NORMAL
- en: Address book images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to the address book's data, each contact may contain an image associated
    with it. This image is displayed on the screen whenever the user receives an incoming
    call from a particular contact. These images can be created by third-party applications
    that have access to the contacts on the device. Often, the contact is linked to
    a third-party application profile photo. The address book images database can
    be found at `/HomeDomain/Library/AddressBook/AddressBookImages.sqlitedb`.
  prefs: []
  type: TYPE_NORMAL
- en: The address book images can be parsed manually, but using commercial software
    makes this process much more practical. Most free and commercial tools will provide
    access to the address book images. However, some tools will not make the link
    between the graphic and the contact, which may require some manual rebuilding.
    Sometimes, the free solutions work best when parsing simple data from iOS devices.
    Next, we will examine the address book images in iExplorer, which was introduced
    in [Chapter 4](f082adcc-6892-4e66-80cc-49b9752cb56a.xhtml), *Data Acquisition
    from iOS Backups*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the example in the following screenshot, iExplorer matched contact data
    with the image automatically:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c5991b98-0b58-44c4-8955-11c1d0a9f20e.png)'
  prefs: []
  type: TYPE_IMG
- en: Examining address book images in iExplorer
  prefs: []
  type: TYPE_NORMAL
- en: The same thumbnails can be found in the `ABThumbnailImage` table, in the `data`
    column. You can match the photo to the contact manually, using the `record_id`
    column from the `ABThumbnailImage` table of `AddressBookImages.sqlitedb` and the `ROWID`
    column from the `ABPerson` table of `AddressBook.sqlitedb`.
  prefs: []
  type: TYPE_NORMAL
- en: Call history
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Phone or FaceTime calls placed, missed, and received by the user are logged
    in the call history along with other metadata, such as call duration, and date
    and time. The call history database can be found at `/HomeDomain/Library/CallHistoryDB/CallHistory.storedata`.
    The `CallHistory.storedata` file was introduced with iOS 8 and is currently in
    use at the time of writing (iOS 13.2).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ZCALLRECORD` table in the `CallHistory.storedata` database contains the
    call history. It''s important to note that only a limited number of calls may
    be stored in the active database. Just because the database removes the oldest
    record when space is needed does not mean this data is deleted. It''s simply in
    the free pages of the SQLite database file, and it can be recovered using forensic
    tools or manually. The most important columns in the `ZCALLRECORD` table are the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ZDATE`: This column contains the timestamps of calls in Mac absolute time
    format.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ZDURATION`: This column contains the duration of calls.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ZLOCATION`: This column contains the locations of phone numbers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ZADDRESS`: This column contains the phone numbers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ZSERVICE_PROVIDER`: This column contains the service providers—for example,
    Phone, WhatsApp, Telegram, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can run the following queries in DB4S to parse the call history. Afterward,
    you can export it into a `.csv` file, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c9e15bf1-ab8e-4000-8456-29f227a1c52b.png)'
  prefs: []
  type: TYPE_IMG
- en: Examining CallHistory.storedata in DB4S
  prefs: []
  type: TYPE_NORMAL
- en: This time, the query is quite simple as all columns of interest are in the same
    table. Notice we used `datetime` to convert Mac absolute timestamps to human-readable
    dates.
  prefs: []
  type: TYPE_NORMAL
- en: Short Message Service (SMS) messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The SMS database contains text and multimedia messages that were sent from and
    received by the device, along with the phone number of the remote party, date
    and time, and other carrier information. Starting with iOS 5, iMessage data is
    also stored in the SMS database. iMessage allows users to send SMS and **Multimedia
    Messaging Service** (**MMS**) messages over a cellular or Wi-Fi network to other
    iOS or macOS users, thus providing an alternative to SMS. The SMS database can
    be found at `/HomeDomain/Library/SMS/sms.db`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can run the following queries in DB4S to parse the SMS messages. Afterward,
    you can export it into a `.csv` file, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7c2195ca-221a-478c-a224-c4811153eb62.png)'
  prefs: []
  type: TYPE_IMG
- en: Examining sms.db in DB4S
  prefs: []
  type: TYPE_NORMAL
- en: There's another interesting subdirectory that can be found at `/HomeDomain/Library/SMS/`—`Drafts`.
    Inside, there are more subfolders, each of which contains a `message.plist` file.
    Each file is a property list with draft messages the user started to type but
    didn't send. You'll learn more about property lists in the next sections.
  prefs: []
  type: TYPE_NORMAL
- en: Calendar events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Calendar events that have been manually created by the user or synced using
    a mail application or other third-party applications are stored in the `Calendar`
    database. The `Calendar` database can be found at `/HomeDomain/Library/Calendar/Calendar.sqlitedb`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `CalendarItem` table in the `Calendar.sqlitedb` file contains the calendar
    events summary, description, start date, end date, and more. You can run the following
    queries in DB4S to parse the calendar, as illustrated in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2f1bdd85-49ca-4b3f-8a00-c8648c6697f3.png)'
  prefs: []
  type: TYPE_IMG
- en: Examining calendar.sqlitedb in DB4S
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the `CalendarItem` table stores dates in Mac absolute time format,
    so we added `978307200` to reveal actual timestamps, with the help of the `datetime`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Notes` database contains the notes that are created by the user using the
    device's built-in `Notes` application. `Notes` is the simplest application, often
    containing the most sensitive and confidential information. The `Notes` database can
    be found at `/HomeDomain/Library/Notes/notes.sqlite`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ZNOTE` and `ZNOTEBODY` tables in the `notes.sqlite` file contain each
    note''s title, content, creation date, modification date, and more. You can run
    the following queries to parse the `Notes` database:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d2995cae-a0c5-4cba-8239-b274e77c4f25.png)'
  prefs: []
  type: TYPE_IMG
- en: Examining notes in DB4S
  prefs: []
  type: TYPE_NORMAL
- en: This query merges data from two tables, so we use `ZOWNER` from `ZNOTEBODY`,
    `Z_PK` from `ZNOTE`, and a `WHERE` clause to do it.
  prefs: []
  type: TYPE_NORMAL
- en: Safari bookmarks and history
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Safari browser used on an iOS device allows users to bookmark their favorite
    websites. The `Bookmarks` database can be found at `/HomeDomain/Library/Safari/Bookmarks.db`.
    Bookmark data can be extracted with a very simple query, as illustrated in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/456f42eb-bf0b-418c-87a8-4bfee6e5c029.png)'
  prefs: []
  type: TYPE_IMG
- en: Examining bookmarks in DB4S
  prefs: []
  type: TYPE_NORMAL
- en: 'Browsing history can be found in `History.db`, at `/HomeDomain/Library/Safari/`.
    The most important pieces of information about visited websites can be extracted
    from `history_items` and `history_visits` tables, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/15dedc9e-25ed-4fae-aded-167b4bdbc601.png)'
  prefs: []
  type: TYPE_IMG
- en: Examining history in DB4S
  prefs: []
  type: TYPE_NORMAL
- en: In addition to Safari, other browsers can be used to store data on an iOS device.
    For this reason, we recommend using a tool built to parse internet history, to
    ensure that data is not overlooked. Good forensic tools for solving this task
    are AXIOM by Magnet Forensics, Physical Analyzer by Cellebrite, and some others.
  prefs: []
  type: TYPE_NORMAL
- en: Voicemail
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Voicemail` database contains metadata about each voicemail that is stored on
    the device, which includes the sender's phone number, callback number, timestamp
    and message duration, and more. The voicemail recordings are stored as **Adaptive
    Multi-Rate** (**AMR**) audio files that can be played by any media player that
    supports the AMR codec (for example, QuickTime Player). The `Voicemail` database can
    be found under `/HomeDomain/Library/Voicemail/voicemail.db`.
  prefs: []
  type: TYPE_NORMAL
- en: Recordings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Recordings `database contains metadata about each recording stored on
    the device, which includes the timestamp, its duration, its location on the device,
    and more. The database can be found at `/MediaDomain/Media/Recordings`. The metadata
    can be extracted with the query shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c34c37f3-762b-4675-ae9d-bdef7279306a.png)'
  prefs: []
  type: TYPE_IMG
- en: Examining recordings in DB4S
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the preceding screenshot, actual files with recordings are
    stored in the same directory.
  prefs: []
  type: TYPE_NORMAL
- en: Device interaction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is an SQLite database that records how the user interacts with different
    applications. This database is called `interactionC.db` and is located at `/HomeDomain/Library/CoreDuet/People`.
    The `ZINTERACTIONS` table contains information about whether the user reads a
    message, sends a message, performs a call, and so on. You can extract this information
    from the table with the query shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d4baf2f6-666d-4e8a-8256-d348057170a6.png)'
  prefs: []
  type: TYPE_IMG
- en: Examining interactions in DB4S
  prefs: []
  type: TYPE_NORMAL
- en: Also, make sure you examined the `ZCONTACTS` table—it contains information about
    contacts who were involved in the user's interactions with the device, if applicable.
  prefs: []
  type: TYPE_NORMAL
- en: Phone numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can obtain information about all phone numbers utilized by the user, even
    if they changed phones and restored from a backup, by analyzing the `CellularUsage.db`
    file located at `/WirelessDomain/Library/Databases`. The query to extract this
    data is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/673b6637-286f-4d21-8fb0-910bdd31bf95.png)'
  prefs: []
  type: TYPE_IMG
- en: Extracting phone numbers
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, there is not only phone numbers available, but also the **Subscriber
    Identity Module** (**SIM**) card's **Integrated Circuit Card Identifier** (**ICCID**).
  prefs: []
  type: TYPE_NORMAL
- en: Property lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A property list, commonly referred to as a `plist`, is a structured data format
    used to store, organize, and access various types of data on an iOS device as
    well as a macOS device. `plist` files are binary-formatted, and they can be viewed
    using a property List Editor, which is capable of reading or converting the binary
    format to an **American Standard Code for Information Interchange** (**ASCII**)
    format.
  prefs: []
  type: TYPE_NORMAL
- en: '`Plist` files may or may not have a `.plist` file extension. To access the
    data stored in these files, you need a tool that can read them. Some of the good
    free tools include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: plist Editor Pro, which can be downloaded from [http://www.icopybot.com/plist-editor.htm](http://www.icopybot.com/plist-editor.htm).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `plutil` command-line utility on macOS.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can view `plist` files using Xcode. macOS includes the `plutil` command-line
    utility by default. This command-line utility can easily convert the binary-formatted
    files into human-readable files. In addition to this, most commercial forensic
    tools include great support for parsing `plist` files.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot displays the `com.apple.mobile.ldbackup.plist` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/85fcf9cc-8be9-489f-850b-5cb264c83f30.png)'
  prefs: []
  type: TYPE_IMG
- en: The com.apple.mobile.ldbackup.plist in plist Editor Pro
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, this `plist` uncovers the last local and cloud backup dates
    (in Mac absolute time, of course), the time zone it was created in, as well as
    the fact that the backup is encrypted.
  prefs: []
  type: TYPE_NORMAL
- en: Important plist files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Raw disk images or the backup that you extracted in [Chapter 3](6bdeccbc-e651-43f3-b5ed-4e6d071adec6.xhtml),
    *Data Acquisition from iOS Devices,* and [Chapter 4](f082adcc-6892-4e66-80cc-49b9752cb56a.xhtml),
    *Data Acquisition from iOS Backups,* should contain the following `plist` files
    that are important for an investigation. The files displayed are extracted from
    an iOS 13.2 device backup. The file locations may vary for your iOS version.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the `plist` files that contain data that may be relevant
    to your investigation:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **plist file** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `/HomeDomain/Library/Preferences/com.apple.commcenter.shared.plist` | Contains
    the phone number in use |'
  prefs: []
  type: TYPE_TB
- en: '| `/HomeDomain/Library/Preferences/com.apple.identityservices.idstatuscache.plist`
    | Contains information about the email address used for the Apple ID and the phone
    numbers of the individuals the user interacted with via FaceTime or iMessage using
    this ID |'
  prefs: []
  type: TYPE_TB
- en: '| `/HomeDomain/Library/Preferences/com.apple.mobile.ldbackup.plist` | Contains
    the timestamps of the last iTunes and iCloud backups, the last iTunes backup time
    zone, and if it was encrypted or not |'
  prefs: []
  type: TYPE_TB
- en: '| `/HomeDomain/Library/Preferences/com.apple.MobileBackup.DemotedApps.plist`
    | Contains the list of unused applications that were automatically offloaded by
    the operating system |'
  prefs: []
  type: TYPE_TB
- en: '| `/HomeDomain/Library/Preferences/com.apple.mobilephone.speeddial.plist` |
    Contains the list of the user''s favorite contacts, including their names and
    phone numbers |'
  prefs: []
  type: TYPE_TB
- en: '| `/HomeDomain/Library/Preferences/com.apple.preferences.datetime.plist` |
    Contains information about the time zone set by the user |'
  prefs: []
  type: TYPE_TB
- en: '| `/RootDomain/Library/Caches/locationd/clients.plist` | Contains the list
    of applications that use location Services |'
  prefs: []
  type: TYPE_TB
- en: '| `/RootDomain/Library/Preferences/com.apple.MobileBackup.plist` | Contains
    information about the last restoration from the backup, including the restore
    start date, file transfer duration, number of files transferred, source device
    **Unique Device Identifier** (**UDID**), and so on |'
  prefs: []
  type: TYPE_TB
- en: '| `/SystemPreferencesDomain/SystemConfiguration/com.apple.mobilegestalt.plist`
    | Contains the device name assigned by the user |'
  prefs: []
  type: TYPE_TB
- en: '| `/SystemPreferencesDomain/SystemConfiguration/com.apple.wifi.plist` | Contains
    information about wireless access points used by the device owner |'
  prefs: []
  type: TYPE_TB
- en: '| `/WirelessDomain/Library/Preferences/com.apple.commcenter.plist` | Contains
    information about the device phone number, network carrier, ICCIDs, and **international**
    **mobile** **subscriber** **identities** (**IMSIs**) |'
  prefs: []
  type: TYPE_TB
- en: Of course, `plist` files don't contain as much information as SQLite databases,
    but they can still be useful during your forensic examinations. Next, we'll look
    at some other files that may be also useful.
  prefs: []
  type: TYPE_NORMAL
- en: Other important files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Apart from SQLite and `plist` files, several other locations may contain information
    that could be valuable to an investigation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other sources include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Local dictionary
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Photos
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thumbnails
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wallpaper
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Downloaded third-party applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's look at each of them.
  prefs: []
  type: TYPE_NORMAL
- en: Local dictionary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The list of words added by the device user to the dictionary are stored in a
    `LocalDictionary` plaintext file, located at `/KeyboardDomain/Library/Keyboard/`.
    As the file is plaintext, you can use your favorite text editor.
  prefs: []
  type: TYPE_NORMAL
- en: Photos
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Photos are stored in a directory located at `/CameraRollDomain/Media/DCIM`,
    which contains the photos taken with the device's built-in camera, screenshots,
    selfies, photo stream, recently deleted photos, and accompanying thumbnails. Some
    third-party applications will also store photos taken in this directory. Every
    photo stored in the `DCIM` folder contains **Exchangeable Image File Format**
    (**EXIF**) data. `EXIF` data stored in the photo can be extracted using `ExifTool`,
    which can be downloaded from [https://sno.phy.queensu.ca/~phil/exiftool/](https://sno.phy.queensu.ca/~phil/exiftool/).
    `EXIF` data may contain geographical information when a photo is tagged with the
    user's geolocation if the user has enabled location permissions on the iOS device.
  prefs: []
  type: TYPE_NORMAL
- en: Thumbnails
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another source of important artifacts related to photos is the `ithmb` files.
    You can find these files at `/CameraRollDomain/Media/PhotoData/Thumbnails`. These
    files contain thumbnails not only for actual photos on the device but also for
    deleted ones. And, of course, there is a tool for parsing such files, `iThmb Converter`,
    which can be downloaded from [http://www.ithmbconverter.com/en/download/](http://www.ithmbconverter.com/en/download/) and
    is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/30e58e68-ad94-4084-8b21-dae387321a59.png)'
  prefs: []
  type: TYPE_IMG
- en: Examining 3304.ithmb with iThmb Converter
  prefs: []
  type: TYPE_NORMAL
- en: As these files may contain thumbnails of deleted photos, they mustn't be overlooked
    by forensic examiners. What's more, some of them contain quite big thumbnails,
    so it will be clear what was pictured.
  prefs: []
  type: TYPE_NORMAL
- en: Wallpaper
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The current background wallpapers set for the iOS device can be recovered from
    the `LockBackgroundThumbnail.jpg` and `LockBackgroundThumbnaildark.jpg` files
    that are found in `/HomeDomain/Library/SpringBoard`.
  prefs: []
  type: TYPE_NORMAL
- en: The wallpaper picture may contain identifying information about the user that
    could help in a missing person's case or that could be found on an iOS device
    recovered from a theft investigation.
  prefs: []
  type: TYPE_NORMAL
- en: Downloaded third-party applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Third-party applications that are downloaded and installed from the App Store—including
    applications such as Facebook, WhatsApp, Viber, Threema, Tango, Skype, and Gmail—contain
    a wealth of information that is useful for an investigation. Some third-party
    applications use Base64 encoding, which needs to be converted for viewing purposes
    as well as encryption. Applications that encrypt the database file may prevent
    you from accessing the data residing in the tables. Encryption varies among these
    applications, based on the application and iOS versions.
  prefs: []
  type: TYPE_NORMAL
- en: A subdirectory with a **universally unique identifier** (**UUID**) is created
    for each application that is installed on the device in the `/private/var/mobile/Containers/Data/Application` directory.
    Most of the files stored in the application's directory are in the SQLite and
    `plist` format. Each file must be examined for relevance. We recommend using Belkasoft
    Evidence Center, Cellebrite UFED Physical Analyzer, Elcomsoft Phone Viewer, and
    Magnet AXIOM when possible to extract these artifacts quickly, before going back
    and manually running queries and parsing the data.
  prefs: []
  type: TYPE_NORMAL
- en: Also, information about installed applications can be gathered from the `applicationState.db` database,
    located at `/HomeDomain/Library/FrontBoard`. This is another SQLite database and
    can be analyzed with an appropriate viewer of the examiner's choice.
  prefs: []
  type: TYPE_NORMAL
- en: Recovering deleted SQLite records
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SQLite databases store the deleted records within the database itself, so it
    is possible to recover deleted data, such as contacts, SMS messages, calendars,
    notes, email, voicemail, and more by parsing the corresponding SQLite database.
    If an SQLite database is vacuumed or defragmented, the likelihood of recovering
    the deleted data is minimal. The amount of cleanup that these databases require
    relies heavily on the iOS version, the device, and the user's settings on the
    device.
  prefs: []
  type: TYPE_NORMAL
- en: A SQLite database file comprises one or more fixed-size pages, which are used
    just once. SQLite uses a B-tree layout of pages to store indices and table content.
    Detailed information on the B-tree layout can be found at [https://github.com/NotionalLabs/SQLiteZer/blob/master/_resources/Sqlite_carving_extractAndroidData.pdf](https://github.com/NotionalLabs/SQLiteZer/blob/master/_resources/Sqlite_carving_extractAndroidData.pdf).
  prefs: []
  type: TYPE_NORMAL
- en: Commercial forensic tools provide support to recover deleted data from SQLite
    database files, but they don't always recover all of the data, nor do they support
    extracting data from all databases on an iOS device. It is recommended that each
    database containing key artifacts be examined for deleted data. The key artifacts
    or databases already discussed in this book should be examined using free parsers,
    hex viewers, or even your forensic tool to determine whether the user deleted
    artifacts that are relevant to the investigation.
  prefs: []
  type: TYPE_NORMAL
- en: To carve an SQLite database, you can examine the data in raw hex or use `sqliteparse.py`,
    a free Python script developed by Mari DeGrazia. The Python script can be downloaded from
    [https://github.com/mdegrazia/SQlite-Deleted-Records-Parser](https://github.com/mdegrazia/SQlite-Deleted-Records-Parser).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example recovers the deleted records from the `notes.sqlitedb`
    file and dumps the output to the `output.txt` file. This script should work on
    all database files recovered from iOS devices. To validate your findings from
    running the script, simply examine the database in a hex viewer to ensure nothing
    is overlooked. The code can be seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition to this, performing a `strings` dump of the database file can also
    reveal deleted records that may have been missed, as shown in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Should you prefer a GUI, Mari DeGrazia kindly created one and placed it on her
    GitHub page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another open-source tool you can use to recover deleted SQLite records is Undark.
    You can download it here: [http://pldaniels.com/undark/](http://pldaniels.com/undark/).
    To use the tool, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: It's important to note that Undark does not differentiate between current and
    deleted data, so you will get the whole set of data, both actual and deleted.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covered various data analysis techniques and specified the locations
    for common artifacts within the iOS device's filesystem. When writing this chapter,
    we aimed to cover the most popular artifacts that tie into most investigations.
    Clearly, it is impossible to cover them all. We hope that once you learn how to
    extract data from SQLite and `plist` files, intuition and persistence will assist
    you in parsing the artifacts that were not covered.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that most open-source and commercial tools are able to pull active
    and deleted data from common database files, such as contacts, calls, SMS messages,
    and more, but they often overlook the third-party application database files.
    Our best advice is to know how to recover the data manually, just in case you
    need to validate your findings or testify as to how your tool functions.
  prefs: []
  type: TYPE_NORMAL
- en: We covered techniques to recover deleted SQLite records that prove useful in
    most iOS device investigations. Again, the acquisition method, encoding, and encryption
    schemas can affect the amount of data that you can recover during your examination.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, *iOS Forensic Tools*, we will introduce you to the most
    popular mobile forensic tools—Cellebrite UFED Physical Analyzer, Magnet AXIOM,
    Elcomsoft Phone Viewer, and Belkasoft Evidence Center.
  prefs: []
  type: TYPE_NORMAL
