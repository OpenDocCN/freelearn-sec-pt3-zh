<html><head></head><body>
		<div><h1 id="_idParaDest-85"><a id="_idTextAnchor093"/>Chapter 5: Controlling Access and Managing Identity</h1>
			<p>Well, well, well… look who we have here. It's you! Not to mention the thirst for knowledge about controlling access and managing identity that you brought along. That's so great, and quite a coincidence, as this chapter actually covers those topics. </p>
			<p><strong class="bold">Identity and Access Management</strong>, or <strong class="bold">IAM</strong>, helps with understanding both the people and the automated services that are doing all of the <strong class="bold">CRUD</strong> (short for <strong class="bold">Creating, Reading, Updating, and Deleting</strong>) in your estate. That sounds important because it is important. How else can you ensure an entity is actually the approved user they claim to be? </p>
			<p>Also, based on previous chapters, we have described certain levels of permission based on various aspects of privacy and confidentiality, but how is it that we can enforce those rules in an automated way in our digital environment? How do you walk the tightrope of the right amount of access? Too much access for your users and you've got a breach on your hands, but not enough access and your users aren't able to be productive in their day-to-day work. The aim of this chapter is to help you answer these questions for you and your organization. </p>
			<p>Essentially, what I want from this chapter is to discuss the following bullet points:</p>
			<ul>
				<li>Access control models and concepts</li>
				<li>Selecting and implementing authentication and authorization mechanisms for people, devices, and services </li>
				<li>Identity and access management</li>
				<li>Controlling physical access to assets</li>
			</ul>
			<p>I know how exciting this all sounds for you because just writing this is making the hair on the back of my neck stand up straight. So, with that said, enough stalling; let's just get started! </p>
			<h1 id="_idParaDest-86"><a id="_idTextAnchor094"/>Access control models and concepts</h1>
			<p>When it comes<a id="_idIndexMarker569"/> to information security, the same idea applies from the<a id="_idIndexMarker570"/> physical security realm; <em class="italic">restricting access</em> to a location or asset is referred to as <strong class="bold">access control</strong>. When we say access, we could mean physically entering a space or digitally accessing a folder. We could mean reading a printed document in an office, but we can also consider the CRUD possibilities in a digital estate as well. </p>
			<p>The classic (or retro?) access control is a <strong class="bold">lock and key</strong>. If somebody has the key, they're able to access what the lock is preventing access to. And if they have the key, they're allowed to access it, right? Is it that simple? Of course not. What we want is the ability to ensure that the people with the key are the people with permission, and try our best to ensure that even <em class="italic">with</em> the key, the wrong people aren't allowed to (or <strong class="bold">authorized</strong> to) access<a id="_idIndexMarker571"/> what they shouldn't. </p>
			<p>Before diving into the <a id="_idIndexMarker572"/>models, I'd like to cover four key definitions first: </p>
			<ul>
				<li>A <strong class="bold">subject</strong> is a<a id="_idIndexMarker573"/> user or program that manipulates <em class="italic">objects</em>. Subjects can act.</li>
				<li>An <strong class="bold">object</strong> is passive<a id="_idIndexMarker574"/> data that is manipulated by <em class="italic">subjects</em>. Objects cannot act.</li>
				<li><strong class="bold">Clearance</strong> is assigned<a id="_idIndexMarker575"/> to a <em class="italic">subject</em>, which dictates their access level, for instance, <em class="italic">Confidential</em>, <em class="italic">Secret</em>, or <em class="italic">Top Secret</em>. </li>
				<li>The <strong class="bold">classification</strong> or <strong class="bold">confidentiality/integrity</strong> level is assigned to an <em class="italic">object</em>, depending on<a id="_idIndexMarker576"/> its nature or sensitivity. </li>
			</ul>
			<p>Now that those are covered, let's begin with the <strong class="bold">state machine model</strong>.</p>
			<h2 id="_idParaDest-87"><a id="_idTextAnchor095"/>State machine model</h2>
			<p>The <strong class="bold">state machine model</strong> is a <a id="_idIndexMarker577"/>concept of preventing a system from becoming insecure by the continual monitoring of its status. All of the potential <em class="italic">states</em> of the system and the ways to transition from one state to another are defined and regulated, along with any other actions. This way, the current state of the system is able to be predicted and compared against. </p>
			<p>A lot of these concepts are going to be a bit "wacky" to write out, and I think it might make more sense to use diagrams to help with conceptualizing their usefulness. Essentially, what a <strong class="bold">state machine diagram</strong> aims to do is to map out the various actions that can <a id="_idIndexMarker578"/>occur on a system, in order to prevent misuse:</p>
			<div><div><img src="img/Figure_5.01_B16611.jpg" alt="Figure 5.1 – State machine model diagram &#13;&#10;(source: https://commons.wikimedia.org/wiki/File:Finite_state_machine_example_with_comments.svg)"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.1 – State machine model diagram </p>
			<p class="figure-caption">(source: <a href="https://commons.wikimedia.org/wiki/File:Finite_state_machine_example_with_comments.svg">https://commons.wikimedia.org/wiki/File:Finite_state_machine_example_with_comments.svg</a>)</p>
			<p>In this example, we have a very simple system consisting of a single object, a door, that has two states, open and closed. The <em class="italic">transitions</em> that can occur are that a closed door can be opened and an opened door can be closed. These are triggered by the actions of <em class="italic">subjects</em>. Please, wake up, I can't have you fall asleep now; there are still three chapters after this<a id="_idIndexMarker579"/> one. Let's move on. </p>
			<h2 id="_idParaDest-88"><a id="_idTextAnchor096"/>Information flow model</h2>
			<p>Similar to (and <a id="_idIndexMarker580"/>extending<a id="_idIndexMarker581"/> on from) the <a id="_idIndexMarker582"/>state<a id="_idIndexMarker583"/> machine <a id="_idIndexMarker584"/>model is the <strong class="bold">information flow model</strong>, consisting of <strong class="bold">objects</strong>, <strong class="bold">state transitions</strong>, and <strong class="bold">flow policy states</strong> (or <strong class="bold">lattice states</strong>). It aims to prevent any insecure or unauthorized communication, no matter the direction of the flow. This model lends to the <strong class="bold">Biba</strong> and <strong class="bold">Bell-LaPadula</strong> models, which will be covered later on in this section. </p>
			<h2 id="_idParaDest-89"><a id="_idTextAnchor097"/>Confidentiality models</h2>
			<p>From the<a id="_idIndexMarker585"/> information flow and state machine models, we can transition into models that are focused primarily on confidentiality. Governments categorize information to be able to streamline the process of managing access to it, such as <em class="italic">Top Secret</em>, <em class="italic">Secret</em>, <em class="italic">Confidential</em>, and <em class="italic">Sensitive but Unclassified</em>. Let's look at how the Bell-LaPadula model, the Take-Grant model, and the Brewer and Nash model can help an organization manage access to information. </p>
			<h3>Bell-LaPadula model</h3>
			<p>By <a id="_idIndexMarker586"/>using <strong class="bold">Mandatory Access Control</strong> (<strong class="bold">MAC</strong>) to enforce a security policy across multiple levels, you <a id="_idIndexMarker587"/>enable the ability to manage access to information based on a subject's <em class="italic">need to know</em> and providing they meet or succeed the required clearance. </p>
			<p>When considering the Bell-LaPadula model, you should keep in mind the following properties: </p>
			<ul>
				<li><strong class="bold">No read up</strong>: Subjects <a id="_idIndexMarker588"/>aren't able to read information at a higher confidentially level than they have clearance to. This is pretty self-explanatory. In order to keep things confidential, you prevent people who are below a certain "level" from being able to know what's going on. It's standard and is <a id="_idIndexMarker589"/>appropriately called the <strong class="bold">simple security property</strong>. </li>
				<li><strong class="bold">No write down</strong>: Subjects aren't able to produce or contribute information that is classified at a lower confidentially level than they have clearance for. This is to prevent information that is classified at a higher "level" from being "written down" to a lower confidentiality-level document, either explicitly or through inference. </li>
				<li><strong class="bold">No read up/down and no write up/down</strong>: Also known as the <em class="italic">strong star * property</em>, this <a id="_idIndexMarker590"/>essentially enforces that in order to read or write to an object, the subject's clearance and the object's confidentiality must be equal. This is a strengthened version of the Bell-LaPadula model, which prevents the write-up operation from occurring. </li>
			</ul>
			<h3>Take-Grant model</h3>
			<p>The <strong class="bold">Take-Grant model</strong>, dating <a id="_idIndexMarker591"/>back to 1976, is a way to represent a system in a directed graph of nodes and connections, rather than a matrix, with the aim to easily be able to determine the safety of the system, even if it's complex. </p>
			<p>The basics are as follows: </p>
			<ul>
				<li><em class="italic">Subjects</em> can have the standard <em class="italic">read and write access rights</em>. </li>
				<li><em class="italic">Subjects</em> can also have state transition rules associated with them, such as <strong class="bold">take</strong>, <strong class="bold">grant</strong>, <strong class="bold">create</strong>, and <strong class="bold">remove</strong>. </li>
				<li>A <em class="italic">subject</em> with the <strong class="bold">take</strong> right can take the rights of another <em class="italic">object</em> or <em class="italic">subject</em>. </li>
				<li>The <strong class="bold">grant</strong> rule allows a <em class="italic">subject</em> to grant their own rights to another <em class="italic">object</em> or <em class="italic">subject</em>. </li>
				<li>The <strong class="bold">create</strong> rule allows a subject to create new <em class="italic">objects</em>. </li>
				<li>The <strong class="bold">revoke</strong> rule allows a subject to remove rights it has over another <em class="italic">object</em>. </li>
			</ul>
			<p>A Take-Grant diagram representation example is shown as follows. Keep in mind that <strong class="bold">D</strong> is a <strong class="bold">directory</strong> and <strong class="bold">F</strong> is a <strong class="bold">file</strong>, both being <strong class="bold">objects</strong>. </p>
			<p><strong class="bold">P1</strong> and <strong class="bold">P2</strong> are <strong class="bold">subjects</strong>. </p>
			<p>You might be able to decipher from the diagram that when a subject or an object has the <strong class="bold">take</strong> right for an object (or <strong class="bold">t</strong>), it can gain any rights the object has. If it has the <strong class="bold">grant</strong> right for an object (or <strong class="bold">g</strong>), it can pass any of its rights to that object. </p>
			<p>See the following<a id="_idIndexMarker592"/> diagram for further investigation, which is exactly the point: </p>
			<div><div><img src="img/Figure_5.02_B16611.jpg" alt="Figure 5.2 – A Take-Grant directed graph from https://commons.wikimedia.org/wiki/File:Take-grant_representation.svg&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.2 – A Take-Grant directed graph from https://commons.wikimedia.org/wiki/File:Take-grant_representation.svg</p>
			<p>Now let's look at the Brewer and Nash model.</p>
			<h3>Brewer and Nash model</h3>
			<p>The <strong class="bold">Brewer and Nash</strong>, or <strong class="bold">Chinese wall</strong>, model is<a id="_idIndexMarker593"/> focused on segmentation. Essentially, we <a id="_idIndexMarker594"/>want to prevent <em class="italic">conflict of interest</em> by allowing access to the group of information that the user needs, but nothing more. The goal of this model is to ensure that no information is able to flow in a way that would allow a conflict of interest to arise. </p>
			<p>It was initially created for the UK's finance sector and can be conceptualized by imagining a consultancy firm that provides services to several different companies. The employees at the consultancy firm who help with one client shouldn't have access to another client's information, as that could lead to issues around confidentiality. </p>
			<h2 id="_idParaDest-90"><a id="_idTextAnchor098"/>Integrity models</h2>
			<p>We have covered<a id="_idIndexMarker595"/> integrity previously, so I'll spare us both from going into it again. Keep in mind that certain organizations might be more focused on integrity loss than confidentiality loss. </p>
			<p>I'd like to go into the Biba and Clark-Wilson models, which address integrity. </p>
			<h3>Biba</h3>
			<p>Biba, or<a id="_idIndexMarker596"/> rather <strong class="bold">the Biba model</strong>, is conversely an access control model that focuses on addressing the concerns of <em class="italic">integrity</em>. </p>
			<p><strong class="bold">The Biba model</strong> was first published in 1977 and is another <em class="italic">lattice</em>-based model, like <em class="italic">Bell-LaPadula</em>. The defining properties of the Biba model for access control are as follows: </p>
			<ul>
				<li><strong class="bold">No read down</strong>: Subjects <a id="_idIndexMarker597"/>are not able to read objects at a lower classification than their clearance. The opposite of the Bell-LaPadula's <em class="italic">no read up</em> principle, Biba's <em class="italic">simple integrity property</em> ensures that subjects that are at a higher rank aren't reading documents that may be "tainted" with misinformation. </li>
				<li><strong class="bold">No write up</strong>: Subjects are not able to write to objects at a higher classification than their clearance. Also known as the <em class="italic">star * integrity property</em>, it prevents breaches to integrity in objects that shouldn't be "tainted" by contributions from below a certain clearance. </li>
				<li><strong class="bold">Invocation property</strong>: This property aims to prevent a subject from invoking another subject who has higher clearance. </li>
			</ul>
			<p>As you might have been able to tell, the Biba model doesn't address availability or confidentiality but focuses on integrity entirely. </p>
			<h3>Clark-Wilson</h3>
			<p>Next, we can speak<a id="_idIndexMarker598"/> about the <strong class="bold">Clark-Wilson model</strong>, dating back to 1987. Like most things from the 80s, it had commercial activities as the foundation of its creation. This model, like Biba, focuses on integrity. </p>
			<p>The key takeaways from the Clark-Wilson access control model are the separation of duties principle and that data must be accessed through an application that allows logging, and the auditing of those logs is imperative. </p>
			<p><strong class="bold">Authorized users</strong> aren't able<a id="_idIndexMarker599"/> to change (or perform a <strong class="bold">transformational procedure</strong>, in this case) <strong class="bold">constrained data items</strong> in a way that <a id="_idIndexMarker600"/>is deemed<a id="_idIndexMarker601"/> inappropriate. The logged statuses for constrained data items are <em class="italic">tampered</em>, <em class="italic">logged</em>, and <em class="italic">consistent</em>. </p>
			<p>In Clark-Wilson, users only have access to the data at their clearance level, not higher or lower, meaning each clearance level has its own set of data entirely. </p>
			<p>With that, to prevent this section from becoming overly long, I'd like to move on to briefly discuss how this applies to the real world. </p>
			<h2 id="_idParaDest-91"><a id="_idTextAnchor099"/>Real-world access control models </h2>
			<p>So, going back to our <a id="_idIndexMarker602"/>definitions from earlier, from a real-world perspective, what we're saying is the following: </p>
			<ul>
				<li><em class="italic">Subjects</em> are entities that perform actions on the system. Some systems give <em class="italic">subjects</em> a <strong class="bold">user ID</strong>. </li>
				<li><em class="italic">Objects</em> are the resources on the system. The <em class="italic">subjects</em> are potentially accessing them, and therefore access to <em class="italic">objects</em> should be controlled. </li>
				<li>Generally, we're <a id="_idIndexMarker603"/>looking at two ways to handle access<a id="_idIndexMarker604"/> control: <strong class="bold">capability-based models</strong>, and <strong class="bold">access control list (ACL)-based models</strong>. </li>
			</ul>
			<p>In <strong class="bold">capability-based models</strong>, subjects that possess a <strong class="bold">capability</strong> to an object (similar to ownership) are the subjects that have access to an object. They can transfer that capability to another user. </p>
			<p>In <strong class="bold">ACL-based models</strong>, subjects have access to an object if their ID is on a list of those with access to the object. If they don't, then "they're not on the list," and they get thrown into the street and a taxi splashes water all over their face and their cool red velvet suit is completely ruined. </p>
			<p>Both model types have the ability to treat a <strong class="bold">group of subjects</strong> as a <em class="italic">subject</em>. </p>
			<p>From there, let's dig further and investigate the real-world access control models that we see regularly: </p>
			<ul>
				<li><strong class="bold">Identity-Based Access Control</strong> (<strong class="bold">IBAC</strong>) is based on individuals and allows a more granular but more difficult-to-manage approach to access control. </li>
				<li><strong class="bold">Lattice-Based Access Control</strong> (<strong class="bold">LBAC</strong>) is a way of describing the rules for accessing an object or the rules for which objects a subject may access. For example, in a lattice approach, let's suppose you create rules that state the following: <p>- If the <em class="italic">classification</em> of <a id="_idIndexMarker605"/>the <em class="italic">object</em> is less than or equal to the <em class="italic">clearance</em> of the <em class="italic">subject</em>, then they are allowed to read it. </p><p>- If the <em class="italic">classification</em> of the <em class="italic">object</em> is less than the <em class="italic">clearance</em> of the <em class="italic">subject</em>, then they aren't able to write to it. </p><p>That's <em class="italic">Bell-LaPadula</em> in practice. I knew it wouldn't be a complete and utter waste of time to describe those models earlier! No read up, no write down, BOOM! </p></li>
				<li><strong class="bold">Role-Based Access Control</strong> (<strong class="bold">RBAC</strong>) is where we create clearance groups based on roles and <a id="_idIndexMarker606"/>put users into the various role groups. As a result, for access to <em class="italic">objects</em>, we eliminate the requirement for ad hoc decisions. If you have the role, you can access this <em class="italic">classification</em> of an <em class="italic">object</em>; if you don't, you can't. </li>
				<li><strong class="bold">Rule-Based Access Control</strong> (<strong class="bold">RAC</strong>) is <a id="_idIndexMarker607"/>associating rules with access, such as dictating that an <em class="italic">object</em> is only available from 09:00 to 17:00 on working days. </li>
				<li><strong class="bold">MAC</strong> is what we've<a id="_idIndexMarker608"/> been describing thus far, in the fact that we're using the <em class="italic">classification</em> of the <em class="italic">objects</em> to determine access, rather than allowing users to determine who gets access to what. </li>
				<li><strong class="bold">Discretionary Access Control</strong> (<strong class="bold">DAC</strong>) is where a data owner determines which subjects <a id="_idIndexMarker609"/>can access specific objects. SysAdmins create a directory structure that has various permissions, and the appropriate data is stored in the appropriate location. </li>
				<li><strong class="bold">Attribute-Based Access Control</strong> (<strong class="bold">ABAC</strong>) is where access is given to <em class="italic">subjects</em> through<a id="_idIndexMarker610"/> policies that check <em class="italic">subject</em> and <em class="italic">object</em> attributes. </li>
				<li><strong class="bold">Graph-Based Access Control</strong> (<strong class="bold">GBAC</strong>) uses graphs and a query language to define access<a id="_idIndexMarker611"/> based on organizational diagrams, which sets it apart from RBAC, for example. Doesn't<a id="_idIndexMarker612"/> this diagram remind you of Take-Grant directed graphs? </li>
			</ul>
			<div><div><img src="img/Figure_5.03_B16611.jpg" alt="Figure 5.3 – A GBAC organizational graph (source: https://commons.wikimedia.org/wiki/File:GBACOrgGraph.pdf)"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.3 – A GBAC organizational graph (source: https://commons.wikimedia.org/wiki/File:GBACOrgGraph.pdf)</p>
			<ul>
				<li><strong class="bold">History-Based Access Control</strong> (<strong class="bold">HBAC</strong>) is where access is determined after assessing the <a id="_idIndexMarker613"/>activities of the <em class="italic">subject</em>. This could include their behavior in the system, the amount of time between their requests for access, and the content of that request. </li>
				<li><strong class="bold">History of Presence-Based Access Control</strong> (<strong class="bold">HPBAC</strong>) is an analytical approach<a id="_idIndexMarker614"/> to access control, taking into consideration the occasions for access. You might set a policy to state that users have access to an object if last week they have accessed the same object four or more times. It's not a popular choice, I'll be honest. </li>
			</ul>
			<p>Now that we have <a id="_idIndexMarker615"/>those covered, let's delve further into the real world and talk about selecting and implementing authentication and authorization mechanisms. </p>
			<h1 id="_idParaDest-92"><a id="_idTextAnchor100"/>Selecting and implementing authentication and authorization mechanisms</h1>
			<p>Thankfully, we <a id="_idIndexMarker616"/>have actually covered some of the<a id="_idIndexMarker617"/> aspects of this topic previously. Just as a<a id="_idIndexMarker618"/> refresher, I think we should touch on <a id="_idIndexMarker619"/>authentication versus authorization before moving on to how we might select and implement the various IAM solutions to ensure we keep unauthorized users from gaining access to resources they shouldn't, and ensuring that the authorized users are able to access what they need to get on with their miserable lives. </p>
			<h2 id="_idParaDest-93"><a id="_idTextAnchor101"/>Authentication versus authorization </h2>
			<p><strong class="bold">Authentication</strong> is focused<a id="_idIndexMarker620"/> on the identity of the user, and ensuring they are <em class="italic">authentic</em>. Not in the way that they compliment you and actually mean it, but rather that they are who they say they are. </p>
			<p><strong class="bold">Authorization</strong> is focused on what that user is allowed to do (or authorized to do) when they are <em class="italic">authenticated</em>. </p>
			<p>A user can be <em class="italic">authenticated</em>, and due to their role as a data analyst have <em class="italic">authorization</em> to access the records they are currently working on. They might not have <em class="italic">authorization</em> for the new quantum levitation device that the company is currently prototyping in order to build the skateboard from Back to the Future: Part II, because the company is focused on confidentiality. </p>
			<p>We are able to associate authorization clearances with the sensitivity labels or classification of the organization's data, which we have previously mentioned. </p>
			<p>Authorization could be conceptualized as follows: </p>
			<p><em class="italic">"If a document has this classification, then users with these clearances are authorized to read, but not write or delete".</em></p>
			<p>Of course, these decisions are based on your organization's policies and vary heavily based on risk and requirements. </p>
			<p>How is it possible to confirm the identity of the user? Where do we store these properties and how are we able to automate the process using computer systems? Those two questions lead into the next section beautifully. </p>
			<h2 id="_idParaDest-94"><a id="_idTextAnchor102"/>Authentication and security</h2>
			<p>A crucial <a id="_idIndexMarker621"/>aspect<a id="_idIndexMarker622"/> of information security is <strong class="bold">authentication</strong>. It's at the center of many things we've covered thus far in this book. We want to allow known people to work on what they need to work on (but nothing more) without a hitch, but at the same time, we want to prevent unknown people from accessing anything they shouldn't. </p>
			<p>There are many ways to tackle this issue, and for many solutions, the goal can be the same but apply to different components inside the network architecture or system. </p>
			<p>Let's have a look at a few examples. We can, for example, authenticate a user through the following:</p>
			<ul>
				<li><strong class="bold">Password authentication</strong>, an example of "<em class="italic">something you know</em>." </li>
				<li><strong class="bold">Smart card authentication</strong>, an example of "<em class="italic">something you have</em>." </li>
				<li><strong class="bold">Biometric authentication</strong>, also known as "<em class="italic">something you are</em>," an example being <strong class="bold">fingerprint scanning</strong></li>
				<li>A combination of <a id="_idIndexMarker623"/>any of the preceding (or other) methods, known as <strong class="bold">multi-factor authentication</strong> (<strong class="bold">MFA</strong>) </li>
			</ul>
			<p>When it comes <a id="_idIndexMarker624"/>to MFA, we <a id="_idIndexMarker625"/>need to remember that entering a password and then "the name of your first dog" is not an example of <em class="italic">MFA</em>. Those are two things that you know. It might strengthen the authentication process, but it's not truly MFA. </p>
			<h3>Password authentication</h3>
			<p>The <a id="_idIndexMarker626"/>advantages of <strong class="bold">password authentication</strong> are<a id="_idIndexMarker627"/> pretty obvious: We have trained people around the world to know how to authenticate themselves using passwords. It's easy for users (unless they're my mother-in-law). If they forget their password (like my mother-in-law does), then they can reset it simply by having access to their email account (which my mother-in-law has forgotten the password of). </p>
			<p>Generally, this password<a id="_idIndexMarker628"/> is stored as a <strong class="bold">salted hash</strong>, and a service such as <strong class="bold">Microsoft Active Directory</strong> handles<a id="_idIndexMarker629"/> the secure storage of these credentials. </p>
			<p>Passwords on their own need to be difficult to guess, and the number of attempts at guessing a<a id="_idIndexMarker630"/> password <a id="_idIndexMarker631"/>should be <em class="italic">rate-limited</em> or blocked, to prevent <strong class="bold">dictionary attacks</strong> or <strong class="bold">brute-force attacks</strong>. </p>
			<p>Another mitigation<a id="_idIndexMarker632"/> against these attacks are <strong class="bold">password complexity requirements</strong>, where a password should not contain dictionary words, must have a certain number of characters, and must be a mix of letters, numbers, and symbols. Additionally, reusing the same password in multiple places allows for a breach in one service leading to account compromise elsewhere… but now we're canceling out the upside of passwords because they're supposed to be easy. <strong class="bold">Password managers</strong> give<a id="_idIndexMarker633"/> us a technological solution to this issue by automating the creation and utilization of complex passwords, provided a "master<a id="_idIndexMarker634"/> password" is <a id="_idIndexMarker635"/>entered, generally with MFA enabled. </p>
			<h3>Smart card authentication</h3>
			<p>By using a<a id="_idIndexMarker636"/> smart card, you're <a id="_idIndexMarker637"/>utilizing the "something you have" factor of authentication. The card has a chip that stores keys to identify a person and verify this information to the authentication process. </p>
			<p>Generally, these cards also require the use of a PIN for access to be granted, which provides the second factor of "something you know." It's a bit like the way we used to use ATMs to take cash out, back when cash was a thing. Generally, the PIN is a very weak password, but the number of attempts is limited to prevent attacks surrounding complexity. The PIN requirement also prevents somebody from just <em class="italic">finding</em> a smart card and being granted access to your system. </p>
			<h3>Biometric authentication</h3>
			<p>Another<a id="_idIndexMarker638"/> form of <em class="italic">authentication</em> is<a id="_idIndexMarker639"/> through <strong class="bold">biometrics</strong>. Scanning your retina, listening to the sound of your voice, reading your fingerprint or palm veins, or dripping your blood into a witch's copper bowl, these sorts of things. </p>
			<p>The advantages of biometrics are that there aren't any passwords to remember; you can't forget your fingerprint at home, and the likelihood of somebody having the same biometrics as another person is very slim – unless you are using something like Face ID on your iPhone, which<a id="_idIndexMarker640"/> occasionally doesn't work when it is actually you attempting to unlock your phone (<strong class="bold">false negative</strong>), or it works to unlock the screen of a similar-looking <a id="_idIndexMarker641"/>person (<strong class="bold">false positive</strong>). </p>
			<p>The negatives of biometrics are also obvious: </p>
			<ul>
				<li>You can't change your fingerprint. </li>
				<li>If somebody needs your fingerprint, they might just chop off your finger (in this situation, you can only hope it's for a fingerprint biometric). </li>
				<li>They cost way more to implement than passwords do. Before phones came out, nobody had<a id="_idIndexMarker642"/> a fingerprint scanner in their home.  </li>
			</ul>
			<h3>Single sign-on</h3>
			<p>Furthermore, entering<a id="_idIndexMarker643"/> in passwords is a bit of an annoying experience, especially if you're following best practices and using different passwords for each service, but not using a password manager. </p>
			<p>Instead of prompting the user to enter in a password each time they try to use a different service, there are solutions that allow for a more unified approach to authentication, such <a id="_idIndexMarker644"/>as <strong class="bold">single sign-on</strong>, or <strong class="bold">SSO</strong>, where a user is prompted to prove their identity once, and then give access to all of the resources they need. This usually requires a bit of configuration but can lead to reduced risk from password reuse and easier revocation of privileges, among other things. </p>
			<h3>Authentication protocols</h3>
			<p>Thankfully, authentication<a id="_idIndexMarker645"/> in the digital estate has become somewhat standardized through a few different protocols. Over time, these protocols have been improved from a security perspective, and their compatibility has expanded to include more use cases. </p>
			<p>As a result, it's worth going into the most common authentication methods and protocols that are utilized by organizations around the world currently, such as <strong class="bold">NTLM</strong>, <strong class="bold">Kerberos</strong>, and <strong class="bold">PKI</strong>. </p>
			<h4>Microsoft NTLM (NT LAN Manager)</h4>
			<p><strong class="bold">NTLM</strong>, or <strong class="bold">NT LAN Manager</strong>, is a<a id="_idIndexMarker646"/> revisioning<a id="_idIndexMarker647"/> of how authenticating in Windows works and an upgrade from LM, or LAN Manager, which merely passed the (weakly hashed) password over the network to the domain controller, which stores the authentication information for each user. With NTLM, now the hashed password is never actually sent over the network, but rather a message that has been encrypted with a hash of the password as the key. </p>
			<p>It is considered an outdated authentication protocol, but it is still widespread in IT systems because of its deep connection with <strong class="bold">Windows</strong>, <strong class="bold">Exchange</strong>, <strong class="bold">Active Directory</strong>, and <strong class="bold">Windows Server</strong> systems. </p>
			<p>Here's a<a id="_idIndexMarker648"/> diagram of how <a id="_idIndexMarker649"/>NTLM works: </p>
			<div><div><img src="img/Figure_5.04_B16611.jpg" alt="Figure 5.4 – NTLM authentication diagram &#13;&#10;(source: https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-apds/5bfd942e-7da5-494d-a640-f269a0e3cc5d)"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.4 – NTLM authentication diagram </p>
			<p class="figure-caption">(source: <a href="https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-apds/5bfd942e-7da5-494d-a640-f269a0e3cc5d">https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-apds/5bfd942e-7da5-494d-a640-f269a0e3cc5d</a>)</p>
			<p>To summarize, here are the steps: </p>
			<ol>
				<li>A user signs in to the <strong class="bold">client</strong> PC, which sends a message to the <strong class="bold">server</strong> requesting authentication. </li>
				<li>The <strong class="bold">server</strong> responds to the <strong class="bold">client</strong> with a challenge message as a response. </li>
				<li>The <strong class="bold">client</strong> encrypts their password with a 56-bit segment of an MD4 hash of their password, encrypts the server's challenge with it, and sends it back to the <strong class="bold">server</strong> as a response. This is part of the weakness of the protocol. </li>
				<li>The <strong class="bold">server</strong> passes the response through to the <strong class="bold">domain controller</strong>.</li>
				<li>The <strong class="bold">domain controller</strong> checks its records for a match and notifies the server whether the user can be authenticated or not. </li>
			</ol>
			<p>Because of flaws in the logic of NTLM, various issues have cropped up. For example, by relaying the NTLM <code>AUTHENTICATE_MESSAGE</code> to a rogue server with a dictionary, a <strong class="bold">rainbow table</strong> (pre-computed <a id="_idIndexMarker650"/>hashes of the most popular passwords), or the <em class="italic">hashcat</em> tool, they are able to quickly solve for username/password combinations. Currently, a modern GPU like the GTX 1060 is able to solve the NTLM for seven-character passwords in 1 second. </p>
			<p>Even worse, malicious actors are able to simply sniff the network for the NTLM hash from another client, and<a id="_idIndexMarker651"/> then <strong class="bold">pass-the-hash</strong> and authenticate as that user, because <a id="_idIndexMarker652"/>the <em class="italic">hash</em> is <strong class="bold">password-equivalent</strong> thanks to a lack of <em class="italic">salting</em>. </p>
			<p>Additionally, <strong class="bold">Remote Code Execution</strong> (<strong class="bold">RCE</strong>) is<a id="_idIndexMarker653"/> possible on machines that have NTLM <a id="_idIndexMarker654"/>enabled and access to<a id="_idIndexMarker655"/> administrative accounts on Exchange and Active Directory servers. </p>
			<p>Unfortunately, NTLM authentication is still used for local log-on authentication, and for any system that is part of a <strong class="bold">workgroup</strong>. Many applications use NTLM for authentication instead of the more recent <strong class="bold">Kerberos</strong> protocol (it's been 20 years, people! COME ON ALREADY!).</p>
			<p>If you find yourself with the requirement to keep NTLM enabled on machines and servers at your organization, there are a few mitigating steps you can take, but keep in mind that your team will be busy each time a new flaw is found, which is quite often. </p>
			<p>You can enforce <strong class="bold">SMB signing</strong> to prevent <strong class="bold">NTLM relay attacks</strong>. </p>
			<p>You can block the older version of <strong class="bold">NTLMv1</strong>, which is beyond saving. </p>
			<p>You can enforce <strong class="bold">LDAP/S signing</strong> and <strong class="bold">channel binding</strong> to prevent <strong class="bold">LDAP relay attacks</strong>. </p>
			<p>You can only accept <a id="_idIndexMarker656"/>requests with <strong class="bold">Enhanced Protection for Authentication </strong>(<strong class="bold">EPA</strong>) to prevent <strong class="bold">NTLM relay attacks</strong> on web servers. </p>
			<h4>Kerberos</h4>
			<p>To remedy many of <a id="_idIndexMarker657"/>these flaws from <strong class="bold">NTLM</strong>, <strong class="bold">Kerberos</strong> was <a id="_idIndexMarker658"/>introduced into <strong class="bold">Windows 2000</strong> onward for authentication. The three parts we'll include in this overview of Kerberos are the <strong class="bold">client</strong> (the user's PC, generally), the <strong class="bold">server</strong>, and <a id="_idIndexMarker659"/>the <strong class="bold">Key Distribution Center</strong> (<strong class="bold">KDC</strong>). </p>
			<p>Before we get into the process, let's have a look at the diagram here: </p>
			<div><div><img src="img/Figure_5.06_B16611.jpg" alt="Figure 5.5 – A diagram of Kerberos authentication &#13;&#10;(source: https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-kile/b4af186e-b2ff-43f9-b18e-eedb366abf13 )"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.5 – A diagram of Kerberos authentication </p>
			<p class="figure-caption">(source: <a href="https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-kile/b4af186e-b2ff-43f9-b18e-eedb366abf13">https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-kile/b4af186e-b2ff-43f9-b18e-eedb366abf13</a> )</p>
			<p>So, one of the first things we can see from this diagram is that the KDC is completely separate from the server, and there's no pass-through authentication happening as there was with NTLM.</p>
			<p>Let's discuss what is occurring and how it's a secure method of authentication: </p>
			<ul>
				<li><strong class="bold">Kerberos Authentication Service exchange</strong>: The <strong class="bold">client</strong> sends a request to the <strong class="bold">KDC</strong> for a <strong class="bold">ticket-granting ticket</strong> (yes, that's an incredibly awful name, let's instead <a id="_idIndexMarker660"/>call it the <strong class="bold">TGT</strong>). The client presents its principal name and can present pre-authentication information. This is represented on the diagram by <strong class="bold">(1) KRB_AS_REQ</strong>. <p>The <strong class="bold">KDC</strong> returns a <strong class="bold">TGT</strong> and a <strong class="bold">session key</strong> that the client can use to encrypt and authenticate communication with the <strong class="bold">KDC</strong> for <strong class="bold">Ticket-Granting Service</strong> (<strong class="bold">TGS</strong>) requests, without reusing the persistent key. This is represented on the diagram by <strong class="bold">(2) KRB_AS_REP</strong>. </p></li>
				<li><strong class="bold">Kerberos TGS exchange</strong>: The <strong class="bold">client</strong> then sends a request to the <strong class="bold">KDC</strong> for a <strong class="bold">ticket</strong> for the server. The client presents the <strong class="bold">TGT</strong>, a <strong class="bold">Kerberos authenticator</strong>, and<a id="_idIndexMarker661"/> the <strong class="bold">Service Principal Name</strong> (<strong class="bold">SPN</strong>), which is the name the client uses to identify a service for authentication purposes. A <strong class="bold">Kerberos authenticator</strong> is the client ID and a timestamp, encrypted with the <strong class="bold">session key</strong>, and helps the server detect <strong class="bold">replay attacks</strong> by proving that the <strong class="bold">authenticator</strong> is recently<a id="_idIndexMarker662"/> constructed. This is <a id="_idIndexMarker663"/>represented on the diagram by <strong class="bold">(3) KRB_TGS_REQ</strong>. <p>The <strong class="bold">KDC</strong> validates the <strong class="bold">TGT</strong> and the <strong class="bold">authenticator</strong>. If these are valid, the <strong class="bold">KDC</strong> returns a <strong class="bold">service ticket</strong> encrypted with the <strong class="bold">server</strong>'s <strong class="bold">long-term key</strong> (which is already stored in the <strong class="bold">KDC</strong>) and a session key, which the client can use to encrypt communication with the <strong class="bold">server</strong>. This is represented on the diagram by <strong class="bold">(4) KRB_TGS_REP</strong>. </p></li>
				<li><strong class="bold">Kerberos client/server authentication protocol exchange</strong>: From there, the <strong class="bold">client</strong> is able to request access to the <strong class="bold">server</strong> by providing the <strong class="bold">service ticket</strong> and a newly generated <strong class="bold">authenticator</strong>. The <strong class="bold">server</strong> then takes the <strong class="bold">service ticket</strong> and decrypts it with its long-term key, checks the <strong class="bold">authenticator</strong> is valid, and then uses the authorization data to dictate access control for the <strong class="bold">client</strong>. </li>
			</ul>
			<p>To ensure the <strong class="bold">server</strong> is genuine, the client is optionally able to request verification by having the <strong class="bold">server</strong> send the <strong class="bold">client's timestamp</strong> extracted from the <strong class="bold">authenticator</strong> (which was previously encrypted with the session key). By returning the timestamp, the <strong class="bold">client</strong> has proof that the <strong class="bold">server</strong> can decrypt the <strong class="bold">authenticator</strong>. Otherwise, the server could be<a id="_idIndexMarker664"/> just gathering information without sending anything<a id="_idIndexMarker665"/> back, leaving the client in the dark. </p>
			<h4>PKI and digital certificates</h4>
			<p>A crucial<a id="_idIndexMarker666"/> part of <strong class="bold">Public Key Infrastructure</strong> (<strong class="bold">PKI</strong>) is <strong class="bold">digital certificates</strong> (or <strong class="bold">public key certificates</strong>), which prove<a id="_idIndexMarker667"/> the ownership of a <em class="italic">key</em>, which is tied to<a id="_idIndexMarker668"/> identity –of <a id="_idIndexMarker669"/>either a user or a device. </p>
			<p>Certificate services are used in the <strong class="bold">TLS protocol</strong> (which protects data-in-transport on the web), as well as in email encryption schemes such as <strong class="bold">S/MIME</strong> and digital signature solutions. The<a id="_idIndexMarker670"/> advantage of <strong class="bold">public key cryptography</strong> (or <strong class="bold">asymmetric cryptography</strong>) is that, depending on which of your two keys you use<a id="_idIndexMarker671"/> to encrypt a message, you're able to ensure integrity, non-repudiation, and confidentiality. </p>
			<p>One of the most popular <a id="_idIndexMarker672"/>standard formats for <em class="italic">public key certificates</em> is called <strong class="bold">X.509</strong>, which is split into several different parts because of the wide range of use cases for this service. Essentially, this certificate sits on a device and silently provides authentication to servers behind the scenes. </p>
			<p>One major advantage <a id="_idIndexMarker673"/>of using an <strong class="bold">X.509 certificate</strong> is that we lose the requirement for a username and password combination, which we've talked about the weaknesses of previously. Using a <em class="italic">digital certificate</em> would ideally be done in combination with another factor of authentication, such as a PIN or an <strong class="bold">MFA app</strong> on the user's mobile phone that requires a fingerprint.</p>
			<p>By acting as a <strong class="bold">Certificate Authority</strong> (<strong class="bold">CA</strong>) in your organization's PKI, your <em class="italic">systems administrator</em> is able<a id="_idIndexMarker674"/> to distribute and revoke digital certificates at scale and utilize those certificates to meet the organization's <strong class="bold">access control policies</strong>. This is <a id="_idIndexMarker675"/>compatible with existing systems such as<a id="_idIndexMarker676"/> Active Directory or<a id="_idIndexMarker677"/> LDAP and provides a much more streamlined<a id="_idIndexMarker678"/> way<a id="_idIndexMarker679"/> of managing authentication in an organization. </p>
			<p>From here, let's move on to <strong class="bold">authorization</strong>.</p>
			<h2 id="_idParaDest-95"><a id="_idTextAnchor103"/>Authorization</h2>
			<p>Often paired <a id="_idIndexMarker680"/>together with <strong class="bold">authentication</strong>, <strong class="bold">authorization</strong> is the level of access that is given to a <strong class="bold">client</strong> or <strong class="bold">subject</strong> after authentication. Authorization isn't always required to access a resource, for example, searching on Google. You don't need to authenticate in order to perform a search on Google (although you can), and anybody that can visit <a href="http://google.com">google.com</a> in their browser has the authorization to use that resource. </p>
			<p>However, in order to access your Facebook messages, or to be able to change your profile picture, you need to <em class="italic">authenticate</em>, and then you have <em class="italic">authorization</em> to create, read, update, and delete content that you have ownership of. </p>
			<p>Essentially, computer systems allow a <em class="italic">programmatic decision-making process</em> to be implemented, which <em class="italic">provides authorization</em> based on information derived from a combination of the <em class="italic">authentication</em> process along with the <em class="italic">defined requirements for security and privacy</em>. </p>
			<p>Focusing on <em class="italic">authorization</em> at your organization is a crucial step in ensuring the appropriate access is given to the appropriate people, and nothing more. Yes, we're talking about <em class="italic">least-privilege</em> again, and there's a reason for it. Least-privilege is a huge part of ensuring your organization is secure, and although sometimes implementing the principle of least-privilege seems like a lot of work, the benefits are generally able to recoup that cost very quickly. </p>
			<p>We spoke about real-world access control models earlier. Leveraging them is a best practice in order to ensure you don't run into (or completely miss) the issues often seen in security breaches. Utilizing either <strong class="bold">MAC</strong>, <strong class="bold">DAC</strong>, <strong class="bold">RBAC</strong>, or <strong class="bold">ABAC</strong>, or a combination of those examples, is standard and seen often in information systems. </p>
			<p>As an example, you might combine an ACL with RBAC to create a set of rules for each role in your organization, allowing access to view the resources associated with their role, and potentially allowing editing, updating, or deleting those resources, as required. </p>
			<p>The best practice for managing these principles and ensuring your organization's users have the access they <a id="_idIndexMarker681"/>need, no more and no less, is to utilize an IAM tool suite. We are going to dive deeper into how to leverage those systems now. </p>
			<h1 id="_idParaDest-96"><a id="_idTextAnchor104"/>Identity and access management (IAM) </h1>
			<p>When we're<a id="_idIndexMarker682"/> looking into how we can possibly manage all of the authentication and authorization principles that we've gone into so far in this chapter, we can simplify the process by leveraging what are known as IAM tools. These tools help organizations give the right access to the right resources at the right time and generally help with maintenance by giving each user a single identity that is then maintained and monitored throughout their time at the organization. This could include employees, customers, or third parties. If a user changes roles or leaves, that is reflected in their access through the <em class="italic">IAM</em>. </p>
			<p>A <em class="italic">centrally managed identity repository system</em> for managing identity and regulating access leads to greater agility, better security, and higher levels of productivity, but requires technically experienced people to manage their administration. Furthermore, policies and procedures surrounding the regular administration and auditing of such systems are crucial to avoiding downtime and ensuring that security violations don't go unnoticed. </p>
			<p>Keep in mind that when we're looking at compliance requirements of the likes of <strong class="bold">HIPAA</strong>, <strong class="bold">SOX</strong>, or <strong class="bold">GDPR</strong>, or almost any other regulation or standard for information security or privacy, we'll see a requirement for <em class="italic">controlling access</em> to employee and customer information. IAM tools provide a powerful solution to ensure your organization is complying with those requirements. </p>
			<p>These systems are generally compatible with the previously mentioned protocols and processes, such as PKI, Kerberos, SSO, and password authentication, and allow for various implementation models, enabling users to work from home, authenticate to <em class="italic">SaaS</em> solutions from their mobile devices, and other non-traditional methods of working. </p>
			<p>It would be pointless <a id="_idIndexMarker683"/>to discuss managing identity at an enterprise level and not mention <strong class="bold">directories</strong>, such as <strong class="bold">Microsoft Active Directory</strong>. Directories are different from IAM tools but are a<a id="_idIndexMarker684"/> crucial part of their functioning. IAM tools manage information coming from multiple sources, such as HR tools or Active Directory, for example. </p>
			<p>Essentially, what we want from an IAM system is to automate the business processes surrounding the managing of these tools in your organization. Somebody new joins the company and a software solution for HR triggers the creation of a new user in the directory, which then triggers other actions based on what they might need on their first day. </p>
			<p><strong class="bold">Third-party identity services</strong>, including <strong class="bold">Identity-as-a-Service</strong> (<strong class="bold">IDaaS</strong>) cloud subscriptions, are<a id="_idIndexMarker685"/> increasingly popular and <a id="_idIndexMarker686"/>aim<a id="_idIndexMarker687"/> to reduce overhead and improve connectivity in this regard. </p>
			<p>With the automation available to reduce manual IT management tasks, a few things are required in order to properly utilize these services. Let's take a look at a few. </p>
			<h2 id="_idParaDest-97"><a id="_idTextAnchor105"/>Leveraging identity services</h2>
			<p>To begin <a id="_idIndexMarker688"/>with, <em class="italic">your organizational</em> <em class="italic">policies and procedures must be in place</em>. That's what I always say, and I always say it because it's always true. How could you possibly manage something as complex as the access control for your organization without writing down the rules? </p>
			<p>These policies and procedures will aim to answer the following questions:</p>
			<ul>
				<li>How is your organization going to handle access control? Is the focus on a <em class="italic">role-based approach</em>? Are we looking at <em class="italic">MAC</em> instead? </li>
				<li>How are <em class="italic">new employees provisioned</em>? With each new employee, how do we define their access? What occurs to ensure they are able to access everything from their first day at work? </li>
				<li>Which roles or employees have which level of authorization? This is likely to be connected to your approach and whether it's <em class="italic">RBAC</em>, <em class="italic">MAC</em>, <em class="italic">DAC</em>, and so on. </li>
				<li>When an employee <em class="italic">leaves the organization</em>, what is required to ensure they don't have access anymore? </li>
				<li>If a user requires an <em class="italic">exception</em> to the rules, how is that escalated, approved, and administrated? </li>
				<li>When is access reviewed? How do we ensure the access to resources isn't growing with each role change for a user at your company? </li>
				<li>How far can automation go? Can we automate <em class="italic">password resets</em>? What about the revocation of privileges based on changes perceived in HR systems? For example, say a user hands in their resignation. </li>
				<li>If an external consultant joins the company or a third-party needs temporary access, how<a id="_idIndexMarker689"/> is that handled? Is <em class="italic">federated identity management</em> employed? </li>
				<li>Which services are covered by <em class="italic">SSO</em>? </li>
				<li>How do you teach new users how to use these systems? Is there a printed handout? A web portal? Is there a person at the company who sits with them? Create a normal starting procedure and try to walk through the steps of what life is like for a new starter, in order to test your plan. </li>
			</ul>
			<p>Now that we have covered the concepts of IAM, I would like to move on to controlling physical access as part of our access control chapter. </p>
			<h1 id="_idParaDest-98"><a id="_idTextAnchor106"/>Controlling physical access to assets</h1>
			<p>When we're<a id="_idIndexMarker690"/> looking at access control in information security, sometimes we neglect the physical aspect in favor of the digital one. <em class="italic">Physical access to hard drives, machines, folders, or printed documents</em> has the potential to be highly valuable to a malicious actor and should be controlled. In this section, I <a id="_idIndexMarker691"/>will briefly discuss various concepts of <strong class="bold">physical security</strong> to consider. </p>
			<h2 id="_idParaDest-99"><a id="_idTextAnchor107"/>Physical access control</h2>
			<p>If we're looking at<a id="_idIndexMarker692"/> restricting access or entrance to a building or room and only allowing authorized individuals to enter the restricted area, we might look at a few solutions:</p>
			<ul>
				<li><strong class="bold">Human access control</strong>, such as <em class="italic">guards</em>, <em class="italic">receptionists</em>, or <em class="italic">ticket-checkers</em>. </li>
				<li><strong class="bold">Mechanical access control</strong>, such as <em class="italic">locks</em> and <em class="italic">keys</em>. </li>
				<li><strong class="bold">Technological access control</strong>, such as <em class="italic">mantraps</em>, <em class="italic">turnstiles</em>, <em class="italic">fingerprint or retina scanners</em>, <em class="italic">fob-based access control</em>, or <em class="italic">exit barriers</em>. </li>
				<li><strong class="bold">Fences or perimeter barriers</strong> may prevent individuals from being able to avoid the <em class="italic">access controls</em>. </li>
			</ul>
			<p>Access control systems can help manage and monitor the access to areas and log who, when, and where the access was attempted, and whether it was accepted or not. </p>
			<p>Physical locks and keys don't provide the ability to restrict access based on time or provide any records of entry. Additionally, there's little in the way of proving the keyholder is the individual who is supposed to have the key. </p>
			<p>Additionally, it's difficult to revoke access in the event of a lost or stolen key, and it's impossible to know whether a key has been duplicated in secret. </p>
			<p>In walks <strong class="bold">electronic access control</strong>, and just in time. </p>
			<h2 id="_idParaDest-100"><a id="_idTextAnchor108"/>Electronic access control</h2>
			<p>The <a id="_idIndexMarker693"/>advantage of <strong class="bold">electronic access control</strong>, or <strong class="bold">EAC</strong>, is <a id="_idIndexMarker694"/>that we can solve some of the previously listed shortcomings of the lock and key combination… or the combination lock, for that matter. </p>
			<p>With computers, we can do the following: </p>
			<ul>
				<li>Better restrict access by time</li>
				<li>Log entry attempts and successes</li>
				<li>Easily revoke access on a granular level, rather than having to replace the entire lock</li>
				<li>Gain other information to prove the individual has authorization rather than just the key</li>
			</ul>
			<p>On the topic of gaining other information, that's when we can get into MFA, asking the user for two or more<a id="_idIndexMarker695"/> of the following factors of information for authentication: </p>
			<ul>
				<li>Something they know, which could be a password or PIN</li>
				<li>Something they have, which could be a key fob or smart card</li>
				<li>Something they are, which could be a retina or fingerprint scan</li>
			</ul>
			<p>If a user is digitally accessing something, rather than physically, we might add one other "factor" type or "<em class="italic">somewhere they are</em>," which is a GPS location that proves the user is in a place deemed to prove their identity. For obvious reasons, that doesn't work for physical security access controls. </p>
			<h2 id="_idParaDest-101"><a id="_idTextAnchor109"/>Preventing exploitation</h2>
			<p>When it comes <a id="_idIndexMarker696"/>to physical security, we could be looking at various risks, such as the following: </p>
			<ul>
				<li>Tailgating, when an unauthorized person follows an authorized one into a restricted area, sometimes being let in through politeness of holding a door open. This can be mitigated with mantraps and turnstiles. </li>
				<li>Destruction, such as crashing a car through a wall in order to gain access, or prying a door open with a prybar. Detection of this activity and defense-in-depth mitigations such as bollards or steel bars may be required for the risk of this to be reduced to an acceptable level. </li>
				<li>Technological attacks, such as cloning smart cards or brute-forcing pins, which can be mitigated through MFA, rate-limiting, and so on. </li>
			</ul>
			<p>Among other things, it's worth considering the risks surrounding your physical access control and<a id="_idIndexMarker697"/> adding them to your risk register. </p>
			<h1 id="_idParaDest-102"><a id="_idTextAnchor110"/>Summary</h1>
			<p>Holy cannoli! We managed to cover so much in this chapter; it's really worth patting yourself on the back. </p>
			<p>We reviewed many of the various access control models and concepts, including classics such as <em class="italic">Bell-LaPadula</em> and <em class="italic">Biba</em>. Then, after those concepts were established, we looked at real-world examples, including <em class="italic">RBAC</em> and <em class="italic">DAC</em> models, and what those actually mean. </p>
			<p>We then proceeded on to the topic of how we might select and implement authentication and authorization mechanisms for people, devices, and services. We covered the difference between <em class="italic">authentication</em> and <em class="italic">authorization</em>, and how they work together to provide <em class="italic">access control</em> for security and privacy purposes. We covered <em class="italic">passwords</em>, <em class="italic">smart cards</em>, and <em class="italic">biometrics</em>, as well as some of the most-used protocols for <em class="italic">authentication</em>. </p>
			<p>Then we dove into what <em class="italic">IAM</em> is, and how you might utilize <em class="italic">identity services</em> at your organization to scale up and ensure your IT team isn't overwhelmed with menial access management tasks. </p>
			<p>We dipped our toe into how to control <em class="italic">physical access to assets</em> as well, which is often overlooked in this topic. </p>
			<p>With all of these topics covered, it looks to me as though you are better acquainted with the ideas that can help you to answer the questions we asked at the start of the chapter:</p>
			<ul>
				<li>How can you ensure an entity is actually the approved user they claim to be? </li>
				<li>How is it that we can enforce those rules in an automated way in our digital environment? </li>
				<li>How do you ensure the right number of permissions to enable productivity? </li>
			</ul>
			<p>Since we've covered those points, I'd say we've reached a major milestone in this book! We have covered enough information security topics to finally get into the topic of <a href="B16611_06_Final_JM_ePub.xhtml#_idTextAnchor112"><em class="italic">Chapter 6</em></a>, <em class="italic">Designing and Managing Security Testing Processes</em>. Without further ado, let's get started! </p>
		</div>
	</body></html>