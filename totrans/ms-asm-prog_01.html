<html><head></head><body>
        

                            
                    <h1 class="header-title">Intel Architecture</h1>
                
            
            
                
<div><q>-What languages do you usually use?<br/></q> <q>-C and Assembly. In fact, I love programming in Assembly.</q><br/>
<q>-Hmmm... I would not have publicly admitted that...</q></div>
<p>When speaking about the Assembly language, people usually imagine a sort of unknown and dangerous beast, which obeys only the weirdest representatives of the programming community, or a gun that may only be used for shooting your own leg. Just as any prejudice, this one is rooted in ignorance and the primal fear of the unknown. The purpose of this book is not only to help you overcome this prejudice, but also to show how the Assembly language may become a powerful tool, a sharp lancet, that will help you perform certain tasks, even sophisticated ones, with elegance and relative simplicity, avoiding the unnecessary complications which are, sometimes, implied by high-level languages.</p>
<p>First of all, what is the Assembly language? To put it simply and precisely, we may safely define the Assembly language as symbolic or human readable machine code as each Assembly instruction translates into a single machine instruction (with a few exceptions). To be even more precise, there is no such thing as a single Assembly language as, instead, there are numerous Assembly languages--one per platform, where a platform is a programmable device. Almost any programmable device with a certain instruction set may have its own Assembly language, but this is not always so. Exceptions are devices such as, for example, NAND flash chips, which have their own command set, but have no means for fetching instructions from memory and executing them without implicitly being told to do so.</p>
<p>In order to be able to effectively use the Assembly language, one has to have a precise understanding of the underlying platform, as programming in the Assembly language means "talking" directly to the device. The deeper such understanding is, the more efficient is Assembly programming; however, we are not going to look at this in great detail, as this is beyond the scope of the book. One book would not be enough to cover each and every aspect of the specific architecture. Since we are going to concentrate on the Intel architecture during the course of this book, let's try to obtain at least a general understanding of Intel's x86/AMD64 architectures, and try to enrich it and make it deeper.</p>
<p>This chapter, in particular, covers processor registers and the functionality thereof and briefly describes memory organization (for example, segmentation and paging).</p>
<ul>
<li><strong>General purpose registers</strong>: Despite the fact that some of them have special meanings under certain circumstances, these registers, as the name of the group states, may be used for any purpose.</li>
<li><strong>Floating point registers</strong>: These registers are used for floating point operations.</li>
<li><strong>Segment registers</strong>: These registers are hardly accessed by applications (the most common case is setting up structured exception handlers on Windows); however, it is important to cover them here so we may better understand the way the CPU percives RAM. The part of the chapter that discusses segment registers also addresses a few memory organization aspects, such as segmentation and paging.</li>
<li><strong>Control registers</strong>: This is a tiny group of registers of registers of high importance, as they control the behavior of the processor as well as enable or disable certain features.</li>
<li><strong>Debug registers</strong>: Although registers of this group are mainly used by debuggers, they add some interesting abilities to our code, for example the ability to set hardware breakpoints when tracing execution of a program.</li>
<li><strong>EFlags register</strong>: This is also known as the status register on some platforms. This one provides us with the information regarding the result of the latest <strong>arithmetic logic unit</strong> (<strong>ALU</strong>) operation performed, as well as some settings of the CPU itself.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Processor registers</h1>
                
            
            
                
<p>Each programmable device, and Intel processors are not an exception, has a set of general purpose registers--memory cells located physically on the die, thus providing low latency access. They are used for temporary storage of data that a processor operates on or data that is frequently accessed (if the amount of general purpose registers allows this). The amount and bit size of registers on an Intel CPU vary in accordance with the current mode of operation. An Intel CPU has at least two modes:</p>
<ul>
<li><strong>Real mode</strong>: This is the good old DOS mode. When the processor is powered up, it starts in the real mode, which has certain limitations, such as the size of the address bus, which is only 20 bits, and the segmented memory space.</li>
<li><strong>Protected mode</strong>: This was first introduced in 80286. This mode provides access to larger amount of memory, as it uses different memory segmentation mechanisms. Paging, introduced in 80386, allows even easier memory addressing virtualization.</li>
</ul>
<p>Since about 2003, we also have the so-called long mode--64-bit registers/addressing (although, not all 64 bits are used for addressing yet), flat memory model, and RIP-based addressing (addressing relative to the instruction pointer register). In this book, we will work with 32-bit protected (there is such a thing as the 16-bit protected mode, but that is out of scope) and Long, which is a 64-bit mode of operation. The long mode may be considered a 64-bit extension of the protected mode, which evolved from 16-bit to 32-bit. It is important to know that registers accessible in the earlier mode are also accessible in the newer mode, meaning that the registers that were accessible in the real mode are also accessible in the protected mode, and that registers accessible in the protected mode would also be accessible in the long mode (if long mode is supported by the processor). There are a few exceptions regarding the bit width of certain registers and we will look at this soon in this chapter. However, since 16-bit modes (real and 16-bit protected modes) are no longer used by application developers (with minor possible exceptions), in this book, we will work on protected and long modes only.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">General purpose registers</h1>
                
            
            
                
<p>Depending on the mode of the operation (protected or long), there are 8 to 16 available general purpose registers in modern Intel processors. Each register is divided into subregisters, allowing access to data with a bit width lower than the width of the register.</p>
<p>The following table shows general purpose registers (further referred to as GPR):</p>
<p> </p>
<div><img class="image-border" src="img/b5174939-0612-4c0e-b002-15a4074b8af3.png"/></div>
<div><img class="image-border" src="img/e4c9aef4-6a1f-4690-b55f-fb2f5b0dcd69.png"/></div>
<p>Table 1: x86/x86_64 registers</p>
<p>All R* registers are only available in the long mode. Registers SIL, DIL, BPL, and SPL are only available in the long mode. Registers AH, BH, CH, and DH cannot be used in instructions that are not valid outside the long mode.</p>
<p>For convenience, we will refer to the registers by their 32-bit names (such as EAX, EBX, and so on) when we do not need to explicitly refer to a register of a certain bit width. The preceding table shows all general purpose registers available on the Intel platform. Some of them are only available in the long mode (all 64-bit registers, R* registers, and a few of the 8-bit registers) and certain combinations are not allowed. However, despite the fact that we can use those registers for any purpose, some of them do have a special meaning in certain circumstances.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Accumulators</h1>
                
            
            
                
<p>The EAX register is also known as an <strong>accumulator</strong> and is used with multiplication and division operations, both as implied and target operands. It is important to mention that the result of a binary multiplication is twice the size of the operands and the result of a binary division consists of two parts (quotient and remainder), each of which has the same bit width as the operands. Since the x86 architecture began with 16-bit registers and for the sake of backward compatibility, the EDX register is used for storing partial results when the values of the operands are larger than could fit into 8 bits. For example, if we want to multiply two bytes, <kbd>0x50</kbd> and <kbd>0x04</kbd>, we would expect the result to be <kbd>0x140</kbd>, which cannot be stored in a single byte. However, since the operands were 8 bits in size, the result is stored into the AX register, which is 16 bits. But if we want to multiply <kbd>0x150</kbd> by <kbd>0x104</kbd>, the result would need 17 bits to be stored (<kbd>0x150 * 0x104 = 0x15540</kbd>) and, as we have mentioned already, the first x86 registers were only 16 bits. This is the reason for using an additional register; in the case of the Intel architecture, this register is EDX (to be more precise, only the DX part would be used in this specific case). As a verbal explanation may sometimes be too generalized, it would be better to simply demonstrate the rule.</p>
<table class="MsoTableGrid" style="width: 736px;height: 325px">
<tbody>
<tr>
<td><strong>Operand size</strong></td>
<td><strong>Source 1</strong></td>
<td><strong>Source 2</strong></td>
<td><strong>Destination</strong></td>
</tr>
<tr>
<td>8 bits (byte)</td>
<td>AL</td>
<td>8-bit register or 8-bit memory</td>
<td>AX</td>
</tr>
<tr>
<td>16 bits (word)</td>
<td>AX</td>
<td>16-bit register or 16-bit memory</td>
<td>DX:AX</td>
</tr>
<tr>
<td>32 bits (double word)</td>
<td>EAX</td>
<td>32-bit register or 32-bit memory</td>
<td>EDX:EAX</td>
</tr>
<tr>
<td>64 bits (quad word)</td>
<td>RAX</td>
<td>64-bit register or 64-bit memory</td>
<td>RDX:RAX</td>
</tr>
</tbody>
</table>
<p>Division implies a slightly different rule. To be more precise, this is the inverted multiplication rule, meaning that the result of the operation is half the bit width of the dividend, which in turn means that the largest dividend in the long mode may be 128-bit wide. The smallest dividend value remains the same as in the smallest value of the source operand in the case of multiplication--8 bits.</p>
<table class="MsoTableGrid">
<tbody>
<tr>
<td><strong>Operand size</strong></td>
<td><strong>Dividend</strong></td>
<td><strong>Divisor</strong></td>
<td><strong>Quotient</strong></td>
<td><strong>Remainder</strong></td>
</tr>
<tr>
<td>8/16 bits</td>
<td>AX</td>
<td>8-bit register or 8-bit memory</td>
<td>AL</td>
<td>AH</td>
</tr>
<tr>
<td>16/32 bits</td>
<td>DX:AX</td>
<td>16-bit memory or 16-bit register</td>
<td>AX</td>
<td>DX</td>
</tr>
<tr>
<td>32/64 bits</td>
<td>EDX:EAX</td>
<td>32-bit register or 32-bit memory</td>
<td>EAX</td>
<td>EDX</td>
</tr>
<tr>
<td>64/128 bits</td>
<td>RDX:RAX</td>
<td>64-bit register or 64-bit memory</td>
<td>RAX</td>
<td>RDX</td>
</tr>
</tbody>
</table>


            

            
        
    

        

                            
                    <h1 class="header-title">Counter</h1>
                
            
            
                
<p>ECX register - also known as counter register. This register is used in loops as a loop iteration counter. It is first loaded with a number of iterations, and then decremented each time the loop instruction is executed until the value stored in ECX becomes zero, which instructs the processor to break out of the loop. We can compare this to the <kbd>do{...}while()</kbd> clause in C:</p>
<pre>int ecx = 10; <br/>do <br/>{ <br/>    // do your stuff <br/>    ecx--; <br/>}while(ecx &gt; 0);</pre>
<p>Another common usage of this register, actually the usage of its least significant part, CL, is in bitwise shift operations, where it contains the number of bits in which the source operand should be shifted. Consider the following code, for example:</p>
<pre>mov eax, 0x12345<br/>mov cl, 5 <br/>shl eax, cl</pre>
<p>This would result in the register EAX being shifted 5 bits to the left (having the value of <kbd>0x2468a0</kbd> as a result).</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Stack pointer</h1>
                
            
            
                
<p>An ESP register is the stack pointer. This register, together with the SS register (the SS register is explained a bit later in this chapter), describes the stack area of a thread, where SS contains the descriptor of the stack segment and ESP is the index that points to the current position within the stack.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Source and destination indices</h1>
                
            
            
                
<p>ESI and EDI registers serve as source and destination index registers in string operations, where ESI contains the source address and EDI, obviously, the destination address. We will talk about these registers a bit more in <a href="57c5447c-2cc4-4a48-9c46-6825e4a83a9c.xhtml">Chapter 3</a>, <em>Intel Instruction Set Architecture (ISA)</em>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Base pointer</h1>
                
            
            
                
<p>EBP. This register is called the base pointer as its most common use is to point to the base of a stack frame during function calls. However, unlike the previously discussed registers, you may use any other register for this purpose if needed.</p>
<p>Another register worth mentioning here is EBX, which, in the good old days of 16-bit modes (when it was still just a BX register), was one of the few registers that we could use as a base for addressing. Unlike EBP, EBX was (in the case of the XLAT instruction, which by default uses DS:EBX, still is) intended to point to a data segment.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Instruction pointer</h1>
                
            
            
                
<p>There is one more special register that cannot be used for data storage--EIP (IP in the real mode or RIP in the long mode). This is the instruction pointer and contains the address of the instruction after the instruction currently being executed. All instructions are implicitly fetched from the code segment by the CPU; thus the full address of the instruction following the one being executed should be described as CS:IP. Also, there is no regular way to modify its content directly. It is not impossible, but we can't just use a <kbd>mov</kbd> instruction in order to load a value into EIP.</p>
<p>All the other registers have no special meaning from the processor's perspective and may be used for any purpose.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Floating point registers</h1>
                
            
            
                
<p>The CPU itself has no means for floating point arithmetic operations. In 1980, Intel announced the Intel 8087 - the floating point coprocessor for the 8086 line. 8087 remained as a separate installable device until 1989, when Intel came up with the 80486 (i486) processor, which had an integrated 8087 circuit. However, when talking about floating point registers and floating point instructions, we still refer to 8087 as a floating-point unit (FPU) or, sometimes, still as a floating-point coprocessor (however, the latter is becoming more and more rare).</p>
<p>8087 has eight registers, 80 bits each, arranged in a stack fashion, meaning that operands are pushed onto this stack from the memory and results are popped from the topmost register to the memory. These registers are named ST0 to ST7 (ST--stack) and the most used one, that is, the ST0 register, may be referred to as simply ST.</p>
<p>The floating-point coprocessor supports several data types:</p>
<ul>
<li>80-bit extended-precision real</li>
<li>64-bit double-precision real</li>
<li>32-bit single-precision real</li>
<li>18-digit decimal integer</li>
<li>64-bit binary integer</li>
<li>32-bit binary integer</li>
<li>16-bit binary integer</li>
</ul>
<p>The floating-point coprocessor will be discussed in more detail in <a href="57c5447c-2cc4-4a48-9c46-6825e4a83a9c.xhtml" target="_blank">Chapter 3</a>, <em>Intel Instruction Set Architecture (ISA)</em>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">XMM registers</h1>
                
            
            
                
<p>The 128-bit XMM registers are part of the SSE extension (where <strong>SSE</strong> is short for <strong>Streaming SIMD Extension</strong>, and <strong>SIMD</strong>, in turn, stands for <strong>single instruction multiple data</strong>). There are eight XMM registers available in non -64-bit modes and 16 XMM registers in long mode, which allow simultaneous operations on:</p>
<ul>
<li>16 bytes</li>
<li>eight words</li>
<li>four double words</li>
<li>two quad words</li>
<li>four floats</li>
<li>two doubles</li>
</ul>
<p>We will pay much more attention to these registers and the technology behind them in <a href="81d8a530-f9fe-484d-83f7-652ce31bfa1c.xhtml">Chapter 5</a>, <em>Parallel Data Processing</em>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Segment registers and memory organization</h1>
                
            
            
                
<p>Memory organization is one of the most important aspects of CPU design. The first thing to note is that when we say "memory organization", we do not mean its physical layout on memory chips/boards. For us, it is much more important how the CPU sees memory and how it communicates with it (on a higher level, of course, as we are not going to dive into the hardware aspects of the architecture).</p>
<p>However, as the book is dedicated to application programming, rather than operating system development, we will further consider the most relevant aspects of memory organization and access in this section.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Real mode</h1>
                
            
            
                
<p>Segment registers are a rather interesting topic, as they are the ones that tell the processor which memory areas may be accessed and how exactly they may be accessed. In real mode, segment registers used to contain a 16-bit segment address. The difference between a normal address and segment address is that the latter is shifted 4 bits to the right when stored in the segment register. For example, if a certain segment register was loaded with the <kbd>0x1234</kbd> value, it, in fact, was pointing to the address <kbd>0x12340</kbd>; therefore, pointers in real mode were rather offsets into segments pointed to by segment registers. As an example, let's take the DI register (as we are talking about a 16-bit real mode now), which is used with the DS (data segment) register automatically, and load it with, let's say, <kbd>0x4321</kbd> when the DS register is loaded with the <kbd>0x1234</kbd> value. Then the 20-bit address would be <kbd>0x12340 + 0x4321 = 0x16661</kbd>. Thus, it was possible to address at most 1 MB of memory in real mode.</p>
<p>There are in total six segment registers:</p>
<ul>
<li><strong>CS</strong>: This register contains the base address of the currently used code segment.</li>
<li><strong>DS</strong>: This register contains the base address of the currently used data segment.</li>
<li><strong>SS</strong>: This register contains the base address of the currently used stack segment.</li>
<li><strong>ES</strong>: This is the extra data segment for the programmer's use.</li>
<li><strong>FS</strong> and <strong>GS</strong>: These were introduced with the Intel 80386 processor. These two segment registers have no specific hardware-defined function and are for the programmer's use. It is important to know that they do have specific tasks in Windows and Linux, but those tasks are operating system dependent only and have no connection to hardware specifications.</li>
</ul>
<p>The CS register is used together with the IP register (the instructions pointer, also known as the program counter on other platforms), where the IP (or EIP in protected mode and RIP in long mode) points to the offset of the instruction in the code segment following the instruction currently being executed.</p>
<p>DS and ES are implied when using SI and DI registers, respectively, unless another segment register is implicitly specified in the instruction. For example, the <kbd>lodsb</kbd> instruction, although, it is written with no operands, loads a byte from the address specified by DS:SI into the AL register and the <kbd>stosb</kbd> instruction (which has no visible operands either) stores a byte from the AL register at the address specified by ES:DI. Using SI/DI registers with other segments would require explicitly mentioning those segments with the relevant segment register. Consider the following code, for example:</p>
<pre>mov ax, [si] <br/>mov [es:di], ax</pre>
<p>The preceding code loads a double word from the location pointed by DS:SI and stores it to another location pointed by ES:DI.</p>
<p>The interesting thing about segment registers and segments at all is that they may peacefully overlap. Consider a situation where you want to copy a portion of code to either another place in the code segment or into a temporary buffer (for example, for decryptor). In such a case, both CS and DS registers may either point to the same location or the DS register may point somewhere into the code segment.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Protected mode - segmentation</h1>
                
            
            
                
<p>While it was all fine and simple in real mode, things become a bit more complicated when it comes to protected mode. Unfortunately, memory segmentation is still intact, but the segment register no longer contain addresses. Instead, they are loaded with the so-called selectors, which are, in turn, the indices into the descriptor table multiplied by 8 (shifted 3 bits to the left). The two least significant bits designate the requested privilege level (0 for kernel space to 3 for user land). The third bit (at index 2) is the <strong>TI</strong> bit (<strong>table indicator</strong>), which indicates whether the descriptor being referred is in a global descriptor table (0) or in a local descriptor table (1). The memory descriptor is a tiny 8-byte structure, which describes the range of physical memory, its access rights, and some additional attributes:</p>
<div><img class="image-border" height="435" src="img/36cdd2b3-3d39-4bab-9dff-512d9d120b34.png" width="545"/></div>
<p>Table 2: Memory descriptor structure</p>
<p>Descriptors are stored in at least two tables:</p>
<ul>
<li><strong>GDT</strong>: Global descriptor table (used by the operating system)</li>
<li><strong>LDT</strong>: Local descriptor table (per task descriptor table)</li>
</ul>
<p>As we may conclude, the organization of memory in protected mode is not that different from that in real mode after all.</p>
<p>There are other types of descriptors--interrupt descriptors (stored in the <strong>interrupt description table</strong> (<strong>IDT</strong>)) and system descriptors; however, since these are in use in kernel space only, we will not discuss them, as that falls out of the scope of this book.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Protected mode - paging</h1>
                
            
            
                
<p>Paging is a more convenient memory management scheme introduced in 80386 and has been a bit enhanced since then. The idea behind paging is memory virtualization--this is the mechanism that makes it possible for different processes to have the same memory layout. In fact, the addresses we use in pointers (if we are writing in C, C++, or any other high-level language that compiles into native code) are virtual and do not correspond to physical addresses. The translation of a virtual address into a physical address is implemented in hardware and is performed by the CPU (however, some operating system interventions are possible).</p>
<p>By default, a 32-bit CPU uses a two-level translation scheme for the derivation of a physical address from the supplied virtual one.</p>
<p>The following table explains how a virtual address is used in order to find a physical address:</p>
<table class="MsoTableGrid">
<tbody>
<tr>
<td><strong>Address bits</strong></td>
<td><strong>Meaning</strong></td>
</tr>
<tr>
<td>0 - 11</td>
<td>Offset into a 4 KB page</td>
</tr>
<tr>
<td>12 - 21</td>
<td>Index of the page entry in the table of 1024 pages</td>
</tr>
<tr>
<td>22 - 31</td>
<td>Index of the page table entry in a 1024-entries page directory</td>
</tr>
</tbody>
</table>
<p>Table 3: Virtual address to physical address translation</p>
<p>Most, if not all, modern processors based on the Intel architecture also support <strong>Page Size Extension</strong> (<strong>PSE</strong>), which makes it possible to use the so-called large pages of 4 MB. In this case, the translation of a virtual address into a physical address is a bit different, as there is no page table any more. The following table shows the meaning of bits in a 32-bit virtual address:</p>
<table class="MsoTableGrid">
<tbody>
<tr>
<td><strong>Address bits</strong></td>
<td><strong>Meaning</strong></td>
</tr>
<tr>
<td>0 - 21</td>
<td>Offset into a 4 MB page</td>
</tr>
<tr>
<td>22 - 31</td>
<td>Index of the corresponding entry in a 1024-entries page directory</td>
</tr>
</tbody>
</table>
<p>Table 4: Virtual address to physical address translation with PSE enabled</p>
<p>Furthermore, the <strong>Physical Address Extension</strong> (<strong>PAE</strong>) was introduced, which significantly changes the scheme and allows access to a much bigger range of memory. In protected mode, PAE adds a page directory pointer table of four entries and the virtual to physical address conversion would be as per the following table:</p>
<table class="MsoTableGrid">
<tbody>
<tr>
<td><strong>Address bits</strong></td>
<td><strong>Meaning</strong></td>
</tr>
<tr>
<td>0 - 11</td>
<td>Offset into a 4 KB page</td>
</tr>
<tr>
<td>12 - 20</td>
<td>Index of a page entry in the table of 512 pages</td>
</tr>
<tr>
<td>21 - 29</td>
<td>Index of a page table entry in a 512-entries page directory</td>
</tr>
<tr>
<td>30 - 31</td>
<td>Index of a page directory entry in a four-entries page directory pointer table</td>
</tr>
</tbody>
</table>
<p>Table 5: Virtual to physical address translation with PAE enabled (no PSE)</p>
<p>Enabling PSE in addition to PAE forces each entry in the page directory to point directly to a 2 MB page instead of an entry in a page table.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Long mode - paging</h1>
                
            
            
                
<p>The only address virtualization allowed in long mode is paging with PAE enabled; however, it adds one more table--the page map level 4 table as the root entry; therefore, the conversion of a virtual address to a physical address uses the bits of a virtual address in the way described in the following table:</p>
<table class="MsoTableGrid">
<tbody>
<tr>
<td><strong>Address bits</strong></td>
<td><strong>Meaning</strong></td>
</tr>
<tr>
<td>0 - 11</td>
<td>Offset into a 4 KB page</td>
</tr>
<tr>
<td>12 - 20</td>
<td>Index of a page entry in the table of 512 pages</td>
</tr>
<tr>
<td>21 - 29</td>
<td>Index of a page table entry in the page directory</td>
</tr>
<tr>
<td>30 - 38</td>
<td>Index of a page directory entry in the page directory pointer table</td>
</tr>
<tr>
<td>39 - 47</td>
<td>Index of a page directory pointer table in the page-map level 4 table</td>
</tr>
</tbody>
</table>
<p>Table 6: Virtual to physical address translation in long mode</p>
<p>It is, however, important to mention that despite the fact that it is a 64-bit architecture, the MMU only uses the first 48 bits of the virtual address (also called the linear address).</p>
<p>The whole process of address resolution is performed by the <strong>memory management unit</strong> (<strong>MMU</strong>) in the CPU itself, and the programmer is only responsible for actually building these tables and enabling PAE/PSE. However, this topic is much wider than may be covered in a single chapter and falls a bit out of the scope of this book.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Control registers</h1>
                
            
            
                
<p>Processors based on the Intel architecture have a set of control registers that are used for configuration of the processor at run time (such as switching between execution modes). These registers are 32-bit wide on x86 and 64-bit wide on AMD64 (long mode).</p>
<p>There are six control registers and one <strong>Extended Feature Enable Register</strong> (<strong>EFER</strong>):</p>
<ul>
<li><strong>CR0</strong>: This register contains various control flags that modify the basic operation of the processor.</li>
<li><strong>CR1</strong>: This register is reserved for future use.</li>
<li><strong>CR2</strong>: This register contains the Page Fault Linear Address when a page fault occurs.</li>
<li><strong>CR3</strong>: This register is used when virtual addressing is enabled (paging) and contains the physical address of the page directory, page directory pointer table, or page map level 4 table, depending on the current mode of operation.</li>
<li><strong>CR4</strong>: This register is used in the protected mode for controlling different options of the processor.</li>
<li><strong>CR8</strong>: This register is new and is only available in long mode. It is used for prioritization of external interrupts.</li>
<li><strong>EFER</strong>: This register is one of the several model-specific registers. It is used for enabling/disabling SYSCALL/SYSRET instructions, entering/exiting long mode, and a few other features. Other model-specific registers are of no interest for us.</li>
</ul>
<p>However, these registers are not accessible in <kbd>ring3</kbd> (user land).</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Debug registers</h1>
                
            
            
                
<p>In addition to control registers, processors also have a set of so-called debug registers, which are mostly used by debuggers for setting the so-called hardware breakpoints. These registers are in fact a very powerful tool when it comes to control over other threads or even processes.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Debug address registers DR0 - DR3</h1>
                
            
            
                
<p>Debug registers 0 to 3 (DR0, DR1, DR2, and DR3) are used to store virtual (linear) addresses of the so-called hardware breakpoints.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Debug control register (DR7)</h1>
                
            
            
                
<p>DR7 defines how the breakpoints set in <strong>Debug Address Registers</strong> should be interpreted by the processor and whether they should be interpreted at all.</p>
<p>The bits layout of this register is shown in the following table:</p>
<div><img class="image-border" height="336" src="img/419c0ba2-0820-456b-bcba-26304a641d71.png" width="496"/></div>
<p>Table 3: DR7 bit layout</p>
<p class="mce-root">L* bits, when set to 1, enable breakpoint at the address which is specified in the corresponding Debug Address Register locally--within a task. These bits are reset by the processor on each task switch. G* bits, on the contrary, enable breakpoints globally--for all tasks, meaning that these bits are not reset by the processor.</p>
<p class="mce-root">The R/W* bits specify breakpoint conditions, as follows:</p>
<ul>
<li><kbd>00</kbd>: Break on instruction execution</li>
<li><kbd>01</kbd>: Break when the specified address is accessed for writing only</li>
<li><kbd>10</kbd>: Undefined</li>
<li><kbd>11</kbd>: Break on either read or write access or when an instruction at the specified address is executed</li>
</ul>
<p>The LEN* bits specify the size of a breakpoint in bytes, thus, allowing coverage of more than one instruction or more than one byte of data:</p>
<ul>
<li><kbd>00</kbd>: Breakpoint is 1-byte long</li>
<li><kbd>01</kbd>: Breakpoint is 2-bytes long</li>
<li><kbd>10</kbd>: Breakpoint is 8-bytes long (long mode only)</li>
<li><kbd>11</kbd>: Breakpoint is 4-bytes long</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Debug status register (DR6)</h1>
                
            
            
                
<p>When an enabled breakpoint is triggered, the corresponding bit of the four low-order bits in DR6 is set to 1 before entering the debug handler, thus, providing the handler with information about the triggered breakpoint (bit 0 corresponds to the breakpoint in DR0, bit 1 to the breakpoint in DR1, and so on).</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The EFlags register</h1>
                
            
            
                
<p>It would have been impossible to write programs in any language for a given platform if the processor had no means to report its status and/or the status of the last operation. More than that, the processor itself needs this information from time to time. Try to imagine a processor unable to conditionally control the execution flow of a program--sounds like a nightmare, doesn't it?</p>
<p>The most common way for a program to obtain information on the last operation or on a certain configuration of an Intel-based processor is through the <strong>EFlags</strong> register (<strong>E</strong> stands for extended). This register is referred to as Flags in real mode, EFlags in protected mode, or <strong>RFlags</strong> in long mode.</p>
<p>Let's take a look at the meaning of the individual bits (also referred to as flags) of this register and its usage.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Bit #0 - carry flag</h1>
                
            
            
                
<p>The <strong>carry flag</strong> (<strong>CF</strong>) is mostly used for the detection of carry/borrow in arithmetic operations and is set if the bit width result of the last such operation (such as addition and subtraction) exceeds the width of the ALU. For example, the addition of two 8-bit values, 255 and 1, would result in 256, which requires at least nine bits to be stored. In such a case, bit eight (the ninth bit) is placed into the CF, thus, letting us and the processor know that the last operation ended with carry.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Bit #2 - parity flag</h1>
                
            
            
                
<p>The <strong>parity flag</strong> (<strong>PF</strong>) is set to 1 in case the number of 1s in the least significant byte is even; otherwise, the flag is set to zero.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Bit #4 - adjust flag</h1>
                
            
            
                
<p>The <strong>adjust flag</strong> (<strong>AF</strong>) signals when a carry or borrow occurred in the four least significant bits (lower nibble) and is primarily used with <strong>binary coded decimal</strong> (<strong>BCD</strong>) arithmetics.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Bit #6 - zero flag</h1>
                
            
            
                
<p>The <strong>zero flag</strong> (<strong>ZF</strong>) is set when the result of an arithmetic or bitwise operation is 0. This includes operations that do not store the result (for example, comparison and bit test).</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Bit #7 - sign flag</h1>
                
            
            
                
<p>The <strong>sign flag</strong> (<strong>SF</strong>) is set when the last mathematical operation resulted in a negative number; in other words, when the most significant bit of the result was set.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Bit #8 - trap flag</h1>
                
            
            
                
<p>When set, the <strong>trap flag</strong> (<strong>TF</strong>) causes a single step interrupt after every executed instruction.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Bit #9 - interrupt enable flag</h1>
                
            
            
                
<p>The <strong>interrup enable flag</strong> (<strong>IF</strong>) defines whether processor will or will not react to incoming interrupts. This flag is only accessible in real mode or at the Ring 0 protection level in other modes.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Bit #10 - direction flag</h1>
                
            
            
                
<p>The <strong>direction flag</strong> (<strong>DF</strong>) controls the direction of string operations. An operation is performed from the lower address to the higher address if the flag is reset (is 0) or from the higher address to the lower address if the flag is set (is 1).</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Bit #11 - overflow flag</h1>
                
            
            
                
<p>The <strong>overflow flag</strong> (<strong>OF</strong>) is sometimes perceived as two's complement form of the carry flag, which is not really the case. OF is set when the result of the operation is either too small or too big a number to fit into the destination operand. For example, consider the addition of two 8-bit positive values, 0x74 and 0x7f. The resulting value of such an addition is 0xf3, which is still 8-bit, which is fine for unsigned numbers, but since we added two values that we considered to be signed, there has to be the sign bit and there are no more bits to store the 9-bit signed result. The same would happen if we try to add two negative 8-bit values, 0x82 and 0x81. The meaning of the addition of two negative numbers is in the fact subtraction of a positive number from a negative number, which should result in an even smaller number. Thus, 0x82 + 0x81 would result in 0x103, where the ninth bit, 1, is the sign bit, but it cannot be stored in an 8-bit operand. The same applies to larger operands (16, 32, and 64-bit).</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Remaining bits</h1>
                
            
            
                
<p>The remaining 20 bits of the EFlags register are not that important for us while in user-land except, probably, the ID bit (bit #21). The ID flag indicates whether we can or cannot use the CPUID instruction.</p>
<p>Bits 32 - 63 of the RFlags register in long mode would be all 0s.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we have briefly run through the basics of the internal structure of x86-based processors essential for the further understanding of topics covered in later chapters. Being a huge fan of Occam's Razor principle, yours truly had no intention to replicate Intel's programmer manual; however, certain topics covered in this chapter exceed the range of topics necessary for a successful start with Assembly language programming.</p>
<p>However, I believe that you would agree--we've had enough of dry information here and it is the right time to start doing something. Let's begin by setting up the development environment for Assembly language programming in <a href="cb7ac242-8ebb-4d6a-946a-220133f96674.xhtml">Chapter 2</a>, <em>Setting Up a Development Environment</em>.</p>


            

            
        
    </body></html>