<html><head></head><body><div><div><p>&#13;
			<h1 id="_idParaDest-106" class="chapter-number"><a id="_idTextAnchor213"/>6</h1>&#13;
			<h1 id="_idParaDest-107"><a id="_idTextAnchor214"/>Disk Encryption</h1>&#13;
			<p>The <strong class="bold">Linux Unified Key Setup</strong> (<strong class="bold">LUKS</strong>) standard<a id="_idIndexMarker267"/> for encrypting block devices within Linux was created way back in 2004. No wonder I feel like I’ve been using it forever! Twenty years is a long time for a tool to get stable and feature-rich. It’s also been around long enough to be universally loved and appreciated by engineers around the world. It’s virtually a mainstay of every Linux distribution’s installer<a id="_idTextAnchor215"/> options when configuring storage for your Linux systems. But each of those installers only lets you take LUKS so far. You will be forced to manually enter keys every time you boot or reboot. As this book is meant to be by no means introductory, let’s assume you have some great baseline Linux skills and continue our journey down the mineshaft of complexities and advanced skill sets.</p>&#13;
			<p>This chapter’s goal is to open your mind to more ways to secure the storage of your system. Here, I plan to expand your insights into how that can be configured alternatively.</p>&#13;
			<p>Grab some caffeinated beverages and a snack. This will be a deeper dive into the employment of LUKS for your future products.</p>&#13;
			<p>In this chapter, we will cover the following topics:</p>&#13;
			<ul>&#13;
				<li>Introduction to LUKS</li>&#13;
				<li>Implementing LUKS on an appliance with automated keys</li>&#13;
				<li>Is recovery possible?</li>&#13;
			</ul>&#13;
			<p>Let’s get started.</p>&#13;
			<h1 id="_idParaDest-108"><a id="_idTextAnchor216"/>Technical requirements</h1>&#13;
			<p>For the exercise in this chapter, you will need a physical or virtual machine that you can (re)install Linux onto to complete these tasks. Administrative (root) access is implied. You will be required to create some custom partitions/filesystems. You will need a fresh installation of a Linux system with the regular filesystems you may have regularly created. Also create a 500 MiB XFS LUKS encrypted partition, labeled <code>data3</code>, with the mount point set as <code>/data3</code>. Use <code>CreatePass</code> as the initial key passphrase. Root or sudo access is mandatory. I cannot highlight enough how important it is that this prerequisite is done as specified – not doing this will impact your ability to easily complete this chapter’s exercises.<a id="_idTextAnchor217"/></p>&#13;
			<h1 id="_idParaDest-109"><a id="_idTextAnchor218"/>Introduction to LUKS</h1>&#13;
			<p>With LUKS in play, any<a id="_idIndexMarker268"/> Linux filesystem can be encrypted. There are some caveats that you should be aware of ahead of time.</p>&#13;
			<p>Encrypting your data at rest (that is, everything stored on disk, SSD, or NVME) is not just a nice-to-have option, it’s almost assumed to be present depending on whom your target clientele may be. For discussion’s sake, let’s imply that the expected customer for your solution is a government entity. Most government customers (regardless of the country we are referring to) are mandated to have an exceptional level of security within whatever may be deployed within their walls. Their standards are significantly higher, as are their risks. It’s safe to say that disk encryption is assumed to be present. We shall cover how to implement some of these more stringent government security standards later in <a href="B22104_13.xhtml#_idTextAnchor400"><em class="italic">Chapter 13</em></a>.</p>&#13;
			<p>Crucial to the encryption process is a<a id="_idTextAnchor219"/>n open source utility called <code>cryptsetup</code>. This relies on functionality provided by the <code>dm-crypt</code> Linux kernel module. These tools, along with your own distribution-specific tooling for managing storage, are installed generally by default in every Linux distribution. Once a volume is encrypted with LUKS, the encryption can only be fully removed when the volume is offline and not mounted.</p>&#13;
			<p>LUKS, most simply stated, leverages <code>dm-crypt</code> module to cipher/decipher data on disks. LUKS requires a passphrase to be entered each time a volume is mounted and accessed. Its inner workings, which are thankfully obscured from us end-users, are rather complex. Automating this process is even more complex.</p>&#13;
			<p>For systems <a id="_idIndexMarker270"/>using the <code>/boot</code> partition. GRUB and GRUB2 both support such encryption. There are other bootloaders that may not do this, so check before considering this option.</p>&#13;
			<p>Most commonly, the root partition along with any application partitions should be encrypted to protect the system from tampering. Swap and user home directory partitions should also be considered.</p>&#13;
			<p>The current version of <a id="_idIndexMarker271"/>LUKS (LUKS2) supports up to 32 encryption keys per encrypted volume, whereas LUKS1 only supports up to 8 keys. This will be a crucial golden nugget to remember when we discuss recovery later on in this chap<a id="_idTextAnchor220"/>ter.</p>&#13;
			<h2 id="_idParaDest-110"><a id="_idTextAnchor221"/>Basic implementation review</h2>&#13;
			<p>With the excellent<a id="_idIndexMarker272"/> graphical installers available in today’s Linux distributions, you have probably seen exactly how they try to assist you with the configuration of LUKS encryption as part of the build process. We won’t be covering LUKS basics in any depth, but if you need a reference, please check the project’s repository at <a href="https://gitlab.com/cryptsetup/cryptsetup/blobmC5#WdW07?dhVJ4aster/README.md">https://gitlab.com/cryptsetup/cryptsetup/blobmC5#WdW07?dhVJ4aster/README.md</a>. However, I do want to highlight specifically that configuring LUKS via the base installer will force the manual entry of the key passphrase every time the system is booted or rebooted.</p>&#13;
			<p>As this is not a beginner’s guide to installing Linux, I’d like to make an important point. The installer can only minimally configure LUKS encryption. This configuration may be suitable for people building things in their lab, but it is not acceptable when one takes on the customers’ perspective in the situation where they’re paying prime money for a well-crafted secure solution.</p>&#13;
			<p>Here’s an example of configuring LUKS via the Linux distribution’s installer:</p>&#13;
			<div>&#13;
				<div>&#13;
					<img src="img/B22104_06_01.jpg" alt="Figure 6.1 – Configuring encryption via the installer" width="1072" height="1013"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.1 – Configuring encryption via the installer</p>&#13;
			<p>Creating encrypted<a id="_idIndexMarker273"/> filesystems through the installer is definitely a positive jumpstart to securing your appliance build, but if you stop there, it’s only a matter of time before the customer complaints over usability and security (as they’ll have to give out the passphrase to all the admins at minimum) will force you to make changes.</p>&#13;
			<p>As we continue to build upon each piece of security and usability criteria in this book, let’s move on to the next section, which will definitely improve the customers’ end-user experience and, without a shadow of a doubt, will improve the security posture of the appliance itself. Automating the encryption/decryption process and securing this information from the end-user becomes a key initiative. The fewer people with access to the ability to decrypt the data, the better the solution will be perceived. Let’s now explore exactly how <a id="_idIndexMarker274"/>such automation looks and let’s get our hands <a id="_idTextAnchor222"/>dirty.</p>&#13;
			<h1 id="_idParaDest-111"><a id="_idTextAnchor223"/>Implementing LUKS on an appliance with automated keys</h1>&#13;
			<p>A key point to keep <a id="_idIndexMarker275"/>at the <a id="_idIndexMarker276"/>forefront of your thought process in the implementation of any security factor in an appliance solution is your end-user experience. This book was created to help you and your team create a secure but usable embedded Linux system.</p>&#13;
			<p>Depending on what your solution is and how it is utilized by the end-users, it is paramount to prevent the need for those end-users to have to enter keys every time a system is turned on. Firstly, that appliance may not even have a console or a keyboard attached. Secondly, forcing the end-user to manually enter such a key will ultimately result in them writing the key down on a note somewhere taped to the machine or elsewhere in clear view in the workplace. Making the end-user enter the key passphrases should be avoided if at all feasible.</p>&#13;
			<p>Here’s an example screenshot of how you may be prompted for a passphrase before the boot sequence can continue:</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B22104_06_02.jpg" alt="Figure 6.2 – Manual encryption key passphrase entry at boot" width="300" height="103"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.2 – Manual encryption key passphrase entry at boot</p>&#13;
			<p>Now that you can see how having your end-user be forced to enter a passphrase is not a great idea, we’ll<a id="_idIndexMarker277"/> take a <a id="_idIndexMarker278"/>journey in the next section to see how this process can be securely automated. Let’s<a id="_idTextAnchor224"/> move on.</p>&#13;
			<h2 id="_idParaDest-112"><a id="_idTextAnchor225"/>Exercise – implementing LUKS with stored keys and leveraging the crypttab file</h2>&#13;
			<p>Before we start <a id="_idIndexMarker279"/>pounding the<a id="_idIndexMarker280"/> keyboard, please allow<a id="_idIndexMarker281"/> me to introduce an ally that you may have known that you have in this battle. The <code>/etc/crypttab</code> file is used by all distributions of Linux to store information about encrypted block devices for them to be automatically unlocked at boot time. In my opinion, this is one of the true hidden gems in Linux.</p>&#13;
			<p>For this exercise, we’ll be using the machine mentioned in this chapter’s <em class="italic">Technical requirements</em> section and we will be automating the unlocking of that <code>/data3 </code>filesystem. Let’s begin with the following steps:</p>&#13;
			<ol>&#13;
				<li>Log in as root.</li>&#13;
				<li>Check device availability. Identify the UUID and the device name of the partition you have created for this exercise. Your output will most likely have differences:<pre class="source-code">&#13;
<strong class="bold">$ sudo lsblk</strong>&#13;
<strong class="bold">NAME           MAJ:MIN RM   SIZE RO TYPE  MOUNTPOINTS</strong>&#13;
<strong class="bold">sda            8:0    0 476.9G  0 disk</strong>&#13;
<strong class="bold">├─sda1         8:1    0     2M  0 part</strong>&#13;
<strong class="bold">├─sda2         8:2    0     3G  0 part  /boot</strong>&#13;
<strong class="bold">├─sda3         8:3    0    55G  0 part  /</strong>&#13;
<strong class="bold">├─sda4         8:4    0    64G  0 part  [SWAP]</strong>&#13;
<strong class="bold">├─sda5         8:5    0    40G  0 part  /var</strong>&#13;
<strong class="bold">├─sda6         8:6    0    40G  0 part  /home</strong>&#13;
<strong class="bold">└─sda78:7    0   500M  0 part</strong>&#13;
<strong class="bold">  └─luks-8e1fb810-b471-491a-adcf-32048a0eb534 253:0    0   484M  0 crypt /data3</strong>&#13;
<strong class="bold">zram0          252:0    0     8G  0 disk  [SWAP]</strong></pre></li>				<li>Now, let’s<a id="_idIndexMarker282"/> determine <a id="_idIndexMarker283"/>the UUID for our<a id="_idIndexMarker284"/> specific volume. Yours may be a different device so please pay attention:<pre class="source-code">&#13;
<strong class="bold">$ sudo blkid /dev/sda7</strong>&#13;
<strong class="bold">/dev/sda7: UUID="8e1fb810-b471-491a-adcf-32048a0eb534" TYPE="crypto_LUKS" PARTUUID="b5906739-06d2-44d2-8770-17f2ffd75212"</strong></pre></li>			</ol>&#13;
			<p class="callout-heading">Important note</p>&#13;
			<p class="callout">For me, my device name was <code>/dev/sda7</code> – yours will be different for a variety of reasons (disk type, the partitioning scheme of your system, etc.) Wherever I have typed <code>/dev/sda7</code> or my unique UUID for the volume, <em class="italic">you must replace it with your </em><em class="italic">own information</em>.</p>&#13;
			<ol>&#13;
				<li value="4">Generate a random passkey as root and save it under <code>/etc</code> as <code>luks-keyfile</code>:<pre class="source-code">&#13;
<strong class="bold"># dd if=/dev/random of=/etc/luks-keyfile \</strong>&#13;
<strong class="bold">bs=1024 count=4</strong>&#13;
<strong class="bold">4+0 records in</strong>&#13;
<strong class="bold">4+0 records out</strong>&#13;
<code>luks-keyfile</code> file as root:<pre class="source-code">&#13;
<code>luks-keyfile</code> file:<pre class="source-code">&#13;
<strong class="bold"># restorecon -vvRF /etc/luks-keyfile</strong>&#13;
<code>luks-keyfile</code> file as<a id="_idIndexMarker287"/> another way of decrypting the drive we just created. You will be prompted for the original passphrase that you used in the prep for this exercise – <code>CreatePass</code>:<pre class="source-code">&#13;
<strong class="bold"># cryptsetup luksAddKey /dev/sda7 /etc/luks-keyfile</strong>&#13;
<code>/etc/crypttab</code> file created by the Linux installer. We’ll need to see whether the installer created a definition for the manual decryption of our volume (in my case, it did):<pre class="source-code">&#13;
<strong class="bold"># cat /etc/crypttab</strong>&#13;
<code>/data3</code> volume and then run the command to ensure the LUKS has also closed the volume:<pre class="source-code">&#13;
<strong class="bold"># umount /data3</strong>&#13;
<strong class="bold"># cryptsetup -v luksClose luks-8e1fb810-b471-491a-adcf-32048a0eb534</strong>&#13;
<strong class="bold">Command successful.</strong></pre></li>			</ol>&#13;
			<p class="callout-heading">Important note</p>&#13;
			<p class="callout">For this exercise, we will also name the volume <code>data3</code>. As my <code>/data3</code> partition was created during the installation (for speed purposes), there was already an entry with the same UUID as my <code>/data3</code> volume so I created a new entry with the label of <code>data3</code> as the new first entry and commented out the original entry. This is a very important step. You may later choose to delete the older entry, but in testing, I recommend simply commenting it out. Additionally, I must remind you that your own UUIDs will be different than mine.</p>&#13;
			<ol>&#13;
				<li value="10">Edit the <code>/etc/crypttab</code> file<a id="_idIndexMarker288"/> using <a id="_idIndexMarker289"/>your <a id="_idIndexMarker290"/>favorite editor:<pre class="source-code">&#13;
<strong class="bold">$ sudo vi /etc/crypttab</strong></pre></li>			</ol>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">/etc/crypttab</p>&#13;
			<pre class="source-code">&#13;
data3   UUID=8e1fb810-b471-491a-adcf-32048a0eb534 /etc/luks-keyfile luks&#13;
###luks-8e1fb810-b471-491a-adcf-32048a0eb534 UUID=8e1fb810-b471-491a-adcf-32048a0eb534 none discard</pre>			<ol>&#13;
				<li value="11">Let’s manually force LUKS to use our new keyfile and test open the encryption and then mount the volume:<pre class="source-code">&#13;
<strong class="bold"># cryptsetup -v luksOpen /dev/sda7 data3 \</strong>&#13;
<strong class="bold">--key-file=/etc/luks-keyfile</strong>&#13;
<strong class="bold">No usable token is available.</strong>&#13;
<strong class="bold">Key slot 2 unlocked.</strong>&#13;
<strong class="bold">Command successful.</strong></pre></li>				<li>Let’s now mount the device:<pre class="source-code">&#13;
<code>/data3</code> is mounted. Depending on how you built your test machine, your output<a id="_idIndexMarker291"/> may vary. Please<a id="_idIndexMarker292"/> pay <a id="_idIndexMarker293"/>attention:<pre class="source-code">&#13;
<strong class="bold">$ df –h</strong>&#13;
<strong class="bold">Filesystem      Size  Used Avail Use% Mounted on</strong>&#13;
<strong class="bold">/dev/sda3        55G  7.2G   48G  13% /</strong>&#13;
<strong class="bold">devtmpfs        4.0M     0  4.0M   0% /dev</strong>&#13;
<strong class="bold">tmpfs            16G     0   16G   0% /dev/shm</strong>&#13;
<strong class="bold">tmpfs           6.3G  1.9M  6.3G   1% /run</strong>&#13;
<strong class="bold">tmpfs            16G   76K   16G   1% /tmp</strong>&#13;
<strong class="bold">/dev/sda2       3.0G  406M  2.6G  14% /boot</strong>&#13;
<strong class="bold">/dev/sda5        40G  2.6G   38G   7% /var</strong>&#13;
<strong class="bold">/dev/sda6        40G  875M   40G   3% /home</strong>&#13;
<strong class="bold">tmpfs           3.2G  224K  3.2G   1% /run/user/1000</strong>&#13;
<strong class="bold">/dev/dm-0       444M  135K  415M   1% /data3</strong></pre></li>				<li>Finally, we need to do a reboot of the system and re-verify all filesystems mounted automatically.</li>&#13;
			</ol>&#13;
			<p>We’ve come a long way with LUKS thus far through some serious advanced automation. Your customers will truly appreciate your attention to detail and the ease of use your solution<a id="_idIndexMarker294"/> provides (along <a id="_idIndexMarker295"/>with the encryption). We are <a id="_idIndexMarker296"/>not done yet. Let’s dive into the million-dollar qu<a id="_idTextAnchor226"/>estion in our next section.</p>&#13;
			<h1 id="_idParaDest-113"><a id="_idTextAnchor227"/>Is recovery possible?</h1>&#13;
			<p>Wow. Is recovery<a id="_idIndexMarker297"/> possible? That’s the million-dollar support question. Please allow me to paint a picture and offer you what may just be the only solution. The truest answer is both <em class="italic">yes</em> and <em class="italic">no</em>. It’s mostly <em class="italic">No!</em> So, let’s explore what I mean and why I call it the million-dollar support question.</p>&#13;
			<p>Please humor me for just a moment. Let’s envision that the worst possible situation has arrived – due to a perfect storm of either a broken TPM module or filesystem corruption or, even worse, a malicious act by a rogue employee or hacker, the keystore for your automated encryption passkeys is lost on one of your customers’ appliances.</p>&#13;
			<p>Your support team is flustered. Not only is that customer offline but there will probably be some significant data loss involved. “<em class="italic">Oh man</em>,” you think to yourself, “<em class="italic">Why didn’t I call in </em><em class="italic">sick today?</em>”</p>&#13;
			<p>How can your support team help this customer? Will your company lose credibility or the end-customers' trust? How could you have prevented this?</p>&#13;
			<p>Okay, here’s the bad news. Brace for impact. If you only have one passkey and it’s lost or compromised or whatever, you and that customer are definitely going to have a very, very bad day. There is no recovery from the loss of the sole key/passphrase store. Period. This type of encryption has ramifications. It’s built into the design. No key or passphrase means zero access, and that is the point!</p>&#13;
			<p>The implications of not being able to help your customer recover can be costly, but it may not be as easy to predict just how costly it could be. If you are unable to assist a customer recover from a passkey/encryption issue, they’ve lost data, and they’ve lost time. We don’t know and can’t possibly calculate whether this impacts their customers too. You’re probably going to lose them as a customer. You will lose credibility in the market. Hopefully, they don’t sue your company for losses. As I said, it’s costly.</p>&#13;
			<p>Now this is where I say, “<em class="italic">Where there’s a will there’s a way!</em>” In the fullest disclosure, nothing can prevent unforeseen failures entirely, but some additional engineering and planning will give your support staff the virtual lifeboat to survive the shipwreck if it ever happens. Please indulge me for a little more time.</p>&#13;
			<p>We have already covered that the current version of LUKS (i.e., LUKS2) supports up to 32 slots for keys or passphrases. There’s a good reason for this. You need more than one. In my jaded opinion, you truly need several. Don’t be lazy. Set multiple. Document them for your product <a id="_idIndexMarker298"/>and support staff. They can be a lifeboat for your customer in the event of a catastrophe.</p>&#13;
			<p>How you apply that knowledge is up to you. What I recommend is at minimum having three options, and I repeat, this is the bare minimum. They are as follows:</p>&#13;
			<ul>&#13;
				<li>The passphrase for LUKS used in the installer</li>&#13;
				<li>The key you create for the automated decryption of filesystems</li>&#13;
				<li>An emergency passphrase for all encrypted filesystems that is known only to your support team</li>&#13;
			</ul>&#13;
			<p>That said, depending on the scale of some of your customers’ implementations of your solution, you might consider adding a standard recovery passphrase as the fourth option. This would empower your support team to work more closely and freely with the customer to deal with any encryption issues.</p>&#13;
			<p>At this point, your own internal documentation and processes for building and support must be spo<a id="_idTextAnchor228"/>t on. Yet in all of this, who actually has access to those specific keys/passphrases must be controlled and regulated. “<em class="italic">Why?</em>” one may ask. Let me be blunt. The worst-case scenario would be a disgruntled employee with access to this critical information and sharing it – <em class="italic">anywhere</em> – such as on the Internet. The level of compromise for all your customers would be devastating.</p>&#13;
			<p>You might be thinking to yourself, “<em class="italic">Geez, this whole book is chock full of doom and gloom!</em>” Well, yeah – it’s <a id="_idIndexMarker299"/>a security book. Fear is a motivator. Move on. But all kidding aside, this is a very serious subject and a design decision you and your team must make.</p>&#13;
			<h1 id="_idParaDest-114"><a id="_idTextAnchor229"/>Summary</h1>&#13;
			<p>Now, let’s review what we’ve covered in this chapter. We have gone way beyond the base configuration of LUKS from common Linux installers. We have reviewed advanced ways of automating LUKS to improve security and the end-user experience; we have also covered more advanced ways of configuring the encryption keys and passphrases; and finally, and just as importantly, we have covered preventative measures with multiple keys and passphrases to virtually eliminate the probability of data loss during a critical support issue. I hope you have enjoyed this deep dive into LUKS as much as I have.</p>&#13;
			<p>The benefits of leveraging this kind of encryption automation are extensive. In doing this, you will immediately create a better end-user experience as they will not be forced to memorize or type the passphrase every boot cycle. This implemented encryption protects your appliance and your end-customers' data or intellectual properties. Having this strong encryption gives the end-customer greater <em class="italic">peace of mind</em> in acquiring and using your solution. At the end of the day, it truly is all about solving your customers’ problems and creating repeat customers who, in turn, tout your solution to their friends and colleagues.</p>&#13;
			<p>Using LUKS should not add complexity for your customers and end-users. This is where implementing the automation of the passkeys is crucial. Ultimately, positive user experience and security can both be achieved in this instance. I hope that this deep dive into LUKS has been inspirational for you and given you new ideas on securing your filesystems.</p>&#13;
			<p>Let’s now move on to our next chapter where we’ll drill deep into BIOS and boot security.</p>&#13;
		</div>&#13;
	</div></div></body></html>