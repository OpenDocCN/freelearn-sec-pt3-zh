<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Windows Memory Acquisition and Analysis</h1>
                </header>
            
            <article>
                
<p class="CDPAlignLeft CDPAlign">In this chapter, we will cover the following recipes:</p>
<ul>
<li>Windows memory acquisition with Belkasoft RAM Capturer</li>
<li>Windows memory acquisition with DumpIt</li>
<li>Windows memory image analysis with <span>Belkasoft Evidence Center</span></li>
<li>Windows memory image analysis with Volatility</li>
<li>Variations in Windows versions</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction</h1>
                </header>
            
            <article>
                
<p>Memory analysis is a relatively new, but increasingly relevant field. A memory image can be acquired in the same way as a physical image, but by using different tools, some of which will be discussed in this section.</p>
<p>The image can be stored as one of the many formats, depending on the tool used to acquire the image. Once an investigator has the image, they can then analyse the data within it.</p>
<p>One of the main challenges associated with memory forensics is data preservation. Although your only option in a given investigation may be to power down a system and then image the data therein, in reality this ends up having an impact on other potential data sources that might be important later on. It is vital, therefore, to have a thorough understanding of the scene you are investigating and the specific needs of the case before you decide which method to choose. Any time you interact with a system, you will alter something simply by virtue of having been there. However, memory acquisition can help to minimize the effects of the investigator on the data collected, since a memory image will sample the volatile memory at a specific time, thus creating a sort of snapshot that can then be analysed later.</p>
<p>In cases where an investigator arrives at a scene to find a machine powered on, the memory on the system will be volatile at that time. This means that, if you manage to acquire a memory image then and there, you will be able to see a snapshot of the computer's memory at the moment at which you acquired it. This can be very useful, especially if a suspect has recently fled a scene or has been arrested at the scene.</p>
<p>You will generally need administrative permissions on the computer if you want to acquire volatile memory unless you are using hardware. One such solution is <strong>CaptureGUARD Physical Memory Acquisition Hardware.</strong> It requires <span>a small CaptureGUARD driver to be installed on the system and creates a memory dump in the standard WinDD format. You can see one of these devices in figure 2.1.</span></p>
<div class="CDPAlignCenter CDPAlign"><img height="266" width="437" class="image-border" src="assets/5f0ccac5-1d5d-412e-a0e7-f1a8a16142e9.jpg"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 2.1. ExpressCard</div>
<p>In other words, memory forensics is a complex and temperamental field. You will need to have a thorough understanding of the tool sets you are using, and any potential impacts they could have on volatile memory before you decide which to use it at a scene. However, if you do manage to acquire a memory image, it can provide a wealth of useful information for your case.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Windows memory acquisition with Belkasoft RAM Capturer</h1>
                </header>
            
            <article>
                
<p class="NormalPACKT"><span>Belkasoft RAM Capturer is a free tool any digital forensic examiner should have in their kit. It's tiny, easy to use, and has the ability to acquire memory from Windows systems, including Windows 10, even if they are protected by an active anti-debugging or anti-dumping system.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>You have two options for downloading the tool. If you are a Belkasoft customer and have a Belkasoft Evidence Center license, go to your customer portal, where you can find a Belkasoft RAM Capturer download link in the <span class="packt_screen">FREE PRODUCTS</span> section. If you are not a customer, just go to the <span class="packt_screen">DOWNLOAD</span> section on the Belkasoft website, choose the product you want to download - in our case, Belkasoft Live RAM Capturer - and fill in a short form with your contact information. After the download, a link will be sent to the email provided.</p>
<p>The steps to prepare a flash drive for acquisition are as follows:</p>
<ol>
<li>It must have enough space to store the memory image.</li>
<li>It must be sterilized via wiping.</li>
<li>Put both folders extracted from the archive you downloaded onto the flash drive.</li>
</ol>
<p>Don't forget to prepare a flash drive for acquisition. Firstly, it must have enough space to store the memory image. Secondly, it must be sterilized by wiping. Finally, put both folders extracted from the archive you downloaded onto the flash drive.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it…</h1>
                </header>
            
            <article>
                
<p>The steps for Windows memory acquisition using Belkasoft Ram Capturer are as follows:</p>
<ol>
<li>The first thing you must do is learn what kind of system you are dealing with x32 or x64. It's really easy to do right-click <span class="packt_screen">Computer</span> and choose <span class="packt_screen">Properties</span>. In our case, it's x64. So our choice is <kbd>RamCapture64.exe</kbd>.</li>
<li>After starting, we will get information about the physical memory page size and its total size.</li>
<li>Now select the output folder path make sure it's your flash drive and not the local system drive.</li>
<li>After that just click <span class="packt_screen">Capture</span>!</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="241" width="465" class="image-border" src="assets/25a3d19b-4153-468d-a77f-f264870ed12e.png"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 2.2. Memory acquisition with Belkasoft RAM Capturer</div>
<p>As a result, we get a file with <kbd>.mem</kbd> extension of the same size as the total physical memory. By default, you have the date of acquisition as the filename, but we highly recommend renaming it, and adding more information for identification purposes: operating system version, edition, computer name, and other information.</p>
<p>That's it! The image is ready for further analysis with memory forensics tools.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works…</h1>
                </header>
            
            <article>
                
<p>Belkasoft RAM Capturer operates in kernel mode (not in user mode like some other acquisition tools) with the help of 32-bit and 64-bit kernel drivers. It extracts the whole physical memory, even if it's protected, in a forensically sound manner, and saves it into a file with the <kbd>.<span><span>mem</span></span></kbd> extension.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<p class="NormalPACKT">The Belkasoft RAM Capturer page on Belkasoft's website: <a href="http://belkasoft.com/ram-capturer">http://belkasoft.com/ram-capturer</a></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Windows memory acquisition with DumpIt</h1>
                </header>
            
            <article>
                
<p>DumpIt is a free memory imaging tool from <span>Comae Memory Toolkit. It's a fusion of Win32dd and Win64dd in one executable. It's extremely easy to use: even a non-technical person can use it in emergency situations. DumpIt supports all modern Windows versions, from XP to 10, both 32 and 64-bit. Also, the tool has a very important feature: it displays the Directory Table Base and the address of the debugging data structures during the acquisition process.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>To get your free copy of DumpIt, go to Comae Technologies' website and click on <span class="packt_screen">GET TOOLS</span>. After you provide some information, including your first name, last name, company name, email address, phone number and website, you'll get your download link via email. Don't forget to put the tool onto a wiped external drive later.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it…</h1>
                </header>
            
            <article>
                
<p>This time, we don't need to know what kind of operating system we are dealing with - 32 or 64-bit. As we have already been said, DumpIt is <span>a fusion of W</span><span>in32dd and Win64dd in one executable. So, there are just two steps:</span></p>
<ol>
<li><span>Plug in the external drive in the target system</span></li>
<li><span>Start <kbd>DumpIt.exe</kbd> and type <kbd>y</kbd> to start the acquisition process</span></li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="331" width="440" class="image-border" src="assets/4f02fca9-c518-4840-9f63-18a908b5debc.png"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 2.3. Memory acquisition with DumpIt</div>
<p style="padding-left: 60px" class="CDPAlignLeft CDPAlign">As a result of the acquisition, you'll get two files: a file with the DMP extension and a file with the JSON extension. The first is the target system's memory dump with the computer name, date and time (UTC) in the file name, the second - the dump information, includes important information from a forensic point of view. It includes file size, system architecture type (32/64), KdCopyDataBlock KdDebuggerData, kdpDataBlockEncoded, sha256 hash, and so on. So that's it, the DMP file is ready to be analysed with the memory forensics software of your choice.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works…</h1>
                </header>
            
            <article>
                
<p>As DumpIt is a fusion of W<span>in32dd and Win64dd, it automatically detects the system architecture type and creates a memory snapshot and a file in JSON format with all the information you will need for further analysis with memory forensics tools, such as Volatility, Rekall, Belkasoft Evidence Center, and others.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<p>The Comae Memory Toolkit (which DumpIt, along with Hibr2Bin, is a part of) webpage:</p>
<p><a href="https://comae.typeform.com/to/XIvMa7">https://comae.typeform.com/to/XIvMa7</a></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Windows memory image analysis with Belkasoft Evidence Center</h1>
                </header>
            
            <article>
                
<p>In the previous recipes, we successfully created two memory forensic images, one with Belkasoft Live RAM Capturer, and the other with DumpIt. Now it's time to perform analysis. Let's start from the first image and use Belkasoft Evidence Center for analysis.</p>
<p><span>Belkasoft Evidence Center is a powerful digital forensics tool, capable of parsing data not only from memory images, but also from images of computer drives and mobile devices. From a memory dump, it can extract valuable artifacts such as remnants of communications via social networks, messengers, chat rooms, webmail systems, data from cloud services, web-browsing artifacts, and so on.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>If you don't have a valid license for Belkasoft Evidence Center, you can download a fully functional trial version of the product from the official website. To do this, go <span>to</span> the <span class="packt_screen">DOWNLOAD</span> <span>section on Belkasoft's website, choose the product you want to download, in our case, Belkasoft Evidence Center (trial version) - and provide your <span class="packt_screen">contact information</span>, including your F<span class="packt_screen">irst Name</span>, L<span class="packt_screen">ast Name</span>, <span class="packt_screen">Your e<span class="packt_screen">mail</span></span> and <span class="packt_screen">Company, Country</span>. After the download, the link will be sent to your email. If you are a licensed user, just go to your customer portal and download the latest version of the product.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>The steps for Windows memory image analysis using Belkasoft Evidence Center:</p>
<ol>
<li>To do that, click on <span class="packt_screen">New</span> in the <span class="packt_screen">Open Case</span> window. Now you need to fill in a few fields:
<ul>
<li><span class="packt_screen">Case name</span> <span>- Usually, we use the case number and year for case names, but this time, as it's being created for testing purposes, we will name it</span> <kbd>Belkasoft Memory Forensics Test</kbd><span>.</span></li>
<li><strong><span class="packt_screen">Root folder</span></strong> <span>- Here, you should choose the folder where the case data will reside. In our case it's D: drive.</span></li>
<li><strong><span class="packt_screen">Case folder</span></strong> <span>- This field will be filled in automatically based on the two previous fields, so in our case, it's</span> <kbd>D:\Belkasoft Memory Forensics Test</kbd><span>.</span></li>
<li><strong><span class="packt_screen">Investigator</span></strong> <span>- Type your name in this field.</span></li>
<li><strong><span class="packt_screen">Time zone</span></strong> <span>- Choosing the right time zone is very important. If you already know the right one, choose it. If not, we suggest choosing UTC +00:00. In our case, we know the time zone, so we can use the correct one (UTC + 03:00).</span></li>
<li><strong><span class="packt_screen">Description</span></strong> <span>- If you want to add a description to your digital evidence item, here is the field to do it. We used the following description:</span> <kbd>Parsing a memory image created with Belkasoft Live RAM Capturer for testing purposes.</kbd></li>
</ul>
</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="388" width="480" class="image-border" src="assets/351b7316-1287-42ac-aedd-c8f29b55ae05.png"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 2.4. Creating a new case in Belkasoft Evidence Center</div>
<ol start="2">
<li>Click <span class="packt_screen">OK</span> and you will see the next window - <span class="packt_screen">Add data source</span>.</li>
</ol>
<p style="padding-left: 60px">Belkasoft Evidence Center supports different kinds of evidence sources, from physical drives and drive images, to mobile backups and, of course, memory images, including <kbd>pagefile.sys</kbd> <span>and</span> <kbd>hiberfil.sys</kbd><span>.</span></p>
<p style="padding-left: 60px" class="CDPAlignLeft CDPAlign">As we are talking about memory forensics now, let's choose the image we previously acquired with <span>Belkasoft RAM Capturer</span> as the data source.</p>
<div class="CDPAlignCenter CDPAlign"><img height="419" width="444" class="image-border" src="assets/2563ec39-55a6-404b-a26b-3073a9b14a86.png"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 2.5. Adding previously acquired memory image as data source in Belkasoft Evidence Center</div>
<ol start="3">
<li>Click <span class="packt_screen">Next</span> to choose the data types you want to search for. For testing purposes, we chose all available data types, but you can choose those you really need, to reduce processing time.</li>
</ol>
<div class="mce-root packt_tip">Don't forget to go to Advanced options and enable BelkaCarving - it will help you to recover fragmented data, for example, pictures.</div>
<div class="CDPAlignCenter CDPAlign"><img height="381" width="403" class="image-border" src="assets/61eb7a10-9b56-421a-ae76-73daad6bedd4.png"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 2.6. Choosing data types in Belkasoft Evidence Center</div>
<ol start="4">
<li>OK, we are ready to start parsing the memory image - just click <span class="packt_screen">Finish</span>.</li>
</ol>
<p style="padding-left: 60px">It took BEC about an hour to parse and carve the image, and we got impressive results: 9728 web browser artifacts, 2848 pictures, <span>74 chat artifacts, and so on.</span></p>
<div class="CDPAlignCenter CDPAlign"><img height="124" width="333" class="image-border" src="assets/fd4c4193-394e-417f-bcb2-e4689bbb53ec.png"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 2.7. Results of memory image processing with Belkasoft Evidence Center</div>
<p class="CDPAlignLeft CDPAlign">As you can see, you can extract quite a lot of valuable digital artifacts from a memory image with just a few clicks - so, if you have access to a running system, make it a rule to capture the memory image. This may help you, for example, to recover browsing history from anonymous tools such as Tor Browser, which are widely used among criminals, as well as other important digital artifacts which may reside only in volatile memory.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p class="CDPAlignLeft CDPAlign">Belkasoft Evidence Center parses memory image structure and extracts available data, putting it into corresponding categories. The BelkaCarving options allow the tool to reconstruct fragmented data, for example, images.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<p>The Belkasoft Evidence Center page on the Belkasoft website: <a href="http://belkasoft.com/ec">http://belkasoft.com/ec</a></p>
<p>BelkaCarving: <a href="http://ru.belkasoft.com/en/bec/en/BelkaCarving.asp">http://ru.belkasoft.com/en/bec/en/BelkaCarving.asp</a></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Windows memory image analysis with Volatility</h1>
                </header>
            
            <article>
                
<p>The Volatility Framework is an open source collection of tools written in Python for the extraction of digital artifacts from memory images. This time, we will use the second memory image, obtained earlier with DumpIt, as a data source to show you how to use this tool set for memory forensics.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p><span>The Volatility Framework is an open source toolkit, so it's cross-platform, which means that you can use any operating system family you want - Windows, Linux, or mac OS. Of course, you can build these tools from source, but there are also so-called standalone executables for all the operating systems mentioned. As this cookbook is about forensic examination of Windows OS and the memory dump, what we are going to analyze is collected from Windows 10, and we are going to use the Windows Standalone Executable.</span></p>
<p>At the time of writing, the most recent version of Volatility is 2.6. With this version, <span>support for Windows 10 (including 14393.447) improved, also support for Windows Server 2016, mac OS Sierra 10.12, and Linux with KASLR kernels was added.</span></p>
<p>To download the collection of tools, go to t<span>he Volatility Framework website and use the Releases tab to choose the most recent version, in our case 2.6. Now, all you need is to unzip <span class="packt_screen">volatility_2.6_win64_standalone.zip</span> which you've just downloaded, and you are ready to go.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>To show you the power of Volatility, we decided to use a memory image from a system infected with known malware - <strong>Stuxnet</strong>. Why? Because this memory image is freely available, so you can download it and use it for training.</p>
<p>Let's start by collecting information about our image.</p>
<ol>
<li>To do this, start <kbd>cmd.exe</kbd>.</li>
<li>Change the directory to the one with the Volatility Standalone Executable, and use the <kbd>imageinfo</kbd> plugin:</li>
</ol>
<pre style="padding-left: 60px">
<strong>volatility_2.6_win64_standalone.exe -f              </strong><br/><strong>X:stuxnet.vmem imageinfo</strong><br/><strong>Volatility Foundation Volatility Framework 2.6</strong><br/><strong>INFO : volatility.debug : Determining profile based    </strong><br/><strong>on KDBG          </strong><br/><strong>search...</strong><br/><strong>Suggested Profile(s) : WinXPSP2x86, </strong><br/><strong>WinXPSP3x86 (Instantiated    with WinXPSP2x86)</strong><br/><strong>AS Layer1 : IA32PagedMemoryPae (Kernel AS)</strong><br/><strong>AS Layer2 : FileAddressSpace (X:stuxnet.vmem)</strong><br/><strong>PAE type : PAE</strong><br/><strong>DTB : 0x319000L</strong><br/><strong>KDBG : 0x80545ae0L</strong><br/><strong>Number of Processors : 1</strong><br/><strong>Image Type (Service Pack) : 3</strong><br/><strong>KPCR for CPU 0 : 0xffdff000L</strong><br/><strong>KUSER_SHARED_DATA : 0xffdf0000L</strong><br/><strong>Image date and time : 2011-06-03 04:31:36 UTC+0000</strong><br/><strong>Image local date and time : 2011-06-03 00:31:36      </strong><br/><strong>-0400</strong>
</pre>
<p style="padding-left: 60px">The <kbd>imageinfo</kbd> plugin returned two suggested profiles. We know that this image was taken from a system running <span>Windows XP with Service Pack 3, so the correct profile is</span> WinXPSP3x86<span>.</span></p>
<p style="padding-left: 60px">Now we know the correct profile, we can use it as a switch to collect information about the processes running on the infected machine.</p>
<ol start="3">
<li>To do this, we can use the <kbd>pslist</kbd> plugin:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root">
<strong>volatility_2.6_win64_standalone.exe -f X:stuxnet.vmem    </strong><br/><strong>--    </strong><br/><strong>profile=WinXPSP3x86 pslist</strong>
</pre>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="assets/ae4fdc23-5c7e-4b56-b86d-064c1795bb63.png"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 2.8. Volatility pslist plugin output</div>
<p style="padding-left: 60px" class="CDPAlignLeft CDPAlign">Do you see anything suspicious? Yes, there are three copies of <kbd>lsass.exe</kbd>, and this is one of the <span>signs of a Stuxnet infection.</span></p>
<p style="padding-left: 60px" class="CDPAlignLeft CDPAlign"><span>Normally, only one</span> <kbd>lsass.exe</kbd> <span>process should be running, so we need</span> <span>to determine which two are malicious.</span></p>
<ol start="4">
<li><span>Look at the timestamps on figure 2.8. Two out of three processes started in 2011. Strange, isn't it?</span> <span>Now let's use the</span> <kbd>pstree</kbd> <span>plugin:</span></li>
</ol>
<pre style="padding-left: 60px">
<strong>volatility_2.6_win64_standalone.exe -f<br/></strong><strong>X:stuxnet.vmem --<br/></strong><strong>profile=WinXPSP3x86 pstree</strong>
</pre>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="assets/14f1f5a8-e11e-402a-adb3-7c490f403272.png"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 2.9. Volatility pstree plugin output</div>
<p style="padding-left: 60px" class="CDPAlignLeft CDPAlign">Our suspicious process, <kbd>lsass.exe</kbd>, is normally started by <kbd>winlogon.exe</kbd>.</p>
<ol start="5">
<li>Let's look at the figure: only one <kbd>lsass.exe</kbd> is started by <kbd>winlogon.exe</kbd> - the one with PID 680; the two others are started by <kbd>services.exe</kbd>! So, the <kbd>lsass.exe</kbd> processes with PIDs <span><kbd>868</kbd> and <kbd>1928</kbd> could be malicious.</span></li>
<li>We have two potentially malicious processes. Let's check the DLLs loaded by these processes using the <kbd>dlllist</kbd> plugin:</li>
</ol>
<pre style="padding-left: 60px">
<strong>volatility_2.6_win64_standalone.exe -f X:stuxnet.vmem       </strong><br/><strong>--   </strong><br/><strong>profile=WinXPSP3x86 -p 868</strong>
</pre>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="assets/7842f147-9026-489d-8f02-078ee503a10b.png"/></div>
<div class="CDPAlignCenter packt_figref CDPAlign">Figure 2.10. Volatility dlllist plugin output for the suspicious process with PID 868</div>
<pre style="padding-left: 60px" class="CDPAlignLeft CDPAlign">
<strong>volatility_2.6_win64_standalone.exe -f X:stuxnet.vmem </strong><br/><strong>profile=WinXPSP3x86 -p 1928</strong>
</pre>
<p> </p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="assets/bf1b54ef-4d85-45c6-8815-da17a289efa9.png"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 2.11. Volatility dlllist plugin output for the suspicious process with PID 1928</div>
<ol start="7">
<li>Look at figure 2.11. Anything suspicious? Yes! According to the Stuxnet threat description on F-Secure's website, an <span>encrypted DLL file should be injected into a process, and it has the following name structure: <kbd>[<span class="text-bold">normaldll</span>].ASLR.[<span class="text-bold">random</span>]</kbd>.</span></li>
<li><span>Look familiar? We have found another trace of Stuxnet - <kbd>KERNEL32.DLL.ASLR.0360b7ab</kbd>.</span></li>
</ol>
<p class="CDPAlignLeft CDPAlign">There is another extremely useful Volatility plugin - <kbd>malfind</kbd>. This plugin helps digital forensic examiners <span>to find hidden or injected code/DLLs in the user mode memory.</span> Let's use it for our suspicious <kbd>lsass.exe</kbd> processes:</p>
<pre style="padding-left: 60px">
<strong>volatility_2.6_win64_standalone.exe -f X:stuxnet.vmem     </strong><br/><strong>--    </strong><br/><strong>profile=WinXPSP3x86 malfind -p 868 --dump-dir    </strong><br/><strong>X:Stuxnet</strong>
</pre>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="assets/b97454d0-d9d0-4d2a-9982-58388a767cd7.png"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 2.12. A part of Volatility malfind plugin output for the suspicious process with PID 868</div>
<p class="CDPAlignLeft CDPAlign">As you can see, we also used the <kbd>--dump-dir</kbd> switch to export the DLLs to a folder. After that we can, for example, upload them to VirusTotal. And of course, most of them are detected as malicious. For example, <kbd>process.0x81c47c00.0x80000.dmp</kbd>, extracted from <span><kbd>lsass.exe</kbd> with PID <kbd>1928</kbd>, is detected by Dr.Web Antivirus as <strong>Trojan.Stuxnet.1</strong>.</span></p>
<div class="CDPAlignLeft CDPAlign packt_infobox">There are many more Volatility plugins available. You can learn more about them in the documentation available on the Volatility Foundation website.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The following list explains the plugins used in the recipe.</p>
<ol>
<li><kbd>Imageinfo</kbd>: This plugin collects some basic information about the memory image you are analyzing: <span>operating system, service pack, hardware architecture; and also useful information such as DTB address, KDBG address, and the timestamp of the image creation.</span></li>
</ol>
<ol start="2">
<li><kbd>Pslist</kbd>: This plugin shows the processes of the system, including <span>the offset, process name, process ID, parent process ID, number of threads, number of handles, date/time when the process started and exited, Session ID and if the process is a WoW64 process.</span></li>
<li><kbd>Pstree</kbd>: This plugin does the same as <kbd>pslist</kbd>, but shows <span>the process list in tree form. It uses indentation and periods to indicate child processes.</span></li>
<li><kbd>Dlllist</kbd>: This plugin displays the DLLs loaded by the process of interest, or all processes if the <kbd>-p</kbd> or <kbd>--pid</kbd> switch isn't used.</li>
<li><kbd>Malfind</kbd>: This plugin allows the examiner to detect and extract <span>hidden or injected code/DLLs in user mode memory for further antivirus scans and analysis.</span></li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<p class="CDPAlignLeft CDPAlign">Volatility documentation: <a href="https://github.com/volatilityfoundation/volatility/wiki">https://github.com/volatilityfoundation/volatility/wiki</a></p>
<p class="CDPAlignLeft CDPAlign">A memory image from a system infected with Stuxnet: <a href="https://github.com/ganboing/malwarecookbook">https://github.com/ganboing/malwarecookbook</a></p>
<p class="CDPAlignLeft CDPAlign">Stuxnet threat description: <a href="https://www.f-secure.com/v-descs/trojan-dropper_w32_stuxnet.shtml">https://www.f-secure.com/v-descs/trojan-dropper_w32_stuxnet.shtml</a></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Variations in Windows versions</h1>
                </header>
            
            <article>
                
<p>As you already know from the first chapter, nowadays we have a number of different Windows versions widely used both by private persons and businesses. Of course, this has an impact on Windows operating system forensic examinations, including Windows memory forensics.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Knowing the Windows version and its type is very important, both in the acquisition and analysis stages. There are a few ways to collect this information. We will cover some in this recipe.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>The easiest way to find out which version a computer is running is by following these steps:</p>
<ol>
<li>Click on <span class="packt_screen">Start</span>.</li>
<li>Go to <span class="packt_screen">Run</span>.</li>
<li>Type <kbd>winver</kbd> in the search field and press <em>Enter</em>.</li>
</ol>
<p>This will work on machines that have installed Windows 7 or earlier versions. For Windows 8 onwards:</p>
<ol>
<li>You will need to press and hold the <em>Windows</em> key along with <em>R</em></li>
<li>Type <kbd>winver</kbd> in the box that appears and press <em>Enter</em></li>
</ol>
<p>This will open a small <span class="packt_screen">About Windows</span> box, which will provide information on the version, as well as the build number:</p>
<div class="CDPAlignCenter CDPAlign"><img height="333" width="380" class="image-border" src="assets/5cf90738-c542-43c0-ad5d-6f6d5ff54f9e.png"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 2.13. About Windows box</div>
<p>To collect more information, perform the following steps:</p>
<ol>
<li>Go to the <span class="packt_screen">Start</span> menu</li>
<li>Right-click on <span class="packt_screen">Computer</span> and choose <span class="packt_screen">Properties</span> from the context menu</li>
</ol>
<p style="padding-left: 60px">Also, you can find <span class="packt_screen">My Computer</span>, <span class="packt_screen">Computer</span>, or <span class="packt_screen">This PC</span> shortcuts on the Desktop right-click on any one of these and choose <span class="packt_screen">Properties</span> from the context menu:</p>
<div class="CDPAlignCenter CDPAlign"><img height="381" width="457" class="image-border" src="assets/10ca51fb-d8cc-4e5e-9e74-b42dc7951d38.png"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 2.14. Computer properties</div>
<p style="padding-left: 60px">As you can see in figure 2.14, with this technique you can collect more information about the machine you are dealing with, including the service pack, <span class="packt_screen">system type</span>, c<span class="packt_screen">omputer name</span>, and so on.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There is more...</h1>
                </header>
            
            <article>
                
<p>If you are planning to use Volatility for memory forensic analysis (and we highly recommend it, because it is the most powerful tool, with lots of plugins, and also it is free and open source), it's very important to choose the right profile. To do this, you will need to know the system type, operating system version, and build number. As you have already learned from the previous recipes, the <kbd>imageinfo</kbd> plugin can help you with this task if this information wasn't properly documented during the acquisition stage.</p>
<p>Table 2.1 contains information about profiles added to the most recent version of the Volatility Framework at the time of writing.</p>
<table>
<thead>
<tr>
<td><strong>OS</strong></td>
<td><strong>Build</strong></td>
<td><strong>Profile</strong></td>
</tr>
</thead>
<tbody>
<tr>
<td>Windows 10 x64</td>
<td>10.0.10586.306</td>
<td>Win10x64_10586</td>
</tr>
<tr>
<td>Windows 10 x64</td>
<td>10.0.14393.0</td>
<td>Win10x64_14393</td>
</tr>
<tr>
<td>Windows 10 x86</td>
<td>10.0.10586.420</td>
<td>Win10x86_10586</td>
</tr>
<tr>
<td>Windows 10 x86</td>
<td>10.0.14393.0</td>
<td>Win10x86_14393</td>
</tr>
<tr>
<td>Windows Server 2008 R2 SP1 x64</td>
<td>6.1.7601.23418</td>
<td>Win2008R2SP1x64_23418</td>
</tr>
<tr>
<td>Windows Server 2008 R2 x64</td>
<td>6.3.9600.18340</td>
<td>Win2012R2x64_18340</td>
</tr>
<tr>
<td>Windows 7 SP1 x64</td>
<td>6.1.7601.23418</td>
<td>Win7SP1x64_23418</td>
</tr>
<tr>
<td>Windows 7 SP1 x86</td>
<td>6.1.7601.23418</td>
<td>Win7SP1x86_23418</td>
</tr>
<tr>
<td>Windows 8 x64</td>
<td>6.3.9600.18340</td>
<td>Win8SP1x64_18340</td>
</tr>
</tbody>
</table>
<div class="packt_figref CDPAlignCenter">Table 2.1. Volatility 2.6 profiles list</div>
<p>Also, it's important to note that on all x64 Windows 8/2012 (and later), the KDBG (which contains a list of the running processes and loaded kernel modules) is encrypted by default, so you should use the virtual address of KdCopyDataBlock. Both addresses can be collected with the <strong>kdbgscan</strong> Volatility plugin.</p>


            </article>

            
        </section>
    </body></html>