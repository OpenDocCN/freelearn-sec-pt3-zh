["```\nPRAGMA journal_mode=WAL; \n```", "```\n(WAL File Size - 32) / (WAL Page Size + 24) \n20,600 / 4,120 = 5 frames \n```", "```\nSerial Types = 0, 2, 6, 8, and 25 \nPayload = 0x166400000009C5BA3649737069646572 \nSplit_Payload = N/A , 0x1664, 0x00000009C5BA3649, N/A, 0x737069646572 \nConverted_Payload = Null, 5732, 163953206, 0, \"spider\" \n```", "```\n>>> import re \n>>> phone = '214-324-5555' \n>>> expression = r'214-324-5555' \n>>> re_expression = re.compile(expression) \n>>> if re_expression.match(phone): print(True)\n...  \nTrue\n```", "```\n>>> expression = r'[0-9]{3}-[0-9]{3}-[0-9]{4}' \n```", "```\n>>> expression_1 = r'^4\\d{15}$' \n>>> expression_2 = r'^4\\d{3}([\\ \\  -]?)\\d{4}\\1\\d{4}\\1\\d{4}$' \n```", "```\n>>> from tqdm import trange \n>>> from time import sleep \n>>> for x in trange(100): \n...     sleep(1) \n```", "```\n002 from __future__ import print_function\n003 import argparse\n004 import binascii\n005 import logging\n006 import os\n007 import re\n008 import struct\n009 import sys\n010 from collections import namedtuple\n011 if sys.version_info[0] == 2:\n012     import unicodecsv as csv\n013 elif sys.version_info[0] == 3:\n014     import csv\n015 \n016 from tqdm import trange\n```", "```\n055 def main() \n... \n133 def frame_parser(): \n... \n173 def cell_parser(): \n... \n229 def dict_helper(): \n... \n243 def single_varint(): \n... \n273 def multi_varint(): \n... \n298 def type_helper(): \n... \n371 def csv_writer(): \n... \n428 def regular_search(): \n```", "```\n481 if __name__ == '__main__':\n482 \n483     parser = argparse.ArgumentParser(description=__description__,\n484                     epilog='Developed by ' +\n485                     __author__ + ' on ' +\n486                     __date__)\n487 \n488     parser.add_argument('WAL', help='SQLite WAL file')\n489     parser.add_argument('OUTPUT_DIR', help='Output Directory')\n490     parser.add_argument('-r', help='Custom regular expression')\n491     parser.add_argument('-m', help='Run regular expression module',\n492     action='store_true')\n493     parser.add_argument('-l', help='File path of log file')\n494     args = parser.parse_args()\n```", "```\n496     if args.l:\n497         if not os.path.exists(args.l):\n498             os.makedirs(args.l)\n499         log_path = os.path.join(args.l, 'wal_crawler.log')\n500     else:\n501         log_path = 'wal_crawler.log'\n502     logging.basicConfig(filename=log_path, level=logging.DEBUG,\n503                         format=('%(asctime)s | %(levelname)s | '\n504                         '%(message)s'), filemode='a')\n505 \n506     logging.info('Starting Wal_Crawler')\n507     logging.debug('System ' + sys.platform)\n508     logging.debug('Version ' + sys.version)\n```", "```\n510     if not os.path.exists(args.OUTPUT_DIR):\n511         os.makedirs(args.OUTPUT_DIR)\n512 \n513     if os.path.exists(args.WAL) and os.path.isfile(args.WAL):\n514         main(args.WAL, args.OUTPUT_DIR, r=args.r, m=args.m)\n515     else:\n516         msg = 'Supplied WAL file does not exist or isn't a file'\n517         print('[-]', msg)\n518         logging.error(msg)\n519         sys.exit(1)\n```", "```\n055 def main(wal_file, output_dir, **kwargs):\n056     \"\"\"\n057     The main function parses the header of the input file and\n058     identifies the WAL file. It then splits the file into the\n059     appropriate frames and send them for processing. After\n060     processing, if applicable, the regular expression modules are\n061     ran. Finally the raw data output is written to a CSV file.\n062     :param wal_file: The filepath to the WAL file to be processed\n063     :param output_dir: The directory to write the CSV report to.\n064     :return: Nothing.\n065     \"\"\"\n```", "```\n066     msg = 'Identifying and parsing file header'\n067     print('[+]', msg)\n068     logging.info(msg)\n069 \n070     wal_attributes = {'size': os.path.getsize(wal_file),\n071     'header': {}, 'frames': {}}\n072     with open(wal_file, 'rb') as wal:\n073 \n074         # Parse 32-byte WAL header.\n075         header = wal.read(32)\n076 \n077         # If file is less than 32 bytes long: exit wal_crawler.\n078         try:\n079             wal_attributes['header'] = dict_helper(header,'>4s7i',\n080             namedtuple('struct',\n081             'magic format pagesize checkpoint '\n082             'salt1 salt2 checksum1 checksum2'))\n083         except struct.error as e:\n084             logging.error('STRUCT ERROR:', e.message)\n085             print('[-]', e.message + '. Exiting..')\n086             sys.exit(2)\n```", "```\n088         # Do not proceed in the program if the input file isn't a\n089         # WAL file.\n090         magic_hex = binascii.hexlify(\n091         wal_attributes['header']['magic']).decode('utf-8')\n092         if magic_hex != \"377f0682\" and magic_hex != \"377f0683\":\n093             logging.error(('Magic mismatch, expected 0x377f0682 '\n094             'or 0x377f0683 | received {}'.format(magic_hex)))\n095             print(('[-] File does not have appropriate signature '\n096             'for WAL file. Exiting...'))\n097             sys.exit(3)\n098 \n099         logging.info('File signature matched.')\n100         logging.info('Processing WAL file.')\n```", "```\n102         # Calculate number of frames.\n103         frames = int((\n104         wal_attributes['size'] - 32) / (\n105         wal_attributes['header']['pagesize'] + 24))\n106         print('[+] Identified', frames, 'Frames.')\n```", "```\n108         # Parse frames in WAL file. Create progress bar using\n109         # trange(frames) which is an alias for tqdm(xrange(frames)).\n110         print('[+] Processing frames...')\n111         for x in trange(frames):\n112 \n113             # Parse 24-byte WAL frame header.\n114             wal_attributes['frames'][x] = {}\n115             frame_header = wal.read(24)\n116             wal_attributes['frames'][x]['header'] = dict_helper(\n117             frame_header, '>6i', namedtuple('struct',\n118             'pagenumber commit salt1'\n119             ' salt2 checksum1'\n120             ' checksum2'))\n```", "```\n121             # Parse pagesize WAL frame.\n122             frame = wal.read(wal_attributes['header']['pagesize'])\n123             frame_parser(wal_attributes, x, frame)\n```", "```\n125         # Run regular expression functions.\n126         if kwargs['m'] or kwargs['r']:\n127             regular_search(wal_attributes, kwargs)\n128 \n129         # Write WAL data to CSV file.\n130         csv_writer(wal_attributes, output_dir)\n```", "```\n133 def frame_parser(wal_dict, x, frame):\n134     \"\"\"\n135     The frame_parser function processes WAL frames.\n136     :param wal_dict: The dictionary containing parsed WAL objects.\n137     :param x: An integer specifying the current frame.\n138     :param frame: The content within the frame read from the WAL\n139     file.\n140     :return: Nothing.\n141     \"\"\"\n```", "```\n143     # Parse 8-byte WAL page header\n144     page_header = frame[0:8]\n145     wal_dict['frames'][x]['page_header'] = dict_helper(\n146     page_header, '>b3hb', namedtuple('struct',\n147     'type freeblocks cells offset'\n148     ' fragments'))\n```", "```\n149     # Only want to parse 0x0D B-Tree Leaf Cells\n150     if wal_dict['frames'][x]['page_header']['type'] != 13:\n151         logging.info(('Found a non-Leaf Cell in frame {}. Popping '\n152         'frame from dictionary').format(x))\n153         wal_dict['frames'].pop(x)\n154         return\n```", "```\n155     # Parse offsets for \"X\" cells\n156     cells = wal_dict['frames'][x]['page_header']['cells']\n157     wal_dict['frames'][x]['cells'] = {}\n158     print('[+] Identified', cells, 'cells in frame', x)\n159     print('[+] Processing cells...')\n```", "```\n161     for y in range(cells):\n162         start = 8 + (y * 2)\n163         wal_dict['frames'][x]['cells'][y] = {}\n164 \n165         wal_dict['frames'][x]['cells'][y] = dict_helper(\n166         frame[start: start + 2], '>h', namedtuple(\n167         'struct', 'offset'))\n```", "```\n169         # Parse cell content\n170         cell_parser(wal_dict, x, y, frame)\n```", "```\n173 def cell_parser(wal_dict, x, y, frame):\n174     \"\"\"\n175     The cell_parser function processes WAL cells.\n176     :param wal_dict: The dictionary containing parsed WAL objects.\n177     :param x: An integer specifying the current frame.\n178     :param y: An integer specifying the current cell.\n179     :param frame: The content within the frame read from the WAL\n180     file.\n181     :return: Nothing.\n182     \"\"\"\n```", "```\n183     index = 0 \n```", "```\n184     # Create alias to cell_root to shorten navigating the WAL\n185     # dictionary structure.\n186     cell_root = wal_dict['frames'][x]['cells'][y]\n187     cell_offset = cell_root['offset']\n```", "```\n189     # Parse the payload length and rowID Varints.\n190     try:\n191         payload_len, index_a = single_varint(\n192         frame[cell_offset:cell_offset + 9])\n193         row_id, index_b = single_varint(\n194         frame[cell_offset + index_a: cell_offset + index_a + 9])\n195     except ValueError:\n196         logging.warn(('Found a potential three-byte or greater '\n197         'varint in cell {} from frame {}').format(y, x))\n198         return\n```", "```\n200     # Update the index. Following the payload length and rowID is\n201     # the 1-byte header length.\n202     cell_root['payloadlength'] = payload_len\n203     cell_root['rowid'] = row_id\n204     index += index_a + index_b\n205     cell_root['headerlength'] = struct.unpack('>b',\n206     frame[cell_offset + index: cell_offset + index + 1])[0]\n```", "```\n208     # Update the index with the 1-byte header length. Next process\n209     # each Varint in \"headerlength\" - 1 bytes.\n210     index += 1\n211     try:\n212         types, index_a = multi_varint(\n213         frame[cell_offset + index:cell_offset+index+cell_root['headerlength']-1])\n214     except ValueError:\n215         logging.warn(('Found a potential three-byte or greater '\n216             'varint in cell {} from frame {}').format(y, x))\n217         return\n218     cell_root['types'] = types\n219     index += index_a\n```", "```\n221     # Immediately following the end of the Varint headers begins\n222     # the actual data described by the headers. Process them using\n223     # the typeHelper function.\n224     diff = cell_root['payloadlength'] - cell_root['headerlength']\n225     cell_root['data'] = type_helper(cell_root['types'],\n226     frame[cell_offset + index: cell_offset + index + diff])\n```", "```\n229 def dict_helper(data, format, keys):\n230     \"\"\"\n231     The dict_helper function creates an OrderedDictionary from\n232     a struct tuple.\n233     :param data: The data to be processed with struct.\n234     :param format: The struct format string.\n235     :param keys: A string of the keys for the values in the struct\n236     tuple.\n237     :return: An OrderedDictionary with descriptive keys of\n238     struct-parsed values.\n239     \"\"\"\n240     return keys._asdict(keys._make(struct.unpack(format, data)))\n```", "```\n240     import pdb; pdb.set_trace() \n241     return keys._asdict(keys._make(struct.unpack(format, data))) \n```", "```\n(Pdb) struct.unpack(format, data) \n('7x7fx06x82', 3007000, 32768, 9, -977652151, 1343711549, 670940632, 650030285) \n```", "```\n(Pdb) keys._make(struct.unpack(format, data)) \nstruct(magic='7x7fx06x82', format=3007000, pagesize=32768, checkpoint=9, salt1=-977652151, salt2=1343711549, checksum1=670940632, checksum2=650030285) \n```", "```\n(Pdb) keys._asdict(keys._make(struct.unpack(format, data))) \nOrderedDict([('magic', '7x7fx06x82'), ('format', 3007000), ('pagesize', 32768), ('checkpoint', 9), ('salt1', -977652151), ('salt2', 1343711549), ('checksum1', 670940632), ('checksum2', 650030285)]) \n```", "```\n243 def single_varint(data, index=0):\n244     \"\"\"\n245     The single_varint function processes a Varint and returns the\n246     length of that Varint.\n247     :param data: The data containing the Varint (maximum of 9\n248     bytes in length as that is the maximum size of a Varint).\n249     :param index: The current index within the data.\n250     :return: varint, the processed varint value,\n251     and index which is used to identify how long the Varint was.\n252     \"\"\"\n```", "```\n254     # If the decimal value is => 128 -- then first bit is set and\n255     # need to process next byte.\n256     if ord(data[index:index+1]) >= 128:\n257         # Check if there is a three or more byte varint\n258         if ord(data[index + 1: index + 2]) >= 128:\n259             raise ValueError\n```", "```\nVarint = ((x - 128) * 128) + y\n```", "```\n260         varint = (ord(data[index:index+1]) - 128) * 128 + ord(\n261         data[index + 1: index + 2])\n262         index += 2\n263         return varint, index\n```", "```\n265     # If the decimal value is < 128 -- then first bit isn't set \n266     # and is the only byte of the Varint.\n267     else:\n268         varint = ord(data[index:index+1])\n269         index += 1\n270         return varint, index\n```", "```\n273 def multi_varint(data):\n274     \"\"\"\n275     The multi_varint function is similar to the single_varint\n276     function. The difference is that it takes a range of data\n277     and finds all Varints within it.\n278     :param data: The data containing the Varints.\n279     :return: varints, a list containing the processed varint\n280     values, and index which is used to identify how long the\n281     Varints were.\n282     \"\"\"\n283     varints = []\n284     index = 0\n```", "```\n286     # Loop forever until all Varints are found by repeatedly\n287     # calling singleVarint.\n288     while len(data) != 0:\n289         varint, index_a = single_varint(data)\n290         varints.append(varint)\n291         index += index_a\n292         # Shorten data to exclude the most recent Varint.\n293         data = data[index_a:]\n294 \n295     return varints, index\n```", "```\n298 def type_helper(types, data):\n299     \"\"\"\n300     The type_helper function decodes the serial type of the\n301     Varints in the WAL file.\n302     :param types: The processed values of the Varints.\n303     :param data: The raw data in the cell that needs to be\n304     properly decoded via its varint values.\n305     :return: cell_data, a list of the processed data.\n306     \"\"\"\n```", "```\n307     cell_data = []\n308     index = 0\n```", "```\n310     # Value of type dictates how the data should be processed. \n311     # See serial type table in chapter for list of possible\n312     # values.\n313     for type in types:\n314 \n315         if type == 0:\n316             cell_data.append('NULL (RowId?)')\n317         elif type == 1:\n318             cell_data.append(struct.unpack('>b',\n319                 data[index:index + 1])[0])\n320             index += 1\n321         elif type == 2:\n322             cell_data.append(struct.unpack('>h',\n323                 data[index:index + 2])[0])\n324             index += 2\n325         elif type == 3:\n326             # Struct does not support 24-bit integer\n327             cell_data.append(int(binascii.hexlify(\n328                 data[index:index + 3]).decode('utf-8'), 16))\n329             index += 3\n330         elif type == 4:\n331             cell_data.append(struct.unpack(\n332                 '>i', data[index:index + 4])[0])\n333             index += 4\n334         elif type == 5:\n335             # Struct does not support 48-bit integer\n336             cell_data.append(int(binascii.hexlify(\n337                 data[index:index + 6]).decode('utf-8'), 16))\n338             index += 6\n```", "```\n339         elif type == 6:\n340             cell_data.append(struct.unpack(\n341                 '>q', data[index:index + 8])[0])\n342             index += 8\n343         elif type == 7:\n344             cell_data.append(struct.unpack(\n345                 '>d', data[index:index + 8])[0])\n346             index += 8\n347         # Type 8 == Constant 0 and Type 9 == Constant 1\\. Neither of these take up space in the actual data.\n348         elif type == 8:\n349             cell_data.append(0)\n350         elif type == 9:\n351             cell_data.append(1)\n352         # Types 10 and 11 are reserved and currently not implemented.\n```", "```\n353         elif type > 12 and type % 2 == 0:\n354             b_length = int((type - 12) / 2)\n355             cell_data.append(data[index:index + b_length])\n356             index += b_length\n357         elif type > 13 and type % 2 == 1:\n358             s_length = int((type - 13) / 2)\n359             cell_data.append(\n360                 data[index:index + s_length].decode('utf-8'))\n361             index += s_length\n```", "```\n363         else:\n364             msg = 'Unexpected serial type: {}'.format(type)\n365             print('[-]', msg)\n366             logging.error(msg)\n367 \n368     return cell_data\n```", "```\n371 def csv_writer(data, output_dir):\n372     \"\"\"\n373     The csv_writer function writes frame, cell, and data to a CSV\n374     output file.\n375     :param data: The dictionary containing the parsed WAL file.\n376     :param output_dir: The directory to write the CSV report to.\n377     :return: Nothing.\n378     \"\"\"\n379     headers = ['Frame', 'Salt-1', 'Salt-2', 'Frame Offset',\n380         'Cell', 'Cell Offset', 'ROWID', 'Data']\n381 \n382     out_file = os.path.join(output_dir, 'wal_crawler.csv')\n383 \n384     if sys.version_info[0] == 2:\n385         csvfile = open(out_file, \"wb\")\n386     elif sys.version_info[0] == 3:\n387         csvfile = open(out_file, \"w\", newline='',\n388             encoding='utf-8')\n389 \n390     with csvfile:\n391         writer = csv.writer(csvfile)\n392         writer.writerow(headers)\n```", "```\n394         for frame in data['frames']:\n395 \n396             for cell in data['frames'][frame]['cells']:\n397 \n398             # Only write entries for cells that have data.\n399             if ('data' in data['frames'][frame]['cells'][cell].keys() and\n400             len(data['frames'][frame]['cells'][cell]['data']) > 0):\n```", "```\n401                 # Convert relative frame and cell offsets to\n402                 # file offsets.\n403                 frame_offset = 32 + (\n404                     frame * data['header']['pagesize']) + (\n405                     frame * 24)\n406                     cell_offset = frame_offset + 24 + data['frames'][frame]['cells'][cell]['offset']\n```", "```\n408                 # Cell identifiers include the frame #, \n409                 # salt-1, salt-2, frame offset,\n410                 # cell #, cell offset, and cell rowID.\n411                 cell_identifiers = [frame, data['frames'][frame]['header']['salt1'],\n412                     data['frames'][frame]['header']['salt2'],\n413                     frame_offset, cell, cell_offset,\n414                     data['frames'][frame]['cells'][cell]['rowid']]\n```", "```\n416                 # Write the cell_identifiers and actual data\n417                 # within the cell\n418                 writer.writerow(\n419                     cell_identifiers + data['frames'][frame]['cells'][cell]['data'])\n```", "```\n421             else:\n422                 continue\n423 \n424     csvfile.flush()\n425     csvfile.close()\n```", "```\n428 def regular_search(data, options):\n429     \"\"\"\n430     The regular_search function performs either default regular\n431     expression searches for personal information or custom\n432     searches based on a supplied regular expression string.\n433     :param data: The dictionary containing the parsed WAL file.\n434     :param options: The options dictionary contains custom or\n435     pre-determined regular expression searching\n436     :return: Nothing.\n437     \"\"\"\n```", "```\n438     msg = 'Initializing regular expression module.'\n439     print('\\n{}\\n[+]'.format('='*20), msg)\n440     logging.info(msg)\n441     if options['r'] and not options['m']:\n442         regexp = {'Custom': options['r']}\n443     else:\n444         # Default regular expression modules include: Credit card\n445         # numbers, SSNs, Phone numbers, URLs, IP Addresses.\n446         regexp = {'Visa Credit Card': r'^4\\d{3}([\\ \\-]?)\\d{4}\\1\\d{4}\\1\\d{4}$',\n447             'SSN': r'^\\d{3}-\\d{2}-\\d{4}$',\n448             'Phone Number': r'^\\d{3}([\\ \\. \\-]?)\\d{3}\\1\\d{4}$',\n449             'URL': r\"(http[s]?://)|(www.)(?:[a-zA-Z]|[0-9]|[$-_@.&+]|[!*\\(\\),]|(?:%[0-9a-fA-F][0-9a-fA-F]))+\",\n450         'IP Address': r'^\\d{1,3}.\\d{1,3}.\\d{1,3}.\\d{1,3}$'}\n```", "```\n452         if options['r']:\n453             regexp['Custom'] = options['r']\n```", "```\n455     # Must compile each regular expression before seeing if any\n456     # data \"matches\" it.\n457     for exp in regexp.keys():\n458         reg_exp = re.compile(regexp[exp])\n```", "```\n460         for frame in data['frames']:\n461 \n462             for cell in data['frames'][frame]['cells']:\n463 \n464                 for datum in range(len(\n465                 data['frames'][frame]['cells'][cell]['data'])):\n466                     # TypeError will occur for non-string objects\n467                     # such as integers.\n468                     try:\n469                         match = reg_exp.match(\n470                         data['frames'][frame]['cells'][cell]['data'][datum])\n471                     except TypeError:\n472                         continue\n473                     # Print any successful match to user.\n474                     if match:\n475                         msg = '{}: {}'.format(exp,\n476                         data['frames'][frame]['cells'][cell]['data'][datum])\n477                         print('[*]', msg)\n478     print('='*20)\n```"]