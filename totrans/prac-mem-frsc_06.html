<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer075">
			<h1 id="_idParaDest-51"><a id="_idTextAnchor050"/>Chapter 4: Reconstructing User Activity with Windows Memory Forensics</h1>
			<p>User activity reconstruction is essential for many use cases since it gives us a better understanding of what is going on. In the first chapter, we discussed that if you receive a device participating in the incident, the victim or suspect probably owned this device. If we analyze the victim's device, user activity can tell us how the infection occurred or how the attacker acted while remotely accessing the computer. If we are talking about the attacker's device, such analysis allows us to understand how the preparation for the attack took place, what actions the threat actor performed, and how to find evidence of illegitimate activity. Also, if you are dealing with criminal cases that are not related to hacking but more traditional crimes, such as child pornography, human trafficking, and drug dealing, memory images may contain key sources of evidence. Here, you may be able to recover private communications and browser history, as well as the encryption keys of the containers that were used by the suspect to hide the data. </p>
			<p>This chapter will provide some insights into user action recovery techniques, based not only on running processes but also on analyzing Windows Registry and the filesystem in memory.</p>
			<p>The following topics will be covered in this chapter:</p>
			<ul>
				<li>Analyzing launched applications</li>
				<li>Searching for opened documents</li>
				<li>Investigating browser history</li>
				<li>Examining communication applications</li>
				<li>Recovering user passwords</li>
				<li>Detecting crypto containers</li>
				<li>Extracting recent activity from the registry</li>
			</ul>
			<h1 id="_idParaDest-52"><a id="_idTextAnchor051"/>Technical requirements</h1>
			<p>To work with the tools described in the next three chapters and conduct Windows memory forensics, you do not need to meet certain technical requirements. It is sufficient to have a Windows operating system installed on the main host or a virtual machine.</p>
			<h1 id="_idParaDest-53"><a id="_idTextAnchor052"/>Analyzing launched applications</h1>
			<p>Applications analysis may help an investigator to build the suspect's profile. The analysis of running processes<a id="_idIndexMarker085"/> may help us to understand whether the suspect is using some messengers or web browsers with high anonymity levels or if any encrypted containers are currently mounted. Such data sources may be full of valuable forensic artifacts and, what's more, be unavailable during post-mortem analysis.</p>
			<p>Each time the user starts a program, the corresponding process is created in memory and added to the list of active processes. By analyzing this list, we can get information about the programs running at the moment the dump is taken. That's what we'll do once we get to know our analysis tools.</p>
			<h2 id="_idParaDest-54"><a id="_idTextAnchor053"/>Introducing Volatility</h2>
			<p>The <strong class="bold">Volatility framework</strong> is the most popular free tool for memory dump analysis. Many vendors<a id="_idIndexMarker086"/> have included support for this tool in their solutions, including <em class="italic">Autopsy</em> and <em class="italic">Magnet AXIOM</em>. The source code for this tool is written in Python, so Volatility<a id="_idIndexMarker087"/> can be used on different operating systems. Moreover, Volatility allows you to analyze various operating systems, ranging from <em class="italic">Windows XP</em> to <em class="italic">Linux</em> and <em class="italic">macOS</em>. Naturally, we also decided to take Volatility as a basis, but we will not limit ourselves to it either.</p>
			<p>To run Volatility, you can use one of the following options:</p>
			<ul>
				<li><strong class="bold">Volatility Standalone</strong>: This version is a separate<a id="_idIndexMarker088"/> executable file. The last version<a id="_idIndexMarker089"/> that was released in this format was <strong class="bold">Volatility 2.6</strong>. You can get it from the official site: <a href="https://www.volatilityfoundation.org/26">https://www.volatilityfoundation.org/26</a>. Just download the version that suits<a id="_idIndexMarker090"/> your operating system and copy the executable file to a convenient location.</li>
				<li><strong class="bold">Python scripts</strong>: Using scripts has its advantages as they are updated more frequently and support a larger<a id="_idIndexMarker091"/> number of profiles. To get them, you can simply<a id="_idIndexMarker092"/> go to the Volatility GitHub repository and clone the project: <a href="https://github.com/volatilityfoundation/volatility">https://github.com/volatilityfoundation/volatility</a>. </li>
				<li><strong class="bold">Volatility Workbench</strong>: This option is suitable for those<a id="_idIndexMarker093"/> who prefer to work with tools that have a graphical interface. The developers of the Workbench periodically<a id="_idIndexMarker094"/> update it, so this tool also supports the latest versions of Volatility, including Volatility 3. However, it also has disadvantages, such as incomplete support<a id="_idIndexMarker095"/> for all the parameters available in Volatility. You can download Workbench for free from the official website: <a href="https://www.osforensics.com/tools/volatility-workbench.html">https://www.osforensics.com/tools/volatility-workbench.html</a>.</li>
			</ul>
			<p>The Volatility<a id="_idIndexMarker096"/> project is actively supported, so you can always find detailed installation instructions, official plugin descriptions, plugins from the community, and more information from the appropriate public sources. This includes the official web page, Volatility's GitHub repository, and various forums.</p>
			<p>At the time of writing, the latest version of Volatility is Volatility 3. However, this version is still under development, and some of the plugins we need are underdeveloped or missing altogether. In addition, the output processing in Volatility 3 is not as easy as in version 2.6, so we gave preference to the previous version of Volatility.</p>
			<p>At the time of writing, the latest version of Volatility is Volatility 3. However, this version is still under development, and some of the plugins we need are underdeveloped or missing altogether. In addition, the output processing in Volatility 3 is not as easy as in version 2.6, so we gave preference to the previous version of Volatility.</p>
			<p>We will take the easy route and choose the standalone version. If you are running Windows, then after downloading Volatility from the official website, you will get the <strong class="source-inline">volatility_2.6_win64_standalone.exe</strong> executable file. Volatility is a command-line tool, so you need <em class="italic">Windows PowerShell</em> or <em class="italic">Windows Command Prompt</em> to run it. To check that everything works correctly, you can open PowerShell, go to the folder that contains the tool (in our case, this is the <strong class="source-inline">D:\</strong> <strong class="source-inline">drive</strong>), and run Volatility with the <strong class="source-inline">--info</strong> option. This option opens the help menu, as shown in the following screenshot:</p>
			<div>
				<div id="_idContainer030" class="IMG---Figure">
					<img src="Images/Figure_4.1_B17056.jpg" alt="Figure 4.1 – Volatility information&#13;&#10;" width="1191" height="630"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.1 – Volatility information</p>
			<p>Pay attention to the <strong class="bold">Profiles</strong> section since it lists all the versions of the operating systems supported<a id="_idIndexMarker097"/> by your version of Volatility. Without a correctly specified profile, the tool will not work as expected. </p>
			<h2 id="_idParaDest-55"><a id="_idTextAnchor054"/>Profile identification</h2>
			<p>Each profile in the <strong class="bold">Profiles</strong> section corresponds<a id="_idIndexMarker098"/> to a specific version of the operating system. If you do not know which profile is needed to analyze your memory<a id="_idIndexMarker099"/> dump, you can always use the <strong class="source-inline">imageinfo</strong> plugin, which will try to find the most suitable profiles for you. To run this plugin, you will also need to use the <strong class="source-inline">-f</strong> option, after which you must specify the path to the memory dump you want to analyze. We used the memory dump named <strong class="source-inline">Win10Mem.vmem</strong>, located in the <strong class="source-inline">D:\user activity</strong> folder. The whole command should look as follows:</p>
			<div>
				<div id="_idContainer031" class="IMG---Figure">
					<img src="Images/Figure_4.2_B17056.jpg" alt="Figure 4.2 – Volatility imageinfo&#13;&#10;" width="1138" height="306"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.2 – Volatility imageinfo</p>
			<p>If you run the command successfully, the <strong class="source-inline">Suggested profiles</strong> line will show a list of profiles that Volatility considers<a id="_idIndexMarker100"/> suitable for the analysis. In most cases, the first profile<a id="_idIndexMarker101"/> on the list will be the most suitable, but if you notice that some plugins do not work (which may be a lack of output, incorrect output, or an error message) with that profile, just try to change it.</p>
			<p>Another important point is that if the operating system that the dump was taken from is quite new, a suitable profile may not exist. In this case, you can search on GitHub and add a new profile to Volatility, look at the next version of Volatility – in this case, Volatility 3 – or use another tool. Of course, if you cannot find a proper profile, you can write one yourself, but you will need a deeper knowledge of programming and operating systems to do so.</p>
			<p>In our case, we will use the <strong class="source-inline">Win10x64_14393</strong> profile for the <strong class="source-inline">Win10Mem.vmem</strong> dump. </p>
			<p>At this point, we have a tool and a suitable profile. Now, we can analyze the list of active processes.</p>
			<h2 id="_idParaDest-56"><a id="_idTextAnchor055"/>Searching for active processes</h2>
			<p>Volatility has several plugins<a id="_idIndexMarker102"/> for listing the processes running on the system at the time of dump creation. The first one, <strong class="source-inline">pslist</strong>, allows you to get a list sorted by time. If we are mostly interested not in creation time but the relationship between the parent and child processes, the better option is to use <strong class="source-inline">pstree</strong>. Both plugins work with a list of active processes in memory and display data that, on a live system, can be obtained with <strong class="bold">Task Manager</strong>.</p>
			<p>The universal command for getting started with any<a id="_idTextAnchor056"/> of the plugins is as follows: </p>
			<p class="source-code">volatility_2.6_win64_standalone.exe -f &lt;memory dump location&gt; --profile &lt;suitable profile from profile list&gt; &lt;plugin to run&gt;</p>
			<p>Let's try to get the list of active processes, sorted by time:</p>
			<div>
				<div id="_idContainer032" class="IMG---Figure">
					<img src="Images/Figure_4.3_B17056.jpg" alt="Figure 4.3 – Volatility pslist&#13;&#10;" width="1607" height="485"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.3 – Volatility pslist</p>
			<p>Take a look at the preceding<a id="_idIndexMarker103"/> screenshot. In the output of the plugin, we can find not only the name of the running process but also its unique identifier, the identifier of its parent process, the number of associated handles and threads, the time the process was created, and, if the process was terminated, the time it was exited.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">There are many different kernel objects. When a process needs to open a particular object, a reference, called handle, is opened for it. Since<a id="_idIndexMarker104"/> every active process must have at least one thread (an object that represents the smallest sequence of programmed instructions), there is always a handle for that type of object. In addition to that, handles are often created for objects such as files, registry keys, and even other processes.</p>
			<p>However, what if the process was terminated recently and information about it has been removed from the list of active processes?</p>
			<h2 id="_idParaDest-57"><a id="_idTextAnchor057"/>Searching for finished processes</h2>
			<p>From the operating system's point of view, all processes are objects of a certain <strong class="source-inline">_EPROCESS</strong> structure. When a process<a id="_idIndexMarker105"/> finishes its work, its data is still stored in memory for some time until the space occupied by the process is overwritten. Volatility allows you to search for such processes using a search for objects, similar in structure to <strong class="source-inline">_EPROCESS</strong>. </p>
			<p>To find such processes, you can use the <strong class="source-inline">psscan</strong> plugin. Its execution will look as follows:</p>
			<div>
				<div id="_idContainer033" class="IMG---Figure">
					<img src="Images/Figure_4.4_B17056.jpg" alt="Figure 4.4 – Volatility psscan&#13;&#10;" width="1596" height="772"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.4 – Volatility psscan</p>
			<p>As you can see, the information that's displayed is quite similar to the <strong class="source-inline">pslist</strong> result, but now, we have more information about the terminated processes. </p>
			<p>Now, we can search for programs that were running by the user when the dump was created or were recently terminated. However, what if we need to look even further and search for programs that terminated earlier?</p>
			<p>In this case, Volatility has a <strong class="source-inline">userassist</strong> plugin, which retrieves information about the programs that the user frequently runs. This can also include programs that the user has recently worked with.</p>
			<p>We can obtain such data as the application name, run count, and last run time of the applications that were launched via <em class="italic">Windows Explorer</em>:</p>
			<div>
				<div id="_idContainer034" class="IMG---Figure">
					<img src="Images/Figure_4.5_B17056.jpg" alt="Figure 4.5 – Volatility userassist&#13;&#10;" width="1436" height="349"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.5 – Volatility userassist</p>
			<p>First of all, after execution, you will be able to see information about specific locations where this information was found. For example, <strong class="source-inline">\??\C:\Users\Ben\ntuser.dat</strong> means<a id="_idIndexMarker106"/> that the shown subkeys and values are related to the user <strong class="source-inline">Ben</strong>.</p>
			<p>The following screenshot shows separate entries related to each application:</p>
			<div>
				<div id="_idContainer035" class="IMG---Figure">
					<img src="Images/Figure_4.6_B17056.jpg" alt="Figure 4.6 – Userassist entries &#13;&#10;" width="1263" height="540"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.6 – Userassist entries </p>
			<p>As you can see, <strong class="source-inline">userassist</strong> shows the full path to the executable, run count, time focused, and the date and time of the key update that is related to the last run time of the application. Here, you can find not only programs running at the moment of memory dump creation but also programs that were launched earlier.</p>
			<p>Now, imagine that, in the list of running<a id="_idIndexMarker107"/> or recently completed processes, we have <strong class="source-inline">WINWORD.exe</strong> (such a process is created when you start MS Word):</p>
			<p class="figure-caption"> </p>
			<div>
				<div id="_idContainer036" class="IMG---Figure">
					<img src="Images/Figure_4.7_B17056.jpg" alt="Figure 4.7 – Active MS Word process&#13;&#10;" width="1643" height="930"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.7 – Active MS Word process</p>
			<p>What document was opened there? Can we get this information from memory? </p>
			<h1 id="_idParaDest-58"><a id="_idTextAnchor058"/>Searching for opened documents</h1>
			<p>In some cases, you may want to understand if any Microsoft Office files or just text files were opened by<a id="_idIndexMarker108"/> corresponding applications. Why? They may contain passwords or some data that's valuable from an investigative perspective. Volatility has several plugins that allow you to work with files in memory. For example, the <strong class="source-inline">filescan</strong> plugin allows you to get information about all the files that were encountered in the memory dump, and <strong class="source-inline">dumpfiles</strong> allows you to try to extract these files (remember that some files may be unloaded at the time the dump is created). So, how do we find a file<a id="_idIndexMarker109"/> that's been opened in MS Word?</p>
			<h2 id="_idParaDest-59"><a id="_idTextAnchor059"/>Documents in process memory</h2>
			<p>If we pay attention to the <strong class="bold">Process ID</strong> (<strong class="bold">PID</strong>) column, we will see<a id="_idIndexMarker110"/> that our WINWORD.exe process has an ID of 1592. We can use this ID with the <strong class="source-inline">-p</strong> option to run Volatility plugins<a id="_idIndexMarker111"/> only for this process. If we want to see what resources our process used, the <strong class="source-inline">handles</strong> plugin can help us. Let's use this with the <strong class="source-inline">-p</strong> option and the <strong class="source-inline">-t</strong> <strong class="source-inline">File</strong> option, which will help us display only those resources that are related to files.</p>
			<div>
				<div id="_idContainer037" class="IMG---Figure">
					<img src="Images/Figure_4.8_B17056.jpg" alt="Figure 4.8 – Volatility handles&#13;&#10;" width="1619" height="706"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.8 – Volatility handles</p>
			<p>In the preceding screenshot, we can see that our process resources mention a file called <strong class="source-inline">GOT-7_HR</strong>. Let's find the location of this file in memory. To do that, we need to run the <strong class="source-inline">filescan</strong> plugin and redirect its output to a text file, as shown here:</p>
			<p class="source-code">PS D:\&gt; .\volatility_2.6_win64_standalone.exe -f '.\user activity\Windows7x64.vmem' --profile Win7SP1x64 filescan &gt; D:\filescan.txt</p>
			<p>When the plugin finishes<a id="_idIndexMarker112"/> running, we can find a text file called <strong class="source-inline">filescan.txt</strong> that contains the following contents on the specified path:</p>
			<div>
				<div id="_idContainer038" class="IMG---Figure">
					<img src="Images/Figure_4.9_B17056.jpg" alt="Figure 4.9 – Volatility filescan output&#13;&#10;" width="1247" height="690"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.9 – Volatility filescan output</p>
			<p>Here, we can see the physical offset where the file was found, some related attributes, and the full path to the file on disk. Let's find our file:</p>
			<div>
				<div id="_idContainer039" class="IMG---Figure">
					<img src="Images/Figure_4.10_B17056.jpg" alt="Figure 4.10 – File offset&#13;&#10;" width="1247" height="690"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.10 – File offset</p>
			<p>We now know the physical<a id="_idIndexMarker113"/> offset of our file and can use the <strong class="source-inline">dumpfiles</strong> plugin to retrieve it from memory. Here, we will use the <strong class="source-inline">-Q</strong> option to specify the physical offset and the <strong class="source-inline">-D</strong> option for the path where we want to save our file.</p>
			<div>
				<div id="_idContainer040" class="IMG---Figure">
					<img src="Images/Figure_4.11_B17056.jpg" alt="Figure 4.11 – Volatility dumpfiles&#13;&#10;" width="1292" height="225"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.11 – Volatility dumpfiles</p>
			<p>As you can see, our file was detected at this offset. Now, there are two new files in our <strong class="source-inline">D:\user activity</strong> folder called<strong class="source-inline"> file.None.0xfffffa80282a6b80.vacb</strong> and <strong class="source-inline">file.None.0xfffffa80258625f0.dat</strong>. </p>
			<p>File data extensions identify the object that the data was extracted from:</p>
			<ul>
				<li><strong class="source-inline">dat</strong>: DataSectionObject </li>
				<li><strong class="source-inline">vacb</strong>: ImageSectionObject</li>
				<li><strong class="source-inline">img</strong>: SharedCacheMap</li>
			</ul>
			<p>These files are containers<a id="_idIndexMarker114"/> where the file's content and data are stored. To get the original file, try to rename the container with its extension. By doing this, you can open the extracted file with a suitable tool and continue to analyze it.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">If you export a file that you think is malicious, make sure that you do not run it on your work machine for analysis. It is better to work with such files in sandboxes or to process them with special tools, which we will discuss in the next chapter.</p>
			<p>With that, the files have been taken care of, but what about the processes related to browsers? </p>
			<h1 id="_idParaDest-60"><a id="_idTextAnchor060"/>Investigating browser history</h1>
			<p>Browsers can contain a lot of useful data. By analyzing<a id="_idIndexMarker115"/> the browser history, we can understand what sites the user visited, what search queries user performed, and what files were downloaded. Even if a private mode or a special browser (for example, <em class="italic">Tor Browser</em>) was used to surf the internet, we can still find useful information in memory. </p>
			<p>The following screenshot shows the output of the <strong class="source-inline">pslist</strong> plugin, where we can see several processes related to <em class="italic">Google Chrome</em>, <em class="italic">Mozilla Firefox</em>, and <em class="italic">Tor Browser</em>:</p>
			<div>
				<div id="_idContainer041" class="IMG---Figure">
					<img src="Images/Figure_4.12_B17056.jpg" alt="Figure 4.12 – Browser-related processes&#13;&#10;" width="1409" height="734"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.12 – Browser-related processes</p>
			<p>So, how do you get information<a id="_idIndexMarker116"/> about the visited resources? There are several ways to do this:</p>
			<ul>
				<li>Export the process memory<a id="_idIndexMarker117"/> and process it with the <strong class="source-inline">Strings</strong> utility (<a href="https://docs.microsoft.com/en-us/sysinternals/downloads/strings">https://docs.microsoft.com/en-us/sysinternals/downloads/strings</a>), which allows you to get the list of ASCII and Unicode symbols from various files.</li>
				<li>Export the process memory and process it with <strong class="source-inline">bulk_extractor </strong>(<a href="https://downloads.digitalcorpora.org/downloads/bulk_extractor/">https://downloads.digitalcorpora.org/downloads/bulk_extractor/</a>), which allows you to scan<a id="_idIndexMarker118"/> disk images, memory dumps, specific files, or directories and extract useful information.</li>
				<li>Search for URLs using regular expressions or YARA rules.</li>
			</ul>
			<p>We have three browsers and three options, so this looks like a good plan. Let's start with Google Chrome and the regular expression search.</p>
			<h2 id="_idParaDest-61"><a id="_idTextAnchor061"/>Chrome analysis with yarascan</h2>
			<p><strong class="source-inline">Yarascan</strong> is one of the Volatility<a id="_idIndexMarker119"/> plugins that allows you to search<a id="_idIndexMarker120"/> for some specific information<a id="_idIndexMarker121"/> using regular expressions or YARA rules. </p>
			<p class="callout-heading">Important note</p>
			<p class="callout">YARA<a id="_idIndexMarker122"/> was originally developed to help malware researchers with detecting and classifying malware samples. However, this tool is also applicable to memory forensics since it allows us to create search patterns<a id="_idIndexMarker123"/> using textual or binary data. For more information, see <a href="https://yara.readthedocs.io/en/v4.1.0/gettingstarted.html">https://yara.readthedocs.io/en/v4.1.0/gettingstarted.html</a>.</p>
			<p>To use <strong class="source-inline">yarascan</strong> with a YARA rule<a id="_idIndexMarker124"/> file, we need to provide a path to the <strong class="source-inline">.yar</strong> file with the <strong class="source-inline">-Y</strong> option. In our case, we will run it with the <strong class="source-inline">-y</strong> option and the <strong class="source-inline">/(https?:\/\/)?([\w\.-]+)([\/\w \.-]*)/</strong> regular expression. In addition, we will scan just one of the Chrome processes – the process with <strong class="source-inline">ID 4236</strong>, as shown here:</p>
			<div>
				<div id="_idContainer042" class="IMG---Figure">
					<img src="Images/Figure_4.13_B17056.jpg" alt="Figure 4.13 – Volatility yarascan&#13;&#10;" width="1301" height="847"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.13 – Volatility yarascan</p>
			<p>Here, you can see that we managed<a id="_idIndexMarker125"/> to find several links using this regular<a id="_idIndexMarker126"/> expression right away – these links are in the memory of the Google<a id="_idIndexMarker127"/> Chrome process with <strong class="source-inline">ID 4236</strong>.</p>
			<p>Now that we've looked at Chrome, let's move on to Firefox.</p>
			<h2 id="_idParaDest-62"><a id="_idTextAnchor062"/>Firefox analysis with bulk extractor</h2>
			<p>Bulk extractor is a command-line<a id="_idIndexMarker128"/> tool that allows you to search<a id="_idIndexMarker129"/> for some specific information, such as URLs, emails, and PDF files<a id="_idIndexMarker130"/> in different sources. There is also <strong class="bold">BEViewer</strong>, a graphical interface for bulk<a id="_idIndexMarker131"/> extractor, but it requires additional<a id="_idIndexMarker132"/> installation.</p>
			<p>Before using this tool, we need to dump the memory of the Firefox process. The <strong class="source-inline">memdump</strong> plugin is great for this as all we need to add is the <strong class="source-inline">-p</strong> option, along with the ID of the required process, and the <strong class="source-inline">-D</strong> option, along with the folder where we want to save the dump. In our case, the ID is <strong class="source-inline">6380</strong> and the path is <strong class="source-inline">.\user activity\firefox</strong>.</p>
			<p>When the plugin<a id="_idIndexMarker133"/> completes, a file with the process ID set<a id="_idIndexMarker134"/> to a name and the <strong class="source-inline">.dmp</strong> extension<a id="_idIndexMarker135"/> will appear in the specified directory.</p>
			<p>Now, we can launch our bulk extractor.</p>
			<div>
				<div id="_idContainer043" class="IMG---Figure">
					<img src="Images/Figure_4.14_B17056.jpg" alt="Figure 4.14 – Volatility memdump and bulk extractor&#13;&#10;" width="1392" height="818"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.14 – Volatility memdump and bulk extractor</p>
			<p>For bulk extractor, we used several options:</p>
			<ul>
				<li><strong class="source-inline">-o</strong>: Provides an output directory</li>
				<li><strong class="source-inline">-x all</strong>: Disables all scanners</li>
				<li><strong class="source-inline">-e email</strong>: Enables an email scanner that searches for emails and URLs</li>
			</ul>
			<p>In the end, we need to provide a path to the file that we want to analyze.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">To see all bulk extractor scanners available for use, simply run <strong class="source-inline">bulk_extractor.exe</strong> without adding any options.</p>
			<p>As a result, several files will appear in the specified directory: </p>
			<div>
				<div id="_idContainer044" class="IMG---Figure">
					<img src="Images/Figure_4.15_B17056.jpg" alt="Figure 4.15 – Bulk extractor's output&#13;&#10;" width="1086" height="678"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.15 – Bulk extractor's output</p>
			<p>In these files, we can find information<a id="_idIndexMarker136"/> about the emails and URLs that appeared<a id="_idIndexMarker137"/> in Firefox's memory. For<a id="_idIndexMarker138"/> instance, we can look into <strong class="source-inline">url_histogram.txt</strong>:</p>
			<div>
				<div id="_idContainer045" class="IMG---Figure">
					<img src="Images/Figure_4.16_B17056.jpg" alt="Figure 4.16 – URL histogram file's content&#13;&#10;" width="972" height="708"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.16 – URL histogram file's content</p>
			<p>Alternatively, we can check<a id="_idIndexMarker139"/> the searches that were made<a id="_idIndexMarker140"/> via the Firefox browser<a id="_idIndexMarker141"/> in the <strong class="source-inline">url_searches.txt</strong> file:</p>
			<div>
				<div id="_idContainer046" class="IMG---Figure">
					<img src="Images/Figure_4.17_B17056.jpg" alt="Figure 4.17 – URL searches&#13;&#10;" width="947" height="623"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.17 – URL searches</p>
			<p>From this, we can<a id="_idIndexMarker142"/> see that our user was searching<a id="_idIndexMarker143"/> for Tor Browser.</p>
			<p>Now that we've looked<a id="_idIndexMarker144"/> at Chrome and Firefox, it is time for the most fun part. Let's try to analyze the Tor process with the <strong class="source-inline">Strings</strong> utility.</p>
			<h2 id="_idParaDest-63"><a id="_idTextAnchor063"/>Tor analysis with Strings</h2>
			<p>Tor is a private browser<a id="_idIndexMarker145"/> that allows you to visit not only standard resources<a id="_idIndexMarker146"/> but also sites in the deep and dark webs, where<a id="_idIndexMarker147"/> some private and sometimes illegal sources are located. Hence, we just can't ignore this process.</p>
			<p>For analysis, we will use<a id="_idIndexMarker148"/> the <strong class="source-inline">Strings</strong> utility, which is part of <strong class="bold">Sysinternals Suite</strong> and can be used to search for different characters in files. When analyzing private browsers such as Tor, this utility is very useful. </p>
			<p>Before we start, we need to dump our Tor memory. We can use the previous technique to do so. Our <strong class="source-inline">tor.exe</strong> file has <strong class="source-inline">ID 4708</strong>, so we will use it with the <strong class="source-inline">-p</strong> option for the <strong class="source-inline">memdump</strong> plugin. Do not forget to add the <strong class="source-inline">-D</strong> option and provide a path to the location where you want to store the dump.</p>
			<p>After creating<a id="_idIndexMarker149"/> the dump, we can run the <strong class="source-inline">Strings</strong> utility. For this, we must<a id="_idIndexMarker150"/> pass the path to our process dump<a id="_idIndexMarker151"/> as an argument and redirect the output to a text file, as we did previously. As a result, we get the following output:</p>
			<div>
				<div id="_idContainer047" class="IMG---Figure">
					<img src="Images/Figure_4.18_B17056.jpg" alt="Figure 4.18 – Volatility memdump and the Strings utility&#13;&#10;" width="1295" height="206"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.18 – Volatility memdump and the Strings utility</p>
			<p>This option takes longer and the final file is harder to work with, but there is more data to find than with the standard URLs.</p>
			<p>We end up with a text file that looks like this:</p>
			<div>
				<div id="_idContainer048" class="IMG---Figure">
					<img src="Images/Figure_4.19_B17056.jpg" alt="Figure 4.19 – URLs in Tor memory&#13;&#10;" width="1088" height="583"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.19 – URLs in Tor memory</p>
			<p>We can also use regular expressions or the usual keyword search to quickly find information of interest.</p>
			<p>With that, we've looked at the history<a id="_idIndexMarker152"/> of browsers and even touched<a id="_idIndexMarker153"/> on the subject of email analysis. Now, let's take things<a id="_idIndexMarker154"/> further and take a closer look at emails and messengers.</p>
			<h1 id="_idParaDest-64"><a id="_idTextAnchor064"/>Examining communication applications</h1>
			<p>How often do you use communication<a id="_idIndexMarker155"/> apps to chat, send videos, or look at pictures of cute cats that have been sent to you? The answer is probably every day. Email and messengers have become an essential part of our lives, so we cannot avoid them. While examining the dump that's been taken from the victim's computer, we might come across a malicious document sent by email, and in the memory dump of the suspect's computer, we might find correspondence with accomplices.</p>
			<p>We have already talked about email, so we'll start there.</p>
			<h2 id="_idParaDest-65"><a id="_idTextAnchor065"/>Email, email, email </h2>
			<p>Nowadays, there are many<a id="_idIndexMarker156"/> different email agents, and some people prefer to use a browser<a id="_idIndexMarker157"/> to check their mail. Thus, we can reduce the analysis to the following:</p>
			<ul>
				<li>If, in the list of running processes, we see a process related to the email agent, we can check the resources being used by the <strong class="source-inline">handles</strong> plugin and look for files that might be in the attachment.</li>
				<li>Also, if there is an active email agent process, we can extract its memory with the <strong class="source-inline">memdump</strong> plugin and process the dump file with the <strong class="source-inline">Strings</strong> utility. This will allow us to search not only for filenames in attachments but also for fragments of the emails themselves.</li>
				<li>Run bulk extractor, as we did in the previous section, but now use it to analyze the entire memory dump. In this case, we will be able to collect information about all the emails and attachments, regardless of using an email agent or a browser. However, be careful as bulk extractor will take much longer to run than it did previously.</li>
			</ul>
			<p>Since all these methods<a id="_idIndexMarker158"/> have already been described in detail, we will take<a id="_idIndexMarker159"/> a look at just one of them: analysis with bulk extractor.</p>
			<p>Since we will now use the whole dump for searching, we do not need to extract the memory of individual processes. The command for this will look like this: </p>
			<div>
				<div id="_idContainer049" class="IMG---Figure">
					<img src="Images/Figure_4.20_B17056.jpg" alt="Figure 4.20 – Full memory dump analysis with bulk extractor&#13;&#10;" width="1265" height="510"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.20 – Full memory dump analysis with bulk extractor</p>
			<p>Now, we can check the <strong class="source-inline">email_histogram.txt</strong> file, which contains information about all the email addresses that appeared in memory:</p>
			<div>
				<div id="_idContainer050" class="IMG---Figure">
					<img src="Images/Figure_4.21_B17056.jpg" alt="Figure 4.21 – Email histogram&#13;&#10;" width="1088" height="713"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.21 – Email histogram</p>
			<p>We also can do a keyword<a id="_idIndexMarker160"/> search against the <strong class="source-inline">url_histogram.txt</strong> file to find information<a id="_idIndexMarker161"/> about mailboxes and attachments:</p>
			<p class="figure-caption"> </p>
			<div>
				<div id="_idContainer051" class="IMG---Figure">
					<img src="Images/Figure_4.22_B17056.jpg" alt="Figure 4.22 – Email attachment in the URL histogram&#13;&#10;" width="1249" height="544"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.22 – Email attachment in the URL histogram</p>
			<p>Everything seems<a id="_idIndexMarker162"/> to be clear regarding emails, but what about messengers? How can we look into conversations<a id="_idIndexMarker163"/> and find something useful in them?</p>
			<h2 id="_idParaDest-66"><a id="_idTextAnchor066"/>Instant messengers </h2>
			<p>When it comes<a id="_idIndexMarker164"/> to messengers, the easiest thing to use<a id="_idIndexMarker165"/> is a messenger memory analysis tool. Let's look at our list of processes again:</p>
			<div>
				<div id="_idContainer052" class="IMG---Figure">
					<img src="Images/Figure_4.23_B17056.jpg" alt="Figure 4.23 – List of active processes&#13;&#10;" width="1412" height="566"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.23 – List of active processes</p>
			<p>In the list of active processes, we can see a couple<a id="_idIndexMarker166"/> of well-known messengers, including <em class="italic">Telegram</em> and <em class="italic">Discord</em>. We can dump<a id="_idIndexMarker167"/> the memory of these processes and parse it with the <strong class="source-inline">Strings</strong> utility, as shown in the following screenshot:</p>
			<div>
				<div id="_idContainer053" class="IMG---Figure">
					<img src="Images/Figure_4.24_B17056.jpg" alt="Figure 4.24 – Telegram memory extraction and parsing&#13;&#10;" width="1399" height="212"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.24 – Telegram memory extraction and parsing</p>
			<p>In the output file, you can search for specific usernames, messages, URLs, or keywords:</p>
			<div>
				<div id="_idContainer054" class="IMG---Figure">
					<img src="Images/Figure_4.25_B17056.jpg" alt="Figure 4.25 – Message history in Telegram's memory&#13;&#10;" width="1226" height="658"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.25 – Message history in Telegram's memory</p>
			<p>This is how we can get some<a id="_idIndexMarker168"/> insights into the instant messengers' memory. By the way, some people can use messengers and chats<a id="_idIndexMarker169"/> with themselves to share their passwords between several devices, so you can check for the appearance of passwords as well.</p>
			<h1 id="_idParaDest-67"><a id="_idTextAnchor067"/>Recovering user passwords</h1>
			<p>Instant messengers are not<a id="_idIndexMarker170"/> the only location where we can search for passwords. We can find them in a cache, in the memory of text editors, buffers, command lines, or even some specific system processes. Volatility has several plugins to collect information about credentials:</p>
			<ul>
				<li><strong class="source-inline">hashdump</strong></li>
				<li><strong class="source-inline">lsadump</strong></li>
				<li><strong class="source-inline">cachedump</strong></li>
			</ul>
			<p>Let's check them out, one by one.</p>
			<h2 id="_idParaDest-68"><a id="_idTextAnchor068"/>Hashdump</h2>
			<p>The <strong class="source-inline">hashdump</strong> plugin can be used to dump<a id="_idIndexMarker171"/> hashes of local user passwords on Windows<a id="_idIndexMarker172"/> systems before Windows 8. The command will look like this:</p>
			<div>
				<div id="_idContainer055" class="IMG---Figure">
					<img src="Images/Figure_4.26_B17056.jpg" alt="Figure 4.26 – Volatility hashdump&#13;&#10;" width="1399" height="212"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.26 – Volatility hashdump</p>
			<p>In the output, you can see the account name, followed by the relative identifier and the LM and NT hashes. Notice that we have the same hashes for Administrator and Guest users. These specific hashes indicate blank passwords.</p>
			<p>Another way to dump credentials is to use the <strong class="source-inline">cachedump</strong> plugin.</p>
			<h2 id="_idParaDest-69"><a id="_idTextAnchor069"/>Cachedump</h2>
			<p>This plugin can be used to dump hashes<a id="_idIndexMarker173"/> of cached domain user passwords. By default, our system<a id="_idIndexMarker174"/> stores up to 10 of the most recent domain account credentials. We can try to access them with <strong class="source-inline">cachedump</strong>. Its execution is quite similar to that of <strong class="source-inline">hashdump</strong>:</p>
			<div>
				<div id="_idContainer056" class="IMG---Figure">
					<img src="Images/Figure_4.27_B17056.jpg" alt="Figure 4.27 – Volatility cachedump&#13;&#10;" width="1399" height="212"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.27 – Volatility cachedump</p>
			<p>Here, you can see the domain<a id="_idIndexMarker175"/> username, followed by the password hash<a id="_idIndexMarker176"/> and the domain itself.</p>
			<p>Another thing<a id="_idIndexMarker177"/> that we can do is search for <strong class="bold">Local Security Authority</strong> (<strong class="bold">LSA</strong>) information.</p>
			<h2 id="_idParaDest-70"><a id="_idTextAnchor070"/>Lsadump</h2>
			<p>The LSA subsystem service is responsible<a id="_idIndexMarker178"/> for user authentication, so its analysis can help us obtain some<a id="_idIndexMarker179"/> useful information. Look at the following example:</p>
			<div>
				<div id="_idContainer057" class="IMG---Figure">
					<img src="Images/Figure_4.28_B17056.jpg" alt="Figure 4.28 – Volatility lsadump&#13;&#10;" width="1399" height="920"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.28 – Volatility lsadump</p>
			<p>Here, we can see information from different resources and for some of them, we can identify plaintext passwords. Other locations where plaintext passwords can be found are in the memory<a id="_idIndexMarker180"/> of text editor processes or the command lines of some specific tools, such as <strong class="bold">PsExec</strong>. </p>
			<h2 id="_idParaDest-71"><a id="_idTextAnchor071"/>Plaintext passwords </h2>
			<p>Since we have already<a id="_idIndexMarker181"/> learned how to extract and analyze process<a id="_idIndexMarker182"/> memory, let's concentrate on the command line. Volatility has several plugins that allow us to retrieve command-line arguments. One such plugin is <strong class="source-inline">cmdline</strong>. It does not require any additional arguments:</p>
			<div>
				<div id="_idContainer058" class="IMG---Figure">
					<img src="Images/Figure_4.29_B17056.jpg" alt="Figure 4.29 – Volatility cmdline&#13;&#10;" width="1399" height="576"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.29 – Volatility cmdline</p>
			<p>From the very beginning, we can see information about the start of the system processes and the command lines that have been used for this purpose. In the case of running programs that require the password to be transmitted in clear text, we will be able to find something similar to the following:</p>
			<div>
				<div id="_idContainer059" class="IMG---Figure">
					<img src="Images/Figure_4.30_B17056.jpg" alt="Figure 4.30 – Plaintext password in the PsExec command line&#13;&#10;" width="1086" height="401"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.30 – Plaintext password in the PsExec command line</p>
			<p>In this case, we can see that PsExec has been used to connect remotely to the <strong class="bold">win7</strong> host and that the max user password<a id="_idIndexMarker183"/> has been transmitted in plaintext.</p>
			<p>Now, you have several<a id="_idIndexMarker184"/> ways to get the user's password information. But what about those who use encryption and crypto containers?</p>
			<h1 id="_idParaDest-72"><a id="_idTextAnchor072"/>Detecting crypto containers</h1>
			<p>There are several popular encryption tools for Windows: </p>
			<ul>
				<li>Bitlocker</li>
				<li>TrueCrypt </li>
				<li>VeraCrypt </li>
			</ul>
			<p>Although the implementation<a id="_idIndexMarker185"/> of these tools varies, they all serve the same purpose – to encrypt user data. For some, this may be an opportunity to keep their data private, while for others, it may be an opportunity for them to hide their illegitimate activity. For us, as investigators, it is important to understand that if the encrypted disk was used at the time of dumping, we may find cached volume passwords, master encryption keys, some parts of unencrypted files, or their exact location in memory.</p>
			<p>The first step of our investigation here is to identify if there are any encryption tools and what data was encrypted. Sometimes, we will be able to easily identify the tool from the list of running processes, as shown in the following screenshot: </p>
			<div>
				<div id="_idContainer060" class="IMG---Figure">
					<img src="Images/Figure_4.31_B17056.jpg" alt="Figure 4.31 – VeraCrypt process&#13;&#10;" width="1639" height="721"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.31 – VeraCrypt process</p>
			<p>Unfortunately, Volatility<a id="_idIndexMarker186"/> does not provide a lot of functionality to work with different encryption solutions, but it has a nice set of plugins<a id="_idIndexMarker187"/> for TrueCrypt:</p>
			<ul>
				<li><strong class="source-inline">truecryptmaster</strong> searches for encryption master keys.</li>
				<li><strong class="source-inline">truecryptpassphrase</strong> searches for the passphrase that was used.</li>
				<li><strong class="source-inline">truecryptsummary</strong> collects TrueCrypt-related information.</li>
			</ul>
			<p>The last plugin allows us to gather information about TrueCrypt processes, services, drivers, associated symbolic links, and file objects. </p>
			<div>
				<div id="_idContainer061" class="IMG---Figure">
					<img src="Images/Figure_4.32_B17056.jpg" alt="Figure 4.32 – Volatility TrueCrypt summary&#13;&#10;" width="1650" height="716"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.32 – Volatility TrueCrypt summary</p>
			<p>Here, we can see that<a id="_idIndexMarker188"/> one of the drives was encrypted with <strong class="bold">TrueCrypt</strong>, so we can try to extract<a id="_idIndexMarker189"/> the master key from memory:</p>
			<div>
				<div id="_idContainer062" class="IMG---Figure">
					<img src="Images/Figure_4.33_B17056.jpg" alt="Figure 4.33 – Volatility TrueCrypt master key&#13;&#10;" width="1260" height="370"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.33 – Volatility TrueCrypt master key</p>
			<p>By default, TrueCrypt and some other tools use AES for encryption. That is why an alternative way to get the encryption master key is to use any tool with AES detection functionality. We have already discussed such a tool: one of the bulk extractor scanners can be used for this purpose. Let's run aes scanner:</p>
			<div>
				<div id="_idContainer063" class="IMG---Figure">
					<img src="Images/Figure_4.34_B17056.jpg" alt="Figure 4.34 – Bulk extractor AES scanner&#13;&#10;" width="934" height="383"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.34 – Bulk extractor AES scanner</p>
			<p>As result, we will get<a id="_idIndexMarker190"/> a text file called <strong class="source-inline">aes_keys.txt</strong>. The content of this file looks as follows:</p>
			<div>
				<div id="_idContainer064" class="IMG---Figure">
					<img src="Images/Figure_4.35_B17056.jpg" alt="Figure 4.35 – Extracted AES keys&#13;&#10;" width="1419" height="549"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.35 – Extracted AES keys</p>
			<p>Here, we found several couples of <strong class="source-inline">AES256</strong> keys. By combining these couples of 256-bit keys, we can obtain our 512-bit master key.</p>
			<p>This process is not very easy, which is why some forensic software developers included key extraction functionality in their solutions.</p>
			<p>Passware<a id="_idIndexMarker191"/> is one of the most popular<a id="_idIndexMarker192"/> solutions to search for encrypted files, decrypt encrypted drives, and recover Windows passwords and passwords stored in Password Managers. This tool supports most of the solutions for full-disk encryption, including <strong class="bold">BitLocker</strong>, <strong class="bold">TrueCrypt</strong>, and <strong class="bold">PGP</strong>.</p>
			<div>
				<div id="_idContainer065" class="IMG---Figure">
					<img src="Images/Figure_4.36_B17056.jpg" alt="Figure 4.36 – Passware&#13;&#10;" width="1129" height="721"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.36 – Passware</p>
			<p>If you want to try this tool, you can request<a id="_idIndexMarker193"/> a demo version from their official web page: <a href="https://www.passware.com/kit-forensic/">https://www.passware.com/kit-forensic/</a>.</p>
			<p>We have already discussed<a id="_idIndexMarker194"/> how to find launched programs and opened documents, how to recover passwords, and how to detect encrypted drives. However, there is one important thing that was left behind – Windows Registry.</p>
			<h1 id="_idParaDest-73"><a id="_idTextAnchor073"/>Investigating Windows Registry</h1>
			<p>Information about the programs<a id="_idIndexMarker195"/> that are frequently run by the user, recently opened documents, outgoing RDP connections, and much more is written in the computer's registry, and we always have the most recent version of it in our memory. To avoid confusion, we need to understand how the registry works in Windows.</p>
			<h2 id="_idParaDest-74"><a id="_idTextAnchor074"/>Virtual registry </h2>
			<p>To work properly, your computer needs to store information about hardware and software configurations, data<a id="_idIndexMarker196"/> about all the system users, information<a id="_idIndexMarker197"/> about each user's settings, and much, much more. When our system starts up, it collects this information from the hardware and registry files stored in non-volatile memory and creates a virtual registry in memory. This virtual registry is where the current configurations are stored, and where all the changes that will be transferred to the files and written to disk will be stored in the first place. The process of interacting with the registry is ongoing, so we can always find the hives of the virtual registry and associated files in the memory dumps. </p>
			<p>Most of the time, we have to work with several files:</p>
			<ul>
				<li><strong class="source-inline">SAM</strong> contains information about groups and users, including their privileges, passwords, and last login date.</li>
				<li><strong class="source-inline">SYSTEM</strong> contains OS-related information such as the computer's name, services, connected USB devices, time zone information, and network adapter configuration.</li>
				<li><strong class="source-inline">SOFTWARE</strong> contains information about installed software, scheduled tasks, autorun, and application backward compatibility.</li>
				<li><strong class="source-inline">NTUSER.DAT</strong> contains information related to a particular user: last viewed documents, frequently run programs, explorer history, and outgoing RDP connections.</li>
			</ul>
			<p>Remember the <strong class="source-inline">userassist</strong> plugin? It takes information from the registry – to be more exact, from the <strong class="source-inline">NTUSER.DAT</strong> file. Both <strong class="source-inline">hashdump</strong> and <strong class="source-inline">cachedump</strong> also use the registry.</p>
			<p>Let's see how we can work with the registry files in memory.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">We are not going to cover the details of Windows Registry forensics as this topic requires in-depth studying. However, we will break down the main keys required for our purposes.</p>
			<p>Volatility provides several plugins for general work with the registry:</p>
			<ul>
				<li><strong class="source-inline">Printkey</strong> shows registry keys, their subkeys, and their values.</li>
				<li><strong class="source-inline">hivelist</strong> lists accessible registry hives.</li>
				<li><strong class="source-inline">dumpregistry</strong> allows us to extract registry files from memory.</li>
				<li>Several plugins also take out the values of certain keys:</li>
				<li><strong class="source-inline">userassist</strong></li>
				<li><strong class="source-inline">shutdowntime</strong></li>
				<li><strong class="source-inline">shellbags</strong></li>
			</ul>
			<p>All of these plugins display<a id="_idIndexMarker198"/> the values of the keys with the same name<a id="_idIndexMarker199"/> after launching them.</p>
			<p>However, working with the registry in this way is not always convenient. In addition, they are not adapted to work with newer versions of Windows 10. What should we do if we need to analyze a fresh build? There is an excellent<a id="_idIndexMarker200"/> tool that allows you to view physical memory as files in a virtual filesystem. It is called <strong class="bold">MemProcFS</strong>.</p>
			<h2 id="_idParaDest-75"><a id="_idTextAnchor075"/>Installing MemProcFS</h2>
			<p>Take a look at this link to learn about the installation process for MemProcFS: <a href="https://github.com/ufrisk/MemProcFS/blob/master/README.md">https://github.com/ufrisk/MemProcFS/blob/master/README.md</a>.</p>
			<p>This tool has several<a id="_idIndexMarker201"/> dependencies. First, you need<a id="_idIndexMarker202"/> to install <strong class="source-inline">LeechCore</strong>. To do so, you need to execute the following command in PowerShell:</p>
			<div>
				<div id="_idContainer066" class="IMG---Figure">
					<img src="Images/Figure_4.37_B17056.jpg" alt="Figure 4.37 – Installing LeechCore&#13;&#10;" width="847" height="167"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.37 – Installing LeechCore</p>
			<p>The next step<a id="_idIndexMarker203"/> is to install Microsoft Visual C++ Redistributables for Visual Studio 2019. You can get the installer from <a href="https://go.microsoft.com/fwlink/?LinkId=746572">https://go.microsoft.com/fwlink/?LinkId=746572</a>. Now, you must install <strong class="bold">Dokany</strong>: <a href="https://github.com/dokan-dev/dokany/releases/latest">https://github.com/dokan-dev/dokany/releases/latest</a>. Developers recommend<a id="_idIndexMarker204"/> that you download and install the <strong class="source-inline">DokanSetup_redist</strong> version. The last thing<a id="_idIndexMarker205"/> you need is <em class="italic">Python 3.6</em> or later. You can get a suitable version of Python<a id="_idIndexMarker206"/> from the official web page: <a href="https://www.python.org/downloads/windows/">https://www.python.org/downloads/windows/</a>. </p>
			<p>Congratulations – you are now ready to download MemProcFS! Go to the MemProcFS GitHub repository at <a href="https://github.com/ufrisk/MemProcFS">https://github.com/ufrisk/MemProcFS</a> and search for the latest releases.</p>
			<div>
				<div id="_idContainer067" class="IMG---Figure">
					<img src="Images/Figure_4.38_B17056.jpg" alt="Figure 4.38 – MemProcFS GitHub repository&#13;&#10;" width="1625" height="657"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.38 – MemProcFS GitHub repository</p>
			<p>Download the files_and_binaries ZIP archive and unzip it to a suitable location. To run <strong class="source-inline">MemProcFS</strong>, open PowerShell and move<a id="_idIndexMarker207"/> to the folder where you have<a id="_idIndexMarker208"/> unzipped the files. Run the following command to create a virtual filesystem from your memory dump (use the <strong class="source-inline">-device</strong> option to provide the location of your memory dump).</p>
			<div>
				<div id="_idContainer068" class="IMG---Figure">
					<img src="Images/Figure_4.39_B17056.jpg" alt="Figure 4.39 – MemProcFS execution &#13;&#10;" width="1076" height="435"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.39 – MemProcFS execution </p>
			<p>As you can see, our operating system<a id="_idIndexMarker209"/> was recognized and the dump was successfully mounted on the <strong class="source-inline">M:\</strong> drive. Now, we can open this drive<a id="_idIndexMarker210"/> via Explorer and search for something interesting.</p>
			<h2 id="_idParaDest-76"><a id="_idTextAnchor076"/>Working with Windows Registry</h2>
			<p>We decided<a id="_idIndexMarker211"/> to tell you about this tool for a reason. The point is that by using MemProcFS, you can easily extract all registry files from memory. (Honestly, you do not even need to extract anything.) Open your drive (in our case, it is the <strong class="source-inline">M:\</strong> drive) and go to <strong class="source-inline">registry</strong> &gt; <strong class="source-inline">hive_files</strong>, as shown in the following screenshot. Here, you will find all the registry files that are available in our dump.</p>
			<div>
				<div id="_idContainer069" class="IMG---Figure">
					<img src="Images/Figure_4.40_B17056.jpg" alt="Figure 4.40 – MemProcFS Hive files&#13;&#10;" width="1524" height="913"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.40 – MemProcFS Hive files</p>
			<p>So, we found the registry, but what should we do next? There are several options here. First, you can use <em class="italic">Eric Zimmerman's Registry Explorer </em>tool. The latest version can be downloaded from the official repository at <a href="https://ericzimmerman.github.io/#!index.md">https://ericzimmerman.github.io/#!index.md</a>. The archive that contains the tool must be unpacked with 7-Zip; otherwise, the tool will not work properly. Registry Explorer allows you to view various keys and values in their original form and use prepared bookmarks that contain useful information.</p>
			<div>
				<div id="_idContainer070" class="IMG---Figure">
					<img src="Images/Figure_4.41_B17056.jpg" alt="Figure 4.41 – Registry Explorer&#13;&#10;" width="1221" height="757"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.41 – Registry Explorer</p>
			<p>On the other hand, you can parse these files with <em class="italic">RegRipper</em>. By doing this, all the information will be available to you as a single text file. This tool can be downloaded from the following GitHub repository: <a href="https://github.com/keydet89/RegRipper3.0">https://github.com/keydet89/RegRipper3.0</a>. </p>
			<p>To run the GUI tool, you need<a id="_idIndexMarker212"/> to use the <strong class="source-inline">rr.exe</strong> file. In the window that appears, you need to specify the path to the file you want to process and the path to the text file where you want to save the result of the execution. Once all the fields have been filled in, you need to click the <strong class="bold">Rip!</strong> button. For example, let's take the file containing the name <strong class="source-inline">ntuser</strong> from our <strong class="source-inline">hive_files</strong> folder, copy it to a convenient location, and try to analyze it.</p>
			<div>
				<div id="_idContainer071" class="IMG---Figure">
					<img src="Images/Figure_4.42_B17056.jpg" alt="Figure 4.42 – RegRipper&#13;&#10;" width="607" height="516"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.42 – RegRipper</p>
			<p>As a result, you will get two<a id="_idIndexMarker213"/> text files. The first one, with the<strong class="source-inline">.log</strong> extension, is the log of the program. The second one, with the<strong class="source-inline">.txt</strong> extension, contains the parsing results. You can open it in any text editor and use a keyword search. For example, to find programs run by a user, you can search for <strong class="source-inline">userassist</strong>.</p>
			<div>
				<div id="_idContainer072" class="IMG---Figure">
					<img src="Images/Figure_4.43_B17056.jpg" alt="Figure 4.43 – Userassist registry key&#13;&#10;" width="1172" height="877"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.43 – Userassist registry key</p>
			<p>If you want to see what documents<a id="_idIndexMarker214"/> the user has recently worked with, look for <strong class="source-inline">opensave</strong> or <strong class="source-inline">recentdocs</strong>.</p>
			<div>
				<div id="_idContainer073" class="IMG---Figure">
					<img src="Images/Figure_4.44_B17056.jpg" alt="Figure 4.44 – RecentDocs registry key&#13;&#10;" width="1030" height="844"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.44 – RecentDocs registry key</p>
			<p>Finally, if you want to see what directories<a id="_idIndexMarker215"/> were visited by a user on a local or remote host, download <em class="italic">ShellbagsExplorer</em> from the respective GitHub repository (https://ericzimmerman.github.io/#!index.md). Find the <strong class="source-inline">usrclass</strong> registry file in the <strong class="source-inline">hive_files</strong> folder and drop it into the running tool. You should get the following output:</p>
			<div>
				<div id="_idContainer074" class="IMG---Figure">
					<img src="Images/Figure_4.45_B17056.jpg" alt="Figure 4.45 – ShellBags Explorer&#13;&#10;" width="908" height="515"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.45 – ShellBags Explorer</p>
			<p>Note that this file is derived<a id="_idIndexMarker216"/> from the memory dump, where we found traces of the S drive encrypted by TrueCrypt. Thanks to our analysis of the <strong class="source-inline">usrclass</strong> file, we can see some of the contents of the encrypted disk.</p>
			<h1 id="_idParaDest-77"><a id="_idTextAnchor077"/>Summary</h1>
			<p>Analyzing user activity is a very important part of investigating memory. In this chapter, you learned that you can recover a lot of artifacts. This can be extremely valuable in criminal investigations as such artifacts can help you reconstruct a user's activity, even if they used anonymous web browsers or secure messengers.</p>
			<p>Volatility is a great tool for memory dump analysis, but do not get hung up on it. Do not be afraid to use additional tools or alternative solutions in situations where you need to.</p>
			<p>Despite the abundance of information in process memory, do not forget about the virtual registry, which stores a lot of useful information, including that related to user activity. Additionally, some registry keys can tell us a lot about malware activity and persistence traces. We will discuss these and other traces of malicious activity in the next chapter.</p>
		</div>
	</div></body></html>