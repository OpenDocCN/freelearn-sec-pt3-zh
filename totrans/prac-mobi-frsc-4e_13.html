<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Android App Analysis, Malware, and Reverse Engineering</h1>
                </header>
            
            <article>
                
<p>Third-party applications are commonly used by smartphone users. Android users download and install several apps from app stores such as Google Play. During forensic investigations, it is often helpful to perform an analysis of these apps to retrieve valuable data and to detect any malware. For instance, a photo vault app might lock sensitive images present on a device. Hence, it would be of great significance to have the knowledge to identify the passcode for the photo vault app.</p>
<p>Also, apps such as Facebook, WhatsApp, Skype, and so on are widely used these days, and they are often the source of valuable data that aids in cracking a case. Hence, it is important to know what kind of data these apps store and the location of this data. While the data extraction and data recovery techniques we discussed in earlier chapters provide access to valuable data, app analysis helps us gain information about the specifics of an application, such as preferences and permissions.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Analyzing widely used Android apps to retrieve valuable data</li>
<li>Techniques to reverse engineer an Android application</li>
<li>Android malware</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Analyzing widely used Android apps to retrieve valuable data</h1>
                </header>
            
            <article>
                
<p>On Android, everything the user interacts with is an application. While some apps are preinstalled by the device manufacturer, others are downloaded and installed by the user. For example, even routine functions, such as contacts, calls, SMS, and so on, are performed through their respective apps. Thus, Android app analysis is crucial during the course of an investigation. Several third-party apps, such as WhatsApp, Facebook, Skype, Chrome browser, and so on, are used widely, and they handle a lot of valuable information. Depending on the type of application, most of these apps store sensitive information on the device's internal memory or SD card. Analyzing them may provide information about the location details of the user, their communication with others, and more. Using the forensic techniques we described earlier, it is possible to get access to the data stored by these applications. However, you, as a forensic examiner, need to develop the necessary skills to convert the available data into useful data. This is achieved when you have a comprehensive understanding of how the application handles data.</p>
<p>As we discussed in previous chapters, all applications store their data in the <kbd>/data/data</kbd> folder by default. Apps also store certain other data on the SD card, if they want to, by asking permission at the time of installation. Information about applications present on the device can be gathered by inspecting the contents of the <kbd>/data/data</kbd> folder, but this is not straightforward as it requires analyzing each individual app folder under this path. As an alternative, you can inspect the <kbd>packages.list</kbd> file present under <kbd>/data/system</kbd>. This file contains information about all the apps, along with their package names and data paths. </p>
<p>This can be performed using the following command:</p>
<pre><strong># cat packages.list</strong></pre>
<p>The following is the output of the preceding command:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1122 image-border" src="assets/07bd4eb4-20af-4cfc-9003-e3219e2aa2b2.png" style="width:32.75em;height:10.58em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Content of the packages.list file</div>
<p>Now, let's look specifically at some third-party apps that are widely used and handle valuable data.</p>
<div class="packt_infobox">The following apps are only being covered to make you familiar with the kind of data that can be extracted and the possible locations where the data can be obtained. You will <span>need to take appropriate permissions and should abide by the legal rules before performing these tasks on a device. As we explained in <a href="b1621e6e-80a3-495e-a288-c8db601149f8.xhtml" target="_blank">Chapter 8</a>, <em>Android Forensic Setup and Pre-Data Extraction Techniques</em>, the following techniques only work after the device has been rooted. </span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Facebook Android app analysis</h1>
                </header>
            
            <article>
                
<p>The Facebook Android app is one of the most widely used social networking applications. It stores its information in the <kbd>/data/data</kbd> folder, within the <kbd>com.facebook.katana</kbd> package. The following details provide an overview of the kind of information that can be gathered across various files:</p>
<ul>
<li><strong>Facebook contacts</strong>: Information about the user's Facebook contacts can be retrieved by analyzing the <kbd>contacts_db2</kbd> database, which is present under the following path:
<ul>
<li><strong>Path</strong>: <kbd>/data/data/com.facebook.katana/databases/contacts_db2</kbd>.</li>
<li>The <kbd>contacts_db2</kbd> database (SQLite file) contains a table named contacts, which contains most of the user's information, such as their first name, last name, display name, and URL for display picture.</li>
</ul>
</li>
</ul>
<ul>
<li><strong>Facebook notifications</strong>: Information about a user's notifications can be gathered by analyzing the <kbd>notification_db</kbd> database, which is present under the following path:
<ul>
<li><strong>Path</strong>: <kbd>/data/data/com.facebook.katana/databases/notifications_db</kbd>.</li>
<li>The <kbd>gql_notifications</kbd> table present under the preceding path holds the user's information. The <kbd>seen_state</kbd> column confirms whether a notification has been seen or not. The <kbd>updated</kbd> column points to the time when the notification was updated. The <kbd>gql_payload</kbd> column contains the notification and the sender information.</li>
</ul>
</li>
<li><strong>Facebook messages</strong>: A Facebook message conversation may be of crucial importance in several cases and can be viewed by analyzing the <kbd>threads_db2</kbd> database:
<ul>
<li><strong>Path</strong>: <kbd>/data/data/com.facebook.katana/databases/threads_db2</kbd></li>
</ul>
</li>
<li><strong>Videos from newsfeed</strong>: The <kbd>/video-cache</kbd> folder contains videos that have been downloaded from the user's newsfeed. Note that these are not the videos posted by the user, but rather they are the videos that appeared on their newsfeed:
<ul>
<li><strong>Path</strong>: <kbd>/data/data/com.facebook.katana/files/video-cache</kbd></li>
</ul>
</li>
<li><strong>Images from newsfeed</strong>: The <kbd>/images</kbd> folder contains various images that appear on the user's profile, such as the ones from their newsfeed and contact profile pictures. Several directories are present within this folder and images may be stored in formats other than <kbd>.jpg</kbd>, such as <kbd>.cnt</kbd>:</li>
<li><strong>Path</strong><span>:</span> <kbd>/data/data/com.facebook.katana/cache/images</kbd></li>
<li><strong>Newsfeed data</strong>: The <kbd>newfeed_db</kbd> database contains data shown to the user on their newsfeed. As shown in the following screenshot, analyzing this database would provide valuable information, such as when a particular story was loaded by the device (the <kbd>fetched_at</kbd> column), if a particular story was seen by the user (the <kbd>seen_state</kbd> column), and where the corresponding files of a story are stored on the device (the <kbd>cache_file_path</kbd> column):</li>
<li><strong>Path</strong>: <kbd>/data/data/com.facebook.katana/databases/newsfeed_db</kbd>:</li>
</ul>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1123 image-border" src="assets/49a0d2c5-1d9b-482f-afdc-45327787d546.png" style="width:67.58em;height:20.83em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>The Facebook newsfeed.db file analyzed in SQLite browser </span></div>
<p>In the preceding screenshot, <kbd>fetched_at</kbd> specifies the date and time when this information is fetched. Notice that the app uses Linux epoch time, also known as Unix time or Posix time, to store this information. This format is often used by multiple apps and, hence, is worth taking a look at. Linux epoch time is stored as the number of seconds (or milliseconds) since midnight on January 1, 1970. There are several online sites, such as <a href="https://www.epochconverter.com/" target="_blank"><span class="URLPACKT">https://www.epochconverter.com/</span></a>, that can readily convert the Linux epoch time into a normal format. For example, the following screenshot shows Linux epoch time 1,577,881,839 converted into a normal format:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/7072a6d0-d3ec-4498-a617-cd9faa509832.png" style="width:35.00em;height:12.42em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Example of time format</div>
<p>Now that we have performed an analysis of the Facebook app, let's perform a similar analysis with our next application, which is WhatsApp.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">WhatsApp Android app analysis</h1>
                </header>
            
            <article>
                
<p>WhatsApp is the most popular chat (audio and video) messaging service and is used by more than a billion people across the globe. It stores <span><span>its </span></span>information under the <kbd>/data/data</kbd> folder, with the package name, <kbd>com.whatsapp</kbd>. The following is an overview of the important files that are of interest from a forensic perspective:</p>
<ul>
<li><strong>User's profile pic</strong>: The user's profile picture is saved with the<kbd>me.jpg</kbd> filename and is present under the following path:
<ul>
<li><strong>Path</strong>: <kbd>/data/data/com.whatsapp/me.jpg</kbd></li>
</ul>
</li>
<li><strong>User's phone number (associated with WhatsApp)</strong>: The <kbd>me</kbd> file that's present under the main folder contains the phone number that is associated with the user's WhatsApp account. Note that this may or may not be the phone number that is associated with the SIM:
<ul>
<li><strong>Path</strong>: <kbd>/data/data/com.whatsapp/me</kbd></li>
</ul>
</li>
<li><strong>Contacts profile pic</strong>: The <kbd>/avatars</kbd> directory contains thumbnails of the profile pictures of the user's contacts (who use WhatsApp):
<ul>
<li><strong>Path</strong>: <kbd>/data/data/com.whatsapp/files/Avatars</kbd></li>
</ul>
</li>
<li><strong>Chat messages</strong>: All message-related information, including chats and sender details, is present in the <kbd>msgstore.db</kbd> file, which is present at the following location:
<ul>
<li><strong>Path</strong>: <kbd>/data/data/com.whatsapp/databases/msgstore.db</kbd></li>
</ul>
</li>
<li><strong>WhatsApp files</strong>: Most of the files shared with WhatsApp, such as images, videos, and audio messages, are stored on the SD card in the following location:
<ul>
<li><strong>Path</strong>: <kbd>/sdcard/WhatsApp/Media</kbd></li>
</ul>
</li>
</ul>
<p>Both sent and received files are stored separately here in their respective folder names.</p>
<p>Next, we will look at another application that is used for telecommunication and specializes in providing video chat and voice calls: Skype.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Skype Android app analysis</h1>
                </header>
            
            <article>
                
<p>Skype is an app that offers video chat and voice call services. The application's data is stored under the <kbd>/data/data</kbd> folder, with the package name <kbd>com.skype.raider</kbd>. The following are some important artifacts that can be extracted by analyzing the Skype app:</p>
<ul>
<li><strong>Username and IP address</strong>: The <kbd>shared.xml</kbd> file present under the following path contains information about the username and the last IP address that connected to Skype:
<ul>
<li><strong>Path</strong>: <kbd>/data/data/com.skype.raider/files/shared.xml</kbd></li>
</ul>
</li>
<li><strong>Profile picture</strong>: The user's profile picture is present in the <kbd>/thumbnails</kbd> directory, whose path is as follows:
<ul>
<li><strong>Path</strong>: <kbd>/data/data/com.skype.raider/files/&lt;username&gt;/thumbnails/</kbd></li>
</ul>
</li>
<li><strong>Call logs</strong>: Information about call logs made from Skype is available in the <kbd>main.db</kbd> file. Analyzing this file gives us a lot of information:
<ul>
<li><strong>Path</strong>: <kbd>/data/data/com.skype.raider/files/&lt;username&gt;/main.db/</kbd>.</li>
<li>For example, the <kbd>duration</kbd> table provides information about call duration, the <kbd>start_timestamp</kbd> field gives the start time of a call, and the <kbd>creation_timestamp</kbd> field indicates when the call is initiated (this includes unanswered calls). The <kbd>type</kbd> column indicates whether the call was incoming (value= <kbd>1</kbd>) or outgoing (value= <kbd>2</kbd>).</li>
</ul>
</li>
<li><strong>Chat messages</strong>: The <kbd>messages</kbd> table present in the <kbd>main.db</kbd> file contains all the chat messages. The <kbd>author</kbd> and <kbd>from_dispname</kbd> columns provide information about who wrote the message. The <kbd>timestamp</kbd> column shows the date/time of the message. The <kbd>body_xml</kbd> column contains the content of the message:
<ul>
<li><strong>Path</strong>: <kbd>/data/data/com.skype.raider/files/&lt;username&gt;/main.db/</kbd></li>
</ul>
</li>
</ul>
<ul>
<li><strong>Files transferred</strong>: The <kbd>Transfers</kbd> table contains information about transferred files, such as the filename, the size of the file, and their location on the device:
<ul>
<li><strong>Path</strong>: <kbd>/data/data/com.skype.raider/files/&lt;username&gt;/main.db/</kbd>.</li>
<li>The actual images or files that are received will be stored on an SD card. If a file is downloaded, it will be in the <kbd>Downloads</kbd> folder in the root of the SD.</li>
</ul>
</li>
<li><strong>Group chats</strong>: The <kbd>ChatMembers</kbd> table shows a list of users who are present in a particular chat. The <kbd>adder</kbd> column shows the user who initiated the conversation:
<ul>
<li><strong>Path</strong>: <kbd>/data/data/com.skype.raider/files/&lt;username&gt;/main.db/</kbd></li>
</ul>
</li>
</ul>
<p>Now, we will perform an analysis on the Gmail application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Gmail Android app analysis</h1>
                </header>
            
            <article>
                
<p>Gmail is a widely used email service offered by Google. The application data is saved under the <kbd>/data/data</kbd> folder, with the package name <kbd>com.google.android.gm</kbd>. The following are the important artifacts that can be extracted by analyzing the Gmail app:</p>
<ul>
<li><strong>Account details</strong>: The XML files present under <kbd>/shared_prefs</kbd> confirm the email account details. Details of other accounts, which are linked to the current email, can be identified from the <kbd>Gmail.xml</kbd> file:
<ul>
<li><strong>Path</strong>: <kbd>/data/data/com.google.android.gm/cache/&lt;username&gt;@gmail.com</kbd></li>
</ul>
</li>
<li><strong>Attachments</strong>: Attachments that are recently used in both sending and receiving emails are saved to the <kbd>/cache</kbd> directory. This is valuable because it gives us access to items that have been deleted from the email service too. Each row also contains a <kbd>messages_conversation</kbd> value. This value can be compared with the <kbd>conversations</kbd> table of the email attachment. The <kbd>filename</kbd> column identifies the path on the device where the file is located. The following is the exact path for this folder:
<ul>
<li><strong>Path</strong>: <kbd>/data/data/com.google.android.gm/cache/&lt;username&gt;@gmail.com</kbd>:</li>
</ul>
</li>
</ul>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1124 image-border" src="assets/66d5e627-1946-46c8-a729-16cad9ba6c46.png" style="width:46.50em;height:14.75em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">List of attachments present under Gmail's cache directory</div>
<ul>
<li><strong>Email subject</strong>: The subject of this email can be recovered by analyzing the <kbd>conversations</kbd> table present in the <kbd>mailstore.&lt;username&gt;@gmail.com.db</kbd> file:
<ul>
<li><strong>Path</strong>: <kbd>/data/data/com.google.android.gm/databases/mailstore.&lt;username&gt;@gmail.com.db</kbd></li>
</ul>
</li>
<li><strong>Search history</strong>: Any text searches that were made within the app are stored in the <kbd>suggestions.db</kbd> file, which is present at the following location:
<ul>
<li><strong>Path</strong>: <kbd>/data/data/com.google.android.gm/databases/suggestions.db</kbd></li>
</ul>
</li>
</ul>
<p>Let's wrap up this section by performing a final analysis on the Google Chrome application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Google Chrome Android app analysis</h1>
                </header>
            
            <article>
                
<p>Google Chrome is the default web browser on <span><span>Google Pixel </span></span>and many other devices, and it is used widely to browse the internet. The application data is present under the <kbd>/data/data</kbd> folder, with the package name, <kbd>com.android.chrome</kbd>. The following are the important artifacts that can be extracted by analyzing the Gmail app:</p>
<ul>
<li><strong>Profile picture</strong>: The profile picture of the user is stored with the <kbd>Google Profile Picture.png</kbd> filename in the following location:
<ul>
<li><strong>Path</strong>: <kbd>/data/data/com.android.chrome/app_chrome/Default/ Google Profile Picture.png</kbd></li>
</ul>
</li>
</ul>
<ul>
<li><strong>Bookmarks</strong>: The <kbd>Bookmarks</kbd> file contains information about all the bookmarks synced with the account. Details such as the site name, URL, and the time when it was bookmarked can be gathered by analyzing this file:
<ul>
<li><strong>Path</strong>: <kbd>/data/data/com.android.chrome/app_chrome/Default/Bookmarks</kbd></li>
</ul>
</li>
<li><strong>Browsing history</strong>: The <kbd>History.db</kbd> file contains the user's web history stored in various tables. For example, as shown in the following screenshot, the <kbd>keyword_search_terms</kbd> table contains information about the searches that were made using the Chrome browser:</li>
</ul>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1125 image-border" src="assets/6a6bb125-9825-4ca7-bfd8-aef1fa43939f.png" style="width:28.08em;height:20.42em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Google Chrome browsing history</div>
<ul>
<li style="list-style-type: none">
<ul>
<li>The <kbd>segments</kbd> table contains a list of sites visited by the user (but not all of the sites). It's interesting to note that Chrome stores the data belonging to not just the device, but the account in general. In other words, information about sites that have been visited from other devices using the same account is also stored on the device; for example, the <kbd>URLs</kbd> table contains the browsing history for a Google account across several devices.</li>
<li><strong>Path</strong>: <kbd>/data/data/com.android.chrome/app_chrome/Default/History</kbd>.</li>
</ul>
</li>
</ul>
<ul>
<li><strong>Login Data</strong>: The <kbd>Login Data</kbd> database contains the login information of different sites saved in the browser. The site URL, along with the username and password, is stored in the respective tables:
<ul>
<li><strong>Path</strong>: <kbd>/data/data/com.android.chrome/app_chrome/Default/Login Data</kbd></li>
</ul>
</li>
<li><strong>Frequently visited sites</strong>: The <kbd>Top Sites</kbd> database contains a list of frequently visited sites:
<ul>
<li><strong>Path</strong>: <kbd>/data/data/com.android.chrome/app_chrome/Default/Top Sites</kbd></li>
</ul>
</li>
</ul>
<ul>
<li><strong>Other data</strong>: Other information, such as the phone numbers or email addresses entered by the user during form fills across different sites, is stored in the <kbd>Web Data</kbd> database. Any tables that are present within this database contain autofill data:
<ul>
<li><strong>Path</strong>: <kbd>/data/data/com.android.chrome/app_chrome/Default/Web Data</kbd></li>
</ul>
</li>
</ul>
<p>Now that we have analyzed the different third-party apps, we will look at the techniques we can use to reverse engineer Android apps.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Techniques to reverse engineer an Android application</h1>
                </header>
            
            <article>
                
<p>You may need to deal with applications that stand as a barrier to accessing the required information. For instance, take the case of the gallery on a phone that is locked by an <em>AppLock</em> application. In this case, in order to access the pictures and videos stored in the gallery, you first need to enter the passcode to the <em>AppLock</em>. Hence, it would be interesting to know how the <em>AppLock</em> app stores the password on the device. You might look into the SQLite database files. However, if they are encrypted, then it's hard to even tell that it's a password. Reverse engineering applications would be helpful in such cases where you want to better understand the application and how the application stores the data.</p>
<p>To state it in simple terms, reverse engineering is the process of retrieving source code from an executable. Reverse engineering an Android app is done in order to understand the functionality of the app, the data storage, the security mechanisms in place, and more. Before we proceed to learn how to reverse engineer an Android app, here is a quick recap of the Android apps:</p>
<ul>
<li>All the applications that are installed on the Android device are written in the Java programming language.</li>
<li>When a Java program is compiled, we get bytecode. This is sent to a dex compiler, which converts it into Dalvik bytecode.</li>
<li>Thus, the class files are converted into dex files using a dx tool. Android uses something called <strong>Dalvik virtual machine</strong> (<strong>DVM</strong>) to run its applications.</li>
<li>JVM's bytecode consists of one or more class files, depending on the number of Java files that are present in an application. Regardless, a Dalvik bytecode is composed of only one dex file.</li>
</ul>
<p>Thus, the dex files, XML files, and other resources that are required to run an application are packaged into an Android package file (an APK file). These APK files are simply collections of items within ZIP files. Therefore, if you rename an APK extension file to a <kbd>.zip</kbd> file, then you will be able to see the contents of the file. However, before you can do this, you need to get access to the APK file of the application that is installed on the phone. Here is how the APK file corresponding to an application can be accessed.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Extracting an APK file from an Android device</h1>
                </header>
            
            <article>
                
<p>Apps that come preinstalled with the phone are stored in the <kbd>/system/app</kbd> directory. Third-party applications that are downloaded by the user are stored in the <kbd>/data/app</kbd> folder. The following method helps you gain access to the APK files on the device; it works on both rooted and non-rooted devices:</p>
<ol>
<li>Identify the package name of the app by issuing the <kbd><span># adb.exe shell pm list packages</span></kbd> command.</li>
</ol>
<p style="padding-left: 60px">The following is the output of the preceding command:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/845bd1f9-74f7-4b82-96ec-9abb26ac9bd4.png" style="width:32.50em;height:19.42em;"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">List of package names present on the device</div>
<p style="padding-left: 60px">As shown in the preceding command-line output, the list of package names is displayed. Try to find a match between the app in question and the package name. Usually, the package names are very much related to the app names. Alternatively, you can use the Android Market or Google Play to identify the package name easily. The URL for an app in Google Play contains the package name, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/5d24586a-85b6-47b0-a70f-58aa01a2ddf1.png" style="width:38.42em;height:20.75em;"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Facebook App in the Google Play Store</div>
<ol start="2">
<li>Identify the full pathname of the APK file for the desired package by issuing the <kbd>adb shell pm path</kbd> command, as follows:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/7de67300-77f9-4d01-8d4e-a4856a021b23.png" style="width:43.58em;height:3.33em;"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Identifying full pathname of APK</div>
<ol start="3">
<li>Pull the APK file from the Android device to the forensic workstation using the <kbd>adb pull</kbd> command:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/62c3987d-21df-4837-a593-eccc2d453207.png" style="width:60.75em;height:3.50em;"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">adp pull command</div>
<p>Now, let's analyze the contents of an APK file. An Android package is a container for an Android app's resources and executables. It's a zipped file that contains the following files:</p>
<ul>
<li><kbd>AndroidManifest.xml</kbd>: This contains information about the permissions and more.</li>
<li><kbd>classes.dex</kbd>: This is the class file that's been converted into a dex file by the dex compiler.</li>
<li><kbd>Res</kbd>: The application's resources, such as the image files, sound files, and more, are present in this directory.</li>
<li><kbd>Lib</kbd>: This contains native libraries that the application may use.</li>
<li><kbd>META-INF</kbd>: This contains information about the application's signature and signed checksums for all the other files in the package.</li>
</ul>
<p>Once the APK file has been obtained, you can proceed to reverse engineer the Android application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Steps to reverse engineer Android apps</h1>
                </header>
            
            <article>
                
<p>APK files can be reverse-engineered in different ways to get the original code. The following is one method that uses the <kbd>dex2jar</kbd> and JD-GUI tools to gain access to the application code. For our example, we will examine the <kbd>com.twitter.android-1.apk</kbd> file. The following are the steps to successfully reverse engineer the APK file:</p>
<ol>
<li>Rename the APK extension to ZIP to see the contents of the file. Rename the <kbd>com.twitter.android-1.apk</kbd> file to <kbd>twitter.android-1.zip</kbd> and extract the contents of this file using any file archiver application. The following screenshot shows the files that were extracted from the original file, <kbd>twitter.android-1.zip</kbd>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/d6a4ff00-b5ed-41df-902e-4c9c3984a9b9.png" style="width:42.33em;height:16.42em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Extracted files of an APK file</div>
<ol start="2">
<li>The <kbd>classes.dex</kbd> file that we discussed previously can be accessed after extracting the contents of the APK file. This dex file needs to be converted into a class file in Java. This can be done using the <kbd>dex2jar</kbd> tool.</li>
<li>Download the <kbd>dex2jar</kbd> tool from <a href="https://github.com/pxb1988/dex2jar" target="_blank"><span class="URLPACKT">https://github.com/pxb1988/dex2jar</span></a>, drop the <kbd>classes.dex</kbd> file into the <kbd>dex2jar</kbd> tools directory, and issue the following command:</li>
</ol>
<pre style="padding-left: 60px"><strong>C:\Users\Rohit\Desktop\Training\Android\dex2jar-0.0.9.15&gt;d2j- dex2jar.bat classes.dex</strong> <strong>dex2jar classes.dex -&gt; classes-dex2jar.jar</strong></pre>
<ol start="4">
<li>When the preceding command is successfully run, it creates a new <kbd>classes -dex2jar.jar</kbd> file in the same directory, as shown in the following screenshot:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/306e7996-4fdd-40e4-b5c3-91e85a53d654.png" style="width:41.08em;height:15.42em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">The classes-dex2jar.jar file created by the dex2jar tool</div>
<ol start="5">
<li>To view the contents of this JAR file, you can use a tool such as JD-GUI. As shown in the following screenshot, the files present in an Android application and the corresponding code can be seen:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/5c1a2e05-7b7f-49d4-b819-626efaf2a5e1.png" style="width:49.33em;height:26.58em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">The JD-GUI tool</div>
<p>Once we get access to the code, it is easy to analyze how the application stores the values, permissions, and more information that may be helpful to bypass certain restrictions. When malware is found on a device, this method to decompile and analyze the application may prove useful, as it will show what is being accessed by the malware and provide clues to where the data is being sent. The following sections focus on Android malware in detail.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Android malware</h1>
                </header>
            
            <article>
                
<p>As Android's market share continues to increase, so do attacks or malware targeted at Android users. Mobile malware is a broad term that refers to a piece of software that performs unintended actions and includes Trojans, spyware, adware, ransomware, and others. According to pandasecurity, Android devices are 50 times more infected with malware compared to iOS devices (<a href="https://www.pandasecurity.com/mediacenter/mobile-security/android-more-infected-than-ios/" target="_blank">https://www.pandasecurity.com/mediacenter/mobile-security/android-more-infected-than-ios/</a>). In 2019, the famous Agent Smith malware alone infected almost 25 million Android devices, as per a Cybersecurity Hub news report (<a href="https://www.cshub.com/malware/articles/incident-of-the-week-malware-infects-25m-android-phones">https://www.cshub.com/malware/articles/incident-of-the-week-malware-infects-25m-android-phones</a>). </p>
<p>One of the primary reasons for this situation is that, unlike Apple's App Store, which is tightly controlled by the company, Google's Play Store is an open ecosystem without any detailed upfront security reviews. Malware developers can easily move their apps to the Play Store and thereby distribute their apps. Google now has a malware-detecting software named Google Bouncer, which will automatically scan an uploaded app for malware, but attackers have figured out several ways to remain undetected. Moreover, Android officially allows us to load apps that have been downloaded over the internet (side-loading), unlike iOS, which does not allow unsigned apps.</p>
<p>For example, as shown in the following screenshot, when the <span class="packt_screen">Unknown sources</span> option is selected on an Android device, it allows the user to install apps that have been downloaded from any site over the internet:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1126 image-border" src="assets/a0adb506-9287-4311-9910-5cc3ef4bb143.png" style="width:28.25em;height:35.33em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Side-loading option in Android</div>
<p>The third-party app stores that host Android apps are known to be hubs of malware. This prompted Google to roll out the <em>Verify Apps</em> feature starting from Android 4.2, which scans apps locally on Android devices to look for malicious activities, such as SMS abuse. As shown in the following screenshot, the Verify apps feature may warn the user, or in some cases may even block the installation. However, this is an opt-in service, so users can disable this feature if they wish to:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1127 image-border" src="assets/c7b30de6-5536-4636-9e17-8c16bff545e3.png" style="width:43.50em;height:28.00em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Verify apps feature in Android</div>
<p>Starting with Android Oreo, Google has rolled out a new feature called Play Protect, which is a better version of the verifying apps feature. The primary job of Play Protect is to block or warn the users of malicious or harmful apps that have been installed on the Android device. For example, as shown in the following screenshot, the Play Protect feature may show a warning message during the app's installation:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/17406d6b-4d5c-42a7-87a4-8c35c6f35eff.png" style="width:22.08em;height:25.42em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Play Protect feature</div>
<p>Next, let's have a look at the types of malware.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Types of Android malware</h1>
                </header>
            
            <article>
                
<p>There are different kinds of malware types that can infect an Android device. The following are some of the most common ones:</p>
<ul>
<li> <strong>Banking malware</strong>: It can be distributed as fake banking applications to steal banking credentials typed by the users, or steal any other sensitive personal information from the user's account. Banking Trojans can intercept or modify banking transactions and perform dangerous actions such as sending, deleting, and intercepting SMS messages, as well as keylogging.</li>
</ul>
<ul>
<li><strong>Spyware</strong>: <span>Spyware monitors, logs, and sends important information from the target device to the attacker's server. This</span> <span>information</span><span> might comprise SMS messages, recorded phone calls, screenshots, keylogs, emails, or any other application data that may be of interest to the attacker. BusyGasper, a spyware identified by Kaspersky Lab experts in early 2018, not only possesses common spyware capabilities, such as collecting information from popular messаging applications, such as WhatsApp, Viber, and Facebook, but it also has device sensor listeners, including motion detectors.</span></li>
<li><strong>Adware</strong>: Adware is another popular malicious or unwanted application type that is very common on Android devices. It is relatively easy to detect, as the victim will receive continuous popups and ads on their device's screen. Such unwanted programs are not always harmless, since popups may result in downloading another piece of malware, including the types already mentioned <span>– </span>spyware and banking Trojans.</li>
<li><strong>Ransomware</strong>: The main targets of ransomware are Windows-based desktop computers and servers, but it also exists on mobile platforms, and on Android in particular. Usually, it only locks the device screen with a ransom note, but sometimes it encrypts users' data as well. </li>
<li><strong>Crypto-mining malware</strong>: <span>Cryptocurrencies are extremely popular nowadays</span>, so this type of malicious program is <span>available even for mobile platforms, such as Android. The goal of such applications is to mine cryptocurrency,</span> <span>using a victim's device computation capacity.</span><span> Occasionally, this type of malware can even </span><span>put smartphone hardware at risk.</span></li>
</ul>
<p>Advanced malware is also capable of rooting the device and installing new apps. For example, the Android Mazar malware, which was discovered in Feb 2016, spreads via text messages and is capable of gaining administrator rights on phones, allowing it to wipe handsets, make calls, or read texts.</p>
<div class="packt_infobox">A full list of Android malware families and their capabilities is available at <a href="https://forensics.spreitzenbarth.de/android-malware/" target="_blank"><span class="URLPACKT">https://forensics.spreitzenbarth.de/android-malware/</span></a>.</div>
<p>Once malware gets into a device, it can perform dangerous actions, some of which are as follows:</p>
<ul>
<li>Send and read your text messages</li>
<li>Steal sensitive data, such as pictures, videos, and credit card numbers</li>
<li>Manipulate files or data present on the device</li>
<li>Send SMS to a premium-rated number</li>
</ul>
<ul>
<li>Infect your browser and steal any data typed into its <span class="packt_screen">Change device</span><span> </span>settings</li>
<li>Wipe all data present on the device</li>
<li>Lock the device until a ransom is paid</li>
<li>Display advertisements continuously</li>
</ul>
<p>Now that we have understood the different types of malware, we will see how the malware spreads in your device.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How does Android malware spread?</h1>
                </header>
            
            <article>
                
<p>An Android device can be infected with malware in several different ways. The following are some of the possible ways:</p>
<ul>
<li><strong>Repackaging legitimate application</strong>: This is the most common method used by attackers. First, the attacker downloads a legitimate application and disassembles it. Then, they add their malicious code and reassemble the application. The new malicious application now functions exactly as the legitimate application does, but it also performs malicious activity in the background. This kind of application is commonly found in third-party Android app stores and is downloaded by many people.</li>
<li><strong>Exploiting Android vulnerabilities</strong>: In this scenario, an attacker exploits the bugs or the vulnerabilities that are discovered in the Android platform to install their malicious application or to perform any unwanted actions. For example, installer hijacking, which was identified in 2015, has been exploited by attackers to replace an Android application with malware during installation.</li>
<li><strong>Bluetooth and MMS propagation</strong>: Malware is also spread via Bluetooth and MMS. The victim receives the malware when the device is in discoverable mode, for example, when it can be seen by other Bluetooth-enabled devices. In the case of MMS, the malware is attached to the message, just like how computer viruses are sent through email attachments. However, in both these methods, the user has to agree, at least once, to run the file.</li>
<li><strong>App downloading a malicious update</strong>: In this case, the app that was originally installed does not contain any malicious code, but a function present within the code will download malicious commands at runtime. This can be done via a stealthy update or user update. For example, the Plankton malware uses stealthy updates that directly download a JAR file from a remote server and do not need any user permission. In the case of user updates, the user has to allow the app to download the new version of the app.</li>
</ul>
<ul>
<li><strong>Remote install</strong>: The attacker may compromise the credentials of the user's account on the device and thereby remotely install apps on the device. This generally happens in targeted scenarios and is less frequent compared to the previous two methods we just described.</li>
</ul>
<p>Now that we've looked at the possible ways in which the Android malware can spread, let's try to identify the presence of malware in your device.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Identifying Android malware</h1>
                </header>
            
            <article>
                
<p>From a forensic perspective, it's important to identify the presence of any malware on the device prior to performing any analysis. This is because malware can alter the state of the device or contents on the device, thereby making the analysis or the results inconsistent. There are tools available on the market that can analyze the physical extraction to identify malware. For example, Cellebrite UFED Physical Analyzer has BitDefender's anti-malware technology, which scans for malware. As shown in the following screenshot, once the physical image has been loaded into the tool, the file can be scanned for malware:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1128 image-border" src="assets/64f84e23-3bfc-40eb-bd46-20a7f256645f.png" style="width:39.33em;height:24.58em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Scanning for malware in UFED Physical Analyzer</div>
<p>Once the scan starts, the BitDefender software tries to unpack the <kbd>.apk</kbd> files and looks for infected or malicious files. This process is automatic and the tool points to the malicious apps, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1129 image-border" src="assets/9b4514e2-3949-4b28-b3b1-abc4cb275bc7.png" style="width:47.75em;height:18.42em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Malware scanner results in UFED Physical Analyzer</div>
<p>The tool simply points out that something malicious is present on the device. The forensic investigator has to then manually confirm whether this is a valid issue by analyzing the respective application. This is where the reverse engineering skills that we discussed in the previous sections need to be leveraged. Once the application has been reverse-engineered and the code has been obtained, it is recommended that you take a look at the <kbd>AndroidManifest.xml</kbd> file to find out the app permissions. This will be helpful for understanding where the app stores the data, what resources it is trying to access, and more. For example, a Flashlight application does not need read/write access to your SD card data, or to make a phone call:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1130 image-border" src="assets/516bfec6-8b29-482e-b80e-3e834b262e12.png" style="width:40.00em;height:34.08em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Permissions in the AndroidManifest.xml file</div>
<p>Alternatively, you can also upload the <kbd>.apk</kbd> file to VirusTotal, a free service that can be used to analyze suspicious files for malware. VirusTotal will scan your file against 55 antivirus engines. It's also important to note that the tool may not identify a valid case if the details are obfuscated in the <kbd>.apk</kbd> file. Hence, as a forensic investigator, it's important to develop the necessary skills to reverse engineer any suspicious apps and analyze the code to identify malicious behavior.</p>
<p>In some investigations, the nature of the malware that is present on a device may also result in arriving at certain crucial conclusions, which may affect the outcome of the case. For example, consider an internal investigation in a corporation that involves sending abusive messages to other employees. Identifying malware on the device that sends the messages would help solve the case.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>Android app analysis helps a forensic investigator look for valuable data in relevant locations on a device. Reverse engineering Android apps is the process of retrieving source code from an APK file. Using certain tools, such as <kbd>dex2jar</kbd>, Android apps can be reverse-engineered in order to understand their functionality and data storage, identify malware, and more. In this chapter, we performed analysis on different android applications and we are now able to retrieve data from them. We also learned about different types of Android malware and how to identify them. Tools such as UFED Physical Analyzer come with BitDefender software, which can automatically scan for malware.</p>
<p>The next chapter covers performing forensics on Windows Phone devices.</p>


            </article>

            
        </section>
    </body></html>