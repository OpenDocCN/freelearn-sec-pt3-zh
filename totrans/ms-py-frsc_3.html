<html><head></head><body><div class="chapter" title="Chapter&#xA0;3.&#xA0;Using Python for Windows and Linux Forensics"><div class="titlepage"><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Using Python for Windows and Linux Forensics</h1></div></div></div><p>In this chapter, we will focus on the parts of the forensic investigation that are specific to the operating systems. We chose the most widely used operating systems on the desktop and server systems—Microsoft Windows and Linux.</p><p>For both operating systems, we selected examples of interesting evidence and how to automate its analysis using Python. Consequently, in this chapter, you will learn the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Analyzing the foundations of the Windows event log, selecting interesting parts, and automatically parsing them</li><li class="listitem" style="list-style-type: disc">Organizing<a id="id111" class="indexterm"/> the Windows Registry and efficiently searching for <span class="strong"><strong>Indicators of Compromise</strong></span> (<span class="strong"><strong>IOC</strong></span>)</li><li class="listitem" style="list-style-type: disc">Searching Linux local account information for IOC</li><li class="listitem" style="list-style-type: disc">Understanding, using, and parsing Linux file metadata with POSIX ACL and file based capabilities as the most prominent extensions to the standard metadata</li></ul></div><div class="section" title="Analyzing the Windows Event Log"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec15"/>Analyzing the Windows Event Log</h1></div></div></div><p>Windows includes<a id="id112" class="indexterm"/> many monitoring and logging capabilities and traces data and events for a large amount and variety of activities occurring in the operating system. The vast number of events, which can be logged, does neither make it easy for an administrator to identify the specific important events nor helps a forensic investigator to find Indicators of Compromise. Therefore, we will start this section with a small introduction to the Windows Event Log and the changes in its format over time, followed by a description of the important event types that should help an investigator to quickly find suspicious actions in the large amount of other events. In the last section of this chapter, we will demonstrate how to parse the Event Log and automatically <a id="id113" class="indexterm"/>find the potential IOCs (e.g., user logons, service creation, and so on).</p><div class="section" title="The Windows Event Log"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec19"/>The Windows Event Log</h2></div></div></div><p>According to<a id="id114" class="indexterm"/> Microsoft, Windows Event Log files are special files that record significant events, such as when a user logs on to the computer or when a program encounters an error, (refer to <a class="ulink" href="http://windows.microsoft.com/en-us/windows/what-information-event-logs-event-viewer#1TC=windows-7">http://windows.microsoft.com/en-us/windows/what-information-event-logs-event-viewer#1TC=windows-7</a>). Whenever these types of events occur, Windows records the event in an event log that can be read using Event Viewer or similar tools.</p><p>With the release of Windows 7 and Windows Server 2008, Microsoft has performed a major change<a id="id115" class="indexterm"/> in their Event Log technique. They changed from the classical <span class="strong"><strong>Windows Event Log</strong></span> (<span class="strong"><strong>EVT</strong></span>) to the newer <span class="strong"><strong>Windows XML Event Log</strong></span> (<span class="strong"><strong>EVTX</strong></span>). In<a id="id116" class="indexterm"/> the following paragraphs, we will explain some of the main differences between these two log file types.</p><p>Due to the fact that Microsoft no longer supports Windows XP and Server 2003 is in the extended support stage at present (meaning that it will go out of support very soon), there are XP and 2003 systems still out there. Thus, some investigators are still going to need to know the difference between the older EVT and the new EVTX and the possible problems arising during analysis of these files.</p><p>Besides the binary differences in the records and the Event Log files themselves, the amount of these log<a id="id117" class="indexterm"/> files differs too. On a Windows XP/2003 system, there were three main Event Log files: <span class="strong"><strong>System</strong></span>, <span class="strong"><strong>Application</strong></span>, and <span class="strong"><strong>Security</strong></span>. They are stored in the <code class="literal">C:\Windows\system32\config</code> directory. The server versions of the OS may maintain additional Event Logs (DNS Server, Directory Service, File Replication Service, and so on) depending upon the functionality of the server. On a current Windows 7 system, you can find more than 143 files full of event logs. This gets even more if you compare it to the newer server versions of Microsoft Windows.</p><p>The EVT log records only contain a very small amount of human-readable content and are made human readable through tools such as the event viewer at analysis time. These tools combine the predefined log templates that are commonly stored in the system's DLL or EXE files with the data stored in the EVT file itself. When one of the various log viewing tools displays log records, it has to determine which DLL files will store the message templates. This meta-information is stored in the Windows Registry and is specific to each type of the previously mentioned three main Event Log files (System, Application, and Security).</p><p>All of the earlier mentioned details follow the fact that the EVT files aren't really useful without their corresponding metafiles, which store the core meaning of the log. This creates two major analysis problems:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">First, an attacker could modify DLL files or the Windows Registry in order to change the meaning of event logs without having to touch the EVT file.</li><li class="listitem" style="list-style-type: disc">Second, when the software is uninstalled on a system, it could result in the EVT records losing their context.</li></ul></div><p>As an investigator, one must carefully keep these issues in mind when analyzing EVT logs and also when writing those logs to remote systems for later analysis. An even more detailed analysis<a id="id118" class="indexterm"/> of the EVT records can be found in the ForensicsWiki, <a class="ulink" href="http://forensicswiki.org/wiki/Windows_Event_Log_(EVT)">http://forensicswiki.org/wiki/Windows_Event_Log_(EVT)</a>.</p><p>In comparison to EVT, the EVTX files are stored as a binary XML file format. On the newer<a id="id119" class="indexterm"/> Windows systems, the event logs can be viewed and analyzed with either the Event Viewer or a vast number of other programs and tools (in the following sections, we will describe some Python scripts that can be used too). When using the Event Viewer, one has to bear in mind that this program can represent the EVTX files in two different formats: <span class="strong"><strong>general</strong></span> and <span class="strong"><strong>detailed</strong></span>. The general (sometimes called formatted) view can hide significant event data that is stored in the event record and can only be seen in the detailed view. Thus, if you are planning to use the Event Viewer for analyzing the EVTX files, always use the detailed option to display the files.</p><p>If you are interested in a more detailed analysis of the EVTX file format, you should take a look at the ForensicsWiki, <a class="ulink" href="http://forensicswiki.org/wiki/Windows_XML_Event_Log_(EVTX)">http://forensicswiki.org/wiki/Windows_XML_Event_Log_(EVTX)</a>. Another great explanation of the deeper EVTX file format details has been presented by <span class="emphasis"><em>Andreas Schuster</em></span> at DFRWS 2007, refer to <a class="ulink" href="http://www.dfrws.org/2007/proceedings/p65-schuster_pres.pdf">http://www.dfrws.org/2007/proceedings/p65-schuster_pres.pdf</a>. This presentation can be very helpful if you want to understand the details of the binary XML format or write your own parsers of EVTX files.</p><p>If you need to open the EVT files on a Windows 7 or newer system, it's best to convert the older EVT file to the EVTX syntax before opening it. This can be done in several ways as described in a technet.com blog post, <a class="ulink" href="http://blogs.technet.com/b/askperf/archive/2007/10/12/windows-vista-and-exported-event-log-files.aspx">http://blogs.technet.com/b/askperf/archive/2007/10/12/windows-vista-and-exported-event-log-files.aspx</a>.</p></div><div class="section" title="Interesting Events"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec20"/>Interesting Events</h2></div></div></div><p>A full list of Windows events on the newer system can be found in a knowledge base article of Microsoft at, <a class="ulink" href="https://support.microsoft.com/en-us/kb/947226">https://support.microsoft.com/en-us/kb/947226</a>. As the number of these<a id="id120" class="indexterm"/> events is getting bigger with every new version of the system and every newly installed application, you can easily find more than several hundreds of different event types on a single Windows system. Due to this fact, we tried to sort out some interesting event types that can be helpful when analyzing a system or reconstructing user events (a more detailed explanation of which Event Logs can be <a id="id121" class="indexterm"/>helpful under what conditions can also be found in TSA-13-1004-SG, <a class="ulink" href="https://www.nsa.gov/ia/_files/app/spotting_the_adversary_with_windows_event_log_monitoring.pdf">https://www.nsa.gov/ia/_files/app/spotting_the_adversary_with_windows_event_log_monitoring.pdf</a>):</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>EMET (1, 2)</strong></span>: If the organization is actively using the Microsoft <span class="strong"><strong>Enhanced Mitigation Experience Toolkit</strong></span> (<span class="strong"><strong>EMET</strong></span>), then these logs can be very helpful during investigation.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Windows-Update-Failure (20, 24, 25, 31, 34, 35)</strong></span>: The failure to update issues should be addressed to avoid prolonging the existence of an application issue or vulnerability in the operating system or an application. Sometimes, this also helps in identifying infections of a system.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Microsoft-Windows-Eventlog (104, 1102)</strong></span>: It is unlikely that event log data would be cleared during normal operations and it is more likely that a malicious attacker may try to cover their tracks by clearing an event log. When an event log gets cleared, it is suspicious.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Microsoft-Windows-TaskScheduler (106)</strong></span>: It displays newly registered Scheduled Tasks. This can be very helpful if you are searching for signs of malware infections.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>McAfee-Log-Event (257)</strong></span>: McAfee malware detection—McAfee AntiVirus may detect malware behaviors without actually detecting the EXE file itself. This can be very valuable in determining how the malware got into a system. In general, the event logs of the installed AV solution are very valuable logs when starting an analysis of a potentially compromised system. Therefore, you should remind yourself where to find those logs in the Event Log.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Microsoft-Windows-DNS-Client (1014)</strong></span>: DNS name resolution timeout; this event type can also be very helpful when searching for malware or when trying to find out whether a user has tried to connect to a specific website or service.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Firewall-Rule-Add/Change/Delete (2004, 2005, 2006, 2033)</strong></span>: If the client workstations are taking advantage of the built-in host-based Windows Firewall, then there is value in collecting events to track the firewall status. Normal users should not be modifying the firewall rules of their local machine.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Microsoft-Windows-Windows Defender (3004)</strong></span>: Windows Defender malware detection logs.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Microsoft-Windows-Security-Auditing (4720, 4724, 4725, 4728, 4732, 4635, 4740, 4748, 4756)</strong></span>: In these logs, you can find information such as remote desktop logins and users that have been added to privileged groups, and account lockouts can also be tracked. User accounts that are being promoted to the privileged groups should be audited very closely to ensure that the users are, in fact, supposed to be in a privileged group. Unauthorized membership of the privileged groups is a strong indicator that a malicious activity has occurred.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Service-Control-Manager (7030, 7045)</strong></span>: It monitors whether a service is configured to interact with the desktop or has been installed on the system in general.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>App-Locker-Block/Warning (8003, 8004, 8006, 8007)</strong></span>: Application whitelisting events should be collected to look for the applications that have been blocked from execution. Any blocked application could be malware or the users trying to run an unapproved software.</li></ul></div><p>
<span class="emphasis"><em>Harlan Carvey</em></span> stated in <a id="id122" class="indexterm"/>one of his blog posts (<a class="ulink" href="http://windowsir.blogspot.de/2014/10/windows-event-logs.html">http://windowsir.blogspot.de/2014/10/windows-event-logs.html</a>) that beyond individual event records (source/ID pairs), one of the aspects of the newer versions of Windows (in particular, Windows 7) is that there are a lot of events that are being recorded by default across multiple Event Log files. Thus, when some events occur, multiple event records are stored in different Event Log types and often across different Event Log files. For example, when a user logs in to a system on the console, there will be an event recorded in the security event log, a couple of events will be recorded in the <code class="literal">Microsoft-Windows-TerminalServices-LocalSessionManager/Operational</code> log, and a couple of events will also be recorded in the <code class="literal">Microsoft-Windows-TaskScheduler/Operational</code> log.</p><p>The Event Log can also be used to detect whether an attacker has used some kind of anti-forensic techniques. One of those techniques would be to change the system time in order to mislead an investigator. To detect this kind of modification, an investigator has to list all the available Event Log records by the sequence number and generated time. If the system time has been rolled back, there would be a point where the time an event has been generated was before the previous event. Some more examples of detecting anti-forensic techniques with the help of Windows Event Log can be found in a blog post by <span class="emphasis"><em>Harlan Carvey</em></span>, at <a class="ulink" href="http://windowsir.blogspot.de/2013/07/howto-determinedetect-use-of-anti.html">http://windowsir.blogspot.de/2013/07/howto-determinedetect-use-of-anti.html</a>.</p></div><div class="section" title="Parsing the Event Log for IOC"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec21"/>Parsing the Event Log for IOC</h2></div></div></div><p>When talking<a id="id123" class="indexterm"/> about Event Logs and analyzing<a id="id124" class="indexterm"/> these logs with Python, there is no way to get around <span class="strong"><strong>python-evtx</strong></span>. These scripts (<a class="ulink" href="https://github.com/williballenthin/python-evtx">https://github.com/williballenthin/python-evtx</a>) have been developed using the 2.7+ tags of the <a id="id125" class="indexterm"/>Python programming language. As it is purely Python, the module works equally well across the platforms. The code does not depend on any modules that require separate compilation and operates on the event log files from the Windows operating systems that are newer than Windows Vista that is EVTX.</p><p>The second tool that we<a id="id126" class="indexterm"/> want to bring to your attention is <span class="strong"><strong>plaso</strong></span>, (refer to <a class="ulink" href="http://plaso.kiddaland.net/">http://plaso.kiddaland.net/</a>). This tool set has evolved from <span class="strong"><strong>log2timeline</strong></span> and is now build in Python. With the help of this tool set, you can create meaningful timelines of the system events and other log files (for example, Apache). There is also a very good cheat sheet, <a class="ulink" href="http://digital-forensics.sans.org/media/log2timeline_cheatsheet.pdf">http://digital-forensics.sans.org/media/log2timeline_cheatsheet.pdf</a>, for log2timeline that demonstrates the real power of this tool. One of the big advantages of this tool set is the fact that you can even run it on a full image of a system to generate a timeline of all actions that the users performed on that system before creating the image.</p><p>In the<a id="id127" class="indexterm"/> following sections, we will show some examples <a id="id128" class="indexterm"/>of how to use python-evtx to find IOC in the Windows Event Log and how plaso will help you identify more IOCs and display them in a nicely formatted timeline.</p><div class="section" title="The python-evtx parser"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec03"/>The python-evtx parser</h3></div></div></div><p>First of all, we <a id="id129" class="indexterm"/>want to start with a basic conversion <a id="id130" class="indexterm"/>of the binary XML format of EVTX files to the readable XML files. This can be done using <code class="literal">evtxdump.py</code>, <a class="ulink" href="https://github.com/williballenthin/python-evtx">https://github.com/williballenthin/python-evtx</a>, which will also be the basis of our following scripts:</p><div class="informalexample"><pre class="programlisting">#!/usr/bin/env python
import mmap
import contextlib
import argparse

from Evtx.Evtx import FileHeader
from Evtx.Views import evtx_file_xml_view

def main():
    parser = argparse.ArgumentParser(description="Dump a binary EVTX file into XML.")
    parser.add_argument("--cleanup", action="store_true", help="Cleanup unused XML entities (slower)"),
    parser.add_argument("evtx", type=str, help="Path to the Windows EVTX event log file")
    args = parser.parse_args()

    with open(args.evtx, 'r') as f:
        with contextlib.closing(mmap.mmap(f.fileno(), 0, access=mmap.ACCESS_READ)) as buf:

            fh = FileHeader(buf, 0x0)
            print "&lt;?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\" ?&gt;"
            print "&lt;Events&gt;"
            for xml, record in evtx_file_xml_view(fh):
                print xml
            print "&lt;/Events&gt;"

if __name__ == "__main__":
    main()</pre></div><p>When <a id="id131" class="indexterm"/>dumping a logon event (event id 4724) with the help of the <a id="id132" class="indexterm"/>previously mentioned script, the result will look similar to the following:</p><div class="informalexample"><pre class="programlisting">&lt;Event &gt;&lt;System&gt;&lt;Provider Name="Microsoft-Windows-Security-Auditing" Guid="54849625-5478-4994-a5ba-3e3b0328c30d"&gt;&lt;/Provider&gt;
<span class="strong"><strong>&lt;EventID Qualifiers=""&gt;4724&lt;/EventID&gt;</strong></span>
&lt;Version&gt;0&lt;/Version&gt;
&lt;Level&gt;0&lt;/Level&gt;
&lt;Task&gt;13824&lt;/Task&gt;
&lt;Opcode&gt;0&lt;/Opcode&gt;
&lt;Keywords&gt;0x8020000000000000&lt;/Keywords&gt;
<span class="strong"><strong>&lt;TimeCreated SystemTime="2013-11-21 10:40:51.552799"&gt;&lt;/TimeCreated&gt;</strong></span>
&lt;EventRecordID&gt;115&lt;/EventRecordID&gt;
&lt;Correlation ActivityID="" RelatedActivityID=""&gt;&lt;/Correlation&gt;
&lt;Execution ProcessID="452" ThreadID="1776"&gt;&lt;/Execution&gt;
&lt;Channel&gt;Security&lt;/Channel&gt;
&lt;Computer&gt;windows&lt;/Computer&gt;
&lt;Security UserID=""&gt;&lt;/Security&gt;
&lt;/System&gt;
<span class="strong"><strong>&lt;EventData&gt;&lt;Data Name="TargetUserName"&gt;mspreitz&lt;/Data&gt;</strong></span>
&lt;Data Name="TargetDomainName"&gt;windows&lt;/Data&gt;
&lt;Data Name="TargetSid"&gt;S-1-5-21-3147386740-1191307685-1965871575-1000&lt;/Data&gt;
&lt;Data Name="SubjectUserSid"&gt;S-1-5-18&lt;/Data&gt;
&lt;Data Name="SubjectUserName"&gt;WIN-PC9VCSAQB0H$&lt;/Data&gt;
&lt;Data Name="SubjectDomainName"&gt;WORKGROUP&lt;/Data&gt;
&lt;Data Name="SubjectLogonId"&gt;0x00000000000003e7&lt;/Data&gt;
&lt;/EventData&gt;
&lt;/Event&gt;</pre></div><p>When using <code class="literal">evtxdump.py</code>, <a class="ulink" href="https://github.com/williballenthin/python-evtx">https://github.com/williballenthin/python-evtx</a>, with a large Windows<a id="id133" class="indexterm"/> Event Log file, the output will be very large as you will find all the recorded logs in the generated XML file. For an analyst, it is often important to perform a fast triage or<a id="id134" class="indexterm"/> search for specific events quickly. Due to this, we<a id="id135" class="indexterm"/> modify the script in a way that it is possible to extract only specific events, as shown in the following:</p><div class="informalexample"><pre class="programlisting">#!/usr/bin/env python
import mmap
import contextlib
import argparse
from xml.dom import minidom

from Evtx.Evtx import FileHeader
from Evtx.Views import evtx_file_xml_view

def main():
    parser = argparse.ArgumentParser(description="Dump specific event ids from a binary EVTX file into XML.")
    parser.add_argument("--cleanup", action="store_true", help="Cleanup unused XML entities (slower)"),
    parser.add_argument("evtx", type=str, help="Path to the Windows EVTX event log file")
    parser.add_argument("out", type=str, help="Path and name of the output file")
    parser.add_argument("--eventID", type=int, help="Event id that should be extracted")
    args = parser.parse_args()

    outFile = open(args.out, 'a+')
    with open(args.evtx, 'r') as f:
        with contextlib.closing(mmap.mmap(f.fileno(), 0, access=mmap.ACCESS_READ)) as buf:
            fh = FileHeader(buf, 0x0)
            outFile.write("&lt;?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\" ?&gt;")
            outFile.write("&lt;Events&gt;")
            for xml, record in evtx_file_xml_view(fh):
                xmldoc = minidom.parseString(xml)
                event_id = xmldoc.getElementsByTagName('EventID')[0].childNodes[0].nodeValue
                if event_id == str(args.eventID):
                    outFile.write(xml)
                else:
                    continue
            outFile.write("&lt;/Events&gt;")

if __name__ == "__main__":
    main()</pre></div><p>If you now want to extract all logon events from the security event log of a Windows system in a<a id="id136" class="indexterm"/> given XML file, you just have to execute the<a id="id137" class="indexterm"/> script as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user@lab:~$ ./evtxdump.py security.evtx logon_events.xml –eventID 4724</strong></span>
</pre></div></div><div class="section" title="The plaso and log2timeline tools"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec04"/>The plaso and log2timeline tools</h3></div></div></div><p>In this section, we <a id="id138" class="indexterm"/>will demonstrate how to find logon and logoff events on a <a id="id139" class="indexterm"/>Terminal Server. The Terminal Services logon and logoff events can<a id="id140" class="indexterm"/> be tagged using <code class="literal">plasm</code> and filtered<a id="id141" class="indexterm"/> using <code class="literal">psort</code> to get a quick overview of which users have been logging in to a machine and when and where from. This information can be very helpful when searching for compromises. To start with plaso<span class="strong"><strong>,</strong></span> you first need to tag all your data. Tagging with plaso is as easy as shown in the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user@lab:~$ ./plasm.py tag --tagfile=tag_windows.txt storage_file</strong></span>
</pre></div><p>After successful tagging, you can search the storage file for tags with the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user@lab:~$ ./psort.py storage_file "tag contains 'Session logon succeeded'"</strong></span>
</pre></div><p>The result of this command execution will show you all the successful logon events on a given system. Similar commands can be executed when searching for the services that are started or EMET failures.</p><p>Now, that you have seen the kind of data that you are able to extract from Windows Event Log, we will show you a second component of Microsoft Windows that is really helpful when searching for IOC or when trying to reconstruct the user behavior.</p></div></div></div></div>
<div class="section" title="Analyzing the Windows Registry"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec16"/>Analyzing the Windows Registry</h1></div></div></div><p>The Windows Registry <a id="id142" class="indexterm"/>is one of the essential components of the current Microsoft Windows operating systems and thus also a very important point in a forensic investigation. It performs two critical tasks for the Windows operating system. First, it is the repository of settings for the Windows operating system and the applications that are installed on the system. Second, it is the database of the configuration of all installed hardware. Microsoft defines the registry as follows:</p><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>"A central hierarchical database used in Microsoft Windows 98, Windows CE, Windows NT, and Windows 2000 used to store information that is necessary to configure the system for one or more users, applications and hardware devices." (Microsoft Computer Dictionary)</em></span></p></blockquote></div><p>In the following<a id="id143" class="indexterm"/> sections, we will explain several elements of the Windows Registry that may be important to a forensics investigator and that help in understanding where to find the most valuable indicators. We will start with an overview of the structure to help you find your way through the large amount of data in the registry. Afterwards, we will demonstrate some helpful scripts to extract indicators of compromise (IOC).</p><div class="section" title="Windows Registry Structure"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec22"/>Windows Registry Structure</h2></div></div></div><p>In the Windows <a id="id144" class="indexterm"/>operating system, the Windows Registry is organized logically in a number of root keys. There are five logical root keys in the Windows Registry of a Windows 7 system, as shown in the following:</p><div class="mediaobject"><img src="graphics/2087_03_01.jpg" alt="Windows Registry Structure"/></div><p>The previous figure shows the five root keys of the Registry in a Windows 7 system that are displayed by the Windows Registry Editor (one of the most common tools to view and examine the Windows Registry).</p><p>There are two kinds of root keys: volatile and nonvolatile. There are only two root keys that are stored on the hard disk of the system and are nonvolatile data held in the main memory: <span class="strong"><strong>HKEY_LOCAL_MACHINE</strong></span> and <span class="strong"><strong>HKEY_USERS</strong></span>. The other root keys are either the subsets of these keys or are the volatile keys that can only be examined during the runtime or when dumping the memory of a system before starting the analysis of its image.</p><p>The Windows operating system organizes the Registry in a number of hive files. According to Microsoft, (refer to <a class="ulink" href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms724877%28v=vs.85%29.aspx">https://msdn.microsoft.com/en-us/library/windows/desktop/ms724877%28v=vs.85%29.aspx</a>), the hive is defined as follows:</p><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>A hive is a logical group of keys, sub keys, and values in the registry that has a set of supporting files containing backups of its data.</em></span></p></blockquote></div><p>If a new user logs on a Windows machine, a User Profile Hive is created. This hive contains specific registry information (for example, application settings, desktop environment, network connections, and printers) and is located in the <span class="strong"><strong>HKEY_USERS</strong></span> key.</p><p>Each hive has <a id="id145" class="indexterm"/>additional supporting files that are stored in the <code class="literal">%SystemRoot%\System32\Config</code> directory. These files are updated each time a user logs on and the filename extensions of the files in these directories indicate the type of data that they contain. Refer to the following table for more details (reference taken from <a class="ulink" href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms724877%28v=vs.85%29.aspx">https://msdn.microsoft.com/en-us/library/windows/desktop/ms724877%28v=vs.85%29.aspx</a>):</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Extension</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>none</p>
</td><td style="text-align: left" valign="top">
<p>A complete copy of the hive data.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">.alt</code>
</p>
</td><td style="text-align: left" valign="top">
<p>A backup copy of the critical <code class="literal">HKEY_LOCAL_MACHINE\System</code> hive. Only the System key has an <code class="literal">.alt</code> file.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">.log</code>
</p>
</td><td style="text-align: left" valign="top">
<p>A transaction log of changes to the keys and value entries in the hive.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">.sav</code>
</p>
</td><td style="text-align: left" valign="top">
<p>A backup copy of a hive.</p>
</td></tr></tbody></table></div><p>In the following section, we will discuss where to find interesting hives and how to analyze them with the help of the Python tools.</p></div><div class="section" title="Parsing the Registry for IOC"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec23"/>Parsing the Registry for IOC</h2></div></div></div><p>In this section, we <a id="id146" class="indexterm"/>will discuss which registry hives <a id="id147" class="indexterm"/>are important when searching for IOC. These subsections include the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Connected USB Devices</strong></span>: This section will show which devices had been connected to a<a id="id148" class="indexterm"/> system and when. This helps in identifying the possible ways of data leakage or exfiltration through a system user.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>User Histories</strong></span>: This<a id="id149" class="indexterm"/> section will show where to find histories of the opened files.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Startup Programs</strong></span>: This<a id="id150" class="indexterm"/> section will show which programs will be executed on system start. This can be very helpful when trying to identify the infected systems.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>System Information</strong></span>: This <a id="id151" class="indexterm"/>section will show where to find important information of the system in question (for example, usernames).</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Shim Cache Parser</strong></span>: This <a id="id152" class="indexterm"/>section will show how to get <a id="id153" class="indexterm"/>important IOC with the help of common Python tools such as Mandiant's <span class="strong"><strong>Shim Cache Parser</strong></span>, refer to <a class="ulink" href="https://www.mandiant.com/blog/leveraging-application-compatibility-cache-forensic-investigations/">https://www.mandiant.com/blog/leveraging-application-compatibility-cache-forensic-investigations/</a>.</li></ul></div><div class="section" title="Connected USB Devices"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec05"/>Connected USB Devices</h3></div></div></div><p>One of the <a id="id154" class="indexterm"/>most common questions that an incident response person has to answer is whether a user has exfiltrated confidential data from a system or whether a system compromise has been initiated by a rogue USB device that a user connected to the system. To answer this question, the Windows Registry is a good point to start.</p><p>Any time a new USB device is connected to the system, it will leave information in the registry. This information can uniquely identify each USB device that has been connected to the system. The registry stores the vendor ID, product ID, revision and serial numbers of each connected USB device. This information can be found in the <code class="literal">HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Enum\USBSTOR</code> registry hive, <span class="emphasis"><em>Windows Forensic Analysis</em></span>, <span class="emphasis"><em>Harlan Carvey</em></span>, <span class="emphasis"><em>Dave Kleiman</em></span>, <span class="emphasis"><em>Syngress Publishing</em></span>, which is also shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/2087_03_02.jpg" alt="Connected USB Devices"/></div></div><div class="section" title="User histories"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec06"/>User histories</h3></div></div></div><p>On a <a id="id155" class="indexterm"/>Windows system, there are several lists in the Registry that help in identifying the recent user activity (for example, recently visited web pages or recently opened Microsoft Word files). The following table shows some of these lists with the corresponding Windows Registry subkeys, for all lists and their <a id="id156" class="indexterm"/>Windows Registry subkeys refer to <a class="ulink" href="http://ro.ecu.edu.au/cgi/viewcontent.cgi?article=1071&amp;context=adf">http://ro.ecu.edu.au/cgi/viewcontent.cgi?article=1071&amp;context=adf</a>:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>History list</p>
</th><th style="text-align: left" valign="bottom">
<p>Related windows registry sub key</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>Typed URLs in Microsoft Internet Explorer</p>
</td><td style="text-align: left" valign="top">
<p>HKEY_USERS\S-1-5-21-[User Identifier] \Software\Microsoft\Internet Explorer\TypedURLs</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Most<a id="id157" class="indexterm"/> recently used Microsoft Office files</p>
</td><td style="text-align: left" valign="top">
<p>HKEY_USERS\S-1-5-21-[User Identifier] \Software \Microsoft\Office\12.0\Office_App_Name\File MRU</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Most recently mapped network drives</p>
</td><td style="text-align: left" valign="top">
<p>HKEY_USERS\S-1-5-21-[User Identifier] \Software \Microsoft\Windows\CurrentVersion\Explorer\Map Network Drive MRU</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Most recently typed command on the RUN dialog</p>
</td><td style="text-align: left" valign="top">
<p>HKEY_USERS\S-1-5-21-[User Identifier] \Software \Microsoft\Windows\CurrentVersion\Explorer\RunMRU</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Recent folders</p>
</td><td style="text-align: left" valign="top">
<p>HKEY_USERS\S-1-5-21-[User Identifier] \Software\Microsoft\Windows\CurrentVersion\Explorer\RecentDocs\Folder</p>
</td></tr></tbody></table></div></div><div class="section" title="Startup programs"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec07"/>Startup programs</h3></div></div></div><p>During some<a id="id158" class="indexterm"/> investigations, it is important to find out which software was automatically run at startup and which software was manually started by a user. To help answer this question, the Windows Registry <code class="literal">HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Run</code> can help again. The list of startup programs is shown in the following figure and is listed within the <span class="emphasis"><em>Windows Register hive</em></span>, which is taken from <span class="emphasis"><em>A Windows Registry Quick Reference</em></span>, <span class="emphasis"><em>Farmer, D. J</em></span>:</p><div class="mediaobject"><img src="graphics/2087_03_03.jpg" alt="Startup programs"/></div></div><div class="section" title="System Information"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec08"/>System Information</h3></div></div></div><p>In this section, we <a id="id159" class="indexterm"/>will see some registry hives that can be important when analyzing a system. First of all, there is a large amount of information about the user account that is stored in the registry, as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A list of user accounts</li><li class="listitem" style="list-style-type: disc">Last login time of each account</li><li class="listitem" style="list-style-type: disc">Whether the account requires a password</li><li class="listitem" style="list-style-type: disc">Whether a specific account is disabled or enabled</li><li class="listitem" style="list-style-type: disc">The hash technique that is used for calculating the password hash</li></ul></div><p>All of this information is held in the following registry key:</p><p>
<code class="literal">HKEY_LOCAL_MACHINE\SAM\Domains\Account\Users</code>
</p><p>There is a lot more interesting data in the Windows Registry; however, one type of information can be very helpful during a forensic investigation: the time of the last shutdown of the system. This information is stored in the <code class="literal">ShutdownTime</code> value in the following hive:</p><p>
<code class="literal">HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Control\Windows</code>
</p><p>This information is often interesting on server systems as it could be a hint as to when the last updates had been applied or whether there had been any unplanned reboots of a system, which also could have been caused by an attacker.</p></div><div class="section" title="Shim Cache Parser"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec09"/>Shim Cache Parser</h3></div></div></div><p>The <a id="id160" class="indexterm"/>Windows Registry contains application<a id="id161" class="indexterm"/> compatibility issues and a large amount of metadata (such as file size, file's last modified time, and last execution time depending on the operating system version) that could be important <a id="id162" class="indexterm"/>for the application runtime in <span class="strong"><strong>Application Compatibility Shim Cache</strong></span>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip05"/>Tip</h3><p>The implementation and structure of the Application Compatibility Shim Cache can vary per operating system. Thus, check your findings thoroughly.</p></div></div><p>Data about application compatibility and runtime issues can be very useful during an incident response or any other kind of forensic investigation in order to identify the potentially infected systems and to create a timeline of when the potential infection took place. Mandiant has released a tool to extract this kind of evidence: <span class="strong"><strong>Shim Cache Parser</strong></span>, (for more information<a id="id163" class="indexterm"/> refer to <a class="ulink" href="https://github.com/mandiant/ShimCacheParser">https://github.com/mandiant/ShimCacheParser</a>)</p><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Shim Cache Parser will automatically determine the format of the cached data and output their contents. It supports a number of inputs including system registry hives, raw binary, or the current system's registry.</em></span></p></blockquote></div><p>The tool can be <a id="id164" class="indexterm"/>used against an exported registry hive<a id="id165" class="indexterm"/> or against the running system. When using it against a running system, you just need to execute the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>C:\tools\mandiant&gt; python ShimCacheParser.py –l –o out.csv</strong></span>

<span class="strong"><strong>[+] Dumping Shim Cache data from the current system...</strong></span>
<span class="strong"><strong>[+] Found 64bit Windows 7/2k8-R2 Shim Cache data...</strong></span>
<span class="strong"><strong>[+] Found 64bit Windows 7/2k8-R2 Shim Cache data...</strong></span>
<span class="strong"><strong>[+] Found 64bit Windows 7/2k8-R2 Shim Cache data...</strong></span>
<span class="strong"><strong>[+] Writing output to out.csv...</strong></span>
</pre></div><p>When looking at the generated CSV output, you can find installed applications and first runtime of these files, as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Last Modified,Last Update,Path,File Size,Exec Flag</strong></span>
<span class="strong"><strong>05/04/11 05:19:28,N/A,C:\Windows\system32\SearchFilterHost.exe,N/A,True</strong></span>
<span class="strong"><strong>05/24/15 16:44:45,N/A,C:\Program Files (x86)\Avira\AntiVir Desktop\avwsc.exe,N/A,True</strong></span>
<span class="strong"><strong>11/21/10 03:24:15,N/A,C:\Windows\system32\wbem\wmiprvse.exe,N/A,True</strong></span>
<span class="strong"><strong>05/30/14 08:07:49,N/A,C:\Windows\TEMP\40F00A21-D2E7-47A3-AE16-0AFB8E6C1F87\dismhost.exe,N/A,True</strong></span>
<span class="strong"><strong>07/14/09 01:39:02,N/A,C:\Windows\system32\DeviceDisplayObjectProvider.exe,N/A,True</strong></span>
<span class="strong"><strong>07/26/13 02:24:56,N/A,C:\Windows\System32\shdocvw.dll,N/A,False</strong></span>
<span class="strong"><strong>05/24/15 16:46:22,N/A,C:\Program Files (x86)\Google\Update\1.3.27.5\GoogleCrashHandler.exe,N/A,True</strong></span>
<span class="strong"><strong>05/07/15 21:42:59,N/A,C:\Windows\system32\GWX\GWX.exe,N/A,True</strong></span>
<span class="strong"><strong>03/26/15 20:57:08,N/A,C:\Program Files (x86)\Parallels\Parallels Tools\prl_cc.exe,N/A,True</strong></span>
<span class="strong"><strong>10/07/14 16:29:54,N/A,C:\Program Files (x86)\KeePass Password Safe 2\KeePass.exe,N/A,True</strong></span>
<span class="strong"><strong>10/07/14 16:44:13,N/A,C:\ProgramData\Avira\Antivirus\TEMP\SELFUPDATE\updrgui.exe,N/A,True</strong></span>
<span class="strong"><strong>04/17/15 21:03:48,N/A,C:\Program Files (x86)\Avira\AntiVir Desktop\avwebg7.exe,N/A,True</strong></span>
</pre></div><p>Looking at the previous data, one can see that the user installed or updated Avira AntiVir on 2015-05-24 and KeePass on 2014-07-10. Also, you can find some hints that the system seems to be a virtual system as you can see the hints of Parallels, a Mac OS X virtualization platform.</p><p>If one <a id="id166" class="indexterm"/>considers the tools that have been described <a id="id167" class="indexterm"/>previously and the information that the Windows Event Log and Windows Registry contain, it is clear that in a forensic investigation, not all questions concerning a system can be answered without these sources of information.</p></div></div></div>
<div class="section" title="Implementing Linux specific checks"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec17"/>Implementing Linux specific checks</h1></div></div></div><p>In this section, we <a id="id168" class="indexterm"/>will describe how to implement some integrity checks to support the finding signs of system manipulation in Linux and similar (for example, BSD) systems.</p><p>These checks include the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Searching for anomalies in the local user management</li><li class="listitem" style="list-style-type: disc">Understanding and analyzing file metadata for special permissions and privileges</li><li class="listitem" style="list-style-type: disc">Using clustering algorithms on file metadata to get indicators on where to look deeper</li></ul></div><div class="section" title="Checking the integrity of local user credentials"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec24"/>Checking the integrity of local user credentials</h2></div></div></div><p>The information <a id="id169" class="indexterm"/>about <a id="id170" class="indexterm"/>local users in Linux is mostly stored in two files: <code class="literal">/etc/passwd</code> and <code class="literal">/etc/shadow</code>. The latter is optional and all the information about local users—including the hashed password—was originally stored in <code class="literal">/etc/passwd</code>. Soon, it was considered a security issue to store the password information in a file that is readable by every user. Therefore, the password hashes in <code class="literal">/etc/passwd</code> were replaced by a single x denoting that the corresponding password hash has to be looked up in <code class="literal">/etc/shadow</code>.</p><p>The side effect of this evolutionary process is that the password hashes in <code class="literal">/etc/passwd</code> are still supported and all the settings in <code class="literal">/etc/passwd</code> may override the credentials in <code class="literal">/etc/shadow</code>.</p><p>Both files <a id="id171" class="indexterm"/>are text files with <a id="id172" class="indexterm"/>one entry per line. An entry consists of multiple fields separated by colons.</p><p>The format of <code class="literal">/etc/passwd</code> is as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>username</strong></span>: This field contains the human-readable username. It is not required for the username to be unique. However, most user management tools enforce unique usernames.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>password hash</strong></span>: This field contains the password in an encoded form according to the Posix <code class="literal">crypt()</code> function. If this field is empty, then the corresponding user does not require a password to log on to the system. If this field contains a value that cannot be generated by the hash algorithm, for example, an exclamation mark, then the user cannot log on using a password. However, this condition does not render the account useless. A user with a locked password can still log on using other authentication mechanisms, for example, SSH keys.<p>As mentioned earlier, the special value x means that the password hash has to be found in the shadow file.</p><p>Starting with the system library <code class="literal">glibc2</code>, the <code class="literal">crypt()</code> function supports multiple hash algorithms. In that case, the password hash has the following format:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$id$salt$encrypted</strong></span>
</pre></div><p>The ID designates the hash algorithm that has been used to encode the password, for example, 1 for md5, 5 for sha256, and 6 for sha512. The salt is a randomly generated string in order to modify the hash algorithm. Consequently, even identical passwords result in different hash sums. The subfield "encrypted" holds the actual hash of the password (modified by the influence of the salt).</p></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>numerical user ID</strong></span>: This field denotes the ID of the user. Internally, the Linux kernel uses only this numerical ID. The special ID 0 is assigned to the administrative root user. Per default, user ID 0 is granted unlimited privileges on the system.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>numerical group ID</strong></span>: This field refers to the primary group of the user.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>comment field</strong></span>: This field can contain the arbitrary information about the user and is mostly used to hold the full name of the user. Sometimes, it also contains a comma-separated list of the full username, phone number, and so on</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>user home directory</strong></span>: The user home directory is a directory on the system's file system. After logging on, new processes are started with this directory as the working directory.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>default command shell</strong></span>: This optional field denotes the default shell that is to be started after a successful logon.</li></ul></div><p>The<a id="id173" class="indexterm"/> format of <code class="literal">/etc/shadow</code> is as <a id="id174" class="indexterm"/>follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="strong"><strong>username</strong></span> field links the entry to the <code class="literal">passwd</code> entry with the same username.</li><li class="listitem" style="list-style-type: disc">The <span class="strong"><strong>password hash</strong></span> field contains the encoded password in the same format as described for the <code class="literal">passwd</code> file.</li><li class="listitem" style="list-style-type: disc">The next five fields contain the information about the password aging, such as the date of the last password change, minimum password age, maximum password age, password warning period, and password inactivity period.</li><li class="listitem" style="list-style-type: disc">If the <span class="strong"><strong>account expiration date</strong></span> field is nonempty, it will be interpreted as the account expiration date. This date is expressed in days since January 1st, 1970.</li></ul></div><p>With this format description, a small Python routine is sufficient to parse the file into a list of entries, each containing a list of fields as shown in the following:</p><div class="informalexample"><pre class="programlisting">def read_passwd(filename):
    """Reads entries from shadow or passwd files and
       returns the content as list of entries.
       Every entry is a list of fields."""

    content = []
    with open(filename, 'r') as f:
        for line in f:
            entry = line.strip().split(':')
            content.append(entry)

    return content</pre></div><p>On using this routine, typical manipulations in these files may be detected.</p><p>The first manipulation technique that we want to describe is the creation of <span class="emphasis"><em>multiple users who share the same numerical id</em></span>. This technique can be used by attackers to plant a backdoor into the system. By creating an additional user for an existing ID, an attacker can create an alias with a separate password. The legitimate account owner would not be aware that there <a id="id175" class="indexterm"/>is an additional<a id="id176" class="indexterm"/> combination of username/password to log in to the account.</p><p>A small Python routine can detect this kind of manipulation, as follows:</p><div class="informalexample"><pre class="programlisting">def detect_aliases(passwd):
    """Prints users who share a user id on the console
    
       Arguments:
       passwd -- contents of /etc/passwd as read by read_passwd"""

    id2user = {}
    for entry in passwd:
        username = entry[0]
        uid = entry[2]
        if uid in id2user:
            print 'User "%s" is an alias for "%s" with uid=%s' % (username, id2user[uid], uid)
        else:
            id2user[uid] = username</pre></div><p>During normal operation, the information in <code class="literal">/etc/passwd</code> and <code class="literal">/etc/shadow</code> is synced, that is, every user should appear in both the files. If there <span class="emphasis"><em>are users appearing in only one of these files</em></span>, it is an indicator that the user management of the operating system has been bypassed. A manipulation like this can be detected with a similar script:</p><div class="informalexample"><pre class="programlisting">def detect_missing_users(passwd, shadow):
    """Prints users of /etc/passwd missing in /etc/shadow
       and vice versa.

       Arguments:
       passwd -- contents of /etc/passwd as read by read_passwd
       shadow -- contents of /etc/shadow as read by read_passwd"""

    passwd_users = set([e[0] for e in passwd])
    shadow_users = set([e[0] for e in shadow])

    missing_in_passwd = shadow_users - passwd_users
    if len(missing_in_passwd) &gt; 0:
        print 'Users missing in passwd: %s' % ', '.join(missing_in_passwd)

    missing_in_shadow = passwd_users - shadow_users
    if len(missing_in_shadow) &gt; 0:
        print 'Users missing in shadow: %s' % ', '.join(missing_in_shadow)</pre></div><p>Just like the first function, this function should not produce any output on a normal system. If there is an output similar to <code class="literal">Users missing in shadow: backdoor</code> then there is a user account "backdoor" in the system without a record in the <code class="literal">shadow</code> file.</p><p>Users <a id="id177" class="indexterm"/>without a password <a id="id178" class="indexterm"/>should not exist in a normal system. Furthermore, all the password hashes should reside in the <code class="literal">shadow</code> file and all entries in the <code class="literal">passwd</code> file should refer to the corresponding shadow entry. The following script detects deviations from this rule:</p><div class="informalexample"><pre class="programlisting">def detect_unshadowed(passwd, shadow):
    """Prints users who are not using shadowing or have no password set
    
       Arguments:
       passwd -- contents of /etc/passwd as read by read_passwd
       shadow -- contents of /etc/shadow as read by read_passwd"""


    nopass = [e[0] for e in passwd if e[1]=='']
    nopass.extend([e[0] for e in shadow if e[1]==''])
    if len(nopass) &gt; 0:
        print 'Users without password: %s' % ', '.join(nopass)

    unshadowed = [e[0] for e in passwd if e[1] != 'x' and e[1] != '']
    if len(unshadowed) &gt; 0:
        print 'Users not using password-shadowing: %s' % \
              ', '.join(unshadowed)</pre></div><p>Our last example of bypassing the operating system in the creation and manipulation of user accounts is the <span class="emphasis"><em>detection of non-standard hash algorithms</em></span> and <span class="emphasis"><em>reusing salts for multiple user accounts</em></span>. While a Linux system allows specifying the hash algorithm for every entry in the <code class="literal">shadow</code> file, normally all user passwords are hashed using the same algorithm. A deviating algorithm is a signal for an entry being written to the <code class="literal">shadow</code> file without using the operating system tools, meaning, system manipulation. If a salt is reused across multiple password hashes, then the salt is either hardcoded into a manipulation tool or the cryptographic routines of the system have been compromised, for example, by manipulating the entropy source of the salt generation.</p><p>The following Python script is capable of detecting this kind of manipulation:</p><div class="informalexample"><pre class="programlisting">import re
def detect_deviating_hashing(shadow):
    """Prints users with non-standard hash methods for passwords
    
       Arguments:
       shadow -- contents of /etc/shadow as read by read_passwd"""

    noalgo = set()
    salt2user = {}
    algorithms = set()
    for entry in shadow:
        pwhash = entry[1]
        if len(pwhash) &lt; 3:
            continue
        
        m = re.search(r'^\$([^$]{1,2})\$([^$]+)\$', pwhash)
        if not m:
            noalgo.add(entry[0])
            continue
        
        algo = m.group(1)
        salt = m.group(2)
        
        if salt in salt2user:
            print 'Users "%s" and "%s" share same password salt "%s"' % \
                  (salt2user[salt], entry[0], salt)
        else:
            salt2user[salt] = entry[0]

        algorithms.add(algo)

    if len(algorithms) &gt; 1:
        print 'Multiple hashing algorithms found: %s' % ', '.join(algorithms)

    if len(noalgo) &gt; 0:
        print 'Users without hash algorithm spec. found: %s' % \
              ', '.join(noalgo)</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip06"/>Tip</h3><p>
<span class="strong"><strong>Regular expressions</strong></span>
</p><p>The last example uses the <code class="literal">re</code> module for <span class="strong"><strong>regular expression</strong></span> matching to extract the algorithm<a id="id179" class="indexterm"/> specification and salt from the password hash. Regular expressions provide a fast and powerful way of text searching, matching, splitting, and replacing. Therefore, we highly recommend getting familiar with regular expressions. The documentation of the <code class="literal">re</code> module is<a id="id180" class="indexterm"/> available online at <a class="ulink" href="https://docs.python.org/2/library/re.html">https://docs.python.org/2/library/re.html</a>. The book <span class="emphasis"><em>Mastering Python Regular Expressions</em></span>, <span class="emphasis"><em>Felix Lopez</em></span> and <span class="emphasis"><em>Victor Romero</em></span>, <span class="emphasis"><em>Packt Publishing</em></span> provides further insights and examples on how to use regular expressions.</p></div></div><p>All of the <a id="id181" class="indexterm"/>detection methods<a id="id182" class="indexterm"/> in this section are examples of anomaly detection methods. Depending on the system environment, more specific anomaly detections can be used and implemented by following the schema of the examples. For example, on a server system, the number of users having a password set should be small. Therefore, counting all the users with passwords can be a reasonable step in the analysis of such systems.</p></div><div class="section" title="Analyzing file meta information"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec25"/>Analyzing file meta information</h2></div></div></div><p>In this<a id="id183" class="indexterm"/> section, we will discuss file meta<a id="id184" class="indexterm"/> information and provide examples on how it can be used in forensic analysis.</p><div class="section" title="Understanding inode"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec10"/>Understanding inode</h3></div></div></div><p>Linux systems <a id="id185" class="indexterm"/>store file meta information in structures <a id="id186" class="indexterm"/>called <span class="strong"><strong>inodes</strong></span> (<span class="strong"><strong>index nodes</strong></span>). In a Linux filesystem, every object is represented by an inode. The data stored per inode depends on the actual filesystem type. Typical contents of an inode are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="strong"><strong>index number</strong></span> is<a id="id187" class="indexterm"/> the identifier of an inode. The index number is unique per file system. If two files share the same index number, then these files are <span class="strong"><strong>hard-linked</strong></span>. Consequently, hard-linked files only differ in their filename and always have the same contents as well as the same meta information.</li><li class="listitem" style="list-style-type: disc">The <span class="strong"><strong>file owner</strong></span> is <a id="id188" class="indexterm"/>defined by the numerical ID of the user (UID). There can be only one owner per file. The user IDs should correspond to the entries in <code class="literal">/etc/passwd</code>. However, it is not guaranteed that there are only files with existing entries in <code class="literal">/etc/passwd</code>. Files can be transferred to the nonexisting users with administrative privileges. Furthermore, the owner of the file may have been removed from the system, making the file orphaned. For files on transportable media, for example, USB drives, there is no mechanism of mapping the user ID from one system to<a id="id189" class="indexterm"/> another. Consequently, the file owner seems to change when a USB drive is attached to a new system with different <code class="literal">/etc/passwd</code>. Furthermore, this can also lead to orphaned files if a UID does not exist on the system where the USB drive is attached.</li><li class="listitem" style="list-style-type: disc">The <span class="strong"><strong>file group</strong></span> is <a id="id190" class="indexterm"/>defined by the numerical ID of the corresponding group (GID). A file is always assigned to exactly one group. All groups of a system should be defined in <code class="literal">/etc/groups</code>. However, files with group IDs that are not listed in <code class="literal">/etc/groups</code> may exist. This indicates that the corresponding group has been deleted from the system, the medium has been transferred from another system<a id="id191" class="indexterm"/> where that group exists, or a user with administrative privileges reassigned the file to a nonexisting group.</li><li class="listitem" style="list-style-type: disc">The <span class="strong"><strong>file mode</strong></span> (<span class="strong"><strong>also known as "protection bits"</strong></span>) defines a simple form of access rights<a id="id192" class="indexterm"/> to the corresponding file. It is a bit mask defining the access rights for the file owner, for users belonging to the group that the file is assigned to, and for all other users. For each of these cases, the following bits are defined:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>read</strong></span> (<span class="strong"><strong>r</strong></span>): If this bit is set on a regular file, the affected user is allowed to<a id="id193" class="indexterm"/> read the file contents. If the bit is set on a directory, the affected user is allowed to list the names of the contents of the directory. The read access does not include the meta-information, which is the inode data of the directory entries. Consequently, the read permission to a directory is not sufficient to read files in that directory as this would require access to the file's inode data.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>write</strong></span> (<span class="strong"><strong>w</strong></span>): If this bit is set on a regular file, the affected user is allowed to <a id="id194" class="indexterm"/>modify the contents of the file in arbitrary ways including manipulation and deletion of the content. If this bit is set on a directory entry, then the affected user is allowed to create, remove, and rename the entries in that directory. The existing files in the directory have their own protection bits that define their access rights.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>execute</strong></span> (<span class="strong"><strong>x</strong></span>): For regular files, this allows the affected user to start the<a id="id195" class="indexterm"/> file as a program. If the file is a compiled binary, for example, in the ELF format, then the execute privileges are sufficient to run the program. If the file is a script that has to be interpreted, then read permission (r) is also required to run the script. The reason is that the Linux kernel determines how to load the program. If it detects that the file contains a script, it loads the script interpreter with the <a id="id196" class="indexterm"/>current user's privileges. For directories, this flag grants permission to read the meta-information of the directory contents, except the names of the entries. Therefore, this allows the affected user to change the working directory to this directory.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>sticky</strong></span> (<span class="strong"><strong>t</strong></span>): This bit <a id="id197" class="indexterm"/>exists only once per inode. When it is set on directories, it limits the right to delete and rename entries to the user owning the entry. On regular files, this flag is ignored or has a file system specific effect. When set on executables, this flag is used to prevent the resulting process from being swapped out from RAM. However, this purpose of the sticky bit is deprecated and Linux systems do not obey the sticky bit on executables.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>set id on execution</strong></span> (<span class="strong"><strong>s</strong></span>): This bit exists for the user and for the group. When set for the user (SUID bit) on an executable file, the<a id="id198" class="indexterm"/> corresponding file is always run with its owner as the effective user. Therefore, the program is run with the privileges of the user owning the executable that is independent from the user that is actually starting the program. If the file is owned by the root user (UID 0), then the executable always runs with unlimited privileges. When the bit is set for the group (SGID bit), the executable is always started with the group of the file as effective group.</li></ul></div></li><li class="listitem" style="list-style-type: disc">The<a id="id199" class="indexterm"/> size of the file in bytes.</li><li class="listitem" style="list-style-type: disc">The number of blocks that are allocated for that file.</li><li class="listitem" style="list-style-type: disc">A timestamp denoting the last change of the file content (<span class="strong"><strong>mtime</strong></span>).</li><li class="listitem" style="list-style-type: disc">A timestamp denoting the last read access to the file content (<span class="strong"><strong>atime</strong></span>).<p>Access time stamp tracking can be disabled by the mount option <span class="strong"><strong>noatime</strong></span> to limit write access to the media (for example, to extend the lifetime of the SD cards). Furthermore, read-only access (mount option <span class="strong"><strong>ro</strong></span>) to the file system prevents atime tracking. Therefore, before analysis of atime information, it should be checked whether atime tracking was enabled for that file system. The corresponding initial mount options can be found in <code class="literal">/etc/fstab</code>.</p></li><li class="listitem" style="list-style-type: disc">A timestamp denoting the last change of the inode data (<span class="strong"><strong>ctime</strong></span>).</li></ul></div><p>Notable extensions to these standard entries are <span class="strong"><strong>POSIX Access Control Lists</strong></span> (<span class="strong"><strong>POSIX ACLs</strong></span>). These<a id="id200" class="indexterm"/> access control lists are supported by the major Linux file systems and allow specifying additional access entries besides the three classes (user, group, and others). These entries allow defining the additional access rights (the previously listed bits r, w and x) for additional users and groups. Evaluating POSIX ACLs will be discussed in detail in a separate section.</p><p>Another extension <a id="id201" class="indexterm"/>consists of the specification of <span class="strong"><strong>capability flags</strong></span> to an executable. This is used for a more granular specification of privileges than using the SUID bit. Instead of giving an executable owned by the root user the SUID bit and allowing it unlimited privileges, a set of required privileges can be specified. Capabilities will also be handled in detail in a separate section.</p></div><div class="section" title="Reading basic file metadata with Python"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec11"/>Reading basic file metadata with Python</h3></div></div></div><p>Python<a id="id202" class="indexterm"/> provides built-in functionality to read the file status information with the <code class="literal">os</code> module. The standard function to retrieve metadata from a file that is specified by its name is <code class="literal">os.lstat()</code>. In contrast to the more commonly used <code class="literal">os.stat()</code>, this function does not evaluate the targets of symbolic links but retrieves the information about the link itself. Therefore, it is not prone to run into infinite loops that are caused by circular symbolic links. Furthermore, it does not cause any errors on links that lack the link target.</p><p>The resulting object is platform dependent; however, the following information is always available: <code class="literal">st_mode</code> (protection bits), <code class="literal">st_ino</code> (inode number), <code class="literal">st_dev</code> (identifier of the device containing the file system object), <code class="literal">st_nlink</code> (number of hard links), <code class="literal">st_uid </code>(user ID of owner), <code class="literal">st_gid</code> (group ID of owner), <code class="literal">st_size</code> (file size in bytes), <code class="literal">st_mtime</code> (last modification), <code class="literal">st_atime</code> (last read access), <code class="literal">st_ctime</code> (last inode change). This information corresponds to the inode data that is described in the previous section.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note04"/>Note</h3><p>A detailed description about <code class="literal">os.stat()</code> and <code class="literal">os.lstat()</code> is available at <a class="ulink" href="https://docs.python.org/2/library/os.html#os.stat">https://docs.python.org/2/library/os.html#os.stat</a>. This also includes the examples of platform-dependent attributes.</p></div></div><p>The <code class="literal">st_mtime</code>, <code class="literal">st_atime</code>, and <code class="literal">st_ctime</code> time stamps are specified in the Unix timestamp format, that is, the number of seconds since January 1st 1970. With the datetime module, this time format can be converted into a human readable form, using the following script:</p><div class="informalexample"><pre class="programlisting">from datetime import datetime as dt
from os import lstat

stat_info = lstat('/etc/passwd')

atime = dt.utcfromtimestamp(stat_info.st_atime)
mtime = dt.utcfromtimestamp(stat_info.st_mtime)
ctime = dt.utcfromtimestamp(stat_info.st_ctime)

<span class="strong"><strong>print 'File mode bits:      %s' % oct(stat_info.st_mode)</strong></span>
print 'Inode number:        %d' % stat_info.st_ino
print '# of hard links:     %d' % stat_info.st_nlink
print 'Owner UID:           %d' % stat_info.st_uid
print 'Group GID:           %d' % stat_info.st_gid
print 'File size (bytes)    %d' % stat_info.st_size
print 'Last read (atime)    %s' % atime.isoformat(' ')
print 'Last write (mtime)   %s' % mtime.isoformat(' ')
print 'Inode change (ctime) %s' % ctime.isoformat(' ')</pre></div><p>This code listing outputs the common return values of the <code class="literal">lstat</code> call. A typical output looks similar to the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>File mode bits:      0100644</strong></span>
<span class="strong"><strong>Inode number:        1054080</strong></span>
<span class="strong"><strong># of hard links:     1</strong></span>
<span class="strong"><strong>Owner UID:           0</strong></span>
<span class="strong"><strong>Group GID:           0</strong></span>
<span class="strong"><strong>File size (bytes)    2272</strong></span>
<span class="strong"><strong>Last read (atime)    2015-05-15 09:25:15.991190</strong></span>
<span class="strong"><strong>Last write (mtime)   2014-09-20 10:40:46.389162</strong></span>
<span class="strong"><strong>Inode change (ctime) 2014-09-20 10:40:46.393162</strong></span>
</pre></div><p>This <a id="id203" class="indexterm"/>sample output denotes that on the lab system, <code class="literal">/etc/passwd</code> is a regular file with read permission for all users. This information is derived from the <code class="literal">st_mode</code> member of the result. On using Python's <code class="literal">oct()</code> function, it is converted in its octal representation, that is, <span class="emphasis"><em>one decimal digit of the output represents exactly three bits of the protection bits</em></span>. The leading zero in the output is a common indicator for the octal representation.</p><p>The lower three digits (<code class="literal">644</code> in the example output) always denote the access rights for the owner of the file (<code class="literal">6</code> in the example), for users belonging to the group of the file (left <code class="literal">4</code> in the example), and all other users (last digit).</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip07"/>Tip</h3><p>
<span class="strong"><strong>How to interpret the file mode bits?</strong></span>
</p><p>In its octal form, the bit values of the three least significant digits represent the access rights for the owner, group, and other users (last digit). For every digit, the read access (r) has bit value 4, write access (w) has bit value 2, and execution (x) has bit value 1.</p></div></div><p>Therefore, in our example, the digit <code class="literal">6</code> denotes read and write access (4 + 2) for the owner of the file. Members of the group 0 and all other users only have read access (4).</p><p>The next digit from the right denotes the sticky bit (value 1), the SGID bit (value 2), and the SUID bit (value 4).</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note05"/>Note</h3><p>The <code class="literal">stat</code> module<a id="id204" class="indexterm"/> defines the constants for all bits of <code class="literal">st_mode</code>. Its documentation is available at <a class="ulink" href="https://docs.python.org/2/library/stat.html">https://docs.python.org/2/library/stat.html</a>.</p></div></div><p>These constants can be used as a bit mask to retrieve information from <code class="literal">st_mode</code>. The earlier example could be extended to detect SGID, SUID, and sticky mode, as follows:</p><div class="informalexample"><pre class="programlisting">import stat

if stat.S_ISUID &amp; stat_info.st_mode:
    print 'SUID mode set!'

if stat.S_ISGID &amp; stat_info.st_mode:
    print 'SGID mode set!'

if stat.S_ISVTX &amp; stat_info.st_mode:
    print 'Sticky mode set!'</pre></div><p>For<a id="id205" class="indexterm"/> testing the code, you may use the example to evaluate the mode of <code class="literal">/etc/passwd</code>, <code class="literal">/tmp</code>, and <code class="literal">/usr/bin/sudo</code> on a standard Linux system. Typically, <code class="literal">/tmp</code> has the sticky flag set, <code class="literal">/usr/bin/sudo</code> has SUID set, and <code class="literal">/etc/password</code> has none of the special bits set.</p><p>The remaining bits denote the type of the file. The following file types may appear on a standard Linux filesystem:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>File type</p>
</th><th style="text-align: left" valign="bottom">
<p>Check function in module <code class="literal">stat</code>
</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>regular</p>
</td><td style="text-align: left" valign="top">
<p>S_ISREG()</p>
</td><td style="text-align: left" valign="top">
<p>This is used to store arbitrary data</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>directory</p>
</td><td style="text-align: left" valign="top">
<p>S_ISDIR()</p>
</td><td style="text-align: left" valign="top">
<p>This is used to store lists of other files</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>soft link</p>
</td><td style="text-align: left" valign="top">
<p>S_ISLNK()</p>
</td><td style="text-align: left" valign="top">
<p>This references one destination file via name</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>character device</p>
</td><td style="text-align: left" valign="top">
<p>S_ISCHR()</p>
</td><td style="text-align: left" valign="top">
<p>This is the interface in the filesystem to access the character-oriented hardware, for example, terminals</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>block device</p>
</td><td style="text-align: left" valign="top">
<p>S_ISBLK()</p>
</td><td style="text-align: left" valign="top">
<p>This is the interface in the filesystem to access the block-oriented hardware, for example, disk partitions</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>fifo</p>
</td><td style="text-align: left" valign="top">
<p>S_ISFIFO()</p>
</td><td style="text-align: left" valign="top">
<p>This is the representation of a named, unidirectional interprocess interface in the filesystem</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>socket</p>
</td><td style="text-align: left" valign="top">
<p>S_ISSOCK()</p>
</td><td style="text-align: left" valign="top">
<p>This is the representation of a named, bidirectional interprocess interface in the filesystem</p>
</td></tr></tbody></table></div><p>Hard links are not represented by a special file type but are merely multiple directory entries in the same filesystem sharing the same inode.</p><p>Unlike the tests for SGID, SUID, and sticky bit, the file type checks are implemented as functions of the <code class="literal">stat</code> module. These functions require the file mode bits as the parameter, for example:</p><div class="informalexample"><pre class="programlisting">from os import readlink,lstat
import stat

path = '/etc/rc5.d/S99rc.local'

stat_info = lstat(path)

if stat.S_ISREG(stat_info.st_mode):
    print 'File type: regular file'

if stat.S_ISDIR(stat_info.st_mode):
    print 'File type: directory'

if stat.S_ISLNK(stat_info.st_mode):
    print 'File type: symbolic link pointing to ',
    print readlink(path)</pre></div><p>In this <a id="id206" class="indexterm"/>example, the <code class="literal">os.readlink()</code> function is used to extract the target filename if a symbolic link is encountered. Symbolic links may refer to an absolute path or a relative path starting from the location of the symbolic link in the filesystem. Absolute symbolic links have a target starting with the character <code class="literal">/</code>, that is, the target is to be searched starting with the root directory of the system.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note06"/>Note</h3><p>If you mount your copy of the evidence in your lab environment for analysis, the absolute symbolic links are either broken or they point to a file in your lab workstation! The relative symbolic links remain intact as long as their destination resides in the same partition as the link.</p></div></div><p>A possible <a id="id207" class="indexterm"/>output of the previous example code could be<code class="literal"> - File type: symbolic link pointing to  ../init.d/rc.local - </code>, which is an example of a relative link.</p></div><div class="section" title="Evaluating POSIX ACLs with Python"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec12"/>Evaluating POSIX ACLs with Python</h3></div></div></div><p>The file <a id="id208" class="indexterm"/>mode bits, which are<a id="id209" class="indexterm"/> defined in the file's inode, only allow three addressees for permissions: the file owner, the users belonging to the file's group, and everybody else.</p><p>If a more granular set of permissions is required, the traditional solution will be to create a group that consists of all the users who should have access and transfer the file to that group. However, the creation of such groups has major disadvantages. First, the list of groups can become unnecessarily large. Second, the creation of such groups requires administrative<a id="id210" class="indexterm"/> privileges and therefore, breaks the Linux/Unix concept of <span class="strong"><strong>discretionary access control</strong></span>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note07"/>Note</h3><p>
<span class="strong"><strong>Discretionary access control</strong></span> is the concept of allowing the owner of the information, that is, the file owner, to decide who should be allowed the access. In discretionary access control, ownership is the sole requirement for being allowed to grant or revoke access to a resource.</p></div></div><p>Last but not least, file owners may just open up files and directories for everyone on the system if there is no group that is matching to the list of the users to authorize. This breaks the <span class="emphasis"><em>concept of least privilege</em></span>, that is, not granting more permissions on a system than required for its operation.</p><p>To maintain the discretionary access control as well as the concept of least privilege, an optional extension to the file access mode was specified, that is, <span class="strong"><strong>POSIX ACL</strong></span>. Besides allowing read, write, and execute permissions for the file owner, group, and others, POSIX ACLs allow to specify the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Specific read, write, and execute permissions for arbitrary users</li><li class="listitem" style="list-style-type: disc">Specific read, write, and execute permissions for arbitrary groups</li><li class="listitem" style="list-style-type: disc">Every privilege that is not set in the access mask is not granted. Only the permissions of the file owner and others are not affected by the access mask.</li></ul></div><p>On the command line, the <code class="literal">getfacl</code> and <code class="literal">setfacl</code> tools can be used to read and modify the POSIX ACL entries respectively:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user@lab:~$ touch /tmp/mytest</strong></span>
<span class="strong"><strong>user@lab:~$ getfacl /tmp/mytest</strong></span>
<span class="strong"><strong>getfacl: Removing leading '/' from absolute path names</strong></span>
<span class="strong"><strong># file: tmp/mytest</strong></span>
<span class="strong"><strong># owner: user</strong></span>
<span class="strong"><strong># group: user</strong></span>
<span class="strong"><strong>user::rw-</strong></span>
<span class="strong"><strong>group::r--</strong></span>
<span class="strong"><strong>other::r--</strong></span>
</pre></div><p>This example also shows that the standard permission set is reflected in the POSIX ACL. Consequently, if POSIX ACLs are supported on a filesystem, then the complete permission set is contained in POSIX ACLs.</p><p>Let's revoke <a id="id211" class="indexterm"/>the read access to <code class="literal">other</code> users and add read/write access to the user <code class="literal">games</code>, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user@lab:~$ setfacl -m o::0 -m u:games:rw /tmp/mytest</strong></span>
<span class="strong"><strong>user@lab:~$ getfacl /tmp/mytest</strong></span>
<span class="strong"><strong>getfacl: Removing leading '/' from absolute path names</strong></span>
<span class="strong"><strong># file: tmp/mytest</strong></span>
<span class="strong"><strong># owner: user</strong></span>
<span class="strong"><strong># group: user</strong></span>
<span class="strong"><strong>user::rw-</strong></span>
<span class="strong"><strong>user:games:rw-</strong></span>
<span class="strong"><strong>group::r--</strong></span>
<span class="strong"><strong>mask::rw-</strong></span>
<span class="strong"><strong>other::---</strong></span>
<span class="strong"><strong>user@lab:~$ ls -l /tmp/mytest</strong></span>
<span class="strong"><strong>-rw-rw----+ 1 user user 0 May 16 16:59 /tmp/mytest</strong></span>
</pre></div><p>The <code class="literal">-m o::0</code> parameter removes all the privileges from <code class="literal">other</code> users while<code class="literal"> –m u:games:rw </code>grants read/write access to the user <code class="literal">games</code>. The subsequent call to <code class="literal">getfacls</code> shows the additional entry for <code class="literal">user:games</code> and the changed entry for <code class="literal">other</code>. Furthermore, a <code class="literal">mask</code> entry is automatically created to limit the access from all the listed groups and <a id="id212" class="indexterm"/>users (except the file owner) to read/write.</p><p>The output of the <code class="literal">ls</code> command shows a plus sign <code class="literal">+</code> to indicate the existence of the additional ACL entries. As also indicated by the output of <code class="literal">ls</code>, tools that only evaluate the mode bits of a file are unaware of the additional permissions, for example, the additional access privileges for the user <code class="literal">games</code> do not show up in the standard output of <code class="literal">ls</code> or other file management applications.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note08"/>Note</h3><p>Forensic tools that do not look for and interpret POSIX ACL entries may miss the additional access rights that are introduced by the ACL entries! Consequently, the investigator may get a false impression of strict, effective privileges.</p></div></div><p>Fortunately, the Python <a id="id213" class="indexterm"/>library <span class="strong"><strong>pylibacl</strong></span> can be used to read and evaluate POSIX ACLs and hence, avoid that pitfall. The library introduces the <code class="literal">posix1e</code> module, that is, a reference to the initial draft first mentioning POSIX ACLs. The detailed <a id="id214" class="indexterm"/>documentation about this library is available at <a class="ulink" href="http://pylibacl.k1024.org/">http://pylibacl.k1024.org/</a>.</p><p>The following <a id="id215" class="indexterm"/>script is an example of how to look for files<a id="id216" class="indexterm"/> with the additional ACL entries:</p><div class="informalexample"><pre class="programlisting">#!/usr/bin/env python

import os
from os.path import join
import posix1e
import re
import stat
import sys

def acls_from_file(filename, include_standard = False):
    """Returns the extended ACL entries from the given
       file as list of the text representation.

       Arguments:
       filename -- the file name to get the ACLs from
       include_standard -- if True, ACL entries representing 
                           standard Linux permissions will be
                           included"""
    result = []
    try:
<span class="strong"><strong>        acl = posix1e.ACL(file=filename)</strong></span>
    except:
        print 'Error getting ACLs from %s' % filename
        return []

    text = acl.to_any_text(options=posix1e.TEXT_ABBREVIATE | posix1e.TEXT_NUMERIC_IDS)

    for entry in text.split("\n"):
        if not include_standard and \
           re.search(r'^[ugo]::', entry) != None:
            continue
        result.append(entry)

    return result


def get_acl_list(basepath, include_standard = False):
    """Collects all POSIX ACL entries of a directory tree.

    Arguments:
    basepath -- directory to start from
    include_standard -- if True, ACL entries representing 
                        standard Linux permissions will be
                        included"""
    result = {}

<span class="strong"><strong>    for root, dirs, files in os.walk(basepath):</strong></span>
        for f in dirs + files:
            fullname = join(root, f)

            # skip symbolic links (target ACL applies)
<span class="strong"><strong>            if stat.S_ISLNK(os.lstat(fullname).st_mode):</strong></span>
                continue

            acls = acls_from_file(fullname, include_standard)
            if len(acls) &gt; 0:
                result[fullname] = acls

    return result

if __name__ == '__main__':
    if len(sys.argv) &lt; 2:
        print 'Usage %s root_directory' % sys.argv[0]
        sys.exit(1)

    acl_list = get_acl_list(sys.argv[1], False)

    for filename, acls in acl_list.iteritems():
        print "%s: %s" % (filename, ','.join(acls))</pre></div><p>The <code class="literal">posix1e.ACL</code> class represents all the permissions set on a specific object on the filesystem. When its constructor is called with a filename as the <code class="literal">file</code> parameter, it represents <a id="id217" class="indexterm"/>ACL of that file. In<a id="id218" class="indexterm"/> the <code class="literal">acls_from_file()</code> function, a regular expression is used to detect and optionally filter out the standard permissions from the text representation of the ACL set.</p><p>The <code class="literal">os.walk()</code> function is used to iterate over a subtree of the filesystem. If you iterate over <code class="literal">os.walk()</code> like in the example, you get a triple in each iteration denoting the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The currently visited directory</li><li class="listitem" style="list-style-type: disc">A list with all of its subdirectories (relative to the currently visited directory)</li><li class="listitem" style="list-style-type: disc">A list with all of its nondirectory entries, for example, files and soft links (relative to the currently visited directory)</li></ul></div><p>The check in the last highlighted line of the script is an example of the evaluating file type information as described in the previous section. It is used to detect and skip symbolic links. The symbolic links always use ACLs of their target and consequently, POSIX ACLs on symbolic links are not supported.</p><p>When invoked with <code class="literal">/tmp</code> as the parameter on our lab machine, it generates the following output:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>/tmp/mytest: u:5:rw-,m::rw-</strong></span>
</pre></div><p>This output<a id="id219" class="indexterm"/> shows that the script detected the leftovers from our first tests with POSIX ACLs: An additional read/write permission for user (u) ID 5 (that is, user <code class="literal">games</code> on the lab machine) and a mask (m) entry that limits the effective privileges to read/write. The script outputs the numerical user IDs because pylibacl would otherwise use your workstation's <code class="literal">/etc/passwd</code> to look up the usernames.</p><p>If you run this script on a copy of the filesystem that contains your evidence, it will list every filesystem object with permissions beyond the Linux standard permission set.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note09"/>Note</h3><p>Most <a id="id220" class="indexterm"/>standard Linux systems and their applications do not use POSIX ACLs. Therefore, if you encounter any additional POSIX ACL entries during your investigation, it is a good idea to thoroughly check whether these POSIX ACLs were the result of a legitimate and benign system operation.</p></div></div></div><div class="section" title="Reading file capabilities with Python"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec13"/>Reading file capabilities with Python</h3></div></div></div><p>Traditionally, in Linux, there are two types of administrative privileges: root and non-root. If <a id="id221" class="indexterm"/>a process is granted the<a id="id222" class="indexterm"/> root privileges, that is, it runs with UID 0, then it may bypass every security restriction of the Linux kernel. On the other hand, if a process does not run with these root privileges, then all security restrictions of the kernel apply.</p><p>In order to replace this <span class="strong"><strong>all or nothing</strong></span> mechanism with a more fine-grained system, the <span class="strong"><strong>Linux capabilities</strong></span> were introduced. The corresponding man page describes it as the following:</p><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>For the purpose of performing permission checks, traditional UNIX implementations distinguish two categories of processes: privileged processes (whose effective user ID is 0, referred to as superuser or root), and unprivileged processes (whose effective UID is nonzero).</em></span></p><p><span class="emphasis"><em>Privileged processes bypass all kernel permission checks, while unprivileged processes are subject to full permission checking based on the process's credentials (usually: effective UID, effective GID, and supplementary group list).</em></span></p><p><span class="emphasis"><em>Starting with kernel 2.2, Linux divides the privileges traditionally associated with superuser into distinct units, known as capabilities, which can be independently enabled and disabled. Capabilities are a per-thread attribute.</em></span></p></blockquote></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip08"/>Tip</h3><p>
<span class="strong"><strong>What capabilities exist?</strong></span>
</p><p>The list of Linux capabilities can be found in the <code class="literal">/usr/include/linux/capability.h</code> file on a standard Linux system. A more human-readable form is provided in the capabilities man page. It can be viewed via <code class="literal">man 7 capabilities</code>. The Linux capabilities include every special permission granted to the root user, for example, overriding file permissions, using raw network connections, and so on.</p></div></div><p>Capabilities <a id="id223" class="indexterm"/>can be assigned to the<a id="id224" class="indexterm"/> threads of processes during the execution and to the executables on the filesystem. In either case, there are always three sets of capabilities:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>permitted set</strong></span> (<span class="strong"><strong>p</strong></span>): The <a id="id225" class="indexterm"/>permitted set contains all capabilities that a thread may request. If an executable is started, its permitted set is used to initialize the permitted set of the process.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>inheritable set</strong></span> (<span class="strong"><strong>i</strong></span>): The<a id="id226" class="indexterm"/> inheritable set of an execution set defines the capabilities that may be forwarded from the thread to a child process. However, only capabilities that are defined in the inheritable set of the executable file of the child process are forwarded to the child process. Therefore, a capability is only inherited if it is in the inheritable set <a id="id227" class="indexterm"/>of the parent process and in the file attribute of the child executable.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>effective set</strong></span> (<span class="strong"><strong>e</strong></span>): This is the set of capabilities that the Linux kernel actually checks when a<a id="id228" class="indexterm"/> privileged operation is requested from an execution thread. By calling <code class="literal">cap_set_proc()</code>, a process can disable or enable the capabilities. Only capabilities in the permitted set (p) may be enabled. On the filesystem, the effective set is represented by only one bit. If this bit is set, the executable is started with all of its permitted capabilities also being effective. If the bit is not set, the new process starts without the effective capabilities.<div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note10"/>Note</h3><p>Capabilities grant administrative privileges to executables without requiring the SUID bit in the file mode. Therefore, during a forensic investigation, all the file capabilities should be documented.</p></div></div></li></ul></div><p>Using<a id="id229" class="indexterm"/> Python's ctypes, the<a id="id230" class="indexterm"/> shared <code class="literal">libcap.so.2</code> library can be utilized to retrieve all the file capabilities from a directory tree, as follows:</p><div class="informalexample"><pre class="programlisting">#!/usr/bin/env python

import ctypes
import os
from os.path import join
import sys

# load shared library
<span class="strong"><strong>libcap2 = ctypes.cdll.LoadLibrary('libcap.so.2')</strong></span>

class cap2_smart_char_p(ctypes.c_char_p):
    """Implements a smart pointer to a string allocated
       by libcap2.so.2"""
    def __del__(self):
        libcap2.cap_free(self)

# note to ctypes: cap_to_text() returns a pointer
# that needs automatic deallocation
libcap2.cap_to_text.restype = cap2_smart_char_p

def caps_from_file(filename):
    """Returns the capabilities of the given file as text"""

<span class="strong"><strong>    cap_t = libcap2.cap_get_file(filename)</strong></span>
    if cap_t == 0:
        return ''
    return libcap2.cap_to_text(cap_t, None).value


def get_caps_list(basepath):
    """Collects file capabilities of a directory tree.

    Arguments:
    basepath -- directory to start from"""

    result = {}
    for root, dirs, files in os.walk(basepath):
        for f in files:
            fullname = join(root, f)
            caps = caps_from_file(fullname)
            if caps != '':
                result[fullname] = caps

    return result

if __name__ == '__main__':
    if len(sys.argv) &lt; 2:
        print 'Usage %s root_directory' % sys.argv[0]
        sys.exit(1)

    capabilities = get_caps_list(sys.argv[1])

    for filename, caps in capabilities.iteritems():
        print "%s: %s" % (filename, caps)</pre></div><p>The first highlighted line loads the <code class="literal">libcap.so.2</code> library for direct use in Python. As the memory<a id="id231" class="indexterm"/> for the text representation<a id="id232" class="indexterm"/> of the capabilities is allocated in this library, it is the responsibility of the caller, that is, our script, to deallocate this memory after usage. The solution for this task, which was chosen here, is to extend the <code class="literal">ctype</code> default representation of <span class="strong"><strong>pointer to character</strong></span>, that is, <code class="literal">ctype.c_char_p</code>. The resulting <code class="literal">cap2_smart_char_p</code> class is a simple version of the so-called <span class="strong"><strong>smart pointer</strong></span>: If the Python representation of objects of this class is being destroyed, the <a id="id233" class="indexterm"/>objects will automatically call <code class="literal">cap_free()</code> to free the corresponding resources that are previously allocated by <code class="literal">libcap.so.2</code>.</p><p>With the <code class="literal">cap_get_file()</code>library function, the capabilities of a file can be retrieved. The subsequent call to <code class="literal">cap_to_text()</code> transforms this internal representation into human-readable text.</p><p>If the script is saved to <code class="literal">chap03_capabilities.py</code>, then it can be called on the lab machine as shown in the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user@lab:~$ python chap03_capabilities.py /usr</strong></span>
</pre></div><p>Of course, the<a id="id234" class="indexterm"/> output is highly<a id="id235" class="indexterm"/> dependent on the Linux version and distribution. It may look similar to the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>/usr/bin/gnome-keyring-daemon: = cap_ipc_lock+ep</strong></span>
</pre></div><p>This output means that only one executable in <code class="literal">/usr</code> has the special capabilities set: <code class="literal">/usr/bin/gnome-keyring-daemon</code>. The name of the capability is given by the constant <code class="literal">cap_ipc_lock</code>, this capability is in the permitted set and is immediately effective on starting this program as denoted by <code class="literal">+ep</code>.</p><p>To resolve the meaning of <code class="literal">cap_ipc_lock</code>, we will call the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user@lab:~$ man 7 capabilities</strong></span>
</pre></div><p>Then we will search for CAP_IPC_LOCK. This reveals that the capability grants the right to lock the parts or all of a process memory in RAM and prevent the swapping of that process. As <code class="literal">gnome-keyring-daemon</code> stores user credentials in RAM, having the privilege to prevent these credentials from being written to the swap is highly advisable from a security perspective.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note11"/>Note</h3><p>Currently, most of the standard Linux distributions make little use of the file capability feature. Therefore, the discovered file capabilities—especially those that are not required for normal operation—may be the first indicator of system manipulation.</p></div></div></div></div><div class="section" title="Clustering file information"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec26"/>Clustering file information</h2></div></div></div><p>In the previous<a id="id236" class="indexterm"/> section, we showed you how<a id="id237" class="indexterm"/> to retrieve and collect file metadata from the Linux/Unix filesystem. In this section, we will provide examples to locate the changes in the filesystem metadata, which may be interesting for further inspection by the investigator.</p><div class="section" title="Creating histograms"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec14"/>Creating histograms</h3></div></div></div><p>Creating histograms <a id="id238" class="indexterm"/>is the process of clustering<a id="id239" class="indexterm"/> the data in bins of equal size and drawing the size of these bins. With Python, plotting these histograms can be easily achieved using the<a id="id240" class="indexterm"/> Python <span class="strong"><strong>matplotlib</strong></span> module. A detailed documentation<a id="id241" class="indexterm"/> including the use cases, examples, and Python source code is available at <a class="ulink" href="http://matplotlib.org/">http://matplotlib.org/</a>.</p><p>The following<a id="id242" class="indexterm"/> Python script can be used to generate<a id="id243" class="indexterm"/> and display the histograms of file access times and file modification times of a directory tree:</p><div class="informalexample"><pre class="programlisting">#!/usr/bin/env python

from datetime import datetime
from matplotlib.dates import DateFormatter
import matplotlib.pyplot as plt
import os
from os.path import join
import sys

# max. number of bars on the histogram
NUM_BINS = 200

def gen_filestats(basepath):
    """Collects metadata about a directory tree.
    
    Arguments:
    basepath -- root directory to start from

    Returns:
    Tuple with list of file names and list of
    stat results."""

    filenames = []
    filestats = []
    
    for root, dirs, files in os.walk(basepath):
        for f in files:
            fullname = join(root, f)
            filenames.append(fullname)
            filestats.append(os.lstat(fullname))
    return (filenames, filestats)

def show_date_histogram(times, heading='', block=False):
    """Draws and displays a histogram over the given timestamps.

    Arguments:
    times -- array of time stamps as seconds since 1970-01-01
    heading -- heading to write to the drawing
    block --- if True, the graph window waits for user interaction"""

    fig, ax = plt.subplots()

<span class="strong"><strong>    times = map(lambda x: datetime.fromtimestamp(x).toordinal(), times)</strong></span>

<span class="strong"><strong>    ax.hist(times, NUM_BINS)</strong></span>
    plt.xlabel('Date')
    plt.ylabel('# of files')
    plt.title(heading)
    
    ax.autoscale_view()

    ax.xaxis.set_major_formatter(DateFormatter('%Y-%m-%d'))
    fig.autofmt_xdate()

    fig.show()
    if block:
        plt.show()

if __name__ == '__main__':
    if len(sys.argv) &lt; 2:
        print 'Usage %s base_directory' % sys.argv[0]
        sys.exit(1)

    path = sys.argv[1]

    (names, stats) = gen_filestats(path)
    
    # extract time stamps
    mtimes = map(lambda x: x.st_mtime, stats)
    atimes = map(lambda x: x.st_atime, stats)

    show_date_histogram(mtimes, 'mtimes of ' + path)
    show_date_histogram(atimes, 'atimes of ' + path, True)</pre></div><p>The <code class="literal">gen_filestats()</code> function<a id="id244" class="indexterm"/> iterates the <a id="id245" class="indexterm"/>directory tree and collects all inode data. The <code class="literal">show_date_histogram()</code> function is used to generate and display the data as a histogram.</p><p>In the first highlighted line of the code, the encoding of the timestamp is changed. This is required because the inode data gives us the timestamps as number of seconds since 1970-01-01. This format is what <code class="literal">datetime.fromtimestamp()</code> expects. However, Matplotlib needs timestamps in number of days since 0001-01-01 of the Gregorian calendar. Fortunately, the <code class="literal">datetime</code> class can provide this representation with its <code class="literal">toordinal()</code> method.</p><p>The next highlighted line is the actual generation and drawing of the histogram in the following figure. All the other statements of <code class="literal">show_date_histogram()</code> merely serve the purpose of adding labels and formatting to the drawing.</p><p>The following<a id="id246" class="indexterm"/> is a sample result of the <code class="literal">/sbin</code> directory<a id="id247" class="indexterm"/> on a standard Linux desktop system:</p><div class="mediaobject"><img src="graphics/2087_03_04.jpg" alt="Creating histograms"/></div><p>Here, the dates of the major system updates are clearly visible. An investigator should be aware that the file metadata and these histograms <span class="emphasis"><em>do not contain historic file information</em></span>. Therefore, from the previous histogram, one cannot derive that there were little or no security updates before December 2011. It is more likely that most of the files that were patched before December 2011 have been modified later on, therefore, masking older patches in the histogram.</p><p>Let's take a look at the access time distribution of this directory:</p><div class="mediaobject"><img src="graphics/2087_03_05.jpg" alt="Creating histograms"/></div><p>This histogram<a id="id248" class="indexterm"/> provides some insight about the <a id="id249" class="indexterm"/>access pattern of this directory. First, the atime timestamp tracking is enabled on the systems. Otherwise, no current access timestamps would be visible in the histogram. About half of the files have been read recently. This information can be used to verify the information about the time when the evidence was acquired or when the system operator claimed to have taken the system offline.</p><p>Furthermore, the contents of this directory were very likely not scanned regularly for viruses and were not recently packed into an archive. Both the actions usually update the atime timestamp.</p><p>If the following command is issued on the system, then <code class="literal">/sbin</code> is scanned for viruses. Of course, the scanner has to read every file in that directory to scan its contents:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user@lab:~$ clamscan –i /sbin</strong></span>
</pre></div><p>The atime diagram of <code class="literal">/sbin</code> reflects the changes, as follows:</p><div class="mediaobject"><img src="graphics/2087_03_06.jpg" alt="Creating histograms"/></div><p>The changes<a id="id250" class="indexterm"/> are obvious: Most of the bars have<a id="id251" class="indexterm"/> collapsed in one at the current time, that is, the time of the virus scan. The timescale is stretched to a single day. Consequently, the bar on the left can also be considered to be a result of the virus scan.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note12"/>Note</h3><p>If there is a directory having all the <code class="literal">atime</code> timestamps on a single date, then this directory was recently copied, scanned for viruses, or packed in an archive. Of course, with sufficient access rights, the timestamps could have been manually set as well.</p></div></div></div><div class="section" title="Advanced histogram techniques"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec15"/>Advanced histogram techniques</h3></div></div></div><p>In the previous section, the histograms were used to learn about the filesystem metadata. However, these <a id="id252" class="indexterm"/>histograms have a number of disadvantages, as<a id="id253" class="indexterm"/> follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">All histogram bars are of equal width</li><li class="listitem" style="list-style-type: disc">The bars are not placed according to the actual clustering of the data, for example, a cluster may be distributed over two bars</li><li class="listitem" style="list-style-type: disc">The outliers disappear, that is, the low bars are easily confused with the empty bars</li></ul></div><p>Therefore, this section presents an example of how to use simple <span class="strong"><strong>machine learning algorithms</strong></span> for<a id="id254" class="indexterm"/> a smarter clustering of the data. A widely used machine learning library for<a id="id255" class="indexterm"/> Python is <span class="strong"><strong>scikit-learn</strong></span>. Among other domains, it provides several algorithms for clustering the input data. We<a id="id256" class="indexterm"/> recommend visiting <a class="ulink" href="http://scikit-learn.org">http://scikit-learn.org</a> for an overview of all the algorithms and examples of their use. The following Python script uses<a id="id257" class="indexterm"/> the <code class="literal">DBSCAN</code> algorithm from scikit-learn to generate clusters of a given width (in days):</p><div class="informalexample"><pre class="programlisting">#!/usr/bin/python

from datetime import date
import numpy as np
import os
from os.path import join
from sklearn.cluster import DBSCAN
import sys

def gen_filestats(basepath):
    """Collects metadata about a directory tree.
    
    Arguments:
    basepath -- root directory to start from

    Returns:
    Tuple with list of file names and list of
    stat results."""

    filenames = []
    filestats = []
    
    for root, dirs, files in os.walk(basepath):
        for f in files:
            fullname = join(root, f)
            filenames.append(fullname)
            filestats.append(os.lstat(fullname))
    return (filenames, filestats)


def _calc_clusters(data, eps, minsamples):
    samples = np.array(data)
<span class="strong"><strong>    db = DBSCAN(eps=eps, min_samples=minsamples).fit(samples)</strong></span>
    return (db.labels_, db.core_sample_indices_)

def calc_atime_clusters(stats, days=1, mincluster=5):
    """Clusters files regarding to their 'last access' date.

    Arguments:
    stats -- file metadata as returned as 2nd element by gen_filestats
    days  -- approx. size of a cluster (default: accessed on same day)
    mincluster -- min. number of files to make a new cluster

    Returns:
    Tuple with array denoting cluster membership
    and indexes of representatives of cluster cores"""

    atimes = map(lambda x: [x.st_atime], stats)
    return _calc_clusters(atimes, days * 24 * 3600, mincluster)

def calc_mtime_clusters(stats, days=1, mincluster=5):
    """Clusters files regarding to their 'last modified' date.

    Arguments:
    stats -- file metadata as returned as 2nd element by gen_filestats
    days  -- approx. size of a cluster (default: accessed on same day)
    mincluster -- min. number of files to make a new cluster

    Returns:
    Tuple with array denoting cluster membership
    and indexes of representatives of cluster cores"""

    mtimes = map(lambda x: [x.st_mtime], stats)
    return _calc_clusters(mtimes, days * 24 * 3600, mincluster)


def calc_histogram(labels, core_indexes, timestamps):
    # reserve space for outliers (label -1), even if there are none
    num_entries = len(set(labels)) if -1 in labels else len(set(labels))+1

    counters = [0] * num_entries
    coredates = [0] * num_entries
    
    for c in core_indexes:
        i = int(c)
        coredates[int(labels[i])+1] = timestamps[i]

    for l in labels:
        counters[int(l)+1] += 1

    return zip(coredates, counters)

def print_histogram(histogram):
    # sort histogram by core time stamps
    sort_histo = sorted(histogram, cmp=lambda x,y: cmp(x[0],y[0]))

    print '[date around] [number of files]'
    for h in sort_histo:
        if h[0] == 0:
            print '&lt;outliers&gt;',
        else:
            t = date.fromtimestamp(h[0]).isoformat()
            print t,
        print '    %6d' % h[1]
        
    

if __name__ == '__main__':
    if len(sys.argv) &lt; 2:
        print 'Usage %s base_directory [number of days in one cluster]' % sys.argv[0]
        sys.exit(1)

    days = 1
    if len(sys.argv) &gt; 2:
        days = int(sys.argv[2])

    names, stats = gen_filestats(sys.argv[1])

    print '%d files to analyze...' % len(names)

    atime_labels, atime_cores = calc_atime_clusters(stats, days)
    mtime_labels, mtime_cores = calc_mtime_clusters(stats, days)

    atimes = map(lambda x: x.st_atime, stats)
    mtimes = map(lambda x: x.st_mtime, stats)

    ahisto = calc_histogram(atime_labels, atime_cores, atimes)
    mhisto = calc_histogram(mtime_labels, mtime_cores, mtimes)

    print "\n=== Access time histogram ==="
    print_histogram(ahisto)

    print "\n=== Modification time histogram ==="
    print_histogram(mhisto)</pre></div><p>The <code class="literal">gen_filestats()</code> function is identical to the version used for the basic histograms in the previous section. The <code class="literal">calc_atime_clusters()</code> and <code class="literal">calc_mtime_clusters()</code> functions <a id="id258" class="indexterm"/>extract the access and modification time of the collected information and pass it on to the cluster generation in <code class="literal">_calc_clusters</code>. The <code class="literal">DBSCAN</code> is initialized with two parameters: the size of a cluster (<code class="literal">eps</code>, in seconds) and the minimum number of sample data that can make a cluster (<code class="literal">min_samples</code>). After the parameters of the algorithm are set, the data is fed in for the purpose of clustering via the <code class="literal">fit()</code> method.</p><p>The result of this clustering is a tuple that consists of <span class="strong"><strong>labels</strong></span> and a list of indices per label. A label correlates to a cluster that is found in the input data. Its value is the center, that is, the average date, of all dates of the cluster. The special label <code class="literal">-1</code> acts as a container for all the outliers, that is, all the data that could not be assigned to a cluster.</p><p>The <code class="literal">calc_histogram()</code> function counts the size of each cluster and returns the histogram, that is, the labels and the number of entries as two-dimensional array.</p><p>We can run this Python script on the <code class="literal">/sbin</code> directory, as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user@lab:~$ python timecluster.py /sbin</strong></span>
</pre></div><p>The output may look similar to the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>202 files to analyze...</strong></span>

<span class="strong"><strong>=== Access time histogram ===</strong></span>
<span class="strong"><strong>[date around] [number of files]</strong></span>
<span class="strong"><strong>&lt;outliers&gt;          0</strong></span>
<span class="strong"><strong>2015-05-24        202</strong></span>

<span class="strong"><strong>=== Modification time histogram ===</strong></span>
<span class="strong"><strong>[date around] [number of files]</strong></span>
<span class="strong"><strong>&lt;outliers&gt;         64</strong></span>
<span class="strong"><strong>2011-11-20          9</strong></span>
<span class="strong"><strong>2012-02-09          5</strong></span>
<span class="strong"><strong>2012-03-02          6</strong></span>
<span class="strong"><strong>2012-03-31         11</strong></span>
<span class="strong"><strong>2012-07-26          6</strong></span>
<span class="strong"><strong>2012-09-11         10</strong></span>
<span class="strong"><strong>2013-01-18         15</strong></span>
<span class="strong"><strong>2013-01-26          6</strong></span>
<span class="strong"><strong>2013-03-07          8</strong></span>
<span class="strong"><strong>2014-06-18         29</strong></span>
<span class="strong"><strong>2014-11-20          7</strong></span>
<span class="strong"><strong>2015-02-16         19</strong></span>
<span class="strong"><strong>2015-05-01          7</strong></span>
</pre></div><p>Here, the access time histogram shows only one entry, reflecting our previous scan of the directory. Furthermore, all the major system updates in the recent past are shown in the modification<a id="id259" class="indexterm"/> time histogram.</p><p>With this tool, the investigator is able to cluster the filesystem information in order to detect the scanning or extraction of the directories as well as the neglected security patches. Furthermore, the special cluster -1 can be analyzed to get the names of the files, which were modified outside of the major system updates.</p></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec18"/>Summary</h1></div></div></div><p>In this chapter, we saw prominent examples of the special properties of Microsoft Windows and Linux (and Linux-like) systems. You are now able to extract information from the Windows event log, the Windows registry, Linux files, and the Linux filesystem. Using Python, all of this information can be automatically and semiautomatically analyzed for the Indicators of Compromise, reconstructing the recent system activity, and signs of exfiltration.</p><p>Furthermore, reading the filesystem capabilities shows us how to use ctype to load the native libraries to assist the filesystem analysis.</p><p>In the clustering of file information, we provided the first example on how to use the basic machine learning algorithms to support the forensic analysis.</p><p>Now that we took a look at the local systems, we will go to the next chapter and take a look at the network traffic and how to search for the Indicators of Compromise (IOC) there.</p></div></body></html>