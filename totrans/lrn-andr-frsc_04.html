<html><head></head><body><div><h1 class="header-title">Extracting Data Logically from Android Devices</h1>
                
            
            
                
<p>This chapter will cover logical data extraction, using free and open source tools wherever possible. The majority of the material covered in this chapter will use the <strong>Android Debug Bridge</strong> (<strong>ADB</strong>) methods previously discussed in <a href="b81853c6-388b-4e15-b8dd-deb5c1b5b36d.xhtml" target="_blank">Chapter 2</a>,<em> Setting Up the Android Forensic Environment</em>.</p>
<p>By the end of this chapter, the reader should be familiar with the following:</p>
<ul>
<li>Logical extraction overview</li>
<li>Manual ADB data extraction</li>
<li>ADB backup extractions</li>
<li>ADB dumpsys</li>
<li>Bypassing Android lock screens</li>
<li>Android SIM card extractions</li>
</ul>


            

            
        
    </div>



  
<div><h1 class="header-title">Logical extraction overview</h1>
                
            
            
                
<p>In digital forensics, the term logical extraction is typically used to refer to extractions that don't recover deleted data or do not include a full bit-by-bit copy of the evidence. However, a more correct definition of logical extraction, also defined in <a href="1e7a3a23-96c6-4085-9981-44b579bb2a7f.xhtml" target="_blank">Chapter 1</a>, <em>Introducing Android Forensics</em>, is any method that requires communication with the base operating system. Because of this interaction with the operating system, a forensic examiner cannot be sure that they have recovered all of the data possible; the operating system is choosing which data it allows the examiner to access. In traditional computer forensics, logical extraction is analogous to copying and pasting a folder in order to extract data from a system; this process will only copy files that the user can access and see. If any hidden or deleted files are present in the folder being copied, they won't be in the pasted version of the folder.</p>
<p class="mce-root"/>
<p>As you'll see, however, the line between logical and physical extractions in mobile forensics is somewhat blurrier than in traditional computer forensics. For example, deleted data can routinely be recovered from logical extractions on mobile devices due to the prevalence of SQLite databases being used to store data. Furthermore, almost every mobile extraction will require some form of interaction with the operating Android OS; there's no simple equivalent to pulling a hard drive and imaging it without booting the drive. For our purposes, we will define a logical extraction as the process that obtains data visible to the user, and may include data that has been marked for deletion.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Root access</h1>
                
            
            
                
<p>When forensically analyzing an Android device, the limiting factor is often not the type of data being sought, but rather whether or not the examiner has the ability to access the data. Root access has been covered extensively in <a href="b81853c6-388b-4e15-b8dd-deb5c1b5b36d.xhtml" target="_blank">Chapter 2</a>, <em>Setting Up the Android Forensic Environment</em>, but it is important enough to warrant repetition. All of the data listed previously, when stored on the internal flash memory, is protected and requires root access to read. The exception to this is application data that is stored on the SD card, which will be discussed later in this book.</p>
<p>Without root access, a forensic examiner cannot simply copy information from the <kbd>/data</kbd> partition. The examiner will have to find some method of escalating privileges in order to gain access to the contacts, call logs, SMS/MMS, and application data. These methods often carry many risks, such as the potential to <em>destroy</em> or <em>brick</em> the device (making it unable to boot), and may alter data on the device in order to gain permanence.</p>
<p class="mce-root"/>
<p>The methods commonly vary from device to device, and there is no universal, one-click method to gain root access to every device. Commercial mobile forensic tools such as Oxygen Forensic Detective and Cellebrite UFED have built-in capabilities to temporarily and safely root many devices, but do not cover the wide range of all Android devices.</p>
<p>Throughout this chapter, we will make note of where root is required for each technique demonstrated.</p>
<div><p>The decision to root a device should be in accordance with your local operating procedures and court opinions in your jurisdiction. The legal acceptance of evidence obtained by rooting varies by jurisdiction.</p>
</div>


            

            
        
    </div>



  
<div><h1 class="header-title">Manual ADB data extraction</h1>
                
            
            
                
<p>The <kbd>adb pull</kbd> command can be used to pull single files or entire directories directly from the device to the forensic examiner's computer. This method is especially useful for small, targeted examinations. For example, in an investigation strictly involving SMS messages, the examiner can choose to pull just the relevant files, if possible.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">USB Debugging</h1>
                
            
            
                
<p>Setting up the ADB environment has been previously discussed in this book. However, the device under examination must also be configured properly. USB Debugging is the actual method through which the examiner's computer will communicate with the device. USB Debugging is found under the Developer Options in the Settings menu. However, as of <strong>Android 8.1</strong>, the Developer Options menu is hidden; to reveal it, a user has to go to Settings | System | About Phone, and then tap the Build Number field seven times. Return to the previous screen—you will find that Developer Options are available now; simply open this menu and select Enable USB Debugging.</p>
<p>In addition to USB Debugging, the correct drivers must be installed on the examiner's computer. Generally, they can be found online, either from the manufacturer's website or <a href="https://www.xda-developers.com/">www.xda-developers.com</a>. If commercial forensic tools are installed on the machine, the appropriate drivers may already be installed.</p>
<p class="NormalPACKT">Prior to Android 4.2.2, enabling USB Debugging was the only requirement to communicate with the device over ADB. In Android 4.2.2, Google added <strong>Secure USB Debugging</strong>. Secure USB Debugging adds an additional requirement of selecting to connect to a computer on the device's screen; this prevents ADB access to locked devices from untrusted computers:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/9d5c70d9-8fea-4583-9a3f-133f1e7f0707.png" style="width:20.08em;height:15.92em;" width="278" height="220"/></p>
<p>RSA fingerprint dialog (Android 8.1)</p>
<p>Once USB Debugging has been enabled and the <strong>Secure USB Debugging</strong> check passed (depending on Android version), the device is ready for examination. To verify that the device is connected and ready to use ADB, execute the following command:</p>
<pre><strong>adb devices</strong></pre>
<p class="NormalPACKT">If Always allow from this computer is selected, the device will store the computer's RSA key and the prompt will not appear on future connections to that computer, even if the device is locked.</p>
<p class="NormalPACKT">If the device status is <strong>offline</strong> or <strong>unauthorized</strong>, the Secure Debugging prompt needs to be selected on the screen:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-619 image-border" src="img/dd866447-8b15-4375-8a82-cd36ad42782b.png" style="width:23.00em;height:3.08em;" width="338" height="45"/></p>
<p class="NormalPACKT">If everything is running correctly, the <strong>device</strong> status should show device like the following screen:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-620 image-border" src="img/87e986c1-fca8-4af6-9d36-263ebf78e32e.png" style="width:19.00em;height:3.08em;" width="279" height="45"/></p>


            

            
        
    </div>



  
<div><h1 class="header-title">Recovery Mode</h1>
                
            
            
                
<p>In order to truly be forensically sound, ADB data extractions shouldn't be used against a phone while it is turned on. While the device is running, timestamps can be modified and applications may be running and updating files in the background. To avoid this, an examiner should place the device into a custom Recovery Mode as shown in <a href="b81853c6-388b-4e15-b8dd-deb5c1b5b36d.xhtml" target="_blank">Chapter 2</a>, <em>Setting Up the Android Forensic Environment</em>, if possible. ADB access isn't available through the stock Android Recovery Mode. Typically, the first step in the rooting process is to flash a custom Recovery Mode to allow a method for repairing the device if something goes wrong. Rooted devices are far more likely to contain a custom recovery, but it is possible to flash a custom recovery to a non-rooted device. This method also allows the examiner to avoid the Secure USB Debugging prompt on newer versions of Android, although our testing shows that this does not work on Android Lollipop and versions newer than that. Recovery Mode also may not require USB Debugging to be enabled, which makes it an excellent option for bypassing a locked device.</p>
<div><p>This method won't work on devices with full disk encryption enabled. Booting into Recovery Mode will not decrypt the <kbd>/data</kbd> partition.</p>
</div>
<p>The process to boot into Recovery Mode will vary for each device. Typically, it involves some combination of powering the device off and holding the volume and power keys. Guides for specific models can be easily found online.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The stock Recovery Mode will typically show a picture of an Android being operated on:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-875 image-border" src="img/a50ec078-0d64-4665-b9c0-63078baf29d1.png" style="width:17.58em;height:31.33em;" width="300" height="300"/></p>
<p>Stock Recovery Mode</p>
<p>It's important to note that stock recoveries will not allow ADB communication; running <kbd>adb devices</kbd> will simply show no devices.</p>
<div><p>Custom recovery images for many devices can be found at the following:</p>
<p><a href="https://twrp.me/Devices/">https://twrp.me/Devices/</a></p>
</div>
<p>If a device is in a custom Recovery Mode and the correct drivers have been installed on the examiner's computer, the device can be accessed via ADB as if it were live. Note that its status using the <kbd>adb devices</kbd> command now shows that it is in Recovery Mode:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-626 image-border" src="img/7e320edb-7122-4543-a8b9-afd4be72b0d2.png" style="width:39.00em;height:6.42em;" width="642" height="106"/></p>
<p class="NormalPACKT">There is one final step before the examiner can begin extracting data over ADB: the <kbd>/data</kbd> partition must be mounted in order to access user data. Some custom recoveries may mount this automatically, and others might not. If using <strong>Team Win Recovery Project</strong> images from the URLs shown previously, the <kbd>/data</kbd> partition can be mounted by selecting Mount and then selecting the <kbd>/data</kbd> partition as seen in the following steps. The recovery menu is generally either navigated by using the volume keys to move up and down and the power button to select, or may be touch-based depending on the custom recovery image used.</p>
<p class="NormalPACKT">For a TWRP recovery, follow these steps:</p>
<ol>
<li class="NormalPACKT">From the main recovery screen, select Mount:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-627 image-border" src="img/36af8c77-3d34-4516-bd74-8f122f7b6903.jpg" style="width:18.25em;height:31.25em;" width="550" height="941"/></p>
<ol start="2">
<li>After choosing Mount, select the partition(s) to be mounted:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-628 image-border" src="img/cbbdc3db-e25f-4fa4-9199-9c7ac080668e.jpg" style="width:23.00em;height:39.33em;" width="566" height="969"/></p>
<p class="NormalPACKT">Once the <kbd>/data</kbd> partition (and any other partition the examiner wants to investigate) is mounted, the examiner can perform ADB data extractions, as demonstrated earlier in this chapter.</p>
<p>On many devices running Android 6.0 (Marshmallow) or higher, the userdata partition is encrypted by default, so it's impossible to mount and image it using custom recovery.</p>
<p class="NormalPACKT">If the device does not have a custom recovery, the following section will show how to boot into one or flash it.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Booting to a custom recovery image</h1>
                
            
            
                
<p>Once the bootloader is determined to be unlocked, an examiner will need a custom recovery image from which to boot. An excellent source of recovery images is <a href="https://twrp.me/Devices/">https://twrp.me/Devices/</a>. </p>
<p>It is absolutely critical to select the correct recovery image for the device being examined; they aren't interchangeable and booting from the wrong image may brick the device.</p>
<p class="mce-root">Once a recovery image is selected and downloaded, the device needs to be placed into fastboot mode. This can be accomplished using one of two ways:</p>
<ul>
<li>ADB</li>
<li>Physical device buttons</li>
</ul>
<p>To enter fastboot on a device over ADB, the device must already have USB Debugging enabled. The following is the command to enter fastboot mode over ADB:</p>
<pre><strong>adb reboot bootloader</strong></pre>
<p>If USB Debugging cannot be enabled or ADB cannot be used, there is also typically a combination of buttons to press while the device is booting, similar to entering Recovery Mode. The exact combination can be found online for each device specifically.</p>
<p>Once the device is in fastboot mode, running the following command will verify the device is connected and ready to communicate:</p>
<pre><strong>fastboot devices</strong></pre>
<p>The following command will load the custom recovery image into RAM and boot the device into Recovery Mode:</p>
<pre><strong>fastboot boot 'path to image'</strong></pre>
<p>The device should now reboot and enter Recovery Mode. As shown in the Recovery Mode section, the <kbd>/data</kbd> partition may need to be mounted in order to access user data.</p>
<p>If the fastboot boot command fails, it is a likely indicator that the device's bootloader is locked.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Using adb shell to determine if a device is rooted</h1>
                
            
            
                
<p>The simplest method to determine if a device is rooted is to use <kbd>adb shell</kbd>. This will open a shell on the device that will be accessed on the examiner's computer; this means that any commands run in the shell will be executed on the device. Once USB Debugging is enabled and Secure USB Debugging is bypassed (or from Recovery Mode, as discussed later), open a Terminal on the local computer and run the following:</p>
<pre><strong>adb shell</strong></pre>
<p>The shell will appear in one of two ways, either with <kbd>$</kbd> or <kbd>#</kbd>:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-621 image-border" src="img/43070d85-ac6b-483a-80f3-9975b13170f7.png" style="width:39.08em;height:3.25em;" width="594" height="49"/></p>
<p>On Linux systems, <kbd>#</kbd> is used to indicate a root user; <kbd>$</kbd> indicates a non-root user. If the shell returns showing <kbd>#</kbd>, the shell has root access:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-622 image-border" src="img/5ecfd6ee-9ba2-4e8c-a0a1-7dec4eb37705.png" style="width:36.92em;height:3.92em;" width="591" height="63"/></p>
<p>One further step may be required on some rooted devices. If the shell returns <kbd>$</kbd>, try running the <kbd>su</kbd> command (as you can see in the previous screenshot):</p>
<pre><strong>su</strong></pre>
<p>If the <kbd>su</kbd> binary is installed on the device, which is usually a part of the rooting process, this will escalate the shell's permissions to root if it did not open with them.</p>
<div><p>Note that some older devices automatically ran the shell as root; simply opening the <kbd>adb shell</kbd> may be enough to give an examiner root access.</p>
</div>


            

            
        
    </div>



  
<div><h1 class="header-title">adb pull</h1>
                
            
            
                
<p class="NormalPACKT">As discussed in <a href="b81853c6-388b-4e15-b8dd-deb5c1b5b36d.xhtml" target="_blank">Chapter 2</a>,<em> Setting Up the Android Forensic Environment</em>, <kbd>adb pull</kbd> is used to transfer files from the device to the local workstation. The following show the format for the <kbd>adb pull</kbd> command:</p>
<pre><strong>adb pull [-p] [-a] &lt;remote&gt; [&lt;local&gt;]</strong></pre>
<p class="NormalPACKT">The optional <kbd>–p</kbd> flag shows the transfer's progress, while the optional <kbd>–a</kbd> flag will copy the file's timestamp and mode. The <kbd>&lt;remote&gt;</kbd> parameter is the exact path to the file on the device. The optional <kbd>&lt;local&gt;</kbd> parameter is the path where the file will be written on the examiner's workstation. If no local path is specified, the file will be written to the current working directory. An example <kbd>adb pull</kbd> command may look like the following:</p>
<pre><strong>adb pull –p /sdcard/Pictures/1.png D:\Test<br/></strong></pre>
<p>Let's look at the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-623 image-border" src="img/567160da-b1df-439c-a0df-62edb511d61a.png" style="width:74.00em;height:4.33em;" width="888" height="52"/></p>
<p class="NormalPACKT">This command would pull an image file from the device and write it to a directory of our choice. Again, note that the device must be rooted if you want to pull, for example, the <kbd>mmssms.db</kbd> database (which contains sent and received SMS and MMS); otherwise, the output would simply show that <kbd>0</kbd> files were pulled.</p>
<p>The output shows that the file is <kbd>599401</kbd> bytes in size. As a result of our command, <kbd>1.png</kbd> now resides in the <kbd>Test</kbd> folder.</p>
<p class="NormalPACKT">Similarly, if an investigator wishes to pull the files for an entire application, that can be done with <kbd>adb pull</kbd> also:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-624 image-border" src="img/259c3f29-51b5-4682-bb62-70317a639e01.png" style="width:70.42em;height:3.92em;" width="845" height="47"/></p>
<p class="NormalPACKT">This time, the <kbd>adb pull</kbd> command fetched every file in the <kbd>Pictures</kbd> directory. As you can see in the preceding screenshot, three files were pulled. The total size of the transfer is shown as <kbd>1310468</kbd> bytes.</p>
<p>It's even possible to do the following:</p>
<pre><strong>adb pull –p /data/data/ D:\Test</strong></pre>
<p>This would pull every logical file available from the <kbd>/data/data</kbd> directory and put them in the examiner's <kbd>Test</kbd> folder. This is not equivalent to a physical image, as certain files are skipped and deleted files will not be copied, but it is a simple method for pulling the vast majority of a user's application data.</p>
<p>Another advantage of the <kbd>adb pull</kbd> command is that it is highly useful for scripting purposes. A knowledgeable examiner can maintain a list of paths for common files of interest, and write a script that automatically pulls these files from a device, or even have the script automatically pull the entire <kbd>/data/data</kbd> directory. The following is a simple example of Python code that will perform this function:</p>
<pre>from subprocess import Popen<br/>from os import getcwd<br/>command = "adb pull /data/data " + getcwd() + "\data_from_device"<br/>p = Popen(command)<br/>p.communicate()</pre>
<p>Note that the code is not very refined; it's only purpose is to illustrate the ease with which <kbd>adb</kbd> commands can be scripted. At the very least, properly implementing the code should include the option to specify an output directory and handle any errors. However, the six lines shown previously would be sufficient to pull the entire <kbd>/data/data</kbd> directory logically, assuming USB Debugging is enabled and the device is rooted.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Fastboot mode</h1>
                
            
            
                
<p>Fastboot is another protocol utility built into the Android Software Development Kit, and is used for interacting directly with a device's bootloader. Essentially, it is a much lower-level version of ADB and is frequently used to flash new images to a device. How can this be helpful to an examiner?</p>
<p>Fastboot can allow an examiner to boot from a custom recovery image and temporarily gain root access on a device, hence gaining access to data that would have been unavailable otherwise. Fastboot does not require USB Debugging to be enabled or root access. The process of loading a custom bootloader onto a device is commonly used by commercial forensic tools to temporarily root a device, but a skilled examiner can also perform the process manually. Using this method, the recovery image is loaded into RAM; no permanent data on the device is altered in any way.</p>
<p>The most important requirement for using fastboot is an unlocked bootloader; locked bootloaders will not allow a device to boot from code that isn't specifically signed by the manufacturer. Unfortunately for forensic purposes, most devices no longer ship with an unlocked bootloader as it is a serious security risk, and manually unlocking a bootloader typically erases the user data. As such, the amount of devices for which this is a feasible method is somewhat limited. But, when it works, it's an absolutely invaluable tool for an examiner to have in their arsenal.</p>
<div><p>This method will not work on devices with full disk encryption enabled. Booting into Recovery Mode will NOT decrypt the <kbd>/data</kbd> partition.</p>
</div>


            

            
        
    </div>



  
<div><h1 class="header-title">Determining bootloader status</h1>
                
            
            
                
<p>Much like everything involving Android forensics, there is no one guaranteed method to determine whether a bootloader is locked, as it varies by manufacturer. To boot into the bootloader, use the <kbd>adb</kbd> command:</p>
<pre><strong>adb reboot bootloader</strong></pre>
<p>The device should boot to a screen that shows information regarding the bootloader. Frequently, this screen will display the bootloader status, as seen in the following screenshot.</p>
<p>The following is a generic, stock fastboot menu from a Nexus 5. Note that the Lock State indicates that the bootloader is unlocked:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-629 image-border" src="img/a082e8a5-f6ec-408f-bd1b-27b20591b880.png" style="width:24.17em;height:40.33em;" width="612" height="1020"/></p>
<p>The following is a standard Samsung Odin mode screen; Odin is the Samsung proprietary equivalent to fastboot:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-876 image-border" src="img/12a786e6-268d-4f00-b862-593292ad668d.png" style="width:25.50em;height:45.92em;" width="1672" height="2140"/></p>
<p>Samsung Odin mode screen</p>


            

            
        
    </div>



  
<div><h1 class="header-title">ADB backup extractions</h1>
                
            
            
                
<p>Google implemented ADB backup functionality beginning in Android 4.0, Ice Cream Sandwich. This allows users (and forensic examiners) to back up application data to a local computer over ADB. This process does not require root and is therefore highly useful for forensic purposes. However, it does not acquire every application installed on the device. When a developer makes a new app, it is set to allow backups by default, but this can be changed by the developer. In practice, it seems the vast majority of developers leave the default setting, which means that backups do capture most third-party applications. Unfortunately, most Google applications disable backups; full application data from apps such as Gmail and Google Maps won't be included. The same can be said about most messengers—its data isn't available in ADB backups.</p>
<div><p>This method will not be useful against a locked device; user interaction with the screen is required.</p>
</div>


            

            
        
    </div>



  
<div><h1 class="header-title">Extracting a backup over ADB</h1>
                
            
            
                
<p>The format of the <kbd>adb backup</kbd> command is shown in the following command:</p>
<pre><strong>adb backup [-f &lt;file&gt;] [-apk|-noapk] [-obb|-noobb] [-shared|-noshared] [-all] [-system|-nosystem] [&lt;packages...&gt;]</strong></pre>
<p>The flags are as follows:</p>
<ul>
<li><kbd>-f</kbd>: Name the path for the output file. If not specified, defaults to <kbd>backup.ab</kbd> in the present working directory.</li>
<li><kbd>[-apk|noapk]</kbd>: Choose whether or not to back up the <kbd>.apk</kbd> file. Defaults to <kbd>–noapk</kbd>.</li>
<li><kbd>[-obb|-noobb]</kbd>: Choose whether or not to back up <kbd>.obb</kbd> (APK expansion) files. Defaults to <kbd>–noobb</kbd>.</li>
</ul>
<ul>
<li><kbd>[-shared|-noshared]</kbd>: Choose whether or not to back up data from shared storage and the SD card. Defaults to <kbd>–noshared</kbd>.</li>
<li><kbd>[-all]</kbd>: Include all applications for which backups are enabled.</li>
<li><kbd>[-system|-nosystem]</kbd>: Choose whether or not to include system applications. Defaults to <kbd>–system</kbd>.</li>
<li><kbd>[&lt;packages&gt;]</kbd>: Explicitly name application packages to be backed up. Not needed if using <kbd>–all</kbd> or <kbd>–shared</kbd>.</li>
</ul>
<p class="mce-root"/>
<p>An example <kbd>adb backup</kbd> command to capture all possible application data would be the following:</p>
<pre><strong>adb backup –f C:/Users/0136/Test/backup.ab –shared –all</strong></pre>
<p>Alternatively, an example <kbd>adb backup</kbd> command to capture a specific application's data would be the following:</p>
<pre><strong>adb backup –f C:/Users/0136/Test/facebook.ab com.facebook.katana</strong></pre>
<p>You should see something like the following:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-631 image-border" src="img/b0ac308c-f817-4cb5-a547-c43130d3cc78.png" style="width:33.08em;height:3.25em;" width="470" height="46"/></p>
<p>When performing a backup, the user must approve the backup on the device; this means that backups can't be performed without bypassing screen locks:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-632 image-border" src="img/02ac4074-080f-4efd-93f2-c742b1abb328.png" style="width:22.92em;height:40.75em;" width="720" height="1280"/></p>
<p>Depending on the number of applications installed, the backup process may take a significant amount of time.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Parsing ADB backups</h1>
                
            
            
                
<p>The resulting backup data is stored as a <kbd>.ab</kbd> file, but is actually a TAR file that has been compressed with the Deflate algorithm. If a password was entered on the device when the backup was created, the file would also be AES encrypted. It should also be mentioned that these files may exist on a suspect's computer and can be analyzed using the same methods.</p>
<p>There are many free utilities to turn the <kbd>.ab</kbd> backup file into a <kbd>.tar</kbd> file that can be viewed. One such utility is the Android Backup Extractor found at: <a href="http://sourceforge.net/projects/adbextractor/">http://sourceforge.net/projects/adbextractor/</a>.</p>
<p>To use the Android Backup Extractor, simply extract its files into the directory with the backup. The command to run the utility is shown in the following:</p>
<pre><strong>java –jar abe.jar unpack backup.ab backup.tar</strong></pre>
<p class="mce-root">The <kbd>.tar</kbd> file will be at the path specified on the command line, or the current working directory if no path is specified. Decompressing the <kbd>.tar</kbd> file may be done manually on a Linux command line or with one of the many Windows archive utilities such as WinRAR or 7Zip:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-633 image-border" src="img/2d749204-152f-4ac0-81b3-cd415a70c053.png" style="width:37.17em;height:36.67em;" width="585" height="578"/></p>
<p>Directories within the backup, seen in 7-Zip</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Data locations within ADB backups</h1>
                
            
            
                
<p>Now that the backup has been converted into a <kbd>.tar</kbd> file and then extracted, the examiner can view the data contained in the backup. In our example, there are two directories found in the root of the backup:</p>
<ul>
<li>
<p><kbd>apps</kbd>: Contains data from <kbd>/data/data</kbd> for applications that were included in the backup</p>
</li>
<li>
<p><kbd>shared</kbd>: Contains all data from the SD card; only present if the shared argument was passed at the command line</p>
</li>
</ul>
<p class="mce-root">Note that the files within the apps directory are stored in directories by their package name (just as seen in <kbd>/data/data</kbd> from within <kbd>adb shell</kbd>), and the shared directory is exactly what the user would see if they accessed the SD card by plugging it into a computer. For a benign example of user data that was pulled from the backup, the user's Pandora activity is shown in the following screenshot. Pandora is a streaming music service with millions of downloads in Google Play Store. Pandora's application data will be contained in the <kbd>apps</kbd> folder of the backup, in the folder named <kbd>com.pandora.android</kbd>:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-634 image-border" src="img/809d7b2b-f3b8-46a1-aa2a-6a9ed6ef8fe4.png" style="width:40.25em;height:15.42em;" width="534" height="204"/></p>
<p>The Pandora directory from the backup</p>
<p>This is a fairly standard layout for an Android application, as discussed in <a href="b81853c6-388b-4e15-b8dd-deb5c1b5b36d.xhtml" target="_blank">Chapter 2</a>, <em>Setting Up the Android Forensic Environment</em>. The application's databases will be in the <kbd>db</kbd> folder:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-635 image-border" src="img/bfe83963-5518-4f97-a84d-09c2c7c6007e.png" style="width:39.92em;height:14.08em;" width="582" height="205"/></p>
<p>Files within the db folder of the Pandora backup</p>
<p>XML configuration settings will be in the <kbd>sp</kbd> folder:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-636 image-border" src="img/35199ac0-04c4-4cbc-83b4-43665869e176.png" style="width:37.17em;height:14.17em;" width="576" height="219"/></p>
<p>Files within the sp folder of the Pandora backup</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Using a database viewer to view <kbd>pandora.db</kbd> reveals stations that the user has created, as well as the timestamp for when it was created:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-637 image-border" src="img/1ac041dc-5ad7-45ce-961a-72672fcae7b2.png" style="width:44.17em;height:13.17em;" width="661" height="197"/></p>
<p>Contents of pandora.db from the backup</p>
<p>Looking in the XML preferences file, the timestamp of the app installation can be found under <kbd>firstInstallId</kbd>. Note that the exact method for converting the timestamps is shown in <a href="c0ffe5a3-4668-436d-9f02-e70a67f3e43e.xhtml" target="_blank">Chapter 7</a>, <em>Forensic Analysis of Android Applications</em>:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-638 image-border" src="img/12ce7e66-1696-4fa4-9380-4e66ac218577.png" style="width:30.50em;height:8.67em;" width="437" height="124"/></p>
<p>Contents of the XML preferences file</p>
<p>If, for some odd reason, the user's Pandora usage was a major question in the investigation, what could an examiner determine from these two seemingly innocuous files?</p>
<p>Firstly, the <kbd>lastTransmission</kbd> and <kbd>firstInstallID</kbd> timestamps are within milliseconds of each other, indicating that the application was never used after it was installed. Furthermore, the creation dates of each station precede the installation of the application, in some cases by years. This would be an indicator that the user has used Pandora on other devices; that may be highly relevant to the investigation.</p>
<p>While Pandora is generally not germane to digital forensic investigations, it is an example of data that can be gleaned from a simple backup over ADB. More detailed application analysis will be presented in <a href="c0ffe5a3-4668-436d-9f02-e70a67f3e43e.xhtml" target="_blank"/><a href="c0ffe5a3-4668-436d-9f02-e70a67f3e43e.xhtml" target="_blank">Chapter 7</a>,<em> Forensic Analysis of Android Applications</em>.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">ADB dumpsys</h1>
                
            
            
                
<p>Dumpsys is a tool built into the Android OS, generally used for development purposes to show the status of services running on the device. However, it can also contain forensically interesting information. Dumpsys does not require root access, but, like all ADB commands, does require USB Debugging to be enabled on the device and Secure USB Debugging to be bypassed.</p>
<p>The exact services that can be viewed differ across devices and Android versions. To view a list of all possible services that can be dumped, run the following command:</p>
<pre><strong>adb shell service list</strong></pre>
<p>The output of the command will appear as a list, as shown here:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-639 image-border" src="img/e784d64f-0f27-4782-873f-d56c506f405b.png" style="width:44.75em;height:32.33em;" width="627" height="453"/></p>
<p> </p>
<p>The service name located before the colon is the argument we will pass to <kbd>dumpsys</kbd>. A valid <kbd>dumpsys</kbd> command, using the previously seen service number seven (<kbd>iphonesubinfo</kbd>), looks like this:</p>
<pre><strong>adb shell dumpsys iphonesubinfo</strong></pre>
<p>In the following, we see that the output of the <kbd>iphonesubinfo</kbd> service includes the device IMEI:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-640 image-border" src="img/90db25f5-377b-45ec-a842-eb1b496721f0.png" style="width:20.08em;height:3.92em;" width="241" height="47"/></p>
<p>There are many forensically interesting <kbd>dumpsys</kbd> services; several examples follow. As the <kbd>dumpsys</kbd> services may vary by OS version and device, this list is not all-inclusive and is merely intended to show the usefulness of <kbd>dumpsys</kbd> to a forensic examiner:</p>
<ul>
<li><kbd>iphonesubinfo</kbd></li>
<li><kbd>batterystats</kbd></li>
<li><kbd>procstats</kbd></li>
<li><kbd>user</kbd></li>
<li><kbd>appops</kbd></li>
<li><kbd>wifi</kbd></li>
<li><kbd>notification</kbd></li>
</ul>


            

            
        
    </div>



  
<div><h1 class="header-title">Dumpsys batterystats</h1>
                
            
            
                
<p>Batterystats is used to show the usage of running applications. Its output can be very verbose, depending on the number of applications in use; in the following screenshot, the output was redirected to a file because it did not fit in the Windows command line:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-641 image-border" src="img/6042281c-036f-4dd6-9c66-faa5769aec16.png" style="width:72.17em;height:4.75em;" width="866" height="57"/></p>
<p>This shows us the network usage of Google Chrome. This information can be used to show that the application had been used recently, and this information will exist even if Chrome was used in Incognito Mode and leaves no forensic evidence elsewhere.</p>
<div><p>Note that the <em>Wakelock</em> section can be very useful for detecting malware. A wakelock is a method of keeping the device awake (that is, not entering sleep mode) and is indicative of an application attempting to stay running in the background.</p>
</div>


            

            
        
    </div>



  
<div><h1 class="header-title">Dumpsys procstats</h1>
                
            
            
                
<p>Procstats is a service to display the processor usage by running applications. Similar to batterystats, it is another method that can be used to show that an application was recently used on a device:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-642 image-border" src="img/588440f4-861d-4312-8e1c-ce21343993ac.png" style="width:35.25em;height:8.92em;" width="506" height="128"/></p>


            

            
        
    </div>



  
<div><h1 class="header-title">Dumpsys user</h1>
                
            
            
                
<p>Beginning with Android Jelly Bean, Google added support for multiple users on tablet devices. With the release of Lollipop, Google extended this support to phones. One of the most challenging problems in digital forensics has long been proving who was using a device when incriminating actions were performed, that is: <em>Who was behind the keyboard?</em></p>
<p>Running <kbd>dumpsys</kbd> on the user service will show the last login info for all users:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-643 image-border" src="img/37c4ea9a-a670-4e92-8cec-78c106e0faf8.png" style="width:26.25em;height:8.00em;" width="315" height="96"/></p>
<p>As only one user can be logged in at a time, looking at the user with the most recent login will identify the account currently in use on the device.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Dumpsys App Ops</h1>
                
            
            
                
<p>App Ops may be the most interesting <kbd>dumpsys</kbd> service. The term App Ops is generally used to refer to permissions accessible by an application. In older versions of Android, it was rumored that Google would include the ability for users to revoke specific permissions from an application. This has never come to fruition, but this service at least remains, and shows the last time an application used each permission that it can access. The following is another example from Google Chrome:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-644 image-border" src="img/cb3a903a-3bf8-4ee5-88a1-d45392b0a7f1.png" style="width:50.58em;height:15.08em;" width="607" height="181"/></p>
<p>In the preceding output, we can see that approximately 1 hour and 7 minutes before <kbd>appops</kbd> was dumped with <kbd>dumpsys</kbd>, Chrome used the <kbd>TAKE_AUDIO_FOCUS</kbd> permission, and later used <kbd>AUDIO_MEDIA_VOLUME</kbd>. This indicates that Chrome was used to listen to something, and when it happened.</p>
<p>A somewhat more interesting example is the phone application:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-645 image-border" src="img/9b8ad528-1e68-43a3-9104-7100fc03fd02.png" style="width:51.33em;height:16.33em;" width="616" height="196"/></p>
<p>44 minutes ago, the user used the phone application and required the <kbd>READ_CONTACTS</kbd> permission, then immediately also used the <kbd>WRITE_CALL_LOG</kbd> permission. We can surmise that the user made a phone call 44 minutes ago; even if they had deleted the call from the records afterwards.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Dumpsys Wi-Fi</h1>
                
            
            
                
<p>The Wi-Fi service will show a list of all SSIDs for which a connection has been saved. This could be useful for showing that a user was in a certain location, for example. More detailed Wi-Fi information is also available on the filesystem, but requires root access to view. Using <kbd>dumpsys</kbd>, we can access this data without requiring root:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-646 image-border" src="img/0993e64f-466c-4b7b-b2b1-c013c49ae333.png" style="width:52.08em;height:20.33em;" width="625" height="244"/></p>


            

            
        
    </div>



  
<div><h1 class="header-title">Dumpsys notification</h1>
                
            
            
                
<p>The notification service will provide information about currently active notifications. This can be useful for recording the state of a device when it is seized or identifying which application is displaying a specific notification. Each notification can be rather large and contain a lot of information, only some of which may be of use. The following is an example of an incoming email from the Gmail application, which includes the subject (<kbd>This is a test email</kbd>) and body (<kbd>To see a test notification</kbd>):</p>
<p class="mce-root"/>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-648 image-border" src="img/3967c31b-71f5-4860-a334-7b7f13dd0c35.png" style="width:54.25em;height:46.17em;" width="651" height="554"/></p>
<p> </p>


            

            
        
    </div>



  
<div><h1 class="header-title">Dumpsys conclusions</h1>
                
            
            
                
<p>Running the <kbd>dumpsys</kbd> command with no service name will run <kbd>dumpsys</kbd> on all available services. However, the output will be very large and should be redirected into a text file. On most platforms, the command to do this would be the following:</p>
<pre><strong>adb shell dumpsys &gt; dumpsys.txt</strong></pre>
<p>This would write the output to <kbd>dumpsys.txt</kbd> in the current working directory. The output can then be searched or a parsing script can be run to pull out known relevant fields.</p>
<p>Dumpsys is an extremely powerful tool that can be used to show information that cannot be obtained elsewhere on the device. We recommend running <kbd>dumpsys</kbd> on every Android device when it is seized, prior to being shut down. This will save a wide variety of information that may be useful later, and does not require root.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Helium backup extractions</h1>
                
            
            
                
<p>According to its developers, Helium is the <em>missing app sync and backup solution for Android</em>. It doesn't require root access and can be used to extract some data that ADB backup can't; for example, SMS messages and call logs.</p>
<p>Actually, there are two apps that an examiner will need: an Android app and a PC app. The Android app can be downloaded from Google Play:</p>
<p><a href="https://play.google.com/store/apps/details?id=com.koushikdutta.backup">https://play.google.com/store/apps/details?id=com.koushikdutta.backup</a>.</p>
<p>The desktop version is available here:</p>
<p><a href="http://www.clockworkmod.com/carbon">http://www.clockworkmod.com/carbon</a>.</p>
<p>Let's follow these steps for extracting the data:</p>
<ol>
<li>Once you open the Android app, you'll see the following screen:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-649 image-border" src="img/7ba24af0-9176-4301-b022-88981ffe09a4.png" style="width:41.50em;height:23.33em;" width="1280" height="720"/></p>
<ol start="2">
<li>Open the desktop app and enable Helium. You will see a message that says Helium has been enabled on your Android.</li>
<li>You can choose the data you want to backup; in our case, it's messages and call logs:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-650 image-border" src="img/d0b11512-6274-49a4-bf88-2b936e8a14c9.png" style="width:27.33em;height:48.67em;" width="720" height="1280"/></p>
<ol start="4">
<li>As we want to save the backup to our forensic workstation, let's go to the menu in the upper-right corner and choose the appropriate option, PC Download:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-651 image-border" src="img/7154414c-544f-4758-a926-1443ee16cc51.png" style="width:21.75em;height:10.50em;" width="720" height="348"/></p>
<ol start="5">
<li>Check the IP address and port the Helium Server is running on; in our case, it's <kbd>192.168.1.71</kbd> and <kbd>5000</kbd>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-652 image-border" src="img/7d5cfe41-0e6e-4fc5-9411-e9632ef0472f.png" style="width:15.75em;height:28.00em;" width="720" height="1280"/></p>
<p class="mce-root"/>
<p class="mce-root"/>
<ol start="6">
<li>Access the address from your web browser of choice, choose the applications you want to back up, and click Start Backup:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-653 image-border" src="img/31e7b13b-bcbc-41d7-8e79-baa894fd43ad.png" style="width:28.92em;height:15.08em;" width="1136" height="593"/></p>
<p>In your default downloads folder you'll find a ZIP archive with the following name: <kbd>backup.zip</kbd>. </p>
<p>There are three files in the archive:</p>
<ul>
<li><kbd>backup.json</kbd>: It contains information about the backup, such as package name, backup date, and smartphone's OS version.</li>
<li><kbd>com.android.providers.telephony.ab</kbd>: It is a backup itself and contains extracted data, in our case, SMS and call logs.</li>
<li><kbd>com.android.providers.telephony.png</kbd>: It backed up the application's icon.</li>
</ul>
<p>Again, to extract the contents of <kbd>com.android.providers.telephony.ab</kbd>, we need to use one of the utilities from Android Backup Toolkit (<a href="https://sourceforge.net/projects/adbextractor/">https://sourceforge.net/projects/adbextractor/</a>), this time Helium Backup Extractor:</p>
<pre><strong>java -jar hbe.jar -force com.android.providers.telephony.ab</strong></pre>
<p>Now, in the current working directory, there is an <kbd>app</kbd> folder, where under <kbd>apps\com.android.providers.telephony\cb</kbd> we can find the <kbd>custom.cb</kbd> file. This file contains backed up application data in JSON format; here is an example:</p>
<pre>{"number":"+79165555555","new":1,"duration":10,"date":1540479309458,"type":1}</pre>
<p>The <kbd>number</kbd> field shows the phone number, the <kbd>new</kbd> field (if the call is recent or not), <kbd>duration</kbd> (call duration), <kbd>date</kbd> (call date in Unix Epoch format—milliseconds), and <kbd>type</kbd> (type of the call); in our case, it's <kbd>1</kbd>, incoming.</p>
<p>Of course, this method may not seem to be very forensically sound as we have to install an app on the target mobile device, but sometimes it's the only way to extract valuable digital evidence. What is more, many commercial mobile forensic tools use small applications, so-called <strong>agents</strong>, to extract more data during logical acquisition. You'll learn more about Android forensic tools in <a href="1b4c4086-f708-4bea-9bb4-f2f477b10c85.xhtml" target="_blank">Chapter 8</a>, <em>Android Forensic Tools Overview</em>.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Bypassing Android lock screens</h1>
                
            
            
                
<p>Lock screens are the most challenging aspect of Android forensic examinations. Frequently, the entire investigation depends on the examiner's ability to gain access to a locked device. While there are methods to bypass them, this can be highly dependent on the OS version, device settings, and technical capabilities of the examiner. There is no magical solution that will work every time on every device. Commercial forensic tools such as Cellebrite and Oxygen have fairly robust bypass capabilities, but are far from infallible. This chapter will show how an examiner can increase their odds of bypassing locked devices with free tools and methods.</p>
<div><p>An examiner should never attempt to guess a pattern/PIN/password on the device. Many manufacturers implement a setting that will wipe the device after a number of failed attempts. Many also allow the user to lower that number.</p>
</div>


            

            
        
    </div>



  
<div><h1 class="header-title">Lock screen types</h1>
                
            
            
                
<p>There are many methods used to secure a device, and the methods for bypassing each vary:</p>
<ul>
<li>None/slide</li>
<li>Pattern</li>
<li>PIN</li>
<li>Password</li>
<li>Smart Lock: Trusted Face, Trusted Voice, Trusted Location, Trusted Device, On-body Detection</li>
</ul>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Other security options may exist; as Android is open source, the possibilities are only limited by the developer's imagination. These are the options that are available in the stock version of Android Oreo released by Google. Most security options used by vendors generally use one of these stock options as a failsafe in case a user is unable to log in with their unique options. Versions in which the setting was first used also refer to stock Android; various manufacturers may have implemented them sooner.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">None/Slide lock screens</h1>
                
            
            
                
<p>The <em>Slide to unlock</em> screen is the default setting of most Android devices. It provides no level of security, and is bypassed by sliding a finger on the screen in the indicated direction.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Pattern lock screens</h1>
                
            
            
                
<p>Pattern lock screens are the iconic Android security method. Frequently referred to as <em>swipe codes</em> or similar names, these require the user to trace a pattern on the device with a finger. A common bypass for this lock is the <em>smudge attack</em>, looking for patterns left on the screen by the user's finger.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Password/PIN lock screens</h1>
                
            
            
                
<p>Users familiar with Apple's iOS will recognize this option. It requires a user to type a password or PIN in order to unlock the device. These are lumped together because, forensically, they are identical: they store their passwords the same way.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Smart Locks</h1>
                
            
            
                
<p>Smart Lock is a term introduced in Android Lollipop, although the Face unlock option was previously available. They require a specific condition to unlock the device: a user's face must be recognized, the user must be in a known location, or a specific other device must be nearby.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Trusted Face</h1>
                
            
            
                
<p>Face unlock works exactly as it sounds: it uses facial recognition to determine if the user has been previously been set up as a trusted user. Older versions of Face locks were easily fooled by pictures of a trusted user, though newer versions may require the user to blink in order to unlock the device.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Trusted Voice</h1>
                
            
            
                
<p>The <strong>OK Google</strong> phrase can be used by the user to unlock the phone. This type of lock isn't available on many devices, as the phone has to actively listen for the user's voice while the screen is off, and it drains the battery.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Trusted Location</h1>
                
            
            
                
<p>Trusted Location is also commonly referred to as <strong>geo-fencing</strong>. If a user is in a location that has been marked as trusted (such as home or work), the device will not lock. There's no input required from the user, but the GPS must be enabled.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Trusted Device</h1>
                
            
            
                
<p>Trusted Device works via Bluetooth; if a device that has been set up as a trusted device is nearby, the lock screen will be disabled. This may be used with smart watches, vehicles that pair over Bluetooth, Bluetooth headsets, or any other Bluetooth–capable device.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">On-body Detection</h1>
                
            
            
                
<p>On-body Detection uses phone's motion sensors, for example, the accelerometer and gyroscope, to keep it unlocked while it's in the user's hand, pocket, or bag.</p>
<div><p>All Smart Lock options require a pattern/PIN/password as a backup security method. This means we only have to learn how to bypass patterns/PINs/passwords in order to crack all of the security options.</p>
</div>


            

            
        
    </div>



  
<div><h1 class="header-title">General bypass information</h1>
                
            
            
                
<p>In all cases, bypassing the lock screen will require retrieving a file from the device. Pattern locks are stored as hash values at <kbd>/data/system/gesture.key</kbd> and PIN/password locks are stored as hash values at <kbd>/data/system/password.key</kbd> (up to Android 5.0, Lollipop). Additionally, the <kbd>password.key</kbd> hash is salted; the salt value is stored at <kbd>/data/data/com.android.providers.settings/databases/settings.db</kbd> prior to Android 4.4, and <kbd>/data/system/locksettings.db</kbd> on devices running Android 4.4 and later. </p>
<p>Android 6.0 (Marshmallow) introduced Gatekeeper password storage—a new level of obfuscation to PIN and pattern locks. Now, the locks are stored in <kbd>gatekeeper.pattern.key</kbd> and <kbd>gatekeeper.password.key</kbd> and no longer use hashes. Gatekeeper uses <strong>Hash-based Message Authentication Code</strong> (<strong>HMAC</strong>) with a hardware-backed secret key to manage and verify passwords. </p>
<p>If the device is locked, how is an examiner supposed to access these files? Again, there is no magic solution that works every time, but some options are as follows:</p>
<ul>
<li>ADB:
<ul>
<li>Requires root</li>
<li>Requires USB Debugging</li>
<li>Requires Secure USB Debugging pairing (depending on OS version)</li>
</ul>
</li>
<li>Booting into a custom Recovery Mode:
<ul>
<li>Does not require root (root will be given through the recovery image)</li>
<li>Does not require USB Debugging (accomplished via fastboot)</li>
<li>Does not require Secure USB Debugging (this is bypassed entirely)</li>
<li>Requires an unlocked bootloader</li>
<li>Won't work on devices with encrypted userdata partition</li>
</ul>
</li>
<li>JTAG/Chip-off:
<ul>
<li>Highly advanced</li>
<li>Does not require any specific device settings or options</li>
<li>Won't work on devices with encrypted userdata partition</li>
</ul>
</li>
</ul>


            

            
        
    </div>



  
<div><h1 class="header-title">Removing Android lock screens</h1>
                
            
            
                
<div><p>PIN or password can be bypassed by simply overwriting or deleting the files. However, this is changing the original evidence and may not be forensically valid in your jurisdiction.</p>
</div>


            

            
        
    </div>



  
<div><h1 class="header-title">Removing PIN/password with ADB</h1>
                
            
            
                
<p class="mce-root">Depending on the device you are examining and its operating system version, you may need to delete different files. If the device contains <kbd>*.key</kbd> files under <kbd>/data/system/</kbd>, you need to remove these files; if there are no such files, you may need to remove <kbd>locksettings.db</kbd>, if possible, or update some of its records (see the next section).</p>
<p class="mce-root">Here is how to remove the files of interest via ADB:</p>
<pre class="mce-root"><strong>adb shell</strong><br/><strong>su</strong><br/><strong>cd /data/system</strong><br/><strong>rm *.key</strong></pre>
<p>Now the device should be rebooted. After the reboot, there will be no PIN or password.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Removing PIN/Password with ADB and SQL</h1>
                
            
            
                
<p class="mce-root">There are no <kbd>*.key</kbd> files on recent Android devices, such as those running Oreo or Pie, but there is still the <kbd>lockscreen.db</kbd> database under <kbd>/data/system</kbd>.</p>
<p>Here is how to remove the PIN or passwords for making changes in this database:</p>
<pre><strong>adb shell</strong><br/><strong>su</strong><br/><strong>cd /data/system</strong><br/><strong>sqlite3 locksettings.db</strong><br/><strong>update locksettings set value=0 where name='lockscreen.password_salt';</strong><br/><strong>update locksettings set value=0 where name='sp-handle';</strong><br/><strong>.quit</strong></pre>
<p>Reboot the device and the screen lock will be removed.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Android SIM card extractions</h1>
                
            
            
                
<p>Traditionally, SIM cards were used for transferring data between devices. SIM cards in the past were used to store many different types of data, such as the following:</p>
<ul>
<li>User data</li>
<li>Contacts</li>
<li>SMS messages</li>
<li>Dialed calls</li>
</ul>
<ul>
<li>Network data</li>
<li><strong>Integrated Circuit Card Identifier (ICCID)</strong>: Serial number of the SIM</li>
<li><strong>International Mobile Subscriber Identity (IMSI)</strong>: Identifier that ties the SIM to a specific user account</li>
<li><strong>MSISDN</strong>: Phone number assigned to the SIM</li>
<li><strong>Location Area Identity (LAI)</strong>: Identifies the cell that a user is in</li>
<li><strong>Authentication Key (Ki)</strong>: Used to authenticate the mobile network</li>
<li>Various other network-specific information</li>
</ul>
<p>With the rise in capacity of device storage, SD cards, and cloud backups, the necessity for storing data on a SIM card has decreased. As such, most modern smartphones typically do not store much, if any, user data on the SIM card. All network data listed previously does still reside on the SIM, as a SIM is necessary to connect to all modern (4G) cellular networks.</p>
<p>As with all Android devices, though, there is no concrete stipulation that user data can't be stored on a SIM; it simply doesn't happen by default. Individual device manufacturers can easily decide to write user data to the SIM, and individual users can download applications to provide that functionality. This means that a device's SIM card should always be examined during a forensic examination. It is a very quick process, and should never be overlooked.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Acquiring SIM card data</h1>
                
            
            
                
<p>The SIM card should always be removed from the device and examined separately. While some tools claim to read the SIM card through the device interface, this may not recover deleted data or all data on the SIM; the only way for an examiner to be certain all data was acquired is to read the SIM through a standalone SIM card reader with a tool that has been tested and verified.</p>
<p>The location of the SIM will vary by device, but is typically either stored beneath the battery or in a tray located on the side of the device. Once the SIM is removed, it should be placed in a SIM card reader. There are hundreds of SIM card readers available in the marketplace, and all major mobile forensics tools come with an included reader that will work with their software. Oftentimes, the forensic tools will also support third-party SIM readers as well.</p>
<p>There is a surprising lack of thorough, free SIM card reading software available. Any software used should always be tested and validated on a SIM card that has been populated with known data prior to being used in an actual forensic investigation. Also, keep in mind that much of the free software available works for older 2G/3G SIMs, but may not work properly on a modern 4G SIM. We used the Mobiledit! Lite, a free version of Mobiledit!, for the following screenshots. It is available at: <a href="http://www.mobiledit.com/downloads">http://www.mobiledit.com/downloads</a>.</p>
<p>The following is a sample 4G SIM card extraction from an Android phone running version 4.4.4; note that nothing that could be considered user data was acquired despite the SIM being used actively for over a year, though fields such as the ICCID, IMSI, and MSISDN (own phone number) could be useful for subpoenas/warrants or other aspects of an investigation:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-654 image-border" src="img/75f5fad3-33c1-4c76-ab6a-7435b4aefb0a.png" style="width:48.67em;height:32.75em;" width="584" height="393"/></p>
<p>SIM card extraction overview</p>
<p>The following screenshot highlights SMS messages on the SIM card:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-655 image-border" src="img/612ae554-6024-4fb9-8d06-c6f80491248a.png" style="width:39.08em;height:15.42em;" width="614" height="243"/></p>
<p>The following screenshot highlights the phonebook of the SIM card:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-656 image-border" src="img/d83c3405-4054-4d0a-8c8a-91964edea4c9.png" style="width:30.42em;height:11.17em;" width="503" height="185"/></p>
<p>The following screenshot highlights the phone number of the SIM card (also called the MSISDN):</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-657 image-border" src="img/97fb182c-d225-49d7-9aae-eee2f5db6695.png" style="width:35.00em;height:9.67em;" width="519" height="144"/></p>
<p class="mce-root"/>


            

            
        
    </div>



  
<div><h1 class="header-title">SIM Security</h1>
                
            
            
                
<p>Due to the fact that SIM cards conform to established, international standards, all SIM cards provide the same security functionality: a 4- to 8-digit PIN. Generally, this PIN must be set through a menu on the device. On Android devices, this setting is found at Settings | Security | Set up SIM card lock. The SIM PIN is completely independent of any lock screen security settings and only has to be entered when the device boots. The SIM PIN only protects user data on the SIM; all network information is still recoverable even if the SIM is PIN locked.</p>
<p>The SIM card will allow three attempts to enter the PIN; if one of these attempts are correct, the counter will reset. On the other hand, if all of these attempts are incorrect, the SIM will enter <strong>Personal Unblocking Key</strong> (<strong>PUK</strong>) mode. The PUK is an 8-digit number assigned by the carrier, and is frequently found on documentation when the SIM is purchased. Bypassing a PUK is not possible with any commercial forensic software; because of this, an examiner should never attempt to enter the PIN on the device as the device will not indicate how many attempts remain before the PUK is activated. An examiner could unwittingly PUK lock the SIM and be unable to access the device. Forensic tools, however, will show how many attempts remain before the PUK is activated, as seen in the previous screenshots.</p>
<p>Common carrier defaults for SIM PINs are 0000 and 1234. If three tries remain before activating the PUK, an examiner may successfully unlock the SIM with one of these defaults.</p>
<p>Carriers frequently retain PUK keys when a SIM is issued. These may be available through a subpoena or warrant issued to the carrier.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">SIM cloning</h1>
                
            
            
                
<p>The SIM PIN itself provides almost no additional security, and can easily be bypassed through SIM cloning. SIM cloning is a feature provided in almost all commercial mobile forensic software, although the term cloning is somewhat misleading. SIM cloning, in the case of mobile forensics, is the process of copying the network data from a locked SIM onto a forensically sterile SIM that does not have the PIN activated. The phone will identify the cloned SIM based on this network data (typically the ICCID and IMSI) and think that it is the same SIM that was inserted previously, but this time there will be no SIM PIN. This cloned SIM will also be unable to access the cellular network, which makes it an effective solution similar to Airplane Mode. Therefore, SIM cloning will allow an examiner to access the device, but the user data on the original SIM is still inaccessible as it remains protected by the PIN.</p>
<p>We are unaware of any free software that performs forensic SIM cloning. It is supported by almost all commercial mobile forensic kits, however. These kits will typically include a SIM card reader, software to perform the clone, as well as multiple blank SIM cards for the cloning process.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Summary</h1>
                
            
            
                
<p>This chapter has covered many topics related to logical extractions of Android devices. As a recap, the various methods and their requirements are as follows:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td>
<p><strong>Method</strong></p>
</td>
<td>
<p><strong>Requirements</strong></p>
</td>
</tr>
<tr>
<td>
<p>ADB pull</p>
<p> </p>
</td>
<td>
<ul>
<li>USB Debugging enabled</li>
<li>Secure USB Debugging bypassed on 4.2.2+</li>
<li>Root access to obtain user data</li>
</ul>
</td>
</tr>
<tr>
<td>
<p>ADB pull from Recovery Mode</p>
<p> </p>
</td>
<td>
<ul>
<li>Must be a custom recovery to enable ADB access</li>
<li>Root access to obtain user data</li>
</ul>
<p> </p>
</td>
</tr>
<tr>
<td>
<p>Fastboot to boot from custom recovery image</p>
<p> </p>
</td>
<td>
<ul>
<li>Unlocked bootloader</li>
<li>Boot image for device</li>
</ul>
<p> </p>
<p> </p>
</td>
</tr>
<tr>
<td>
<p>ADB backup</p>
<p> </p>
</td>
<td>
<ul>
<li>USB Debugging enabled</li>
<li>Secure USB Debugging bypassed on 4.2.2+</li>
<li>Must be done from a running device (not Recovery Mode)</li>
</ul>
<p> </p>
</td>
</tr>
<tr>
<td>
<p>ADB Dumpsys</p>
<p> </p>
</td>
<td>
<ul>
<li>USB Debugging enabled</li>
<li>Secure USB Debugging bypassed on 4.2.2+</li>
<li>Must be done from a running device (not Recovery Mode)</li>
</ul>
<p> </p>
</td>
</tr>
<tr>
<td>
<p>SIM card extraction</p>
<p> </p>
</td>
<td>
<ul>
<li>None, should be done independent of device</li>
</ul>
<p> </p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>Additionally, valuable user data can be recovered from the SD card, which will be covered in <a href="a910938e-1c0b-4f19-baae-509ccaa36c09.xhtml" target="_blank">Chapter 5</a>, <em>Extracting Data Physically from Android</em> <em>Devices</em>.</p>
<p>If a screen is locked, an examiner can remove the key files or remove some records from the <kbd>locksettings.db</kbd> database using the methods listed previously.</p>
<p>There is a lot of data in this chapter and to help simplify it somewhat, a suggested <em>best practices</em> flowchart is shown as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-658 image-border" src="img/4f07a5a6-2220-4b35-8629-a1e6c525399a.png" style="width:111.00em;height:65.08em;" width="1332" height="781"/></p>
<p>Android Forensics flowchart</p>


            

            
        
    </div>



  </body></html>