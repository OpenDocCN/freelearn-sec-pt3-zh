- en: Cryptography
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cryptography is the practice of securing communications even when a third-party
    can view those communications. There are two-way symmetric and asymmetric encryption
    methods, as well as one-way hashing algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: Encryption is a critical part of the modern internet. With services such as [LetsEncrypt.com](http://www.LetsEncrypt.com),
    everyone has access to trusted SSL certificates. Our entire infrastructure relies
    on and trusts encryption to work to keep all our confidential data secret. It
    is important to properly encrypt and hash data correctly, and it is easy to misconfigure
    a service, leaving it vulnerable or exposed.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers examples and use cases for the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Symmetric and asymmetric encryption
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Signing and verifying messages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hashing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing passwords securely
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating secure random numbers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating and using TLS/SSL certificates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hashing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Hashing is when a variable length message is transformed into a unique fixed-length
    alphanumeric string. There are various hashing algorithms available, such as MD5
    and SHA1\. Hashes are one-way and non-invertible, unlike symmetric encryption
    functions, such as AES, which can recover the original message if you have the
    key. Because hashes cannot be reversed, most of them are cracked by brute force.
    Crackers will build power-sucking rigs with several GPUs to hash every possible
    character combination until they find a hash that matches. They will also generate
    rainbow tables or files containing all of the hash outputs generated for quick
    lookup.
  prefs: []
  type: TYPE_NORMAL
- en: Salting your hashes is important for this reason. Salting is the process of
    adding a random string to the end of the password, provided by a user, to add
    more randomness or entropy. Consider an application that stores user login information
    and hashed passwords for authentication. If two users had the same password, then
    their hash output would be identical. Without salts, a cracker might find multiple
    people who use the same password and would only need to crack the hash one time.
    By adding a unique salt to each user's password, you ensure that each user has
    a unique hash value. Salting reduces the effectiveness of rainbow tables because,
    even if they knew the salt that goes with each hash, they would have to generate
    a rainbow able to each salt, which is time consuming.
  prefs: []
  type: TYPE_NORMAL
- en: Hashes are commonly used to validate passwords. Another common use is for file
    integrity. Large downloads often come with an MD5 or SHA1 hash of the file. After
    downloading you can hash the file to make sure that it matches the expected value.
    If it doesn't match, then the download was modified in some way. Hashing is also
    used as a way of recording indicators of compromise or IOCs. Files that are known
    to be malicious or dangerous are hashed, and that hash is stored in a catalog.
    These are often shared publicly so people can check suspicious files against known
    risks. It is much more efficient to store and compare a hash than the entire file.
  prefs: []
  type: TYPE_NORMAL
- en: Hashing small files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If a file is small enough to be contained in memory, the `ReadFile()` method
    works quickly. It loads the whole file into memory and then digests the data.
    The sum will be calculated with multiple different hash algorithms for demonstration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Hashing large files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous hashing example, the entire file to be hashed was loaded into
    memory before hashing. This is not practical or even possible when files reach
    a certain size. Physical memory limitations will come into play. Because the hashes
    are implemented as a block cipher, it will operate on one chunk at a time without
    the need to load the entire file in memory at once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Storing passwords securely
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we know how to hash, we can talk about securely storing passwords.
    Hashing is an important factor when it comes to protecting passwords. Other important
    factors are salting, using a cryptographically strong hash function, and the optional
    use of **hash-based message authentication code** (**HMAC**), which all add an
    additional secret key into the hashing algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: HMAC is an added layer that uses a secret key; so, even if an attacker got your
    database of hashed passwords with the salts, they would still have a difficult
    time cracking them without the secret key. The secret key should be stored in
    a separate location such as an environment variable rather than in the database
    with the hashed passwords and salts.
  prefs: []
  type: TYPE_NORMAL
- en: This example application has limited use as it is. Use it as a reference for
    your own applications
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Encryption
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Encryption is different from hashing because it is reversible and the original
    message can be recovered. There are symmetric encryption methods that use a password
    or a shared key to encrypt and decrypt. There are also asymmetric encryption algorithms
    that operate with a public and private key pair. AES is an example of symmetric
    encryption, and it is used to encrypt ZIP files, PDF files, or an entire filesystem.
    RSA is an example of asymmetric encryption and is used for SSL, SSH keys, and
    PGP.
  prefs: []
  type: TYPE_NORMAL
- en: Cryptographically secure pseudo-random number generator (CSPRNG)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `math` and `rand` packages do not provide the same amount of randomness
    that the `crypto/rand` package offers. Do not use `math/rand` for cryptographic
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: Read more about Go's `crypto/rand` package at [https://golang.org/pkg/crypto/rand/](https://golang.org/pkg/crypto/rand/).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example will demonstrate how to generate random bytes, a random
    integer, or any other signed or unsigned type of integer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Symmetric encryption
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Symmetric encryption is when the same key or password is used to encrypt and
    decrypt the data. Advanced Encryption Standard, also known as AES or Rijndael,
    is a symmetric encryption algorithm made standard by NIST in 2001.
  prefs: []
  type: TYPE_NORMAL
- en: Data Encryption Standard, or DES, is another symmetric encryption algorithm
    that is older and less secure than AES. It should not be used over AES unless
    there is a specific requirement or specification to do so. Go standard library
    includes AES and DES packages.
  prefs: []
  type: TYPE_NORMAL
- en: AES
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This program will encrypt and decrypt a file using a key, which is basically
    a 32-byte (256-bit) password.
  prefs: []
  type: TYPE_NORMAL
- en: When generating a key, encrypting, or decrypting, the output is sent to `STDOUT`
    or the Terminal typically. You can easily redirect the output to a file or another
    program using the `>` operator. Refer to the usage patterns for examples. If you
    need to store the key or the encrypted data as an ASCII encoded string, use base64
    encoding.
  prefs: []
  type: TYPE_NORMAL
- en: At some point in this example, you will see the message being split into two
    pieces, the IV, and the cipher text. The initialization vector, or IV, is a random
    value that gets prepended to the actual encrypted message. Every time a message
    is encrypted with AES, a random value is generated and used as part of the encryption.
    The random value is called a nonce, which means simply a number that is only used
    once.
  prefs: []
  type: TYPE_NORMAL
- en: Why are these one time values created? Especially, if they aren't kept secret
    and are put right in front of the encrypted message, what purpose does it serve?
    The random IV is used in a similar fashion to a salt. It is used primarily so
    that when the same message is encrypted repeatedly, the cipher text is different
    each time.
  prefs: []
  type: TYPE_NORMAL
- en: To use **Galois/Counter Mode** (**GCM**) instead of CFB, change the encrypt
    and decrypt methods. GCM has better performance and efficiency because it allows
    parallel processing. Read more about GCM at [https://en.wikipedia.org/wiki/Galois/Counter_Mode](https://en.wikipedia.org/wiki/Galois/Counter_Mode).
  prefs: []
  type: TYPE_NORMAL
- en: 'Start with an AES cipher and call `cipher.NewCFBEncrypter(block, iv)`. Then
    depending on whether you need to encrypt or decrypt, you will either call `.Seal()` with
    a nonce you generate, or call `.Open()` and pass it the separated nonce and cipher
    text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Asymmetric encryption
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Asymmetric is when there are two keys for each party. A public and private key
    pair is required on each side. Asymmetric encryption algorithms include RSA, DSA,
    and ECDSA. The Go standard library has packages for RSA, DSA, and ECDSA. Some
    applications that use asymmetric encryption include **Secure Shell** (**SSH**),
    **Secure Sockets Layer** (**SSL**), and **Pretty Good Privacy** (**PGP**).
  prefs: []
  type: TYPE_NORMAL
- en: SSL is the **Secure Sockets Layer** originally developed by Netscape, and version
    2 was publicly released in 1995\. It is used to encrypt communication between
    a server and a client providing confidentiality, integrity, and authentication.
    **TLS**, or **Transport Layer Security**, is the new version of SSL, with 1.2
    being defined in 2008 as RFC 5246\. The Go package for TLS does not completely
    implement the specification, but it implements the major parts. Read more about
    Go's `crypto/tls` package at [https://golang.org/pkg/crypto/tls/](https://golang.org/pkg/crypto/tls/).
  prefs: []
  type: TYPE_NORMAL
- en: You can only encrypt things smaller than the key size, which is frequently 2048
    bits. Because of this size limitation, asymmetric RSA encryption is not practical
    for encrypting entire documents, which easily exceed 2048 bits or 256 bytes. On
    the other hand, symmetric encryption such as AES can encrypt large documents,
    but it requires a shared key by both parties. TLS/SSL uses a combination of asymmetric
    and symmetric encryption. The initial connection and handshake is done using asymmetric
    encryption with the public and private keys of each party. Once the connection
    is established, a shared key is generated and shared. Once the shared key is known
    by both parties, the asymmetric encryption is dropped, and the rest of the communication
    is done using symmetric encryption such as AES using the shared key.
  prefs: []
  type: TYPE_NORMAL
- en: The examples here will use RSA keys. We will cover generating your own public
    and private keys and saving them as PEM encoded files, digitally signing messages
    and verifying signatures. In the next section, we will use the keys to create
    a self-signed certificate and establish secure TLS connections.
  prefs: []
  type: TYPE_NORMAL
- en: Generating a public and private key pair
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before using asymmetric encryption, you need a public and private key pair.
    The private key must be kept secure and not shared with anyone. The public key
    should be shared with others.
  prefs: []
  type: TYPE_NORMAL
- en: '**RSA** (**Rivest-Shamir-Adleman**) and **ECDSA** (**Elliptic Curve Digital
    Signing Algorithm**) algorithms are available in the Go standard library. ECDSA
    is considered more secure, but RSA is the most common algorithm used in SSL certificates.'
  prefs: []
  type: TYPE_NORMAL
- en: You have the option to password protect your private key. You don't need to
    do it, but it is an extra layer of security. Because the private key is so sensitive,
    it is recommended that you use password protection.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to password protect your private key file using a symmetric encryption
    algorithm, such as AES, you can use some of the standard library functions. The
    primary functions you will need are `x509.EncryptPEMBlock()`, `x509.DecryptPEMBlock()`,
    and `x509.IsEncryptedPEMBlock()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To perform the equivalent operation of generating a private and public key
    file using OpenSSL, use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'You can learn more about PEM encoding with Go at [https://golang.org/pkg/encoding/pem/](https://golang.org/pkg/encoding/pem/).
    Refer to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Digitally signing a message
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The purpose of signing a message is to let the recipient know the message came
    from the correct person. To sign a message, first generate the hash of the message
    and then use your private key to encrypt the hash. The encrypted hash is your
    signature.
  prefs: []
  type: TYPE_NORMAL
- en: The recipient will decrypt your signature to get the original hash you provided,
    then they will hash the message themselves and see if the hash they generated
    themselves from the message matches the decrypted value of the signature. If they
    match, the recipient knows that the signature is valid and it came from the correct
    sender.
  prefs: []
  type: TYPE_NORMAL
- en: Note that signing a message does not actually encrypt the message. You will
    still need to encrypt the message before sending it, if needed. You may not want
    to encrypt the message itself, if you want to post your message publicly. Others
    can still use the signature to verify who posted the message.
  prefs: []
  type: TYPE_NORMAL
- en: Only messages smaller than the RSA key size can be signed. Because the SHA-256
    hash always has the same output length, we can be sure that it is within the acceptable
    size limit. In this example, we are using the RSA PKCS#1 v1.5 standard signature
    with a SHA-256 hashing method.
  prefs: []
  type: TYPE_NORMAL
- en: The Go programming language comes with functions in the core packages to handle
    signing and verifying. The primary function is `rsa.VerifyPKCS1v5`. This function
    takes care of hashing the message and then encrypting it with the private key.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following program will take a message and a private key and create a signature
    output to `STDOUT`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Verifying a signature
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous example, we learned how to create a signature of a message for
    the recipient to verify. Now let's look at the process of verifying a signature.
  prefs: []
  type: TYPE_NORMAL
- en: If you receive a message and a signature, you must first decrypt the signature
    using the sender's public key. Then hash the original message and see if your
    hash matches the decrypted signature. If your hash matches the decrypted signature,
    then you can be sure that the sender is the person who owns the private key that
    is paired with the public key you used to verify.
  prefs: []
  type: TYPE_NORMAL
- en: To verify the signature, we are using the same algorithms (RSA PKCS#1 v1.5 with
    SHA-256) that were used to create the signature.
  prefs: []
  type: TYPE_NORMAL
- en: This example requires two command-line arguments. The first argument is the
    public key of the person who created the signate and the second argument is the
    file with the signature. To create a signature file, use the sign program from
    the previous example and redirect the output to a file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to the previous section, Go has a function in the standard library
    for verifying a signature. We can use `rsa.VerifyPKCS1v5()` to compare the message
    hash to the decrypted value of the signature and see whether they match:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: TLS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We usually don't encrypt whole messages with RSA because it can only encrypt
    messages smaller than the key size. The solution to this is typically to begin
    the communication with small messages that use the RSA keys to encrypt. When they
    have established a secure channel, they can safely exchange a shared key that
    they can use to symmetrically encrypt the rest of their messages without the size
    limitations. This is the approach SSL and TLS take to establish a secure communication.
    The handshake takes cares of negotiating which encryption algorithms will be used
    when generating and sharing a symmetric key.
  prefs: []
  type: TYPE_NORMAL
- en: Generating a self-signed certificate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To create a self-signed certificate with Go, you need a public and private key
    pair. The x509 package has a function for creating a certificate. It requires
    the public and private key along with a template certificate with all the information.
    Since we are self-signing, the template certificate is also going to be used as
    the parent certificate doing the signing.
  prefs: []
  type: TYPE_NORMAL
- en: Each application can treat self-signed certificates differently. Some applications
    will warn you if a certificate is self-signed, some will refuse to accept it,
    and others will happily use it without warning you. When you write your own applications,
    you will have to decide if you want to verify certificates or accept self-signed
    ones.
  prefs: []
  type: TYPE_NORMAL
- en: 'The important function is `x509.CreateCertificate()`, referenced at [https://golang.org/pkg/crypto/x509/#CreateCertificate](https://golang.org/pkg/crypto/x509/#CreateCertificate).
    Here is the function signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This example will take a private key and generate a certificate signed by it.
    It will save it to a file in PEM format. Once you create a self-signed certificate,
    you can use that certificate along with the private key to run secure TLS socket
    listeners and web servers.
  prefs: []
  type: TYPE_NORMAL
- en: For the sake of brevity, this example hardcodes the certificate owner information
    and the hostname IP to be localhost. This is good enough for testing on your local
    machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify these to suit your needs, customize the values, have them input through
    command-line arguments, or use standard input to get the values from the user
    dynamically, as shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Creating a certificate signing request
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you don't want to create a self-signed certificate, you have to create a
    certificate signing request and have it signed by a trusted certificate authority.
    You create a certificate request by calling `x509.CreateCertificateRequest()`
    and passing it an `x509.CertificateRequest` object with the private key.
  prefs: []
  type: TYPE_NORMAL
- en: 'The equivalent operation using OpenSSL is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This example demonstrates how to create a certificate signing request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Signing a certificate request
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous example, when generating a self-signed certificate, we already
    demonstrated the process for creating a signed certificate. In the self-signed
    example, we just used the same certificate template as the signee and the signer.
    For this reason, there is not a separate code example. The only difference is
    that the parent certificate doing the signing or the template to be signed should
    be swapped out to a different certificate.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the function definition for `x509.CreateCertificate()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In the self-signed example, the template and parent certificates were the same
    object. To sign a certificate request, create a new certificate object and populate
    the fields with the information from the signing request. Pass the new certificate
    as the template, and use the signer's certificate as the parent. The `pub` parameter
    is the signee's public key and the `priv` parameter is the signer's private key.
    The signer is the certificate authority and the signee is the requester. You can
    read more about this function at [https://golang.org/pkg/crypto/x509/#CreateCertificate](https://golang.org/pkg/crypto/x509/#CreateCertificate).
  prefs: []
  type: TYPE_NORMAL
- en: 'The  `X509.CreateCertificate()` parameters are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`rand`: This is the cryptographically secure pseudorandom number generator'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`template`: This is the certificate template populated with info from CSR'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`parent`: This is the certificate of the signer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pub`: This is the public key of the signee'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`priv`: This is the private key of the signer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The equivalent operation using OpenSSL is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: TLS server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can set up a listener just like a normal socket connection, but with encryption.
    Just call the TLS `Listen()` function, and provide it your certificate and private
    key. The certificate and key generated using the previous examples will work.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following program will create a TLS server and echo back any data received,
    then close the connection. The server will not require or verify client certificates,
    but the code to do so is left commented out for reference in case you want to
    authenticate clients with certificates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: TLS client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: TCP sockets are a simple and common way of communicating over a network. Adding
    the TLS layer on top of a standard TCP socket is simple with Go's standard library.
  prefs: []
  type: TYPE_NORMAL
- en: A client dials a TLS server just like a standard socket. Clients typically aren't
    required to have any sort of key or certificate, but a server could implement
    client-side authentication and only allow certain users to connect.
  prefs: []
  type: TYPE_NORMAL
- en: This program will connect to a TLS server and send the contents of STDIN to
    the remote server and read the response. We can use this program to test our basic
    TLS echo server created in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: Before running this program, make sure that the TLS server from the previous
    section is running so that you can connect.
  prefs: []
  type: TYPE_NORMAL
- en: Note that this is a raw socket-level server. It is not an HTTP server. In [Chapter
    9](f15910a1-239e-49a5-b4d9-3881a524bfa9.xhtml), *Web Applications* there are examples
    of running an HTTPS TLS web server.
  prefs: []
  type: TYPE_NORMAL
- en: By default, the client verifies that the server's certificate is signed by a
    trusted authority. We have to override this default and tell the client not to
    verify the certificate because we signed it ourselves. The list of trusted certificate
    authorities is loaded from the system, but can be overridden by populating the
    RootCAs variable in `tls.Config`. This example will not verify the server certificate,
    but the code to provide a list of trusted RootCAs is provided, but commented out
    for reference.
  prefs: []
  type: TYPE_NORMAL
- en: You can see how Go is loading the certificate pool for each system by looking
    through the `root_*.go` files in [https://golang.org/src/crypto/x509/](https://golang.org/src/crypto/x509/).
    For example, `root_windows.go` and `root_linux.go` load the system's default certificates.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you wanted to connect to a server and inspect or store its certificate,
    you would connect and then inspect client''s `net.Conn.ConnectionState().PeerCertificates`.
    It comes in a standard `x509.Certificate` struct. To do so, refer to the following
    block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Other encryption packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are no source code examples for the following sections, but they are worth
    mentioning. These packages provided by Go are built on top of the principles demonstrated
    in the previous examples.
  prefs: []
  type: TYPE_NORMAL
- en: OpenPGP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PGP stands for **Pretty Good Privacy**, and OpenPGP is standard RFC 4880\. PGP
    is a convenient suite for encrypting text, files, directories, and disks. All
    the principles are the same as discussed in the previous section with SSL and
    TLS key/certificates. The encrypting, signing, and verification are all the same.
    Go provides an OpenPGP package. Read more about it at [https://godoc.org/golang.org/x/crypto/openpgp](https://godoc.org/golang.org/x/crypto/openpgp).
  prefs: []
  type: TYPE_NORMAL
- en: Off The Record (OTR) messaging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Off The Record** or **OTR** messaging is a form of end-to-end encryption
    for users to encrypt their communication over whatever message medium is being
    used. It is convenient because you can implement an encrypted layer over any protocol
    even if the protocol itself is unencrypted. For example, OTR messaging works over
    XMPP, IRC, and many other chat protocols. Many chat clients such as Pidgin, Adium,
    and Xabber have support for OTR either natively or via plugin. Go provides a package
    for implementing OTR messaging. Read more about Go''s OTR support at [https://godoc.org/golang.org/x/crypto/otr/](https://godoc.org/golang.org/x/crypto/otr/).'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After reading this chapter, you should have a good understanding of what the
    Go cryptography packages are capable of. Using the examples given in this chapter
    as a reference, you should feel comfortable performing basic hash operations,
    encrypting, decrypting, generating keys, and using keys.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, you should understand the difference between symmetric and asymmetric
    encryption, and how it is different from hashing. You should feel comfortable
    with the basics of running a TLS server and connecting with a TLS client.
  prefs: []
  type: TYPE_NORMAL
- en: Remember, the goal is not to memorize every detail, but to remember what options
    are available so that you can choose the best tool for the job.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at using secure shell, also known as SSH.
    Authenticating with public and private key pairs and passwords is covered first,
    along with how to verify the remote host's key. We will also look at how to execute
    commands on a remote server and how to create an interactive shell. Secure shell
    makes use of the encryption techniques discussed in this chapter. It is one of
    the most common and practical applications of encryption. Continue reading to
    learn more about using SSH in Go.
  prefs: []
  type: TYPE_NORMAL
