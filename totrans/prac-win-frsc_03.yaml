- en: Chapter 3. Volatile Data Collection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is dedicated to some issues that are related to the acquisition
    of data, which has changed very fast. Due to its nature, it reflects the state
    of the system at a certain time because the collection of data takes place on
    a live system.
  prefs: []
  type: TYPE_NORMAL
- en: The **Request for Comments RFC** 3227 document provides a list of digital evidence
    and the order in which it should be collected. The main principle that should
    guide this is that the most rapidly changing data should be collected first.
  prefs: []
  type: TYPE_NORMAL
- en: 'The list of evidence from RFC comprises the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Registers and cache CPU
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Routing table, ARP cache, process table, kernel statistics, and memory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Temporary filesystems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disk
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remote logging and monitoring data that is relevant to the system's media
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Physical configuration and network topology
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Archival media
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: According to this list, the volatile data which should be collected first are
    memory and network related data.
  prefs: []
  type: TYPE_NORMAL
- en: Memory acquisition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For many years, the main technique for conducting digital forensics was analysis
    of hard disk images. Certainly, if a hard disk image is available, we have a good
    chance of getting a lot of data to resolve the incident. However, this approach
    has some disadvantages.
  prefs: []
  type: TYPE_NORMAL
- en: Modern hard drives have a huge size, or sometimes we have to deal with RAID
    arrays, so analysis of such large amounts of data will require a long time. Also,
    Full Disk Encryption technology could be implemented and without encryption keys
    it will be not possible to get access to the files on the disk. Moreover, analysis
    of hard disk content does not always give the whole picture of what was happened
    at a particular point in time. Also, today there is a lot of bodiless malware;
    in this case, malicious code is not presented in the filesystem as a file.
  prefs: []
  type: TYPE_NORMAL
- en: All these listed facts force a forensics specialist to seek new alternative
    ways to solve forensics tasks. So, researchers look at the RAM as an alternative
    source of information.
  prefs: []
  type: TYPE_NORMAL
- en: As well-known and modern PCs are built on the von Neumann architecture, any
    piece of code which is executed on the computer should appear somewhere in the
    memory. The memory could be a useful source of evidence. Another advantage of
    using memory is its small size. Despite the fact that nowadays a user's workstation
    has more and more RAM, it still has a far smaller size than modern hard drives.
    However, for a long time analysis of memory was not widely used. The process of
    memory analysis was just scanning dump memory to search some strings. This situation
    changed when tools such as Volatility Framework appeared.
  prefs: []
  type: TYPE_NORMAL
- en: So today, memory forensics is no longer optional but is a compulsory step for
    a professional investigation. However, before memory analysis, we should first
    get to the dump of the memory, and we should do it in the right way. Otherwise,
    even with powerful tools, such as Volatility, the analysis of memory will be unsuccessful.
  prefs: []
  type: TYPE_NORMAL
- en: There are a lot of tools which allow creating memory dumps for any operating
    system—MS Windows, Linux, or Mac OS X. Some of them are very simple, and all you
    need to do is just push the button. However, the professional should understand
    how it works and be ready to fix problems in case they happen.
  prefs: []
  type: TYPE_NORMAL
- en: Issues related to memory access
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, let's discuss some of the issues that are related to memory access on MS
    Windows. In MS Windows, there is a `\Device\PhysicalMemory` kernel object, which
    presents direct access to the physical memory of the system. To get the contents
    of the memory, we should read this file. Before Windows Server 2003 SP2, a given
    file was accessible from the user's space. However, starting from this update
    and in all later versions of MS Windows, this object is accessible from kernel
    space only. User space applications can read this file, but to open and edit it,
    the kernel space code or driver is required. Moreover, any manipulation of this
    object is a dangerous operation. The device memory is part of the physical memory,
    which is mapped to other devices in the system. This is the area of memory for
    devices, such as graphics cards, mapped to this part of physical memory in such
    way that the operating system could send data to such devices. Some particular
    blocks of memory are reserved for these devices and data that is written to these
    addresses are sent to the device. Thus, the writing or the request for access
    to this area of memory that is reserved for the device is translated into a request,
    which is sent to a real device.
  prefs: []
  type: TYPE_NORMAL
- en: How the request will be handled by a device depends on the device. Also, it
    could cause the system to hang or crash and destroy evidence. So, the software
    and the hardware that are used to dump memory should exclude these areas of memory
    from the process. We suggest testing all tools before using them. Besides the
    problem just described, there are malware which could change the behavior of tools
    and change the result of memory dumps.
  prefs: []
  type: TYPE_NORMAL
- en: Although we have never faced such malware in real life, there are a few PoC
    written by some researchers which could prove this threat. So, if the process
    of memory acquisition fails, this could make the system crash and cause a loss
    of data as well.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing a tool
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To choose a tool we need to answer the following questions:'
  prefs: []
  type: TYPE_NORMAL
- en: What is the supported OS version?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the supported hardware architecture (x32, x64)?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the required privilege level?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Where are the results stored?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Today, there are a lot free and commercial tools on the market that support
    all versions of MS Windows that we could use to dump memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Free tools** | **Commercial tools** |'
  prefs: []
  type: TYPE_TB
- en: '| DumpIt | F-Response |'
  prefs: []
  type: TYPE_TB
- en: '| WinPMEM (rekall) | Guidance Winen |'
  prefs: []
  type: TYPE_TB
- en: '| FTKImager | HBGary Fastdump PRO |'
  prefs: []
  type: TYPE_TB
- en: '| BelkaSoft Live RAM Capturer |  |'
  prefs: []
  type: TYPE_TB
- en: We need to note that the commercial tools are not always better. Which tool
    we should use depends on the case of usage, experience, and qualification of responder,
    and on other factors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Despite all the possible options, the principles that we suggest for you to
    follow are the same:'
  prefs: []
  type: TYPE_NORMAL
- en: Minimize impact to the system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the tool from a safe environment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Store results outside the system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will divide all use cases into three groups with two approaches, hardware
    and software:'
  prefs: []
  type: TYPE_NORMAL
- en: Locally
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remotely
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Post mortem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each of them has their own advantages and disadvantages. For example, let's
    take a look at the hardware approach. In this case, administrator privileges are
    not required, but you should have local physical access to the PC under investigation.
    The given approach is based on **Direct Memory Access** (**DMA**) and some technologies,
    such as Fireware, Thunderbolt, ExpressCard, or PCI. The disadvantage of this approach
    is that you need to install some hardware and software into the system before
    you can use it. Also, this action requires a reboot of the system. So, doing this
    could destroy some evidence. Another disadvantage is the limitation of the 4 GB
    memory size, which we can dump using the FireWare technology. However, solutions
    based on PCI are rare and expensive.
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned earlier, there are a lot of variants of use cases. Therefore,
    it is impossible to observe every one of them in a single chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The most simple and prevalent case is the local software approach. In this approach,
    we can use a number of utilities, and we will look at some of them now.
  prefs: []
  type: TYPE_NORMAL
- en: DumpIt
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In cases where the system has no more than 4 GB of RAM, the DumpIt utility
    is a good choice. DumpIt has a very simple command-line interface, and it is easy
    to use even for an inexperienced person. To dump the whole system memory, you
    should copy it to some removable device with enough space to store the memory
    dump. Then, plug this device in to the system and run it from the drive. After
    running this, DumpIt will create a file that contains the memory dump of the system
    in the same path from where DumpIt was executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![DumpIt](img/image_03_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Unfortunately, the free version of DumpIt doesn't work correctly with memory
    more than 4 GB.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have 8 GB of memory or more, we suggest using Belkasoft Live RAM Capturer.
    This software also has a simple graphical interface. It works on both architectures:
    x32 and x64 bits:'
  prefs: []
  type: TYPE_NORMAL
- en: '![DumpIt](img/image_03_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: FTK Imager
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One more popular utility for memory dump is FTK Imager. It is also free. There
    are two versions of it. We suggest using the FTK Imager Lite version. It does
    not require installation, has an easy-to-use interface, and has a lot of useful
    features:'
  prefs: []
  type: TYPE_NORMAL
- en: '![FTK Imager](img/image_03_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Acquiring memory from a remote computer using iSCSI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another common scenario is the acquisition of memory from a remote computer.
    Consider the case when we need to dump memory from a remote Windows workstation
    using different operating systems including MS Windows, Mac OS X, and Linux. To
    do this, we can use the **iSCSI** protocol. Internet Small Computer System Interface
    protocol was developed in 1998 by IBM and CISCO. This protocol allows clients
    (named initiator) to send SCSI (CDBs) to SCSI storage devices (named target),
    which are located on remote servers.
  prefs: []
  type: TYPE_NORMAL
- en: Initiator is an iSCSI client and it works as an SCSI adapter except that it
    uses the IP network rather than physical bus. The iSCSI target is a server that
    provides a network interface to a storage device. Thus, we should install the
    iSCSI target on workstation of investigator where we will store the memory dump.
    There are a few free implementations of iSCSI for Microsoft and StarWind. Also,
    F-Response provides features to access a remote PC by iSCSI. Most operating systems
    have a free built-in initiator client software, including MS Windows 2000 SP4
    and higher.
  prefs: []
  type: TYPE_NORMAL
- en: So, in our use case, we will use our own written iSCSI target software, **KFA**
    (**Kaspersky Forensics Agent**), and the `iscsiadm` utility as initiator on a
    Linux station.
  prefs: []
  type: TYPE_NORMAL
- en: 'To dump memory using Kaspersky Forensics Agent, run the utility on the target
    system with the `-mountphysmem` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Acquiring memory from a remote computer using iSCSI](img/image_03_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To provide access with authorization, we can use the `chaplogin` and `chapsecret`
    options:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Acquiring memory from a remote computer using iSCSI](img/image_03_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'It is now possible to connect to the selected media using any iSCSI initiator:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we test the connection:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Having verified that the iSCSI connection is in working order, we establish
    a full connection:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Make sure that the memory is visible in the Ubuntu environment as a new device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, you can dump it with the `dd` utility as usual.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, you have a memory dump, and you are ready to analyze it!
  prefs: []
  type: TYPE_NORMAL
- en: Using the Sleuth Kit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We want to discuss one more use case. It is possible that an investigator has
    only a hard disk image and no opportunity to dump memory from the system of interest.
    In this case, we still have the ability to receive some kind of system memory
    information. MS Windows saves the contents of memory in the `hiberfil.sys` file
    when the system goes to hibernate. So, if we have a disk image, we can extract
    `hiberfil.sys` from the disk.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we need to use the Sleuth Kit. Let''s take a look at how we can
    do this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To obtain information about partitions on the disk, use the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Using the Sleuth Kit](img/image_03_006.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Then, use `fls` to list files on the root directory of the NTFS partition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, extract `hiberfil.sys`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, you can analyze `hiberfil.sys` with an analysis tool, such as Volatility.
  prefs: []
  type: TYPE_NORMAL
- en: Network-based data collection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nowadays, it is difficult enough to find computers that don't have any network
    connections. This is almost impossible in the enterprise environment. Network
    connections reflect the interaction of computers with the outer world. Also, the
    network is the main source of threats. Today, the Internet is a very aggressive
    environment. Threats of various levels from spam to APT often penetrate computers
    via networks.
  prefs: []
  type: TYPE_NORMAL
- en: So, in almost every incident, computers have network activities that are related
    to the incident. There are a lot of examples of such events from receiving e-mails
    with malicious attachments and visits of a malicious URL. However, sometimes to
    have only host-based evidence to get a whole picture about an incident is not
    enough. In such cases, network-based evidence can help a lot.
  prefs: []
  type: TYPE_NORMAL
- en: Network forensics is a vast topic. We won't cover all the issues. In this chapter,
    we just want to look at this as an additional source of evidence. There is a lot
    of network-based evidence, but we will focus on network traffic acquisition.
  prefs: []
  type: TYPE_NORMAL
- en: Forensics investigators can capture the network traffic from physical media,
    such as cables or air and network devices, such as switches or hubs.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will give a short introduction to this topic to understand how we can
    collect network traffic.
  prefs: []
  type: TYPE_NORMAL
- en: Hubs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: These are a simple network devices that allow connecting all devices from a
    local subnet. Hubs don't have any functionality beside the physical connection
    of all devices.
  prefs: []
  type: TYPE_NORMAL
- en: When such a device receives the network frame, it transfers packets on other
    ports. Thus, every device that is connected to the hub will receive all traffic
    that is dedicated for other devices. In the case of a hub-based network, it is
    simple enough to capture traffic from a given segment of a network. We should
    note that sometimes some manufactures designate some devices which are in reality
    switches as hubs.
  prefs: []
  type: TYPE_NORMAL
- en: The most reliable way to figure out what kind of device you are dealing with
    is to connect the station to the device, turn the network interface to promiscuous
    mode, and capture the traffic using the tcpdump utility or a similar utility.
    If you only have a broadcast and packets are dedicated to this station, this means
    that you have a **switch device**. If the traffic contains packets for other stations,
    you have a **hub**.
  prefs: []
  type: TYPE_NORMAL
- en: Investigators should be careful when they use hubs to capture traffic. In this
    case, investigators could see all traffic, but it could also be everybody from
    a local network. A compromised system could work as a passive sniffer and eavesdrop
    on all transferred data. Any investigator activities and data in the network could
    be intercepted. So, it's a good idea to use an already installed hub, but the
    installation of a new one to capture the network traffic will bring new risks.
  prefs: []
  type: TYPE_NORMAL
- en: Switches
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Switches are the most prevalent network devices used to build local networks.
    They also serve as hubs serve to connect network devices into the network. However,
    unlike hubs, they use software to keep track of the stations connected to the
    ports of the switch. This information will be kept in the CAM table. When the
    switch receives a new packet, it will forward this packet only to a certain port
    according to the CAM table. So, each station receives only its traffic.
  prefs: []
  type: TYPE_NORMAL
- en: Investigators can often capture the network traffic on switch devices because
    most of them have the functionality of replicating traffic from one or a few ports
    to other ports for aggregation and analysis. Various vendors use different terms
    for this, the most widely used is **SPAN** (**Switched Port Analyzer**) or **RSPAN**
    (**Remote SPAN**). Sometimes, the term port mirroring is used. Also, switches
    have various hardware capacities. Port mirroring is limited by the physical capacity
    of a device. Consider this example, we have a 100 Mbps switch, and we want to
    mirror four ports to another one. With an average load of 50 Mbps for every port,
    the load for mirror ports will be 200 Mbps, which is far from the capacity of
    every port. Thus, some packets will be dropped in the process.
  prefs: []
  type: TYPE_NORMAL
- en: We should note that the approach with the SPAN port can change the collected
    traffic. However, there is one more method to capture the traffic. This is a network
    tap.
  prefs: []
  type: TYPE_NORMAL
- en: Network taps are placed between stations and switches and can look at and capture
    all traffic for this host. Network taps duplicate all traffic, including corrupted
    and any other packets. So, this approach is more suitable for forensics.
  prefs: []
  type: TYPE_NORMAL
- en: After we finally choose the method that we will use to capture the traffic,
    we need some software. A common solution for this is the `libpcap` library and
    software based on it, including `tcpdump`, Wireshark, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: There are two main approaches to using such software to capture the traffic.
    They are filtering in capturing, and capturing all data and filtering it later.
  prefs: []
  type: TYPE_NORMAL
- en: 'In some cases, filtering during collection is a good idea if you have limited
    storage space to keep the traffic. From other side, libpcap has a very powerful
    filtering capability called **Berkley Packet Filter** (**BPF**). Using BPF filters,
    we can control what traffic we will capture and what we will drop. If you know
    exactly what you want to capture, this approach can save a lot of time and resources
    for you. BPF can filter traffic based on a comparison of fields in the protocols
    at second, third, and fourth levels. Also, the BPF language has some built-in
    primitives: `host id`, `dst host id`, `src host id`, `net id`, `dst net id`, `src
    net id`, `ether id`, `dst ether id`, `src ether id`, `port id`, `dst port id`,
    `src port id`, `gateway id`, `ip proto id`, `ether proto id`, `tcp`, `udp`, `icmp`,
    and `arp`. You could find more in manual documentation on `pcap-filter`.'
  prefs: []
  type: TYPE_NORMAL
- en: Tcpdump
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`tcpdump` is a tool to capture, filter, and analyze network traffic. The main
    purpose of this tool is to capture the traffic and print it out or store it in
    a file. `tcpdump` captures the traffic in bit-to-bit as it is transferred via
    media. We can use `tcpdump` to analyze traffic for troubleshooting in the network.
    In this case, you will use BPF to prefilter. However, usually this approach is
    a good fit for the initial triage only:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Tcpdump](img/image_03_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In forensics practice, other approaches are more prevalent. Tcpdump is used
    to capture traffic during long periods of time and to store it in a file on disk
    with further analysis and correlation with other data.
  prefs: []
  type: TYPE_NORMAL
- en: The `tcpdump` is a high-fidelity tool, but the quality of captured traffic depends
    on resources available on the host where `tcpdump` is running. For instance, the
    performance of `tcpdump` will depend on the power of the CPU. The capturing of
    packets is a CPU-intensive activity, and if CPU is overloaded, `tcpdump` will
    fail and drop packets. In forensics cases, we want to capture all packets and
    this issue could be critical. In the case of high-loaded networks, the storage
    space for traffic is also an important question. As we mentioned earlier, you
    can use filtration of traffic and keep only useful information.
  prefs: []
  type: TYPE_NORMAL
- en: Despite the fact that filtration will save resources, such as CPU, disk space,
    and capacity, it should be implemented carefully because excessive filtration
    could cause a loss of evidence.
  prefs: []
  type: TYPE_NORMAL
- en: Wireshark
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One more popular utility for capture and traffic analysis is Wireshark:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Wireshark](img/image_03_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Wireshark is a tool with an easy to use graphical user interface. So it can
    be a good tool for beginners in network forensics. It also has a lot of features
    for filtration, decryption, and analysis of network traffic. Therefore, this makes
    Wireshark a must-have tool for any network investigator. Wireshark allows capturing
    traffic from any interface on the system if you have the necessary permissions,
    displaying it in real time, and storing it in a file on disk.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, there are a few useful command-line tools, which are distributed together
    with Wireshark.
  prefs: []
  type: TYPE_NORMAL
- en: Tshark
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Tshark is the CLI version of Wireshark. It has almost the same functionality
    and works with the same file formats:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Tshark](img/image_03_009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Dumpcap
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One more useful tool from the Wireshark kit is Dumpcap. It is dedicated to
    capturing network packets. Therefore, it is optimized for good performance in
    capture and will spend less system resources. If you plan to capture the traffic
    and analyze it with Wireshark, then the Dumpcap utility will be a good tool to
    capture the network traffic:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Dumpcap](img/image_03_009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered issues that are related to volatile data collection.
    We discussed different tools and approaches to how to collect memory and network
    traffic.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss issues that are related to non-volatile
    data collection. We will discuss how to duplicate hard drives and how to use standalone
    tools such as IR CD for this.
  prefs: []
  type: TYPE_NORMAL
