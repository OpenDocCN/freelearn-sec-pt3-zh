<html><head></head><body><div><p>&#13;
			<h1 id="_idParaDest-157"><em class="italic"><a id="_idTextAnchor194"/>Chapter 11</em>: Incorporating New Binary Formats</h1>&#13;
			<p><a id="_idTextAnchor195"/>In this chapter, we will discuss how to incorporate new binary formats into Ghidra, enabling you to analyze exoteric binaries – for instance, ROMs of video games (a copy of the data from the cartridge or any other read-only memory). Throughout this chapter, you will learn how to develop Ghidra loader extensions, which were previously introduced in the <em class="italic">Loaders</em> subsection of the <em class="italic">The Ghidra extension module skeleton</em> section in <a href="B16207_04_Final_SK_ePub.xhtml#_idTextAnchor063"><em class="italic">Chapter 4</em></a>, <em class="italic">Using Ghidra Extensions</em>.</p>&#13;
			<p>We will start by looking at what a binary file is. We will explore the differences between raw binary files and formatted binary files and how Ghidra can deal with them. Next, we will perform some experiments with Ghidra to understand how binaries are loaded from a user perspective. <a id="_idTextAnchor196"/><a id="_idTextAnchor197"/>Finally, we will analyze the loader for <strong class="bold">old-style DOS executable binaries</strong> from a Ghidra developer perspective. The loader under analysis is responsible for enabling Ghidra to load MS-DOS executable binaries, so you will learn about loader development by analyzing a real-world example.</p>&#13;
			<p>In this chapter, we're going to cover the following main topics:  </p>&#13;
			<ul>&#13;
				<li>Understanding the difference between raw binaries and formatted binaries</li>&#13;
				<li>Developing a Ghidra loader</li>&#13;
				<li>Understanding filesystem loaders</li>&#13;
			</ul>&#13;
			<h1 id="_idParaDest-158"><a id="_idTextAnchor198"/>Technical requirements </h1>&#13;
			<p>The requirements for this chapter are as follows:</p>&#13;
			<ul>&#13;
				<li><strong class="bold">Flat assembler</strong> (<strong class="bold">fasm</strong>), which is an assembly language compiler that can produce binaries of different formats (plain binary, MZ, PE, COFF, or ELF): <a href="https://flatassembler.net/download.php">https://flatassembler.net/download.php</a></li>&#13;
				<li>HexIt v.1.57, which is a hex editor allowing you to parse old MS-DOS executable files (MZ): <a href="https://mklasson.com/hexit.php">https://mklasson.com/hexit.php</a></li>&#13;
			</ul>&#13;
			<p>The GitHub repository containing all the necessary code for this chapter can be found at <a href="https://github.com/PacktPublishing/Ghidra-Software-Reverse-Engineering-for-Beginners/tree/master/Chapter11">https://github.com/PacktPublishing/Ghidra-Software-Reverse-Engineering-for-Beginners/tree/master/Chapter11</a>.</p>&#13;
			<p>Check out the following link to see the Code in Action video: <a href="https://bit.ly/3mQraZo">https://bit.ly/3mQraZo</a></p>&#13;
			<h1 id="_idParaDest-159"><a id="_idTextAnchor199"/>Understanding the difference between raw binaries and formatted binaries</h1>&#13;
			<p>In this section, you will <a id="_idIndexMarker388"/>learn the difference <a id="_idIndexMarker389"/>between raw and formatted binaries.The concept of a binary file can be easily defined by negation; that is, a <strong class="bold">binary file</strong> is a file that is not a text file.</p>&#13;
			<p>We can classify binary files into two categories: raw binary files and formatted binary files.</p>&#13;
			<p><strong class="bold">Raw binaries</strong> are those binary <a id="_idIndexMarker390"/>files that contain unprocessed data, so these binary files have no format in any way. An example of a raw binary could be a memory dump taken from some buffer containing a piece of code.</p>&#13;
			<p>On the <a id="_idIndexMarker391"/>other hand, <strong class="bold">formatted binaries</strong> are those binary files that have a format specification so that you can parse it. Examples of formatted binaries are the Windows executable (image) files and object <a id="_idIndexMarker392"/>files that follow the <strong class="bold">Portable Executable</strong> (<strong class="bold">PE</strong>) format, the <a id="_idIndexMarker393"/>specification of which is available online: https://docs.microsoft.com/en-us/windows/win32/debug/pe-format.</p>&#13;
			<p>For the purpose of Ghidra, raw binaries are a truly general concept, meaning any file treated without taking into account its format. You can deal with raw binaries and manually process the data by structuring the file in some way, but it is much more comfortable to work with formatted binaries. It is for this reason that you will want to develop your own loaders for binary formats that are not supported yet.</p>&#13;
			<h2 id="_idParaDest-160"><a id="_idTextAnchor200"/>Understanding raw binaries</h2>&#13;
			<p>Ghidra can load any <a id="_idIndexMarker394"/>kind of file from your filesystem, even if that file is not of a known file format (that is, files not having a known file structure). For instance, you can write a file that relates numbers with words and separates those pairs with a semicolon and Ghidra will be able to load it. We can generate a <code>raw.dat</code> file in this way by executing the following command:</p>&#13;
			<pre>C:\Users\virusito\loaders&gt; echo "1=potato;2=fish;3=person" &gt; raw.dat</pre>&#13;
			<p>If you drag and drop the resulting <code>raw.dat</code> file into a Ghidra project, it will be loaded as a <strong class="bold">Raw Binary</strong> file (a sequence of bytes without sense) because Ghidra doesn't know its file format.</p>&#13;
			<p>As you can see in the following screenshot, Ghidra, based on the loader's results, recognizes the file as <strong class="bold">Raw Binary</strong> during the importing phase and suggests this as the best format to use:</p>&#13;
			<div>&#13;
				<div>&#13;
					<img src="img/B16207_11_001.jpg" alt="Figure 11.1 – Loading a raw binary&#13;&#10;"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption"> </p>&#13;
			<p class="figure-caption">Figure 11.1 – Loading a raw binary</p>&#13;
			<p>The drop-down list of file formats is filled based on two concepts, <strong class="bold">tiers</strong> and <strong class="bold">tiers priority</strong>, which allows you to sort the list of formats from the most adequate (<strong class="bold">Raw Binary</strong> in <em class="italic">Figure 11.1</em>) to the least: </p>&#13;
			<ul>&#13;
				<li><strong class="bold">Tiers</strong>, an integer number in range 0 to 3 allowing us to represent four classes of loaders and enabling us to sort the loaders from the most specialized (tier 0) or appropriate to the least (tier 3).</li>&#13;
				<li>While the higher-tier value wins, an integer number named <strong class="bold">tiers priority</strong> is used to tiebreak when more than one loader is able to load a file with the same tier. Both tiers and tiers priority are mandatory when developing a loader.<p class="callout-heading">More about tiers and tiers priority</p><p class="callout">As always, you can check the documentation on tiers and tiers priority if you want to look at them further in depth: <a href="https://ghidra.re/ghidra_docs/api/ghidra/app/util/opinion/LoaderTier.html">https://ghidra.re/ghidra_docs/api/ghidra/app/util/opinion/LoaderTier.html</a> and <a href="https://ghidra.re/ghidra_docs/api/ghidra/app/util/opinion/Loader.html#getTierPriority()">https://ghidra.re/ghidra_docs/api/ghidra/app/util/opinion/Loader.html#getTierPriority()</a>.</p></li>&#13;
			</ul>&#13;
			<p>We did this little <a id="_idIndexMarker395"/>experiment with <code>raw.dat</code> to understand, in baby steps, the basics of loaders using a file that you fully understand. Let's now try something a little more complicated!</p>&#13;
			<p>To provide a more realistic example, let's load the shellcode of the Alina malware previously shown when analyzing the <code>0x004554E0</code> function in <a href="B16207_05_Final_SK_ePub.xhtml#_idTextAnchor082"><em class="italic">Chapter 5</em></a>, <em class="italic">Reversing Malware Using Ghidra</em>, under the <em class="italic">In-depth analysis</em> section.</p>&#13;
			<p>As it is not recognized, we must manually set the language in which the shellcode was written:</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B16207_11_002.jpg" alt="Figure 11.2 – Choosing a language and compiler for the raw binary&#13;&#10;"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption"> </p>&#13;
			<p class="figure-caption">Figure 11.2 – Choosing a language and compiler for the raw binary</p>&#13;
			<p>You can also set a value for <strong class="bold">Destination Folder</strong> for the importing file, and <strong class="bold">Program Name</strong>, which will be used for importing the file into the project.</p>&#13;
			<p>Finally, you can import just a block of the file by clicking on <strong class="bold">Options…</strong>, as shown in the following screenshot. It shows a menu allowing you to choose the block name (a name for this block <a id="_idIndexMarker396"/>of data), the base address, indicating the memory address where the block will start or be put on, and finally, a file offset, indicating the position of the block in the importing file and the length of the block.</p>&#13;
			<p>The block will be labeled using <code>shellcode</code> by writing it into the input box). If you check the <strong class="bold">Apply Processor Defined Labels</strong> box, then the importer will create labels at some addresses as specified by the processor. On the other hand, those labels will not be moved even if the image base is changed later if you check the <strong class="bold">Anchor Processor Defined Labels</strong> box:</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B16207_11_003.jpg" alt="Figure 11.3 – Loading a block of a raw binary&#13;&#10;"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption"> </p>&#13;
			<p class="figure-caption">Figure 11.3 – Loading a block of a raw binary</p>&#13;
			<p>You can also add, remove, or edit blocks of memory by accessing the <strong class="bold">Window</strong> | <strong class="bold">Memory Map</strong> option of Ghidra's CodeBrowser:</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B16207_11_004.jpg" alt=" Figure 11.4 – Adding, removing, and editing memory blocks&#13;&#10;"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption"> Figure 11.4 – Adding, removing, and editing memory blocks</p>&#13;
			<p>As you can see in the following screenshot, if the file format is not recognized by Ghidra, you will have to <a id="_idIndexMarker397"/>manually perform a lot of work. In this case, you will need to define the bytes as code or strings, create symbols, and so on:</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B16207_11_005.jpg" alt=" Figure 11.5 – Alina malware shellcode loaded as a raw binary&#13;&#10;"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption"> Figure 11.5 – Alina malware shellcode loaded as a raw binary</p>&#13;
			<p>Instead of doing it manually, you can extend Ghidra by developing a loader for such a format. Let's look at how we do this in the next section.</p>&#13;
			<h2 id="_idParaDest-161"><a id="_idTextAnchor201"/>Understanding formatted binaries</h2>&#13;
			<p>Executable binaries are <a id="_idIndexMarker398"/>formatted binaries; therefore, their importers must import them by taking into account the format structure. To understand this, let's generate and look at an old MS-DOS executable because it will produce a light binary and, since the old MS-DOS executable structure is not especially complex, it is a really good real-world example to start with. The code of our <code>hello world</code> old MS-DOS executable program (the <code>mz.asm</code> file), written in assembly language, looks as follows:</p>&#13;
			<pre>00 format MZ</pre>&#13;
			<pre>01 </pre>&#13;
			<pre>02 mov ah, 9h</pre>&#13;
			<pre>03 mov dx, hello</pre>&#13;
			<pre>04 int 21h</pre>&#13;
			<pre>05</pre>&#13;
			<pre>06 mov ax, 4c00h</pre>&#13;
			<pre>07 int 21h</pre>&#13;
			<pre>08</pre>&#13;
			<pre>09 hello db 'Hello, world!', 13, 10, '$'</pre>&#13;
			<p>Line <code>00</code> tells the compiler that this is an old MS-DOS program. At line <code>04</code>, we are triggering an interrupt, <code>21h</code> (most of the DOS API calls are invoked using interrupt <code>21h</code>), which receives <code>9h</code> in the <code>ah</code> register <a id="_idIndexMarker399"/>as a parameter (line <code>02</code>), indicating that the program has to print the message referenced by <code>dx</code> (line <code>03</code>), which is located at line <code>09</code>, to <code>stdout</code>.</p>&#13;
			<p>Finally, the program ends, passing control to the operative system. This is done by passing the corresponding value in <code>ax</code> to indicate that the program must end its execution (line <code>06</code>) and again triggering the <code>21h</code> interruption. Let's compile the program using <code>fasm</code>:</p>&#13;
			<pre>C:\Users\virusito\loaders&gt; fasm mz.asm</pre>&#13;
			<pre>flat assembler  version 1.73.04  (1048576 kilobytes memory)</pre>&#13;
			<pre>2 passes, 60 bytes.</pre>&#13;
			<p>By compiling the program, we obtained an <code>mz.exe</code> file as a result. To show you the format, I'm using HexIt v.1.57, which is a hexadecimal editor that parses old DOS executable headers when <em class="italic">F6</em> is pressed.</p>&#13;
			<p>In the following screenshot, you can see the DOS .EXE header. Each row starts with the offset of the header field between brackets, then the name of the field, and, finally, its value. For instance, at the very beginning of the file (offset <strong class="bold">[00]</strong>), we have <strong class="bold">Signature</strong>, which has a value of <strong class="bold">MZ</strong>:</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B16207_11_006.jpg" alt="Figure 11.6 – Showing the DOS .EXE header in HexIt v1.57&#13;&#10;"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption">Figure 11.6 – Showing the DOS .EXE header in HexIt v1.57</p>&#13;
			<p>Ghidra includes a loader that is able to parse these <strong class="bold">old-style DOS executable (MZ)</strong> binaries, so when you drag <a id="_idIndexMarker400"/>and drop this file into Ghidra, the language and format will both be recognized:</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B16207_11_007.jpg" alt="Figure 11.7 – Importing an old-style DOS executable (MZ) to Ghidra&#13;&#10;"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption">Figure 11.7 – Importing an old-style DOS executable (MZ) to Ghidra</p>&#13;
			<p>As you can see in the following screenshot, when this formatted binary file is loaded by Ghidra's CodeBrowser, the entry point of the program is successfully detected. Addresses and a lot of useful information are automatically given to you:</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B16207_11_008.jpg" alt="Figure 11.8 – Ghidra successfully loaded the old-style DOS executable (MZ) and its disassembly matches our source code&#13;&#10;"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption"> </p>&#13;
			<p class="figure-caption">Figure 11.8 – Ghidra successfully loaded the old-style DOS executable (MZ) and its disassembly matches our source code</p>&#13;
			<p>In the following section, we <a id="_idIndexMarker401"/>will overview how this <strong class="bold">old-style DOS executable (MZ)</strong> loader is <a id="_idTextAnchor202"/>implemented.</p>&#13;
			<h1 id="_idParaDest-162"><a id="_idTextAnchor203"/>Developing a Ghidra loader</h1>&#13;
			<p>A loader is a Ghidra <a id="_idIndexMarker402"/>extension module that extends from the <code>AbstractLibrarySupportLoader</code> class. This class has the following methods: <code>getName</code>, <code>findSupportedLoadSpecs</code>, <code>load</code>, and, optionally, if supporting custom options,<code>getDefaultOptions</code> and <code>validateOptions</code>.</p>&#13;
			<p>I'm assuming that you are familiar with loaders and these methods because they were superficially overviewed in <a href="B16207_04_Final_SK_ePub.xhtml#_idTextAnchor063"><em class="italic">Chapter 4</em></a>, <em class="italic">Using Ghidra Extensions</em>.</p>&#13;
			<h2 id="_idParaDest-163"><a id="_idTextAnchor204"/>The old-style DOS executable (MZ) parser</h2>&#13;
			<p>The existing <a id="_idIndexMarker403"/>Ghidra loader for MZ files must be able to parse <a id="_idIndexMarker404"/>the old-style DOS executable (MZ) file as we did by using <strong class="bold">HexIt v.1.57</strong> in the <em class="italic">Formatted binaries</em> section of this chapter. To do that, Ghidra implements a parser for these kinds of binaries that is available here: <a href="https://github.com/NationalSecurityAgency/ghidra/tree/master/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/mz">https://github.com/NationalSecurityAgency/ghidra/tree/master/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/mz</a>.</p>&#13;
			<p>This link contains three files:</p>&#13;
			<ul>&#13;
				<li><code>DOSHeader.java</code>: A file implementing the old-style DOS executable parser. It relies on the <code>StructConverter</code> class to create a structure data type that is equivalent to the <code>DOSHeader</code> class members.</li>&#13;
				<li><code>OldStyleExecutable.java</code>: A class that uses <code>FactoryBundledWithBinaryReader</code> to read data from a generic byte provider and passes it to the <code>DOSHeader</code> class in order to parse it. The <code>OldStyleExecutable</code> class exposes both via getter methods: <code>DOSHeader</code> and the underlying <code>FactoryBundledWithBinaryReader</code> object.</li>&#13;
				<li><code>package.html</code>: A short description of the directory content.<p class="callout-heading">Relevant parser classes</p><p class="callout">You can find the documentation for <code>StructConverter</code> at <a href="https://ghidra.re/ghidra_docs/api/ghidra/app/util/bin/StructConverter.html">https://ghidra.re/ghidra_docs/api/ghidra/app/util/bin/StructConverter.html</a>. You can find the documentation for <code>FactoryBundledWithBinaryReader</code> at <a href="https://ghidra.re/ghidra_docs/api/ghidra/app/util/bin/format/FactoryBundledWithBinaryReader.html">https://ghidra.re/ghidra_docs/api/ghidra/app/util/bin/format/FactoryBundledWithBinaryReader.html</a>.</p></li>&#13;
			</ul>&#13;
			<p>When writing <a id="_idIndexMarker405"/>your own loaders, you can <a id="_idIndexMarker406"/>put your parsers into the <code>format</code> directory of Ghidra (<code>Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format</code>), which will be available as both <code>*.jar</code> and <code>*.src</code> files in your Ghidra distribution.</p>&#13;
			<h2 id="_idParaDest-164"><a id="_idTextAnchor205"/>The old-style DOS executable (MZ) loader</h2>&#13;
			<p>After <a id="_idIndexMarker407"/>implementing the parser for this format, the loader <a id="_idIndexMarker408"/>itself is implemented here, extending from <code>AbstractLibrarySupportLoader</code>: <a href="https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/MzLoader.java">https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/MzLoader.java</a>.</p>&#13;
			<p>Let's look at how this class is implemented.</p>&#13;
			<h3>The getTierPriority method</h3>&#13;
			<p>This loader <a id="_idIndexMarker409"/>defines a tier priority of <code>60</code>, which is less than the PE (Portable Executable) tier priority. It is done in this way to prevent PE files from being loaded as MZ files. This could happen because the PE file format contains an MZ stub at the beginning. On the other hand, MZ files can't be <a id="_idIndexMarker410"/>loaded by the PE loader:</p>&#13;
			<pre>@Override</pre>&#13;
			<pre>public int getTierPriority() {</pre>&#13;
			<pre>  return 60; // we are less priority than PE!  Important for </pre>&#13;
			<pre>             // AutoImporter</pre>&#13;
			<pre>}</pre>&#13;
			<p>It is a simple method but no less important.</p>&#13;
			<h3>The getName method</h3>&#13;
			<p>As <a id="_idIndexMarker411"/>mentioned before, a <code>getName</code> method must be implemented, allowing us to show the name of the loader when importing the file:</p>&#13;
			<pre>public class MzLoader extends AbstractLibrarySupportLoader {</pre>&#13;
			<pre>  public final static String MZ_NAME = "Old-style DOS " +</pre>&#13;
			<pre>                                       "Executable (MZ)";</pre>&#13;
			<pre>  @Override</pre>&#13;
			<pre>  public String getName() {</pre>&#13;
			<pre>    return MZ_NAME;</pre>&#13;
			<pre>  }</pre>&#13;
			<p>The returned name must be descriptive enough taking into account the user's perspective.</p>&#13;
			<h3>The findSupportedLoadSpecs method</h3>&#13;
			<p>The loader specs are <a id="_idIndexMarker412"/>loaded by implementing the <code>findSupportedLoadSpecs</code> method, which queries the opinion service (<a href="https://ghidra.re/ghidra_docs/api/ghidra/app/util/opinion/QueryOpinionService.html#query(java.lang.String,java.lang.String,java.lang.String">https://ghidra.re/ghidra_docs/api/ghidra/app/util/opinion/QueryOpinionService.html#query(java.lang.String,java.lang.String,java.lang.String</a>).</p>&#13;
			<p>The <code>query</code> method receives the name of the loader as the first parameter, the primary key as the second parameter, and, finally, the secondary key:</p>&#13;
			<pre>List&lt;QueryResult&gt; results = QueryOpinionService.query(</pre>&#13;
			<pre>                                          getName(),</pre>&#13;
			<pre>                                          "" + dos.e_magic(), </pre>&#13;
			<pre>                                          null</pre>&#13;
			<pre>);</pre>&#13;
			<p>The opinion service retrieves the loader specifications from a <code>*.opinion</code> file (<a href="https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Processors/x86/data/languages/x86.opinion">https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Processors/x86/data/languages/x86.opinion</a>). Opinion files contain constraints allowing you to determine <a id="_idIndexMarker413"/>whether the file can be loaded or not:</p>&#13;
			<pre>&lt;constraint loader="Old-style DOS Executable (MZ)"</pre>&#13;
			<pre>                                  compilerSpecID="default"&gt;</pre>&#13;
			<pre>  &lt;constraint primary="23117" processor="x86" endian="little" </pre>&#13;
			<pre>                             size="16" variant="Real Mode"/&gt;</pre>&#13;
			<pre>&lt;/constraint&gt;</pre>&#13;
			<p>The short format opinion documentation is available here: <a href="https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Framework/SoftwareModeling/data/languages/Steps%20to%20creation%20of%20Format%20Opinion.txt">https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Framework/SoftwareModeling/data/languages/Steps%20to%20creation%20of%20Format%20Opinion.txt</a>.</p>&#13;
			<p>In any case, the XML attributes are self-explanatory.</p>&#13;
			<h3>The load method</h3>&#13;
			<p>At <a id="_idIndexMarker414"/>last, the <code>load</code> method does the hard job of loading the file into Ghidra. Let's analyze the code. The loader starts obtaining information from the program being analyzed:</p>&#13;
			<ol>&#13;
				<li>It obtains the bytes of the file being analyzed by calling the <code>MemoryBlockUtils.createFileBytes</code> function (lines <code>09</code>–<code>14</code>):<pre>00 @Override
01 public void load(ByteProvider provider,
02                  LoadSpec loadSpec, 
03                  List&lt;Option&gt; options,
04                  Program prog, 
05                  TaskMonitor monitor,
06                  MessageLog log) 
07               throws IOException, CancelledException {
08
09   FileBytes fileBytes = 
10               MemoryBlockUtils.createFileBytes(
11                                              prog, 
12                                              provider,
13                                              monitor
14   );</pre><p>The result of the call to <code>MemoryBlockUtils.createFileBytes()</code> is the <code>fileBytes</code> variable containing all the bytes of the file.</p></li>&#13;
				<li>It creates an address space to deal with Intel-segmented address spaces. Briefly, Intel memory segmentation allows you to isolate memory regions, offering, in this way, security. Due <a id="_idIndexMarker415"/>to segmentation, a memory address consists of a segment register (for example, the <code>CS</code> register) pointing to some segment of memory (for example, <code>code segment</code>) and an offset. The task of creating an address space for Intel-segmented address spaces is performed in two steps:<p>a. First, it obtains the address factory for the language of the current program (line <code>15</code>):</p><pre>15   AddressFactory af = prog.getAddressFactory();
16   if (!(af.getDefaultAddressSpace() instanceof 
17      SegmentedAddressSpace)) {
18      throw new IOException(
19            "Selected Language must have a" +
20            "segmented address space.");
21   }</pre><p>The <code>getAddressFactory()</code> result is <code>af</code>, an <code>AddressFactory</code> object that is expected to be a segmented address space. It is checked by the <code>instanceof</code> operator.</p><p>b. Next, it obtains the segmented address space using the address factory (lines <code>23</code>–<code>24</code>):</p><pre>22
23 SegmentedAddressSpace space = 
24   (SegmentedAddressSpace) af.getDefaultAddressSpace();</pre></li>&#13;
				<li>After creating an address space, it retrieves the <code>25</code>) and the processor register context over the address space (line <code>26</code>):<pre>25   SymbolTable symbolTable = prog.getSymbolTable();
26   ProgramContext context = prog.getProgramContext();</pre></li>&#13;
				<li>Finally, it obtains <a id="_idIndexMarker416"/>the memory of the program (line <code>27</code>):<pre>27   Memory memory = prog.getMemory();</pre></li>&#13;
				<li>By using the old-style DOS executable (MZ) parser (line <code>28</code>), the loader obtained the DOS header (line <code>34</code>) and a reader (lines <code>35</code> and <code>36</code>), allowing it to read bytes from the generic provider:<pre>28
29   ContinuesFactory factory = 
30                MessageLogContinuesFactory.create(log);
31   OldStyleExecutable ose = new OldStyleExecutable(
32                                         factory,
33                                         provider);
34   DOSHeader dos = ose.getDOSHeader();
35   FactoryBundledWithBinaryReader reader = 
36                                 ose.getBinaryReader();
37</pre></li>&#13;
			</ol>&#13;
			<p>After retrieving all the previously mentioned information about the executable file, the loading actions are performed. Since actions are long tasks, every action is preceded by a <code>monitor.isCancelled()</code> call, allowing it to cancel the loading process (lines <code>38</code>, <code>43</code>, <code>47</code>, <code>51</code>, and <code>55</code>), and the user is notified when starting the action via the <code>monitor.setMessage()</code> call (lines <code>39</code>, <code>44</code>, <code>48</code>, <code>52</code>, and <code>56</code>):</p>&#13;
			<pre>38   if (monitor.isCancelled()) return;</pre>&#13;
			<p>In the upcoming sections, we will look over the <a id="_idIndexMarker417"/>following actions in order to deeply understand the <code>load</code> function:</p>&#13;
			<ol>&#13;
				<li value="1"><code>processSegments()</code> (line <code>34</code>):<pre>39   monitor.setMessage("Processing segments...");
40   processSegments(prog, fileBytes, space, reader, dos, 
41                   log, monitor);
42</pre></li>&#13;
				<li><code>adjustSegmentStarts()</code> (line <code>39</code>):<pre>43   if (monitor.isCancelled()) return;
44   monitor.setMessage("Adjusting segments...");
45   adjustSegmentStarts(prog);
46 </pre></li>&#13;
				<li><code>doRelocations()</code> (line <code>43</code>):<pre>47   if (monitor.isCancelled()) return;
48   monitor.setMessage("Processing relocations...");
49   doRelocations(prog, reader, dos);
50 
51   if (monitor.isCancelled()) return;</pre></li>&#13;
				<li><code>createSymbols()</code> (line <code>47</code>):<pre>52   monitor.setMessage("Processing symbols...");
53   createSymbols(space, symbolTable, dos);
54 
55   if (monitor.isCancelled()) return;</pre></li>&#13;
				<li><code>setRegisters()</code> (line <code>56</code>):<pre>56   monitor.setMessage("Setting registers...");
57 
58   Symbol entrySymbol = 
59      SymbolUtilities.getLabelOrFunctionSymbol(
60        prog, ENTRY_NAME, err -&gt; log.error("MZ", err));
61   setRegisters(context, entrySymbol,
62                memory.getBlocks(), dos);
63 }</pre></li>&#13;
			</ol>&#13;
			<p>After covering the <a id="_idIndexMarker418"/>sequence of calls performed by the <code>load</code> function, let's analyze each one in detail. In the following section, we will start by looking at how program segments are processed.</p>&#13;
			<h4>Processing segments</h4>&#13;
			<p>The <code>processSegments()</code> function processes program segments. The following code snippet illustrates <a id="_idIndexMarker419"/>how it calculates segments. The code snippet extracts the code segment relative address from the DOS header via <code>dos.e_cs()</code>, as shown on line <code>04</code>, and, as it is relative to the segment the program was loaded at (in this case, <code>csStart</code>, whose value is equal to the <code>INITIAL_SEGMENT_VAL</code> constant, as shown on line <code>00</code>), it adds the <code>csStart</code> value to it, as shown again on line <code>04</code>:</p>&#13;
			<pre>00 int csStart = INITIAL_SEGMENT_VAL;</pre>&#13;
			<pre>01 HashMap&lt;Address, Address&gt; segMap = new HashMap&lt;Address,</pre>&#13;
			<pre>02                                                Address&gt;();</pre>&#13;
			<pre>03 SegmentedAddress codeAddress = space.getAddress(</pre>&#13;
			<pre>04                  Conv.shortToInt(dos.e_cs()) + csStart, 0);</pre>&#13;
			<p>After calculating the segment addresses, <code>processSegments()</code> uses the Ghidra <code>MemoryBlockUtils.createInitializedBlock()</code> (line <code>01</code>) and <code>MemoryBlockUtils.createUninitializedBlock()</code> (line <code>09</code>) API methods to create the segments (memory regions) that were previously calculated:</p>&#13;
			<pre>00 if (numBytes &gt; 0) </pre>&#13;
			<pre>01   MemoryBlockUtils.createInitializedBlock(</pre>&#13;
			<pre>02                           program, false, "Seg_" + i,</pre>&#13;
			<pre>03                           start, fileBytes, readLoc,</pre>&#13;
			<pre>04                           numBytes, "", "mz", true,</pre>&#13;
			<pre>05                           true, true, log</pre>&#13;
			<pre>06   );</pre>&#13;
			<pre>07 }</pre>&#13;
			<pre>08 if (numUninitBytes &gt; 0) {</pre>&#13;
			<pre>09   MemoryBlockUtils.createUninitializedBlock(</pre>&#13;
			<pre>10                           program, false, "Seg_" + i + "u",</pre>&#13;
			<pre>11                           start.add(numBytes),</pre>&#13;
			<pre>12                           numUninitBytes, "", "mz", true,</pre>&#13;
			<pre>13                           true, false, log</pre>&#13;
			<pre>14   );</pre>&#13;
			<pre>15 }</pre>&#13;
			<p>Since segment <a id="_idIndexMarker420"/>processing is not precise, it requires some adjustment. In the next section, we will look at how to adjust the segments.</p>&#13;
			<h4>Adjusting segment starts</h4>&#13;
			<p>The function <a id="_idIndexMarker421"/>responsible for segment adjustment is <code>adjustSegmentStarts()</code>. It receives the <code>prog</code> program object as a parameter (an object of the <code>Program</code> class). It also retrieves the memory of the program via <code>prog.getMemory()</code> (line <code>00</code>), which allows access to its blocks of memory via the <code>getBlocks()</code> method (line <code>01</code>):</p>&#13;
			<pre>00 Memory mem = prog.getMemory();</pre>&#13;
			<pre>01 MemoryBlock[] blocks = mem.getBlocks();</pre>&#13;
			<p>The approach to adjust the segment consists of checking whether the starting bytes (<code>0x10</code> bytes) of the current block contain a far return (<code>FAR_RETURN_OPCODE</code>, as shown on line <code>00</code>), in which case the block is split by the far return (line <code>03</code>) appending it and the code preceding it to the previous block of memory (line <code>04</code>):</p>&#13;
			<pre>00 if (val == FAR_RETURN_OPCODE) {</pre>&#13;
			<pre>01   Address splitAddr = offAddr.add(1);</pre>&#13;
			<pre>02   String oldName = block.getName();</pre>&#13;
			<pre>03   mem.split(block, splitAddr);</pre>&#13;
			<pre>04   mem.join(blocks[i - 1], blocks[i]);</pre>&#13;
			<pre>05   blocks = mem.getBlocks();</pre>&#13;
			<pre>06   blocks[i].setName(oldName);</pre>&#13;
			<pre>07  }</pre>&#13;
			<p>Now that we've <a id="_idIndexMarker422"/>covered segment adjustment, let's see how code is loaded in the next section.</p>&#13;
			<h4>Code relocation</h4>&#13;
			<p>Code relocation <a id="_idIndexMarker423"/>allows us to load addresses for position-dependent code, adjusting both code and data. It is implemented by the <code>doRelocations()</code> function, which uses the <code>e_lfarlc()</code> method of <code>DOSHeader</code> to retrieve the address of the MZ relocation table (line <code>01</code>). By using <code>e_crlc()</code>, it also retrieves the number of entries comprising the relocation table (line <code>02</code>).</p>&#13;
			<p>For each entry (line <code>03</code>), the segment and the offset being relative to the segment (lines <code>04</code>-<code>05</code>) allows you to calculate the location (line <code>07</code>), which is relative to the segment the program is loaded at (line <code>08</code>):</p>&#13;
			<pre>00  int relocationTableOffset =</pre>&#13;
			<pre>01                          Conv.shortToInt(dos.e_lfarlc());</pre>&#13;
			<pre>02  int numRelocationEntries = dos.e_crlc();</pre>&#13;
			<pre>03  for (int i = 0; i &lt; numRelocationEntries; i++) {</pre>&#13;
			<pre>04    int off = Conv.shortToInt(reader.readNextShort());</pre>&#13;
			<pre>05    int seg = Conv.shortToInt(reader.readNextShort());</pre>&#13;
			<pre>06  </pre>&#13;
			<pre>07    int location = (seg &lt;&lt; 4) + off;</pre>&#13;
			<pre>08    int locOffset = location + dataStart;</pre>&#13;
			<pre>09  </pre>&#13;
			<pre>10    SegmentedAddress fixupAddr = space.getAddress(</pre>&#13;
			<pre>11                                        seg + csStart, off</pre>&#13;
			<pre>12    );</pre>&#13;
			<pre>13    int value = Conv.shortToInt(reader.readShort(</pre>&#13;
			<pre>14                                                 locOffset</pre>&#13;
			<pre>15                                                 )</pre>&#13;
			<pre>16    );</pre>&#13;
			<pre>17    int fixupAddrSeg = (value + csStart) &amp; Conv.SHORT_MASK;</pre>&#13;
			<pre>18    mem.setShort(fixupAddr, (short) fixupAddrSeg);</pre>&#13;
			<pre>19  }</pre>&#13;
			<p>Now that the code is <a id="_idIndexMarker424"/>loaded, it is also possible to create useful symbols for referencing it. We will overview how to create symbols in the next section.</p>&#13;
			<h4>Creating symbols</h4>&#13;
			<p>The <code>createSymbols()</code> function <a id="_idIndexMarker425"/>creates the entry point of the program, which is a symbol. To do that, it uses two <code>DOSHeader</code> methods, <code>e_ip()</code> (line <code>00</code>) and <code>e_cs()</code> (lines <code>01</code>–<code>02</code>), whose values are relative to the segment the program was loaded at:</p>&#13;
			<pre>00  int ipValue = Conv.shortToInt(dos.e_ip());</pre>&#13;
			<pre>01  int codeSegment = Conv.shortToInt(dos.e_cs()) +</pre>&#13;
			<pre>02                                    INITIAL_SEGMENT_VAL;</pre>&#13;
			<p>By using <code>e_ip()</code>, the program retrieves the IP start value (the entry point offset relative to the code segment) while the code segment is retrieved via <code>e_cs()</code>. By calling to the <code>getAddress()</code> method of <code>SegmentedAddressSpace</code> and giving to it the <code>IP</code> and <code>CS</code> values, it retrieves the entry point at <code>addr</code> (line <code>00</code>). Finally, it creates the label for the entry point using the <code>createLabel()</code> method of the <code>SymbolTable</code> class (lines <code>01</code>–<code>02</code>) and adds the entry point symbol (line <code>03</code>) to the program:</p>&#13;
			<pre>00  Address addr = space.getAddress(codeSegment, ipValue);</pre>&#13;
			<pre>01  symbolTable.createLabel(addr, ENTRY_NAME, </pre>&#13;
			<pre>02                          SourceType.IMPORTED);</pre>&#13;
			<pre>03  symbolTable.addExternalEntryPoint(addr);</pre>&#13;
			<p>After creating the entry <a id="_idIndexMarker426"/>point symbol, let's look at how to set the segment registers.</p>&#13;
			<h4>Setting registers</h4>&#13;
			<p>The <a id="_idIndexMarker427"/>program registers are set by the <code>setRegisters()</code> function, which gets the stack and segment register objects (<code>ss</code>, <code>sp</code>, <code>ds</code>, and <code>cs</code>) by calling the <code>getRegister()</code> method of <code>ProgramContext</code>. Then, it sets the register object via <code>setValue()</code> with values extracted from the DOS header.</p>&#13;
			<p>The following code snippet illustrates how to retrieve the <code>ss</code> register (line <code>00</code>) and set the appropriate MZ header-retrieved value (line <code>04</code>) to it (line <code>01</code>):</p>&#13;
			<pre>00  Register ss = context.getRegister("ss");</pre>&#13;
			<pre>01  context.setValue(ss, entry.getAddress(), </pre>&#13;
			<pre>02                   entry.getAddress(), </pre>&#13;
			<pre>03                   BigInteger.valueOf(</pre>&#13;
			<pre>04                               Conv.shortToLong(dos.e_ss())</pre>&#13;
			<pre>05                   )</pre>&#13;
			<pre>06  );</pre>&#13;
			<p class="callout-heading">The MzLoader source code</p>&#13;
			<p class="callout">In the previous code snippets, a lot of implementation details were omitted in order to keep the focus on the key aspects and relevant parts. If you want to dig into the details, please, follow this link: <a href="https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/MzLoader.java">https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/MzLoader.java</a>.</p>&#13;
			<p>As you will notice, the loader development complexity strongly depends on the binary format. We learned <a id="_idIndexMarker428"/>about loaders by analyzing a real-world example; therefore, the complexity of the code shown here is real-world complexity.</p>&#13;
			<h1 id="_idParaDest-165"><a id="_idTextAnchor206"/>Understanding filesystem loaders</h1>&#13;
			<p>Ghidra also <a id="_idIndexMarker429"/>allows us to load filesystems. Filesystems are, basically, archive files (a file containing other files):</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B16207_11_009.jpg" alt=" Figure 11.9 – A file named hello_world.zip imported as a filesystem&#13;&#10;"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption"> Figure 11.9 – A file named hello_world.zip imported as a filesystem</p>&#13;
			<p>A good example of a filesystem loader implemented by Ghidra is the ZIP compressed format loader, which is available here: <a href="https://github.com/NationalSecurityAgency/ghidra/tree/master/Ghidra/Features/FileFormats/src/main/java/ghidra/file/formats/zip">https://github.com/NationalSecurityAgency/ghidra/tree/master/Ghidra/Features/FileFormats/src/main/java/ghidra/file/formats/zip</a>.</p>&#13;
			<p>To develop a filesystem, you will need to implement the <code>GFileSystem</code> interface with the following methods: <code>getDescription</code>, <code>getFileCount</code>, <code>getFSRL</code>, <code>getInfo</code>, <code>getInputStream</code>, <code>getListing</code>, <code>getName</code>, <code>getRefManager</code>, <code>getType</code>, <code>isClosed</code>, <code>isStatic</code> <code>lookup</code>, and <code>close</code>.</p>&#13;
			<h2 id="_idParaDest-166"><a id="_idTextAnchor207"/>FileSystem Resource Locator</h2>&#13;
			<p>A <a id="_idIndexMarker430"/>remarkable method of the <code>GFileSystem</code> interface is <code>getFSRL</code>, which allows you to retrieve the <strong class="bold">FileSystem Resource Locator</strong> (<strong class="bold">FSRL</strong>). An FSRL is a string allowing Ghidra to access files and directories stored in a filesystem:</p>&#13;
			<ul>&#13;
				<li>The FSRL for accessing a file located in the local filesystem: <code>file://directory/subdirectory/file</code>.</li>&#13;
				<li>The FSRL for accessing a file located in a ZIP archive file: <code>file://directory/subdirectory/example.zip|zip://file</code>.</li>&#13;
				<li>The FSRL for accessing a file in nested filesystems (for example, <code>tar</code> stored in a <code>zip</code> file): <code>file://directory/subdirectory/example.zip|zip:// directory /nested.tar|tar://file</code>.</li>&#13;
				<li>The FSRL for accessing a file but checking its <code>MD5</code>: <code>file://directory/subdirectory/example.zip?MD5= 6ab0553f4ffedd5d1a07ede1230c4887 |zip://file?MD5= 0ddb5d230a202d20a8de31a69d836379</code>.</li>&#13;
				<li>Another remarkable method is <code>getRefManager</code>, which allows accessing <code>GFileSystem</code> but preventing it from being closed via the <code>close</code> method.</li>&#13;
				<li>Finally, <code>FileSystemService</code> can be used to instantiate filesystems. <p class="callout-heading">Filesystem loaders</p><p class="callout">If you want to learn more about loaders, please check out the following official documentation links: </p><p class="callout">– <a href="https://ghidra.re/ghidra_docs/api/ghidra/formats/gfilesystem/GFileSystem.html">https://ghidra.re/ghidra_docs/api/ghidra/formats/gfilesystem/GFileSystem.html</a></p><p class="callout">– <a href="https://ghidra.re/ghidra_docs/api/ghidra/formats/gfilesystem/FSRL.html">https://ghidra.re/ghidra_docs/api/ghidra/formats/gfilesystem/FSRL.html</a></p><p class="callout">– <a href="https://ghidra.re/ghidra_docs/api/ghidra/formats/gfilesystem/FileSystemService.html">https://ghidra.re/ghidra_docs/api/ghidra/formats/gfilesystem/FileSystemService.html</a></p></li>&#13;
			</ul>&#13;
			<p>This is the way that filesystem loaders are implemented. If you want to look further into the details, please remember to check the ZIP filesystem implementation.</p>&#13;
			<h1 id="_idParaDest-167"><a id="_idTextAnchor208"/>Summary</h1>&#13;
			<p>In this chapter, you learned what a binary file is and how it can be dichotomously classified as a raw binary or a formatted binary, and you also learned that any formatted binary is also a raw binary.</p>&#13;
			<p>You learned skills for Ghidra file importing by loading both raw binaries and formatted binaries. This new skill allows you to configure better options when loading a file and manually perform some adjustments if necessary.</p>&#13;
			<p>You also learned about the old-style DOS executable format by producing a <code>hello world</code> program from scratch written in assembly language and later analyzing it with a hexadecimal editor.</p>&#13;
			<p>Finally, you learned how to extend Ghidra with new loaders and filesystems, allowing you to import unsupported and exoteric binary formats and archive files. You learned this by analyzing the old-style DOS executable format loader, a good real-world example to start with.</p>&#13;
			<p>In the next chapter, we will cover an advanced topic in Ghidra, which is processor module development. This skill will enable you to incorporate unsupported processors into Ghidra. It includes virtualization processors commonly used in advanced binary obfuscation. Beyond that, you will learn a lot about disassemblers along the way.</p>&#13;
			<h1 id="_idParaDest-168"><a id="_idTextAnchor209"/>Questions</h1>&#13;
			<ol>&#13;
				<li value="1">What is the difference between raw binaries and formatted binaries?</li>&#13;
				<li>Taking into account that any formatted binary is also a raw binary, why are formatted binaries necessary?</li>&#13;
				<li>What is an old-style DOS executable and what software pieces comprise the loader enabling Ghidra to support it?</li>&#13;
			</ol>&#13;
			<h1 id="_idParaDest-169"><a id="_idTextAnchor210"/>Further reading</h1>&#13;
			<p>You can refer to the following links for more information on the topics covered in this chapter:</p>&#13;
			<ul>&#13;
				<li><em class="italic">Mastering Assembly Programming</em>,  <em class="italic">Alexey Lyashko</em>, <em class="italic">September 2017</em>: <a href="https://subscription.packtpub.com/book/application_development/9781787287488">https://subscription.packtpub.com/book/application_development/9781787287488</a></li>&#13;
				<li>The DOS MZ executable – format specification using the Kaitai Struct declarative language: <a href="https://formats.kaitai.io/dos_mz/index.html">https://formats.kaitai.io/dos_mz/index.html</a></li>&#13;
				<li>Online Ghidra loader documentation: <a href="https://ghidra.re/ghidra_docs/api/ghidra/app/util/opinion/Loader.html">https://ghidra.re/ghidra_docs/api/ghidra/app/util/opinion/Loader.html</a> </li>&#13;
			</ul>&#13;
		</div>&#13;
	</div></body></html>