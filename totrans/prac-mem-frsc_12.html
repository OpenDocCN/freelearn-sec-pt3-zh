<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer278">
			<h1 id="_idParaDest-132"><a id="_idTextAnchor141"/>Chapter 9: Malicious Activity Detection</h1>
			<p>Under most circumstances, the main goal of a memory forensic investigation is to look for malicious activity. According to recent <strong class="bold">TrendMicro</strong> (<a href="https://www.trendmicro.com/vinfo/us/security/news/cybercrime-and-digital-threats/a-look-at-linux-threats-risks-and-recommendations">https://www.trendmicro.com/vinfo/us/security/news/cybercrime-and-digital-threats/a-look-at-linux-threats-risks-and-recommendations</a>) and <strong class="bold">Group-IB</strong> (<a href="https://www.group-ib.com/media/ransomware-empire-2021/">https://www.group-ib.com/media/ransomware-empire-2021/</a>, <a href="https://blog.group-ib.com/blackmatter">https://blog.group-ib.com/blackmatter</a>) research, attacks on Linux-based systems are on the rise, and many threat actors have added specialized software targeting Linux-based systems to their arsenal. For example, ransomware operators such as <strong class="bold">BlackMatter</strong>, <strong class="bold">RansomExx</strong>, and <strong class="bold">Hive</strong> have added corresponding versions to their arsenal. Furthermore, post-exploitation frameworks and individual scripts are also used to attack Linux-based systems. At the same time, exploitation of vulnerabilities and the use of security misconfigurations remain the most widespread initial access techniques, especially when we are talking about web applications.</p>
			<p>The main activity we are going to look at is almost the same – network connections, injections into processes, and access to atypical resources. This is what we will try to focus on, but this time we will try to break down different analysis techniques with concrete examples.</p>
			<p>In this chapter, we will discuss the following topics:</p>
			<ul>
				<li>Investigating network activity </li>
				<li>Analyzing malicious activity</li>
				<li>Examining kernel objects</li>
			</ul>
			<h1 id="_idParaDest-133"><a id="_idTextAnchor142"/>Investigating network activity</h1>
			<p>Since most malware needs to communicate<a id="_idIndexMarker489"/> with a command-and-control server, download additional modules, or send some data, the appearance of network connections is unavoidable. However, before going on to investigate network connections, it would be a good idea to find out which network interfaces were used on our host and how they were configured. To do this, we can use the Volatility <strong class="source-inline">linux_ifconfig</strong> plugin, which provides all the necessary information in the following way:</p>
			<div>
				<div id="_idContainer237" class="IMG---Figure">
					<img src="Images/Figure_9.1_B17056.jpg" alt="Figure 9.1 – Information about network interfaces&#13;&#10;" width="1170" height="241"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.1 – Information about network interfaces</p>
			<p>In the output, we can see that there are three interfaces used on the investigated host:</p>
			<ul>
				<li><strong class="source-inline">lo</strong> – A loopback interface with the standard <strong class="source-inline">127.0.0.1</strong> IP address</li>
				<li><strong class="source-inline">ens33</strong> – A network interface with the <strong class="source-inline">192.168.168.144</strong> IP address</li>
				<li><strong class="source-inline">ens38</strong> – A network interface with the <strong class="source-inline">192.168.3.133</strong> IP address</li>
			</ul>
			<p>We can now start investigating active network<a id="_idIndexMarker490"/> connections. For this purpose, Volatility has the <strong class="source-inline">linux_netstat</strong> plugin, which can be run as follows:</p>
			<div>
				<div id="_idContainer238" class="IMG---Figure">
					<img src="Images/Figure_9.2_B17056.jpg" alt="Figure 9.2 – Volatility linux_netstat plugin&#13;&#10;" width="1177" height="314"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.2 – Volatility linux_netstat plugin</p>
			<p>As you can see, in this case, we will also have quite an extensive output, and it won't only be associated with the network connections we are directly interested in, so it is better to redirect the output to a text file:</p>
			<div>
				<div id="_idContainer239" class="IMG---Figure">
					<img src="Images/Figure_9.3_B17056.jpg" alt="Figure 9.3 – Active network connections&#13;&#10;" width="1139" height="482"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.3 – Active network connections</p>
			<p>In this case, we see a connection established by the Firefox browser, as well as multiple connections established by <strong class="bold">Postgres</strong> and <strong class="bold">Ruby</strong>. This activity can be observed in various situations, one<a id="_idIndexMarker491"/> of which is the use of the Metasploit<a id="_idIndexMarker492"/> post-exploitation framework on the attacker's host. Also note the connection to the <strong class="source-inline">192.168.3.132</strong> IP address, which was set up using port <strong class="source-inline">22</strong>, which is typical for <strong class="source-inline">SSH</strong>. It is likely that this was the victim's host, which was connected through <strong class="source-inline">SSH</strong>. </p>
			<p>Another way to check<a id="_idIndexMarker493"/> the network activity is to use Bulk Extractor, as it allows us to extract leftover network traffic from memory dumps. In this case, we use the net scanner, as shown here:</p>
			<div>
				<div id="_idContainer240" class="IMG---Figure">
					<img src="Images/Figure_9.4_B17056.jpg" alt="Figure 9.4 – Bulk Extractor net scanner&#13;&#10;" width="1010" height="323"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.4 – Bulk Extractor net scanner</p>
			<p>The output will contain the <strong class="source-inline">packets.pcap</strong> file, which is a dump of network traffic. This<a id="_idIndexMarker494"/> file can be opened with <strong class="bold">Wireshark</strong>, one of the most widely used network protocol analyzers. To get this tool, simply go to the official website (<a href="https://www.wireshark.org/">https://www.wireshark.org/</a>), click on the <strong class="bold">Download</strong> icon, and choose<a id="_idIndexMarker495"/> the installer version suitable for your system.</p>
			<p>After installation, you can run Wireshark<a id="_idIndexMarker496"/> and simply drag and drop the <strong class="source-inline">packets.pcap</strong> file inside:</p>
			<div>
				<div id="_idContainer241" class="IMG---Figure">
					<img src="Images/Figure_9.5_B17056.jpg" alt="Figure 9.5 – Dump of the network traffic opened with Wireshark&#13;&#10;" width="1155" height="634"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.5 – Dump of the network traffic opened with Wireshark</p>
			<p>Here, you can see the endpoints statistics and find out what IP addresses were connected to. To do this, open the <strong class="bold">Statistics</strong> tab and search for <strong class="bold">Endpoints</strong>:</p>
			<div>
				<div id="_idContainer242" class="IMG---Figure">
					<img src="Images/Figure_9.6_B17056.jpg" alt="Figure 9.6 – Endpoints &#13;&#10;" width="808" height="431"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.6 – Endpoints </p>
			<p>Similarly, you can see<a id="_idIndexMarker497"/> statistics on the protocols used:</p>
			<div>
				<div id="_idContainer243" class="IMG---Figure">
					<img src="Images/Figure_9.7_B17056.jpg" alt="Figure 9.7 – Protocol hierarchy&#13;&#10;" width="954" height="415"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.7 – Protocol hierarchy</p>
			<p>We can examine individual packets or try to extract transmitted objects, and it is also possible to configure filters<a id="_idIndexMarker498"/> and check communication with individual IP addresses. In our case, for example, you can check whether an <strong class="source-inline">SSH</strong> connection was actually established with a specific IP address by using the simple <strong class="source-inline">ip.addr==192.168.3.133 &amp;&amp; ssh</strong> filter:</p>
			<div>
				<div id="_idContainer244" class="IMG---Figure">
					<img src="Images/Figure_9.8_B17056.jpg" alt="Figure 9.8 – Wireshark filter for SSH&#13;&#10;" width="1155" height="634"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.8 – Wireshark filter for SSH</p>
			<p>In the figure, we see a large number of packets passing between our IP and the <strong class="source-inline">192.168.3.132</strong> IP. Such communication will naturally attract our attention.</p>
			<p>Here is another example of how analysis of network connections or network traffic from the memory dump can be useful:</p>
			<div>
				<div id="_idContainer245" class="IMG---Figure">
					<img src="Images/Figure_9.9_B17056.jpg" alt="Figure 9.9 – Meterpreter activity&#13;&#10;" width="1558" height="478"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.9 – Meterpreter activity</p>
			<p>Here, we can see active use of port <strong class="source-inline">4444</strong>. Remember in <a href="B17056_05_Final_JM_ePub.xhtml#_idTextAnchor078"><em class="italic">Chapter 5</em></a>, <em class="italic">Malware Detection and Analysis with Windows Memory Forensics</em>, when we talked about how some ports are used by default by different software? This is exactly the case, and port <strong class="source-inline">4444</strong> is used by default by the Meterpreter reverse shell. So, we can<a id="_idIndexMarker499"/> already tell from one traffic analysis that there are processes on the examined host that are related to Meterpreter.</p>
			<p>Let's look at one more example:</p>
			<div>
				<div id="_idContainer246" class="IMG---Figure">
					<img src="Images/Figure_9.10_B17056.jpg" alt="Figure 9.10 – Nginx activity&#13;&#10;" width="1067" height="357"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.10 – Nginx activity</p>
			<p>In the output of <strong class="source-inline">linux_netstat</strong>, we can see that the investigated host is used as a web server because on port <strong class="source-inline">80</strong>, the <strong class="source-inline">nginx</strong> process is listening:</p>
			<div>
				<div id="_idContainer247" class="IMG---Figure">
					<img src="Images/Figure_9.11_B17056.jpg" alt="Figure 9.11 – SSH connections&#13;&#10;" width="1100" height="467"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.11 – SSH connections</p>
			<p>In addition, we can see several <strong class="source-inline">SSH</strong> connections with different IP addresses. In this case, we can conclude that one of those IP addresses could potentially be used by an attacker. </p>
			<p>Since the output of the plugin contains<a id="_idIndexMarker500"/> information on the processes that initiated the connections, naturally, sooner or later, we will get to investigating those processes. </p>
			<p>In all these examples, we see traces of potentially malicious activity. Let's talk about how to analyze this kind of activity.</p>
			<h1 id="_idParaDest-134"><a id="_idTextAnchor143"/>Analyzing malicious activity</h1>
			<p>Let's take a closer look at the last example. We saw that we had several <strong class="source-inline">SSH</strong> connections. We can analyze the processes<a id="_idIndexMarker501"/> that might be related to that. To do that, let's use the <strong class="source-inline">linux_pstree</strong> plugin and add <strong class="source-inline">sshd</strong> process identifiers – <strong class="source-inline">29897</strong> and <strong class="source-inline">23251</strong>:</p>
			<div>
				<div id="_idContainer248" class="IMG---Figure">
					<img src="Images/Figure_9.12_B17056.jpg" alt="Figure 9.12 – Volatility linux_pstree&#13;&#10;" width="1143" height="303"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.12 – Volatility linux_pstree</p>
			<p>In <em class="italic">Figure 9.12</em>, we can see that the child processes of <strong class="source-inline">sshd</strong> are bash as well as <strong class="source-inline">sudo</strong>, which means that elevated<a id="_idIndexMarker502"/> privileges were used. In this case, we can search the bash history as well as dump and analyze the memory of these processes. </p>
			<p>We start with the bash history. For this, we will use the <strong class="source-inline">linux_bash</strong> plugin:</p>
			<div>
				<div id="_idContainer249" class="IMG---Figure">
					<img src="Images/Figure_9.13_B17056.jpg" alt="Figure 9.13 – Bash history&#13;&#10;" width="1650" height="601"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.13 – Bash history</p>
			<p>Here, we can see that someone was working with MySQL and WordPress, and we can see the interaction with the <strong class="source-inline">site-info.php</strong> file, as well as the <strong class="source-inline">nyan-cat.gif</strong> download associated with the bash process with the <strong class="source-inline">30112</strong> PID.</p>
			<p>We can check which user ran bash in this case. To do this, we will use the already known <strong class="source-inline">linux_psenv</strong> Volatility plugin:</p>
			<div>
				<div id="_idContainer250" class="IMG---Figure">
					<img src="Images/Figure_9.14_B17056.jpg" alt="Figure 9.14 – Bash process's environment&#13;&#10;" width="1154" height="254"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.14 – Bash process's environment</p>
			<p>The output of this plugin allows us to determine that this activity was performed within the <strong class="source-inline">SSH</strong> connection from the <strong class="source-inline">192.168.110.40</strong> IP address by the user admin. We can search for information about this user. In the previous chapter, we already mentioned that this information<a id="_idIndexMarker503"/> can be found in the <strong class="source-inline">/etc/passwd</strong> file, so let's use the <strong class="source-inline">linux_recover_filesystem</strong> plugin and try to recover the filesystem from memory. To do that, we will use the following command:</p>
			<p class="source-code">$ vol.py --plugins=profiles -f /mnt/hgfs/flash/ubuntu-server.vmem --profile=Linuxubuntu-server_17_47_52-profilex64 linux_recover_filesystem -D /mnt/hgfs/flash/recovered/</p>
			<p>In our case, the restored filesystem will be placed in the recovered folder:</p>
			<div>
				<div id="_idContainer251" class="IMG---Figure">
					<img src="Images/Figure_9.15_B17056.jpg" alt="Figure 9.15 – Recovered folder content&#13;&#10;" width="1097" height="627"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.15 – Recovered folder content</p>
			<p>As you can see in the figure, the <strong class="source-inline">/etc</strong> directory failed<a id="_idIndexMarker504"/> to recover; nevertheless, we have <strong class="source-inline">/var/log</strong> where we can find the <strong class="source-inline">auth.log</strong> file:</p>
			<div>
				<div id="_idContainer252" class="IMG---Figure">
					<img src="Images/Figure_9.16_B17056.jpg" alt="Figure 9.16 – Recovered auth.log file&#13;&#10;" width="1086" height="556"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.16 – Recovered auth.log file</p>
			<p>This file logs all authentication attempts, and we can find the following:</p>
			<div>
				<div id="_idContainer253" class="IMG---Figure">
					<img src="Images/Figure_9.17_B17056.jpg" alt="Figure 9.17 – The content of auth.log file&#13;&#10;" width="1650" height="618"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.17 – The content of auth.log file</p>
			<p>Note that from here we get the information that the admin user was created at the time of the attack, and we also have a specific timestamp for its creation. After that, we can also see several logins from this user<a id="_idIndexMarker505"/> and its use of root, on behalf of which our picture was downloaded. We also see that the picture was uploaded to <strong class="source-inline">/var/www/wordpress</strong>. Fortunately, the <strong class="source-inline">linux_recover_filesystem</strong> plugin was able to partially recover this folder:</p>
			<div>
				<div id="_idContainer254" class="IMG---Figure">
					<img src="Images/Figure_9.18_B17056.jpg" alt="Figure 9.18 – Recovered WordPress folder&#13;&#10;" width="1218" height="550"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.18 – Recovered WordPress folder</p>
			<p>Here, we can see our picture. So, we need to find out what role it plays here and how exactly the attacker gained access to the system.</p>
			<p>Let's add the network traffic dump extracted from the memory dump to our investigation. To extract the traffic, we run Bulk Extractor:</p>
			<div>
				<div id="_idContainer255" class="IMG---Figure">
					<img src="Images/Figure_9.19_B17056.jpg" alt="Figure 9.19 – Network traffic extraction&#13;&#10;" width="978" height="319"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.19 – Network traffic extraction</p>
			<p>Now, we open the <strong class="source-inline">packets.pcap</strong> file in Wireshark. Examining<a id="_idIndexMarker506"/> the packets, you may come across the following:</p>
			<div>
				<div id="_idContainer256" class="IMG---Figure">
					<img src="Images/Figure_9.20_B17056.jpg" alt="Figure 9.20 – Wireshark packet analysis&#13;&#10;" width="636" height="293"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.20 – Wireshark packet analysis</p>
			<p>We see a <strong class="source-inline">GET</strong> request with interesting parameters. As you can see, the user agent listed here is <strong class="source-inline">WPScan v.3.8.7</strong>. This means that this request was made using the WPScan tool, used to search for vulnerabilities in the content management system WordPress. Similar information should be logged in the <strong class="source-inline">nginx</strong> access log. This log was also recovered using <strong class="source-inline">linux_recover_filesystem</strong> and can be found in <strong class="source-inline">/var/log/nginx</strong>:</p>
			<div>
				<div id="_idContainer257" class="IMG---Figure">
					<img src="Images/Figure_9.21_B17056.jpg" alt="Figure 9.21 – Recovered access log&#13;&#10;" width="1650" height="667"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.21 – Recovered access log</p>
			<p>In <strong class="source-inline">access.log</strong>, we can see a huge number of requests<a id="_idIndexMarker507"/> sent by WPScan from an IP address we already know. If we go further, we can also see the following:</p>
			<div>
				<div id="_idContainer258" class="IMG---Figure">
					<img src="Images/Figure_9.22_B17056.jpg" alt="Figure 9.22 – Comment post&#13;&#10;" width="1628" height="645"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.22 – Comment post</p>
			<p>After the scan was completed, a <strong class="source-inline">POST</strong> request was sent with a comment; possibly, a vulnerability related to comment sending was used for the initial access. </p>
			<p>Continuing the analysis, we can try to extract objects transmitted during the network session using Wireshark's Export Objects feature:</p>
			<div>
				<div id="_idContainer259" class="IMG---Figure">
					<img src="Images/Figure_9.23_B17056.jpg" alt=" Figure 9.23 – Objects export in Wireshark&#13;&#10;" width="750" height="344"/>
				</div>
			</div>
			<p class="figure-caption"> Figure 9.23 – Objects export in Wireshark</p>
			<p>As you can see in the preceding figure, in our case several objects<a id="_idIndexMarker508"/> have been found that we can try to extract. This includes some comments. Let's check them out:</p>
			<div>
				<div id="_idContainer260" class="IMG---Figure">
					<img src="Images/Figure_9.24_B17056.jpg" alt="Figure 9.24 – Exported comments&#13;&#10;" width="923" height="430"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.24 – Exported comments</p>
			<p>As we can see, one of the users left a comment on the blog with a link accessing the same <strong class="source-inline">192.168.110.40</strong> IP address. You can also see in the traffic dump that the same <strong class="source-inline">SSH</strong> connections started to appear sometime after the attempt to open the link. </p>
			<p>If we consider the situation from the point of view of WordPress, the comments sent by users must be saved in the database. Accordingly, you can look for information about them in the MySQL logs or in the memory of this process. From the list of processes, we can say that our mysqld process related to mysql deamon has the identifier<strong class="source-inline"> 29602</strong>:</p>
			<div>
				<div id="_idContainer261" class="IMG---Figure">
					<img src="Images/Figure_9.25_B17056.jpg" alt="Figure 9.25 – Process ID of mysqld&#13;&#10;" width="563" height="201"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.25 – Process ID of mysqld</p>
			<p>Now, we can dump the mapping<a id="_idIndexMarker509"/> of this process with the <strong class="source-inline">linux_dump_map</strong> plugin:</p>
			<div>
				<div id="_idContainer262" class="IMG---Figure">
					<img src="Images/Figure_9.26_B17056.jpg" alt="Figure 9.26 – Volatility linux_dump_map&#13;&#10;" width="1381" height="357"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.26 – Volatility linux_dump_map</p>
			<p>Now, it is the turn of the <strong class="source-inline">strings</strong> utility:</p>
			<p class="source-code">$ for file in /mnt/hgfs/flash/mysql/*; do strings "$file" &gt;&gt; /mnt/hgfs/flash/mysql_strings.txt; done</p>
			<p>We can now explore the <strong class="source-inline">strings</strong> output and look for information about our comments:</p>
			<div>
				<div id="_idContainer263" class="IMG---Figure">
					<img src="Images/Figure_9.27_B17056.jpg" alt="Figure 9.27 – Comments in the mysqld process memory&#13;&#10;" width="1650" height="592"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.27 – Comments in the mysqld process memory</p>
			<p>Bingo! Here, we can see not only the comment that was sent but also the actual payload that was used. Now, we know for sure that the attackers used exploitation of vulnerabilities for the initial access. That's one mystery solved. </p>
			<p>In <em class="italic">Figure 9.27</em>, we can also note the interaction with the <strong class="source-inline">site-info.php</strong> file in the footer. Since we managed to extract<a id="_idIndexMarker510"/> the WordPress folder along with the filesystem, let's find this file:</p>
			<div>
				<div id="_idContainer264" class="IMG---Figure">
					<img src="Images/Figure_9.28_B17056.jpg" alt="Figure 9.28 – WordPress-related files&#13;&#10;" width="1123" height="493"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.28 – WordPress-related files</p>
			<p>The content of this file looks as follows:</p>
			<div>
				<div id="_idContainer265" class="IMG---Figure">
					<img src="Images/Figure_9.29_B17056.jpg" alt="Figure 9.29 – The content of the site-info.php file&#13;&#10;" width="1418" height="422"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.29 – The content of the site-info.php file</p>
			<p>Based on all the information obtained, we can conclude that after accessing the host, the attacker changed the source code of the site so that now when users visit the compromised resource, they will see a picture instead of a blog. </p>
			<p>Let's consider in a similar way the Meterpreter example<a id="_idIndexMarker511"/> we mentioned earlier. This is an example worthy of special attention because this type of payload is most often found on Linux-based systems involved in incidents. So, we have information that some connections were made using port <strong class="source-inline">4444</strong>. Let's try to find out which process the Meterpreter is associated with. The most logical thing to do here would be to check the network connections and look for connections to ports and addresses we know, and then look for the process that established the connection. However, you may come across a situation where there is no information about network connections or no information about the exact connections you are looking for. In this case, you can use YARA rules with the <strong class="source-inline">linux_yarascan</strong> plugin to try to find a process with our IP address in its memory. Also, injections into processes are often related to Meterpreter, as attackers need to somehow put the payload into memory. In this case, Volatility has the <strong class="source-inline">linux_malfind</strong> plugin, which is an analog of the Windows plugin with the same name. Let's run it:</p>
			<div>
				<div id="_idContainer266" class="IMG---Figure">
					<img src="Images/Figure_9.30_B17056.jpg" alt="Figure 9.30 – Volatility linux_malfind&#13;&#10;" width="1261" height="297"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.30 – Volatility linux_malfind</p>
			<p>In the output of the plugin, we can find something similar. We have a rules_for_emplo process, associated with the <strong class="source-inline">rules_for_employees</strong> file, which is located in the <strong class="source-inline">it-sec</strong> user downloads. The inject found there starts with <strong class="source-inline">ELF</strong>, so we are dealing with something executable.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout"><strong class="bold">Executable and Linkable Format</strong> (<strong class="bold">ELF</strong>) is a binary file format used in many<a id="_idIndexMarker512"/> modern UNIX-like operating systems, such as Ubuntu, FreeBSD, Linux, and Solaris.</p>
			<p>First of all, we can try<a id="_idIndexMarker513"/> to analyze the rules_for_emplo process. For this purpose, we can extract the executable itself using the <strong class="source-inline">linux_procdump</strong> plugin:</p>
			<div>
				<div id="_idContainer267" class="IMG---Figure">
					<img src="Images/Figure_9.31_B17056.jpg" alt="Figure 9.31 – Executable extraction&#13;&#10;" width="1588" height="139"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.31 – Executable extraction</p>
			<p>After extraction, we can either calculate the hash of the executable and check it in cyber threat intelligence platforms or try to run the file in a controlled environment and find out what it does. Of course, if you have reverse engineering skills or have a dedicated malware analysis team, they are good options as well. Another way is to extract the memory of this process with the <strong class="source-inline">linux_dump_map</strong> plugin:</p>
			<div>
				<div id="_idContainer268" class="IMG---Figure">
					<img src="Images/Figure_9.32_B17056.jpg" alt="Figure 9.32 – Process memory extraction&#13;&#10;" width="1588" height="267"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.32 – Process memory extraction</p>
			<p>Then, we can use our script again to get readable strings:</p>
			<p class="source-code">for file in /mnt/hgfs/flash/rules_for_employees/*; do strings "$file" &gt;&gt; /mnt/hgfs/flash/rules_strings.txt; done</p>
			<p>The result will be the following:</p>
			<div>
				<div id="_idContainer269" class="IMG---Figure">
					<img src="Images/Figure_9.33_B17056.jpg" alt="Figure 9.33 – IP addresses in the rules_for_emplo process memory&#13;&#10;" width="968" height="474"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.33 – IP addresses in the rules_for_emplo process memory</p>
			<p>In the strings extracted from the memory of our process, we can find the <strong class="source-inline">192.168.168.144</strong> IP address with which we saw many connections and the <strong class="source-inline">tcp://192.168.168.153:4444</strong> string. From that, we can conclude that <strong class="source-inline">reverse_tcp</strong> was used.</p>
			<p>Let's look a little bit more into what happened<a id="_idIndexMarker514"/> after the rules_for_emplo process started. We will use the <strong class="source-inline">linux_pstree</strong> plugin to get a list of active processes and display their parent and child relationships:</p>
			<div>
				<div id="_idContainer270" class="IMG---Figure">
					<img src="Images/Figure_9.34_B17056.jpg" alt="Figure 9.34 – Child processes of rules_for_emplo &#13;&#10;" width="636" height="445"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.34 – Child processes of rules_for_emplo </p>
			<p>Here, we see the rules_for_emplo process, which spawns shells, including ones with elevated privileges, Python and systemctl. Let's see how these processes<a id="_idIndexMarker515"/> were started. To do this, we will use the <strong class="source-inline">linux_psaux</strong> plugin:</p>
			<div>
				<div id="_idContainer271" class="IMG---Figure">
					<img src="Images/Figure_9.35_B17056.jpg" alt="Figure 9.35 – Starting arguments of child processes&#13;&#10;" width="801" height="181"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.35 – Starting arguments of child processes</p>
			<p>Here, we see that Python was used to spawn a <strong class="source-inline">tty</strong> shell and get <strong class="source-inline">sudo</strong>. To understand what was going on here, we can use the <strong class="source-inline">linux_bash</strong> plugin to see what commands were executed:</p>
			<div>
				<div id="_idContainer272" class="IMG---Figure">
					<img src="Images/Figure_9.36_B17056.jpg" alt="Figure 9.36 – Bash history&#13;&#10;" width="1262" height="556"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.36 – Bash history</p>
			<p>From the output of this plugin, we can see that the attacker was trying to install a cron job to get persistence, while systemctl was used to reload the cron service and check its status. We can also notice that the <strong class="source-inline">/tmp</strong> directory was used as a working directory for creating and storing temporary files. It would be nice to know what cron job was created in the end. On Linux-based systems, such activity should be logged to <strong class="source-inline">/var/log/cron.log</strong>, from which you can get information about the job that was created.</p>
			<p>By the way, if you are interested<a id="_idIndexMarker516"/> in resources used by a certain process, you can still use the <strong class="source-inline">linux_lsof</strong> plugin. The point is that, in Linux philosophy, everything is a file. That is to say, if the process used text files, sockets, or pipes, all of those things can be found in the output of <strong class="source-inline">linux_lsof</strong>. For example, if we run <strong class="source-inline">linux_lsof</strong> for rules_for_emplo and all the processes it spawns and redirect the output to a text file, we will see the following:</p>
			<div>
				<div id="_idContainer273" class="IMG---Figure">
					<img src="Images/Figure_9.37_B17056.jpg" alt="Figure 9.37 – Volatility linux_lsof output&#13;&#10;" width="1057" height="623"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.37 – Volatility linux_lsof output</p>
			<p>Here, we see descriptors<a id="_idIndexMarker517"/> for the following resources:</p>
			<ul>
				<li><strong class="source-inline">/dev/null</strong> is a special file, which is a so-called <em class="italic">empty device</em>. Writing to it is successful, regardless of the amount<a id="_idIndexMarker518"/> of information, and reading is equivalent to reading the end of the file.</li>
				<li><strong class="source-inline">/dev/ptmx</strong> is a character file used to create a pseudo-terminal master and slave pair.</li>
				<li><strong class="source-inline">/dev/pts</strong> is a special directory that is created dynamically by the Linux kernel. The<a id="_idIndexMarker519"/> entries in <strong class="source-inline">/dev/pts</strong> correspond<a id="_idIndexMarker520"/> to pseudo-terminals (<strong class="bold">pseudo-TTYs</strong> or <strong class="bold">PTYs</strong>).</li>
				<li><strong class="source-inline">/dev/tty</strong> stands for the controlling terminal for the current process.</li>
			</ul>
			<p>As you can see, in general, the initial malicious activity detection and analysis process on Linux-based systems is not very different from that on Windows. We concentrate on looking for suspicious connections, processes with weird names, atypical child processes or behavior, and afterward, we untwist the chain based on our findings. However, there are some peculiarities. For example, rootkits were previously often used in attacks against Linux. </p>
			<p>Historically, the term <em class="italic">rootkit</em> was used to refer to loadable kernel modules, which threat actors install immediately<a id="_idIndexMarker521"/> after gaining root<a id="_idIndexMarker522"/> privileges. A rootkit allows them to gain persistence in a compromised system and hide activities by hiding files, processes, and the presence of the rootkit<a id="_idIndexMarker523"/> in the system itself. Despite the fact that rootkits are now almost non-existent, we believe it is necessary to discuss the main analysis techniques that can help you detect the manipulation of kernel objects and their associated interfaces.</p>
			<h1 id="_idParaDest-135"><a id="_idTextAnchor144"/>Examining kernel objects</h1>
			<p>To<a id="_idTextAnchor145"/> begin with, rootkits are loaded kernel<a id="_idIndexMarker524"/> modules. Accordingly, we need methods to detect loaded modules. For this case, Volatility has a couple of nice plugins: <strong class="source-inline">linux_lsmod</strong>, which enumerates kernel modules, and <strong class="source-inline">linux_hidden_modules</strong>, which carves memory to find hidden kernel modules.</p>
			<p>The first plugin enumerates kernel modules by walking the global list stored within the <strong class="source-inline">modules</strong> variable. The output looks as follows:</p>
			<div>
				<div id="_idContainer274" class="IMG---Figure">
					<img src="Images/Figure_9.38_B17056.jpg" alt="Figure 9.38 – List of loaded kernel modules&#13;&#10;" width="1071" height="276"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.38 – List of loaded kernel modules</p>
			<p>Here, we can see the names of the loaded modules and their size. Note that if you used tools that require the kernel module to be loaded when dumping, the loaded module will also be on this list. For example, in our case, in the first line, you can see the lime module.</p>
			<p>The <strong class="source-inline">linux_hidden_modules</strong> plugin scans memory for instances of a module structure and then compares the results with the list of modules reported by <strong class="source-inline">linux_lsmod</strong>. It looks like this:</p>
			<div>
				<div id="_idContainer275" class="IMG---Figure">
					<img src="Images/Figure_9.39_B17056.jpg" alt="Figure 9.39 – List of hidden kernel modules&#13;&#10;" width="1420" height="157"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.39 – List of hidden kernel modules</p>
			<p>As we can see, there are two hidden modules in our case. In order to analyze them, we can try to extract them with the Volatility <strong class="source-inline">linux_moddump</strong> plugin. To do this, we have to use the <strong class="source-inline">-b</strong> option to set the base address and the <strong class="source-inline">-D</strong> option to set the directory to save the result. For example, if we want<a id="_idIndexMarker525"/> to try to extract the <strong class="source-inline">RG24XR24AR24</strong> module, we will need to run the following command:</p>
			<p class="source-code">$ vol.py --plugins=profiles -f /mnt/hgfs/flash/it-sec.lime --profile=Linuxubuntu_it-secx64 linux_moddump -b 0xffffffffc0521970 -D /mnt/hgfs/flash/</p>
			<p>Of course, rootkits will not always try to hide their module; instead, they may use masquerading and try to look like legitimate modules. In this case, to find the rootkit, it is possible to extract all modules found with <strong class="source-inline">linux_lsmod</strong> and compare them with their legitimate counterparts.</p>
			<p>Another important point is that rootkits often use hooking to perform their activities.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">Hooking is the process of modifying or augmenting the behavior of the operating system, applications, or other software components by intercepting function calls, messages, or events passed between those components.</p>
			<p>There are many hooking techniques, but the most common are IDT and syscall hooks.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">An <strong class="bold">Interrupt Descriptor Table</strong> (<strong class="bold">IDT</strong>) stores pointers to interrupt service<a id="_idIndexMarker526"/> routines. When an interrupt occurs, the processor stops its activity and calls the interrupt service routine, which handles the interrupt. Such interrupts can be triggered by button presses, mouse movements, or other events. </p>
			<p class="callout"><strong class="bold">Syscalls</strong> or <strong class="bold">system calls</strong> are calls from an application program<a id="_idIndexMarker527"/> to the operating system kernel to perform some operation. The Linux kernel header file has a <strong class="source-inline">syscall</strong> function that allows such calls to be made directly, and the Linux system call table itself is part of that operating system's API.</p>
			<p>Volatility provides the <strong class="source-inline">linux_check_idt</strong> and <strong class="source-inline">linux_check_syscall</strong> plugins to detect IDT and syscall hooks.</p>
			<p>Running the first plugin<a id="_idIndexMarker528"/> is as follows:</p>
			<div>
				<div id="_idContainer276" class="IMG---Figure">
					<img src="Images/Figure_9.40_B17056.jpg" alt="Figure 9.40 – IDT hooks&#13;&#10;" width="1072" height="358"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.40 – IDT hooks</p>
			<p>In our case, no IDT hooks were detected because we would have seen the word <strong class="source-inline">HOOKED</strong> in the output.</p>
			<p>The second plugin runs the same way:</p>
			<div>
				<div id="_idContainer277" class="IMG---Figure">
					<img src="Images/Figure_9.41_B17056.jpg" alt="Figure 9.41 – Syscall hooks&#13;&#10;" width="1648" height="425"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.41 – Syscall hooks</p>
			<p>Here, the situation is more interesting. We see a lot of system call hooks, but unfortunately, there is no additional information about these hooks, so we will have to analyze them manually.</p>
			<p>Among other things, Volatility provides a few more plugins for analyzing other types of hooks:</p>
			<ul>
				<li><strong class="source-inline">linux_apihooks</strong> – Checks for userland apihooks</li>
				<li><strong class="source-inline">linux_check_evt_arm</strong> – Checks the exception vector table to look for syscall table hooking</li>
				<li><strong class="source-inline">linux_check_inline_kernel</strong> – Checks for inline kernel hooks</li>
				<li><strong class="source-inline">linux_check_tty</strong> – Checks the tty devices for hooks</li>
			</ul>
			<p>In some situations, rootkits<a id="_idIndexMarker529"/> can also interact with different files. Volatility allows us to find files that are opened from within the kernel with the <strong class="source-inline">linux_kernel_opened_files</strong> plugin and to check file operation structures for rootkit modifications with the <strong class="source-inline">linux_check_fop</strong> plugin. </p>
			<p>This is how we can do an initial examination of kernel objects and search for rootkits. But again, at the time of writing this book, rootkits are almost obsolete. They have been replaced by the use of post-exploitation frameworks and dedicated malware.</p>
			<h1 id="_idParaDest-136"><a id="_idTextAnchor146"/>Summary</h1>
			<p>The techniques used to detect and analyze malicious activity on Linux-based systems are similar to those used on Windows operating systems. We concentrate on the investigation of active network connections and various anomalies in the processes and their behavior. However, analysis of such activity often comes down to examining network traffic dumps, which can also be extracted from memory; investigating the memory of individual processes; or examining the filesystem in memory. In most cases, it is these three elements that allow us to find the necessary evidence and reconstruct the actions of the threat actors. </p>
			<p>Undoubtedly, knowledge of the filesystem structure, the location, and the contents of the major files play an important role in the investigation of Linux-based systems. Thus, knowing what software is being used on the system under investigation, and knowing where its logs and configuration files are stored, will allow you to easily find the information you need and fill in the missing details of the incident.</p>
			<p>This concludes our examination of Linux-based systems memory. Our last stop on this difficult but fascinating journey will be devoted to macOS. We will discuss the process of obtaining memory dumps from macOS and actually investigating them. So, we cannot wait to see you in the next part.</p>
		</div>
	</div></body></html>