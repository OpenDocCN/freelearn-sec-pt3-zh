- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: API Reconnaissance and Information Gathering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Knowing the terrain before committing to attacking it is a military maxim. Sun
    Tzu, the famous author of the bestseller *The Art of War* wrote that “*you should
    have a strong sense of the surrounding terrain.*” Getting to know the target API
    is as important as deleting the intrusion evidence of the attack. So, know before
    you go!
  prefs: []
  type: TYPE_NORMAL
- en: API reconnaissance and information gathering is the process of collecting information
    about an API, such as its endpoints, methods, parameters, authentication mechanisms,
    and business purpose. This information can then be used to identify security weaknesses,
    test the API’s functionality, or develop new applications that interact with the
    API.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn reconnaissance and information-gathering techniques
    that will become part of the planning activities of a penetration test. As a matter
    of fact, after correctly setting up your toolbelt, as you did in the previous
    chapter, uniting information about the target is the next step.
  prefs: []
  type: TYPE_NORMAL
- en: You will learn important concepts, such as enumeration, API documentation, **Open
    Source Intelligence** (**OSINT**), and API schemas. All of these are related to
    basically any modern API available on the Internet. We will use OWASP’s crAPI
    and WebGoat projects as our playground.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Identifying and enumerating APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analyzing API documentation and endpoints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leveraging OSINT
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identifying data and schema structures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ideally, you should have already created your pentesting environment, as pointed
    out in [*Chapter 2*](B19657_02.xhtml#_idTextAnchor028). However, if you haven’t,
    this is not a big deal.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the tools that follow to go through this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: A hypervisor such as Oracle VirtualBox is needed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Linux **Virtual Machine** (**VM**); I recommend selecting either Ubuntu or
    Fedora distros because of the vast number of utilities on both.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Postman ([https://www.postman.com/downloads/](https://www.postman.com/downloads/)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OWASP **Completely Ridiculous API** (**crAPI**) ([https://github.com/OWASP/crAPI/](https://github.com/OWASP/crAPI/)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OWASP WebGoat ([https://owasp.org/www-project-webgoat/](https://owasp.org/www-project-webgoat/)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OWASP ZAP ([https://www.zaproxy.org/](https://www.zaproxy.org/)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In terms of container engines, use either Docker or Podman, which is a superset
    of Docker.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are going for the standalone version of WebGoat, you will need a Java
    runtime environment. I suggest selecting OpenJDK. Both Ubuntu and Fedora have
    packages for it. Other distros might have it as well.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You will need at least 30 GB of disk space, 2 vCPUs, and 4 GB of RAM on your
    host to accommodate the VM. The recommendation is 50 GB, 4 vCPUs, and 8 GB, respectively.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: When this book was being written, there was no stable version of VirtualBox
    for computers with Apple Silicon chips. The beta versions available were unable
    to launch ARM VMs. If this is your scenario, I recommend using UTM ([https://mac.getutm.app/](https://mac.getutm.app/))
    instead. There are a few ways to install it, including via Homebrew. This chapter
    uses an Ubuntu 22.04 LTS server as a VM on top of UTM.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying and enumerating APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Identification and enumeration of targets can be done passively or actively
    and this is not exclusive to APIs. Passive recon involves gathering information
    about an API without directly interacting with it. This can be done through a
    variety of methods, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Searching public documentation**: Many API providers publish documentation
    that describes the API’s endpoints, methods, parameters, and authentication mechanisms.
    This documentation can be found on the provider’s website, in online forums, or
    in code repositories.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Analyzing public traffic**: If the API is publicly accessible, it is possible
    to analyze traffic to the API to learn more about how it is used. This can be
    done using tools such as Wireshark or Fiddler.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Searching for exposed information**: API providers may accidentally expose
    sensitive information, such as API keys or passwords, in public forums or code
    repositories. It is possible to find this information using search engines or
    tools such as Shodan.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Passive reconnaissance** is about getting information about an API without
    necessarily talking to it. In other words, you need to search for the required
    information by using other sources such as public documentation, analyzing public
    traffic, or searching for exposed information. Many API providers release documentation
    about their API’s methods, verbs, and parameters, as well as how authentication
    and authorization work. This can eventually reveal weak control mechanisms, such
    as a simple pair of username/password credentials. If the API is publicly accessible,
    you can analyze its traffic by capturing it with the help of tools such as Wireshark
    and Fiddler. Additionally, sensitive data, such as keys, tokens, passwords, or
    special configuration parameters, might have been inadvertently leaked in code
    repositories or forums. With the use of a web search engine or a tool such as
    Shodan, you can easily find them.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Active enumeration**, on the other hand, will require you to interact with
    the API. As is the case for all activate phases of a pentest, bear in mind that
    your actions might be logged by the API provider. Regardless of that, active recon
    usually follows this sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You start by discovering the API’s endpoints (that is, the URLs it’s waiting
    for) and answering requests. With a spider, such as Sitebulb or Screaming Frog
    SEO Spider, you can enumerate all the API’s endpoints:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.1 – Sitebulb’s interface (image credit: Sitebulb)](img/B19657_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.1 – Sitebulb’s interface (image credit: Sitebulb)'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can then send requests to them via the `curl` utility or utilities such
    as Postman. In fact, one very interesting feature of Postman is translating the
    request you graphically build in a `curl` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Some API endpoints accept parameters that can be used to control the API’s behavior.
    By probing such parameters, you can learn more about them, including which values
    are acceptable and how they can affect the API’s operation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can also choose to test the API’s authentication mechanism. Some APIs return
    data when you send a read-only request even without a prior authentication. However,
    if an API requires some type of authentication control, you can test it to understand
    its robustness, for example, by crafting special or fuzzed credentials.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We are now going to cover a few tools that are quite useful for pentesting purposes,
    including crAPI, which you will use throughout the rest of the book.
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing WebGoat
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s start playing with our lab. Docker is installed along with crAPI and WebGoat,
    both using Docker images. crAPI is distributed with a Docker Compose multi-container
    definition file. You are more than free to pick any other combination of distributions
    and ways to install WebGoat and WebWolf (the accompanying application to test
    some features of WebGoat). Both can be installed with the same Docker image or
    directly executed using separate Java Archive files. Wireshark is also installed.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 – WebGoat’s login page (http://localhost:8080/WebGoat/login)](img/B19657_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.2 – WebGoat’s login page (http://localhost:8080/WebGoat/login)
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the login page for WebWolf:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3 – WebWolf’s initial page (http://localhost:9090/home)](img/B19657_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.3 – WebWolf’s initial page (http://localhost:9090/home)
  prefs: []
  type: TYPE_NORMAL
- en: Since our target APIs are crAPI and WebGoat, there’s no API documentation to
    be searched, which reduces our passive reconnaissance options. We can still simulate
    some traffic capture to understand how it works. Start Wireshark and start the
    capture on the loopback interface (`127.0.0.1`). To avoid getting overwhelmed
    with other traffic that your system generates, put a filter to restrict capturing
    HTTP packets on TCP port `8080` only (`tcp.port == 8080 and http`). With a simple
    load of WebGoat’s login page, you’ll see capture lines popping up. To facilitate
    identifying when the packets were captured, you may change the way Wireshark shows
    them by clicking on **View** | **Time** **Display Format**.
  prefs: []
  type: TYPE_NORMAL
- en: 'You need to register an account before start using the tool. The examples in
    this book use `pentest`/`pentest` as a pair of credentials. Register an account
    and launch Wireshark. Observe one of the captured packets. Obviously, we can see
    the password because WebGoat does not apply a digital certificate in the communication:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4 – The output of a Wireshark packet capture showing a clear text
    password](img/B19657_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.4 – The output of a Wireshark packet capture showing a clear text password
  prefs: []
  type: TYPE_NORMAL
- en: From that packet, you can verify that the element that created the credentials
    is called `/WebGoat/register.mvc`, which was called by `/WebGoat/registration`.
    Try to call it individually via `curl` to see whether there’s anything useful.
    If you do a `curl -vslk http://localhost:8080/WebGoat/register.mvc`, you’ll see
    something like the following. Part of the output was omitted for brevity.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.5 – WebGoat’s register.mvc element throwing an error message](img/B19657_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.5 – WebGoat’s register.mvc element throwing an error message
  prefs: []
  type: TYPE_NORMAL
- en: 'The `curl` utility uses the `GET` HTTP verb by default. We just discovered
    that this element does not support the `GET` verb and it simply threw a very informative
    error message, saying (for example) that the application runs with the Spring
    framework. Even one of the affected source code files and its line are provided:
    `RequestMappingInfoHandler.java`, line `253`! You could have acquired this information
    via a web browser too, but getting used to `curl` is important. That was nice
    for a start, but WebGoat is not exactly the best tool to help us dive into an
    API’s internals. crAPI is a better candidate.'
  prefs: []
  type: TYPE_NORMAL
- en: Looking at crAPI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: crAPI is an intentionally vulnerable application with a RESTful API that was
    created to facilitate exploring OWASP’s API Security Top 10 threats ([https://owasp.org/API-Security/](https://owasp.org/API-Security/)).
    The year when this book was being written coincided with the latest release of
    the API Security Top 10 project. Another tool like crAPI is Juice Shop ([https://owasp.org/www-project-juice-shop/](https://owasp.org/www-project-juice-shop/)),
    written in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'As soon as you finish running crAPI’s Docker Compose file, you can open the
    application by accessing `http://localhost:8888/`. You will be redirected to the
    `/login` path. This doesn’t necessarily mean at first that you are dealing with
    a RESTful API. Being redirected to another path simply means that the application
    either recognized that you are not authenticated yet or sent you to the correct
    page in case you have tried to open an obsolete component. The command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The backward compatibility flag was implemented with the new version of Docker
    Compose. Support for the previous version was ended in June 2023\. More information
    can be found at [https://docs.docker.com/compose/compose-file/compose-versioning/](https://docs.docker.com/compose/compose-file/compose-versioning/).
  prefs: []
  type: TYPE_NORMAL
- en: 'As it is a container-based application, you will leverage the advantage of
    not having to manually download all the components. When Compose finishes downloading
    images, creating volumes and environment variables, and defining limits, you will
    have the following containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Container name** | **Container image** | **Purpose** |'
  prefs: []
  type: TYPE_TB
- en: '| `api.mypremiumdealership.com` | gateway-service | The vulnerable API |'
  prefs: []
  type: TYPE_TB
- en: '| `crapi-community` | Same name | Community blogs |'
  prefs: []
  type: TYPE_TB
- en: '| `crapi-identity` | Same name | Authentication endpoint |'
  prefs: []
  type: TYPE_TB
- en: '| `crapi-web` | Same name | The web UI |'
  prefs: []
  type: TYPE_TB
- en: '| `crapi-workshop` | Same name | Car workshop |'
  prefs: []
  type: TYPE_TB
- en: '| `mailhog` | Same name | Mail service |'
  prefs: []
  type: TYPE_TB
- en: '| `mongodb` | mongo | Self-explanatory |'
  prefs: []
  type: TYPE_TB
- en: '| `postgresdb` | postgres | Self-explanatory |'
  prefs: []
  type: TYPE_TB
- en: Table 3.1 – crAPI’s containers and images and their purposes
  prefs: []
  type: TYPE_NORMAL
- en: 'crAPI implements a website for vehicle owners to search, find, and request
    maintenance for their cars, while also exposing a RESTful API to facilitate such
    tasks. I’m assuming that you have already installed either ZAP or Burp Suite,
    as per the previous chapter. We will use ZAP here. The first crAPI page is a sign
    in/sign up dialog box:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.6 – crAPI’s login page](img/B19657_03_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.6 – crAPI’s login page
  prefs: []
  type: TYPE_NORMAL
- en: 'You can play with the signup page a bit by providing special characters in
    the username or email address fields. You can even provide an invalid phone number
    (the frontend logic only checks whether the contents are not null), which I did,
    and see the results on ZAP. I left the phone number empty and tried to sign up.
    The response is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.7 – An invalid sign-up page revealing details on the app’s backend](img/B19657_03_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.7 – An invalid sign-up page revealing details on the app’s backend
  prefs: []
  type: TYPE_NORMAL
- en: 'On the very first interaction with the web application, without even crafting
    a special request, we discovered that it runs the Spring Framework, which means
    that we are dealing with a backend running on top of Java. Cool! Now let’s fill
    in the form as a car owner and log in. The response provides a bearer token:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.8 – The response of a valid login action, providing the corresponding
    bearer token](img/B19657_03_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.8 – The response of a valid login action, providing the corresponding
    bearer token
  prefs: []
  type: TYPE_NORMAL
- en: Let’s proceed by adding a dummy vehicle. We will verify that more information
    about the application and the API endpoints will be revealed. When adding a vehicle,
    you need the PIN and the VIN, which are provided in an email sent to the address
    you entered when signing up. Simply open another browser tab and go to `http://localhost:8025`
    to access the Mailhog service. You will find the message there. The simple fact
    of logging in and clicking the corresponding button to add a vehicle reveals more
    API endpoints. Observe the series of figures that follows to know more. In the
    first one, you can see the response to a successful login.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.9 – The /api/v2/user endpoint after logging in](img/B19657_03_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.9 – The /api/v2/user endpoint after logging in
  prefs: []
  type: TYPE_NORMAL
- en: The following is the sort of response you will get after adding a vehicle.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.10 – The /api/v2/vehicle endpoint after clicking the button to add
    a vehicle](img/B19657_03_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.10 – The /api/v2/vehicle endpoint after clicking the button to add
    a vehicle
  prefs: []
  type: TYPE_NORMAL
- en: Finally, after correctly adding a vehicle, you will receive a screen like this
    one.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.11 – The random vehicle has been added](img/B19657_03_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.11 – The random vehicle has been added
  prefs: []
  type: TYPE_NORMAL
- en: 'When a vehicle is added, the application assigns an UUID to it, as we can confirm
    by checking the response of the `/``api/v2/vehicle/vehicles` invocation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.12 – The UUID generated as part of adding a vehicle](img/B19657_03_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.12 – The UUID generated as part of adding a vehicle
  prefs: []
  type: TYPE_NORMAL
- en: Location data is also informed. Pay attention to this fact as it will be quite
    useful. You can play with the web UI a bit but check what happens with the response
    when you enter the **Community** section. This represents a sort of forum where
    vehicle owners can comment on or ask for help. The problem is that *all* owners’
    posts have their corresponding vehicle IDs! It’s obviously not advisable to disclose
    data when it’s not strictly necessary, which is the case here. Why would some
    well-intentioned person want to know the vehicle ID of another person?
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.13 – Other vehicle IDs are disclosed in the Community section of
    the application](img/B19657_03_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.13 – Other vehicle IDs are disclosed in the Community section of the
    application
  prefs: []
  type: TYPE_NORMAL
- en: 'The `/api/v2/vehicle` endpoint has an option to provide the vehicle’s UUID
    and then specify the `location` keyword to obtain the car’s latitude and longitude.
    What if we leverage the output in the preceding screenshot and try to do this
    with a vehicle that’s not ours? You can do this however you prefer, such as via
    ZAP itself, Postman, or even the command line with the help of `curl`, for example.
    However, remember to log in first, as all subsequent requests will require the
    authorization token that you can only get after successfully authenticating. Observe
    in *Figure 3**.13* that my vehicle’s ID ends with `5b0a`. I will try to get the
    location of a vehicle whose ID ends with `8e3f`. Using `curl`, the command would
    be (this is a single command line):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Bingo! Observe the following screenshot. This demonstrates the fragility of
    the API provided by crAPI. By simply providing a valid token, I can see the details
    of an asset belonging to a different username!
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.14 – Obtaining another vehicle’s data](img/B19657_03_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.14 – Obtaining another vehicle’s data
  prefs: []
  type: TYPE_NORMAL
- en: 'Congratulations! You just inadvertently accessed another user’s vehicle data,
    which corresponds to the first crAPI challenge: **Broken Object Level Authorization**
    (**BOLA**). Let’s see how else we can get information about APIs.'
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing API documentation and endpoints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can also acquire important information about APIs by carefully analyzing
    their documentation and the endpoints they expose. Even nowadays, some API endpoints
    are made available without **Transport Layer Security** (**TLS**), which shouldn’t
    at all be a habit that is adopted. For the sake of keeping backward compatibility,
    some vendors and application owners choose to leave such insecure connection points
    open. They are sometimes used by lower-performance devices, such as **Internet
    of Things** (**IoT**) Raspberry Pis, Arduino controllers, or even regular clients
    with not much computing power. That’s because TLS offloading might demand substantial
    processing depending on the number of needed simultaneous or subsequent connections.
  prefs: []
  type: TYPE_NORMAL
- en: Aside from that, by analyzing documentation and endpoints, you can spot other
    potential attack vectors such as weak or no authentication and/or authorization
    mechanisms. For the purposes of analyzing API documentation, you can make use
    of some decent utilities, such as SwaggerUI ([https://github.com/swagger-api/swagger-ui](https://github.com/swagger-api/swagger-ui))
    and ReDoc ([https://github.com/Redocly/redoc](https://github.com/Redocly/redoc)).
    Although originally conceived to build documentation for APIs that follow the
    OpenAPI specification ([https://www.openapis.org/](https://www.openapis.org/)),
    they can also be applied to analyze written docs. Considering the file that follows,
    replace the `<<<Put OpenAPI Link here>>>` placeholder with a link hosting an OpenAPI-like
    documentation YAML file. You can find websites on the APIs Guru’s website ([https://apis.guru/](https://apis.guru/));
    see *Figures 3.15* and *3.16*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You can find part of the Fitbit’s API documentation here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.15 – Fitbit’s API documentation](img/B19657_03_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.15 – Fitbit’s API documentation
  prefs: []
  type: TYPE_NORMAL
- en: Here you can see the same but for Forex’s API. It is a screenshot of the documentation
    screen showing the response to a request.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.16 – 1Forge Finance’s API documentation](img/B19657_03_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.16 – 1Forge Finance’s API documentation
  prefs: []
  type: TYPE_NORMAL
- en: Observe that one of the first Fitbit items covers authentication, making use
    of the OAuth2 protocol. On the other hand, at first sight, 1Forge’s API does not
    provide any authentication whatsoever, at least not for those exposed services.
    As a matter of fact, it does provide this, but this is only correctly mentioned
    on their website. 1Forge also exposes pure HTTP endpoints. Leveraging that we
    just mentioned “exposed”, when you expand an item in the right pane of ReDoc,
    more information is given. In this case, we can see the websites we can leverage
    to interact with the API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, to locally see a dummy OpenAPI specification, you can install
    ReDoc – or better yet, you can use its Docker version. I loaded the Docker version
    and set it to listen on the `8085` port (the default `8080` port was already being
    used either by ZAP or by another utility). This makes the dummy PetStore API documentation
    available for reading:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Another purpose of verifying an API’s documentation is to check its request
    and response structures. By analyzing how they need to be crafted or how they
    are sent back to you, it’s possible to infer some more details about the API.
    For example, that leak of other vehicle owners’ data would possibly go unnoticed
    if you didn’t use a proxy or your browser’s inspector tool. Another example concerns
    user IDs. Some applications may be vulnerable to user ID profiling. If an API
    allows you to create a user, you can build a simple script to make two or three
    requests in sequence to create a small list of users. If the API gives back to
    you the users’ IDs as part of the response, and if such IDs are sequential, you
    know the API is vulnerable to this threat. With pure HTTP endpoints, the game
    is even better since you can capture all other users’ data (on a local network)
    by faking a proxy server.
  prefs: []
  type: TYPE_NORMAL
- en: Recalling the HTTP RFC (link on the reference), we know that an HTTP request
    has headers and a body. A web application developer can use any or both when implementing
    the API. By double checking the RFC, we can reach the consensus that if the data
    being sent in a request *is* metadata, then the *header* is the best place to
    put them. If the data *is not* metadata, then the *body* should be used instead.
    Why am I telling you that? Public cloud providers log pretty much everything that
    comes and goes to their networks. However, web requests’ bodies may not be fully
    logged since they can contain customers’ sensitive data and allowing an unauthorized
    person (such as a cloud provider’s engineer) to have access to such logs would
    cause failure in security compliance and no providers want this for sure. Hence,
    when interacting with any API, pay very close attention to the API’s response
    bodies, as they may hold very valuable data that can be used later when preparing
    for an attack.
  prefs: []
  type: TYPE_NORMAL
- en: Leveraging OSINT
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OSINT is a market that has substantially grown in the last few years and has
    a continuous tendency to keep growing. According to a publicly available report,
    in 2022 the market size was 4.2 billion USD. It’s expected to reach 7.32 billion
    USD in 2031, which represents a 73.43% increase with a **Compound Annual Growth
    Rate** (**CAGR**) of about 6.31% in a nine-year period. That’s something that
    can’t go unnoticed. This market is comprised mostly of companies that build software
    and/or training to explore the corresponding research techniques.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have never heard about OSINT, I will summarize it for you. OSINT comprises
    a series of techniques for collecting and analyzing information that is publicly
    available. OSINT can be used to gather information about APIs in a variety of
    ways. For example, you can use OSINT to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Find information about APIs that are not documented by the provider.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identify new API endpoints that have been released.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discover changes to existing API endpoints.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Find information about security vulnerabilities in APIs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some common OSINT resources for gathering information about APIs include the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Search engines**: Search engines can be used to find information about APIs
    that are not documented by the provider.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Social media**: Social media platforms such as X (previously known as Twitter)
    and GitHub can be used to find information about new API endpoints, changes to
    existing API endpoints, and security vulnerabilities in APIs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Online forums**: Online forums such as Stack Overflow and Reddit can be used
    to find information about how to use APIs and to troubleshoot problems with APIs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'OSINT can also be used for several other activities, such as watching or tracking
    individuals or companies, discovering information about assets besides API endpoints,
    such as servers, applications, externally available systems, locating buildings
    or facilities among others. I know that it looks scary, but as with most things
    in life, there are good and evil uses for this technology. There is a decent amount
    of free content about OSINT available on the internet, including lists of resources
    and tools. Among everything, I would not forget to mention the following ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The OSINT framework** ([https://osintframework.com/](https://osintframework.com/)):
    This is an online catalog with a curated list of online resources categorized
    by type. Some of those are free, others allow you to test them, and still others
    are commercial.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Shodan** ([https://www.shodan.io/](https://www.shodan.io/)): This is a search
    service with a huge database of IoT devices, such as cameras, routers, and micro-controllers.
    Although it’s a paid service, it’s not rare to find good discounts on some dates,
    such as Black Friday.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The Google Hacking Database** ([https://www.exploit-db.com/google-hacking-database/](https://www.exploit-db.com/google-hacking-database/)):
    This is a compendium of Google dorks (specially crafted Google queries) that you
    can filter to show only the desired types of targets, including APIs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Figures 3.17* and *3.18* show examples of what you can find when looking for
    API endpoints on Shodan. The service can disclose whether the endpoint has vulnerabilities,
    as well as what they are. Practical, right? They are usually related to the operating
    systems that support the servers, but the web service can also be listed as vulnerable,
    which would help with your pentesting tasks. The screenshots were captured after
    logging in to the service. The first one shows an API endpoint. The screenshots
    have been anonymized on purpose.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.17 – An Indonesian university with a potentially vulnerable API
    endpoint](img/B19657_03_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.17 – An Indonesian university with a potentially vulnerable API endpoint
  prefs: []
  type: TYPE_NORMAL
- en: The second one shows an Oracle server with an endpoint that is open to the world.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.18 – Simple API queries on Shodan](img/B19657_03_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.18 – Simple API queries on Shodan
  prefs: []
  type: TYPE_NORMAL
- en: 'The service has a fair number of queries you can explore. Some of the most
    used ones follow:'
  prefs: []
  type: TYPE_NORMAL
- en: '`hostname:targetdomain.com`: This directs all queries to the target domain,
    which can also result in a hostname if the target uses an APEX domain name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`content-type:application/json` (or `xml`): The majority of APIs accept and
    return data either in JSON or in XML. When combined with a hostname, this keyword
    filters the results to contain the desired content type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`200 OK`: This corresponds to the successful HTTP status code. You can add
    this combined with other queries to return only the successful requests. If the
    target API does not accept Shodan queries, it may return HTTP codes of 300 or
    400.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`wp-json`: When querying target **Content Management Systems** (**CMSs**),
    such as Joomla or Drupal, this type of query may reveal the presence of one of
    them. This, in particular, corresponds to the WordPress REST API.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s see what we can get with ExploitDB. If you search for the `API` term,
    the service will return a reasonable amount of Google dorks, a fair amount being
    `allintext`, `intitle`, and `inurl`. These represent searches for occurrences
    in the whole page’s content, in its title only, and in the URL’s name respectively.
    There are a few that deserve your attention:'
  prefs: []
  type: TYPE_NORMAL
- en: '`allintext:"API_SECRET*" ext:env | ext:yml`: Look for the string beginning
    with `API_SECRET` inside files whose extensions are either `.env` or `.yml`. This
    is useful since many configurations of applications store sensitive data, such
    as API keys, inside files with these extensions. An inattentive developer might
    have pushed them to a public repository. You can also get to know about versions
    of the implemented API. Old ones may have vulnerabilities.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`intitle:"Index of /api/"`: You will find websites that list all the files
    inside their `/api` web directories. You can find very useful information here
    for websites that you wouldn’t even imagine were disclosing this.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`inurl:execute-api site:amazonaws.com`: This lists all sites that have `execute-api`
    as part of their URLs. Sites like those are implemented by Amazon API Gateway,
    a public cloud service that exposes a layer before your actual web background.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are not restricted to the Google search engine. Nowadays, we have online
    generative AI services that can give us a hand with OSINT as well. Once you build
    good prompts, I mean, good questions, you can acquire pretty much all of the desired
    information. These services are being optimized over time and receiving additional
    guardrails to protect companies and individuals against inadvertent data exposure
    or leakage. Nevertheless, I can’t guarantee that all data will be fully protected.
  prefs: []
  type: TYPE_NORMAL
- en: 'GitHub also has its dorks. Focused on specific file names, you can find relevant
    information about the API you are inspecting. The following is a small list of
    dorks that I got after asking such a generative AI service, organized by categories.
    You can mix and match them at will. The service didn’t want to give them to me
    at first, but as I said before, with the right prompts and some patience, you
    will make it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Path-based dorks:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Language-specific dorks:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Extension-based dorks:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'User or organization-based dorks:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Size-based dorks:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Fork and stars dorks:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Date-range dorks:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'License-based dorks:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Text content dorks:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Wildcard dorks:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Some good keywords to reveal the presence of APIs’ sensitive data include the
    following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Moving forward, we are going to learn more about the internal details of APIs
    by learning their data and schema structures.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying data and schema structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will end our chapter about API reconnaissance and enumeration by covering
    a subject as important as all the others. By successfully identifying an API’s
    data and schema structures, you can acquire even more information about the target.
    Once you have analyzed the API documentation and endpoints, you need to identify
    the data and schema structures that are used by the API. This information can
    be used to understand how the API works and to develop applications that interact
    with the API.
  prefs: []
  type: TYPE_NORMAL
- en: The API documentation should provide information about the data and schema structures
    that are used by the API. However, you may need to analyze the API responses to
    get a complete understanding of the data and schema structures.
  prefs: []
  type: TYPE_NORMAL
- en: Some APIs return JSON structures, whereas others prefer to encode responses
    in XML before sending them to the requester. As a matter of fact, XML was the
    preferred data transport format for some years because of its flexibility and
    power. However, the drawback was derived from such advantages as well. The more
    complex an XML structure is, the more prone to attacks it is as well. Badly written
    XML interpreters may lead to unexpected application failures and worse, to data
    exposure or leakage.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, first, what are schemas? Like their counterpart in databases, API
    schemas are metadata used to define how data is structured inside the API. In
    other words, when requesting and receiving the responses of such requests, you
    can know in advance which components are expected and which data types they use.
    This is especially important for one operation in particular: *fuzzing*.'
  prefs: []
  type: TYPE_NORMAL
- en: We haven’t talked about this up to this point yet, but in general terms, fuzzing
    consists of generating random sequences of characters that are used as input for
    different interactions with a system. In our case, the system is an API endpoint.
    After knowing its schema and data structures, you can test the API by sending,
    for example, symbols to a field that’s expecting a date, or letters to a field
    that carries quantity. Alternatively, you can refer to a structure, such as a
    list or array, that does not belong to the data structure, and they check the
    endpoint behavior. When it is well written, a fuzzing-proof application simply
    ignores the data and optionally throws warning or error messages stating that
    a corrupted entry was provided.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s do some exercises. Leveraging our crAPI deployment and Postman, let’s
    make a few requests and verify their responses. crAPI expects JSON as input and
    returns a JSON structure as a response. crAPI already provides a handy collection
    of Postman requests in its repository. Let’s see what happens when we send something
    different from JSON. First, we need to log in to get an authorization token. This
    is our initial test. Let’s replace the JSON portion with, let’s say, an XML format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `{{email}}` and `{{password}}` annotations are conventions Postman uses
    to refer to variables. I have created variables in my Postman collection to store
    my login and password, so I don’t have to type them every time I need to log in.
    I did the same with the authorization token. Well, in this initial test, crAPI
    returned nothing at all. Let’s move on and log in the right way, with a JSON data
    structure as input. We just received the token.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s another endpoint that is accessed with a POST verb. It’s called `Signup
    example.com`. It expects the following as the request body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'When you send the expected formats, such as the email address and a numeric
    sequence as the phone number, the API responds with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'However, what if we send something slightly different, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'It seems that crAPI does validate the input somehow, but not exactly in a good
    way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We discovered a few things with this simple test:'
  prefs: []
  type: TYPE_NORMAL
- en: crAPI definitely uses some flavor of Java as its backend.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Email and phone are somehow validated, but errors look like exceptions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The maximum length of the phone number is 15 characters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When you verify the log of the identity container, you’ll find the following
    exceptions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: With this, we have finished our chapter on API reconnaissance and information
    gathering.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covered important topics on your journey toward pentesting APIs.
    You learned that you must begin by gathering information about the target and
    reconning it. After correctly identifying and enumerating the API, you learned
    that you must read its documentation carefully and find out which endpoints it
    exposes. This may reveal valuable information, as you learned. Additionally, you
    learned that you can make use of an extremely useful set of techniques called
    OSINT, which are extensively applied everywhere by forensic investigators and
    enthusiasts. The chapter finished with a complementary section about how API data
    and schema structures are important in this phase.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn how to explore the authentication and authorization
    stages more while pentesting an API. This chapter included some introduction to
    that topic, but we’ll go into greater depth in the next one with analysis and
    more tests.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The VirtualBox type 2 hypervisor: [https://www.virtualbox.org/](https://www.virtualbox.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The UTM type 2 hypervisor: [https://mac.getutm.app/](https://mac.getutm.app/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Podman, a superset of Docker: [https://podman.io/](https://podman.io/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The OWASP WebGoat vulnerable web app: [https://owasp.org/www-project-webgoat/](https://owasp.org/www-project-webgoat/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The OWASP crAPI vulnerable API: [https://owasp.org/www-project-crapi/](https://owasp.org/www-project-crapi/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Zed Attack Proxy scanner: [https://www.zaproxy.org/](https://www.zaproxy.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Shodan, an IoT vulnerability search engine: [https://www.shodan.io/](https://www.shodan.io/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Fiddler, a network analysis tool: [https://www.telerik.com/fiddler/fiddler-everywhere](https://www.telerik.com/fiddler/fiddler-everywhere)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Wireshark, one of the most famous network packet capture tools: [https://www.wireshark.org/](https://www.wireshark.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'APIs Guru, a decent list of APIs’ documentation: [https://apis.guru/](https://apis.guru/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ReDoc, utility to build and read API documentation: [https://github.com/Redocly/redoc](https://github.com/Redocly/redoc)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Swagger UI, utility to build and read API documentation: [https://github.com/swagger-api/swagger-ui](https://github.com/swagger-api/swagger-ui)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The RFC establishing the HTTP Specification: [https://datatracker.ietf.org/doc/html/rfc2616#page-31](https://datatracker.ietf.org/doc/html/rfc2616#page-31)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A report discussing the OSINT growing market: [https://www.businessresearchinsights.com/market-reports/open-source-intelligence-market-109546](https://www.businessresearchinsights.com/market-reports/open-source-intelligence-market-109546)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ExploitDB Google Dorks, a list with OSINT cheat sheets: [https://www.exploit-db.com/google-hacking-database/](https://www.exploit-db.com/google-hacking-database/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The OSINT Framework, a vast list of tools and resources about OSINT: [https://osintframework.com/](https://osintframework.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Google dork cheat sheet, more resources on OSINT: [https://gist.github.com/ikuamike/c2611b171d64b823c1c1956129cbc055](https://gist.github.com/ikuamike/c2611b171d64b823c1c1956129cbc055)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'crAPI Postman collections to help automate crAPI requests: [https://github.com/OWASP/crAPI/tree/develop/postman_collections](https://github.com/OWASP/crAPI/tree/develop/postman_collections)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
