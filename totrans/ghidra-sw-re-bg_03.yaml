- en: '*Chapter 2*: Automating RE Tasks with Ghidra Scripts'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will cover **Reverse Engineering** (**RE**) automation by
    scripting Ghidra. We will start by reviewing the impressive and pretty well-organized
    arsenal of available Ghidra scripts built into the tool. These few hundreds of
    scripts are usually more than enough to cover the main automation needs.
  prefs: []
  type: TYPE_NORMAL
- en: Once you know the arsenal, you will probably also want to know how it works.
    Then, we will have an overview of the Ghidra script class in order to understand
    its internals and get some background, which will be very useful for the last
    part of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you will learn how to develop your own Ghidra scripts. To do so, it
    will be necessary to have an overview of the Ghidra API. Fortunately, you will
    be able to program in Java or Python according to your preferences since the Ghidra
    API is the same in both cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the Ghidra scripts arsenal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analyzing the Ghidra script class and the API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing your own Ghidra scripts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The GitHub repository containing all the necessary code for this chapter can
    be found at [https://github.com/PacktPublishing/Ghidra-Software-Reverse-Engineering-for-Beginners/tree/master/Chapter02](https://github.com/PacktPublishing/Ghidra-Software-Reverse-Engineering-for-Beginners/tree/master/Chapter02).
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the Code in Action: [https://bit.ly/3mZbdAm](https://bit.ly/3mZbdAm)'
  prefs: []
  type: TYPE_NORMAL
- en: Using and adapting existing scripts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ghidra scripts allow you to automate RE tasks when analyzing binaries. Let's
    cover an overview of how to use scripts from `hello world` program. Our starting
    point here is a `hello world` program loaded into Ghidra's **CodeBrowser**, as
    explained in the *Overview of Ghidra's features* section of [*Chapter 1*](B16207_01_Final_SK_ePub.xhtml#_idTextAnchor017),
    *Getting Started with Ghidra*.
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned in the introduction of this chapter, Ghidra includes a true script
    arsenal. To access it, go to **Window** and then **Script Manager**. Alternatively,
    click the button highlighted in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1 – The run script button highlighted in the quick access bar'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16207_02_001.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.1 – The run script button highlighted in the quick access bar
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see on the left in the folder browser, all these scripts are categorized
    by folder, showing the scripts each one contains when selected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.2 – Script Manager'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16207_02_002.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.2 – Script Manager
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding screenshot, when clicking on the checklist icon located at
    the upper right in the **Script Manager** window, the paths of the script directories
    will be shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.3 – Script directories'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16207_02_003.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.3 – Script directories
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a very good starting point to experiment with existing scripts. You
    can analyze and edit all of them by using Ghidra. It will allow you to understand
    how they work and how to adapt them to your needs. Use the highlighted icons shown
    in the following screenshot to edit scripts or create new ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.4 – The edit script and create a new script buttons highlighted
    in the quick access bar'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16207_02_004.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.4 – The edit script and create a new script buttons highlighted in
    the quick access bar
  prefs: []
  type: TYPE_NORMAL
- en: 'As we are analyzing a `hello world` program that only prints `hello world`
    on the screen, we can choose a string-related Ghidra script, and then see how
    it can speed up the analysis. As you can see in the following screenshot, both
    Python and Java scripts are mixed in **Script Manager**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.5 – String-related scripts available in Script Manager'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16207_02_005.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.5 – String-related scripts available in Script Manager
  prefs: []
  type: TYPE_NORMAL
- en: For instance, the `RecursiveStringFinder.py` file can speed up your analysis
    by showing all the functions and their associated strings. It speeds up your analysis
    because strings can reveal the purpose of a function without the need for reading
    even a single line of code.
  prefs: []
  type: TYPE_NORMAL
- en: Let's execute the mentioned script, taking the `_mainCRTStartup()` function
    of the `hello world` program as input (you will need to put the cursor onto this
    function) while seeing the output in the scripting console.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the following screenshot, `RecursiveStringFinder.py` printed
    out an indented (according to the calling depth) list of functions, each one containing
    its own referenced strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, the `_mainCRTStartup()` function is the first function that will
    be executed (we know this because of the indentation; it is the one that is the
    most to the left). After that, the `__pei386_runtime_relocator()` function, which
    was introduced by the compiler, will be called. This function contains the string
    `" Unknown pseudo relocation bit size %d. \n"`, and we know that it is a string
    because of the `ds` indicator. You can see, after some functions and strings that
    are also introduced by the compiler, the `_main()` function containing the `"Hello
    world."` string, which reveals what our program does:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.6 – Result of running the RecursiveStringFinder.py script over a
    Hello World program'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16207_02_006.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.6 – Result of running the RecursiveStringFinder.py script over a Hello
    World program
  prefs: []
  type: TYPE_NORMAL
- en: The previous script was developed in Python and it uses the `getStringReferences()`
    function (line `04`) to obtain the operands of instructions (line `07`) that are
    referencing something (line `10`). When the thing referenced is data and, to be
    more precise, a string (lines `12-14`), it is appended to the list of results,
    which is finally shown in the scripting console.
  prefs: []
  type: TYPE_NORMAL
- en: We modified this script to implement a filter when appending strings to the
    list of results in `isAnInterestingString()` (line `15`) to determine whether
    to append it to the list of results or not (lines `16-20`).
  prefs: []
  type: TYPE_NORMAL
- en: Imagine you are looking for URLs in the code of the program being analyzed,
    which can be very useful in practice when analyzing malware because it can reveal
    the server of the attackers. All you need to do is to open `strings` folder (this
    script works with strings). Then, open the `RecursiveStringFinder.py` script and
    add a filtering condition to it by implementing an `isAnInterestingString()` function
    (lines `00-02` in the following code snippet).
  prefs: []
  type: TYPE_NORMAL
- en: 'As a general rule, don''t write a script without first checking whether something
    similar already exists in Ghidra''s arsenal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This script can be easily modified to search for URLs in the code, which is
    very useful when analyzing malware. All you need to do is to replace the condition
    in `isAnInterestingString()` with the appropriate regular expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous script was developed in the Python programming language. If you
    want to experiment with Java, then you can analyze the code in `TranslateStringsScript.java`.
    For the sake of brevity, imports are omitted in the following code listing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: The previous script allows you to modify strings referenced in the program by
    prefixing and suffixing the `TODO` string to it (line `04`). The mentioned script
    can be useful in some cases. For example, if you need to decode a lot of Base64-encoded
    strings or defeat some similar malware obfuscation, then modify the `translateString()`
    function, which is responsible for taking the input string, applying some transformation,
    and returning it.
  prefs: []
  type: TYPE_NORMAL
- en: The `run()` function is the main function of a Ghidra script (line `08`). In
    this case, a string counter is first initialized to zero (line `14`), and then,
    for each string (line `20`), the counter is incremented while the string transformation
    is produced (lines `30`–`32`) and shown (lines `34`–`35`) on each loop iteration.
  prefs: []
  type: TYPE_NORMAL
- en: 'The execution of this script as is produces changes in all the program strings
    by prefixing and suffixing `TODO` to them. As you can see in the following screenshot,
    our `Hello world` string was modified in this way. The script also calculated
    the number of transformed strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.7 – Result of running TranslateStringsScript.java over a Hello World
    program'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16207_02_007.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.7 – Result of running TranslateStringsScript.java over a Hello World
    program
  prefs: []
  type: TYPE_NORMAL
- en: We have seen how to use existing scripts and also how to adapt them to our needs.
    Next, we will learn how exactly the Ghidra script class works.
  prefs: []
  type: TYPE_NORMAL
- en: The script class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To develop a Ghidra script, you need to click on the **Create New Script**
    option available on the **Script Manager** menu. Then, you will be able to decide
    which programming language to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.8 – The programming language dialog during new script creation'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16207_02_008.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.8 – The programming language dialog during new script creation
  prefs: []
  type: TYPE_NORMAL
- en: 'If you decide to use Java, the skeleton of the script will be composed of three
    parts. The first part is the comments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Some comments are obvious, but some of them deserve mention. For instance,
    `@menupath` allows you to specify where to put the script in the menu when it
    is enabled:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.9 – Enabling a script to be integrated with Ghidra'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16207_02_009.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.9 – Enabling a script to be integrated with Ghidra
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that the path must be split by a `.` character:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous source code comment produces the following script integration
    with Ghidra''s menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.10 – Result of integrating a new script with Ghidra'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16207_02_010.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.10 – Result of integrating a new script with Ghidra
  prefs: []
  type: TYPE_NORMAL
- en: 'The next part is the imports, where the most important and strictly necessary
    one is `GhidraScript`. All scripts must inherit from this class and implement
    the `run()` method (which is the main method):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: All the imports are documented in Ghidra's Javadoc documentation; you should
    refer to it when developing your scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Javadoc Ghidra API documentation
  prefs: []
  type: TYPE_NORMAL
- en: By clicking on **Help** and then **Ghidra API Help**, JavaDoc documentation
    for Ghidra will be automatically generated, if it doesn't already exist. Then,
    you will be able to access the documentation for the mentioned import packages:/api/ghidra/app/script/package-summary.html/api/ghidra/program/model/.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the body of the script inherits from `GhidraScript`, where the `run()`
    method must be implemented with your own code. You can access the following `GhidraScript`
    states in your implementation: `currentProgram`, `currentAddress`, `currentLocation`,
    `currentSelection`, and `currentHighlight`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to write a script using Python, the API is the same as Java and
    the script skeleton contains a header (the rest of the script must be filled with
    your own code) and it is very similar to the Java one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: In fact, the Java API is exposed to Python by wrapping it using Jython, which
    is an implementation of the Python programming language designed to run on the
    Java platform.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you go to **Window** and then **Python**, a Python interpreter will appear,
    allowing autocompletion when a *Tab* keystroke happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.11 – The Ghidra Python interpreter autocompletion feature'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16207_02_011.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.11 – The Ghidra Python interpreter autocompletion feature
  prefs: []
  type: TYPE_NORMAL
- en: 'It also allows you to see the documentation by using the `help()` function.
    As you may have already noticed, it is highly recommended to have a Ghidra Python
    interpreter open while developing Ghidra scripts to quickly access the documentation,
    test code fragments, and more. It is very useful:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.12 – Querying Ghidra help by using the Python interpreter'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16207_02_012.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.12 – Querying Ghidra help by using the Python interpreter
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we covered the script class and its structure, how to query
    the Ghidra API documentation in order to implement it, and how the Python interpreter
    can help us during development. In the next section, we will put this into practice
    by writing a Ghidra script.
  prefs: []
  type: TYPE_NORMAL
- en: Script development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now you know all the things needed in order to implement your own script. Let's
    start by writing the header. This script will allow you to patch bytes with no
    operation instructions (`NOP` assembly opcode).
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we start writing the header. Notice that `@keybinding` allows us to
    execute the script with the *Ctrl* + *Alt* + *Shift* + *N* key combination:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, all our script needs to do is to get the current cursor location in Ghidra
    (the `currentLocation` variable), then obtain the address of it (line `03`), the
    instruction at that address is undefined (lines `06`-`08`), patch the byte with
    the `NOP` instruction opcode, which is `0x90` (lines `09`-`11`), and disassemble
    the bytes again (line `12`). The important work to do here is to search for the
    appropriate API functions in the mentioned Javadoc documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, as you know, it is straightforward to translate this piece of code
    to Python, since, as previously said, the API is the same for both languages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: 'In this section, we covered how to write a simple Ghidra script in both supported
    languages: Java and Python.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use existing Ghidra scripts, how to easily
    adapt them to your needs, and finally, how to develop an extremely simple script
    for your preferred language as an introduction to this topic.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 6*](B16207_06_Final_SK_ePub.xhtml#_idTextAnchor108), *Scripting
    Malware Analysis*, and [*Chapter 9*](B16207_09_Final_SK_ePub.xhtml#_idTextAnchor155),
    *Scripting Binary Audits*, you will improve your skills in Ghidra scripting by
    developing and analyzing more complex scripts applied to malware analysis and
    binary auditing.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn how to debug Ghidra by integrating it with
    the Eclipse IDE, which is an extremely useful and required skill to extend Ghidra
    features, as well as for exploring its internals.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Why are Ghidra scripts useful? What is something that you can do with them?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How are scripts organized in Ghidra? Is this organization related to its own
    source code or with the location of the script on the filesystem?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is there no difference between the Java and Python Ghidra scripting APIs?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
