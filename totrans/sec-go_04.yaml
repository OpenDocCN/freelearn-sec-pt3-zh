- en: Forensics
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Forensics is the gathering of evidence to detect a crime. Digital forensics
    refers simply looking for digital evidence and includes locating anomalous files
    that may contain relevant information, searching for hidden data, figuring out
    when a file was last modified, figuring out who sent an email, hashing files,
    gathering information about an attacking IP, or capturing network communication.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: In addition to forensics, this chapter will cover a basic example of steganography—the
    hiding of archives inside images. Steganography is a trick employed to hide information
    within other information so that it is not easily found.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Hashing, while relevant to forensics, is covered in [Chapter 6](f68073f0-8cc8-40b5-af0e-795ce30e5271.xhtml),
    *Cryptography*, and packet capturing is covered in [Chapter 5](e69a87b2-99ff-47cf-a935-4ef39304ed15.xhtml), *Packet
    Capturing and Injection*. You will find examples that could be useful to forensic
    investigators throughout all the chapters this book.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter you, will learn about the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: File forensics
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting basic file information
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding large files
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding recently changed files
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading the boot sector of a disk
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Network forensics
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Looking up hostnames and IP addresses
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Looking up MX mail records
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Looking up nameservers for a host
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Steganography
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hiding an archive in an image
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detecting an archive hidden in an image
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating a random image
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a ZIP archive
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Files
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: File forensics is important because an attacker may leave behind traces, and
    the evidence needs to be gathered before any more changes are made or any information
    is lost. This includes determining who owns a file, when it was last changed,
    who has access to it, and seeing whether there is any hidden data in a file.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Getting file information
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's begin with something simple. This program will print the information about
    a file, namely when it was last modified, who owns it, how many bytes it is, and
    what its permissions are. This will also serve as a good test to make sure that
    your Go development environment is set up properly.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: If an investigator has found an anomalous file, the first thing to do is to
    check all the basic metadata. This will give information about who owns the file,
    what groups have access to it, when it was last modified, whether it is an executable
    file, and how large it is. All of this information is potentially useful.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: The primary function we'll use is `os.Stat()`. This returns a `FileInfo` struct,
    which we will print. We have to import the `os` package at the beginning to call
    `os.Stat()`. Two variables are returned from `os.Stat()`, which is different than
    many languages that only allow one return variable. You can ignore a return variable,
    such as an error you want to ignore, using an underscore (`_`) symbol in place
    of a variable name.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: The `fmt` (short for format) package we import contains typical printing functions
    such as `fmt.Println()` and `fmt.Printf()`. The `log` package contains `log.Printf()`
    and `log.Println()`. The difference between `fmt` and `log` is that `log` prints
    out a `timestamp` before the message, and it is thread safe.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: The `log` package has one function that is not available in `fmt`, and that
    is `log.Fatal()`, which calls `os.Exit(1)` immediately after printing. The `log.Fatal()`
    function is useful for handling certain error conditions by printing the error
    and quitting. Use the `fmt print` function if you want clean output with full
    control. Use the `log` package's print functions if it will be useful to have
    timestamp on each message. When gathering forensic clues, it is important to log
    what time you performed each action.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, the variables are defined in their own section before the
    `main` function. Variables at this scope are available to the whole package. This
    means that every function is in the same file, and the other files are in the
    same directory with the same package declaration. This method of defining variables
    is just to show that this is possible with Go. It is one of Pascal''s influences
    on the language, along with the `:=` operator. It can be nice to have all the
    variables defined at the top with the data type explicitly listed. To save space
    in later examples, we will take advantage of the *declare and assign* operator
    or the `:=` symbol. This is convenient when writing code because you don''t have
    to declare the variable type first. It infers the data type on compilation. When
    reading source code, however, having the variable types declared explicitly can
    help the reader navigate the code. We could have also placed the whole `var` declaration
    inside the `main` function to limit the scope further:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Finding the largest files
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Large files are always prime suspects when investigating. Large database dumps,
    password dumps, rainbow tables, credit card caches, stolen intellectual property,
    and other data are often stored in one large archive that is easy to spot if you
    have the right tools. Also, it would be helpful to find exceptionally large image
    or video files that may have steganographically-hidden information inside. Steganography
    is covered further in this chapter.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: 'This program will search in a directory and all subdirectories for all files
    and sort them by file size. We''ll explore the initial directory with `ioutil.ReadDir()`
    to get the contents as a slice of the `os.FileInfo` structs. To check whether
    a file is a directory, we''ll use `os.IsDir()`. We''ll then create a custom data
    struct named `FileNode` to store the information we need. We use a linked list
    to store the file information. Before inserting an element into the list, we''ll
    go through it to find the proper place in order to keep the list sorted correctly.
    Note that running the program on a directory such as `/` may take a very long
    time. Try a more specific directory such as your `home` folder:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Finding recently modified files
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When examining a victim machine forensically, one of the first things you can
    do is to look for files that have been recently altered. It could give you clues
    as to where an attacker was looking, what settings they modified, or what their
    motive was.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: However, if an investigator is looking through an attacker's machine, then the
    goal is slightly different. Recently accessed files may give clues as to what
    tools they were using to attack where they might be hiding data, or what software
    they use.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example will search a directory and subdirectories to find all
    the files and sort them by the last modified time. This example is very much like
    the previous one except that the sorting is done by comparing timestamps using
    the `time.Time.Before()` function:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Reading the boot sector
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This program will read the first 512 bytes of a disk and print the results as
    decimal values, hex, and a string. The `io.ReadFull()` function is like a normal
    read, but it ensures that the byte slice you provide with for data is completely
    filled. It returns an error if there are not enough bytes in the file to fill
    the byte slice.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: A practical use for this is to check a machine's boot sector to see if it has
    been modified. Rootkits and malware may hijack the boot process by modifying the
    boot sector. You can manually inspect it for anything strange or compare it to
    a known good version. Perhaps a backup image of the machine or a fresh install
    can be compared to see if anything has changed.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can technically pass it any filename and not specifically a disk,
    since everything in Linux is treated as a file. If you pass it the name of the
    device directly, such as `/dev/sda`, it will read the first `512` bytes of the
    disk, which is the boot sector. The primary disk device is typically `/dev/sda`,
    but may also be `/dev/sdb` or `/dev/sdc.` Use `mount` or the `df` tools to get
    more information about what your disks are named. You will need to run the application
    with `sudo` in order to have the permission to read the disk device directly.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information on files, input, and output, look into the `os`, `bufio`,
    and `io` packages, as demonstrated in the following code block:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Steganography
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Steganography is the practice of hiding a message inside a nonsecret message.
    It is not to be confused with stenography, the practice of taking diction, like
    a court reporter who transcribes the spoken words during a trial. Steganography
    goes back in history a long time, and an old-fashioned example is sewing in morse
    code messages in the stitching of clothing items.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: In the digital world, people can hide any type of binary data inside an image,
    audio, or video file. The quality of the original may or may not suffer from this
    process. Some images can maintain their original integrity fully, but they have
    extra data hidden from plain sight in the form of a `.zip` or `.rar` archive.
    Some steganography algorithms are complex and hide the original binary data in
    the single lowest bit of each byte, only denigrating the original quality slightly.
    Other steganography algorithms are simpler and just combine an image file and
    an archive into a single file. We will look at how to hide an archive inside an
    image and also how to detect hidden archives.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Generating an image with random noise
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This program will create a JPEG image with every pixel set to a random color.
    It is a simple program so we have just a jpeg image available to work with. The
    Go standard library comes with `jpeg`, `gif`, and `png` packages. The interface
    to all different image types is the same, so swapping from a `jpeg` to a `gif`
    or `png` package is very easy:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Creating a ZIP archive
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This program will create a ZIP archive, so we have an archive to use with our
    steganography experiments. The Go standard library has a `zip` package, but it
    also supports TAR archives with the `tar` package. This example generates a ZIP
    file with two files: `test.txt` and `test2.txt`. To keep it simple, the contents
    of each file is hard-coded as a string in this source code:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Creating a steganographic image archive
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have an image and a ZIP archive, we can combine them together to
    "hide" the archive within the image. This is probably the most primitive form
    of steganography. A more advanced way would be to split up the file byte by byte,
    store the information in the low bits of the image, use a special program to extract
    the data from the image, and then reconstruct the original data. This example
    is nice because we can easily test and verify if it still loads as an image and
    still behaves like a ZIP archive.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example will take a JPEG image and a ZIP archive and combine
    them to create a hidden archive. The file will retain the `.jpg` extension and
    will still function and look like a normal image. However, the file also still
    works as a ZIP archive. You can unzip the `.jpg` file and the archived files will
    be extracted:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Detecting a ZIP archive in a JPEG image
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If data is hidden using the technique from the previous example, it can be
    detected by searching for the ZIP file signature in the image. A file may have
    a `.jpg` extension and still load properly in a photo viewer, but it may still
    have a ZIP archive stored in the file. The following program searches through
    a file and looks for a ZIP file signature. We can run it against the file created
    in the previous example:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Network
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, a strange IP will show up in logs, and you will need to find out
    more information, or there can be a domain name that you need to geolocate based
    on an IP address. These examples demonstrate gathering information about hosts.
    Packet capturing is also an integral part of network forensic investigations,
    but there is so much to say about packet capturing, so [Chapter 5](e69a87b2-99ff-47cf-a935-4ef39304ed15.xhtml),
    *Packet Capturing and Injection* dedicated just to packet capturing and injection.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: Looking up a hostname from an IP address
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This program will take an IP address and figure out what the hostnames are.
    The `net.parseIP()` function is used to validate the IP address provided, and
    `net.LookupAddr()` does the real work of figuring out what the hostname is.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, the pure Go resolver is used. The resolver can be overridden by
    setting the `netdns` value of the `GODEBUG` environment variable. Set the value
    of `GODEBUG` to `go` or `cgo`. You can do this in Linux with the following shell
    commands:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here is the code for the program:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Looking up IP addresses from a hostname
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following example takes a hostname and returns the IP address. It is very
    similar to the previous example, but it is in reverse. The `net.LookupHost()`
    function does the heavy lifting:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Looking up MX records
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This program will take a domain name and return the MX records. MX records,
    or mail exchanger records, are DNS records that point to the mail server. For
    example, the MX server of [https://www.devdungeon.com/](https://www.devdungeon.com/)
    is `mail.devdungeon.com`. The `net.LookupMX()` function performs this lookup and
    returns a slice of the `net.MX` structs:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Looking up nameservers for a hostname
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This program will find nameservers associated with a given hostname. The primary
    function here is `net.LookupNS()`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Summary
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After reading this chapter, you should now have a basic understanding of the
    goal of digital forensic investigations. Much more could be said on each of these
    topics, and forensics is a specialty field that warrants its own book, much less
    a chapter.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: Use the examples you have read as a starting place to think about what kind
    of information you would look for if you were presented a machine that had been
    compromised, and your goal was to figure out how the attacker got in, what time
    it happened, what they accessed, what they modified, what their motive was, how
    much data was exfiltrated, and anything else you can find to identify who the
    actor was or what actions were taken on the system.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: A skilled adversary will make every attempt to cover their tracks and avoid
    forensic detection. For this reason, it is important to stay up to date on the
    latest tools and trends being used so that you know what tricks and clues to look
    for when investigating.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 一个熟练的对手会尽力掩盖自己的踪迹并避免被取证检测。因此，保持对最新工具和趋势的了解非常重要，这样在调查时你才能知道应该寻找哪些技巧和线索。
- en: These examples can be expanded upon, automated, and integrated into other applications
    that perform forensic searches on a larger scale. With the scalability of Go,
    a tool could easily be crafted to search an entire filesystem or network in an
    efficient manner.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例可以扩展、自动化，并集成到其他执行大规模取证搜索的应用程序中。借助Go语言的可扩展性，可以轻松创建一个工具，以高效的方式搜索整个文件系统或网络。
- en: In the next chapter, we will look at packet capturing with Go. We'll start with
    the basics such as getting a list of network devices and dumping network traffic
    to a file. Then we will talk about using filters to look for specific network
    traffic. In addition, we will look at more advanced techniques for decoding and
    inspecting packets using Go interfaces. We will also cover creating custom packet
    layers and forging and sending packets from a network card, allowing you to send
    arbitrary packets.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将讨论如何使用Go进行数据包捕获。我们将从基本的内容开始，比如获取网络设备列表并将网络流量转储到文件中。接着，我们将讨论如何使用过滤器来查找特定的网络流量。此外，我们还将探讨使用Go接口解码和检查数据包的更高级技巧。我们还将介绍如何创建自定义数据包层以及从网络卡伪造和发送数据包，从而允许你发送任意数据包。
