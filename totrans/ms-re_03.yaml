- en: The Low-Level Language
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main piece of knowledge required in advance for any reverse engineer is
    assembly language. Understanding assembly language is like learning the ABCs of
    reversing. It may look hard at first, but eventually it will become like a muscle
    memory. Assembly language is the language that is used to communicate with the
    machine. The source code of a program can be understood by humans but not by the
    machine. The source code has to be compiled down to its assembly language code
    form for the machine to understand it.
  prefs: []
  type: TYPE_NORMAL
- en: But, as humans, what if the source code is not available? Our only way to understand
    what a program does is to read its assembly codes. In a way, what we are building
    here is a way to turn an assembly language code back to the source code. That
    would be why this is called reversing.
  prefs: []
  type: TYPE_NORMAL
- en: We will provide a brief introduction to assembly language, focusing on the x86
    Intel architecture. So, why x86? There are a lot of architectures out there, such
    as 8080, ARM, MIPS, PowerPC, and SPARC, but we are focusing on Intel x86 as it
    is the most popular and widely used architecture today.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will get to learn the basics of assembly language. We will
    start by reviewing binary numbers, followed by using assembly language instructions
    to implement binary arithmetic, we will then learn how to compile our own low-level
    program, and, finally, how to debug a program.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter has been divided into sections. We will learn about the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Binary numbers, bases, and the ASCII table
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: x86 architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assembly language instructions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tools used to edit and compile an assembly-language source code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exceptions and error handling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Windows APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: High-level language constructs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will include instructions to set up and develop your assembly language code.
    This also comes with exercises that may help to inspire you to develop programs
    using assembly language.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is best, but not required, that the reader has some background knowledge
    of any programming language. Having a programming background will help the reader
    to understand assembly language more quickly. There are references given at the
    end of this chapter that the reader can use for further programming development
    and research not provided in this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some tools that we will use here include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Binary editors, such as HxD Editor or HIEW (Hacker's View)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Text editors, such as Notepad++
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Binary numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Computers were designed to electronically process and store data using signals.
    A signal is like an on/off switch, where both the "on" and "off" positions can
    be denoted by the numbers "1" and "0" respectively. These two numbers are what
    we call binary numbers. The next section will discuss how binary numbers are used
    and how this relates to other number bases.
  prefs: []
  type: TYPE_NORMAL
- en: Bases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The place value of a digit in a number determines its value at that position.
    In the standard decimal numbers, the value of a place is ten times the value of
    the place on its right. The decimal number system is also called base-10, which
    is composed of digits from 0 to 9.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say that position 1 is at the right-most digit of the whole number,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The sum of all represented numbers is the actual value. Following this concept
    will help us to read or convert into other number bases.
  prefs: []
  type: TYPE_NORMAL
- en: 'In base-2 numbers, the value of a place is 2 times the value of the place on
    its right. Base-2 uses only 2 digits, composed of 0 and 1\. In this book, we will
    append a small `b` to denote that the number is of base-2 format. Base-2 numbers
    are also called binary numbers. Each digit in a binary string is called a bit.
    Consider the following as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In base-16 numbers, the value of a place is 16 times the value of the place
    on its right. It is composed of digits 0 to 9 and letters A to F where A is equivalent
    to 10, B is 11, C is 12, D is 13, E is 14, and F is 15\. We will denote base-16
    numbers, also known as hexadecimal numbers, with the letter `h`. In this book,
    hexadecimal numbers with an odd number of digits will be prefixed with `0` (zero).
    Hexadecimal numbers can also instead be prefixed with "0x" (zero and a lowercase
    x). The `0x` is a standard used on various programming languages denoting that
    the number next to it is of hexadecimal format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Converting between bases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already converted hexadecimal and binary numbers into decimal, or base-10\.
    Converting base-10 into other bases simply requires division of the base being
    converted into, while taking note of the remainders.
  prefs: []
  type: TYPE_NORMAL
- en: The following is an example for base-2
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is an example for base-16:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Converting from hexadecimal into binary simply requires knowing how many binary
    digits there are in a hexadecimal digit. The highest digit for a hexadecimal number
    is `0Fh` (15) and is equivalent to `1111b`. Take note that there are 4 binary
    digits in a hexadecimal digit. An example conversion is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Split the binary number into four digits each when converting from binary into
    hexadecimal, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'So, why the use of base-2 and base-16 in computers, rather than our daily base-10
    usage? Well, for base-2, there are two states: an on and an off signal. A state
    can easily be read and transmitted electronically. Base-16 compresses the representation
    of the binary equivalent of a decimal number. Take 10 for instance: this number
    is represented as `1010b` and consumes 4 bits. To maximize the information that
    can be stored in 4 bits, we can represent numbers from 0 to 15 instead.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A 4-bit value is also called a nibble. It is half of a byte. Bytes can represent alphabets,
    numbers, and characters. This representation of characters is mapped in the ASCII
    table. The ASCII table has three sections: control, printable, and extended characters.
    There are 255 (`FFh`) ASCII characters. Lists of printable characters that can
    be typed on the keyboard and some of the extended characters with keyboard format
    can be found at [https://github.com/PacktPublishing/Mastering-Reverse-Engineering/tree/master/ch3](https://github.com/PacktPublishing/Mastering-Reverse-Engineering/tree/master/ch3).'
  prefs: []
  type: TYPE_NORMAL
- en: Though not directly visible from the English language keyboard, symbols can
    still be displayed by using the character's equivalent code.
  prefs: []
  type: TYPE_NORMAL
- en: Binary arithmetic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since a byte is the common unit used in computers, let''s play with it. We
    can start with basic arithmetical functions: addition, subtraction, multiplication,
    and division. The pencil-and-paper method is still a strong method for doing binary
    math. Binary arithmetic is similar to doing arithmetic in decimal numbers. The
    difference is that there are only two numbers used, 1 and 0.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Addition is carried out as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'An example of subtraction is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Multiplication is carried out as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Division in binary works as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Signed numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Binary numbers can be structured as signed or unsigned. For signed numbers or
    integers, the most significant bit dictates what sign the number is in. This requires
    a defined size of the binary such as `BYTE`, `WORD`, `DWORD`, and `QWORD`. A `BYTE`
    has a size of 8 bits. A `WORD` has 16 bits while a DWORD (double `WORD`) has 32
    bits. A `QWORD` (quad `WORD`) has 64 bits. Basically, the size doubles as it progresses.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example, let''s use a `BYTE`. Identifying a positive binary number is
    easy. In positive numbers, the most significant bit, or 8^(th) bit in a byte,
    is 0\. The rest of the bits from 0 to the 7th bit is the actual value. For a negative
    binary number, the most significant bit is set to 1\. However, the value set from
    0 to the 7th bit is then calculated for a two''s complement value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The "2''s complement" of a value is calculated in two steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Reverse 1s and 0s, so that 1 becomes 0 and 0 becomes 1, for example, `1010b`
    becomes `0101b`. This step is called the one's complement.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add 1 to the result of the previous step, for example, `0101b + 1b = 0110b`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To write down the binary equivalent of -63, assuming it is a `BYTE`, we only
    take bits 0 to 7:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Convert into binary using the previous procedure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Do "1''s complement" as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Add 1 to the preceding outcome to get the "2''s complement" result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Since this is a negative number, set the most significant bit to 1:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s how to write the decimal of a negative binary number:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Take note that the significant bit is 1, and so a negative sign:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Take the "1''s complement," then add 1:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Convert the result to decimal, and place the – sign at the beginning, since
    this is a negative number:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: x86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like any other programming language, assembly language has its own variables,
    syntax, operations, and functions. Every line of code is processes a small amount
    of data. In other words, every byte is read or written per line of code.
  prefs: []
  type: TYPE_NORMAL
- en: Registers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In programming, processing data requires variables. You can simply think of
    registers as variables in assembly language. However, not all registers are treated
    as plain variables, but rather, each register has a designated purpose. The registers
    are categorized as being one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: General purpose registers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Segment registers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flag registers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instruction pointers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In x86 architecture, each general purpose register has its designated purpose
    and is stored at `WORD` size, or 16 bits, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Accumulator (AX)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Counter (CX)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data (DX)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Base (BX)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stack pointer (SP)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Base pointer (BP)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Source index (SI)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Destination index (DI)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For registers AX, BX, CX, and DX, the least and most significant bytes can
    be accessed by smaller registers. For AX, the lower 8 bits can be read using the
    AL register, while the upper 8 bits can be read using the AH register, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9526322d-72c7-40e5-be7b-4114fb6d614c.png)'
  prefs: []
  type: TYPE_IMG
- en: When running code, the system needs to identify where the code is at. The Instruction
    Pointer (IP) register is the one that contains the memory address where the next
    assembly instruction to be executed is stored.
  prefs: []
  type: TYPE_NORMAL
- en: 'System states and logical results of executed code are stored in the **FLAGS
    register**. Every bit of the FLAGS register has its own purpose, with some of
    the definitions given in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Offset** | **Abbreviation** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | CF | Carry flag. This flag is set when an addition operation requires
    a bit to be carried. It is also set when a bit needs to be borrowed in a subtraction
    operation. |'
  prefs: []
  type: TYPE_TB
- en: '| 1 |  | Reserved |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | PF | Parity flag. This flag indicates if the number of set bits is odd
    or even from the last instruction operation. |'
  prefs: []
  type: TYPE_TB
- en: '| 3 |  | Reserved |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | AF | Adjust flag. This is used in Binary-Coded Decimals (BCD). This flag
    is set when a carry happens from the low to high nibble or when a borrow happens
    from the high to low nibble of a byte. |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | ZF | Zero flag. This flag is set when the result of the last instruction
    operation is zero. |'
  prefs: []
  type: TYPE_TB
- en: '| 7 | SF | Sign flag. This flag is set when the result of the last instruction
    operation is a negative number. |'
  prefs: []
  type: TYPE_TB
- en: '| 8 | TF | Trap flag. This is used when debugging. This flag is set when breakpoints
    are encountered. Setting the trap flag can cause an exception on every instruction,
    enabling debugging tools to control step-by-step debugging. |'
  prefs: []
  type: TYPE_TB
- en: '| 9 | IF | Interrupt flag. If this flag is set, the processor responds to interrupts.
    Interrupts are instances where errors, external events, or exceptions are triggered
    from hardware or software.  |'
  prefs: []
  type: TYPE_TB
- en: '| 10 | DF | Direction flag. When set, data is read from memory backwards. |'
  prefs: []
  type: TYPE_TB
- en: '| 11 | OF | Overflow flag. It is set if an arithmetic operation results in
    a value larger than what the register can contain. |'
  prefs: []
  type: TYPE_TB
- en: '| 12 to 13 | IOPL | Input/output privilege level. The IOPL shows the ability
    of the program to access IO ports. |'
  prefs: []
  type: TYPE_TB
- en: '| 14 | NT | Nested task flag. This controls the chaining of interrupt tasks
    or processes. If set, then it is linked to the chain. |'
  prefs: []
  type: TYPE_TB
- en: '| 15 |  | Reserved |'
  prefs: []
  type: TYPE_TB
- en: '| 16 | RF | Resume flag. It temporarily disables debug exceptions so the next
    instruction being debugged can be interrupted without a debug exception. |'
  prefs: []
  type: TYPE_TB
- en: '| 17 | VM | Virtual mode. Sets the program to run in compatibility with 8086
    processors. |'
  prefs: []
  type: TYPE_TB
- en: '| 18 | AC | Alignment check. This flag is set when data written on a memory
    reference, such as the stack, is a non-word (for 4 byte boundaries) or non-doubleword
    (for 8 byte boundaries). However, this flag was more useful before the 486-architecture
    days. |'
  prefs: []
  type: TYPE_TB
- en: '| 19 | VIF | Virtual interrupt flag. Similar to the interrupt flag, but works
    when in virtual mode. |'
  prefs: []
  type: TYPE_TB
- en: '| 20 | VIP | Virtual interrupt pending flag. Indicates that triggered interrupts
    are waiting to be processed. Works in Virtual mode. |'
  prefs: []
  type: TYPE_TB
- en: '| 21 | ID | Identification flag. Indicates if the CPUID instruction can be
    used. The CPUID can determine the type of processor and other processor info.
    |'
  prefs: []
  type: TYPE_TB
- en: '| 22 |  | Reserved |'
  prefs: []
  type: TYPE_TB
- en: '| 23 to 31 |  | Reserved |'
  prefs: []
  type: TYPE_TB
- en: '| 32 to 63 |  | Reserved |'
  prefs: []
  type: TYPE_TB
- en: All of these flags have a purpose, but the flags that are mostly monitored and
    used are the carry, sign, zero, overflow, and parity flags.
  prefs: []
  type: TYPE_NORMAL
- en: All these registers have an "extended" mode for 32-bits. It can accessed with
    a prefixed "E" (`EAX`, `EBX`, `ECX`, `EDX`, `ESP`, `EIP`, and `EFLAGS`). The same
    goes with 64-bit mode, which can be accessed with a prefixed "R" (`RAX`, `RBX`,
    `RCX`, `RDX`, `RSP`, and `RIP`).
  prefs: []
  type: TYPE_NORMAL
- en: 'The memory is divided into sections such as the code segment, stack segment,
    data segment, and other sections. The segment registers are used to identify the
    starting location of these sections, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Stack segment (SS)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code segment (CS)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data segment (DS)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extra segment (ES)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: F segment (FS)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: G segment (GS)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When a program loads, the operating system maps the executable file to the memory.
    The executable file contains information to which data maps respective segments.
    The code segment contains the executable code. The data segment contains the data
    bytes, such as constants, strings, and global variables. The stack segment is
    allocated to contain runtime function variables and other processed data. The
    extra segment is similar to the data segment, but this space is commonly used
    to move data between variables. Some 16-bit operating systems, such as DOS, make
    use of the SS, CS, DS, and ES since there are only 64 kilobytes allocated per
    segment. However, in modern operating systems (32-bit systems and higher) these
    four segments are set in the same memory space, while FS and GS point to process
    and thread information respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Memory addressing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The start of a piece of data, a series of bytes, stored in the memory can be
    located using its memory address. Every byte stored in the memory is assigned
    a memory address that identifies its location. When a program is executed by a
    user, the executable file is read, then mapped by the system to an allocated memory
    address. The executable file contains information on how it maps it, so that all
    executable code is in the code section, all initialized data is in the data section,
    and uninitialized data is in the BSS section. Code instructions found in the code
    section are able to access data in the data section using memory addresses, which
    can be hard-coded. Data can also be a list of addresses pointing to another set
    of data.
  prefs: []
  type: TYPE_NORMAL
- en: Endianness
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When reading or writing data to memory, we use the registers or memory to process
    them as `BYTE`, `WORD`, `DWORD`, or even `QWORD`. Depending on the platform or
    program, data is read in little-endian or big-endian form.
  prefs: []
  type: TYPE_NORMAL
- en: 'In little-endian, a chunk of data read into a `DWORD` is reversed. Let''s take
    the following piece of data as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AA BB CC DD`'
  prefs: []
  type: TYPE_NORMAL
- en: When the data on a file or memory looks like this, in little-endian format,
    it will be read as `DDCCBBAAh` in a `DWORD` value. This endianness is common to
    Windows applications.
  prefs: []
  type: TYPE_NORMAL
- en: In the big-endian system, the same chunk of data will be read as `AABBCCDDh`.
    The advantage of using the big-endian form arises when reading streaming data
    such as file, serial, and network streams.
  prefs: []
  type: TYPE_NORMAL
- en: 'The advantage of reading in little-endian is that the address you read it from
    remains fixed, regardless of whether it is read as `BYTE`, `WORD`, or `DWORD`.
    For example, consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we attempt to read the data from address the `0x00000000`
    address. When read as `BYTE`, it will be `AAh`. When read as a `WORD`, it will
    be `AAh`. When read as a `DWORD`, it will be `AAh`.
  prefs: []
  type: TYPE_NORMAL
- en: But when in big endian, when read as a `BYTE`, it will be `AAh`. When read as
    a `WORD`, it will be `AA00h`. When read as a `DWORD`, it will be `AA000000h`.
  prefs: []
  type: TYPE_NORMAL
- en: There are actually a lot more advantages over the other. Either of these can
    be used by an application depending on its purpose. In `x86` assembly, the little-endian
    format is the standard.
  prefs: []
  type: TYPE_NORMAL
- en: Basic instructions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Assembly language is made up of direct lines of code that follow this syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/24fb4ebb-a025-441f-96ea-0233fbe2e22d.png)'
  prefs: []
  type: TYPE_IMG
- en: The label is used to define the location of the instruction line. It is generally
    used during development of an assembly code without prior knowledge of the address
    where the code will be placed in the memory. Some debuggers are able to support
    having the user label addresses with a readable name. A mnemonic is a human readable
    instruction, such as MOV, ADD and SUB. Every mnemonic is represented by a byte
    number or a couple of bytes called an opcode. The operands are the instruction's
    arguments. This is normally read as `destination, source` . In the instruction
    shown above, the `eax` register is the destination and the doubleword data stored
    at address 0x0AD4194\. Finally, we can add comments to every instruction line
    of our program.
  prefs: []
  type: TYPE_NORMAL
- en: In assembly language, code comments are denoted by a semicolon (;)
  prefs: []
  type: TYPE_NORMAL
- en: Opcode bytes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Every instruction has an equivalent opcode (operation code) byte:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the MOV instruction is equivalent to the `B8` opcode
    byte. The `MOV` instruction at the `00A92D81` address is equivalent to `B9`. The
    difference between the two `MOV` instructions is the register into which the `DWORD`
    value is moved. There are a total of 5 bytes consumed in `MOV EAX, 80000000h`.
    It consists of the opcode byte, `B8`, and the operand value, `80000000h`. The
    same number of bytes is also used in `MOV ECX, 2`, and `MUL ECX` uses 2 bytes.
  prefs: []
  type: TYPE_NORMAL
- en: '`MOV EAX, 80000000h` is located at `00A92D7ch`. Add 5 bytes (becomes `00A92D81`)
    and we get to the address of the next instruction. Viewing the code in the memory
    would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: A dump of memory is usually shown in memory dumpers in paragraphs or 16 bytes
    per line and address aligned to `10h`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assembly language instructions can be categorized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Copying and accessing data instructions (for example, MOV, LEA, and MOVB)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arithmetic instructions (for example, ADD, SUB, MUL, and DIV)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Binary logic instructions (for example, XOR, NOT, SHR, and ROL)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flow control (for example, JMP, CALL, CMP, and INT)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copying data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The MOV  instruction is used to move data. With this, data is moved either to
    or from a register or a memory address.
  prefs: []
  type: TYPE_NORMAL
- en: '`mov eax, 0xaabbccdd`  places the `0xaabbccdd` value in the `eax` register.'
  prefs: []
  type: TYPE_NORMAL
- en: '`mov eax, edx` places the data value from the`edx` register to the `eax `register.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take the following memory entries as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Reading data may require using directives to help the assembler. We use `byte
    ptr`, `word ptr`, or `dword ptr`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The memory will look like this afterward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: MOV and LEA
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'MOV is used to read the value at a given address, while LEA (Load Effective
    Address) is used to get the address instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'So, how is the LEA instruction helpful if you can calculate the address by
    yourself? Let''s take the following C code as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The C code starts with defining `test[10]`, an array of `struct Test`, which
    contains two integers, `x` and `y`. The `for-loop` statement takes the value of
    `y` and the pointer address of `y` in a `struct test` element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say the base of the test array is in EBX, the `for-loop` counter, `i`,
    is in `ECX`, the integers are `DWORD` values, and so `struct Test` will contain
    two `DWORD` values. Knowing that a `DWORD` has 4 bytes, the equivalent of `value
    = test[i].y;` in assembly language will look like `mov edx, [ebx+ecx*8+4]`. Then,
    the equivalent of `p = &test[i].y;` in assembly language will look like `lea esi,
    [ebx+ecx*8+4]`. Indeed, without using LEA, the address can still be calculated
    with arithmetic instructions. However, calculating for the address could be done
    much more easily using LEA:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code shows that the six lines of code can be optimized to three
    lines using the LEA instruction.
  prefs: []
  type: TYPE_NORMAL
- en: Arithmetic operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: x86 instructions are based on the CISC architecture, where arithmetical instructions
    such as ADD, SUB, MUL, and DIV have a more low-level set of operations behind
    them. Arithmetical instructions work with the help of a set of flags that indicates
    certain conditions to be met during the operation.
  prefs: []
  type: TYPE_NORMAL
- en: Addition and subtraction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition (ADD) and subtraction (SUB), the OF, SF, and CF flags are affected.
    Let's see some examples of usage as instruction.
  prefs: []
  type: TYPE_NORMAL
- en: '`add eax, ecx` adds whatever value is in the `ecx` register to the value in
    `eax`. The results of adding `eax` and `ecx` goes into `eax`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take the following example to see how it sets the OF, SF and CF flags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The registers are DWORDs. The `ecx` and `ebx` registers were set with `0x0fffffff`
    (‭268,435,455‬), adding these results to `0x1ffffffe` (‭536,870,910‬). SF was
    not set, since the result did not touch the most significant bit (MSB). CF was
    not set because the result is still within the capacity of a `DWORD`. Assuming
    that both were signed numbers, the result is still within the capacity of a signed
    `DWORD` number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The result in `ecx` becomes `0xfffffffe` (`-2`). `CF = 0`; `SF = 1`; `OF = 1`.
    Assuming that both `ecx` and `ebx` were unsigned, the CF flag will not be set.
    Assuming that both `ecx` and `ebx` were signed numbers and both are positive numbers,
    the `OF` flag will be set. And since the most significant bit becomes `1`, the
    `SF` flag is also set.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, how about adding two negative numbers? Let''s consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Basically, we're adding both `ecx` and `ebx`, containing `0x80000000` (-2,147,483,648),
    the result of which becomes zero (0). `CF = 1`; `SF = 0`; `OF = 1`. The SF flag
    was not set since the `MSB` of the result is 0\. Adding both MSB of ecx and ebx
    will definitely exceed the capacity of a `DWORD` value. At the signed number perspective,
    the OF flag is also set, since adding both negative values exceeds the signed
    `DWORD` capacity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try the borrow concept in this next example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: What happens here is that we are subtracting `0x80000000` (-2,147,483,648) from
    `0x7fffffff` (‭2,147,483,647‬). In fact, what we are expecting is the sum of 2,147,483,648
    and 2,147,483,647\. The result in `ecx` becomes `0xffffffff` (-1). CF = 1; SF
    = 1; OF = 1\. Remember that we are doing a subtraction operation, thereby causing
    CF to be set, due to borrowing. The same goes for the OF flag.
  prefs: []
  type: TYPE_NORMAL
- en: Increment and decrement instructions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The INC instruction simply adds 1, while DEC subtracts 1\. The following code
    results in `eax` becoming zero (0):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code results in `eax` becoming `0xffffffff`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Multiplication and division instructions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'MUL is used for multiplication and DIV for division. In multiplication, we
    expect that multiplying values would exceed the capacity of the register value.
    Hence the product is stored in AX, `DX:AX` or `EDX:EAX` (long or `QWORD`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The product stored in eax is zero (0), and `edx` now contains `0x00000001`.
    `SF =0`; `CF = 1`; and `OF = 1`.
  prefs: []
  type: TYPE_NORMAL
- en: For division, the dividend is placed in `AX`, `DX:AX`, or `EDX:EAX`, and after
    the division operation, the quotient is placed in `AL`, `AX`, or `EAX`. The remainder
    is stored in `AH`, `DX`, or `EDX`.
  prefs: []
  type: TYPE_NORMAL
- en: Other signed operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**NEG**'
  prefs: []
  type: TYPE_NORMAL
- en: This operation does a two's complement.
  prefs: []
  type: TYPE_NORMAL
- en: Consider the following as an example: `NEG EAX` or `NEG dword ptr [00403000]`.
  prefs: []
  type: TYPE_NORMAL
- en: If `EAX` were `01h`, it becomes `FFFFFFFFh` (-1).
  prefs: []
  type: TYPE_NORMAL
- en: '**MOVSX**'
  prefs: []
  type: TYPE_NORMAL
- en: This moves a `BYTE` to WORD or WORD to `DWORD`, including the sign. It is a
    more flexible instruction than CBW, CWDE, CWD, since it accommodates operands.
  prefs: []
  type: TYPE_NORMAL
- en: Consider the following as an example: `MOVSX EAX, BX`.
  prefs: []
  type: TYPE_NORMAL
- en: If BX were `FFFFh` (-1) and the sign flag is set, EAX will be `FFFFFFFFh` (-1).
  prefs: []
  type: TYPE_NORMAL
- en: '**CBW**'
  prefs: []
  type: TYPE_NORMAL
- en: Similar to MOVSX, it converts a `BYTE` into `WORD`, including the sign. The
    affected register is AL and AX. This is an instruction without any operands and
    is similar to MOVSX.  The effect turns the byte AL extend to its word counterpart,
    AX.   Such conversion is dentoed with a "->" sign.  For example,  `AL -> AX` means
    we are extending the 8-bit number to a 16-bit without compromising the stored
    value.
  prefs: []
  type: TYPE_NORMAL
- en: If AL were `FFh` (-1), AX will be `FFFFh` (-1).
  prefs: []
  type: TYPE_NORMAL
- en: '**CWDE**'
  prefs: []
  type: TYPE_NORMAL
- en: This is similar to CBW, but converts a `WORD` into `DWORD`. It affects `AX->EAX`.
  prefs: []
  type: TYPE_NORMAL
- en: '**CWD**'
  prefs: []
  type: TYPE_NORMAL
- en: This is similar to CBW, but converts a `WORD` into `DWORD`. It affects `AX->
    DX:AX`.
  prefs: []
  type: TYPE_NORMAL
- en: '**IMUL/IDIV**'
  prefs: []
  type: TYPE_NORMAL
- en: This performs MUL and DIV, but accepts operands from other registers or memory.
  prefs: []
  type: TYPE_NORMAL
- en: Bitwise algebra
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Boolean algebra or bitwise operations are necessary in low-level programming
    since it can perform simple calculations by changing the bits of a number. It
    is commonly used in cryptography's obfuscation and decoding.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOT**'
  prefs: []
  type: TYPE_NORMAL
- en: This operation reverses the bits.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following as an example: `NOT AL`'
  prefs: []
  type: TYPE_NORMAL
- en: If AL equals `1010101b` (`55h`), it becomes `10101010b` (`AAh`).
  prefs: []
  type: TYPE_NORMAL
- en: '**AND**'
  prefs: []
  type: TYPE_NORMAL
- en: This operation sets `bit` to `1` if both are `1`s, otherwise it sets `bit` to
    `0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following as an example: `AND AL, AH`'
  prefs: []
  type: TYPE_NORMAL
- en: If AL equals `10111010b` (`BAh`) and AH equals `11101101b` (`EDh`), AL becomes
    `10101000b` (`A8h`).
  prefs: []
  type: TYPE_NORMAL
- en: '**OR**'
  prefs: []
  type: TYPE_NORMAL
- en: This operation sets `bit` to `0` if both are `0`s, else it sets `bit` to `1`.
  prefs: []
  type: TYPE_NORMAL
- en: Consider the following as an example: `OR AL, AH`
  prefs: []
  type: TYPE_NORMAL
- en: If AL equals `10111010b` (`BAh`) and AH equals `11101100b` (`ECh`), AL becomes
    `11111110b` (`FEh`).
  prefs: []
  type: TYPE_NORMAL
- en: '**XOR**'
  prefs: []
  type: TYPE_NORMAL
- en: This operation sets bit to `0` if both bits are equal, else it sets bit to `1`.
  prefs: []
  type: TYPE_NORMAL
- en: Consider the following as an example: `XOR EAX, EAX`
  prefs: []
  type: TYPE_NORMAL
- en: 'XOR-ing the same value will become `0`. Thus `EAX` becomes `0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`XOR AH, AL`'
  prefs: []
  type: TYPE_NORMAL
- en: If AH were `100010b` (`22h`) and AL were `1101011b` (`6Bh`), AH becomes `1001001b`
    (`49h`).
  prefs: []
  type: TYPE_NORMAL
- en: '**SHL/SAL**'
  prefs: []
  type: TYPE_NORMAL
- en: This operation shifts bits to the left.
  prefs: []
  type: TYPE_NORMAL
- en: Consider the following as an example: `SHL AL, 3`
  prefs: []
  type: TYPE_NORMAL
- en: If `AL` were `11011101b` (`DDh`), shifting it to the left by `3` makes AL equal
    to `11101000b` (`E8h`).
  prefs: []
  type: TYPE_NORMAL
- en: '**SHR/SAR**'
  prefs: []
  type: TYPE_NORMAL
- en: This operation shifts bits to the right.
  prefs: []
  type: TYPE_NORMAL
- en: Consider the following as an example: `SHR AL, 3`
  prefs: []
  type: TYPE_NORMAL
- en: If `AL` were `11011101b` (`DDh`), shifting it to the right by `3` makes AL equal
    to `011011b` (`1Bh`).
  prefs: []
  type: TYPE_NORMAL
- en: '**ROL**'
  prefs: []
  type: TYPE_NORMAL
- en: This operation rotates bits to the left.
  prefs: []
  type: TYPE_NORMAL
- en: Consider the following as an example: `ROL AL, 3`
  prefs: []
  type: TYPE_NORMAL
- en: if `AL` were `11011101b` (`DDh`), rotating it to the left by `3` makes AL equal
    to `11101110b` (`EEh`).
  prefs: []
  type: TYPE_NORMAL
- en: '**ROR**'
  prefs: []
  type: TYPE_NORMAL
- en: This operation rotates bits to the right.
  prefs: []
  type: TYPE_NORMAL
- en: Consider the following as an example: `ROR AL, 3`
  prefs: []
  type: TYPE_NORMAL
- en: If `AL` were `11011101b` (`DDh`), rotating it to the right by `3` makes AL equal
    to `10111011b` (`BBh`).
  prefs: []
  type: TYPE_NORMAL
- en: Control flow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The beauty of a program is that we can carry out a number of different behaviors
    based on condition and state. For example, we can make a certain task repeat until
    a counter reaches a defined maximum. In C programming, the program's flow is controlled
    by instructions such as the `if-then-else` and `for-loop` statements. The following
    are common instructions used in assembly language, in conjunction with program
    control flow. The affected register in this is the index pointer IP/EIP, which
    holds the current address where the next instruction to execute is located.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Short for jump, this means that the operand is an address that it will go to.
    It sets the EIP to the next instruction line. There are two main variations for
    the address: direct and indirect.'
  prefs: []
  type: TYPE_NORMAL
- en: A `JMP` using a direct address would literally jump to the given address. Consider
    as an example: `JMP  00401000`. This will set the `EIP` to `00401000h`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A `JMP` using an indirect address would jump to an address that can only be
    known when the jump is executed. The address has to be retrieved or calculated
    somehow prior to the `JMP` instruction. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '**CALL and RET**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to `JMP`, this goes to the address stated in the operand, but stores
    the address of the next instruction to the stack after the CALL instruction. The
    address is stored in the stack and will be used by the `RET` instruction later
    to point `EIP` back to it. For example, consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: When the CALL happens at the address `00401000`, the top of the stack will contain
    the value `00401005h`, which will be the return address. The code passes it to
    the instruction at the address `00401100`, where `EAX` is set to `F00bF00Bh`.
    Then the `RET` instruction retrieves the return address from the top of the stack
    and sets the EIP.  A subroutine or procedure is the term used for the lines of
    instructions from the call.
  prefs: []
  type: TYPE_NORMAL
- en: The `RET` instruction can optionally have an operand. The operand is the number
    of stack `DWORDs` it will release before retrieving the return address. This is
    useful when the stack is used within the subroutine as it serves as a cleanup
    of the used stack.
  prefs: []
  type: TYPE_NORMAL
- en: '**Conditional jumps**'
  prefs: []
  type: TYPE_NORMAL
- en: 'These are jumps that depend on the flags and the counter register:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Instruction** | **Flags** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `JZ/JE` | ZF = 1 | Jump if zero/Jump if equal |'
  prefs: []
  type: TYPE_TB
- en: '| `JNZ/JNE` | ZF = 0 | Jump if not zero/Jump if not equal |'
  prefs: []
  type: TYPE_TB
- en: '| `JS` | SF = 1 | Jump if sign |'
  prefs: []
  type: TYPE_TB
- en: '| `JNS` | SF = 0 | Jump if not sign |'
  prefs: []
  type: TYPE_TB
- en: '| `JC/JB/JNAE` | CF = 1 | Jump if carry/Jump if below/Jump if not above or
    equal |'
  prefs: []
  type: TYPE_TB
- en: '| `JNC/JNB/JAE` | CF = 0 | Jump if not carry/jump if not below/Jump if above
    or equal |'
  prefs: []
  type: TYPE_TB
- en: '| `JO` | OF = 1 | Jump if overflow |'
  prefs: []
  type: TYPE_TB
- en: '| `JNO` | OF = 0 | Jump if not overflow |'
  prefs: []
  type: TYPE_TB
- en: '| `JA/JNBE` | CF = 0 and ZF = 0 | Jump if above/Jump if not below or equal
    |'
  prefs: []
  type: TYPE_TB
- en: '| `JNA/JBE` | CF = 1 or ZF = 1 | Jump if not above/Jump if below or equal |'
  prefs: []
  type: TYPE_TB
- en: '| `JG/JNLE` | ZF = 0 and SF = OF | Jump if greater/Jump if not less or equal
    |'
  prefs: []
  type: TYPE_TB
- en: '| `JNG/JLE` | ZF = 1 or SF != OF | Jump if not greater/Jump if less or equal
    |'
  prefs: []
  type: TYPE_TB
- en: '| `JL/JNGE` | SF != OF | Jump if less/Jump if not greater or equal |'
  prefs: []
  type: TYPE_TB
- en: '| `JNL/JGE` | SF = OF | Jump if not less/Jump if greater or equal |'
  prefs: []
  type: TYPE_TB
- en: '| `JP/JPE` | PF = 1 | Jump if parity/Jump if parity is even |'
  prefs: []
  type: TYPE_TB
- en: '| `JNP/JPO` | PF = 0 | Jump if not parity/Jump if parity is odd |'
  prefs: []
  type: TYPE_TB
- en: '| `JCXZ` | CX = 0 | Jump if CX is zero. |'
  prefs: []
  type: TYPE_TB
- en: '| `JECXZ` | ECX = 0 | Jump if ECX is zero. |'
  prefs: []
  type: TYPE_TB
- en: '| `LOOP` | ECX > 0 | Jump if ECX is not zero. Decrements ECX. |'
  prefs: []
  type: TYPE_TB
- en: '| `LOOPE` | ECX > 0 and ZF = 1 | Jump if ECX is not zero and zero flag is set.
    Decrements ECX. |'
  prefs: []
  type: TYPE_TB
- en: '| `LOOPNE` | ECX > 0 and ZF = 0 | Jump if ECX is not zero and zero flag is
    not set. Decrements ECX. |'
  prefs: []
  type: TYPE_TB
- en: '**Flagging instructions**'
  prefs: []
  type: TYPE_NORMAL
- en: Besides the arithmetic, bit-wise operations, interrupts, and return values from
    functions, these instructions are also able to set flags.
  prefs: []
  type: TYPE_NORMAL
- en: '**CMP** performs a SUB instruction on the first and second operands, but does
    not modify the registers or the immediate value. It only affects the flags.'
  prefs: []
  type: TYPE_NORMAL
- en: '**TEST** performs an AND instruction on the first and second operands, but
    does not modify the registers or the immediate value. It only affects the flags.'
  prefs: []
  type: TYPE_NORMAL
- en: Stack manipulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The stack is a memory space where data is temporarily stored. Adding and removing
    data in the stack is in a first-in-last-out method. Subroutines compiled from
    programs in C initially allocate space in the stack, called a stack frame, for
    its uninitialized variables. The address of the top of the stack is stored in
    the ESP register:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2c2c1b04-c690-41f9-972c-bdc59768bcbf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The stack is controlled by two common instructions: `PUSH` and `POP`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**PUSH** decreases the top-of-stack address by a `DWORD` size, for a 32-bit
    address space, then stores the value from its operand.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following as an example: `PUSH 1`'
  prefs: []
  type: TYPE_NORMAL
- en: If the top of the stack, stored in ESP, is at address `002FFFFCh`, then the
    ESP becomes `002FFFF8h` and stores `1` at the new ESP address.
  prefs: []
  type: TYPE_NORMAL
- en: '**POP** retrieves the value from the top of the stack (ESP) then stores it
    to the register or memory space indicated in the operand. Then ESP is increased
    by a `DWORD` size.'
  prefs: []
  type: TYPE_NORMAL
- en: Consider the following as an example: `POP EAX`
  prefs: []
  type: TYPE_NORMAL
- en: If the address of the top of the stack, stored in ESP, is at address `002FFFF8h`,
    and the stored `DWORD` value at the top of the stack is `0xDEADBEEF`, then `0xDEADBEEF`
    will be stored in `EAX`, while ESP becomes `002FFFFCh`.
  prefs: []
  type: TYPE_NORMAL
- en: '**PUSHA/PUSHAD** both push all the general purpose registers to the stack in
    this order (for 32-bit builds): `EAX`, `ECX`, `EDX`, `EBX`, `EBP`, `ESP`, `EBP`,
    `ESI`, and `EDI`. `PUSHA` is intended for 16-bit operands, while `PUSHAD` is for
    32-bit operands. However, both may be synonymous to each other, adapting to the
    current operand size.'
  prefs: []
  type: TYPE_NORMAL
- en: '**POPA/POPAD** both pop all the general purpose registers from the stack and
    retrieved in a reverse order as stored by `PUSHA`/`PUSHAD`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**PUSHF** pushes the `EFLAGS` to stack.'
  prefs: []
  type: TYPE_NORMAL
- en: '**POPF** pops the `EFLAGS` from stack.'
  prefs: []
  type: TYPE_NORMAL
- en: '**ENTER** is commonly used at the start of a subroutine. It is used to create
    a stack frame for the subroutine. Internally, `ENTER 8,0` may roughly be equivalent
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '`LEAVE`is used to reverse what the `ENTER` instruction did eventually destroying
    the stack frame created.'
  prefs: []
  type: TYPE_NORMAL
- en: Tools – builder and debugger
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we proceed with more instructions, it would be best to try actually programming
    with assembly language. The tools we will need are a text editor, the assembly
    code builder, and the debugger.
  prefs: []
  type: TYPE_NORMAL
- en: Popular assemblers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All programming languages need to be built to become an executable on the system
    platform that the program was built for. Unless you want to enter each opcode
    byte in a binary file, developers have made tools to convert that source code
    to an executable that contains code that the machine can understand. Let's take
    a look at some of the most popular assembly language builders today.
  prefs: []
  type: TYPE_NORMAL
- en: MASM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Also known as Microsoft Macro Assembler, MASM has been around for more than
    30 years. It is maintained by Microsoft and is part of the Visual Studio product.
    It was developed for compiling x86 source code to executable code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Compiling takes two steps: compiling the source into an object file, then linking
    all necessary modules required by the object file into a single executable.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/05a5158f-4a56-4937-b53b-d8679d4349f3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The MASM package comes along with a text editor that has the menu containing
    the compiler and linker to build the source as an executable. This comes very
    handy as there is no need to go to the command line to run the compiler and linker
    to build the executable. A simple "`Console Build All`" command on the following
    source generates an executable that can be run in the command terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7f6bf1c8-9526-49ca-8ba6-f9fa3530185f.png)'
  prefs: []
  type: TYPE_IMG
- en: MASM can be downloaded from [http://www.masm32.com/](http://www.masm32.com/).
  prefs: []
  type: TYPE_NORMAL
- en: NASM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**NASM** is the abbreviation of **Netwide Assembler**. NASM is very similar
    to MASM with slight differences between its syntax, directives, and variable declaration.
    A great thing about NASM is that sectioning of code and data is easily identified:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5b418ac9-d780-473b-839b-f2da606d8f7c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Both MASM and NASM also require compiling and linking to build the executable:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3e1eb06b-897f-465c-bb71-92cd4a60f41b.png)'
  prefs: []
  type: TYPE_IMG
- en: However, unlike MASM, the installer package does not have its own editor. NASM
    is very popular in the Linux community due to its development as opensource software.
    The package contains only the compiler for the object file; you'll have to download
    a GCC  compiler to generate the executable.
  prefs: []
  type: TYPE_NORMAL
- en: The official website for downloading NASM is at [https://www.nasm.us/](https://www.nasm.us/).
    For Windows, MinGW ([http://www.mingw.org/](http://www.mingw.org/)) can be used
    to generate the executable.
  prefs: []
  type: TYPE_NORMAL
- en: FASM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'FASM, or Flat Assembler, is similar MASM and NASM. Like MASM, it has its own
    source editor. Like NASM, the sections are easily identifiable and configured,
    and the software comes in flavors for both Windows and Linux:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bb02f798-7ebf-42d1-9582-61ae313a338d.png)'
  prefs: []
  type: TYPE_IMG
- en: FASM can be downloaded from [http://flatassembler.net/](http://flatassembler.net/).
  prefs: []
  type: TYPE_NORMAL
- en: In our assembly language programming, we will use FASM, since we can use its
    editor in both Windows and Linux.
  prefs: []
  type: TYPE_NORMAL
- en: x86 Debuggers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Debuggers are program developers' tools for tracing through their code.  These
    tools are used to validate that the program  follows the expected behavior.  With
    a debugger, we can trace our code line per line.  We get to see every instruction
    in action as it make changes to the registers and data stored in the memory. 
    In reversing, debuggers are used to analyze programs at its low-level. With what
    we learned about assembly language, the target compiled program, and a debugger,
    we are able to do reverse engineering.
  prefs: []
  type: TYPE_NORMAL
- en: Besides the tools introduced in this book,  there are a lot of tools available
    in the internet that may have more or less features.  The point is that reverse
    engineering rely on the tools and we need to keep ourselves updated with the latest
    tool. Feel free to download other tools that you want to explore and see which
    one makes your reversing feel more comfortable.
  prefs: []
  type: TYPE_NORMAL
- en: WinDbg
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Developed by Microsoft to perform debugging on Microsoft Windows, `WinDbg` is
    a powerful tool that can debug in user and kernel mode. It can load memory dumps
    and crash dumps caused by errors flagged by Windows itself. In kernel mode, it
    can be used to remotely debug a device driver or a Windows operating system. It
    can load symbol files linked to the program that aid the developer or analyst
    in identifying the proper library function format and other information.
  prefs: []
  type: TYPE_NORMAL
- en: '`WinDbg` has a graphical user interface, and by default, shows a command box
    where you can type in and enter commands. You can add a set of information windows
    and dock them. It can show the disassembly, registers and flags, the stack (using
    the memory dump window), and a memory dump of whichever address entered:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5dbd1ab2-e79e-4484-8ad7-e06a7c380859.png)'
  prefs: []
  type: TYPE_IMG
- en: '`Windbg` can be downloaded from [https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/.](https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/.)'
  prefs: []
  type: TYPE_NORMAL
- en: Ollydebug
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is the most popular debugger on the x86 32-bit Windows platform due to
    its lightweight package file size. Its default interface shows the important information
    needed by a reverse engineer: a disassembly view where tracing happens; registers
    and flags panes; and the stack and memory views.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e2ddfff3-b669-4358-ad27-c87246f0c788.png)'
  prefs: []
  type: TYPE_IMG
- en: OllyDebug can be downloaded from [http://www.ollydbg.de/](http://www.ollydbg.de/).
  prefs: []
  type: TYPE_NORMAL
- en: x64dbg
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This debugger is most recommended as the developers keep this up-to-date, working
    with the community. It also supports both 64- and 32-bit Windows platforms with
    a lot of useful plugins available. It has a similar interface as Ollydebug.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8ef58c36-fd12-42e1-bd98-7400c929b7e8.png)'
  prefs: []
  type: TYPE_IMG
- en: '`x64dbg` can be downloaded from [https://x64dbg.com/](https://x64dbg.com/).'
  prefs: []
  type: TYPE_NORMAL
- en: Hello World
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are going to use `FASM` for building our first assembly language program.
    And we will debug the executable using `x64dbg`.
  prefs: []
  type: TYPE_NORMAL
- en: Installation of FASM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using our Windows setup, download FASM from [http://flatassembler.net/](http://flatassembler.net/),
    [then extract FASM into a folder of your choice:](http://flatassembler.net/)
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/874ec904-69c3-461e-bc2b-6fb260e5f8d8.png)'
  prefs: []
  type: TYPE_IMG
- en: Run `FASMW.EXE` to bring up the `FASM` GUI.
  prefs: []
  type: TYPE_NORMAL
- en: It works!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In your text editor, write down the following code, or you can simply do a Git
    clone of the data at [https://github.com/PacktPublishing/Mastering-Reverse-Engineering/blob/master/ch3/fasmhello.asm](https://github.com/PacktPublishing/Mastering-Reverse-Engineering/blob/master/ch3/fasmhello.asm).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Save it by clicking on File->Save as..., then click on Run->Compile:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fd0bc3e2-c137-493b-923b-2fe735592745.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The executable file will be located where the source was saved:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/033636a3-403a-4022-a97f-719688e1af09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If "`Hello World!`" did not show up, one thing to note is that this is a console
    program. You''ll have to open up a command terminal and run the executable from
    there:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/789c36b3-17b6-4b7c-842e-f46d71f4f63d.png)'
  prefs: []
  type: TYPE_IMG
- en: Dealing with common errors when building
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Write Failed Error** – This means that the builder or compiler is not able
    to write to the output file. It is possible that the executable file it was going
    to build to is still running. Try looking for the program that was run previously
    and terminate it. You can also terminate it from the process list or Task Manager.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Unexpected Characters** – Check for the syntax at the indicated line. Sometimes
    the included files also need to be updated because of changing syntax on recent
    versions of the builder.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Invalid argument** – Check for the syntax at the indicated line. There might
    be missing parameters of a definition or a declaration.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Illegal instruction** – Check for the syntax at the indicated line. If you
    are sure that the instruction is valid, it might be that the builder version doesn''t
    match where the instruction was valid. While updating the builder to the most
    recent version, also update the source to comply with the recent version.'
  prefs: []
  type: TYPE_NORMAL
- en: Dissecting the program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have built our program and got it working, let's discuss what the
    program contains and is intended for.
  prefs: []
  type: TYPE_NORMAL
- en: 'A program is mainly structured with a code section and a data section. The
    code section, as its name states, is where program codes are placed. On the other
    hand, the data section is where the data, such as text strings, used by the program
    code is located. There are requirements before a program can be compiled. These
    requirements define how the program will be built. For example, we can tell the
    compiler to build this program as a Windows executable, instead of a Linux executable.
    We can also tell the compiler which line in the code should the program start
    running. An example of a program structure is given here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9c1e0b16-c1e2-4849-b2c3-5bbb2b908af0.png)'
  prefs: []
  type: TYPE_IMG
- en: We can also define the external library functions that the program will be using.
    This list is described under a separate sections called the Import section. There
    are various sections that can be supported by a compiler. An example of these
    extended sections include the resource section, which contains data such as icons
    and images.
  prefs: []
  type: TYPE_NORMAL
- en: With the a basic picture of a what a program is structured, let see how our
    program was written. The first line, `format PE CONSOLE`, indicates that the program
    will be compiled as a Windows PE executable file and built to run on the console,
    better known in Windows as Command Prompt.
  prefs: []
  type: TYPE_NORMAL
- en: The next line, `entry start`, means that the program will start running code
    located at the `start` label. The name of the label can be changed as desired
    by the programmer. The next line, `include '%include%\win32a.inc'`, will add declarations
    from the FASM library file `win32a.inc`. The declared functions expected are for
    calling the `printf` and `ExitProcess` API functions discussed in the `idata`
    section.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three sections built in this program: the `data`, `code`, and `idata`
    sections. The section names here are labeled as `.data`, `.code`, and `.idata`.
    The permissions for each section are also indicated as either `readable`, `writeable`,
    and `executable`. The `data` section is where integers and text strings are placed
    and listed using the define byte (`db`) instruction. The `code` section is where
    lines of instruction code are executed. The `idata` section is where imported
    API functions are declared.'
  prefs: []
  type: TYPE_NORMAL
- en: 'On the next line, we see that the data section is defined as a `writeable`
    section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The program''s `.data` section contains two constant variables, `message` and `msgformat`.
    Both text strings are `ASCIIZ` (`ASCII-Zero`) strings, which means that they are
    terminated with a zero (0) byte. These variables are defined with the `db` instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The next line defines the code section. It is defined with read and execute
    permissions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: It is in the `.code` section where the `start:` label is and where our code
    is. Label names are prefixed with a colon character.
  prefs: []
  type: TYPE_NORMAL
- en: 'In C programming, `printf` is a function commonly used to print out messages
    to the console using the C syntax, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`int printf ( const char * format, ... );`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first parameter is the message containing format specifiers. The second
    parameter contains the actual data that fills up the format specifiers. In assembly
    language perspective, the `printf` function is an API function that is in the
    `msvcrt` library. An API function is set up by placing the arguments in the memory
    stack space before calling a function. If your program is built in C, a function
    that requires 3 parameters (for example, `myfunction(arg1, arg2, arg3)`) will
    have the following as an equivalent in assembly language:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: For a 32-bit address space, the `push` instruction is used to write a `DWORD`
    (32 bits) of data on the top of the stack. The address of the top of the stack
    is stored in the ESP register. When a `push` instruction is executed, the ESP
    decreases by 4\. If the argument is a text string or a data buffer, the address
    is push-ed to the stack. If the argument is a number value, the value is directly
    push-ed to the stack.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following the same API calling structure, with two arguments, our program called
    `printf` in this manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: In the data section, the addresses, labeled as `message` and `msgformat`, are
    pushed to the stack as a setup before calling the `printf` function. Addresses
    are usually placed in square brackets, `[]`. As discussed previously, the value
    at the address is used instead. The `printf` is actually a label that is the local
    address in the program declared in the `.idata` section. `[printf]` then means
    that we are using the address of the `printf` API function from the `msvcrt` library.
    Thus, `call [printf]` will execute the `printf` function from the `msvcrt` library.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same goes for `ExitProcess`. `ExitProcess` is a `kernel32` function that
    terminates the running process. It requires a single parameter, which is the exit
    code. An exit code of 0 means that the program will terminate without any errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: In C syntax, this code is equivalent to `ExitProcess(0)`, which terminates the
    program with a success result defined with zero.
  prefs: []
  type: TYPE_NORMAL
- en: 'The program''s `.idata` section contains external functions and is set with
    read and write permissions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following code snippet, there are two portions. The first part indicates
    which library files the functions are located in. The `library` command is used
    to set the libraries required, and uses the syntax `library <library name>, <library
    file>`. A backslash, `\`, is placed to indicate that the next line is a continuation
    of the current line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Once the libraries are declared, specific API functions are indicated using
    the `import` command. The syntax is `import <library name>, <function name>, <function
    name in library file>`. Two external API functions are imported here, *kernel32*'s
    *ExitProcess* and *msvcrt*'s *printf:*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: A annotated version of the program can be found at [https://github.com/PacktPublishing/Mastering-Reverse-Engineering/blob/master/ch3/FASM%20commented.txt](https://github.com/PacktPublishing/Mastering-Reverse-Engineering/blob/master/ch3/FASM%20commented.txt)
  prefs: []
  type: TYPE_NORMAL
- en: 'The library of API functions can be found in the MSDN library ([https://msdn.microsoft.com/en-us/library](https://msdn.microsoft.com/en-us/library)),
    which also has an offline version packaged in the Visual Studio installer. It
    contains detailed information about what the API function is for and how to use
    it. The online version looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bb928665-6664-4b30-83ca-ee18a0962334.png)'
  prefs: []
  type: TYPE_IMG
- en: After Hello
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We encountered an external call to the `printf` and `ExitProcess` API functions.
    These specific functions were developed for Windows as a means of communication
    between the user-mode and the kernel-mode. Generally, for most operating systems,
    the kernel is responsible for literally displaying the output on the monitor,
    writing files to the disk, reading keyboard strokes, transmitting data to USB
    ports, sending data to the printer, transmitting data to the network wire, and
    so forth. In essence, everything that has something to do with hardware has to
    go through the kernel. Our program, however, is in the user-mode, and we use the
    APIs to tell the kernel to do stuff for us.
  prefs: []
  type: TYPE_NORMAL
- en: Calling APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Calling APIs within our program just requires us to define the library file
    where the API function is, and the API name itself. As we did with our Hello World
    program, we import the API function by setting it up in the import section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'And then we call the APIs with a CALL instruction, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Common Windows API libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**KERNEL32** contains base functions of Windows that are responsible for file
    I/O operations and memory management, including processes and threads management.
    Some functions are helpers for calling more native APIs in the NTDLL library.'
  prefs: []
  type: TYPE_NORMAL
- en: '**USER32** contains functions that deal with the display and graphical interface,
    such as program windows, menu, and icons. It also contains functions that controls
    window messages.'
  prefs: []
  type: TYPE_NORMAL
- en: '**ADVAPI32** contains functions that has to do with the Windows registry.'
  prefs: []
  type: TYPE_NORMAL
- en: '**MSVCRT** contains standard C library functions from Microsoft Visual C++
    runtime, such as printf, scanf, malloc, strlen, fopen, and getch.'
  prefs: []
  type: TYPE_NORMAL
- en: '**WS2_32**, **WININET**, **URLMON**, and **NETAPI32** are libraries that contain
    functions that have to do with networking and internet communication.'
  prefs: []
  type: TYPE_NORMAL
- en: Short list of common API functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The API functions can be categorized based on their purposes. A complete list
    can be found at the MSDN Library, but the most common ones are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Purpose** | **API functions** |'
  prefs: []
  type: TYPE_TB
- en: '| **Console output** | `KERNEL32!GetStdHandle, MSVCRT!printf` |'
  prefs: []
  type: TYPE_TB
- en: '| **File handling** | `KERNEL32!ReadFile, KERNEL32!WriteFile, KERNEL32!CreateFile`
    |'
  prefs: []
  type: TYPE_TB
- en: '| **Memory management** | `KERNEL32!VirtualAlloc, KERNEL32!VirtualProtect,
    MSVCRT!malloc` |'
  prefs: []
  type: TYPE_TB
- en: '| **Process and threads** | `KERNEL32!ExitProcess, KERNEL32!CreateProcess, KERNEL32!CreateThread,
    SHELL32!ShellExecute` |'
  prefs: []
  type: TYPE_TB
- en: '| **Window management** | `USER32!MessageBoxA, USER32!CreateWindowExA, ``USER32!RegisterWindowMessageW`
    |'
  prefs: []
  type: TYPE_TB
- en: '| **Strings** | `MSVCRT!strlen, MSVCRT!printf` |'
  prefs: []
  type: TYPE_TB
- en: '| **Network communication** | `WININET!InternetAttemptConnect, WS2_32!socket, WS2_32!connect,
    URLMON!URLDownloadToFile` |'
  prefs: []
  type: TYPE_TB
- en: '| **Cryptography** | `CryptDecrypt, CryptEncrypt` |'
  prefs: []
  type: TYPE_TB
- en: '| **Registry** | `RegDeleteKey, RegCreateKey, RegQueryValueExW, RegSetValueExW`
    |'
  prefs: []
  type: TYPE_TB
- en: Debugging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At certain points, our program may produce unpredictable errors or invalid output.
    In that case, we need to trace what went wrong, by debugging each line of code.
    But before that, there are some general debug commands we need to know.
  prefs: []
  type: TYPE_NORMAL
- en: 'Single-stepping a program means debugging per line of code. There are two modes
    to single step: step into and step over. During debugging, when the line being
    debugged is a CALL instruction, single-step debugging continues in the subroutine
    when a **step into** mode is used. The **step over** mode, however doesn''t enter
    the subroutine, but rather lets the subroutine finish up running and the single
    step continues on the line after the CALL instruction. See the following comparison:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Step into | Step over |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: A **run** or **continue** makes the debugger execute instructions continuously
    until the program terminates, encounters an error, or until it encounters a manually
    set breakpoint.
  prefs: []
  type: TYPE_NORMAL
- en: 'Placing a **breakpoint** is a way to enable to the debugger to interrupt a
    code that was set to freely run. For example, if I placed a breakpoint at address
    0040200A in the following code, and let the debugger automatically run every instruction
    starting from 00402000, the debugger stops at address 0040200A and leaves the
    user to continue doing single steps or run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Let's debug our Hello World program.
  prefs: []
  type: TYPE_NORMAL
- en: Download x64dbg from [https://x64dbg.com/](https://x64dbg.com/).
  prefs: []
  type: TYPE_NORMAL
- en: 'It is a ZIP archive that you will have to extract. And once extracted, open
    the x96dbg.exe from the release folder. This will show the launcher dialog where
    you get to select x32dbg (for 32-bit debugging) and x64dbg (for 64-bit debugging)
    as your debugger:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cda8c465-709d-42de-9e08-e09bfaab749f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The Hello World program we developed is a 32-bit program, thus, select x32dbg.
    Then click on File->Open, then browse and open the helloworld.exe program. Opening
    it will show you where the EIP is at in the disassembly window as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/62671264-1b8c-49d4-8d23-6afd32415c6f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'At the bottom of the window, it says: "System breakpoint reached!" EIP is at
    a high-memory region address and the window title also indicates "Module: ntdll.dll
    - Thread: Main Thread." All of this suggests that we are not yet in the helloworld
    program, but rather still in the ntdll.dll code that loads up the helloworld program
    to memory, initializes it and then starts to run it. If you go to Options->Preferences,
    and in the Events table of the Settings window, by default, the System Breakpoint*
    is checked. This causes the debugger to pause in the ntdll.dll before we even
    reach our helloworld code. Uncheck the System Breakpoint*, click on Save, then
    exit the debugger, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5cd8c14a-4bd3-4524-a7d2-d9b71e2973bc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that we have removed the System Breakpoint, repeat loading the helloworld
    program. The EIP should now be in the helloworld code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/24d781b2-f654-431d-acf8-d24936f65f21.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on the Debug menu. You should see that there are keyboard keys assigned
    to Step into, Step over, Run and more debugging options:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1a0c8fcf-67f7-461a-8227-ca1a1e49d4b8.png)'
  prefs: []
  type: TYPE_IMG
- en: The stack frame window is located at the lower right pane. Take note of the
    information there, then press `*F7*` or *F8* to do a single step. The `PUSH helloworld.401000`
    instruction just placed the address of "`Hello World`" text string at the top
    of the stack. At the upper right pane where the registers and flags are, all changes
    have their text colored red. With the stack moving its address, ESP should change.
    And since we are now on the next line of instruction code, EIP should have also
    changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Do another single step to push the address of "`%s`" to the stack. You should
    now be in address `0040200A`. At this point, doing a step over will execute the
    `printf` function and be at address 00402010\. Out of curiosity, let''s do a step
    into instead. This leads us in the `msvcrt` library, where the `printf` function
    is:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/97fe9783-f71b-4277-9ba7-3914935d1475.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To get back to our `helloworld` program, we can do a "`Run to user code`,"
    which has a mapped key of *Alt *+ *F9* or an "`Execute till return`" *Ctrl *+
    *F9*. The user code pertains to our hello world program. Doing a "`Run to user
    code`" will bring us to address `00402010`, which is the instruction after the
    `printf` call. Doing an "`Execute till return`" will bring us to the address where
    the `RET` instruction is. Let''s do an "`Execute till return`" instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a6190ea8-0505-49f7-a5a0-bab9faef4bea.png)'
  prefs: []
  type: TYPE_IMG
- en: Now take a look at the stack. As discussed previously about the `CALL-RET` instructions,
    a `CALL` stores the address of the next instruction at the top of the stack. At
    this point, the address stored at the top of the stack is `00402010`. Make a single
    step and we should be back in our `hello world` program.
  prefs: []
  type: TYPE_NORMAL
- en: Just continue doing step overs. The last two instructions should terminate the
    program and the debugging will stop.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Assembly language is a low-level language that uses instructions to communicate directly with
    the computer system. Logic used in computers is based on an on-and-off concept,
    from which binary 1s and 0s were derived. We have learned how to read and write
    binary from various number bases, and how to do arithmetic and bitwise computations.
  prefs: []
  type: TYPE_NORMAL
- en: We introduced popular assemblers and debuggers that we can use to build and
    validate our program. Then, we used FASM to code and build our Win32 low-level
    hello world program that uses APIs to communicate with the kernel. We validated
    our built executable program using `x64dbg` to debug it. Debugging our hello world
    program is a good start for us to get introduced to the world of reverse engineering.
  prefs: []
  type: TYPE_NORMAL
- en: Practice makes perfect. We have a listed a few suggested programs that can be
    developed using assembly language.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing the lowest level of a code is a good start for our reverse engineering
    journey. As you finish up this book, assembly language will feel somewhat like
    a walk in the park.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Intel's documentation contains the complete list of x86 instructions and describes
    the syntax and use of each instruction in assembly language. You can get these
    documents from [http://www.intel.com/products/processor/manuals/](http://www.intel.com/products/processor/manuals/).
  prefs: []
  type: TYPE_NORMAL
