- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Image-Based Deployments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are going to truly diverge from the existing norms of package-based
    installs (and updates), which have been the mainstay of Linux for over thirty
    years. Let’s talk about **immutable image-based systems**. Immutable images have
    only been around for a few years. Just recently, they have captured the limelight.
    Some will argue (myself included) that immutable operating systems for appliances
    are the future of all embedded systems. The very thought of a system that is immutable
    and unchanging just gives us the impression of something even more secure than
    the rest. Or does it? If you too assume that it is more secure, you would be correct.
    More secure – yes – but not perfect...this chapter will give you a great overview
    of a topic that in my professional opinion deserves its own book due to its complexities
    and rapidly evolving future. In this chapter, we will review and also go through
    some focused exercises geared towards providing you with a greater understanding
    of the levels of security provided by immutable operating systems. We will take
    a look at some of the tools available and how to leverage them into building,
    deploying, and, later on, supporting your appliances once your customers have
    them in hand.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you might just convince yourself that this new method
    of deploying Linux was tailor-made for us in the embedded Linux systems community.
    Conversely, you may also decide after digging deeper into the technology that
    perhaps it’s not for you (yet).
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will have the following main headings:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing image-based Linux deployments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: bootc and bootable container images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Special tooling and support infrastructure differences
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Limitations of image-based deployments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating and rolling back changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Practical exercises – step-by-step walkthrough of how to deploy image-based
    systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, let’s move on and dive deeper.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To successfully navigate through the exercises in this chapter, you will need
    two bare metal or virtual machines that you can modify or reinstall the operating
    system upon. Root access, internet access, and DHCP IP addressing are mandatory.
    You will also need the ability to download ISO images and have a 16 GB (or greater)
    USB thumb drive. Finally, you will need a free Red Hat Developer account and access
    to your own **Quay** registry (also free). The requirements are greater for these
    exercises as the outcomes are more significant. I am hopeful you’ll even have
    fun along the way, which in my opinion is also a requirement.
  prefs: []
  type: TYPE_NORMAL
- en: For these exercises. I am using CentOS Streams 9 as my build machine’s operating
    system, and we’ll be creating a CentOS Streams 9 bootable container image. Let’s
    now move onward to the stars of the show, image-based Linux deployments.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing image-based Linux deployments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This subject is something near and dear to my heart, as I am an embedded systems
    specialist and have dedicated the past decade to this endeavor. It’s truly my
    opinion that this set of technologies was virtually tailor made for our embedded
    Linux systems appliances and the ecosystem of people who build and support them.
    It would be justifiable for you to question why I, along with many other leaders
    in the industry, see this as the future. I will give you the short answer here,
    but we will review it in depth as the chapter progresses. Simplified lifecycle
    management is the single greatest reason to adopt this new technology for your
    products.
  prefs: []
  type: TYPE_NORMAL
- en: In the upcoming sections, I will walk you through two of these methodologies,
    their features, their limitations, and their tooling, along with some exercises
    to make it all real for you.
  prefs: []
  type: TYPE_NORMAL
- en: rpm-ostree and atomic images
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first type of image-based installation method that we’ll review is **rpm-ostree**.
    This type of deployment is sometimes also called *atomic* because of its immutability.
    Some vendors have their own marketing name for it. Red Hat® calls it RHEL for
    Edge™. Whatever they call it, I call it a game-changer. Many other distributions,
    in recent years, have added rpm-ostree deployment options. Maybe you’d like a
    few more examples? Fedora® Silverblue, NixOS, openSUSE® MicroOS, Nitrux, Vanilla
    OS, Talos Linux™, and BlendOS are some of the many purely atomic distributions.
  prefs: []
  type: TYPE_NORMAL
- en: Any use case for Linux you previously had can be addressed with greater security
    and stability with an image-based deployment. Where you are deploying is irrelevant;
    these systems run on bare metal, virtual machines, or cloud instances with ease.
  prefs: []
  type: TYPE_NORMAL
- en: The `/etc` and `/var`. Because of this image format, the old-school methodology
    of partitioning is essentially moot. …Or should I say immutable?
  prefs: []
  type: TYPE_NORMAL
- en: OSTree at its core replicates read-only trees via HTTP. It also has mechanisms
    for application layering and installation either in `/var` or `/home` (which more
    details about their actual filesystem layout will be covered next). This mechanism
    is like how rpm repositories are hosted; however, they are different in the manner
    of images as reference data (versioning, tags, etc.). For your solution, you will
    have to create the infrastructure to support your deployed appliances.
  prefs: []
  type: TYPE_NORMAL
- en: To give you a rough idea of how drastic a change in what might have been its
    own writable partition in the standard deployment model, here’s a look at how
    they are handled in this new model. With `/var` being RW, there are several key
    directory/filesystem mappings that are different from what you are used to in
    Linux. Pay close attention.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how filesystems are mapped and their permissions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/home` links to `/var/home` as RW'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/srv` links to `/var/srv` as RW'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/root` links to `/var/roothome` as RW'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/opt` links to `/var/opt` as RW'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/mnt` links to `/var/mnt` as RW'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/sysroot` is RO'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/boot` and `/boot/efi` are RW'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '`rpm-ostree` is the mechanism that enables `ostree` image base. Installing
    an RPM package with `rpm-ostree` forces the creation of a new image that is merely
    an update of the base image.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To oversimplify, I will try to relate this methodology as I see it: a series
    of commits that build upon each other that can be easily rolled back delivered
    as an immutable image-based appliance-like deployment. I’ll say it again. I feel
    like sometimes this was tailor-made for embedded Linux systems and custom appliance
    solutions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, how can we take advantage of `rpm-ostree` and layer more awesomeness on
    top? Let’s take a quick look at some of the ways as we already know that the base
    image itself is immutable. First, I give you this disclaimer: anything you layer
    on top might not be maintained as part of that image and could induce the risk
    of being forgotten as updates to that system progress.'
  prefs: []
  type: TYPE_NORMAL
- en: That said, we can layer things on top of an rpm-ostree system (outside the image
    itself). This can be done through fully self-contained applications deployed via
    flatpacks or as a running container image deployed outside the image. In this
    use case, the base image is simply the immutable platform for delivering a dynamic
    application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other method is to install RPM packages on top of the image. I suppose
    someone has a use case where this makes sense, but I argue that it should just
    have been made part of the image, and the system should be updated with the latest
    image containing the additional RPM packages. Now that we understand rpm-ostree
    and its key features, here are examples of distributions that can be deployed
    *optionally* as rpm-ostree. Please note that this is a non-exhaustive list:'
  prefs: []
  type: TYPE_NORMAL
- en: Red Hat® Enterprise Linux®
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fedora® (many variants; the most common is Silverblue)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vanilla OS (an Ubuntu®/Debian® variant)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debian® ostree
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: openSUSE® (Slowroll)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SUSE Linux Enterprise Server™
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CoreOS®
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rocky Linux®
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AlmaLinux®
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Oracle Enterprise Linux™
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CentOS® Stream
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, please know that you have many options for testing the waters with rpm-ostree,
    for more details I invite you to check out the libostree documentation online:
    [https://ostreedev.github.io/ostree/](https://ostreedev.github.io/ostree/).'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s move on to our next subject and that’s bootable containers.
  prefs: []
  type: TYPE_NORMAL
- en: bootc and bootable container images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I have been involved deeply with product teams in the scoping, testing, and
    documentation of this new leading-edge technology since before I started writing
    this book. These efforts introduced me to some really amazing engineers who are
    adept at thinking outside the box.
  prefs: []
  type: TYPE_NORMAL
- en: What is bootc? A simplified way of looking at bootc would be to define it as
    a tool for layering a Linux kernel into a container image so the container image
    can boot itself without external operating systems hosting it.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are interested in contributing to this global effort to transform technology
    (or just learning more), here’s the bootc GitHub repository: [https://github.com/containers/bootc](https://github.com/containers/bootc).
    There, you can find extensive documentation that is readily maintained.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s be clear, bootc is bleeding-edge technology. Red Hat® (the organization
    leading the charge in this new technology) considers this to have *Technology
    Preview* status and they will not consider it fully supportable until the tooling
    and support infrastructure are present. Basically, the technology will not be
    considered fully supportable, or as Red Hat calls it, **Generally Available**
    (**GA**), and production-workload-ready until the advent of RHEL 10 and RHEL 9.6,
    which are both released in May of 2025.
  prefs: []
  type: TYPE_NORMAL
- en: This doesn’t mean you should be waiting around. I highly recommend doing an
    exhaustive level of testing and due diligence to see if this deployment method
    can add value to your product now and in the future.
  prefs: []
  type: TYPE_NORMAL
- en: What exactly is bootc? bootc is an open source project that leverages an **Open
    Container Initiative** (**OCI**) standard-based container image to create a full
    operating system image. It leverages the same layering techniques that existing
    container infrastructures use today for their creation and also for updating themselves.
    It leverages the functionality of other projects, such as rpm-ostree, to create
    and update those operating system images.
  prefs: []
  type: TYPE_NORMAL
- en: What makes bootc different from rpm-ostree? Both are image-based deployment
    methods. Both have levels of immutability. What sets them apart is how they are
    built and how they are updated. The single greatest defining point is bootc’s
    unique ability to use a container as the basis for an immutable image.
  prefs: []
  type: TYPE_NORMAL
- en: Where the bootc methodology absolutely shines is that there’s a vast ecosystem
    of developers and tools for building containers already. If you can build a container,
    you can build a whole system now. That whole build chain is now transformational,
    and for most companies, it will require little tooling to adapt to this new methodology
    if they’re already using containerized apps today.
  prefs: []
  type: TYPE_NORMAL
- en: But hold on…in corporate America, and elsewhere globally, not every containerized
    application needs to be converted to an image-based appliance. The true transformations
    are, for us, the embedded Linux system community. With this technology, we can
    design, create, build, and automate the lifecycles of the products that drive
    our company’s success.
  prefs: []
  type: TYPE_NORMAL
- en: Many engineers are currently working feverishly to deliver new tools to support
    this type of deployment method. By the time RHEL 9.5 ships, the community should
    have all new functionality available within what is considered the premier tool
    for building systems images and installers from the RHEL ecosystem and that tool
    is **Image Builder**. Image Builder has been around since RHEL 8.3 days (quite
    some time ago), but it has evolved and keeps getting better month by month.
  prefs: []
  type: TYPE_NORMAL
- en: 'For those of us building images in Fedora and CentOS Stream, we can leverage
    new functionality today at the risk of being on the bleeding edge without the
    support and obvious stability of the enterprise distributions. I highly recommend
    checking out the ongoing development of functionality for Image Builder in this
    GitHub repository: [https://github.com/osbuild/bootc-image-builder](https://github.com/osbuild/bootc-image-builder).'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve introduced rpm-ostree and bootc images, let’s continue our journey
    and see how they differ.
  prefs: []
  type: TYPE_NORMAL
- en: Special tooling and support infrastructure differences
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is where we can easily set one methodology against the other. Both methods
    work eloquently; however, creating, maintaining, and supporting appliances built
    from rpm-ostree alone is more difficult, and their tooling is more intensively
    hands-on.
  prefs: []
  type: TYPE_NORMAL
- en: In the next few sections, I will primarily focus on open source tools that are
    the most relevant for either methodology. Let’s start this investigation by looking
    at tooling that can help you deliver an rpm-ostree solution.
  prefs: []
  type: TYPE_NORMAL
- en: rpm-ostree open source tooling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Today, there’s a vast set of tools available within the open source community
    for your teams to leverage, regardless of the operating system you have selected.
    That said, each distribution may have some slight alterations or functionality
    differences that tailor the tools to their specific distribution’s base.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some great examples of tools for building or maintaining functionality in an
    rpm-ostree image deployment that are available across distributions are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Composer-cli:** A command-line tool for defining the complex contents of
    a Linux image and a way of rendering the image into multiple formats'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Osbuild**: A command-line tool for building Linux images'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Composer** (also known as **Image Builder** in some distributions): A graphical,
    web-based tool for defining, building, and updating a Linux image'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cockpit-composer**: A plugin for the web console on a Linux machine that
    enables a user to use Composer within the cockpit/web console web UI'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Toolbox:** An interactive command-line tool that assists in the troubleshooting
    of an operating system'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s move on to what tools we can leverage for other methods of image-based
    deployments.
  prefs: []
  type: TYPE_NORMAL
- en: bootc bootable container image tooling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is where things get a little interesting, in my opinion. bootc image-based
    systems don’t exactly require a plethora of complex tools to be built and supported.
    This concept we will dive into deeply in our hands-on exercises within this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Please allow me to elaborate. As we will see shortly, all you really need on
    your build machine is a text editor and access to a registry in order to build
    and update your appliances. We’ll be leveraging some container tools as well during
    the build.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example list of the tools that you can leverage to create and support
    the lifecycle of a bootc image-based system:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Editors (vi, emacs, nano, etc.): Simple text editing programs that are console-based
    or graphical, yet not as feature-rich as an IDE suite.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Podman: A container management tool used for building, running, and managing
    containers on top of Linux'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'IDE’s (Podman-Desktop, Eclipse, Visual Studio): Various graphical comprehensive
    development tools'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Image Builder: A graphical, web-based tool for defining, building, and updating
    a Linux image.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Cockpit-composer: A plugin for the web console on a Linux machine that enables
    a user to use Composer within the cockpit/web console web UI.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Console.redhat.com: A comprehensive service hosted by Red Hat®, that can assist
    in the building, maintaining, and introspection of systems'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Registries: A registry is crucial for hosting container images and providing
    a central location to distribute updates, for example, Quay™, Amazon Elastic Container
    Registry™ (ECR), Harbor, Azure Container Registry (ACR), GitHub Container Registry™,
    Google Container Registry™ (GCR), JFrog Container Registry™.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s move onto a more serious topic, the limitations of images-based deployments
    today.
  prefs: []
  type: TYPE_NORMAL
- en: Limitations of image-based deployments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While image-based deployments are a paradigm shift in how we can create and
    maintain solutions, they do have idiosyncrasies that standard package-based deployments
    do not have. For image-based systems, updates happen at the speed of a reboot.
    Package-based systems’ update operations can take hours and require multiple reboots,
    all while hoping no dependencies are broken and everything works in the end.
  prefs: []
  type: TYPE_NORMAL
- en: One significant perceived limitation is that filesystems are defined as non-writable.
    While many see the broader concept of immutability as a feature, if you are trying
    to install a third-party solution into your image and said solution expects to
    be installed in a very specific location (filesystem) that is readable and writable,
    but the actual location is read-only, issues are instantaneous.
  prefs: []
  type: TYPE_NORMAL
- en: This is a perceived limitation, not an actual one. With some creative usage
    of symbolic links, this most likely can easily be circumvented.
  prefs: []
  type: TYPE_NORMAL
- en: For those not involved in the ecosystem, these deployments can sometimes be
    miscategorized or perceived as inflexible, or as having limited ability to customize
    or tailor the solution easily, and often the necessary software may need to be
    layered onto them into non-standard filesystem locations so that those applications
    can function in read/write mode. Some of that is a myth, but not all of it. Let’s
    go deeper.
  prefs: []
  type: TYPE_NORMAL
- en: rpm-ostree image limitations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Alright, rpm-ostree is a great solution. It really is. I have to give credit
    where it’s due. I love it. That said, I have to address the perception that it
    can be inflexible. I propose the statement that in all actuality it’s meant to
    be just that. It is a very secure, immutable image-based deployment. The very
    tooling itself helps to keep rpm-ostree a very prescriptive type of deployment
    methodology. rpm-ostree was basically designed to be a secure platform that can
    easily host containerized apps or virtual machines while retaining a very minimal
    footprint.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are some limitations and frustrations that I must bring to light for
    you. First, kernel customizations are a bit of a challenge as the tooling does
    not help you in that endeavor (yet). I would say that if you have some customizations
    for anything in the end-state that you desire, your team should create custom
    RPM packages for them to be implemented. This also requires that you have a deep
    understanding of the exact hardware that you plan to leverage as your appliances’
    baseline. Managing operating-system-level user accounts can be a significant challenge
    because any changes, layered on such as passwords or group affiliations, that
    are added on after the deployment can easily be lost as they run the risk of being
    overwritten by the next image update deployment. In [*Chapter 10*](B22104_10.xhtml#_idTextAnchor305),
    we will cover this in more depth; we’ll review the best practice of not having
    your end-users ever log into the operating system itself on your appliance. I
    can see how in a corporate environment, this can be seen as a massive issue, but
    in a secure appliance, I beg the question: is it an issue at all?'
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, the places where data is actually in a read/write capability does
    add additional work in the design and support process. Users’ data, application
    data, and so on – these are seen as some of the complexities of this method of
    deployment. Planning, testing, and creative usage of symbolic links to locations
    that are writable will be key concepts that shall help you overcome most of these
    perceived issues.
  prefs: []
  type: TYPE_NORMAL
- en: I often argue that these facets mentioned are truly not limitations but simply
    design considerations because if you choose to deploy via rpm-ostree, you are
    embarking on a different and complex journey with many security rewards. Remember
    when I stated that security begins at the design table?
  prefs: []
  type: TYPE_NORMAL
- en: Let’s move on to how other systems could be perceived as limited.
  prefs: []
  type: TYPE_NORMAL
- en: bootc bootable container image limitations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here, I feel I must be a bit forgiving as the technology has not even reached
    version 1.0 status yet. bootc is still evolving, and its potential is astronomical.
    Additionally, I feel the need to reiterate that the advanced tools to support
    bootc are also still evolving as well. I might be biased, but I see a massively
    bright future for bootc images.
  prefs: []
  type: TYPE_NORMAL
- en: For an embedded appliance, having a stable and secure update methodology is
    a major design point. Today, bootc images are most easily supported by access
    to the online registry that created their existence. That’s all good and well
    if your solution will have access to the internet once the customer has implemented
    it in their own environment. Today, for an embedded Linux system appliance based
    upon bootc, being *online* is best.
  prefs: []
  type: TYPE_NORMAL
- en: One of the perceived limitations I see today isn’t exactly a limitation, but
    a serious design consideration that has to be addressed at the design table. Today,
    an offline bootc image-based deployment is possible. It’s just a little bit more
    complex. If your product is to be deployed in an **air-gapped environment** or
    non-networked environment, one must build into the appliance’s interface a way
    of ingesting its updates. This actually means a way of importing locally a new
    container image to use as the new baseline for its updates and rebuilding.
  prefs: []
  type: TYPE_NORMAL
- en: Again, as with rpm-ostree, I recommend obscuring the operating system from the
    end-user by only allowing them application-based access and keeping the operating
    system accounts limited. This will address the similar difficulty of maintaining
    operating systems’ user accounts through each update/image rerendering. Yes, managing
    or controlling operating-system-level users is a concern in bootc images too.
    I suspect that there shall be additional tooling developed for this as bootc evolves.
  prefs: []
  type: TYPE_NORMAL
- en: In comparison with rpm-ostree, bootc exceeds flexibility and customization.
    Kernel modifications are easier to achieve. Why? Containers are incredibly flexible
    themselves and they’re easier to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: My professional opinion is that this is a technology worth keeping a very close
    eye on because it can transform and simplify how you build appliances. I won’t
    say that it’s without pain points, but I do have the opinion that it has a very
    bright future. Let’s move on to how we can update or, in the worst cases, roll
    back.
  prefs: []
  type: TYPE_NORMAL
- en: Updating and rolling back changes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Package-based systems**, regardless of the package system (RPM, DNF, APT,
    Zypper, etc.) can have issues and artifacts when either moving to a newer version
    of their operating system or during an attempt to roll back installations that
    produce unintended consequences. If you have ever experienced this, you know exactly
    what I mean and I offer my condolences. For those of you who have been blessed
    or simply lucky enough to not have suffered a failed package update process, here’s
    the difference.'
  prefs: []
  type: TYPE_NORMAL
- en: Package-based systems are forced to do their dependency checks in real time
    when they process their updates. What this process amounts to is some packages
    may be added or deprecated that you might not even be aware of during the process.
    Not only can it be clunky and obtuse, but it consumes significant time. Hopefully,
    you tested this process for each release *ad nauseum* before presenting updates
    to your customers. Sometimes, oftentimes, multiple reboots are required. I feel
    for anyone enduring this. This is downtime. Hopefully, it just works the first
    time, because if it doesn’t, roll backs often require a recovery from a backup
    or a snapshot, Hahahahaha – if that even exists.
  prefs: []
  type: TYPE_NORMAL
- en: Image-based operating systems do not fall victim to those issues. Whether providing
    an incremental update or a completely new operating system, this delivery method
    allows for a rapid in-place upgrade while not impacting user or application data.
    How? These systems stage their new image and then simply reboot into it. Fast,
    clean, efficient. More importantly, since you and your team have tested these
    images, there’s little worrying about whether or not this new image has issues.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let’s assume the worst case: the image had some corruption in downloading.
    *No problem*. We can recover from the previous image with little to no effort.
    That’s some amazing upside, right?! Let’s move on to how these systems also can
    be upgraded in place without stress.'
  prefs: []
  type: TYPE_NORMAL
- en: Upgrade of operating system version in place
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is yet another area where all image-based deployments shine: upgrades
    in place.'
  prefs: []
  type: TYPE_NORMAL
- en: For atomic/rpm-ostree systems, all we need to do is create a new image based
    on a newer operating system and get that image staged in the appliance’s update
    repository. The appliance can download/stage the new image and will be upgraded
    to the new version of the operating system upon reboot.
  prefs: []
  type: TYPE_NORMAL
- en: For bootc-based systems, all we need to do is base our container image upon
    a newer operating system base image, rebuild the container, and upload the container
    to the registry. When the system checks for updates, it will pull the new container
    and rerender itself as an upgraded system.
  prefs: []
  type: TYPE_NORMAL
- en: Like I’ve said, it’s almost like these things are tailor-made for embedded Linux
    systems, right? Let’s move on to our hands-on exercises now and build one for
    ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: Practical exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is the time when we get to roll up our sleeves and bash the keyboard. If
    you follow the exercises in the order presented, at the end you will have a bootc
    image-based deployment ecosystem set up for yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Before we begin, I want to share with you some useful information. The tools
    for this type of infrastructure are evolving rapidly, and there is already more
    than one way to design, build, and deploy these images. I see this as an amazing
    opportunity for the Linux community. The method I am demonstrating here is simple
    and easy to either script or automate via something such as Ansible. Throughout
    the exercises, I will mention other ways or alternative tools that could enhance
    the developer experience and make things scale better.
  prefs: []
  type: TYPE_NORMAL
- en: As these exercises require precision in the configuration files that we will
    be creating together, I urge extreme caution should you choose to leverage a method
    of cutting and pasting to rapidly create the files. It is often too easy to copy
    over hidden ASCII characters (or formatting characters) that will render your
    working configuration files utterly useless and virtually impossible to debug
    because when you enter your text editor you may only see a blank space (if anything).
    I have added templated files that you can download and tailor yourself to your
    own lab’s environment. They can be found in the book’s GitHub repository ([https://github.com/PacktPublishing/The-Embedded-Linux-Security-Handbook/tree/main/Chapter09/exercises](https://github.com/PacktPublishing/The-Embedded-Linux-Security-Handbook/tree/main/Chapter09/exercises)),
    and they will also enlighten you about other options that we have not covered.
  prefs: []
  type: TYPE_NORMAL
- en: So, grab a formattable 16 GB USB thumb drive along with your favorite beverage
    (maybe several), and let’s get started.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 1 – preparing the environment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this first exercise, we will install the necessary tools along with some
    optional tools to create our minimal bootable container image build chain. Let’s
    do that using the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will set up a build environment, configure our registry, and create
    a container that will become the basis for not just our application but our operating
    system as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we’ll ensure that the web console has been enabled:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And here, we’ll start the socket for the web console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Confirm the web console is active:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Your output should resemble something like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Click on the link for **centos-bootc/centos-bootc**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make note of the URL as we’ll be using it soon. Consider bookmarking the page
    too.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.1 – Searching for CentOS Stream’s bootc base image](img/B22104_09_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.1 – Searching for CentOS Stream’s bootc base image
  prefs: []
  type: TYPE_NORMAL
- en: 'Back in your terminal, configure your non-root user account to be able to search
    the registry:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the requisite directories to store your container configuration so Podman
    will know where to seek for information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s change directories to the one we just created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: $ vi registries.conf
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: we will use these registries only
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: '[registries.search]'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: registries = ['registry.redhat.io','quay.io']
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we’ll go back to our home directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Let’s download the CentOS Stream 9 DVD ISO image to be used later in the process
    when we create our custom installer. Use your web browser to go to [https://centos.org/download/](https://centos.org/download/)
    and then click on the **x86_64** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.2 – CentOS Stream 9 download](img/B22104_09_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.2 – CentOS Stream 9 download
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s verify the file size and that it’s fully downloaded:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: $ podman login quay.io
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Login Succeeded!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: 'If you opted to generate the encrypted CLI password, the `login` command should
    look a little different. Replace `[your username]` with your own username and
    `[encrypted pass]` with your long, encrypted password here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$ podman login -u=''[your username]'' -p=''[encrypted` `pass]'' quay.io`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s pull down our base container image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output for this one is astronomically long (again). Here, we’ve truncated
    the output to show you generally what you can expect to see:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s check our local container inventory and verify that we have the intended
    CentOS Stream 9 bootc image in our inventory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Your output should resemble this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, in the Quay.io web interface, we will create our own public repository
    for our container image project. We’ll start on the **Repositories** tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: As a simple reminder, this is not exactly how one should ever do this in production.
    We’ll be using a public configuration for lab purposes only. Private, secure registries
    are the only way I would recommend doing this deployment method while being connected
    to the internet.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.3 – Quay – Repositories main page](img/B22104_09_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.3 – Quay – Repositories main page
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll click on the `bootc` and ensure that the **Public** radio button
    is selected along with the **(Empty repository)** radio button. Then, click the
    **Create Public Repository** button at the bottom.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.4 – Creating a new repository in Quay](img/B22104_09_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.4 – Creating a new repository in Quay
  prefs: []
  type: TYPE_NORMAL
- en: Make note of the URL for your repository; we’ll be using it soon. I also recommend
    bookmarking it in your web browser.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.5 – Your custom Quay repository](img/B22104_09_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.5 – Your custom Quay repository
  prefs: []
  type: TYPE_NORMAL
- en: Now, we have configured a baseline build environment on your system. By configuring
    how we leverage registries, installed container tools, and staged a container
    base image and a Linux installer ISO image, we have all we need to be successful.
    We additionally set up the web console on our build system, which will come in
    handy later. Let’s move on to building our initial container, which will be the
    basis for our future immutable image.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 2 – creating a container file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we’ll create a container file that we will build using the
    base image we downloaded in the previous exercise. The results of this exercise
    will give us a container that can run a simple **Linux Apache mySQL and PHP**
    (**LAMP**) stack. If you decide not to type this file, there will be a prebuilt
    one in the book’s GitHub repository for reference.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s build our container:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create the container file and name it `mycontainerfile.cf` :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set the contents of the file to look like the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s build our container image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Replace your own Quay.io username where `[my_account]` appears in the command
    line.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The output for this one is really long too. We’ve truncated the output somewhat
    to save space while still showing you what you can expect to see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Great! We now have our container image. Let’s do a quick test to see how well
    it works:'
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Replace your own Quay.io username where `[my_account]` appears in the command
    line.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Your output will resemble something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'With the container started, let’s open a browser window and verify that you
    can view the served content: http://[your_ip_address]:8080.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the page doesn’t load, double-check your firewall settings. If you are on
    the same system where you are running the container, your loopback address should
    also work.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.6 – Testing our container](img/B22104_09_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.6 – Testing our container
  prefs: []
  type: TYPE_NORMAL
- en: 'We should now also be able to shell into the container while it’s running:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When given the prompt feel free to test some commands but remember to exit:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You will then be returned to your regular shell prompt on your system.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Stop the running container since we know that the image works:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Our final step will be saving our functional container image to your own repository
    within Quay.io:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Log back into Quay.io via the command line if you are not logged in already.
  prefs: []
  type: TYPE_NORMAL
- en: Replace your own Quay.io username where `[my_account]` appears in the command
    line.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The output for this operation will be rather lengthy, so I’ll only show you
    the last few lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Excellent! You’ve created the basis of your future operating system via the
    base image and layered the applications stack, all by creating a working container
    image. In our next exercise, we’ll create an installer so we can deploy it as
    a bootable image.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 3 – creating an installer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will create a kickstart file and then take that kickstart
    along with a standard vendor-provided ISO install image and create our own custom
    ISO installer image for our amazing new system. This method of installation is
    great when you’re working in your lab or data center. Alternative methods will
    be necessary if you are deploying in a cloud services provider. For a great reference
    on how to build kickstart files, you can check out this guide: [https://docs.fedoraproject.org/en-US/fedora/f36/install-guide/appendixes/Kickstart_Syntax_Reference/](https://docs.fedoraproject.org/en-US/fedora/f36/install-guide/appendixes/Kickstart_Syntax_Reference/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s move on to the first step of this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this first step, you will create a kickstart file (`mykickstart.ks`). Within
    this file, you will substitute your own account username, where I state `[you]`,
    and you’ll also be setting basic configuration for the operating system’s filesystem
    layout and root password. Save and exit the file when you are done. Should you
    choose not to type the file in its entirety, there’s an example in the book’s
    GitHub repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Replace your own Quay.io username where `[my_account]` appears in the file’s
    contents.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: mykickstart.ks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: version 1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: anaconda installer type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: text
  prefs: []
  type: TYPE_NORMAL
- en: ensure that you connect your device to a Ethernet network with active DHCP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: network -–bootproto=dhcp -–device=link -–activate
  prefs: []
  type: TYPE_NORMAL
- en: basic partitioning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: clearpart –-all -–initlabel -–disklabel=gpt
  prefs: []
  type: TYPE_NORMAL
- en: reqpart --add-boot
  prefs: []
  type: TYPE_NORMAL
- en: part / --grow --fstype xfs
  prefs: []
  type: TYPE_NORMAL
- en: here's where we reference the container image
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: notice this kickstart has no packages section
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ostreecontainer –-url quay.io/ [quay_username]/bootc/lamp-bootc:latest –-no-signature-verification
  prefs: []
  type: TYPE_NORMAL
- en: additional settings for demonstration purposes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: in production use better settings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: the purpose of this exercise is not to tech you kickstart
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: but to show how to leverage it in custom installers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: firewall –-disabled
  prefs: []
  type: TYPE_NORMAL
- en: services –-enabled=sshd
  prefs: []
  type: TYPE_NORMAL
- en: add your own user account to the system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: user –-name=mstonge -–groups=wheel –-plaintext –-password=embedded
  prefs: []
  type: TYPE_NORMAL
- en: set root password
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: rootpw –-plaintext embedded
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Complete:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: $ sudo mkksiso –ks [absolute path to mykickstart.ks] \
  prefs: []
  type: TYPE_NORMAL
- en: '[absolute path to the CentOS Stream 9 ISO] \'
  prefs: []
  type: TYPE_NORMAL
- en: '[absolute path to the new ISO you want created]'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: ((( output truncated)))
  prefs: []
  type: TYPE_NORMAL
- en: 'xorriso : UPDATE : Writing:     830548s   74.1%   fifo   0%  buf  50%  137.6xD'
  prefs: []
  type: TYPE_NORMAL
- en: 'xorriso : UPDATE : Writing:     932628s   83.2%   fifo   0%  buf  50%  150.7xD'
  prefs: []
  type: TYPE_NORMAL
- en: 'xorriso : UPDATE : Writing:    1007616s   89.9%   fifo  29%  buf  50%  110.7xD'
  prefs: []
  type: TYPE_NORMAL
- en: 'xorriso : UPDATE : Writing:    1097728s   97.9%   fifo  10%  buf  50%  133.0xD'
  prefs: []
  type: TYPE_NORMAL
- en: 'ISO image produced: 1120832 sectors'
  prefs: []
  type: TYPE_NORMAL
- en: 'Written to medium : 1121008 sectors at LBA 48'
  prefs: []
  type: TYPE_NORMAL
- en: Writing to '/home/mstonge/mycustominstaller.iso' completed successfully.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: $ ip addr show
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: $ vi mycontainerfile2.cf
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: FROM quay.io/centos-bootc/centos-bootc:stream9
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: RUN dnf install -y httpd mariadb mariadb-server php-fpm php-mysqlnd && dnf clean
    all
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: RUN systemctl enable httpd mariadb php-fpm
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: this next command is all one line although looks
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: like two or more
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: RUN echo '<h1 style="Text-align:center;">Welcome to My Appliance</h1><?php phpinfo();
    ?>' >> /var/www/html/index.php
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: new stuff
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: RUN dnf install -y cockpit
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: RUN systemctl enable cockpit.socket
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: $ podman build -f mycontainerfile2.cf -t \
  prefs: []
  type: TYPE_NORMAL
- en: quay.io/[my_account]/lamp-bootc:latest
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: (((output truncated)))
  prefs: []
  type: TYPE_NORMAL
- en: Installed products updated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Installed:'
  prefs: []
  type: TYPE_NORMAL
- en: PackageKit-1.2.6-1.el9.x86_64
  prefs: []
  type: TYPE_NORMAL
- en: PackageKit-glib-1.2.6-1.el9.x86_64
  prefs: []
  type: TYPE_NORMAL
- en: abattis-cantarell-fonts-0.301-4.el9.noarch
  prefs: []
  type: TYPE_NORMAL
- en: adobe-source-code-pro-fonts-2.030.1.050-12.el9.1.noarch
  prefs: []
  type: TYPE_NORMAL
- en: ((( output truncated more )))
  prefs: []
  type: TYPE_NORMAL
- en: sscg-3.0.0-7.el9.x86_64
  prefs: []
  type: TYPE_NORMAL
- en: tracer-common-1.1-2.el9.noarch
  prefs: []
  type: TYPE_NORMAL
- en: udisks2-iscsi-2.9.4-11.el9.x86_64
  prefs: []
  type: TYPE_NORMAL
- en: udisks2-lvm2-2.9.4-11.el9.x86_64
  prefs: []
  type: TYPE_NORMAL
- en: webkit2gtk3-jsc-2.44.3-2.el9.x86_64
  prefs: []
  type: TYPE_NORMAL
- en: Complete!
  prefs: []
  type: TYPE_NORMAL
- en: --> 6ab95e317a3c
  prefs: []
  type: TYPE_NORMAL
- en: 'STEP 6/6: RUN systemctl enable cockpit.socket'
  prefs: []
  type: TYPE_NORMAL
- en: Created symlink /etc/systemd/system/sockets.target.wants/cockpit.socket → /usr/lib/systemd/system/cockpit.socket.
  prefs: []
  type: TYPE_NORMAL
- en: COMMIT quay.io/matt_st_onge/bootc/lamp-bootc:latest
  prefs: []
  type: TYPE_NORMAL
- en: --> fe247cf7e89d
  prefs: []
  type: TYPE_NORMAL
- en: Successfully tagged quay.io/matt_st_onge/bootc/lamp-bootc:latest
  prefs: []
  type: TYPE_NORMAL
- en: fe247cf7e89d97d5832d889718750d63cc5f2f24dcfd5ed4cce39dfafd150778
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: $ podman push quay.io/[my_account]/bootc/lamp-bootc:latest
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: (((output truncated)))
  prefs: []
  type: TYPE_NORMAL
- en: 'Copying blob ad312c5c40cc skipped: already exists'
  prefs: []
  type: TYPE_NORMAL
- en: 'Copying blob bd9ddc54bea9 skipped: already exists'
  prefs: []
  type: TYPE_NORMAL
- en: Copying blob 386e8ecea514 done   |
  prefs: []
  type: TYPE_NORMAL
- en: 'Copying blob 2463de35bc3e skipped: already exists'
  prefs: []
  type: TYPE_NORMAL
- en: 'Copying blob d4cfe3c3d422 skipped: already exists'
  prefs: []
  type: TYPE_NORMAL
- en: Copying blob eedcea4f81f6 done   |
  prefs: []
  type: TYPE_NORMAL
- en: 'Copying blob 2bca4ceb08f4 skipped: already exists'
  prefs: []
  type: TYPE_NORMAL
- en: Copying config fe247cf7e8 done   |
  prefs: []
  type: TYPE_NORMAL
- en: Writing manifest to image destination
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '#  /usr/bin/bootc update –-apply –-quiet'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
