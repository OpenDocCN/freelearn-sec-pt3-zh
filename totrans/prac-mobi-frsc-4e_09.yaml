- en: Understanding Android
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, we covered details about iOS devices, including the
    filesystem structure, key artifacts, backup files, and acquisition and analysis
    methods. Starting with this chapter, we will focus on the Android platform and
    how to perform forensics on Android devices. Having a good understanding of the
    Android ecosystem, security constraints, filesystems, and other features would
    prove useful during a forensic investigation. Gaining knowledge of these fundamentals
    would help a forensic expert to make informed decisions while conducting an investigation.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: The evolution of Android
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Android architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Android security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Android file hierarchy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Android filesystem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The evolution of Android
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Android is a Linux-based mobile operating system developed for touchscreen mobile
    devices. It is developed by a consortium of companies known as the **Open Handset
    Alliance** (**OHA**), with the primary contributor and commercial marketer being
    Google. The Android operating system has evolved significantly since its inaugural
    release date. Android was officially launched to the public in 2008, with Android
    version 1.0\. With the Android 1.5 Cupcake release in 2009, the tradition of naming
    Android versions after confectionery was born. The version names were also released
    in alphabetical order for the next 10 years. However, in 2019, Google announced
    that they were ending the confectionery-based naming, and were using numerical
    ordering for future versions. In the initial years, Android versions were updated
    more than twice a year, but in more recent years, version updates are done once
    per year. The most recent major Android update is Android 11, the eleventh major
    version of the Android operating system, announced by Google on February 19, 2020.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an overview of Android version history as of the time of writing:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Version** | **Version name** | **Release year** |'
  prefs: []
  type: TYPE_TB
- en: '| Android 1.0 | Apple Pie | 2008 |'
  prefs: []
  type: TYPE_TB
- en: '| Android 1.1 | Banana Bread | 2009 |'
  prefs: []
  type: TYPE_TB
- en: '| Android 1.5 | Cupcake | 2009 |'
  prefs: []
  type: TYPE_TB
- en: '| Android 1.6 | Donut | 2009 |'
  prefs: []
  type: TYPE_TB
- en: '| Android 2.0 | Eclair | 2009 |'
  prefs: []
  type: TYPE_TB
- en: '| Android 2.2 | Froyo | 2010 |'
  prefs: []
  type: TYPE_TB
- en: '| Android 2.3 | Gingerbread | 2010 |'
  prefs: []
  type: TYPE_TB
- en: '| Android 3.0 | Honeycomb | 2011 |'
  prefs: []
  type: TYPE_TB
- en: '| Android 4.0 | Ice Cream Sandwich | 2011 |'
  prefs: []
  type: TYPE_TB
- en: '| Android 4.1 | Jelly Bean | 2012 |'
  prefs: []
  type: TYPE_TB
- en: '| Android 4.4 | KitKat | 2013 |'
  prefs: []
  type: TYPE_TB
- en: '| Android 5.0 | Lollipop | 2014 |'
  prefs: []
  type: TYPE_TB
- en: '| Android 6.0 | Marshmallow | 2015 |'
  prefs: []
  type: TYPE_TB
- en: '| Android 7.0 | Nougat | 2016 |'
  prefs: []
  type: TYPE_TB
- en: '| Android 8.0 | Oreo | 2017 |'
  prefs: []
  type: TYPE_TB
- en: '| Android 9.0 | Pie | 2018 |'
  prefs: []
  type: TYPE_TB
- en: '| Android 10.0 | Q | 2019 |'
  prefs: []
  type: TYPE_TB
- en: '| Android 11 | R | 2020 |'
  prefs: []
  type: TYPE_TB
- en: This evolution has also dramatically impacted the security considerations of
    Android and how forensics techniques are applied. For example, the initial versions
    of Android did not have a **Full Disk Encryption** (**FDE**) mechanism to store
    data in an encrypted format within the device. As a result, extracting data from
    the device was much easier for a forensic investigator than it is currently. With
    each Android version update, more and more security features, such as app permissions,
    **trusted execution environment** (**TEE**), and secure kernel, have been added
    to improve the security of the platform overall but at the same time complicate
    the process of data extraction. We shall cover these security features in detail
    in the other sections of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know about the history and versions of Android, we will take a look
    at the Android architecture in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: The Android architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To effectively understand forensic concepts when dealing with Android, you should have
    a basic understanding of the Android architecture. Just like a computer, any computing
    system that interacts with the user and performs complicated tasks requires an
    operating system to handle the tasks effectively. This operating system (whether
    it's a desktop operating system or a mobile phone operating system) is responsible
    for managing the resources of the system, to provide a way for the applications
    to talk to the hardware or physical components to accomplish certain tasks. Android
    is currently the most popular mobile operating system designed to power mobile
    devices. You can find out more about this at [https://developer.android.com/about/android.html](https://developer.android.com/about/android.html).
  prefs: []
  type: TYPE_NORMAL
- en: Android, as an open source operating system, releases its code under the Apache
    License, one of the many open source licenses. Practically, this means anyone
    (especially device manufacturers) can access it, freely modify it, and use the
    software according to the requirements of any device. This is one of the primary
    reasons for its wide acceptance. Notable players that use Android include Samsung,
    HTC, Sony, and LG.
  prefs: []
  type: TYPE_NORMAL
- en: As with any other platform, Android consists of a stack of layers running one
    above the other. To understand the Android ecosystem, it's essential to have a
    basic understanding of what these layers are and what they do.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram summarizes the various layers involved in the Android
    software stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6ee0ce43-84de-41ea-8a04-dec28c003cc9.png)'
  prefs: []
  type: TYPE_IMG
- en: Android architecture
  prefs: []
  type: TYPE_NORMAL
- en: This image is modified based on work created and shared by the Android Open
    Source Project: https://developer.android.com/guide/platform
  prefs: []
  type: TYPE_NORMAL
- en: License: https://creativecommons.org/licenses/by/4.0/
  prefs: []
  type: TYPE_NORMAL
- en: Each of these layers performs several operations that support specific operating
    system functions. Each layer provides services to the layers lying on top of it.
    Let's look at them in a little more detail.
  prefs: []
  type: TYPE_NORMAL
- en: The Linux kernel layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Android operating system is built on top of the Linux kernel, with some
    architectural changes made by Google. There are several reasons for choosing the
    Linux kernel. Most importantly, Linux is a portable platform that can be compiled
    easily on different hardware. The kernel acts as an abstraction layer between
    the software and hardware present on the device. Consider the case of a camera.
    What happens when you take a photo using the camera button on your device? At
    some point, the hardware instruction (pressing a button) has to be converted to
    a software instruction (to take a picture and store it in the gallery). The kernel
    contains drivers to facilitate this process. When the user presses the button,
    the instruction goes to the corresponding camera driver in the kernel, which sends
    the necessary commands to the camera hardware, similar to what occurs when a key
    is pressed on a keyboard. In simple words, the drivers in the kernel command control
    the underlying hardware. As shown in the Android architecture model, the kernel
    contains drivers related to Wi-Fi, Bluetooth, **Universal Service Bus** (**USB**),
    audio, display, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The Linux kernel is responsible for managing the core functionality of Android,
    such as process management, memory management, security, and networking. Linux
    is a proven platform when it comes to security and process management. Android
    has taken leverage of the existing Linux open source operating system to build
    a solid foundation for its ecosystem. Each version of Android has a different
    version of the underlying Linux kernel. The Oreo Android version is known to use
    Linux kernel 3.18 or 4.9, whereas the Pie version is known to use Linux kernel
    4.4, 4.9, or 4.14. Android Q, targets Linux kernel 4.9, 4.14, or 4.19\. The actual
    kernel depends on the individual device.
  prefs: []
  type: TYPE_NORMAL
- en: The Hardware Abstraction Layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The device hardware capabilities are exposed to the high-level Java framework
    through the **Hardware Abstraction Layer** (**HAL**). The HAL consists of several
    library modules that implement interfaces for a specific type of hardware component.
    This allows hardware vendors to implement functionality without changing the higher-level
    system.
  prefs: []
  type: TYPE_NORMAL
- en: Libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next layer in the Android architecture consists of Android's native libraries.
    The libraries are written in C or C++, and help the device to handle different
    kinds of data. For example, the SQLite libraries are useful for storing and retrieving
    the data from a database. Other libraries include Media Framework, WebKit, Surface
    Manager, and **Secure Sockets Library** (**SSL**).
  prefs: []
  type: TYPE_NORMAL
- en: The Media Framework library acts as the main interface to provide a service
    to the other underlying libraries. The WebKit library provides web pages in web
    browsers, and the Surface Manager library maintains the graphics. In the same
    layer, we have **Android Runtime** (**ART**) and core libraries. ART is responsible
    for running applications on Android devices. The term *runtime* refers to the
    time from when an application is launched until it is shut down.
  prefs: []
  type: TYPE_NORMAL
- en: Dalvik Virtual Machine (DVM)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the applications that you install on the Android device are written in the
    Java programming language. When a Java program is compiled, we get bytecode. A
    **virtual machine** (**VM**) is an application that acts as an operating system—that
    is, it is possible to run an instance of the Windows operating system on a Mac,
    or vice versa, using a VM. **Java Virtual Machine** (**JVM**) is one such VM that
    can execute the previously mentioned bytecode. But Android versions before Android
    5.0 used something called DVM to run their applications.
  prefs: []
  type: TYPE_NORMAL
- en: DVM runs Dalvik bytecode, which is Java bytecode converted by the **Dalvik Executable**
    (**DEX**) compiler. Thus, the `.class` files are converted to `dex` files using
    the `dx` tool. Dalvik bytecode, when compared with Java bytecode, is more suitable
    for low-memory and low-processing environments. Also, note that JVM's bytecode
    consists of one or more `.class` files, depending on the number of Java files
    that are present in an application, but Dalvik bytecode is composed of only one
    `dex` file. Each Android application runs its own instance of DVM. This is a crucial
    aspect of Android security and will be addressed in detail in [Chapter 8](b1621e6e-80a3-495e-a288-c8db601149f8.xhtml),
    *Android Forensic Setup and Pre-Data Extraction Techniques*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram provides an insight into how Android''s DVM differs from
    Java''s JVM:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ff51cea3-861f-42fb-b320-de90d9d3b12a.png)'
  prefs: []
  type: TYPE_IMG
- en: JVM versus DVM
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have understood the basic differences between JVM and DVM, let's
    quickly have a look at ART.
  prefs: []
  type: TYPE_NORMAL
- en: ART
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: From the Android 5.0 Lollipop version onward, Dalvik was replaced by ART. Earlier
    versions of Android used **just-in-time** (**JIT**) compilation with Dalvik (frequently
    executed operations are identified and dynamically compiled to native machine
    code). This native execution of these frequently used bytecodes, called traces,
    provides significant performance improvements.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike Dalvik, ART uses **ahead-of-time** (**AOT**) compilation, which compiles
    entire applications into native machine code upon their installation. This automatically
    increases the install time for an application, but a major advantage is that this
    eliminates Dalvik's interpretation and trace-based JIT compilation, and thereby
    increases efficiency and reduces power consumption. ART uses a utility called
    `dex2oat` that accepts `DEX` files as input and generates a compiled app executable
    for the target device. With ART, the **optimized DEX** (**.odex**) files have
    been replaced with the **Executable and Linkable Format** (**ELF**) executables.
  prefs: []
  type: TYPE_NORMAL
- en: The Java API framework layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The application framework is the layer responsible for handling the basic functioning
    of a phone, such as resource management, handling calls, and so on. This is the
    block through which the applications installed on the device directly talk to
    it. The following are some of the important blocks in the application framework
    layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Telephony Manager**: This block manages all the voice calls.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Content Provider**: This block manages the sharing of data between different
    applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resource Manager**: This block manages various resources used in applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The final layer is the system apps layer, which will be discussed next.
  prefs: []
  type: TYPE_NORMAL
- en: The system apps layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is the topmost layer where the user can interact directly with the device.
    There are two kinds of applications—preinstalled applications and user-installed
    applications. Preinstalled applications—such as dialer, web browser, and contacts—come
    along with the device. User-installed applications can be downloaded from different
    places, such as Google Play Store, Amazon Marketplace, and so on. Everything that
    you see on your phone (contacts, mail, camera, and so on) is an application.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have learned about the Android architecture and the important building
    blocks. We shall now dive into some of the inherent security features in the Android
    operating system.
  prefs: []
  type: TYPE_NORMAL
- en: Android security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Android was designed with a specific focus on security. Android as a platform
    offers and enforces certain features that safeguard the user data present on the
    mobile through multilayered security. There are certain safe defaults that will
    protect the user, and there are certain offerings that can be leveraged by the
    development community to build secure applications. As a forensic investigator,
    understanding the internals of Android security is crucial as it helps to identify
    the best techniques to apply in a given situation, the technical limitations of
    certain techniques, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The next few sections will help us understand more about Android's security
    features and offerings.
  prefs: []
  type: TYPE_NORMAL
- en: A detailed explanation on Android security can be found at [https://source.android.com/security/](https://source.android.com/security/).
  prefs: []
  type: TYPE_NORMAL
- en: Secure kernel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The kernel is at the heart of the security of any operating system. By choosing
    Linux, which has evolved as a trusted platform over the years, Android has established
    a very solid security foundation. Most of the security features that are inherent
    to the Linux kernel are automatically adopted by Android. For example, the user-based
    permission model of Linux has, in fact, worked well for Android. As mentioned
    earlier, there is a lot of specific code built into the Linux kernel. With each
    Android version release, the kernel version has also changed. The following table
    shows Android versions and their corresponding kernel versions:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Android version** | **Linux kernel version** |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 2.6.25 |'
  prefs: []
  type: TYPE_TB
- en: '| 1.5 | 2.6.27 |'
  prefs: []
  type: TYPE_TB
- en: '| 1.6 | 2.6.29 |'
  prefs: []
  type: TYPE_TB
- en: '| 2.2 | 2.6.32 |'
  prefs: []
  type: TYPE_TB
- en: '| 2.3 | 2.6.35 |'
  prefs: []
  type: TYPE_TB
- en: '| 3.0 | 2.6.36 |'
  prefs: []
  type: TYPE_TB
- en: '| 4.0 | 3.0.1 |'
  prefs: []
  type: TYPE_TB
- en: '| 4.1 | 3.0.31 |'
  prefs: []
  type: TYPE_TB
- en: '| 4.2 | 3.4.0 |'
  prefs: []
  type: TYPE_TB
- en: '| 4.2 | 3.4.39 |'
  prefs: []
  type: TYPE_TB
- en: '| 4.4 | 3.8 |'
  prefs: []
  type: TYPE_TB
- en: '| 5.0 | 3.16.1 |'
  prefs: []
  type: TYPE_TB
- en: '| 6.0 | 3.18.1 |'
  prefs: []
  type: TYPE_TB
- en: '| 7.0 | 4.4.1 |'
  prefs: []
  type: TYPE_TB
- en: '| 8.0 | 4.10 |'
  prefs: []
  type: TYPE_TB
- en: '| 9.0 | 4.4, 4.9, and 4.14 |'
  prefs: []
  type: TYPE_TB
- en: '| 10.0 |  4.9, 4.14, and 4.19 |'
  prefs: []
  type: TYPE_TB
- en: 'The Linux kernel automatically brings some of its inherent security features,
    such as the following, to the Android platform:'
  prefs: []
  type: TYPE_NORMAL
- en: A user-based permissions model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Isolation of running processes (application sandbox)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Secure **inter-process communication** (**IPC**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We shall now learn about each of these features.
  prefs: []
  type: TYPE_NORMAL
- en: The permission model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As shown in the following screenshot, any Android application must be granted
    permissions to access sensitive functionality—such as the internet, dialer, and
    so on—by the user. This provides an opportunity for the user to know in advance
    which functionality on the device is being accessed by the application. Simply
    put, it requires the user's permission to perform any kind of malicious activity
    (stealing data, compromising the system, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: This model helps the user to prevent attacks, but if the user is unaware and
    gives away a lot of permissions, it leaves them in trouble (remember—when it comes
    to installing malware on any device, the weakest link is always the user).
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cd2f6a83-7870-4892-8d69-d73868619edd.png)'
  prefs: []
  type: TYPE_IMG
- en: The permission model in Android
  prefs: []
  type: TYPE_NORMAL
- en: Until Android 6.0, users needed to grant the permissions during install time.
    Users had to either accept all the permissions or not install the application.
    But, starting from Android 6.0, users grant permissions to apps while the app
    is running. This new permission system also gives the user more control over the
    app's functionality by allowing the user to grant selective permissions. For example,
    a user can deny a particular app access to their location but provide access to
    the internet. The user can revoke the permissions at any time by going to the
    app's Settings screen. From a forensic perspective, what this means is that the
    kind of information that can be extracted from a device depends not only on the
    device and the installed apps but also on the permissions that are configured
    by the user.
  prefs: []
  type: TYPE_NORMAL
- en: Application sandbox
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Linux systems, each user is assigned a unique **user identifier** (**UID**),
    and users are segregated so that one user cannot access the data of another user.
    However, all applications under a particular user are run with the same privileges.
    Similarly, in Android, each application runs as a unique user. In other words,
    a UID is assigned to each application and is run as a separate process. This concept
    ensures an application sandbox at the kernel level. The kernel manages the security
    restrictions between the applications by making use of existing Linux concepts,
    such as UID and **group identifier** (**GID**). If an application attempts to
    do something malicious—say, to read the data of another application—this is not
    permitted as the application does not have user privileges. Hence, the operating
    system protects an application from accessing the data of another application.
  prefs: []
  type: TYPE_NORMAL
- en: Secure IPC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Android offers secure IPC, through which one activity in an application can
    send messages to another activity in the same or a different application. To achieve
    this, Android provides IPC mechanisms: Intents, Services, Content Providers, and
    so on. This is more relevant to developers who code third-party apps for the Android
    platform. Behind the scenes, forensic tools exploit some of these concepts to
    gain access to the device information.'
  prefs: []
  type: TYPE_NORMAL
- en: Application signing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is mandatory that all of the installed applications are digitally signed.
    Developers can place their applications in Google''s Play Store only after signing
    the applications. The private key with which the application is signed is held
    by the developer. Using the same key, a developer can provide updates to their
    application, share data between the applications, and so on. Unsigned applications,
    if attempted to be installed, will be rejected by either Google Play or the package
    installer on the Android device. In Android 8.0 and above, users must navigate
    to the Install unknown apps setting in order to run unsigned apps, as shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c0984e6e-5005-4e9e-ab00-3b83223b7431.png)'
  prefs: []
  type: TYPE_IMG
- en: Install unknown apps screen in Android
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have some basic knowledge about digitally signed applications, let's
    look at one of the security features in Android.
  prefs: []
  type: TYPE_NORMAL
- en: Security-Enhanced Linux (SELinux)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'SELinux is a security feature that was introduced in Android 4.3 and fully
    enforced in Android 5.0\. Until this addition, Android security was based on **Discretionary
    Access Control** (**DAC**), which means applications can ask for permissions,
    and users can grant or deny those permissions. Thus, malware can create havoc
    on phones by gaining those permissions. But SE Android uses **Mandatory Access
    Control** (**MAC**), which ensures that applications work in isolated environments.
    Hence, even if a user installs a malware app, the malware cannot access the operating
    system and corrupt the device. SELinux is used to enforce MAC over all the processes,
    including the ones running with root privileges. In SELinux, anything that is
    not explicitly allowed is, by default, denied. SELinux can operate in one of the
    two global modes: **Permissive** mode, which logs the permission denials but does
    not enforce them; and **Enforcing** mode, which logs and also enforces the permission
    denials. More details about SELinux can be found at [https://source.android.com/security/selinux/concepts](https://source.android.com/security/selinux/concepts).'
  prefs: []
  type: TYPE_NORMAL
- en: FDE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With Android 6.0 Marshmallow, Google has mandated FDE for most devices, provided
    that the hardware meets certain minimum standards. Encryption is the process of
    converting data into ciphertext using a secret key. On Android devices, FDE refers
    to the process of encrypting all user data using a secret key. This key is in
    turn encrypted by the device's **personal identification number** (**PIN**)/pattern/password
    that is set by the user. Once a device is encrypted, all user-created data is
    automatically encrypted before writing it to disk, and all reads automatically
    decrypt data before returning it to the calling process. FDE in Android works
    only with an **Embedded Multimedia Card** (**eMMC**) and similar flash devices
    that present themselves to the kernel as block devices.
  prefs: []
  type: TYPE_NORMAL
- en: Staring from Android 7.x, Google decided to shift the encryption feature from
    FDE to **file-based encryption** (**FBE**). In FBE, different files are encrypted
    with different keys. By doing so, those files can be accessed independently, without
    the need to decrypt the complete partition. As a result of this, the system can
    now display open notifications or access boot-related files without having to
    wait until the user unlocks the phone.
  prefs: []
  type: TYPE_NORMAL
- en: Android Keystore
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Android Keystore is used to protect sensitive cryptographic keys from unauthorized
    access. Keys stored within a Keystore can be used to perform cryptographic operations,
    but they can never be extracted outside of the Keystore. The hardware-backed Keystores
    provide security at hardware level—that is, even if the operating system is compromised,
    the keys in the hardware module would still be secure.
  prefs: []
  type: TYPE_NORMAL
- en: TEE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A TEE is an isolated area (typically, a separate microprocessor) intended to
    guarantee the security of data stored inside it, and also to execute code with
    integrity. The main processor on mobile devices is considered untrusted and cannot
    be used to store secret data (such as cryptographic keys). Hence, a TEE is used
    specifically to perform such operations, and the software running on the main
    processor delegates any operations that require the use of secret data to the
    TEE processor.
  prefs: []
  type: TYPE_NORMAL
- en: Verified Boot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Verified Boot tries to ensure that all code that is executed on an Android device
    comes from a legitimate source rather than from an attacker or a fraud. It establishes
    a full chain of trust and prevents side-loading of any other operating system.
    During device boot-up, each stage validates the integrity and authenticity of
    the next stage before handing over execution.
  prefs: []
  type: TYPE_NORMAL
- en: We shall now look into the various partitions and filesystems available on an
    Android device.
  prefs: []
  type: TYPE_NORMAL
- en: The Android file hierarchy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to perform forensic analysis on any system (desktop or mobile), it's
    important to understand the underlying file hierarchy. A basic understanding of
    how Android organizes its data in files and folders helps a forensic analyst narrow
    down their research to specific issues. Just as with any other operating system,
    Android uses several partitions. This chapter provides an insight into some of
    the most significant partitions and the content stored in them.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s worth mentioning again that Android uses the Linux kernel. Hence, if
    you are familiar with Unix-like systems, you will understand the file hierarchy
    in Android very well. For those who are not very well acquainted with the Linux
    model, here is some basic information: in Linux, the file hierarchy is a single
    tree, with the top of the tree being denoted as `/` (called the *root*). This
    is different from the concept of organizing files in drives (as with Windows).
    Whether the filesystem is local or remote, it will be present under the root.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Android file hierarchy is a customized version of this existing Linux hierarchy.
    Based on the device manufacturer and the underlying Linux version, the structure
    of this hierarchy may have a few insignificant changes. The following is a list
    of important folders that are common to most Android devices. Some of the folders
    listed are only visible through root access. Rooting is the process of gaining
    privileged access on an Android device. More details about rooting and executing
    the `adb` commands (which are shown in the following list) are covered in detail
    in [Chapter 8](b1621e6e-80a3-495e-a288-c8db601149f8.xhtml), *Android Forensic
    Setup and Pre-Data Extraction Techniques*:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/boot`: As the name suggests, this partition has the information and files
    required for the phone to boot. It contains the kernel and **Random Access Memory**
    (**RAM**) disk, so without this partition, the phone cannot start its processes.
    Data residing in RAM is rich in value and should be captured during a forensic
    acquisition.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/system`: This partition contains system-related files other than the kernel
    and RAM disk. This folder should never be deleted as that will make the device
    unbootable. The contents of this partition can be viewed using the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/d596a874-3308-425c-8db7-270b404755f3.png)'
  prefs: []
  type: TYPE_IMG
- en: /system partition
  prefs: []
  type: TYPE_NORMAL
- en: '* `/recovery`: This is designed for backup purposes and allows the device to
    boot into recovery mode. In recovery mode, you can find tools to repair your phone
    installation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/data`: This is the partition that contains the data of each application.
    Most of the data belonging to the user—such as the contacts, SMS, and dialed numbers—is
    stored in this folder. This folder has significant importance from a forensic
    point of view as it holds valuable data. The contents of the data folder can be
    viewed using the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/dbfb40c0-e007-4322-be05-327102e4b80c.png)'
  prefs: []
  type: TYPE_IMG
- en: /data partition
  prefs: []
  type: TYPE_NORMAL
- en: '* `/cache`: This is the folder used to store the frequently accessed data and
    some of the logs for faster retrieval. The `/cache` partition is also important
    to a forensic investigation as the data residing here may no longer be present
    in the `/data` partition.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '* `/misc`: As the name suggests, this folder contains information about miscellaneous
    settings. These settings mostly define the state of the device—that is, on/off.
    Information about hardware settings, USB settings, and so on can be accessed from
    this folder.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/sdcard`: This is the partition that holds all the information present on
    the **Secure Digital** (**SD**) card. It is valuable as it can contain information
    such as pictures, videos, files, documents, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have understood the Android file hierarchy and looked at the important
    folders in it, let's have a look at the filesystem in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: The Android filesystem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Understanding the filesystem is one essential part of forensic methodologies.
    Knowledge about the properties and the structure of a filesystem proves to be
    useful during forensic analysis. The filesystem refers to the way data is stored,
    organized, and retrieved from a volume. A basic installation may be based on one
    volume split into several partitions; here, each partition can be managed by a
    different filesystem. As is true in Linux, Android utilizes mount points, and
    not drives (that is, `C:` or `E:`).
  prefs: []
  type: TYPE_NORMAL
- en: In Linux, mounting is an act of attaching an additional filesystem to the currently
    accessible filesystem of a computer. The filesystems in Linux are not accessed
    by drive names but instead are organized into a multi-level hierarchy with a directory
    called `root` at the top. Each new filesystem is added into this single filesystem
    tree when it is mounted.
  prefs: []
  type: TYPE_NORMAL
- en: It does not make any difference whether the filesystem exists on the local device
    or on a remote device. Everything is in a single hierarchy that begins with `root`. Each
    filesystem defines its own rules for managing the files in the volume. Depending
    on these rules, each filesystem offers a different speed for file retrieval, security,
    size, and so on. Linux uses several filesystems, and so does Android. From a forensic
    point of view, it's important to understand which filesystems are used by Android
    and to identify the filesystems that are of significance to the investigation.
    For example, the filesystem that stores the user's data is of primary concern
    to us, as opposed to a filesystem used to boot the device.
  prefs: []
  type: TYPE_NORMAL
- en: Viewing filesystems on an Android device
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The filesystems supported by the Android kernel can be determined by checking
    the contents of the `filesystems` file in the `proc` folder. The content of this
    file can be viewed using the `# cat /proc/filesystems` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/233ac818-3d93-4d98-8b96-8a364216653d.png)'
  prefs: []
  type: TYPE_IMG
- en: Filesystems on an Android device
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding output, the first column tells us whether the filesystem is
    mounted on the device. The ones with the `nodev` property are not mounted on the
    device.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second column lists all the filesystems present on the device. A simple
    `mount` command displays different partitions available on the device, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/33438950-4399-4e5b-aa48-07cbeb9abf73.png)'
  prefs: []
  type: TYPE_IMG
- en: Partitions on the Android device
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's look at the common filesystems on Android.
  prefs: []
  type: TYPE_NORMAL
- en: Common filesystems found on Android
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The filesystems present in Android can be organized primarily into three main
    categories, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Flash memory filesystems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Media-based filesystems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pseudo filesystems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's look at each of them in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Flash memory filesystems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Flash memory is a type of constantly powered **nonvolatile memory** (**NVM**)
    that retains data in the absence of a power supply. Flash memory can be erased
    and reprogrammed in units of memory called blocks. While the supported filesystems
    vary based on the device and underlying Linux kernel, the common flash memory
    filesystems are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Extended File Allocation Table** (**exFAT**) is a Microsoft proprietary filesystem
    that was created to be used on flash drives such as USB memory sticks and SD cards.
    Because of the license requirements, it isn''t part of the standard Linux kernel.
    But still, a few manufacturers provide support for this filesystem.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Flash Friendly File System **(**F2FS**) was released in February 2013 to
    support Samsung devices running the Linux 3.8 kernel. F2FS relies on log-structured
    methods that optimize the NAND flash memory. The offline support features are
    a highlight of this filesystem, though it is still transient and being updated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Yet Another Flash File System 2 **(**YAFFS2**) is an open source, single-threaded
    filesystem released in 2002\. It is mainly designed to be fast when dealing with the
    NAND flash. YAFFS2 utilizes **Out**-**of**-**band **(**OOB**), and this is often
    not captured or decoded correctly during forensic acquisition, which makes analysis difficult.
    We will discuss this further in [Chapter 9](https://cdp.packtpub.com/practical_mobile_forensics__fourth_edition/wp-admin/post.php?post=60&action=edit#post_470), *Android
    Data Extraction Techniques*. YAFFS2 was the most popular release at one point
    and is still widely used in Android devices. YAFFS2 is a log-structured filesystem.
    Data integrity is guaranteed, even in the case of a sudden power outage. In 2010,
    there was an announcement stating that in releases after Gingerbread, devices
    were going to move from YAFFS2 to **fourth extended file system** (**EXT4**).
    Currently, YAFFS2 is not supported by newer kernel versions, but certain mobile
    manufacturers might still continue to support it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Robust File System **(**RFS**) supports NAND flash memory on Samsung devices.
    RFS can be summarized as a **File Allocation Table 16** (**FAT16**) or FAT32 filesystem,
    whereby journaling is enabled through a transaction log. Many users complain that
    Samsung should stick with EXT4\. RFS has been known to have lag times that slow
    down the features of Android.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next in line is media-based filesystems.
  prefs: []
  type: TYPE_NORMAL
- en: Media-based filesystems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following are some of the media-based filesystems supported by Android devices.
  prefs: []
  type: TYPE_NORMAL
- en: The **Extended File System** (**EXT**), which was introduced in 1992 specifically
    for the Linux kernel, was one of the first filesystems, and it used a virtual
    filesystem. EXT2, EXT3, and EXT4 are the subsequent versions. Journaling is the
    main advantage of EXT3 over EXT2\. With EXT3, if there is an unexpected shutdown,
    there is no need to verify the filesystem. The EXT4 filesystem has gained significance
    with mobile devices implementing dual-core processors. The YAFFS2 filesystem is
    known to have a bottleneck on dual-core systems. With the Gingerbread version
    of Android, the YAFFS filesystem was swapped for EXT4.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the mount points that use EXT4 on the Samsung Galaxy mobile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '**Virtual File Allocation Table** (**VFAT**) is an extension to the FAT16 and
    FAT32 filesystems. Microsoft''s FAT32 filesystem is supported by most Android
    devices. It is supported by almost all the major operating systems, including
    Windows, Linux, and macOS. This enables these systems to easily read, modify,
    and delete the files present on the FAT32 portion of the Android device. Most
    of the external SD cards are formatted using the FAT32 filesystem.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Observe the following output, which shows that the `/sdcard` and `/secure/asec` mount
    points use the VFAT filesystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3d4cba12-e8f5-458a-af33-cce3f715f589.png)'
  prefs: []
  type: TYPE_IMG
- en: mount command output in Android
  prefs: []
  type: TYPE_NORMAL
- en: The final category is pseudo filesystems.
  prefs: []
  type: TYPE_NORMAL
- en: Pseudo filesystems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Pseudo filesystems, as the name suggests, are not actual files but a logical
    grouping of files. The following are some of the important pseudo filesystems
    in Android:'
  prefs: []
  type: TYPE_NORMAL
- en: The root filesystem (`rootfs`) is one of the main components of Android and
    contains all the information required to boot the device. When the device starts
    the boot process, it needs access to many core files, and thus, it mounts the
    root filesystem. As shown in the preceding `mount` command-line output, this filesystem
    is mounted at `/` (`root` folder). Hence, this is the filesystem on which all
    the other filesystems are slowly mounted. If this filesystem is corrupt, the device
    cannot be booted.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `sysfs` filesystem mounts the `/sys` folder, which contains information
    about the configuration of the device. The following output shows various folders
    under the `sys` directory in an Android device:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/5539a170-e9b9-432a-b089-f9a0aaf70de5.png)'
  prefs: []
  type: TYPE_IMG
- en: Folders under /sys directory in Android
  prefs: []
  type: TYPE_NORMAL
- en: Since the data present in these folders is mostly related to configuration,
    this is not usually of much significance to a forensic investigator. But there
    can be some circumstances where we might want to check whether a particular setting
    was enabled on the phone, and analyzing this folder could be useful under such
    conditions.
  prefs: []
  type: TYPE_NORMAL
- en: Note that each folder consists of a large number of files. Capturing this data
    through forensic acquisition is the best method to ensure that this data is not
    changed during an examination.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `devpts` filesystem presents an interface to the Terminal session on an
    Android device. It is mounted at `/dev/pts`. Whenever a Terminal connection is
    established—for instance, when an `adb` shell is connected to an Android device—a
    new node is created under `/dev/pts`. The following is the output showing this
    when the `adb` shell is connected to the device:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `cgroup` filesystem stands for **control groups**. Android devices use this
    filesystem to track their job. They are responsible for aggregating the tasks
    and keeping track of them. This data is generally not very useful during forensic
    analysis.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `proc` filesystem contains information about kernel data structures, processes,
    and other system-related information in the `/proc` directory. For instance, the `/sys` directory
    contains files related to kernel parameters. Similarly, `/proc/filesystems` displays
    the list of available filesystems on the device. The following command shows all
    the information about the **central processing unit** (**CPU**) of the device:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/f84b90ee-5d42-419a-abf3-b9b5871a95e5.png)'
  prefs: []
  type: TYPE_IMG
- en: Output of the cpuinfo command on an Android device
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, there are many other useful files that provide valuable information
    when you traverse them.
  prefs: []
  type: TYPE_NORMAL
- en: The `tmpfs` filesystem is a temporary storage facility on the device that stores
    the files in RAM (volatile memory). The main advantage of using RAM is faster
    access and retrieval. But once the device is restarted or switched off, this data
    will not be accessible anymore. Hence, it's important for a forensic investigator
    to examine the data in RAM before a device reboot happens, or to extract the data
    via RAM acquisition methods.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Today's forensic tools can easily mount these filesystems and display the contents
    in a **graphical user interface** (**GUI**) screen, thereby enabling forensic
    investigators to easily navigate and parse through the files. In the initial days
    of Android forensics, an investigator had to typically run a set of Linux or Windows
    commands to format and view these filesystems.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered the Android operating system's underlying features,
    filesystems, and other details that are useful in a forensic investigation. We
    learned about interesting security capabilities that are built into Android. Unlike
    iOS, several variants of Android exist as many devices run the Android operating
    system, and each may have different filesystems and unique features. The fact
    that Android is open and customizable also changes the playing field of digital
    forensics. This knowledge will be helpful to understand forensic acquisition techniques.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss how to set up a forensic workstation before
    performing the analysis.
  prefs: []
  type: TYPE_NORMAL
