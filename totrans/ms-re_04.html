<html><head></head><body><div><h1 class="header-title">Static and Dynamic Reversing</h1>
                
            
            
                
<p>Like a patient in a hospital, a file needs to undergo some triage to determine the right allocation of resources. The result of the file assessment will tell us what tools need to be used, what kind of reversing steps need to be taken, and what resources will be used. The steps involved in carrying out reversing are categorized into static and dynamic analysis. </p>
<p>In this chapter, we will introduce the methods and tools used in assessing a file. We will be focusing on a 32-bit Windows operating system for our examples. This will be followed by an examination of tools we can use for static and dynamic analysis. This chapter can help you to generate a checklist that will serve as a guide for you to retrieve all information on a file in the least amount of time.</p>
<p>In this chapter, you will do the following: </p>
<ul>
<li>Gain an understanding of Target assessment</li>
<li>Perform static analysis</li>
<li>Perform dynamic analysis</li>
</ul>


            

            
        
    </div>



  
<div><h1 class="header-title">Assessment and static analysis</h1>
                
            
            
                
<p>A file needs to undergo an initial assessment in order for us to determine what tools and analysis methods will be required. This process also helps us to create a strategy for analyzing the file. Doing such an assessment requires carrying out a light static analysis. Here are some ideas for assessment that may serve as our guide:</p>
<ul>
<li>Where did it originate from:
<ul>
<li>One of the purposes of reverse engineering is to help network administrators prevent similar malware from infiltrating the network. Knowing where a file came from would be helpful in securing the channel used to transmit it. For example, if the file being analyzed was determined to have been an email attachment, network administrators should secure the email server.</li>
</ul>
</li>
<li>Existing information:
<ul>
<li>Searching the internet for already existing information can be very helpful. There might be existing analyses that has been done on the file. We would be able to determine what behaviors to expect, which will help hasten the analysis.</li>
</ul>
</li>
<li>Viewing the file and extracting its text strings:
<ul>
<li>Using tools to view the file help us to determine the type of file. Extracting readable text from the file also gives us hints of what messages, functions, and modules it will use when opened or executed.</li>
</ul>
</li>
<li>File information:
<ul>
<li>What is the file type?</li>
<li>Header and type analysis</li>
</ul>
</li>
</ul>


            

            
        
    </div>



  
<div><h1 class="header-title">Static analysis</h1>
                
            
            
                
<p>Static analysis will help us make notes of what we will do during dynamic analysis. With knowledge of the <kbd>x86</kbd> assembly language, we should be able to understand a disassembled <kbd>Win32 PE</kbd> file and its branches. Doing so, we would be able to prepare the right tools to read, open, and debug the file based on its file type, and also understand the file's structure based on its file format.</p>
<p class="mce-root"/>
<p>We begin static analysis by determining the file type, then move on to understanding the file format. We can extract text strings that might help us instantly identify useful information, such as the API function used, which library modules it will use, what high level language the file was compiled from, registry keys it will try to access, and websites or IP addresses it might try to connect to.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">File types and header analysis</h1>
                
            
            
                
<p>The type of file is the most important piece of information that sets off the whole analysis. If the file type is a Windows executable, a preset of <kbd>PE</kbd> tools will be prepared. If the file type is a Word document, the sandbox environment we are going to use will have to be installed with Microsoft Office and analysis tools that can read the <kbd>OLE</kbd> file format. If the given target for analysis is a website, we may need to prepare browser tools that can read HTML and debug Java scripts or Visual Basic scripts.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Extracting useful information from file</h1>
                
            
            
                
<p>It would be fun to manually parse each piece of information about a file using file viewing tools, such as HxD (<a href="https://mh-nexus.de/en/hxd/">https://mh-nexus.de/en/hxd/</a>). But, since searching for documentation about the file would take some time, there are existing tools that were developed for reverse engineers. These tools, readily available on the internet, can easily extract and display file information, and have features that can identify what type of file it is. This extracted information helps us determine what type of file we are dealing with.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">PEid and TrID</h1>
                
            
            
                
<p>PEid and TrID are the tools that are able to detect the type of file, the compiler used, the encrypting tool, and the packer and protector used. Compressed executables are better known as packers. Some examples of these packers are UPX, PECompact, and Aspack. Protectors, on the other hand, are somewhat like packers, but rather more advanced in the sense that the original compiled code would be protected from being reversed easily. Examples of protectors include Themida, AsProtect, and Enigma Protector.</p>
<p class="mce-root"/>
<p>Protector software is usually commercial software. Neither tool is updated anymore but both still work very well. Here's a screenshot of PEiD's main interface:</p>
<div><img src="img/aa2462af-d655-4c28-9973-20df5425d1e0.png" width="422" height="236"/></div>
<p>Here's a screenshot of how <kbd>TrID</kbd> can be used in a Linux Terminal:</p>
<div><img src="img/4d832653-cf9c-485e-884f-ed62c20c50d4.png" width="413" height="160"/></div>
<p>At the time of writing, these tools could be downloaded at the following links:<br/>
PEid is available from <a href="http://www.softpedia.com/get/Programming/Packers-Crypters-Protectors/PEiD-updated.shtml">http://www.softpedia.com/get/Programming/Packers-Crypters-Protectors/PEiD-updated.shtml</a>.<a href="http://www.softpedia.com/get/Programming/Packers-Crypters-Protectors/PEiD-updated.shtml"><br/></a>TriD is available at <a href="http://mark0.net/soft-trid-e.html">http://mark0.net/soft-trid-e.html</a>.<a href="http://mark0.net/soft-trid-e.html"/></p>


            

            
        
    </div>



  
<div><h1 class="header-title">python-magic</h1>
                
            
            
                
<p>This is a Python module that is able to detect the file type. However, unlike PEiD and TrID, it also detects compilers and packers:</p>
<div><img src="img/474f937f-639c-42b2-8565-c5b10878e1da.png" width="438" height="94"/></div>
<p>It can be downloaded at <a href="https://pypi.org/project/python-magic/">https://pypi.org/project/python-magic/</a>.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">file</h1>
                
            
            
                
<p>Linux has a built-in command known as <strong>file</strong>. <strong>file</strong> is based on the <kbd>libmagic</kbd> library, and is able to determine file types of various file formats:</p>
<div><img src="img/8386d977-f4fa-40d7-a5b1-c960bc37b0fd.png" width="482" height="48"/></div>


            

            
        
    </div>



  
<div><h1 class="header-title">MASTIFF</h1>
                
            
            
                
<p>MASTIFF is an static analyzer framework. It works on Linux and Mac. As a framework, the static analysis is based on plugins from the MASTIFF author and from the community. </p>
<p>These plugins include the following:</p>
<p><strong>trid</strong> : This is used for identifying file types.<br/>
<strong>ssdeep</strong> : <kbd>ssdeep</kbd> is a fuzzy hash calculator. A fuzzy hash, or context triggered piecewise hashes (<kbd>CTPH</kbd>), can be used to identify nearly identical files. This is useful for identifying variants of a malware family.<br/>
<strong>pdftools</strong> : A plugin by Didier Stevens. This extracts information about PDF files.<br/>
<strong>exiftool</strong> : This shows info, from image files.<br/>
<strong>pefile</strong> : This shows information about PE files.<br/>
<strong>disitool</strong> : This is another Python script from Didier Stevens. This is used to extract digital signatures from signed executables.<br/>
<strong>pyOLEscanner</strong> : This is a tool used to extract information from OLE file types, such as Word documents and Excel spreadsheets.</p>
<p>An example of MASTIFF at work can be seen in the following screenshot:</p>
<div><img class="alignnone size-full wp-image-1359 image-border" src="img/6516bd44-c318-439c-b3a9-76a0f2082b52.png" style="width:59.08em;height:57.67em;" width="709" height="692"/></div>
<p>MASTIFF can be downloaded from <a href="https://github.com/KoreLogicSecurity/mastiff">https://github.com/KoreLogicSecurity/mastiff</a>.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Other information</h1>
                
            
            
                
<p>As part of static information gathering, a file is given its own unique hash. These hashes are used to identify a file from a database of file information. Hash information generally helps analysts share information about the file, without transmitting the file itself.</p>
<p>Here is an example of MASTIFF's <kbd>file_info</kbd> result on a test file:</p>
<div><img src="img/f8f0d228-9306-49fe-b424-b70d53d1d97d.png" width="641" height="154"/></div>


            

            
        
    </div>



  
<div><h1 class="header-title">PE executables</h1>
                
            
            
                
<p>PE executables are programs that work on Windows. Executable files have the <kbd>.exe</kbd> extension. Dynamic link libraries uses the same PE file format and use the <kbd>.dll</kbd> file extension. Windows device driver programs, also in PE file format, use the <kbd>.sys</kbd> extension. There are also other extensions that use the PE file format, such as screensavers (<kbd>.scr</kbd>).</p>
<p>The PE file format has a header, which is divided into the MZ header, along with its DOS stub and the PE header, followed by the data directories and section tables, as shown here:</p>
<div><img src="img/00d2f852-d39c-4aa4-b0fd-7d4b43e2c34a.png" style="width:30.50em;height:27.67em;" width="621" height="565"/></div>
<p>The file format follows the original <kbd>MSDOS EXE</kbd> format, but was extended for Windows using the PE header. If a Windows program were run in an MSDOS environment, it would display this message: <kbd>This program cannot be run in DOS mode.</kbd></p>
<p>The code that displays this message is part of the DOS stub.</p>
<p>The PE header's section table contains all the information about where code and data are located in the file, and how it will be mapped into the memory when it gets loaded as a process. The PE header contains the address where the program begins to execute code—a location known as the entry point—and will be set in the EIP register.</p>
<p>The data directories contain addresses of tables that, in turn, contain information such as the import table. The import table contains the libraries and APIs that will be used by the program. The table follows a structure that points to a set of addresses, pointing, in turn, to the names of libraries and their respective export functions:</p>
<div><img class="alignnone size-full wp-image-1368 image-border" src="img/1836364c-bd2e-4019-b0eb-b4d51b551935.png" style="width:35.50em;height:45.33em;" width="612" height="783"/></div>
<p>The <kbd>peinfo</kbd> module used in <kbd>MASTIFF</kbd> is able to display the imported libraries and functions, as shown here:</p>
<div><img class="alignnone size-full wp-image-1361 image-border" src="img/fcd61863-d72d-48d5-8a49-d4329ba8f724.png" style="width:52.50em;height:53.25em;" width="630" height="639"/></div>
<p><kbd>HxD</kbd> and <kbd>HIEW</kbd> are popular binary editors used in this chapter; <kbd>HxD</kbd>, being the more popular, is free, and can easily be used to make binary edits to a file. More information and a download link can be found at <a href="https://mh-nexus.de/en/hxd/">https://mh-nexus.de/en/hxd/</a>. If you try using <kbd>HxD</kbd>, you'll see something similar to this screenshot:</p>
<div><img src="img/c242bbb6-783e-43a1-9ea4-b928a97d1e1d.png" width="1155" height="623"/></div>
<p>Another useful hex-editing tool is <kbd>HIEW</kbd> (Hacker's View). The demo and free versions are able to parse through a <kbd>PE</kbd> header. This tool can also show exports and imported API functions:</p>
<div><img src="img/a0506bee-48e2-45d9-a01b-459883d30afe.png" style="width:38.17em;height:48.67em;" width="615" height="783"/></div>
<p>The statically imported modules, libraries, and functions are hints on what we can expect the program to access. Consider, for example, that if the <kbd>PE</kbd> file imports the <kbd>KERNEL32.DLL</kbd> library, then we should expect the file to contain core APIs that may access files, processes, and threads, or dynamically load other libraries and import functions. Here are some of the more common libraries that we should take note of:</p>
<ul>
<li><kbd>ADVAPI32.DLL</kbd> : This library contains functions that will access the registry.</li>
<li><kbd>MSVCRXX.DLL</kbd>  (where XX is a version number. Examples are the libraries <kbd>MSVCRT.DLL</kbd> and <kbd>MSVCR80.DLL</kbd>) – This contains Microsoft Visual C runtime functions. This tells us straight away that the program was compiled using Visual C.</li>
<li><kbd>WININET.DLL</kbd> : This library contains functions that accesses the internet.</li>
<li><kbd>USER32.DLL</kbd> : This contains window-control functions related to anything displayed on the monitor, such as dialog boxes, showing message boxes, and positioning window boxes where they should be.</li>
<li><kbd>NTDLL.DLL</kbd> : This library contains native functions that directly interact with the kernel system. <kbd>KERNEL32.DLL</kbd> and libraries like <kbd>USER32.DLL</kbd>, <kbd>WININET.DLL</kbd>, and <kbd>ADVAPI32.DLL</kbd>  have functions that are used to forward information to the native functions to perform actual system-level operations.</li>
</ul>


            

            
        
    </div>



  
<div><h1 class="header-title">Deadlisting</h1>
                
            
            
                
<p>Deadlisting is an analysis method where we get to analyze a file's disassembled or decompiled code, and map out the flow of events that will happen when it executes. The resulting illustrated flow will serve as a guide for dynamic analysis.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">IDA (Interactive Disassembler)</h1>
                
            
            
                
<p>We previously introduced the IDA tool to show the disassembly of a given file. It has a graph-view feature that shows an overview of blocks of code and the branching of conditional flow. In deadlisting, we try to describe each block of code and what possible results it will give. This gives us an idea of what the program does.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Decompilers</h1>
                
            
            
                
<p>Some high-level programs are compiled using p-code, such as C# and Visual Basic (p-code version). On the contrary, a decompiler attempts to recreate the high-level source code based on the p-code. A high-level syntax usually has an equivalent block of p-code that can by identified by the decompiler.</p>
<p>Programs compiled using the C language are laid to a file in plain assembly language. But since it is still a high-level language, some blocks of code can be identified back to their C syntax. The paid version of IDA Pro has an expensive, but very useful plugin, called Hex-Rays, that can identify these blocks of code and recreate the C source code.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">ILSpy – C# Decompiler</h1>
                
            
            
                
<p>A popular tool used to decompile a C# program is ILSpy. Some decompilers will leave the analyst with just the source being statically analyzed as is. But, in ILSpy, it is possible to save the decompiled source as a Visual Studio project. This enables the analyst to compile and debug it for dynamic analysis.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Dynamic analysis</h1>
                
            
            
                
<p>Dynamic analysis is a type of analysis that requires live execution of the code. In static analysis, the farthest we can go is with deadlisting. If, for example, we encounter a code that decrypts or decompresses to a huge amount of data, and if we want to see the contents of the decoded data, then the fastest option would be to do dynamic analysis. We can run a debug session and let that area of code run for us. Both static analysis and dynamic analysis work hand in hand. Static analysis helps us identify points in the code where we need a deeper understanding and some actual interaction with the system. By following static analysis with dynamic analysis, we can also see actual data, such as file handles, randomly generated numbers, network socket and packet data, and API function results.</p>
<p>There are existing tools that can carry out an automated analysis, which runs the program in a sandbox environment. These tools either log the changes during runtime, or in between snapshots:</p>
<ul>
<li>Cuckoo (open source) – This tool is deployed locally. It requires a host and sandbox client(s). The host serves as a web console to which files are submitted for analysis. The files are executed in the sandbox, and all activities are logged and then sent back to the host server. The report can be viewed from the web console.</li>
<li>RegShot (free) - This tool is used to take a snapshot of the registry and file system before and after running a program. The difference between the snapshots enables the analyst to determine what changes happened. The changes may include changes made by the operating system, and it is up to the analyst to identify which changes were caused by the program.</li>
<li>Sandboxie (freemium) - This tool is used in the environment where the program will be run. It is claimed that internally, it uses isolation technology. In essence, the isolation technology allocates disk space, to which disk writes will only happen at the time the program is executed by Sandboxie. This enables Sandboxie to determine changes by looking only at the isolated space. A download link and some more information about Sandboxie can be found at <a href="https://www.sandboxie.com/HowItWorks">https://www.sandboxie.com/HowItWorks</a>.</li>
<li>Malwr (free) - This is a free online service that uses Cuckoo. Files can be submitted at <a href="https://malwr.com/">https://malwr.com/</a>.</li>
<li>ThreatAnalyzer (paid) - Originally known as CWSandbox, this is the most popular sandboxing technology used in the security industry for automating the extraction of information from a piece of running malware. The technology has improved a lot, especially with its reporting. In addition, it reports descriptive behaviors found, including a cloud query about the submitted file. It can cater to customized rules and flexible Python plugins to bring up behaviors seen by the analyst.</li>
<li>Payload Security's Hybrid Analysis (free) - One of the most popular free online services, like Malwr, with report contents similar to that of ThreatAnalyzer. </li>
</ul>
<p>Submitting files to online services reduce the need to set up a host-sandbox environment. However, some would still prefer to set up their own, to avoid having files shared to the community or an online service.</p>
<p>For malware analysis, it is advisable to do automated analysis and network information gathering at the time the file was received. Sites from which malware retrieve further data might not be available if authorities act fast enough to take such sites down.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Memory regions and the mapping of a process</h1>
                
            
            
                
<p>In dynamic analysis, it is important to know what the memory looks like when a program gets loaded and then executed.</p>
<p class="mce-root"/>
<p>Since Windows and Linux are capable of multitasking, every process has its own <strong>Virtual Address Space (VAS)</strong>. For a 32-bit operating system, the VAS has a size of 4 GB. Each VAS is mapped to the physical memory using its respective page table and is managed by the operating system's kernel. So how do multiple VASes fit in the physical memory? The operating system manages this using paging. The paging has a list of used and unused memory, including privilege flags. If the physical memory is not enough, then paging can use disk space as an form of extended physical memory. A process and its module dependencies don't use up the whole 4 GB of space, and only these virtually allocated memory segments are listed as used in the page tables and mapped in the physical memory.</p>
<p>A VAS is divided into two regions: user space and kernel space, with the kernel space located in the higher address region. The division of virtual space differs between Windows and Linux:</p>
<div><img src="img/664a936f-51f3-4213-880c-ffc38bc1db71.png" style="width:41.92em;height:26.00em;" width="841" height="521"/></div>
<p>Every VAS has a kernel space listed in the page tables as a space that has exclusive privileges. Generally, these privileges are called kernel mode and user mode. These are specifically identified as protection rings. The kernel has a privilege of ring 0, while the applications that we use are run on ring 3 privilege. Device drivers are in the ring 1 or ring 2 layers, and are also identified as having kernel-mode privileges. If user-mode programs try to directly access the kernel space in kernel mode, a page fault is triggered.</p>
<p>Once a VAS is enabled, the user space is initially allocated for the stack, heap, the program, and the dynamic libraries. Further allocations are caused by the program at runtime by requesting memory using APIs, such as <kbd>malloc</kbd> and <kbd>VirtualAlloc</kbd>:</p>
<div><img src="img/7cc17c91-e137-4106-b08f-5ca519ba4904.png" width="692" height="408"/></div>
<p>The preceding screenshot is a mapped view when <kbd>jbtest.exe</kbd> had just been loaded in 32-bit Windows. Here is a more descriptive standard layout of a program in a virtual allocated space under Windows:</p>
<p> </p>
<div><img src="img/800ba473-2d11-42de-8307-5c592c009d67.png" style="width:23.00em;height:47.08em;" width="416" height="851"/></div>
<p class="mce-root"/>


            

            
        
    </div>



  
<div><h1 class="header-title">Process and thread monitoring</h1>
                
            
            
                
<p>Monitoring the processes and threads, especially those that were created by the file we are analyzing, tells us that there are more behaviors occurring than is obvious. A process can create multiple threads, which tells us that it might be doing several behaviors at the same time. A created process tells us that a new program was just executed.</p>
<p>In Windows, the termination, creation, and opening of a process can be monitored by third-party tools such as Process Monitor. Though there are built-in tools, such as Task Manager, that can show information about processes, some third-party tools can give more detail about the processes and the threads tied to it.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Network traffic</h1>
                
            
            
                
<p>The communicated data between a server and a client computer can only be seen during dynamic analysis. The packet captured during transmission will help the analyst understand what the program is sending to a server and how it will respond to any such data received.</p>
<p>Popular tools, such as Wireshark and Fiddler, are used to capture packets of data and store them as <kbd>pcap</kbd> files. In Linux, the <kbd>tcpdump</kbd> tool is commonly used to do the same thing.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Monitoring system changes</h1>
                
            
            
                
<p>For Windows, there are three aspects we need to monitor: memory, disk, and registry. File monitoring tools look at created, modified, or deleted files and directories. On the other hand, registry monitoring tools look at created, updated, or deleted registry keys, values, and data. We can use tools such as <kbd>FileMon</kbd> and <kbd>RegMon</kbd> to do this job.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Post-execution differences</h1>
                
            
            
                
<p>Comparing differences between snapshots taken before and after running the executable shows all the system changes that happened. For this type of analysis, any events that happened in between are not identified. This is useful for finding out how a software installer installed a program. And as a result, the difference comes in handy, especially when manually uninstalling a piece of software. The tool used here is RegShot.</p>
<p class="mce-root"/>


            

            
        
    </div>



  
<div><h1 class="header-title">Debugging</h1>
                
            
            
                
<p>Deadlisting gives us most of the information we need, including the program's branching flow. Now, we have an opportunity to validate the path that the program will follow when doing debugging. We get to see the data that are temporarily stored in the registers and memory. And instead of manually trying to understand a decryption code, debugging it would easily show the resulting decrypted data.</p>
<p>Tools used for debugging in Windows include the following:</p>
<ul>
<li><kbd>OllyDebug</kbd></li>
<li><kbd>x86dbg</kbd></li>
<li><kbd>IDA Pro</kbd></li>
</ul>
<p>Tools used for debugging Linux include the following:</p>
<ul>
<li><kbd>gdb</kbd></li>
<li><kbd>radare2</kbd></li>
</ul>


            

            
        
    </div>



  
<div><h1 class="header-title">Try it yourself</h1>
                
            
            
                
<p>To try out the tools we have learned about, let's try doing some static analysis on <kbd>ch4_2.exe</kbd>. To help out, here's a list of what we need to find:</p>
<ul>
<li>File information:
<ul>
<li>file type</li>
<li>imported DLLs and APIs</li>
<li>text strings</li>
<li>file hash</li>
</ul>
</li>
<li>What the file does</li>
</ul>
<p>Jumping right into getting file information, we will use TrID (<a href="http://mark0.net/soft-trid-e.html">http://mark0.net/soft-trid-e.html</a>) to identify the file type. Execute the following line:</p>
<pre>trid cha4_2.exe</pre>
<p class="mce-root"/>
<p>The TrID result tells us that we have here a Windows 32-bit executable file that is UPX packed:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1060 image-border" src="img/449c55a6-ab9c-408d-9d76-3b7762093a72.png" style="width:42.92em;height:13.00em;" width="515" height="156"/></p>
<p>Knowing that this is a UPX packed file, we can try the UPX (<a href="https://upx.github.io/">https://upx.github.io/</a>) tool's decompress feature to help us restore the file back to its original form before it was packed. A packed file is a compressed executable file that decompresses and then executes the program during runtime. The primary purpose of a packed file is to reduce the file size of executables while retaining the program's original  behavior. We will be discussing more about packers in <a href="1dd193b9-0d30-425a-b593-f3b6bcce3414.xhtml"><em>Chapter 10</em></a>, <em>Packing and Encryption</em>, of this book. For now, let's just unpack this file with the UPX tool using the <kbd>-d</kbd> parameter:</p>
<pre>upx -d cha4_2.exe</pre>
<p>This results to the file being expanded back to its original form:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1061 image-border" src="img/4f903d05-ec27-4bdf-9b12-15b10a665c15.png" style="width:52.08em;height:11.25em;" width="625" height="135"/></p>
<p class="mce-root"/>
<p>And if we use <kbd>TrID</kbd> this time, we should get a different result:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1062 image-border" src="img/18765e82-1a78-42e9-b239-18a8920c4aa9.png" style="width:42.08em;height:12.42em;" width="505" height="149"/></p>
<p>It is still a Windows executable file, so we can use CFF Explorer to check for more information:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1063 image-border" src="img/e2d58160-cafa-4741-bb25-c7a05186361d.png" style="width:58.00em;height:35.25em;" width="696" height="423"/></p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>On the left pane, if we select Import Directory, we should see a list of imported library files and API functions it will use, as shown here:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1064 image-border" src="img/6dba3eaa-2f0c-4272-9f40-4aabf5f35faa.png" style="width:75.67em;height:29.75em;" width="908" height="357"/></p>
<p>Clicking on <kbd>USER32.dll</kbd>, we see that the <kbd>MessageBoxA</kbd> API is going to be used by the program.</p>
<p class="mce-root"/>
<p>Using the bintext (<a href="http://b2b-download.mcafee.com/products/tools/foundstone/bintext303.zip">http://b2b-download.mcafee.com/products/tools/foundstone/bintext303.zip</a>) tool, we can see a list of text strings found in the file:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1065 image-border" src="img/473e0328-74e1-4037-9036-11ca8411be2c.png" style="width:72.08em;height:57.58em;" width="865" height="691"/></p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>These appear to be the notable text strings, which suggest that the program checks for the time and displays various greetings. It will probably retrieve a file from the internet. It may do something about the <kbd>File.txt</kbd> file. But all these are just educated guesses, which makes good practice for reversing, as it helps use to build an overview of the relationship between each aspect of our analysis:</p>
<pre>000000001134 000000402134 0 The system time is: %02d:%02d<br/>000000001158 000000402158 0 Nice Night!<br/>000000001164 000000402164 0 Good Morning<br/>000000001174 000000402174 0 Good Afternoon<br/>000000001184 000000402184 0 Good Evening<br/>000000001198 000000402198 0 https://raw.githubusercontent.com/PacktPublishing/Mastering-Reverse-Engineering/master/ch4/encmsg.bin<br/>000000001200 000000402200 0 File.txt<br/>00000000122C 00000040222C 0 Reversing</pre>
<p>The hash (MD5, SHA1, SHA256) of a file will help as a reference to every file we analyze. There are a lot of file hash-generating tools available in the internet. To generate the hashes of this file, we chose a tool called HashMyFiles. This is a tool compiled for Windows OS and can be added to the context menu (right-click) of the Windows Explorer:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1066 image-border" src="img/3ba6a73b-d820-4195-805e-daa71edd8dcb.png" style="width:71.00em;height:11.17em;" width="852" height="134"/></p>
<p> It can display the file's <kbd>CRC</kbd>, <kbd>MD5</kbd>, <kbd>SHA1</kbd>, <kbd>SHA-256</kbd>, <kbd>SHA-512</kbd>, and <kbd>SHA-384</kbd>, as follows:</p>
<pre>MD5: 38b55d2148f2b782163a3a92095435af<br/>SHA1: d3bdb435d37f843bf68560025aa77239df7ebb36<br/>CRC: 0bfe57ff<br/>SHA256: 810c0ac30aa69248a41c175813ede941c79f27ddce68a91054a741460246e0ae<br/>SHA512: a870b7b9d6cc4d86799d6db56bc6f8ad811fb6298737e26a52a706b33be6fe7a8993f9acdbe7fe1308f9dbf61aa1dd7a95015bab72b5c6af7b7359850036890e<br/>SHA384: b0425bb66c1d327d7819f13647dc50cf2214bf00e5fb89de63bcb442535860e13516de870cbf07237cf04d739ba6ae72</pre>
<p>Usually, we only take either <kbd>MD5</kbd>, <kbd>SHA1</kbd>, or <kbd>SHA256</kbd>.</p>
<p class="mce-root"/>
<p>We should not forget the file size and the creation time using a simple file property check:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1067 image-border" src="img/acf21dd1-2b1d-4a96-a749-223e79541616.png" style="width:29.83em;height:41.83em;" width="358" height="502"/></p>
<p>The Modified date is more relevant in terms of when the file was actually compiled. The Created date is when the file was written or copied to the directory where it is now. That means that the first time the file was built, both the Created and Modified dates were the same.</p>
<p class="mce-root"/>
<p>To statically analyze the file's behavior, we will be using a disassembly tool known as IDA Pro. A freeware version of IDA Pro can be found at <a href="https://www.hex-rays.com/products/ida/support/download_freeware.shtml">https://www.hex-rays.com/products/ida/support/download_freeware.shtml</a>. But, if you can afford the luxury of its paid version, which we highly recommend, please do purchase it. We find the features and supported architectures of the paid version way better. But for this book, we will be using every available tool that does not require purchasing.</p>
<p>There are currently two known free versions of IDA Pro. We have made backups of the tool available at <a href="https://github.com/PacktPublishing/Mastering-Reverse-Engineering/tree/master/tools/Disassembler%20Tools">https://github.com/PacktPublishing/Mastering-Reverse-Engineering/tree/master/tools/Disassembler%20Tools</a>. And since we are dealing with a 32-bit Windows executable file, select the 32-bit version.</p>
<p>Once IDA Pro is installed, open up <kbd>cha4_2.exe</kbd> inside. Wait for the auto-analysis to complete and it will redirct the disassembly to the <kbd>WinMain</kbd> function:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1068 image-border" src="img/fc46e48f-ae83-437a-89db-68b7e6102919.png" style="width:110.17em;height:58.17em;" width="1322" height="698"/></p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Scrolling down will show more disassembly code that we learned in <a href="c296c377-99c9-422d-b021-ce72b3d731dc.xhtml"><em>Chapter 3</em></a>, <em>The Low-Level Language</em>. For deadlisting behaviors, we usually look for instructions that call APIs. The very first API we encounter is a call to <kbd>GetSystemTime</kbd>:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1069 image-border" src="img/af6fa114-88dc-46b1-8ce9-fb62405eeba4.png" style="width:28.50em;height:6.50em;" width="342" height="78"/></p>
<p>Following the code, we encounter these API functions in this sequence:</p>
<ol>
<li><kbd>vsprintf_s</kbd></li>
<li><kbd>MessageBoxA</kbd></li>
<li><kbd>InternetOpenA</kbd></li>
<li><kbd>InternetConnectW</kbd></li>
<li><kbd>InternetOpenUrlA</kbd></li>
<li><kbd>memset</kbd></li>
<li><kbd>InternetReadFile</kbd></li>
<li><kbd>InternetCloseHandle</kbd></li>
<li><kbd>strcpy_s</kbd></li>
<li><kbd>CreateFileA</kbd></li>
<li><kbd>WriteFile</kbd></li>
<li><kbd>CloseHandle</kbd></li>
<li><kbd>RegCreateKeyExW</kbd></li>
<li><kbd>RegSetValueExA</kbd></li>
</ol>
<p>With what we learned in <a href="c296c377-99c9-422d-b021-ce72b3d731dc.xhtml"><em>Chapter 3</em></a>, <em>The Low Level Language</em>, try to follow the code and deduce what the file will do without executing it. To help out, here are the expected behaviors of the program:</p>
<ol>
<li>Displaying a message depending on the current system time. The messages can be one of the following:
<ul>
<li><kbd>Good Morning</kbd></li>
<li><kbd>Good Afternoon</kbd></li>
<li><kbd>Good Evening</kbd></li>
<li><kbd><kbd>Nice Night</kbd></kbd></li>
</ul>
</li>
<li>Reading the contents of a file from the internet, decrypting the contents, and saving it to a file named <kbd>File.txt</kbd>.</li>
<li>Making a registry key, <kbd>HKEY_CURRENT_USER\Software\Packt</kbd>, and storing the same decrypted data in the <kbd>Reversing</kbd> registry value.</li>
</ol>
<p>This may take a long time for beginners, but with continuous practice, analysis will be done at a fast pace.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Summary</h1>
                
            
            
                
<p>Both approaches to analysis, static and dynamic, have their means to extract information and are required to properly analyze a file. Before doing dynamic analysis, it is recommended to start with static analysis first. We stick to our goal of generating an analysis report from the information we get. The analyst is not limited to using just the tools and resources outlined here to conduct an analysis—any information from the internet is useful, but validating it with your own analysis will stand as proof. Taking all items from the file, such as notable text strings, imported API functions, system changes, code flows, and possible blocks of behaviors are important, as these may be useful when building an overview of the file.</p>
<p>The result of the static analysis draws together the approach and resources that need to be prepared for dynamic analysis. For example, if the static analysis identified the file as a <kbd>Win32</kbd> PE file executable, then tools for analyzing PE files will need to be prepared.</p>
<p>As part of dynamic analysis, we discussed about <strong>Virtual Allocated Space (VAS)</strong> and how a program is mapped in memory along with its library dependencies. This information comes in handy when attempting reversing in further chapters.</p>
<p>We also introduced a few tools that we can use to engage in both static and dynamic approaches, and ended this chapter with a brief exercise on a 32-bit Windows PE executable file. In the next chapter, we will show more use of some of these tools as we reverse-engineer files.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">References</h1>
                
            
            
                
<p>The files used in this chapter can be downloaded from <a href="https://github.com/PacktPublishing/Mastering-Reverse-Engineering">https://github.com/PacktPublishing/Mastering-Reverse-Engineering</a>.<a href="https://github.com/PacktPublishing/Mastering-Reverse-Engineering"><br/></a></p>


            

            
        
    </div>



  </body></html>