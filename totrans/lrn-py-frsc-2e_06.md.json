["```\nSOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\UserAssist \n.{GUID_1} \n..Count \n.{GUID_2} \n..Count \n```", "```\n>>> original_data = 'Why, ROT-13?' \n>>> encoded_data = original_data.encode('rot-13') \n>>> print encoded_data \nJul, EBG-13? \n>>> print encoded_data.decode('rot-13') \nWhy, ROT-13? \n```", "```\n>>> import codecs\n>>> enc = codecs.getencoder('rot-13')\n>>> enc('Why, ROT-13?')\n('Jul, EBG-13?', 12)\n>>> enc('Why, ROT-13?')[0]\n'Jul, EBG-13?'\n```", "```\n032 def rot_code(data):\n033    \"\"\"\n034     The rot_code function encodes/decodes data using string\n035     indexing\n036     :param data: A string\n037     :return: The rot-13 encoded/decoded string\n038     \"\"\"\n039     rot_chars = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i',\n040     'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',\n041     'u', 'v', 'w', 'x', 'y', 'z']\n042 \n043     substitutions = []\n```", "```\n045     # Walk through each individual character\n046     for c in data:\n047 \n048         # Walk through each individual character\n049         if c.isupper():\n```", "```\n051             try:\n052                 # Find the position of the character in\n053                 # rot_chars list\n054                 index = rot_chars.index(c.lower())\n055             except ValueError:\n056                 substitutions.append(c)\n057                 continue\n```", "```\n059             # Calculate the relative index that is 13\n060             # characters away from the index\n061             substitutions.append(\n062             (rot_chars[(index-13)]).upper())\n```", "```\n064         else:\n065 \n066             try:\n067                 # Find the position of the character in\n068                 # rot_chars list\n069                 index = rot_chars.index(c)\n070             except ValueError:\n071                 substitutions.append(c)\n072                 continue\n073 \n074             substitutions.append(rot_chars[((index-13))])\n```", "```\n\n076     return ''.join(substitutions)\n077 \n078 if __name__ == '__main__':\n079     print(rot_code('Jul, EBG-13?'))\n```", "```\npython setup.py install \n```", "```\n>>> from yarp import Registry\n>>> reg_file = open('NTUSER.DAT', 'rb')\n>>> reg = Registry.RegistryHive(reg_file) \n>>> recent_docs = reg.find_key('SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\RecentDocs')\n```", "```\n>>> print(recent_docs) \nRegistryKey, name: RecentDocs, subkeys: 75, values: 151\n\n>>> print(recent_docs.last_written_timestamp()) # Last Written Time \ndatetime.datetime(2018, 11, 20, 3, 14, 40, 286516) \n```", "```\n>>> for i, value in enumerate(recent_docs.subkeys()): \n...     print('{}) {}: {}'.format(i, value.name(), value.values_count())) \n...  \n0) .001: 2\n1) .1: 2\n2) .7z: 2\n3) .AAE: 2\n...  \n```", "```\n>>> if recent_docs.subkey('.docx'): \n...     print('Found docx subkey.') \n...  \nFound docx subkey. \n>>> if recent_docs.subkey('.1234abcd') is None: \n...     print('Did not find 1234abcd subkey.') \n...  \nNone\n```", "```\n>>> import struct \n>>> raw_data = b'\\x01\\x00\\x00\\x00' # Integer (1) \n>>> print(struct.unpack('<i', raw_data)) # Little-Endian \n(1,) \n```", "```\n>>> print(struct.unpack('>i', raw_data)) # Big-Endian \n(16777216,) \n>>> print(type(struct.unpack('>i', raw_data))) \n<class 'tuple'> \n```", "```\n>>> rawer_data = b'\\x01\\x00\\x00\\x00\\x05\\x00\\x00\\x00\\x04\\x00\\x00\\x00' \n>>> print(struct.unpack('<iii', rawer_data)) \n(1, 5, 4) \n>>> print(struct.unpack('<3i', rawer_data)) \n(1, 5, 4) \n>>> print(struct.unpack('<i4xi', rawer_data)) # \"skip\" 4 bytes \n(1, 4) \n```", "```\n>>> print(struct.unpack('<4i', rawer_data)) \nstruct.error: unpack requires a buffer of 16 bytes\n>>> print(struct.unpack('<2i', rawer_data)) \nstruct.error: unpack requires a buffer of 8 bytes \n```", "```\n0000: 0300 0000 4800 0000  |....H... \n0010: 01D1 07C4 FA03 EA00  |........ \n```", "```\n>>> rawest_data = open('Neguhe Qrag.bin', 'rb').read()\n>>> parsed_data = struct.unpack('<2iq', rawest_data)\n>>> print('Session ID: {}, Count: {}, FILETIME: {}'.format(parsed_data[0], parsed_data[1], parsed_data[2]))\n...\nSession ID: 3, Count: 72, FILETIME: 6586952011847425 \n```", "```\npip install xlsxwriter==1.1.2 \n```", "```\n002 import xlsxwriter\n003 from datetime import datetime\n...  \n033 school_data = [['Department', 'Students', 'Cumulative GPA',\n034                 'Final Date'],\n035                ['Computer Science', 235, 3.44,\n036                datetime(2015, 7, 23, 18, 0, 0)],\n037                ['Chemistry', 201, 3.26,\n038                datetime(2015, 7, 25, 9, 30, 0)],\n039                ['Forensics', 99, 3.8,\n040                datetime(2015, 7, 23, 9, 30, 0)],\n041                ['Astronomy', 115, 3.21,\n042                datetime(2015, 7, 19, 15, 30, 0)]]\n```", "```\n045 def write_xlsx(data):\n046     \"\"\"\n047     The write_xlsx function creates an XLSX spreadsheet from a\n048     list of lists\n049     :param data: A list of lists to be written in the spreadsheet\n050     :return: Nothing\n051     \"\"\"\n052     workbook = xlsxwriter.Workbook('MyWorkbook.xlsx')\n053     main_sheet = workbo\nok.add_worksheet('MySheet')\n```", "```\n055     date_format = workbook.add_format(\n056     {'num_format': 'mm/dd/yy hh:mm:ss AM/PM'})\n057 \n058     for i, entry in enumerate(data):\n059         if i == 0:\n060             main_sheet.write(i, 0, entry[0])\n061             main_sheet.write(i, 1, entry[1])\n062             main_sheet.write(i, 2, entry[2])\n063             main_sheet.write(i, 3, entry[3])\n```", "```\n064         else:\n065             main_sheet.write(i, 0, entry[0])\n066             main_sheet.write_number(i, 1, entry[1])\n067             main_sheet.write_number(i, 2, entry[2])\n```", "```\n068             main_sheet.write_datetime(i, 3, entry[3], date_format)\n069 \n070     workbook.close()\n071 \n072 \n073 write_xlsx(school_data)\n```", "```\n034 school_data = [['Computer Science', 235, 3.44,\n035                 datetime(2015, 7, 23, 18, 0, 0)],\n036                 ['Chemistry', 201, 3.26,\n037                 datetime(2015, 7, 25, 9, 30, 0)],\n038                 ['Forensics', 99, 3.8,\n039                 datetime(2015, 7, 23, 9, 30, 0)],\n040                 ['Astronomy', 115, 3.21,\n041                 datetime(2015, 7, 19, 15, 30, 0)]]\n```", "```\n044 def write_xlsx(data):\n045     \"\"\"\n046     The write_xlsx function creates an XLSX spreadsheet from a\n047     list of lists\n048     :param data: A list of lists to be written in the spreadsheet\n049     :return: Nothing\n050     \"\"\"\n051     workbook = xlsxwriter.Workbook('MyWorkbook.xlsx')\n052     main_sheet = workbook.add_worksheet('MySheet')\n053 \n054     date_format = workbook.add_format(\n055     {'num_format': 'mm/dd/yy hh:mm:ss AM/PM'})\n```", "```\n056     length = str(len(data) + 1)\n057 \n058     main_sheet.add_table(('A1:D' + length),\n059     {'data': data,\n060     'columns': [{'header': 'Department'}, {'header': 'Students'},\n061                 {'header': 'Cumulative GPA'},\n062                 {'header': 'Final Date', 'format': date_format}]})\n063 \n064     workbook.close()\n```", "```\n065     department_grades = workbook.add_chart({'type':'column'})\n```", "```\n066     department_grades.set_title(\n067     {'name':'Department and Grade distribution'})\n068     department_grades.add_series(\n069     {'categories':'=MySheet!$A$2:$A$5',\n070     'values':'=MySheet!$C$2:$C$5'})\n071     main_sheet.insert_chart('A8', department_grades)\n072     workbook.close()\n```", "```\n  |-- userassist_parser.py \n  |-- Writers \n      |-- __init__.py \n      |-- csv_writer.py \n      |-- xlsx_writer.py \n```", "```\n001 \"\"\"UserAssist parser leveraging the YARP library.\"\"\"\n002 from __future__ import print_function\n003 import argparse\n004 import struct\n005 import sys\n006 import logging\n007 import os\n008 from Writers import xlsx_writer, csv_writer\n009 from yarp import Registry\n```", "```\n045 KEYS = [] \n...  \n048 def main(): \n... \n085 def create_dictionary(): \n... \n134 def parse_values(): \n...  \n176 def get_name(): \n```", "```\n202 if __name__ == '__main__':\n203     parser = argparse.ArgumentParser(description=__description__,\n204                                      epilog='Developed by ' +\n205                                      __author__ + ' on ' +\n206                                      __date__)\n207     parser.add_argument('REGISTRY', help='NTUSER Registry Hive.')\n208     parser.add_argument('OUTPUT',\n209     help='Output file (.csv or .xlsx)')\n210     parser.add_argument('-l', help='File path of log file.')\n211 \n212     args = parser.parse_args()\n```", "```\n214     if args.l:\n215         if not os.path.exists(args.l):\n216             os.makedirs(args.l)\n217         log_path = os.path.join(args.l, 'userassist_parser.log')\n218     else:\n219         log_path = 'userassist_parser.log'\n220     logging.basicConfig(filename=log_path, level=logging.DEBUG,\n221                         format=('%(asctime)s | %(levelname)s | '\n222                         '%(message)s'), filemode='a')\n223 \n224     logging.info('Starting UserAssist_Parser')\n225     logging.debug('System ' + sys.platform)\n226     logging.debug('Version ' + sys.version)\n227     main(args.REGISTRY, args.OUTPUT)\n```", "```\n048 def main(registry, out_file):\n049     \"\"\"\n050     The main function handles main logic of script.\n051     :param registry: Registry Hive to process\n052     :param out_file: The output path and file\n053     :return: Nothing.\n054     \"\"\"\n055     if os.path.basename(registry).lower() != 'ntuser.dat':\n056         print(('[-] {} filename is incorrect (Should be '\n057                'ntuser.dat)').format(registry))\n058         logging.error('Incorrect file detected based on name')\n059         sys.exit(1)\n060     # Create dictionary of ROT-13 decoded UA key and its value\n061     apps = create_dictionary(registry)\n```", "```\n062     ua_type = parse_values(apps)\n063 \n064     if ua_type == 0:\n065         logging.info('Detected XP-based Userassist values.')\n066 \n067     else:\n068         logging.info(('Detected Win7-based Userassist values. '\n069                       'Contains Focus values.'))\n```", "```\n071     # Use .endswith string function to determine output type\n072     if out_file.lower().endswith('.xlsx'):\n073         xlsx_writer.excel_writer(KEYS, out_file)\n074     elif out_file.lower().endswith('.csv'):\n075         csv_writer.csv_writer(KEYS, out_file)\n```", "```\n076     else:\n077     print(('[-] CSV or XLSX extension not detected in '\n078            'output. Writing CSV to current directory.'))\n079     logging.warning(('.csv or .xlsx output not detected. '\n080                      'Writing CSV file to current '\n081                      'directory.'))\n082     csv_writer.csv_writer(KEYS, 'Userassist_parser.csv')\n```", "```\n085 def create_dictionary(registry):\n086     \"\"\"\n087     The create_dictionary function creates a list of dictionaries\n088     where keys are the ROT-13 decoded app names and values are\n089     the raw hex data of said app.\n090     :param registry: Registry Hive to process\n091     :return: apps_list, A list containing dictionaries for\n092     each app\n093     \"\"\"\n```", "```\n094     try:\n095         # Open the registry file to be parsed\n096         registry_file = open(registry, \"rb\")\n097         reg = Registry.RegistryHive(registry_file)\n098     except (IOError, UnicodeDecodeError) as e:\n099         msg = 'Invalid NTUSER.DAT path or Registry ID.'\n100         print('[-]', msg)\n101         logging.error(msg)\n102         sys.exit(2)\n```", "```\n104     # Navigate to the UserAssist key\n105     ua_key = reg.find_key(\n106     ('SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Explorer'\n107     '\\\\UserAssist'))\n108     if ua_key is None:\n109         msg = 'UserAssist Key not found in Registry file.'\n110         print('[-]', msg)\n111         logging.error(msg)\n112         sys.exit(3)\n```", "```\n113     apps_list = []\n114     # Loop through each subkey in the UserAssist key\n115     for ua_subkey in ua_key.subkeys():\n116         # For each subkey in the UserAssist key, detect a subkey\n117         # called Count that has more than 0 values to parse.\n```", "```\n118         if(ua_subkey.subkey('Count') and\n119         ua_subkey.subkey('Count').values_count() > 0):\n```", "```\n120             apps = {}\n121             for v in ua_subkey.subkey('Count').values():\n122                 if sys.version_info[0] == 2:\n123                     apps[v.name().encode('utf-8').decode(\n124                     'rot-13')] = v.data_raw()\n125                 elif sys.version_info[0] == 3:\n126                     import codecs\n127                     enc = codecs.getencoder('rot-13')\n128                     apps[enc(str(v.name()))[0]] = v.data_raw()\n129 \n130                 apps_list.append(apps)\n131     return apps_list\n```", "```\n134 def parse_values(data):\n135     \"\"\"\n136     The parse_values function uses struct to unpack the raw value\n137     data from the UA key\n138     :param data: A list containing dictionaries of UA\n139     application data\n140     :return: ua_type, based on the size of the raw data from\n141     the dictionary values.\n142     \"\"\"\n143     ua_type = -1\n144     msg = 'Parsing UserAssist values.'\n145     print('[+]', msg)\n146     logging.info(msg)\n147 \n148     for dictionary in data:\n149         for v in dictionary.keys():\n```", "```\n150             # WinXP based UA keys are 16 bytes\n151             if len(dictionary[v]) == 16:\n152                 raw = struct.unpack('<2iq', dictionary[v])\n153                 ua_type = 0\n154                 KEYS.append({'Name': get_name(v), 'Path': v,\n155                 'Session ID': raw[0], 'Count': raw[1],\n156                 'Last Used Date (UTC)': raw[2],\n157                 'Focus Time (ms)': '', 'Focus Count': ''})\n```", "```\n158             # Win7 based UA keys are 72 bytes\n159             elif len(dictionary[v]) == 72:\n160                 raw = struct.unpack('<4i44xq4x', dictionary[v])\n161                 ua_type = 1\n162                 KEYS.append({'Name': get_name(v), 'Path': v,\n163                 'Session ID': raw[0], 'Count': raw[1], \n164                 'Last Used Date (UTC)': raw[4],\n165                 'Focus Time (ms)': raw[3],'Focus Count': raw[2]})\n```", "```\n166             else:\n167                 # If the key is not WinXP or Win7 based -- ignore.\n168                 msg = 'Ignoring {} value that is {} bytes'.format(\n169                 str(v), str(len(dictionary[v])))\n170                 print('[-]', msg)\n171                 logging.info(msg)\n172                 continue\n173     return ua_type\n```", "```\n176 def get_name(full_name):\n177     \"\"\"\n178     the get_name function splits the name of the application\n179     returning the executable name and ignoring the\n180     path details.\n181     :param full_name: the path and executable name\n182     :return: the executable name\n183     \"\"\"\n```", "```\n184     # Determine if '\\\\' and ':' are within the full_name\n185     if ':' in full_name and '\\\\' in full_name:\n186         # Find if ':' comes before '\\\\'\n187         if full_name.rindex(':') > full_name.rindex('\\\\'):\n188             # Split on ':' and return the last element \n189             # (the executable)\n190             return full_name.split(':')[-1]\n191         else:\n192             # Otherwise split on '\\\\'\n193             return full_name.split('\\\\')[-1]\n```", "```\n194     # When just ':' or '\\\\' is in the full_name, split on\n195     # that item and return the last element (the executable)\n196     elif ':' in full_name:\n197         return full_name.split(':')[-1]\n198     else:\n199         return full_name.split('\\\\')[-1]\n```", "```\n001 from __future__ import print_function\n002 import xlsxwriter\n003 from operator import itemgetter\n004 from datetime import datetime, timedelta\n005 import logging\n```", "```\n036 excel_writer(): \n... \n071 dashboard_writer(): \n... \n156 userassist_writer(): \n... \n201 file_time(): \n... \n214 sort_by_count(): \n... \n227 sort_by_date():\n```", "```\n036 def excel_writer(data, out_file):\n037     \"\"\"\n038     The excel_writer function handles the main logic of writing\n039     the excel output\n040     :param data: the list of lists containing parsed UA data\n041     :param out_file: the desired output directory and filename\n042     for the excel file\n043     :return: Nothing\n044     \"\"\"\n045     print('[+] Writing XLSX output.')\n046     logging.info('Writing XLSX to ' + out_file + '.')\n047     headers = ['Name', 'Path', 'Session ID', 'Count',\n048     'Last Used Date (UTC)', 'Focus Time (ms)', 'Focus Count']\n049     wb = xlsxwriter.Workbook(out_file)\n050     title_format = wb.add_format({'bold': True,\n051     'font_color': 'white', 'bg_color': 'black', 'font_size': 30,\n052     'font_name': 'Calibri', 'align': 'center'})\n```", "```\n054     # A temporary list that will store dictionary values\n055     tmp_list = []\n056     for dictionary in data:\n057         # Adds dictionary values to a list ordered by the headers\n058         # Adds an empty string is the key does not exist\n059         tmp_list.append([dictionary.get(x, '') for x in headers])\n```", "```\n061     dashboard_writer(wb, tmp_list, title_format)\n062     userassist_writer(wb, tmp_list, headers, title_format)\n063 \n064     wb.close()\n065     msg =('Completed writing XLSX file. '\n066           'Program exiting successfully.')\n067     print('[*]', msg)\n068     logging.info(msg)\n```", "```\n071 def dashboard_writer(workbook, data, ua_format):\n072     \"\"\"\n073     the dashboard_writer function creates the 'Dashboard'\n074     worksheet, table, and graphs\n075     :param workbook: the excel workbook object\n076     :param data: the list of lists containing parsed UA data\n077     :param ua_format: the format object for the title and\n078     subtitle row\n079     :return: Nothing\n080     \"\"\"\n081     dashboard = workbook.add_worksheet('Dashboard')\n082     dashboard.merge_range('A1:Q1', 'XYZ Corp', ua_format)\n083     dashboard.merge_range('A2:Q2', 'Dashboard', ua_format)\n```", "```\n085     # The format to use to convert datetime object into a human\n086     # readable value\n087     date_format = workbook.add_format({\n088     'num_format': 'mm/dd/yy h:mm:ss'})\n089 \n090     # Sort our original input by count and date to assist with\n091     # creating charts.\n092     sorted_count = sort_by_count(data)\n093     sorted_date = sort_by_date(data)\n094 \n095     # Use list slicing to obtain the most and least frequently\n096     # used UA apps and the most recently used UA apps\n097     topten = sorted_count[-10:]\n098     leastten = sorted_count[:10]\n099     lastten = sorted_date[:10]\n```", "```\n101     # For the most recently used UA apps, convert the FILETIME\n102     # value to datetime format\n103     for element in lastten:\n104         element[1] = file_time(element[1])\n```", "```\n106     # Create a table for each of the three categories, specifying\n107     # the data, column headers, and formats for specific columns\n108     dashboard.add_table('A100:B110',\n109     {'data': topten, 'columns': [{'header': 'App'},\n110     {'header': 'Count'}]})\n111     dashboard.add_table('D100:E110',\n112     {'data': leastten, 'columns': [{'header': 'App'},\n113     {'header': 'Count'}]})\n114     dashboard.add_table('G100:H110',\n115     {'data': lastten, 'columns': [{'header': 'App'},\n116     {'header': 'Date (UTC)', 'format': date_format}]})\n```", "```\n118     # Create the most used UA apps chart\n119     top_chart = workbook.add_chart({'type': 'pie'})\n120     top_chart.set_title({'name': 'Top Ten Apps'})\n121     # Set the relative size to fit the labels and pie chart within\n122     # chart area\n123     top_chart.set_size({'x_scale': 1, 'y_scale': 2})\n```", "```\n125     # Add the data as a series by specifying the categories and\n126     # values\n127     top_chart.add_series(\n128     {'categories': '=Dashboard!$A$101:$A$110',\n129     'values': '=Dashboard!$B$101:$B$110',\n130     'data_labels': {'percentage': True}})\n131     # Add the chart to the 'Dashboard' worksheet\n132     dashboard.insert_chart('A4', top_chart)\n```", "```\n134     # Create the least used UA apps chart\n135     least_chart = workbook.add_chart({'type': 'pie'})\n136     least_chart.set_title({'name': 'Least Used Apps'})\n137     least_chart.set_size({'x_scale': 1, 'y_scale': 2})\n138 \n139     least_chart.add_series(\n140     {'categories': '=Dashboard!$D$101:$D$110',\n141     'values': '=Dashboard!$E$101:$E$110',\n142     'data_labels': {'percentage': True}})\n143     dashboard.insert_chart('J4', least_chart)\n```", "```\n145     # Create the most recently used UA apps chart\n146     last_chart = workbook.add_chart({'type': 'column'})\n147     last_chart.set_title({'name': 'Last Used Apps'})\n148     last_chart.set_size({'x_scale': 1.5, 'y_scale': 1})\n149 \n150     last_chart.add_series(\n151     {'categories': '=Dashboard!$G$101:$G$110',\n152     'values': '=Dashboard!$H$101:$H$110'})\n153     dashboard.insert_chart('D35', last_chart)\n```", "```\n156 def userassist_writer(workbook, data, headers, ua_format):\n157     \"\"\"\n158     The userassist_writer function creates the 'UserAssist'\n159     worksheet and table\n160     :param workbook: the excel workbook object\n161     :param data: the list of lists containing parsed UA data\n162     :param headers: a list of column names for the spreadsheet\n163     :param ua_format: the format object for the title and subtitle\n164     row\n165     :return: Nothing\n166     \"\"\"\n167     userassist = workbook.add_worksheet('UserAssist')\n168     userassist.merge_range('A1:H1', 'XYZ Corp', ua_format)\n169     userassist.merge_range('A2:H2', 'Case ####', ua_format)\n170 \n171     # The format to use to convert datetime object into a\n172     # human readable value\n173     date_format = workbook.add_format(\n174     {'num_format': 'mm/dd/yy h:mm:ss'})\n```", "```\n176     # Convert the FILETIME object to datetime and insert the 'ID'\n177     # value as the first element in the list\n178     for i, element in enumerate(data):\n179         element[4] = file_time(element[4])\n180         element.insert(0, i + 1)\n```", "```\n182     # Calculate how big the table should be. Add 3 to account for\n183     # the title and header rows.\n184     length = len(data) + 3\n185 \n186     # Create the table; depending on the type (WinXP v. Win7) add\n187     # additional headers\n188     userassist.add_table(('A3:H' + str(length)),\n189                          {'data': data,\n190                          'columns': [{'header': 'ID'},\n191                          {'header': 'Name'},\n192                          {'header': 'Path'},\n193                          {'header': 'Session ID'},\n194                          {'header': 'Count'},\n195                          {'header': 'Last Run Time (UTC)',\n196                          'format': date_format},\n197                          {'header': 'Focus Time (MS)'},\n198                          {'header': 'Focus Count'}]})\n```", "```\n201 def file_time(ft):\n202     \"\"\"\n203     The file_time function converts the FILETIME objects into\n204     datetime objects\n205     :param ft: the FILETIME object\n206     :return: the datetime object\n207     \"\"\"\n208     if ft is not None and ft != 0:\n209         return datetime(1601, 1, 1) + timedelta(microseconds=ft / 10)\n210     else:\n211         return 0\n```", "```\n>>> from operator import itemgetter \n>>> test = [['a', 2], ['b', 5], ['c', -2], ['d', 213], ['e', 40], ['f', 1]] \n>>> print(sorted(test, key=itemgetter(1)))\n[['c', -2], ['f', 1], ['a', 2], ['b', 5], ['e', 40], ['d', 213]] \n>>> print(sorted(test, key=itemgetter(1), reverse=True)) \n[['d', 213], ['e', 40], ['b', 5], ['a', 2], ['f', 1], ['c', -2]] \n>>> print(sorted(test, key=itemgetter(0))) \n[['a', 2], ['b', 5], ['c', -2], ['d', 213], ['e', 40], ['f', 1]] \n```", "```\n214 def sort_by_count(data):\n215     \"\"\"\n216     The sort_by_count function sorts the lists by their count\n217     element\n218     :param data: the list of lists containing parsed UA data\n219     :return: the sorted count list of lists\n220     \"\"\"\n221     # Return only the zero and third indexed item (the name and\n222     # count values) in the list after it has been sorted by the\n223     # count\n224     return [x[0:5:3] for x in sorted(data, key=itemgetter(3))]\n```", "```\n227 def sort_by_date(data):\n228     \"\"\"\n229     The sort_by_date function sorts the lists by their datetime\n230     object\n231     :param data: the list of lists containing parsed UA data\n232     :return: the sorted date list of lists\n233     \"\"\"\n234     # Supply the reverse option to sort by descending order\n235     return [x[0:6:4] for x in sorted(data, key=itemgetter(4),\n236     reverse=True)]\n```", "```\n001 from __future__ import print_function\n002 import sys\n003 if sys.version_info[0] == 2:\n004     import unicodecsv as csv\n005 elif sys.version_info[0] == 3:\n006     import csv\n007 from datetime import datetime, timedelta\n008 import logging\n...\n038 def csv_writer(data, out_file):\n039     \"\"\"\n040     The csv_writer function writes the parsed UA data to a csv\n041     file\n042     :param data: the list of lists containing parsed UA data\n043     :param out_file: the desired output directory and filename\n044     for the csv file\n045     :return: Nothing\n046     \"\"\"\n047     print('[+] Writing CSV output.')\n048     logging.info('Writing CSV to ' + out_file + '.')\n```", "```\n049     headers = ['ID', 'Name', 'Path', 'Session ID', 'Count',\n050     'Last Used Date (UTC)', 'Focus Time (ms)', 'Focus Count']\n051 \n052     if sys.version_info[0] == 2:\n053         csvfile = open(out_file, \"wb\")\n054     elif sys.version_info[0] == 3:\n055         csvfile = open(out_file, \"w\", newline='',\n056         encoding='utf-8')\n```", "```\n058     with csvfile:\n059         writer = csv.DictWriter(csvfile, fieldnames=headers,\n060         extrasaction='ignore')\n```", "```\n061         # Writes the header from list supplied to fieldnames\n062         # keyword argument\n063         writer.writeheader()\n```", "```\n065         for i, dictionary in enumerate(data):\n066             # Insert the 'ID' value to each dictionary in the\n067             # list. Add 1 to start ID at 1 instead of 0.\n068             dictionary['ID'] = i + 1\n069             # Convert the FILETIME object in the fourth index to\n070             # human readable value\n071             dictionary['Last Used Date (UTC)'] = file_time(\n072             dictionary['Last Used Date (UTC)'])\n073             writer.writerow(dictionary)\n```", "```\n075         csvfile.flush()\n076         csvfile.close()\n077         msg = 'Completed writing CSV file. Program exiting successfully.'\n078         print('[*]', msg)\n079         logging.info(msg)\n```"]