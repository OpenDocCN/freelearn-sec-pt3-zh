["```\n*; File: srctemplate_win.asm*\n\n*; First of all, we tell the compiler which type of executable we want it*\n*; to be. In our case it is a 32-bit PE executable.* \nformat PE GUI\n\n*; Tell the compiler where we want our program to start - define the entry*\n*; point. We want it to be at the place labeled with '_start'.*\nentry _start\n\n*; The following line includes a set of macros, shipped with FASM, which* \n*; are essential for the Windows program. We can, of course, implement all* \n*; we need ourselves, and we will do that in chapter 9.*\ninclude 'win32a.inc'\n\n*; PE file consists of at least one section.* \n*; In this template we only need 3:*\n*;    1\\. '.text' - section that contains executable code*\n*;    2\\. '.data' - section that contains data*\n*;    3\\. '.idata' - section that contains import information*\n*;*\n*; '.text' section: contains code, is readable, is executable*\nsection '.text' code readable executable\n_start:\n   *;*\n *; Put your code here*\n *;*\n\n *; We have to terminate the process properly*\n *; Put return code on stack*\n   push  0\n   *; Call ExitProcess Windows API procedure*\n   call [exitProcess]\n\n*; '.data' section: contains data, is readable, may be writeable*\nsection '.data' data readable writeable\n   *;*\n *; Put your data here*\n *;*\n\n*; '.idata' section: contains import information, is readable, is* *writeable*\nsection '.idata' import data readable writeable\n\n*; 'library' macro from 'win32a.inc' creates proper entry for importing* \n*; procedures from a dynamic link library. For now it is only 'kernel32.dll',*\n*; library kernel, 'kernel32.dll'*\n\n*; 'import' macro creates the actual entries for procedures we want to import* \n*; from a dynamic link library*\nimport kernel, \n   exitProcess, 'ExitProcess'\n```", "```\n*; File: src/template_lin.asm*\n\n*; Just as in the Windows template - we tell the assembler which type* \n*; of output we expect.* \n*; In this case it is 32-bit executable ELF*\nformat ELF executable\n\n*; Tell the assembler where the entry point is*\nentry _start\n\n*; On *nix based systems, when in memory, the space is arranged into* \n*; segments, rather than in sections, therefore, we define* \n*; two segments:*\n*; Code segment (executable segment)*\nsegment readable executable\n\n*; Here is our entry point*\n_start:\n\n   *; Set return value to 0*\n   xor ebx, ebx\n   mov eax, ebx\n\n   *; Set eax to 1 - 32-bit Linux SYS_exit system call number*\n   inc eax\n\n   *; Call kernel*\n   int 0x80\n\n*; Data segment*\nsegment readable writeable\n   db 0\n\n*; As you see, there is no import/export segment here. The structure* \n*; of an ELF executable/object file will be covered in more detail* \n*; in chapters 8 and 9*\n```", "```\nmy_var   db  0x5a\n```", "```\nmy_var db ?\n```", "```\nmy_array rd 12\n```", "```\n push ebx                 *; save EBX register on stack*\n mov  ax, 0xc001          *; move immediate value to AX register*\n movzx ebx, ax             *; move zero-extended content of AX to EBX* \n *; register*\n *; EBX = 0x0000c001*\n bswap ebx                 *; reverse byte order of EBX register* \n *; EBX = 0x01c00000*\n mov  [some_address], ebx *; move content of EBX register to* \n *; memory at 'some_address'*\n *; content of 'some_address' =* \n *; 0x01c00000*\n                            *; The above two lines of code could have* \n *; been replaced with:*\n *; movbe [some_address], ebx*\n pop  ebx                  *; restore EBX register from stack*\n```", "```\n      inc eax\n```", "```\n *;Assuming EAX equals to 8 and EBX equals to 4*\n      adc eax, ebx\n```", "```\nmov   eax, 0          *; Set EAX to 0*\nmov   ebx, eax        *; Set EBX to 0*\ninc   ebx             *; Increment EBX*\n *; EBX = 1*\nadd   ebx, 0xffffffff *; add 4294967295 to EBX*\n *; EBX = 0 and Carry Flag is set*\nadc   eax, 0          *; Add 0 and Carry Flag to EAX* \n *; EAX = 1*\n```", "```\nmov al, 0x12   *; AL = 0x12, which is packed BCD* \n *; representation of 12*\nadd al, 0x18   *; Add BCD representation of 18, \n               ; which would result in 0x2a*\ndaa            *; Adjust. AL would contain 0x30 after this instruction,* \n *; which is the BCD representation of 30*\n```", "```\nsub al, 0x03  *; We are subtracting 3 from 30, however,* \n *; the result of 0x30 - 0x03* \n *; would be 0x2d*\ndas           *; This instruction sets AL to 0x27, \n              ; which is the packed BCD* \n              *; representation of 27.*\n```", "```\nmov ax, 0x0102  *; 0x0102 is the unpacked BCD representation of 12*\nadd ax, 0x0108  *; same for 18*\n *; The result of the addition would be \n                ; 0x020a - far from being 0x0300*\naaa             *; Converts the value of AX register to 0x0300*\n```", "```\nsub ax, 0x0003  *; AX now contains 0x02fd*\naas             *; So we convert it to unpacked BCD* \n                *; representation, but...*\n *; AX becomes 0x0107, but as we know, \n                ; 30 - 3 != 17...*\n```", "```\nadc ah, 0  *; Adds the value of CF to AH*\n```", "```\nmov al, 4 \nmov bl, 8\nmul bl     *; AX becomes 0x0020*\naam        *; Converts the value of AX to the* \n *; corresponding unpacked BCD form. Now the AX*\n *; register equals to 0x0302*\n```", "```\nmov bl, 4\naad        *; Adjust AX. The value changes from 0x0302 to 0x0020*\ndiv bl     *; Perform the division itself*\n *; AL register contains the result - 0x08*\n```", "```\nif(my_var & 0x20)\n{\n   *// do something if true*\n}\nelse\n{\n  *// do something else otherwise*\n}\n```", "```\nand dword [my_var], 0x20  *; Check for sixth bit of 'my_var'.* \n *; This operation sets ZF if the result* \n *; is zero (if the bit is not set).*\njnz do_this_if_true       *; Go to this label if the bit is set*\njmp do_this_if_false      *; Go to this label otherwise*\n```", "```\n   poly = 0x31       *; The polynomial used for CRC8 calculation*\n   xor  dl, dl       *; Initialise CRC state register with 0*\n   mov  al, 0x16     ; *Prepare the sequence of 8 bits (may definitely* \n *; be more than 8 bits)*\n   mov  ecx, 8       *; Set amount of iterations*\ncrc_loop:\n   shl  al, 1\n   rcl  bl, 1\n   shl  dl, 1\n   rcl  bh, 1\n   xor  bl, bh\n   test bl, 1\n   jz  .noxor\n   xor  dl, poly\n.noxor:\n   loop crc_loop\n```", "```\ncrc_loop:\n   shl  al, 1     *; Shift left-most bit out to CF*\n   setc bl        *; Set bl to 1 if CF==1, or to zero otherwise*\n   shl  dl, 1     *; shift left-most bit out to CF*\n   setc bh        *; Set bh to 1 if CF==1, or to zero otherwise*\n   xor  bl, bh    *; Here we, in fact, are XOR'ing the previously left-most bits of al and dl*\n   jz  .noxor     *; Do not add POLY if XOR result is zero*\n   xor  dl, poly\n.noxor:\n   loop crc_loop\n```", "```\n*;*\n*; Put your code here*\n*; * \n   mov al, 0x16         *; In this specific case we pass the \n                        ; only argument via AL register*\n   call crc_proc        *; Call the 'crc_proc' procedure*\n\n *; For Windows*\n   push 0               *; Terminate the process if you are on Windows*\n   call [exitProcess]\n\n   *; For Linux          ; Terminate the process if you are on Linux*\n   xor  ebx, ebx\n   mov  eax, ebx\n   inc  eax\n   int  0x80\n\ncrc_proc:               *; Our CRC8 procedure*\n   push ebx ecx edx     *; Save the register we are going to use on stack*\n   xor dl, dl           *; Initialise the CRC state register*\n   mov ecx, 8           *; Setup counter*\n.crc_loop:\n   shl al, 1\n   setc bl\n   shl dl, 1\n   setc bh\n   xor bl, bh\n   jz .noxor\n   xor dl, 0x31\n.noxor:\n   loop .crc_loop\n   mov al, dl          *; Setup return value*\n   pop edx ecx ebx     *; Restore registers*\n   ret                 *; Return from this procedure*\n```", "```\nscas byte[edi]\n```", "```\n*; Calculate the length of a string*\n   mov   edi, hello\n   mov   ecx, 0x100    *; Maximum allowed string length*\n   xor   al, al        *; We will look for 0*\n   rep scasb           *; Scan for terminating 0*\n   or    ecx, 0        *; Check whether the string is too long*\n   jz    too_long\n   neg   ecx           *; Negate ECX*\n   add   ecx, 0x100    *; Get the length of the string*\n                       *; ECX = 14 (includes terminating 0)*\ntoo_long:\n   *; Handle this*\n\nhello db \"Hello, World!\", 0\n```", "```\nrepz cmpsb\n```", "```\n*; Do something here*\ncall   my_proc\n*; Do something else here*\n\nmy_proc:\n   enter 0x10, 0   *; Save EBP register on stack,*\n                   *; save ESP to EBP and*\n *; allocate 16 bytes on stack for procedure variables*\n *;*\n *; procedure body*\n *;*\n   leave           *; Restore ESP and EBP registers (this automatically*\n                   *; releases the space allocated on stack with ENTER)*\n   ret             *; Return from procedure*\n```", "```\n*; Do something here*\ncall   my_proc\n*; Do something else here*\n\nmy_proc:\n   push   ebp       *; Save EBP register on stack,*\n   mov    ebp, esp  *; save ESP to EBP and*\n   sub    esp, 0x10 *; allocate 16 bytes on stack for procedure variables*\n *;*\n *; procedure body*\n *;*\n   mov    esp, ebp *; Restore ESP and EBP registers (this automatically*\n   pop    ebp       *; releases the space allocated on stack with ENTER)*\n   ret              *; Return from procedure*\n```", "```\nlea eax, [some_label] *; EAX will contain the address of some_label*\n lea eax, [ebx + edi] *; EAX will contain the sum of EBX and EDI*\n```", "```\n*; This goes in '.text' section*\nfld     [radius]    *; Load radius to ST0*\n *; ST0 <== 0.2345*\nfldpi               *; Load PI to ST0*\n *; ST1 <== ST0*\n *; ST0 <== 3.1415926*\nfmulp               *; Multiply (ST0 * ST1) and pop*\n *; ST0 = 0.7367034*\nfadd    st0, st0    *; * 2*\n *; ST0 = 1.4734069*\nfstp    [result]    *; Store result*\n *; result <== ST0*\n\n*; This goes in '.data' section*\nradius  dt  0.2345\nresult  dt  0.0\n```", "```\nmov   eax, 1        *; CPUID request code #1*\ncpuid\ntest ecx, 1 shl 25  *; Check bit 25*\njz not_supported    *; If bit 25 is not set - CPU does not support AES-NI*\n```", "```\nlea   esi, [fnum1]\nmovq  xmm0, [esi]    *; Load fnum1 and fnum2 into xmm0 register*\nadd   esi, 8\nmovq  xmm1, [esi]    *; Load fnum3 and fnum4 into xmm1 register*\naddps xmm0, xmm1     *; Add two floats in xmm1 to another two floats in xmm0*\n *; xmm0 will then contain:*\n *; 0.0  0.0  1.663  12.44*\n\nfnum1  dd 0.12\nfnum2  dd 1.24\nfnum3  dd 12.32\nfnum4  dd 0.423\n```", "```\n*;*\n*; Put your code here*\n*;*\n```", "```\n *; First of all we have to expand the key*\n *; into AES key schedule.*\n lea esi, [k]\n movups xmm1, [esi]\n lea edi, [s]\n\n *; Copy initial key to schedule*\n mov ecx, 4\n rep movsd\n *; Expand the key*\n call aes_set_encrypt_key\n\n *; Actually encrypt data*\n lea esi, [s] *; ESI points to key schedule*\n lea edi, [r] *; EDI points to result buffer*\n lea eax, [d] *; EAX points to data we want*\n *; to encrypt*\n movups xmm0, [eax] *; Load this data to XMM0*\n\n *; Call the AES128 encryption procedure*\n call aes_encrypt\n\n *; Nicely terminate the process*\n push 0\n call [exitProcess]\n\n*; AES128 encryption procedure*\naes_encrypt: *; esi points to key schedule*\n *; edi points to output buffer*\n *; xmm0 contains data to be encrypted*\n   mov ecx, 9\n   movups xmm1, [esi]\n   add esi, 0x10\n   pxor xmm0, xmm1          *; Add the first round key*\n\n.encryption_loop:\n   movups xmm1, [esi]       *; Load next round key*\n   add esi, 0x10\n   aesenc xmm0, xmm1        *; Perform encryption round*\n   loop .encryption_loop\n\n   movups xmm1, [esi]       *; Load last round key* \n   aesenclast xmm0, xmm1    *; Perform the last encryption round*\n\n   lea edi, [r]\n   movups [edi], xmm0       *; Store encrypted data*\n   ret\n\n*; AES128 key setup procedures*\n*; This procedure creates full*\n*; AES128 encryption key schedule*\naes_set_encrypt_key: *; xmm1 contains the key*\n *; edi points to key schedule*\n   aeskeygenassist xmm2, xmm1, 1\n   call key_expand\n   aeskeygenassist xmm2, xmm1, 2\n   call key_expand\n   aeskeygenassist xmm2, xmm1, 4\n   call key_expand\n   aeskeygenassist xmm2, xmm1, 8\n   call key_expand\n   aeskeygenassist xmm2, xmm1, 0x10\n   call key_expand\n   aeskeygenassist xmm2, xmm1, 0x20\n   call key_expand\n   aeskeygenassist xmm2, xmm1, 0x40\n   call key_expand\n   aeskeygenassist xmm2, xmm1, 0x80\n   call key_expand\n   aeskeygenassist xmm2, xmm1, 0x1b\n   call key_expand\n   aeskeygenassist xmm2, xmm1, 0x36\n   call key_expand\n   ret\n\nkey_expand: *; xmm2 contains key portion*\n *; edi points to place in schedule*\n *; where this portion should*\n *; be stored at*\n pshufd xmm2, xmm2, 0xff    *; Set all elements to 4th element*\n vpslldq xmm3, xmm1, 0x04   *; Shift XMM1 4 bytes left*\n *; store result to XMM3*\n pxor xmm1, xmm3            \n vpslldq xmm3, xmm1, 0x04\n pxor xmm1, xmm3\n vpslldq xmm3, xmm1, 0x04\n pxor xmm1, xmm3\n pxor xmm1, xmm2\n movups [edi], xmm1\n add edi, 0x10\n ret\n```", "```\n *; Data to be encrypted*\n d db 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0xa,0xb, 0xc, 0xd, 0xe, 0xf\n\n *; Encryption key*\n k db 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1\n\n *; AES key schedule (11 round keys, 16 bytes each)*\n s rb 16 * 11\n\n *; Result will be placed here*\n r rb 16\n```"]