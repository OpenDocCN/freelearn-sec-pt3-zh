<html><head></head><body>
        

                            
                    <h1 class="header-title">Mixing Modules Written in Assembly and Those Written in High-Level Languages</h1>
                
            
            
                
<p class="mce-root">We have come a long way and have covered almost every aspect of Assembly programming basics. In fact, we should be able to implement any algorithm in Assembly language by this time; however, there are a few important things left we have not touched yet, but they are nonetheless important to know.</p>
<p>Despite the fact that writing relatively large parts of a product (not to say writing a complete product) in Assembly language may not be the best idea when it comes to timelines, it may still be a very interesting and challenging task (educational as well). Sometimes it is more convenient to implement certain parts of an algorithm in Assembly, rather than using a high-level language. Remember the tiny virtual machine we used for XOR encryption of data? For the sake of an example, we will implement a simple encryption/decryption module in Assembly and see how it may be used with high-level languages.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Implementing the core of a primitive cryptographic module</li>
<li>Building object files for further linking with code written in high-level languages:
<ul>
<li><strong>OBJ</strong>: Object files for Windows (32 and 64 bit);</li>
<li><strong>O</strong>: Linkable ELF for Linux (32 and 64 bit);</li>
</ul>
</li>
<li>Building DLL (dynamic link libraries) and SO (shared objects) for Windows and Linux (32 and 64 bit) to be used with the .NET platform</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Crypto Core</h1>
                
            
            
                
<p>The main project of this chapter is a tiny, simple (not to say primitive) encryption/decryption module written entirely in Assembly. Since the topic of this chapter is interfacing Assembly modules and modules written in high-level languages, we will not delve into cryptography principles, but we will rather concentrate on the portability and interoperability of our code while using a slightly modified XOR algorithm. The idea behind the algorithm is to receive an array of bytes and do the following:</p>
<ol>
<li>Take a byte and rotate it a certain number of bits to the left (the counter is randomly generated at compile time).</li>
<li>XOR the result with the 1-byte key (randomly generated at compile time as well).</li>
<li>Write the byte back to the array.</li>
<li>If there are more bytes to encrypt, go to step 1; otherwise break out of the loop.</li>
</ol>
<p>The following screenshot is an example output of the algorithm we are about to implement:</p>
<div><img class="image-border" height="106" src="img/23636279-3418-455a-92cc-ab914aa0008a.png" width="513"/></div>
<p>Not the best encryption, but definitely enough for our needs.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Portability</h1>
                
            
            
                
<p>Our intention is to write portable code that may be used on both 32-bit and 64-bit Windows and Linux platforms. This may either sound impossible or very tedious work, but it is quite simple. First of all, we have to define a few constants and macros, which will ease our further work, so let's begin by creating the <kbd>platform.inc</kbd> and <kbd>crypto.asm</kbd> source files where the latter is the main source file and the one we will compile.</p>
<p>Flat Assembler is capable of producing files in a variety of formats, beginning with raw binary output and DOS executables, through Windows-specific formats and up to Linux binaries (both executable and object). It is assumed that you are familiar with at least some of the following formats:</p>
<ul>
<li>32-bit Windows object file (MS COFF format)</li>
<li>64-bit Windows object file (MS64 COFF format)</li>
<li>32-bit Windows DLL</li>
<li>64-bit Windows DLL</li>
<li>32-bit Linux object file (ELF)</li>
<li>64-bit Linux object file (ELF64)</li>
</ul>
<p>There is no need to be deeply acquainted with them, as the Flat Assembler does all the hard work for us and all we have to do is tell it which format we are interested in (and format our code accordingly). We will use a compile time variable, <kbd>ACTIVE_TARGET</kbd>, for conditional compilation and use the following constants as possible values:</p>
<pre class="mce-root">; Put this in the beginning of 'platform.inc'<br/><br/>type_dll       equ 0<br/>type_obj       equ 1<br/><br/>platform_w32   equ 2<br/>platform_w64   equ 4<br/>platform_l32   equ 8<br/>platform_l64   equ 16<br/><br/>TARGET_W32_DLL equ platform_w32 or type_dll<br/>TARGET_W32_OBJ equ platform_w32 or type_obj<br/>TARGET_W64_DLL equ platform_w64 or type_dll<br/>TARGET_W64_OBJ equ platform_w64 or type_obj<br/>TARGET_L32_O   equ platform_l32 or type_obj<br/>TARGET_L64_O   equ platform_l64 or type_obj</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Specifying the output format</h1>
                
            
            
                
<p>As usual, the main source file (in our case, <kbd>crypto.asm</kbd>) should begin with the output format specification, thus telling the assembler how to treat the code and sections when creating the output file. As we have mentioned earlier, the compile-time variable, <kbd>ACTIVE_TARGET</kbd>, is the one to be used for the selection of the proper code for the assembler to process.</p>
<p>The next step would be defining a macro that would conditionally generate the proper code sequence. Let's call it <kbd>set_output_format</kbd>:</p>
<pre class="mce-root">macro set_output_format<br/>{<br/>   if ACTIVE_TARGET = TARGET_W32_DLL<br/>      include 'win32a.inc'<br/>      format PE DLL<br/>      entry DllMain<br/><br/>   else if ACTIVE_TARGET = TARGET_W32_OBJ<br/>      format MS COFF<br/><br/>   else if ACTIVE_TARGET = TARGET_W64_DLL<br/>      include 'win64a.inc'<br/>      format PE64 DLL<br/>      entry DllMain<br/><br/>   else if ACTIVE_TARGET = TARGET_W64_OBJ<br/>      format MS64 COFF<br/><br/>   else if ACTIVE_TARGET = TARGET_L32_O<br/>      format ELF<br/><br/>   else if ACTIVE_TARGET = TARGET_L64_O<br/>      format ELF64<br/>   end if<br/>}</pre>
<p>This macro would tell the assembler to evaluate the <kbd>ACTIVE_TARGET</kbd> compile-time variable and only use specific code. For example, when <kbd>ACTIVE_TARGET</kbd> equals <kbd>TARGET_W64_OBJ</kbd>, the assembler will only process the following line:</p>
<pre>format MS64 COFF</pre>
<p>Thus, it will generate a 64-bit Windows object file.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Conditional declaration of code and data sections</h1>
                
            
            
                
<p>Having told the compiler what output format we are expecting, we need to declare the sections. Since we are writing portable code, we will use two macros to properly declare code and data sections for each of the formats mentioned earlier. As we are used to seeing a data section after the code section (at least in this book, as the order may vary), we will declare a macro responsible for the proper declaration of the beginning of the code section first:</p>
<pre class="mce-root">macro begin_code_section<br/>{<br/>   if ACTIVE_TARGET = TARGET_W32_DLL<br/>      section '.text' code readable executable<br/>    <em>; This is not obligatory, but nice to have - the DllMain procedure</em><br/>    DllMain:<br/>      xor eax, eax<br/>      inc eax<br/>      ret 4 * 3<br/><br/>   else if ACTIVE_TARGET = TARGET_W32_OBJ<br/>      section '.text' code readable executable<br/><br/>   else if ACTIVE_TARGET = TARGET_W64_DLL<br/>      section '.text' code readable executable<br/>    <em>; DllMain procedure for 64-bit Windows DLL</em><br/>    DllMain:<br/>      xor rax, rax<br/>      inc eax<br/>      ret<br/><br/>   else if ACTIVE_TARGET = TARGET_W64_OBJ<br/>      section '.text' code readable executable<br/><br/>   else if ACTIVE_TARGET = TARGET_L32_O<br/>      section '.text' executable<br/><br/>   else if ACTIVE_TARGET = TARGET_L64_O<br/>      section '.text' executable<br/><br/>   end if<br/>}</pre>
<p>We will follow it by the macro declaring data section:</p>
<pre class="mce-root">macro begin_data_section<br/>{<br/>   if ACTIVE_TARGET = TARGET_W32_DLL<br/>      section '.data' data readable writeable<br/><br/>   else if ACTIVE_TARGET = TARGET_W32_OBJ<br/>      section '.data' data readable writeable<br/><br/>   else if ACTIVE_TARGET = TARGET_W64_DLL<br/>      section '.data' data readable writeable<br/><br/>   else if ACTIVE_TARGET = TARGET_W64_OBJ<br/>      section '.data' data readable writeable align 16<br/><br/>   else if ACTIVE_TARGET = TARGET_L32_O<br/>      section '.data' writeable<br/><br/>   else if ACTIVE_TARGET = TARGET_L64_O<br/>      section '.data' writeable<br/><br/>   end if<br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Exporting symbols</h1>
                
            
            
                
<p>The last macro in the series would be the one that makes it possible to export certain symbols. Our implementation of a cryptographic core would export just one symbol--the <kbd>GetPointers()</kbd> procedure--which, in turn, would return a pointer to a structure containing pointers to the rest of procedures. This macro follows the previously defined pattern:</p>
<pre class="mce-root"><em>; In this specific case, when the macro would be called </em><br/><em>; at the end of the source, we may replace the</em><br/><em>; "macro finalize" declaration with the "postpone" directive.</em><br/>macro finalize<br/>{<br/>   if ACTIVE_TARGET = TARGET_W32_DLL<br/>      section '.edata' export data readable<br/>         export 'MA_CRYPTO.DLL',\<br/>            GetPointers, 'GetPointers'<br/><br/>   else if ACTIVE_TARGET = TARGET_W32_OBJ<br/>      public GetPointers as '_GetPointers'<br/><br/>   else if ACTIVE_TARGET = TARGET_W64_DLL<br/>      section '.edata' export data readable<br/>         export 'MA_CRYPTO.DLL',\<br/>            GetPointers, 'GetPointers'<br/><br/>   else if ACTIVE_TARGET = TARGET_W64_OBJ<br/>      public GetPointers as 'GetPointers'<br/><br/>   else if ACTIVE_TARGET = TARGET_L32_O<br/>      public GetPointers as 'GetPointers' <br/><br/>   else if ACTIVE_TARGET = TARGET_L64_O<br/>      public GetPointers as 'GetPointers'<br/><br/>   end if<br/>}</pre>
<p>The preceding macro would make the symbol visible to either a static or dynamic linker, depending on the target we are building. Alternatively, we could replace <kbd>macro finalize</kbd> with the <kbd>postpone</kbd> directive, which would force the body of the macro to be executed automatically once the end of the source is reached.</p>
<p>Now we may save the <kbd>platform.inc</kbd> file as we will not alter it in any way in the future.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Core procedures</h1>
                
            
            
                
<p>Having taken care of all the output format specifics, we may safely proceed to the implementation of the core's code. As it has already been mentioned earlier, we are about to export only a single entry; however, we still need to implement the rest. There are only four procedures in our core:</p>
<ul>
<li><kbd>f_set_data_pointer</kbd>: This procedure accepts a single parameter, which is a pointer to the data we want to process, and stores it to the <kbd>data_pointer</kbd> global variable</li>
<li><kbd>f_set_data_length</kbd>: This procedure accepts one parameter, which is the length of data we want to encrypt/decrypt, and stores it to the <kbd>data_length</kbd> global variable</li>
<li><kbd>f_encrypt</kbd>: This procedure implements the encryption loop</li>
<li><kbd>f_decrypt</kbd>: This is the inverse operation of <kbd>f_encrypt</kbd></li>
</ul>
<p>However, prior to implementing all of these, we first need to prepare the template or, to be more precise, the skeleton for our main source file. This template would look a tiny bit different from what we are used to due to the extensive usage of macroinstructions. However, don't let it confuse you. The structure is logically (and from an Assembler's point of view) the same as the one we have been dealing with earlier:</p>
<pre><em>; First of all we need to include all that we have written this far</em><br/>include 'platform.inc'<br/><br/><em>; The following variable and macro are used in compile time <br/>; only for generation of </em><em>pseudorandom sequences, where <br/>; count specifies the amount of pseudorandom bytes to </em><em>generate</em><br/>seed = %t<br/>macro fill_random count<br/>{<br/>   local a, b<br/>   a = 0<br/>   while a &lt; count<br/>      seed = ((seed shr 11) xor (seed * 12543)) and 0xffffffff<br/>      b = seed and 0xff<br/>      db   b<br/>      a = a + 1<br/>   end while<br/>}<br/><br/><em>; ACTIVE_TARGET variable may be set to any of the <br/>; TARGET* constants</em><br/>ACTIVE_TARGET = TARGET_W32_DLL<br/><br/><em>; Tell the compiler which type of output is expected <br/>; depending on the value of </em><em>the ACTIVE_TARGET variable</em><br/>set_output_format<br/><br/><em>; Create code section depending on selected target</em><br/>begin_code_section<br/><br/><strong><em>; We will insert our code here</em></strong><br/><br/><em>; Create appropriate declaration of the data section</em><br/>begin_data_section<br/><br/>   <em>; Tell the compiler whether we are expecting 32-bit <br/>   ; or 64-bit output</em><br/>   if(ACTIVE_TARGET = TARGET_W32_OBJ) |\ <br/>     (ACTIVE_TARGET = TARGET_W32_DLL) |\ <br/>     (ACTIVE_TARGET = TARGET_L32_O)<br/>      use32<br/>   else if(ACTIVE_TARGET = TARGET_W64_OBJ) |\ <br/>          (ACTIVE_TARGET = TARGET_W64_DLL) |\ <br/>          (ACTIVE_TARGET = TARGET_L64_O)<br/>      use64<br/>   end if<br/><br/>   <em>; This, in fact, is a structure which would be populated with <br/>   ; addresses of our procedures</em><br/>   pointers:<br/>   fill_random 4 * 8<br/>   <br/>   <em>; Here the core stores the address of the data to be processed</em><br/>   data_pointer:<br/>   fill_random 8<br/><br/>   <em>; And here the core stores its length in bytes</em><br/>   data_length:<br/>   fill_random 8<br/><br/>   <em>; Pseudorandom encryption key</em><br/>   key:<br/>   fill_random 2<br/><br/><em>; The following line may be omitted if we used the postpone</em><br/><em>; directive instead of "macro finalize"</em><br/>finalize</pre>
<p>Despite having a different look from what we are used to seeing, the preceding code is quite self-explanatory and there is not too much to add, if at all. All the hard work is being delegated to previously defined macroinstructions and the only aspect we still have to take care of is the bit capacity. As you can see, the size and addresses are given 8 bytes by default. The purpose of this is to make them fit both 32-bit and 64-bit needs. We could have inserted another <kbd>ifâ€¦else</kbd> clause, but since we only have 3 bit capacity-dependent data items, spending another 4 bytes for each of them in 32-bit mode is not an issue.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Encryption/decryption</h1>
                
            
            
                
<p>As we are developing a crypto core here, it is natural to begin with the implementation of the cryptographic functionality first. The following code performs the encryption of data according to the algorithm we previously defined:</p>
<pre>f_encrypt:<br/>   <em>; The if statement below, when the condition is TRUE, forces the assembler to produce</em><br/><em>   ; 32-bit code</em><br/>   if (ACTIVE_TARGET = TARGET_W32_OBJ) |\<br/>      (ACTIVE_TARGET = TARGET_W32_DLL) |\<br/>      (ACTIVE_TARGET = TARGET_L32_O)<br/>      push eax ebx esi edi ecx<br/>      lea esi, [data_pointer]<br/>      mov esi, [esi]<br/>      mov edi, esi<br/>      lea ebx, [data_length]<br/>      mov ebx, [ebx]<br/>      lea ecx, [key]<br/>      mov cx, [ecx]<br/>      and cl, 0x07<br/><br/>   <em>; Encryption loop</em><br/>   @@:<br/>      lodsb<br/>      rol al, cl<br/>      xor al, ch<br/>      stosb<br/>      dec ebx<br/>      or ebx, 0<br/>      jnz @b<br/><br/>      pop ecx edi esi ebx eax<br/>      ret<br/><br/><em>; In general, we could have omitted the "if" statement here,<br/>; but the assembler</em><br/><em>; should not generate any code at all, if <br/>; the value of ACTIVE_TARGET is not valid.</em><br/><em>; In either case, the following block is processed only<br/>; when we are expecting </em><em>a 64-bit output</em><br/>   else if (ACTIVE_TARGET = TARGET_W64_OBJ) |\<br/>           (ACTIVE_TARGET = TARGET_W64_DLL) |\<br/>           (ACTIVE_TARGET = TARGET_L64_O)<br/>      push rax rbx rsi rdi rcx<br/>      lea rsi, [data_pointer]<br/>      mov rsi, [rsi]<br/>      mov rdi, rsi<br/>      lea rbx, [data_length]<br/>      mov ebx, [rbx]<br/>      lea rcx, [key]<br/>      mov cx, [rcx]<br/>      and cl, 0x07<br/><br/>   @@:<br/>      lodsb<br/>      rol al, cl<br/>      xor al, ch<br/>      stosb<br/>      dec rbx<br/>      or rbx, 0<br/>      jnz @b<br/><br/>      pop rcx rdi rsi rbx rax<br/>      ret<br/><br/>   end if </pre>
<p>By now, you should be able to differentiate between different parts of a procedure yourself, seeing where the prolog ends, where the epilog begins, and where the core functionality resides. In this particular case, the majority of the code is dedicated to preserving/restoring registers and to accessing parameters/variables, while the core functionality may be narrowed down to this code:</p>
<pre><em>; Encryption loop</em><br/>   @@:<br/>      lodsb<br/>      rol al, cl<br/>      xor al, ch<br/>      stosb<br/>      dec ebx<br/>      or ebx, 0<br/>      jnz @b</pre>
<p>For 32-bit platform or to this code:</p>
<pre>@@:<br/>      lodsb<br/>      rol al, cl<br/>      xor al, ch<br/>      stosb<br/>      dec rbx<br/>      or rbx, 0<br/>      jnz @b</pre>
<p>For its 64-bit platform.</p>
<p>It is quite obvious that the implementation of the decryption procedure would be 99% identical to the encryption one. The only change would be swapping the rotation and <kbd>XOR</kbd> instructions (while changing the direction of rotation, of course). Thus, the 32-bit version of <kbd>f_decrypt</kbd> would have the following:</p>
<pre>xor al, ch<br/>ror al, cl</pre>
<p>Similarly, its 64-bit analog would be just the same two lines.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Setting the encryption/decryption parameters</h1>
                
            
            
                
<p>As you may have noticed (I hope you have), the procedures discussed in the previous section do not receive any parameters at all. Therefore, we do need to supply two more procedures in order to make it possible to tell the core where data resides and how many bytes to process. As each of these procedures accepts one parameter, the code would be a bit more segmented in order to reflect the calling convention being used, which, in our case, is as follows:</p>
<ul>
<li>cdecl for 32-bit targets</li>
<li>Microsoft x64 for Windows-based 64-bit targets</li>
<li>AMD64 for Linux-based 64-bit targets</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">f_set_data_pointer</h1>
                
            
            
                
<p>This procedure receives a parameter of the <kbd>void*</kbd> type . Of course, the assembler does not care about the type of parameter a certain procedure expects. To be more precise, the assembler, as a compiler, is not aware of the procedure parameters as a concept, not to mention that it has no concept of procedure at all. Let's take a look at the implementation of the <kbd>f_set_data_pointer</kbd> procedure:</p>
<pre>f_set_data_pointer:<br/>   if (ACTIVE_TARGET = TARGET_W32_OBJ) |\<br/>      (ACTIVE_TARGET = TARGET_W32_DLL) |\<br/>      (ACTIVE_TARGET = TARGET_L32_O)<br/>      push eax<br/>      lea eax, [esp + 8]<br/>      push dword [eax]<br/>      pop dword [data_pointer]<br/>      pop eax<br/>      ret<br/><br/>   else if (ACTIVE_TARGET = TARGET_W64_OBJ) |\<br/>           (ACTIVE_TARGET = TARGET_W64_DLL)<br/>      push rax<br/>      lea rax, [data_pointer]<br/>      mov [rax], rcx<br/>      pop rax<br/>      ret<br/><br/>   else if (ACTIVE_TARGET = TARGET_L64_O)<br/>      push rax<br/>      lea rax, [data_pointer]<br/>      mov [rax], rdi<br/>      pop rax<br/>      ret<br/><br/>   end if </pre>
<p>Nothing complicated in this code either. The parameter passed to this procedure is simply being written to the <kbd>data_pointer</kbd> location.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">f_set_data_length</h1>
                
            
            
                
<p>This procedure is identical to <kbd>f_set_data_pointer</kbd> with the only difference being the address where the parameter is written. Simply copy the preceding code and change <kbd>data_pointer</kbd> to <kbd>data_length</kbd>.</p>
<p>Another alternative is to implement a single procedure, thus getting rid of redundant code, which would accept two parameters:</p>
<ul>
<li>The actual parameter (either a pointer to data or its size) as the assembler does not care about types</li>
<li>A selector, which will tell the procedure where the parameter value should be stored</li>
</ul>
<p>Try to implement this yourself; it would be a good quick exercise.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">GetPointers()</h1>
                
            
            
                
<p>The <kbd>GetPointers()</kbd> procedure is the only one we make public, the only one that would be visible to a dynamic or static linker, depending on the selected output target. The logic behind this procedure is primitive. It creates a structure (in this example, the structure is statically allocated), filled with the addresses of core procedures, and returns the address of this structure:</p>
<pre>GetPointers:<br/><br/>   if (ACTIVE_TARGET = TARGET_W32_OBJ) |\<br/>      (ACTIVE_TARGET = TARGET_W32_DLL) |\<br/>      (ACTIVE_TARGET = TARGET_L32_O)<br/><br/>      push dword pointers<br/>      pop eax<br/>      mov [eax], dword f_set_data_pointer<br/>      mov [eax + 4], dword f_set_data_length<br/>      mov [eax + 8], dword f_encrypt<br/>      mov [eax + 12], dword f_decrypt<br/>      ret<br/><br/>   else if (ACTIVE_TARGET = TARGET_W64_OBJ) |\<br/>           (ACTIVE_TARGET = TARGET_W64_DLL) |\<br/>           (ACTIVE_TARGET = TARGET_L64_O)<br/><br/>      push rbx<br/>      mov rbx, pointers<br/>      mov rax, rbx<br/>      mov rbx, f_set_data_pointer<br/>      mov [rax], rbx<br/>      mov rbx, f_set_data_length<br/>      mov [rax + 8], rbx<br/>      mov rbx, f_encrypt<br/>      mov [rax + 16], rbx<br/>      mov rbx, f_decrypt<br/>      mov [rax + 24], rbx<br/>      pop rbx<br/>      ret<br/><br/>   end if </pre>
<p>Once all of the preceding procedures have been added to the main source file, you may safely compile it and see that an output of the selected output format is being generated. If you leave the target specified here, you should be able to see a 32-bit windows DLL being created.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Interfacing with C/C++</h1>
                
            
            
                
<p>Let me take advantage of the topic of this chapter and say it once. Enough of the Assembly, let's do some C (for those willing to link Assembly code to C++, this C example should be easy to understand; if not--this is the wrong book). For the sake of an example, we will generate an object file out of our Assembly sources and link it with the code written in C for both 32-bit and 64-bit Windows and Linux.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Static linking - Visual Studio 2017</h1>
                
            
            
                
<p>First of all, let's see how we generate an object file. I am quite sure you have already understood how to produce different targets in general and for this example in particular. Let's begin with a 32-bit MSCOFF object file by setting the <kbd>ACTIVE_TARGET</kbd> variable to <kbd>TARGET_W32_OBJ</kbd> and compiling the main source file.</p>
<p>Create a C/C++ project in Visual Studio and copy the object file into the project directory as shown in the following screenshot (the screenshot shows object files for both 32-bit and 64-bit):</p>
<div><img class="image-border" height="166" src="img/3d49a776-9371-48ae-8395-bf2a55cee01c.png" width="371"/></div>
<p>As you can see in the preceding screenshot, there is at least one more file we need, namely the header file. Since our crypto engine is fairly simple, we do not need any complicated header files. The one shown here would definitely suffice:</p>
<div><img class="image-border" height="293" src="img/b6dc370f-0850-4d1c-80bd-72feba5642d4.png" width="306"/></div>
<p>There is a small catch in the preceding code. Try figuring out what isn't correct before you read the next paragraph.</p>
<p>Technically, the code is correct. It would compile and run without a problem, but there is one very important aspect of linking modules written in Assembly to other languages, very important and not quite obvious at the first glance:structure member alignment. In this example, we only used one structure (where we store procedure pointers) and we took proper care of it so that the pointers would be properly aligned depending on the platform. While we aligned our data on a byte boundary (stored it sequentially), Visual Studio's default structure member alignment value is, well, Default, which does not really tell us a lot. Assumptions may be made (in this case, we can assume that Default means the first option, which is a 1-byte alignment), but there is no guarantee of that and we have to explicitly specify the alignment, as assumptions not only do not always work in the case of Assembly, but they also pose a serious threat. It is important to mention that, despite the fact that we have been mentioning Visual Studio in this paragraph, the same applies to any C compiler.</p>
<p>One way to specify structure member alignment would be through the project settings, as follows:</p>
<div><img class="image-border" src="img/1c462b0e-ec69-4c68-88e6-335d602a609f.png"/></div>
<p>This is good enough for our example, but it may cause problems in the case of larger projects. It is highly recommended not to change the structure member alignment project-wide without any reasonable need for such a change. Instead, we may make a tiny modification to our header file, which would tell the compiler how to handle structure member alignment for this specific structure. Insert the following code right before the declaration of the <kbd>crypto_functions_t</kbd> structure:</p>
<pre>#ifdef WIN32                   <em>// For Windows platforms (MSVC)</em><br/>#pragma pack(push, 1)          <em>// set structure member alignment to 1</em><br/>#define PACKED                 <br/>#else                          <em>// Do the same for Unix based platforms</em> (GCC)<br/>#define PACKED  __attribute__((packed, aligned(1)))  <br/>#endif</pre>
<p>Insert the following right after the declaration:</p>
<pre>#ifdef WIN32                   <em>// For Windows platforms</em><br/>#pragma pack(pop)              <em>// Restore previous alignment settings</em><br/>#endif</pre>
<p>Now, consider the following line:</p>
<pre>}crypto_functions_t, *pcrypto_functions_t;</pre>
<p>Change the preceding line to this:</p>
<pre>}PACKED crypto_functions_t, *pcrypto_functions_t;</pre>
<p>Then, add the <kbd>main.c</kbd> file as shown in the following screenshot:</p>
<div><img class="image-border" height="233" src="img/988a72aa-6f43-4189-b431-a15b843f9a57.png" width="341"/></div>
<p>The code in the <kbd>main.c</kbd> file is more than self-explanatory. There are only two local variables; the <kbd>testString</kbd> variable represents the data we will process and <kbd>funcs</kbd> will store the pointer to the <kbd>pointers</kbd> structure in our Crypto Core.</p>
<p>Do not try to build the project yet as we have not told Visual Studio about our object file. Right-click on the project and select Properties. The following screenshot shows how to add our object file for a 64-bit platform project. The same should be done for a 32-bit project. You should just pay attention to which object file goes to which platform:</p>
<div><img class="image-border" src="img/e0fbfe62-707d-4086-8d64-800214506a65.png"/></div>
<p>In the accompanying example project, the <kbd>crypto_w64.obj</kbd> file goes to the x64 platform, and <kbd>crypto_w32.obj</kbd> is for x86.</p>
<p>You are now free to build and run the project (either x86 or x64, given that the object files are specified correctly). I would suggest setting breakpoints at lines 13 and 15 of the <kbd>main.c</kbd> file in order to be able to spot the changes in memory pointed by <kbd>testString</kbd>. While running, you would get something similar to the following (similar because the key would be different with each build of our Crypto Core):</p>
<div><img class="image-border" height="33" src="img/8a81cb37-2039-404c-882f-1835968eff7e.png" width="479"/></div>
<p>The preceding screenshot shows the data supplied to the core prior to encryption. The following screenshot shows the same data after it has been encrypted:</p>
<div><img class="image-border" height="34" src="img/d7e4ab3f-733f-4f93-8f66-eed9ecc7afd0.png" width="480"/></div>
<p>The decryption of this encrypted data would take us back to the good old <kbd>Hello, World!</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Static linking - GCC</h1>
                
            
            
                
<p>There is not much difference between Visual Studio and GCC when it comes to linking object files built from Assembly sources to high-level language code. In fact, to be completely honest, we have to admit that an object file compiled from Assembly code is not different from an object file compiled from high-level languages. In the case of GCC, we have the high-level sources (the C source and the header; no need to modify the files) and two object files, which, for the sake of convenience, we name <kbd>crypto_32.o</kbd> and <kbd>crypto_64.o</kbd>. The commands used to build executables out of our source and object files would slightly differ depending on the platform in use. If you are running a 32-bit Linux system, then you would issue the following commands in order to build 32-bit and 64-bit executables, respectively:</p>
<pre><strong>gcc -o test32 main.c crypto_32.o<br/><br/></strong><strong>gcc -o test64 main.c crypto_64.o -m64</strong></pre>
<p>The second command would only work if you have 64-bit development tools/libraries installed.</p>
<p>If you are running a 64-bit system, then you make a slight change to the commands (and take care of the 32-bit development tools and libraries being installed):</p>
<pre><strong>gcc -o test32 main.c crypto_32.o -m32</strong></pre>
<p>And:</p>
<pre><br/><strong>gcc -o test64 main.c crypto_64.o</strong></pre>
<p>Inspecting the memory content with GDB while running one of the <kbd>testxx</kbd> files would provide you with a picture similar to the following screenshot before encryption:</p>
<div><img class="image-border" height="30" src="img/0dc58d05-4366-451e-819b-9aee957b53cf.png" width="588"/></div>
<p>And after encryption, you will see something like the following:</p>
<div><img class="image-border" height="28" src="img/a0ad54b9-bdc4-4882-a175-6a8420ef5702.png" width="589"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Dynamic linking</h1>
                
            
            
                
<p>Dynamic linking implies the use of dynamic link libraries (on Windows) or shared objects (on Linux) and is the same as with other DLLs/SOs. The mechanism of dynamic linking will be briefly covered in the next chapter.</p>
<p>We will, however, build dynamic link libraries and shared objects right now in order to be able to proceed further. Compile the <kbd>crypto.asm</kbd> file, setting the <kbd>ACTIVE_TARGET</kbd> compile-time variable to <kbd>TARGET_W32_DLL</kbd> in order to generate a 32-bit DLL for Windows, and then to <kbd>TARGET_W64_DLL</kbd> in order to generate a 64-bit DLL. Keep in mind the fact that changing <kbd>ACTIVE_TARGET</kbd> does not affect the name of the output, so we would have to rename the result of each compilation accordingly.</p>
<p>While on Windows you have to simply change the <kbd>ACTIVE_TARGET</kbd> compile-time variable and compile by going to Run | Compile in the GUI (or hit <em>Ctrl</em> + <em>F9</em> on the keyboard), you would have to build object files for Linux and then enter another command in a terminal when on Linux. The command would be one of these:</p>
<pre><em># For 64-bit output on 64-bit machine</em><br/><strong>gcc -shared crypto_64.o -o libcrypto_64.so</strong><br/><br/><em># For 64-bit output on 32-bit machine</em><br/><strong>gcc -shared crypto_64.o -o libcrypto_64.so -m64</strong><br/><br/><em># For 32-bit output on 64-bit machine</em><br/><strong>gcc -shared crypto_32.o -o libcrypto_32.so -m32</strong><br/><br/><em># For 32-bit output on 32-bit machine</em><br/><strong>gcc -shared crypto_32.o -o libcrypto_32.so</strong></pre>
<p>Having DLLs for Windows and shared objects for Linux, we are now safe to proceed further and see how modules written in Assembly may be integrated with frameworks such as .NET.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Assembly and managed code</h1>
                
            
            
                
<p>As we have already seen, static or dynamic linking is not as difficult as it may seem, as long as we are dealing with native code, but what happens when we, for example, decide to use code written in Assembly with a program written in C#, which is a managed environment and is not run by the processor itself, but rather by a sort of a virtual machine? Many are afraid of mixing native modules and managed ones. Using native modules compiled from Assembly sources with managed code may seem to be even more frightening or even impossible. However, as we have seen earlier, there is no difference between modules initially written in Assembly and those written in other languages on the binary level. When it comes to managed code like, for example C#, things are just a bit more complex than linking to native object files or using a DLL/SO. The following does not apply to managed C++ code, in which case you may simply follow the steps discussed earlier in this chapter, in order to link a native object to managed code, as managed C++ is the only language supported by Visual Studio that provides such capability.</p>
<p>In the case of C#, however, we are limited to DLL/SO as C# is a pure managed environment without the ability to digest native code in the form of an object file. In such a case, there is a need for a sort of a shim code, an adapter. In our example, we will use a simple class, which imports our core's functionality from <kbd>crypto_wxx.dll</kbd> on Windows or from <kbd>libcrypto_xx.so</kbd> on Linux and exposes it through its methods to the rest of the code.</p>
<p>There is a common misbelief that the .NET platform is Windows-specific. Alas, this is too common. However, .NET platform is, in reality, almost as portable as Java and supports quite a selection of platforms. However, we will concentrate on Windows (32/64-bits) and Linux (32/64-bits).</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Native structure versus managed structure</h1>
                
            
            
                
<p>The first thing we would run into, when attempting to tie something similar to the implementation of our core's interface to a platform such as .NET, is the way data is passed between managed code and native code. There's hardly any possibility for managed and native code to access the same memory areas. It is not impossible, but definitely is not healthy, hence we would have to pass data between the two domains--the managed domain and native domain. Luckily, there is a class in the .NET framework that allows us to perform such operations relatively painlessly--<kbd>System.Runtime.InteropServices.Marshal</kbd>. Since we are using a pointer to a structure containing pointers to exported procedures, we need to implement a managed structure to be used with our .NET crypto class and this is done in a rather simple manner:</p>
<pre><em>// First of all, we tell the compiler how members of the</em><br/><em>//struct are stored in memory and alignment thereof</em><br/>[StructLayout(LayoutKind.Sequential, Pack=1)]<br/><br/><em>// Then we implement the structure itself</em><br/>internal struct Funcs<br/>{<br/>   internal IntPtr f_set_data_pointer;<br/>   internal IntPtr f_set_data_length;<br/>   internal IntPtr f_encrypt;<br/>   internal IntPtr f_decrypt;<br/>}</pre>
<p>The preceding code perfectly declares the type of structure we need and we may get to implement the crypto class. Although the implementation of misbelief C# class falls way beyond the scope of this book, it seems appropriate to dedicate a few lines to a definition of methods and delegates in this case.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Importing from DLL/SO and function pointers</h1>
                
            
            
                
<p>Interoperability in .NET is an interesting topic, but it would be much better to refer to proper resources dedicated to it. Here, we will only consider .NET's analogs of function pointers and misbelief dynamic importing of functions exported by DLLs and shared objects. But, first, let's construct the class, import the <kbd>GetPointers()</kbd> procedure, and define function pointer delegates:</p>
<pre>internal class Crypto<br/>{<br/>   Funcs  functions;<br/>   IntPtr buffer;<br/>   byte[] data;<br/><br/>   <em>// The following two lines make up the properties of the class</em><br/>   internal byte[] Data { get { return data; } }<br/>   internal int Length { get { return data.Length; } }<br/>   <br/>   <em>// Declare binding for GetPointers()</em><br/><em>   // The following line is written for 64-bit targets, you should </em><br/><em>   // change the file name to crypto_32.so when building for</em><br/><em>   // 32-bit systems.<br/>   // Change the name to crypto_wXX.dll when on Windows, where XX </em><br/><em>   // stands for 32 or 64.</em><br/>   [DllImport("crypto_64.so", CallingConvention = CallingConvention.Cdecl)]<br/>   internal static extern IntPtr GetPointers();<br/><br/>   <em>// Declare delegates (our function pointers)</em><br/>   [UnmanagedFunctionPointer(CallingConvention.Cdecl)]<br/>   internal delegate void dSetDataPointer(IntPtr p);<br/><br/>   [UnmanagedFunctionPointer(CallingConvention.Cdecl)]<br/>   internal delegate void dSetDataSize(int s);<br/><br/>   [UnmanagedFunctionPointer(CallingConvention.Cdecl)]<br/>   internal delegate void dEncrypt();<br/><br/>   [UnmanagedFunctionPointer(CallingConvention.Cdecl)]<br/>   internal delegate void dDecrypt();<br/><br/>   <em>// Constructor</em><br/>   internal Crypto()<br/>   {<br/>      <em>// Luckily when we get a pointer to structure by calling </em><br/><em>      // GetPointers() we do not have to do more than just let </em><br/><em>      // the framework convert native structure to managed one</em><br/>      functions = (Funcs)Marshal.PtrToStructure(<br/>         GetPointers(), <br/>         typeof(Funcs));<br/><br/>      <em>// Set initial buffer ptr</em><br/>      buffer = IntPtr.Zero;<br/>   }<br/><br/>   <em>// SetDataPointer() method is the most complex one in our class, </em><br/><em>   // as it includes invocation of SetDataLength()</em><br/>   internal void SetDataPointer(byte[] p)<br/>   {<br/>      <em>// If an unmanaged buffer has been previously allocated,</em><br/><em>      // then we need to free it first.</em><br/>      if(IntPtr.Zero != buffer)<br/>         Marshal.FreeHGlobal(buffer);<br/>      buffer = Marshal.AllocHGlobal(p.Length);<br/><br/>      <em>// Copy data to both the local storage and unmanaged buffer</em><br/>      data = new byte[p.Length];<br/>      Array.Copy(p, data, p.Length);<br/>      Marshal.Copy(p, 0, buffer, p.Length);<br/><br/>      <em>// Call f_set_data_pointer with a pointer to unmanaged buffer</em><br/>      ((dSetDataPointer) Marshal.GetDelegateFromFunctionPointer(<br/>         functions.f_set_data_pointer, <br/>         typeof(dSetDataPointer)))(buffer);<br/><br/>      <em>// Tell the core what the length of the data buffer is</em><br/>      ((dSetDataSize) Marshal.GetDelegateFromFunctionPointer(<br/>         functions.f_set_data_length, <br/>         typeof(dSetDataSize)))(p.Length);<br/>   }<br/><br/>   <em>// The remaining two methods are more than simple</em><br/>   internal void Encrypt()<br/>   {<br/>      // Encrypt the data in the unmanaged buffer and copy it <br/>      // to local storage<br/>      ((dEncrypt)Marshal.GetDelegateFromFunctionPointer(<br/>         functions.f_encrypt, <br/>         typeof(dEncrypt)))();<br/>      Marshal.Copy(buffer, data, 0, data.Length);<br/>   }<br/><br/>   internal void Decrypt()<br/>   {<br/>      // Decrypt the data in the unmanaged buffer and copy it<br/>      // to local storage<br/>      ((dDecrypt)Marshal.GetDelegateFromFunctionPointer(<br/>         functions.f_decrypt, <br/>         typeof(dDecrypt)))();<br/>      Marshal.Copy(buffer, data, 0, data.Length);<br/>   }<br/>}</pre>
<p>The preceding code is for the Linux version; however, it may easily be changed to the Windows version by changing the name of the shared object to the name of a DLL. With this class, working with our Crypto Core is rather simple and may be summarized by the following code:</p>
<pre>Crypto c = new Crypto();<br/>string message = "This program uses \"Crypto Engine\" written in Assembly language.";<br/>c.SetDataPointer(ASCIIEncoding.ASCII.GetBytes(message);<br/>c.Encrypt();<br/>c.Decrypt();</pre>
<p>However, despite the fact that, if we implement the preceding class and try to use it in our code, it would compile well, we are still unable to actually run it. This is because we need to supply the DLL or shared object, depending on the platform of our choice. The easiest way to supply the libraries is to copy them into the solution folder and tell the IDE (Visual Studio or Monodevelop) to handle them properly.</p>
<p>The first step is to copy the libraries (DLLs on Windows and SOs on Linux) into the project folder. The following screenshot shows the Monodevelop project folder on Linux, but the procedure is just the same for both Linux and Windows:</p>
<div><img class="image-border" src="img/f74210ea-23ec-4561-9ab5-8b524735bbcf.png"/></div>
<p>The next step would be to actually tell the IDE how to treat these files. First, add them to the project by right-clicking on the project and then navigating to Add | Existing Item for Visual Studio or Add | Add Files for Monodevelop, and then set the properties for each of the libraries as shown in the following screenshots.</p>
<p class="mce-root">To set the properties in Visual Studio:</p>
<div><img class="image-border" src="img/a71c3698-b647-43ab-8dda-1bc8b7b689d6.png"/></div>
<p class="mce-root">To set the properties in Monodevelop:</p>
<div><img class="image-border" src="img/c5d7916b-8acf-4f11-92b7-10c9230638ba.png"/></div>
<p>Although the GUI is different, both need to have Build Action set to Content and Copy to Output Directory set to Copy always in Visual Studio and checked in Monodevelop.</p>
<p>Now we can build out project (either on Windows or Linux) and run it. We may either watch the data being encrypted/decrypted in memory or add a tiny function that would print out the content of memory within a specific range.</p>
<p>If everything is set up correctly, then the output should be similar to the following when on Windows:</p>
<div><img class="image-border" height="164" src="img/262b1def-d9f0-4b1e-86a3-824b72fabaf9.png" width="516"/></div>
<p class="mce-root">The output on Linux would be similar to this:</p>
<div><img class="image-border" height="319" src="img/0e4bdbf1-efab-45c3-a61a-012875cb0d64.png" width="455"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p class="mce-root">In this chapter, we covered just a few aspects of interfacing your Assembly code to the outer world. There are numerous programming languages out there; however, a decision was taken to concentrate on C/C++ and the .NET platform as the best way to illustrate how modules written in Assembly language may be bound to the code written in high-level languages. To put it simply, any language that is compiled into native code would use the same mechanism as C and C++; on the other hand, any .NET-like platform, although, having a platform-specific binding mechanism, would use the same approach on a low level.</p>
<p>However, I assume that there is one question hanging in the air. How about linking third-party code to our Assembly program? Although the title of this chapter may have implied that this topic is included, it would make much more sense to cover it in the next chapter as the only thing we will be dealing with is using third-party code with our programs written in the Assembly language.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    </body></html>