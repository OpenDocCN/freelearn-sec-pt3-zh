<html><head></head><body>
		<div><h1 id="_idParaDest-151" class="chapter-number"><a id="_idTextAnchor153"/>10</h1>
			<h1 id="_idParaDest-152"><a id="_idTextAnchor154"/>Secure Coding Practices for APIs</h1>
			<p>Welcome to the end of our book, which matches the beginning of your <strong class="bold">Application Programming Interface</strong> (<strong class="bold">API</strong>) pentesting journey! If you’ve been reading this book from <a href="B19657_01.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>, we’ve been together for quite a while, covering and learning about different aspects of APIs in their most diverse forms, sticking with penetration techniques but still having an eye on what application owners and developers should pay attention to before releasing their APIs. An API opens the door of applications, services, and entire businesses to the world. This door represents an immense responsibility for a software and is surely extensible for all the infrastructure that supports it.</p>
			<p>The upcoming sections bring recommendations when coding to build APIs. You will find tips and practices in some modern programming languages and technologies, the ones that are more applied when creating APIs: Golang, GraphQL, Java, JavaScript, and Python. All major problems that were tackled in this book are covered. As you may already know, security is about layered protection. There’s no one-size-fits-all. We should pay attention to the eventual attack surface we are creating when coding.</p>
			<p>This book is about attacking, but it’s ethical enough to discuss the prevention of attacks too. It doesn’t hurt to say that. At the end of the day, we are security professionals, and our main intent is to reinforce the software we are testing for the sake of reducing the chances of an invasion or data leakage.</p>
			<p>In this chapter, we’re going to cover the following topics:</p>
			<ul>
				<li>The importance of secure coding practices</li>
				<li>Implementing secure authentication mechanisms</li>
				<li>Validating and sanitizing user input</li>
				<li>Implementing proper error handling and exception management</li>
				<li>Best practices for data protection and encryption</li>
			</ul>
			<h1 id="_idParaDest-153"><a id="_idTextAnchor155"/>Technical requirements</h1>
			<p>As we are not going to do any practical exercise in this chapter, there are no technical requirements. If you, however, feel compelled to put the code into practice, be my guest. As the saying goes, practice makes perfect. Just go for it and enjoy it.</p>
			<h1 id="_idParaDest-154"><a id="_idTextAnchor156"/>The importance of secure coding practices</h1>
			<p>I’m not trying to teach your grandmother to suck eggs. Not at all. However, as I like to say in person and while writing this book, it never hurts to emphasize concepts and ideas that are paramount to something. Putting API-secure coding into practice is important because of the intricate<a id="_idIndexMarker708"/> and complex role APIs play in software development. They act as links between diverse applications and services, making them able to talk to each other and exchange data. This feature-rich scenario results in a situation in which the vulnerabilities embedded in some API may be explored (or, as is most commonly said, exploited), allowing unauthorized data access, privilege escalation, service disruption, or system criminal ownership, and sometimes resulting in data ransom. Thus, secure coding practices aid in mitigating these risks by increasing API<a id="_idIndexMarker709"/> robustness against common threats, such as injection (SQL or NoSQL), <strong class="bold">Cross-site Scripting</strong> (<strong class="bold">XSS</strong>), and <strong class="bold">Man-in-the-middle</strong> (<strong class="bold">MitM</strong>).</p>
			<p>Moreover, these practices<a id="_idIndexMarker710"/> collaborate to sustain the business’ trust and reputation among its customers. Nowadays, data leaks and security incidents may impose significant damages on companies, which include but are not limited to financial losses, legal penalties (some due to compliance mechanisms), and cracks in the company’s reputation. Customers and regular users expect not only that the services provided by APIs work smoothly and are always available but also that their data is correctly handled and protected.</p>
			<p>There are some secure coding methodologies that can be adopted by companies to help them establish a decent <strong class="bold">Software Development Life Cycle</strong> (<strong class="bold">SDLC</strong>). If you haven’t heard about this yet, it’s just a process that is<a id="_idIndexMarker711"/> applicable when software is being developed. Such a process has stages, such as planning, designing, coding, testing, deployment, and maintenance. With the help of an SDLC, the software progresses in each of the phases, which increases the efficiency of project management as well as producing high-quality software as a result. Here, you find a humble list of SDLC methodologies:</p>
			<ul>
				<li><strong class="bold">Building Security in Maturity Model</strong> (<strong class="bold">BSIMM</strong>): Originally a 	part of the <strong class="bold">Software Assurance Maturity Model</strong> (<strong class="bold">SAMM</strong>), BSIMM has transitioned from offering prescriptive guidance to taking a <a id="_idIndexMarker712"/>descriptive approach and is regularly updated to reflect the latest best practices. Rather than suggesting specific actions, BSIMM outlines the activities and practices of its member organizations. More information can be found at <a href="https://www.synopsys.com/glossary/what-is-bsimm.html">https://www.synopsys.com/glossary/what-is-bsimm.html</a>.</li>
				<li><strong class="bold">Microsoft Secure Development Life Cycle</strong> (<strong class="bold">SDL</strong>): This prescriptive approach addresses a wide<a id="_idIndexMarker713"/> range of security concerns and offers organizations guidance on achieving more<a id="_idIndexMarker714"/> secure coding practices. It assists in developing software that complies with regulatory standards and helps reduce costs. More information can be found at <a href="https://www.microsoft.com/en-us/securityengineering/sdl">https://www.microsoft.com/en-us/securityengineering/sdl</a>.</li>
				<li><strong class="bold">OWASP Software Assurance Maturity Model</strong> (<strong class="bold">SAMM</strong>): SAMM is an open source initiative that uses <a id="_idIndexMarker715"/>a prescriptive methodology to incorporate security into the SDLC. It is maintained by OWASP and benefits from contributions by companies of various sizes and sectors. More information can be found at <a href="https://owasp.org/www-project-samm/">https://owasp.org/www-project-samm/</a>.</li>
			</ul>
			<p>Demonstrating a commitment to security through rigorous coding practices can help build and maintain trust with stakeholders. It also shows regulatory bodies that the company is serious about compliance with data protection laws and industry standards, which can prevent legal issues down the line. Another helpful resource is the OWASP Developer Guide (<a href="https://owasp.org/www-project-developer-guide/">https://owasp.org/www-project-developer-guide/</a>), which provides a fairly complete list of definitions and guidelines on how to generally increase code security. When this book was being written, the guide was on version <code>4.1.0</code>. Of course, do not ever forget to check the OWASP Top Ten API, which is available at <a href="https://owasp.org/API-Security/editions/2023/en/0x11-t10/">https://owasp.org/API-Security/editions/2023/en/0x11-t10/</a>. The current release is from 2023 and it details the ten most dangerous threats to APIs. We discussed them in <em class="italic">Chapters 1</em> and <em class="italic">3</em>.</p>
			<p>Lastly, secure coding practices help ensure the long-term sustainability and scalability of software systems. As applications grow and evolve, maintaining a secure foundation becomes increasingly complex. Early adoption of secure coding practices helps create a culture of security within development teams, making it easier to identify and fix vulnerabilities before they become significant issues. This proactive approach to security can save time and <a id="_idIndexMarker716"/>resources by reducing the need for extensive security patches and mitigating the impact of potential security breaches. In turn, this leads to more stable, resilient applications that can adapt to new challenges and threats in the ever-evolving digital landscape. Let’s start discussing the various relevant topics.</p>
			<h1 id="_idParaDest-155"><a id="_idTextAnchor157"/>Implementing secure authentication mechanisms</h1>
			<p>We covered attacks on secure authentication mechanisms in <a href="B19657_04.xhtml#_idTextAnchor056"><em class="italic">Chapter 4</em></a>. Authentication is a crucial component of API security, ensuring that only authorized users can access protected resources. Implementing secure<a id="_idIndexMarker717"/> authentication mechanisms requires careful consideration of various factors. For instance, using strong, unique passwords and hashing them with modules such as <code>bcrypt</code> in Python can significantly enhance security. Avoid storing passwords in plaintext or using weak hashing algorithms such as MD5. In Java, libraries such as Spring Security provide robust authentication mechanisms, including support for OAuth2 and JWTs. An insecure implementation might directly accept user credentials and return a token without<a id="_idIndexMarker718"/> proper validation, making it vulnerable to attacks. Instead, developers should enforce <code>bcrypt</code>:</p>
			<pre class="source-code">
# Insecure implementation
password = request.form['password']
user = authenticate(username, password)
# A more secure way of doing things
from bcrypt import hashpw, gensalt
password = request.form['password']
hashed_password = hashpw(password.encode('utf-8'), gensalt())
user = authenticate(username, hashed_password)</pre>			<p>In JavaScript, especially in Node.js environments, using libraries such as <code>Passport.js</code> can help manage authentication effectively. However, ensure that tokens are stored securely, preferably using <code>HttpOnly</code> cookies, to prevent XSS attacks. Similarly, in Golang, using middleware such as <code>gorilla/sessions</code> to handle session management securely is advisable. Flaws in authentication mechanisms often arise from improper session management or<a id="_idIndexMarker719"/> insecure token storage. Developers should ensure that tokens are rotated regularly and that sessions have a timeout to mitigate the risk of session hijacking. In GraphQL, make sure to limit the query complexity and depth to prevent abuse. Failing to do this might expose sensitive user details in error messages, which should be sanitized and kept minimal. The following JavaScript code replaces an insecure way of storing tokens by applying httpOnly:</p>
			<pre class="source-code">
// Insecure way of storing token in local storage
localStorage.setItem('token', token);
// Secure way of doing the same, but with HttpOnly cookies
res.cookie('token', token, { httpOnly: true, secure: true });</pre>			<p>In the next section, we’ll talk about how to properly manipulate user input.</p>
			<h1 id="_idParaDest-156"><a id="_idTextAnchor158"/>Validating and sanitizing user input</h1>
			<p>We covered attacks leveraging user input in <a href="B19657_05.xhtml#_idTextAnchor078"><em class="italic">Chapter 5</em></a>. Validating and sanitizing user input is paramount to prevent injection attacks, such as SQL injection, XSS, and command injection. In Python, frameworks <a id="_idIndexMarker720"/>such as <code>Django</code> and <code>Flask</code> provide built-in<a id="_idIndexMarker721"/> validation tools, but developers must ensure that they use them correctly. For instance, relying on raw SQL queries without parameterized inputs can lead to SQL injection. Instead, use <strong class="bold">Object Relational Mapper</strong> (<strong class="bold">ORM</strong>) methods that automatically handle parameterization. The Python code that follows shows the<a id="_idIndexMarker722"/> slight difference of using parameters:</p>
			<pre class="source-code">
# How you do an insecure SQL query
cursor.execute("SELECT * FROM users WHERE id = '%s'" % user_id)
# A secure approach by using parameterized queries
cursor.execute("SELECT * FROM users WHERE id = %s", (user_id,))</pre>			<p>In Java, using<a id="_idIndexMarker723"/> libraries such as <code>Hibernate</code> can help prevent injection attacks by utilizing <strong class="bold">Hibernate Query Language</strong> (<strong class="bold">HQL</strong>) or <strong class="bold">Java Persistence Query Language</strong> (<strong class="bold">JPQL</strong>), which are <a id="_idIndexMarker724"/>inherently safe when <a id="_idIndexMarker725"/>used properly. However, developers must <a id="_idIndexMarker726"/>avoid concatenating strings to build queries. The Java excerpt that follows applies parameterized queries with HQL replacing the original or insecure query:</p>
			<pre class="source-code">
// When you concatenate strings for SQL queries, you make them insecure
String query = "SELECT * FROM users WHERE id = " + userId;
List&lt;User&gt; users = entityManager.createNativeQuery(query, User.class).getResultList();
// Prefer instead using parameterized queries with HQL, for example
String query = "FROM User WHERE id = :userId";
List&lt;User&gt; users = entityManager.createQuery(query, User.class)
    .setParameter("userId", userId)
    .getResultList();</pre>			<p>In JavaScript, especially with Node.js, developers should use ORM libraries such as <code>Sequelize</code> or <code>Mongoose</code>, which support parameterized queries. Additionally, input validation libraries such as <code>Joi</code> can help enforce schema validation. However, a common mistake is failing to validate input from all sources, including headers, cookies, and query parameters. Look at the snippet that follows, which shows how to create a parameterized query with <code>Sequelize</code>:</p>
			<pre class="source-code">
// This is insecure since it directly applies the user input
const userId = req.params.userId;
User.find({ where: { id: userId } });
// This is a parameterized query with Sequelize
const userId = req.params.userId;
User.find({ where: { id: Sequelize.literal('?'), replacements: [userId] } });</pre>			<p>Golang developers should use libraries such as <code>validator</code> to enforce strict input validation rules. For example, a <a id="_idIndexMarker727"/>flawed input validation might accept unchecked user input <a id="_idIndexMarker728"/>directly into the application logic, leading to potential vulnerabilities. Instead, sanitize and validate all inputs rigorously before processing them. The following code uses Golang’s <code>sql</code> package to send a parameterized query to a database. The <code>db</code> variable is generated from this package as well (with <code>sql.Open()</code>). The difference is quite subtle in the eyes of an attentive reader (or human security auditor) but it is impactful in the final result:</p>
			<pre class="source-code">
// Insecure: Directly using user input
userId := r.URL.Query().Get("user_id")
db.Query("SELECT * FROM users WHERE id = " + userId)
// Secure: Using parameterized queries with sql package
userId := r.URL.Query().Get("user_id")
db.Query("SELECT * FROM users WHERE id = ?", userId)</pre>			<p>GraphQL poses unique challenges for input validation due to its flexible query structure. Developers should define strict schemas and use validation middleware to ensure that only valid inputs are processed. For instance, an insecure GraphQL endpoint might accept arbitrary inputs, leading to resource exhaustion or other attacks. By enforcing strict type definitions and validation rules, developers can mitigate these risks effectively. The next JavaScript excerpt compares an insecure strategy with a secure one. Observe how <code>user</code> is internally <a id="_idIndexMarker729"/>defined with the help of a <a id="_idIndexMarker730"/>middleware:</p>
			<pre class="source-code">
// The insecure way: not validating input in GraphQL resolver
const resolvers = {
  Query: {
    user: (parent, args) =&gt; User.findById(args.id),
  },
};
// Here we make use of GraphQL middleware to reinforce protection
const { GraphQLObjectType, GraphQLString } = require('graphql');
const { GraphQLSchema, validateSchema } = require('graphql');
const userType = new GraphQLObjectType({
  name: 'User',
  fields: {
    id: { type: GraphQLString },
    name: { type: GraphQLString },
  },
});
const queryType = new GraphQLObjectType({
  name: 'Query',
  fields: {
    user: {
      type: userType,
      args: {
        id: { type: GraphQLString },
      },
      resolve: (parent, args) =&gt; {
        if (!args.id.match(/^[0-9a-fA-F]{24}$/)) {
          throw new Error('Invalid user ID format');
        }
        return User.findById(args.id);
      },
    },
  },
});
const schema = new GraphQLSchema({ query: queryType });
validateSchema(schema);</pre>			<p>In the next section, you’ll learn<a id="_idIndexMarker731"/> the best practices for how to correctly handle errors and <a id="_idIndexMarker732"/>exceptions.</p>
			<h1 id="_idParaDest-157"><a id="_idTextAnchor159"/>Implementing proper error handling and exception management</h1>
			<p>We covered attacks with bad error and exception handling in <a href="B19657_06.xhtml#_idTextAnchor102"><em class="italic">Chapter 6</em></a>. Proper error handling and exception management are critical for maintaining the security and stability of APIs. In Python, developers should use <code>try-except</code> blocks to handle exceptions gracefully and avoid<a id="_idIndexMarker733"/> exposing stack traces to the client. A common flaw is returning detailed error messages that reveal internal logic, which can be exploited by attackers. Instead, provide generic error messages and log detailed errors server-side. Do not forget to rotate and encrypt such logs. Also, restrict access to the logs only to people and applications that have legitimate reasons. The following code block shows two ways of handling exceptions:</p>
			<pre class="source-code">
# Here you expose stack traces. Bad!
try:
    user = User.get(user_id)
except Exception as e:
    return str(e)
# Here you treat and hide internal error details
try:
    user = User.get(user_id)
except Exception as e:
    log.error(f"Error retrieving user: {e}")
    return "An error occurred"</pre>			<p>Java developers can leverage the equivalent <code>try-catch</code> blocks and custom exception-handling mechanisms provided by frameworks such as <code>Spring</code> to manage errors securely. Avoid exposing<a id="_idIndexMarker734"/> sensitive information in exception messages and use logging frameworks such as <code>Logback</code> or <code>SLF4J</code> to log errors securely. The implementation that follows is equivalent to the previous one, but in Java, it is as follows:</p>
			<pre class="source-code">
// Do not expose internal details
try {
    User user = userService.findUserById(userId);
} catch (Exception e) {
    return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(e.getMessage());
}
// Instead, treat them and hide them
try {
    User user = userService.findUserById(userId);
} catch (Exception e) {
    log.error("Error retrieving user", e);
    return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body("An error occurred");
}</pre>			<p>In JavaScript, using global error handling middleware in <code>Express.js</code> can help catch unhandled exceptions and prevent application crashes. However, a common mistake is logging errors directly to the <a id="_idIndexMarker735"/>console, which can be a security risk. Instead, use secure logging mechanisms and ensure that logs do not contain sensitive information. Look at how this could be implemented:</p>
			<pre class="source-code">
// Do not log errors directly to the console
app.use((err, req, res, next) =&gt; {
  console.error(err.stack);
  res.status(500).send(err.message);
});
// Instead, prefer a logging library and hide error details
const winston = require('winston');
const logger = winston.createLogger({
  transports: [new winston.transports.File({ filename: 'error.log' })],
});
app.use((err, req, res, next) =&gt; {
  logger.error(err.stack);
  res.status(500).send('An error occurred');
});</pre>			<p>Golang developers should use <strong class="bold">defer-recover patterns</strong> to handle panics and ensure that the application does not <a id="_idIndexMarker736"/>crash unexpectedly. For example, an insecure implementation might panic and expose sensitive data in the response. By recovering from panics and returning a generic error message, developers can enhance security. Observe in the next code snippet<a id="_idIndexMarker737"/> two ways of using a deferred function. They show how panic messages are generated:</p>
			<pre class="source-code">
// Insecure way: Allowing panic to expose sensitive data
func handler(w http.ResponseWriter, r *http.Request) {
    defer func() {
        if err := recover(); err != nil {
            fmt.Fprintf(w, "An error occurred: %v", err)
        }
    }()
    // Put here some code that could panic
}
// Secure way: Recovering from panic and hiding internal details
func handler(w http.ResponseWriter, r *http.Request) {
    defer func() {
        if err := recover(); err != nil {
            log.Printf("Recovered from panic: %v", err)
            http.Error(w, "An error occurred", http.StatusInternalServerError)
        }
    }()
    // Put here some code that could panic
}</pre>			<p>Finally, in GraphQL, error handling should be implemented carefully to avoid revealing internal schema details. Use custom error classes and middleware to catch and handle errors gracefully. An insecure GraphQL implementation might return detailed error messages that expose field names <a id="_idIndexMarker738"/>or other schema details, making it easier for attackers to craft malicious queries. By implementing proper error handling and sanitizing error messages, developers can protect their APIs from exploitation. The JavaScript code follows:</p>
			<pre class="source-code">
// Insecure form: Exposing detailed error messages in GraphQL
const resolvers = {
  Query: {
    user: (parent, args) =&gt; {
      throw new Error('Detailed error message with internal information');
    },
  },
};
// Secure form: Using custom error classes and middleware
class UserError extends Error {
  constructor(message) {
    super(message);
    this.name = 'UserError';
  }
}
const resolvers = {
  Query: {
    user: (parent, args) =&gt; {
      try {
        // Put here some code that may throw an error
      } catch (error) {
        throw new UserError('An error occurred');
      }
    },
  },
};</pre>			<p>In the next section, we’ll <a id="_idIndexMarker739"/>discuss the best practices for data protection.</p>
			<h1 id="_idParaDest-158"><a id="_idTextAnchor160"/>Best practices for data protection and encryption</h1>
			<p>We covered attacks accessing data in unauthorized ways in <a href="B19657_08.xhtml#_idTextAnchor131"><em class="italic">Chapter 8</em></a>. Data protection and encryption are <a id="_idIndexMarker740"/>essential for securing sensitive information transmitted via APIs. In Python, using libraries such as <code>cryptography</code> to encrypt data at rest and in transit is crucial. For instance, encrypting sensitive information such as passwords and personal data before storing it in the database can prevent unauthorized access. Observe the following code that applies the <code>cryptography</code> library to make use of Fernet tokens and keys:</p>
			<pre class="source-code">
# The wrong way: Storing sensitive data without encryption
user_data = {'ssn': '123-45-6789'}
database.store(user_data)
# The correct way: Encrypting sensitive data before storing
from cryptography.fernet import Fernet
key = Fernet.generate_key()
cipher_suite = Fernet(key)
encrypted_ssn = cipher_suite.encrypt(b'123-45-6789')
user_data = {'ssn': encrypted_ssn}
database.store(user_data)</pre>			<p>In Java, leveraging the <strong class="bold">Java Cryptography Architecture</strong> (<strong class="bold">JCA</strong>) provides robust encryption mechanisms. However, developers<a id="_idIndexMarker741"/> must avoid using outdated encryption algorithms such as DES or RC4. Instead, it’s better to use modern algorithms such as AES with appropriate key management practices. Observe the example that follows:</p>
			<pre class="source-code">
// Insecure: Using flawed encryption algorithm
Cipher cipher = Cipher.getInstance("DES");
SecretKey key = KeyGenerator.getInstance("DES").generateKey();
cipher.init(Cipher.ENCRYPT_MODE, key);
// Secure: Using a more robust encryption algorithm (AES)
Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding");
SecretKey key = KeyGenerator.getInstance("AES").generateKey();
cipher.init(Cipher.ENCRYPT_MODE, key, new GCMParameterSpec(128, iv));</pre>			<p>JavaScript developers should <a id="_idIndexMarker742"/>use libraries such as <code>crypto</code> in Node.js to implement encryption and decryption routines securely. For example, an insecure implementation might use hardcoded encryption keys or weak algorithms. Instead, use environment variables to store keys securely and implement key rotation policies. Look at the following code:</p>
			<pre class="source-code">
// Hardcoding encryption keys (bad!)
const crypto = require('crypto');
const key = 'hardcodedkey123';
const cipher = crypto.createCipher('aes-256-cbc', key);
// Using environment variables for encryption key (better!)
const key = process.env.ENCRYPTION_KEY;
const cipher = crypto.createCipher('aes-256-cbc', key);</pre>			<p>In the preceding snippet, the JavaScript code leverages environment variables to store some sensitive data. Such data may be controlled by a <code>.env</code> file, which is an approach followed by many modern programming languages. This file simply has associations between variables and their contents and usually lies in the very same directory where the source code is. Of course, it’s not the best solution whatsoever, but it’s definitely better than hardcoding the key into the logic. Another solution when you have a secrets manager at hand (either a local one or a service provided by a public cloud player) is to store all sensitive data there and then. This can be done using an ephemeral session by assuming a role with the necessary permissions; you simply access such a manager and then retrieve the data.</p>
			<p>In Golang, using packages such as <code>crypto/aes</code> for encryption and ensuring proper key management can enhance data security. A common flaw is failing to secure keys or using weak keys, which can be<a id="_idIndexMarker743"/> mitigated by following the best practices for key management. The excerpt that follows demonstrates what is being said:</p>
			<pre class="source-code">
// Insecure: Using weak encryption key
block, err := aes.NewCipher([]byte("weakkey12345678"))
if err != nil {
    panic(err)
}
// Secure: Using strong encryption key
key := []byte("strongkey12345678901234567890")
block, err := aes.NewCipher(key)
if err != nil {
    panic(err)
}</pre>			<p>GraphQL poses unique challenges for data protection, especially when dealing with sensitive queries and mutations. Implementing field-level encryption and ensuring that sensitive data is encrypted before being returned in responses is crucial. For instance, an insecure GraphQL implementation might return sensitive data without encryption, exposing it to potential interception. By encrypting sensitive fields and using secure transport protocols such as HTTPS, developers can protect data effectively. The following JavaScript block <a id="_idIndexMarker744"/>shows how to return sensitive data only after correctly encrypting it:</p>
			<pre class="source-code">
// Bad way: Returning sensitive data without encryption
const resolvers = {
  Query: {
    user: (parent, args) =&gt; {
      return User.findById(args.id);
    },
  },
};
// Right way: Encrypting sensitive data before returning
const crypto = require('crypto');
const secret = process.env.SECRET_KEY;
const resolvers = {
  Query: {
    user: async (parent, args) =&gt; {
      const user = await User.findById(args.id);
      user.ssn = crypto.createHmac('sha256', secret)
                       .update(user.ssn)
                       .digest('hex');
      return user;
    },
  },
};</pre>			<p>In conclusion, secure coding practices for APIs are fundamental to building robust and secure APIs and applications. By implementing secure authentication mechanisms, validating and sanitizing user input, handling errors properly, and protecting data through encryption, developers can significantly enhance the security of their APIs. These practices, combined with continuous security testing and monitoring, can help mitigate risks and protect sensitive information from potential threats.</p>
			<p>As we’ve seen several times in this book, there’s no one-size-fits-all solution. No single technique or principle will <a id="_idIndexMarker745"/>protect the whole API. Secure coding best practices are a vital part of the protection universe, but they must be combined with a secure API architecture design and be followed by continuous monitoring and checking, triggering general verifications every time a major change is needed in the code or the data flow.</p>
			<h1 id="_idParaDest-159"><a id="_idTextAnchor161"/>Summary</h1>
			<p>In this chapter, we covered important actions that should be taken toward avoiding major incidents in different aspects that were covered throughout previous chapters. We learned tips on how to better code APIs for the sake of reducing risks in authentication mechanisms, user input, error handling and exception management, and data protection.</p>
			<p>In general, we learned that it’s about leveraging widely used open source libraries that implement secure mechanisms or open algorithms, combined with some practices such as avoiding hardcoding important things in the logic and continuously monitoring the activities. Never reinvent the wheel. Avoid obscure solutions as much as possible. In the end, if neither you nor the community nor a compliance authority can audit such a product or service, it’s nearly impossible to truly know what’s going on behind the scenes, as we learned in this chapter.</p>
			<p>Furthermore, we learned that it’s important for developers and development managers to discuss, in their companies, the possibility of adopting a secure coding methodology. They are especially useful when you are completely clueless about where to start to transform your API software into something more secure.</p>
			<p>Finally, I hope you enjoyed reading this book as much as I did writing it. This is my very first book; hopefully it’s the first of many more to come.</p>
			<h1 id="_idParaDest-160"><a id="_idTextAnchor162"/>Further reading</h1>
			<ul>
				<li>Python <code>bcrypt</code>, a hashing alternative module: <a href="https://pypi.org/project/bcrypt/">https://pypi.org/project/bcrypt/</a></li>
				<li>Python <code>scrypt</code>, a more mature implementation of encryption library: <a href="https://pypi.org/project/scrypt/">https://pypi.org/project/scrypt/</a></li>
				<li>Java Spring, a major framework for Java: <a href="https://spring.io/">https://spring.io/</a></li>
				<li>Java Spring Security, a framework for protecting applications written in Java Spring: <a href="https://spring.io/projects/spring-security">https://spring.io/projects/spring-security</a></li>
				<li>JavaScript Passport.js, an authentication middleware for Node.js: <a href="https://www.passportjs.org/">https://www.passportjs.org/</a></li>
				<li>Gorilla Sessions, a Golang package that provides cookie and filesystem sessions for applications: <a href="https://github.com/gorilla/sessions">https://github.com/gorilla/sessions</a></li>
				<li>Python Django, a framework for building modern Python applications and APIs: <a href="https://www.djangoproject.com/">https://www.djangoproject.com/</a></li>
				<li>Python Flask, another framework, which is lighter than Django: <a href="https://flask.palletsprojects.com/en/">https://flask.palletsprojects.com/en/</a></li>
				<li>Java Hibernate, a library that facilitates and protects data handling: <a href="https://hibernate.org/">https://hibernate.org/</a></li>
				<li>Java HQL, the query language behind Hibernate: <a href="https://docs.jboss.org/hibernate/orm/3.3/reference/en/html/queryhql.html">https://docs.jboss.org/hibernate/orm/3.3/reference/en/html/queryhql.html</a>.</li>
				<li>Java JPQL, a query language used for data persistence: <a href="https://openjpa.apache.org/builds/1.2.3/apache-openjpa/docs/jpa_langref.html">https://openjpa.apache.org/builds/1.2.3/apache-openjpa/docs/jpa_langref.html</a></li>
				<li>JavaScript Sequelize, an ORM for Node.js: <a href="https://sequelize.org/">https://sequelize.org/</a></li>
				<li>JavaScript Mongoose, an intelligent and elegant way to deal with data on Node.js when connecting with MongoDB: <a href="https://mongoosejs.com/docs/">https://mongoosejs.com/docs/</a></li>
				<li>Joi, a tool that helps you validate data when coding in JavaScript: <a href="https://joi.dev/">https://joi.dev/</a></li>
				<li>Golang Package Validator, an aid to valid user input before taking it into consideration: <a href="https://pkg.go.dev/github.com/go-playground/validator/">https://pkg.go.dev/github.com/go-playground/validator/</a></li>
				<li>Golang SQL Package, which should be used when interacting with SQL databases rather than directly sending queries to them: <a href="https://pkg.go.dev/database/sql">https://pkg.go.dev/database/sql</a></li>
				<li>Java Logback, a framework to correctly handle logging: <a href="https://logback.qos.ch/">https://logback.qos.ch/</a></li>
				<li>Simple Log Facade for Java, a wrapper for logging frameworks such as Logback: <a href="https://www.slf4j.org/">https://www.slf4j.org/</a></li>
				<li>JavaScript Express.js, a minimal web framework: <a href="https://expressjs.com/">https://expressjs.com/</a></li>
				<li>Python cryptography, a module to facilitate encryption activities: <a href="https://pypi.org/project/cryptography/">https://pypi.org/project/cryptography/</a></li>
				<li>Java Cryptography Architecture, a reference and set of implementations for dealing with cryptographic primitives with the language (the current version is 22): <a href="https://docs.oracle.com/en/java/javase/22/security/java-cryptography-architecture-jca-reference-guide.html">https://docs.oracle.com/en/java/javase/22/security/java-cryptography-architecture-jca-reference-guide.html</a></li>
				<li>Golang crypto, a package that handles encryption and hashing tasks: <a href="https://pkg.go.dev/crypto">https://pkg.go.dev/crypto</a></li>
				<li>A blog post discussing what<code>.env</code> is and how it can be leveraged to grant some protection to sensitive data: <a href="https://platform.sh/blog/we-need-to-talk-about-the-env/">https://platform.sh/blog/we-need-to-talk-about-the-env/</a></li>
			</ul>
		</div>
	</body></html>