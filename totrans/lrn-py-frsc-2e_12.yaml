- en: Recovering Transient Database Records
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will revisit SQLite databases and examine a type of journaling
    file called a **Write Ahead Log** (**WAL**). Due to the complexity of the underlying
    structure, parsing a WAL file is a more difficult task than our previous work
    with SQLite databases. There are no existing modules that we can leverage to directly
    interact with the WAL file in the same way we used `sqlite3` or `peewee` with
    SQLite databases. Instead, we'll rely on the struct library and our ability to
    understand binary files.
  prefs: []
  type: TYPE_NORMAL
- en: Once we've successfully parsed the WAL file, we will leverage the regular expression
    library, `re`, in Python to identify potentially relevant forensic artifacts.
    Lastly, we briefly introduce another method of creating progress bars using the
    third-party `tqdm` library. With a few lines of code, we'll have a functioning
    progress bar that can provide feedback of program execution to the user.
  prefs: []
  type: TYPE_NORMAL
- en: The WAL file can contain data that's no longer present or not yet been added
    to the SQLite database. It can also contain previous copies of altered records
    and give a forensic investigator an idea of how the database changed over time.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will explore the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Parsing complex binary files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning about and utilizing regular expressions to locate specified patterns
    of data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a simple progress bar in a few lines of code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the built-in Python debugger, `pdb`, to troubleshoot code quickly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code for this chapter was developed and tested using Python 2.7.15 and Python
    3.7.1.
  prefs: []
  type: TYPE_NORMAL
- en: SQLite WAL files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When analyzing SQLite databases, the examiner might come across additional
    temporary files. There are nine types of temporary SQLite files:'
  prefs: []
  type: TYPE_NORMAL
- en: Rollback journals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Master journals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Statement journals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: WAL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shared-memory files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TEMP databases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Views and subqueries materializations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transient indices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transient databases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For more details on these files, refer to [https://www.sqlite.org/tempfiles.html](https://www.sqlite.org/tempfiles.html),
    which describes these files in greater detail. The WAL is one of these temporary
    files and is involved in the atomic commit and rollback scenarios. Only databases
    that have set their journaling mode to WAL will use the write ahead log method.
    The following SQLite command is required to configure a database to use WAL journaling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The WAL file is created in the same directory as the SQLite database with `-wal`
    appended to the original SQLite database filename. When a connection is made to
    the SQLite database, a WAL file is temporarily created. This WAL file will contain
    any changes made to the database while leaving the original SQLite database unaffected.
    Advantages of using WAL files include concurrent and speedier read/write operations.
    Specifics on the WAL file can be read at [https://www.sqlite.org/wal.html](https://www.sqlite.org/wal.html):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/17d1071f-ec60-467d-9b87-c01cba6889b8.png)'
  prefs: []
  type: TYPE_IMG
- en: By default, records within the WAL file are committed to the original database
    when either the WAL file reaches 1,000 pages or the last connection to the database
    closes.
  prefs: []
  type: TYPE_NORMAL
- en: 'WAL files are forensically relevant for two reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing database activity overtime
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recovering deleted or altered records
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The creators of Epilog, an advanced SQLite carving tool, have a well-written
    article detailing the specific forensic implications of WAL files at [https://digitalinvestigation.wordpress.com/2012/05/04/the-forensic-implications-of-sqlites-write-ahead-log/](https://digitalinvestigation.wordpress.com/2012/05/04/the-forensic-implications-of-sqlites-write-ahead-log/).
    With an understanding of what makes WAL files important, why they are used, and
    their forensic relevance, let's examine their underlying structure.
  prefs: []
  type: TYPE_NORMAL
- en: WAL format and technical specifications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A WAL file is a collection of frames with embedded B-tree pages that correspond
    to pages in the actual database. We aren't going to get into the nitty-gritty
    of how B-trees work. Instead, let's focus on some of the important byte offsets
    of various structures of interest, so that we can have a better understanding
    of the code and, in doing so, we'll further exemplify the forensic relevance of
    WAL files.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main components of a WAL file include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: WAL header (32 bytes)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: WAL frames (page size)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Frame header (24 bytes)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Page header (8 bytes)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: WAL cells (variable length)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that the WAL frame size is dictated by the page size, which can be extracted
    from the WAL header.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the structure of a WAL file at a high level:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/70061399-9032-4bf2-a136-272924866f94.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's take a look at each of the high-level categories of the WAL file. Some
    of these structures are described at [https://www.sqlite.org/fileformat2.html](https://www.sqlite.org/fileformat2.html).
  prefs: []
  type: TYPE_NORMAL
- en: The WAL header
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The 32-byte WAL header contains properties such as the page size, number of
    checkpoints, size of the WAL file, and indirectly, number of frames in the WAL
    file. The following table details the byte offset and description of the 8 big-endian
    32-bit integers stored in the header:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Byte offset** | **Value** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| 0-3 | File signature | This is either `0x377F0682` or `0x377F0683`. |'
  prefs: []
  type: TYPE_TB
- en: '| 4-7 | File version | This is the WAL format version, which is currently 3007000.
    |'
  prefs: []
  type: TYPE_TB
- en: '| 8-11 | Database page size | This is the size of the page within the database,
    which is usually 1024 or 4096. |'
  prefs: []
  type: TYPE_TB
- en: '| 12-15 | Checkpoint number | This is the number of commits that have occurred.
    |'
  prefs: []
  type: TYPE_TB
- en: '| 16-19 | Salt-1 | This is a random integer that is incremented by one with
    each commit. |'
  prefs: []
  type: TYPE_TB
- en: '| 20-23 | Salt-2 | This is a random integer that changes with each commit.
    |'
  prefs: []
  type: TYPE_TB
- en: '| 24-27 | Checksum-1 | This is the first part of the header checksum. |'
  prefs: []
  type: TYPE_TB
- en: '| 28-31 | Checksum-2 | This is the second part of header checksum. |'
  prefs: []
  type: TYPE_TB
- en: 'The file signature should always be either `0x377F0682` or `0x377F0683`. The
    database page size is a very important value as this allows us to calculate how
    many frames are present in the WAL file. For example, there are 5 frames in a
    20,632 byte WAL file using 4,096 byte pages. To calculate the number of frames
    properly, we need to account for the 32 byte WAL header and the 24-byte WAL frame
    header in the following equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The checkpoint number indicates how many commits have been triggered, either
    automatically, or manually by executing PRAGMA `wal_checkpoint`. Now, let's focus
    on the Salt-1 value. When it comes to creating a timeline of database activity,
    this is the most important value in the header. The Salt-1 value increments with
    each commit. In addition to that, each frame stores the current salt values in
    its own header at the time of the commit. If a record was modified and recommitted,
    the newer record would have a larger Salt-1 value than the previous version of
    the record. Therefore, we might have multiple snapshots of a given record in time
    within the WAL file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s pretend we have a database containing one table, storing data related
    to employee names, positions, salaries, and so on. Early on, we have an entry
    for Peter Parker, a 23-year old freelance photographer making $45,000\. A few
    commits later, Parker''s salary changes to $150,000 and within the same commit
    Parker''s name is updated to Spiderman:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Frame** | **Salt-1** | **Row ID** | **Employee name** | **Position** |
    **Salary** |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | -977652151 | 123 | Spiderman? | Freelance | 150,000 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | -977652151 | 123 | Peter Parker | Freelance | 150,000 |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | -977652150 | 123 | Peter Parker | Freelance | 45,000 |'
  prefs: []
  type: TYPE_TB
- en: Because these entries share the same **Row ID**, we know that we're dealing
    with three different versions of record 123 in the main table. To identify the
    most recent version of this record, we need to examine the Salt-1 value. Based
    on our discussion earlier and the Salt-1 values of the records, we know that the
    records in Frame 0 and 1 are the most recent records and that there have been
    two commits since the record was first added to the database.
  prefs: []
  type: TYPE_NORMAL
- en: How do we know which of the records in Frames 0 and 1 is the most recent? Dealing
    with the scenario where we have two records in the same commit, the one in an
    earlier frame is regarded as the most recent. This is because the WAL file adds
    new frames to the beginning of the file rather than the end. Therefore, the record
    in Frame 0 is the most recent and the record in Frame 2 is the oldest.
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have more than one record per frame. Newer records are found
    at the beginning of the frame.
  prefs: []
  type: TYPE_NORMAL
- en: In the database, we'll only see the most recent version of the record, but in
    the WAL file, we can see previous versions. As long as the WAL file exists, we
    would still see this information, even if the record with Row ID of 123 is deleted
    from the main database.
  prefs: []
  type: TYPE_NORMAL
- en: The WAL frame
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The WAL frame is essentially a B-tree structured page with a frame header.
    The frame header contains 6 big-endian 32-bit integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Byte offset** | **Value** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| 0-3 | Page number | This is the frame or page number in the WAL file. |'
  prefs: []
  type: TYPE_TB
- en: '| 4-7 | Database Size | This is the size of the database in pages for commit
    records. |'
  prefs: []
  type: TYPE_TB
- en: '| 8-11 | Salt-1 | This is copied from the WAL header at the time of writing
    the frame. |'
  prefs: []
  type: TYPE_TB
- en: '| 12-15 | Salt-2 | This is copied from the WAL header at the time of writing
    the frame. |'
  prefs: []
  type: TYPE_TB
- en: '| 16-19 | Checksum-1 | This is the cumulative checksum including this frame.
    |'
  prefs: []
  type: TYPE_TB
- en: '| 20-23 | Checksum-2 | This is the second part of the checksum. |'
  prefs: []
  type: TYPE_TB
- en: The Salt-1 value is simply the Salt-1 value in the WAL header at the time of
    creating the frame. We used this value stored in the frame to determine the time
    of events in the previous example. The page number is an integer starting at zero,
    where zero is the first frame in the WAL file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following the frame header are the contents of a single page in the database,
    starting with the page header. The page header consists of two 8-bit and three
    16-bit big-endian integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Byte offset** | **Value** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | B-Tree flag | This is the type of B-tree node |'
  prefs: []
  type: TYPE_TB
- en: '| 1-2 | Freeblocks | This is the number of freeblocks in the page. |'
  prefs: []
  type: TYPE_TB
- en: '| 3-4 | Cell count | This is the number of cells in the page. |'
  prefs: []
  type: TYPE_TB
- en: '| 5-6 | Cell offset | This is the byte offset to the first cell relative to
    the start of this header. |'
  prefs: []
  type: TYPE_TB
- en: '| 7 | Fragments | These are the number of fragmented freeblocks in the page.
    |'
  prefs: []
  type: TYPE_TB
- en: With this information, we now know how many cells we're dealing with and the
    offset to the first cell. Following this header are *N* big-endian 16-bit integers
    specifying the offset for each of the cells. The cell offsets are relative to
    the start of the page header.
  prefs: []
  type: TYPE_NORMAL
- en: The WAL cell and varints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Each cell is made up of the following components:'
  prefs: []
  type: TYPE_NORMAL
- en: Payload length (varint)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Row ID (varint)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Payload header:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Payload header length (varint)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Array of serial types (varints)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Payload
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The payload length describes the overall length of the cell. The Row ID is the
    unique key in the actual database corresponding to this record. The serial types
    array in the payload header contains the length and type of data in the payload.
    We can subtract the payload length by the payload header length to determine how
    many bytes of the cell is actually recorded data.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that most of these values are varints, or variable length integers. Varints
    in SQLite are integers that can be anywhere from 1 to 9 bytes in size based on
    the first bit of each byte. If the first bit is set, that is, a value of 1, then
    the next byte is a part of the varint. This continues until you have a 9 byte
    varint or the first bit of a byte isn't set. The first bit isn't set for all 8-bit
    integers less than 128\. This allows large numbers to be stored flexibly within
    this file format. More details on varints is available at [https://www.sqlite.org/src4/doc/trunk/www/varint.wiki](https://www.sqlite.org/src4/doc/trunk/www/varint.wiki).
  prefs: []
  type: TYPE_NORMAL
- en: For example, if the first byte that's processed is `0x03` or `0b00000011`, we
    know the varint is just one-byte long and has the value of 3\. If the first byte
    that's processed is `0x9A` or `0b10011010`, then the first bit is set and the
    varint is at least two-bytes long depending on the next byte, using the same decision
    making process. For our purposes, we will only support varints up to 2 bytes in
    length. A detailed tutorial on parsing a WAL file can be read at [http://www.forensicsfromthesausagefactory.blogspot.com/2011/05/analysis-of-record-structure-within.html](http://www.forensicsfromthesausagefactory.blogspot.com/2011/05/analysis-of-record-structure-within.html).
    It's highly recommended to use a hex editor and parse a page by hand before attempting
    to develop the code. Handling varints can be a lot easier through examination
    in a hex editor and helps cement your understanding of the database structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most of the varints are found in the serial types array. This array immediately
    follows the payload header length and has a value of 1\. The resulting table of
    varint values dictate the size and data type of the cells:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Varint value** | **Size (bytes)** | **Data type** |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0 | Null |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 1 | 8-bit integer |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | 2 | Big-endian 16-bit integer |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | 3 | Big-endian 24-bit integer |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | 4 | Big-endian 32-bit integer |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | 6 | Big-endian 48-bit integer |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | 8 | Big-endian 64-bit integer |'
  prefs: []
  type: TYPE_TB
- en: '| 7 | 8 | Big-endian 64-bit float |'
  prefs: []
  type: TYPE_TB
- en: '| 8 | 0 | Integer constant: 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 9 | 0 | Integer constant: 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 10, 11 |  | Not used |'
  prefs: []
  type: TYPE_TB
- en: '| X >= 12 and even | (X-12)/2 | BLOB of length (X-12)/2 |'
  prefs: []
  type: TYPE_TB
- en: '| X >= 13 and odd | (X-13)/2 | String of length (X-13)/2 |'
  prefs: []
  type: TYPE_TB
- en: 'The payload begins immediately following the final serial type. Let''s look
    at how we can use varints to properly parse the contents of the payload properly.
    For example, if given the following serial types: 0, 2, 6, 8, and 25, we would
    expect a 16-byte payload containing a `Null` value, a 2-byte 16-bit integer, an
    8-byte 64-bit integer, a constant 0, and a 6-byte string. The size of the string
    is calculated by the equation (25-13) / 2\. The following pseudocode highlights
    this process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example illustrates how the 16-byte payload would be decoded using
    the known serial types. We will employ this same approach when developing our
    program. Notice that serial types 0, 8, and 9 don't require any space in the payload
    as their values are static.
  prefs: []
  type: TYPE_NORMAL
- en: Manipulating large objects in Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before developing any script, especially one that deals with a large and complicated
    structure, it's vital to choose the appropriate data type to work with. For our
    solution, we will use dictionaries and ordered dictionaries. The difference between
    a dictionary and an ordered dictionary is that ordered dictionaries preserve the
    order in which items are added. This feature isn't essential for our script and
    is merely used as a convenience.
  prefs: []
  type: TYPE_NORMAL
- en: A dictionary allows us to map the structures of the WAL file as key-value pairs.
    In the end, we'll create a large nested dictionary object, which could easily
    be saved as a JSON file for use with other programs. Another benefit of this data
    type is that we can navigate through multiple dictionaries by descriptive keys.
    This can be used to compartmentalize between different sections of the WAL file
    and will help keep processed data organized. This covers all of the high-level
    details we need to know about to write our WAL file parsing script. Before doing
    so, let's briefly introduce regular expressions and the `tqdm` progress bar module.
  prefs: []
  type: TYPE_NORMAL
- en: Regular expressions in Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Regular expressions allow us to identify patterns of data by using generic search
    patterns. For example, searching for all possible phone numbers of the `XXX-XXX-XXXX`
    type appearing in a document can be easily accomplished by one regular expression.
    We're going to create a regular expression module that will run a set of default
    expressions or a user-supplied expression against the processed WAL data. The
    purpose of the default expressions will be to identify relevant forensic information
    such as URLs or **Personally Identifiable Information** (**PII**).
  prefs: []
  type: TYPE_NORMAL
- en: 'While this section is not a primer on regular expression by any means, we''ll
    briefly touch on the basics so that we can understand its advantages and the regular
    expressions used in the code. In Python, we use the `re` module to run regular
    expressions against strings. First, we must compile the regular expression and
    then check whether there are any matches in the string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Using the identical string as our expression results in a positive match. However,
    this would not capture other phone numbers. Regular expressions can use a variety
    of special characters that either represent a subgroup of characters or how the
    preceding elements are interpreted. We use these special characters to refer to
    multiple sets of characters and create a generic search pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'Square brackets, `[]`, are used to indicate a range of characters such as `0`
    through `9` or `a` through `z`. Using curly braces, `{n}`, after a regular expression
    requires that `n` copies of the preceding regular expression must be matched to
    be considered valid. Using these two special characters, we can create a much
    more generic search pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This regular expression matches anything of the `XXX-XXX-XXXX` pattern containing
    only integers 0 through 9\. This wouldn't match phone numbers such as `+1 800.234.5555`.
    We can build more complicated expressions to include those types of patterns.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another example we''ll take a look at is matching credit card numbers. Fortunately,
    there exist standard regular expressions for some of the major cards such as Visa,
    MasterCard, American Express, and so on. The following is the expression we could
    use for identifying any Visa card. The variable, `expression_1`, matches any number
    starting with four followed by any 15 digits (0-9). The second expression, `expression_2`,
    matches any number starting with 4 followed by any 15 digits (0-9) that are optionally
    separated by a space or dash:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'For the first expression, we''ve introduced three new special characters: `^`,
    `d`, and `$`. The caret (`^`) asserts that the starting position of the string
    is at the beginning. Likewise, `$` requires that the end position of the pattern
    is the end of the string or line. Together, this pattern would only match if our
    credit card is the only element on the line. The `d` character is an alias for
    [0-9]. This expression could capture a credit card number such as 4111111111111111\.
    Note that, with regular expressions, we use the `r` prefix to create a raw string
    which ignores backslashes as Python escape characters. Because regular expressions
    use backslashes as an escape character, we would have to use double backslashes
    wherever one is present so Python doesn''t interpret it as an escape character
    for itself.'
  prefs: []
  type: TYPE_NORMAL
- en: In the second expression, we use parentheses and square brackets to optionally
    match a space or dash between quartets. Notice the backslash, which acts as an
    escape for the space, and dash, which are themselves special characters in regular
    expressions. If we didn't use the backslash here, the interpreter wouldn't realize
    we meant to use the literal space and dash rather than their special meaning in
    regular expressions. We can use 1 after we define our pattern in parentheses rather
    than rewriting it each time. Again, because of `^` and `$`, this pattern will
    only match if it's the only element on the line or entire string. This expression
    would capture Visa cards such as 4111-1111-1111-1111 and capture anything `expression_1`
    would match.
  prefs: []
  type: TYPE_NORMAL
- en: Mastering regular expressions allow a user to create very thorough and comprehensive
    patterns. For the purpose of this chapter, we'll stick to fairly simple expressions
    to accomplish our tasks. As with any pattern matching, there's the possibility
    of generating false positives as a result of throwing large datasets at the pattern.
  prefs: []
  type: TYPE_NORMAL
- en: TQDM – a simpler progress bar
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The  `tqdm` module (version 4.23.2) can create a progress bar with any Python
    iterator:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/38c6a780-ab98-4dce-b92f-d052e91611c5.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding example, we wrapped an iterator that was created by `range(100)`
    around `tqdm`. That alone creates the progress bar that's displayed in the image.
    An alternative method, using the `trange()` function, makes our task even simpler.
    We'll use this module to create a progress bar for processing each WAL frame.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code creates the same progress bar, as shown in the previous
    screenshot. `trange()` is an alias for `tqdm(xrange())` and makes creating a progress
    bar even simpler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Parsing WAL files – wal_crawler.py
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we understand how a WAL file is structured and what data type we'll
    use to store data, we can begin planning the script. As we're working with a large
    binary object, we'll make great use of the `struct` library. We first introduced
    `struct` in [Chapter 6](59414e87-5820-4942-bd47-aba762dd9f14.xhtml), *Extracting
    Artifacts from Binary Files*, and have used it whenever dealing with binary files.
    Therefore, we won't repeat the basics of `struct` in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The goal of our `wal_crawler.py` script is to parse the content of the WAL
    file, extract and write the cell content to a CSV file, and, optionally, run regular
    expression modules against the extracted data. This script is considered more
    advanced due to the complexity of the underlying object we''re parsing. However,
    all we''re doing here is applying what we''ve learned in the previous chapters
    at a larger scale:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'As with any script we''ve developed, in lines 1-11 we import all modules we''ll
    use for this script. Most of these modules we''ve encountered before in the previous
    chapters and are used in the same context. We''ll use the following modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '`binascii`: This is used to convert data that''s read from the WAL file into
    hexadecimal format'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tqdm`: This is used to create a simple progress bar'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`namedtuple`: This data structure from the collections module will simply be
    the process of creating multiple dictionary keys and values when using the `struct.unpack()`
    function'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `main()` function will validate the WAL file input, parse the WAL file
    header, and then iterate through each frame and process it with the `frame_parser()`
    function. After all of the frames have been processed, the `main()` function optionally
    runs the regular expression `regular_search()` function and writes the processed
    data to a CSV file with the `csv_writer()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The `frame_parser()` function parses each frame and executes further validation
    by identifying the type of B-trees. There are four types of B-trees in a database:
    `0x0D`, `0x05`, `0x0A`, and `0x02`. In this script, we''re only interested in
    0x0D type frames and will not process the others. This is because `0x0D` B-trees
    contain both the Row ID and payload, whereas other tree types contain one or the
    other. After validating the frame, the `frame_parser()` function processes each
    cell with the `cell_parser()` function.'
  prefs: []
  type: TYPE_NORMAL
- en: The `cell_parser()` function is responsible for processing each cell and all
    of its components, including the payload length, Row ID, payload header, and payload.
    Both the `frame_parser()` and `cell_parser()` functions rely on various helper
    functions to perform their tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `dict_helper()` helper function returns `OrderedDictionary` from a tuple.
    This function allows us to process and store struct results in a database on one
    line. The `single_varint()` and `multi_varint()` functions are used to process
    single and multiple varints, respectively. Finally, the `type_helper()` function
    processes the serial type array and interprets the raw data into the appropriate
    data types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'On line 483, we create our argument parser, specifying the required input values,
    the WAL file and output directory, and optional input values, executing pre-built
    or custom regular expressions and log output path. On lines 496 through 508, we
    perform the same log setup that we used in the previous chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Before executing the `main()` function, we perform some sanity checks and validate
    the supplied input. On line 510, we check and, optionally, create the output directory
    if it doesn''t exist. Before executing the `main()` function, we validate the
    input file by checking whether the input actually exists and whether it''s a file
    by using the `os.path.exists()` and `os.path.isfile()` functions. Otherwise, we
    write an error message to the console and log before exiting the program. Within
    the `main()` function, we''ll further validate the WAL file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The following flow diagram highlights the interactions between the different
    functions and illustrates how our code processes the WAL file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1cfbf3b9-85d3-40b3-9327-d19012ae5730.png)'
  prefs: []
  type: TYPE_IMG
- en: Understanding the main() function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This function is more complicated than our typical `main()` function and starts
    to parse the WAL file rather than act as a controller for the script. In this
    function, we will perform file validation, parse the WAL file header, identify
    the number of frames in the file, and call the function to process those frames:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'On line 70, we create the `wal_attributes` dictionary, which is the dictionary
    that we''ll expand as we parse the WAL file. Initially, it stores the file size,
    and two empty dictionaries for the file header and the frames. Next, we open the
    input file in `rb` mode, or read binary mode, and read the first 32 bytes as the
    file header. On line 79, we try to parse the header and add all of the keys and
    their values to the header dictionary. This performs another sanity check as struct
    will throw an error if the file is less than 32 bytes long. We use `>4s7i` as
    our string to unpack the values pulling out a 4 byte string and seven 32-bit big-endian
    integers (the endianness is specified by `>` in the format string):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Notice the use of the `dict_helper()` function. We'll explain how exactly this
    function works in a later section, however, it allows us to parse the data read
    from the WAL file with struct and return `OrderedDict`, which contain the key-value
    pairs. This significantly cuts down the amount of code necessary to otherwise
    add each value in the returned struct tuple to the dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: 'After parsing the WAL header, we can compare the file magic, or signature,
    against the known values. We use `binascii.hexlify` to convert the raw data into
    hex. On line 92, we use an `if` statement to compare the `magic_hex` value. If
    they don''t match, we stop program execution. If they do match, we note it in
    the log and continue processing the WAL file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the file size, we can calculate the number of frames on line 103\. Note
    that we need to account for the 32 byte WAL header and the 24-byte frame header
    in addition to the page size within each frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'On line 111, we create our progress bar using `trange` from `tqdm` and begin
    processing each frame. We first create an index key, represented by `x`, and an
    empty dictionary for our frame on line 114\. This index will ultimately point
    to the processed data for the frame. Next, we read the 24-byte frame header. On
    line 116, we parse the six 32-bit big-endian integers from the header and add
    the appropriate key-value pairs to the dictionary by calling our `dict_helper()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'After parsing the frame header, we read the entire frame from our WAL file
    on line 122\. We then pass this frame to the `frame_parser()` function, along
    with the `wal_attributes` dictionary and `x`, which represents the index of the
    current frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The `frame_parser()` function calls other functions within it, rather than
    return data and have `main()` call the next function. Once the parsing of the
    WAL file has completed parsed, the main function calls the `regular_search()`
    function if the user supplied the `m` or `r` switch and  calls the `csv_writer()`
    function to write the parsed data out to a CSV file for review:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Developing the frame_parser() function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `frame_parser()` function is an intermediate function that continues parsing
    the frame, identifies the number of cells within the frame, and calls the `cell_parser()` function
    to finish the job:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'As we described previously, the WAL page header is the first 8 bytes after
    the frame header. The page header contains two 8-bit and three 16-bit big-endian
    integers. In the struct string, `>b3hb`, `b` will parse the 8-bit integer and
    `h` parses 16-bit integers. With this header parsed, we now know how many cells
    are within the page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'On line 150, we check whether the type of the frame is `0x0D` (which, when
    interpreted as a 16-bit integer, will have the value of 13). If the frame isn''t
    of the appropriate type, we log this information and `pop()` the frame from the
    dictionary before returning the function. We return the function so that it doesn''t
    continue attempting to process a frame we have no interest in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Regardless, on line 156, we create a new nested dictionary called cells and
    use it to keep track of our cells in the exact way we did with our frames. We
    also print the number of identified cells per frame to provide feedback to the
    user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, on line 161, we iterate over each cell and parse their offsets before
    adding it to the dictionary. We know that *N* 2 byte cell offsets begin immediately
    following the 8-byte page header. We use the start variable, calculated on line
    162 for every cell, to identify the starting offset of the cell offset values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'On line 163, we create an index key and empty dictionary for our cell. We then
    parse the cell offset with the `dict_helper()` function and store the contents
    in the specific cell dictionary. Once the offset is identified, we call the `cell_parser()`
    function to process the cell and its contents. We pass along the `wal_attributes`
    dictionary, the `frame` and cell index, `x` and `y`, respectively, and the frame
    data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Processing cells with the cell_parser() function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `cell_parser()` function is the heart of our program. It''s responsible
    for actually extracting the data stored within the cells. As we''ll see, varints
    add another wrinkle to the code; however, for the most part, we''re still ultimately
    parsing binary structures using struct and making decisions based on those values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we begin to parse the cells, we instantiate a few variables. The index
    variable, which we created on line 183, is used to keep track of our current location
    within the cell. Remember that we''re no longer dealing with the entire file itself
    but a subset of it representing a cell. The frame variable is the page size amount
    of data read from the database itself. For example, if the page size is 1,024,
    then the frame variable is 1,024 bytes of data, which correspond to a page in
    the database. The struct module requires that the data parsed is exactly the length
    of the data types specified in the struct string. Because of these two facts,
    we need to use string slicing to provide only the data we want to parse with struct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'On line 186, we create `cell_root`, which is essentially a shortcut to the
    nested cell dictionary within the `wal_attributes` dictionary. This isn''t just
    about being lazy; this helps with code readability and reduce the overall clutter
    by referring to a variable that points to a nested dictionary rather than typing
    it out each time. For the same reason, we create the `cell_offset` variable on
    line 187:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Starting on line 191, we encounter our first varint in the cell payload length.
    This varint will dictate the overall size of the cell. To extract the varint,
    we call the `single_varint()` helper function supplying it a 9 byte slice of data.
    This function, which we will explain later, will check whether the first byte
    is greater than or equal to 128; if so, it processes the second byte. In addition
    to the varint, the `single_varint()` helper function also returns a count of how
    many bytes the varint was made up of. This allows us to keep track of our current
    position in the frame data. We use that returned index to parse the row ID varint
    in a similar fashion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'After processing the first two varints, we add the key-value pair to the `wal_attributes`
    dictionary. On line 204, we update our index variable to maintain our current
    position in the frame data. Next, we manually extract the 8-bit payload header
    length value without the `dict_helper()` function. We do this for two reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: We're only processing one value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting `cell_root` equal to the output of `dict_helper()` was found to erase
    all other keys in the individual cell nested dictionary described by `cell_root`,
    which, admittedly, isn't ideal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code block shows this functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'After parsing the payload length, row ID, and payload header length, we can
    now parse the serial types array. As a reminder, the serial types array contains
    *N* varints that is headerlength, 1 bytes long. On line 210, we update the index
    by 1 to account for the 1 byte header we parsed on line 205\. We then extract
    all of the varints within the appropriate range by calling the `multi_varint()`
    function. This function returns a tuple containing the list of serial types and
    the current index. On lines 218 and 219, we update the `wal_attributes` and `index`
    objects, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the serial types array has been parsed, we can begin to extract the actual
    data stored in the cell. Recall that the cell payload is the difference between
    the payload length and payload header length. This value calculated on line 224
    is used to pass the remaining contents of the cell to the `type_helper()` helper
    function, which is responsible for parsing the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Writing the dict_helper() function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `dict_helper()` function is a one-line function, and is less than six lines
    of documentation. It utilizes the `named_tuple` data structure, which is passed
    in as the `keys` variable and calls the `_make()` and `_asdict()` functions to
    create our ordered dictionary after struct parses the values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: As with most compact one-liners, it's possible to lose the meaning of the function
    as readability starts to decrease when more functions are called in a single line.
    We're going to introduce and use the built-in Python debugger to take a look at
    what is going on.
  prefs: []
  type: TYPE_NORMAL
- en: The Python debugger – pdb
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python is great for a multitude of reasons, which we don't need to rehash now.
    One excellent feature is a built-in debugging module called `pdb`. This module
    is simple yet incredibly useful for identifying troublesome bugs or to simply
    look at variables during execution. If you're using an IDE (highly recommended)
    to develop your scripts, then chances are that there is already built-in debugging
    support. However, if you develop your code in a simple text editor, have no fear;
    you can always use `pdb` to debug your code.
  prefs: []
  type: TYPE_NORMAL
- en: In this instance, we're going to examine each component of `dict_helper()` to
    fully understand the function. We aren't going to cover all of the uses and commands
    of `pdb`. Instead, we'll illustrate through example, and for additional information,
    you can refer to [https://docs.python.org/3/library/pdb.html](https://docs.python.org/3/library/pdb.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to modify the existing code and create a debug point in the
    code that we want to examine. On line 240, we import `pdb` and call `pdb.set_trace()`
    in one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Using the semicolon allows us to separate multiple statements on a single line.
    Normally, we wouldn't use this as it impacts readability. However, this is just
    for testing and will be removed from the final code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, when we execute the code, we see the `pdb` prompt, as displayed in the
    following screenshot. The `pdb` prompt is similar to the Python interpreter. We
    can access current variables within scope, for example, `data`, `format`, and
    `keys`. We can also create our own variables and execute simple expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/895f96de-2718-4051-975b-44a8046d6961.png)'
  prefs: []
  type: TYPE_IMG
- en: The first line of the `pdb` prompt contains the location of the file, the current
    line within the file, and the current function being executed. The second line
    is the next line of code that's about to be executed. The `Pdb` prompt has the
    same significance as the `>>>` prompt in the Python interpreter, and is where
    we can enter our own input.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we''re parsing the file header as it''s the first time that
    `dict_helper()` is called. If you recall, the struct string we used was `>4s7i`.
    As we can see in the following example, `unpack()` returns a tuple of results.
    However, we want to return a dictionary matching all of the values with their
    associated keys so that we don''t have to perform this task manually:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that `keys._make` creates an object with the appropriate field names
    set for each value. It does this by associating the field names that were supplied
    when we created the `keys` variable on line 41 to each value in the struct tuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can use `pdb` to verify that the `keys._asdict()` function converts
    our `namedtuple` into an `OrderedDict`, which is what we return:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Using `pdb` in this manner allows us to visualize the current state of variables
    and execute functions individually. This is incredibly useful when your program
    encounters an error on a particular function as you can execute line by line and
    function by function until you identify the issue. We recommend you become familiar
    with `pdb` as it expedites the debugging process and is much more effective than
    using print statements for troubleshooting. Press q and *Enter* to exit `pdb`
    and make sure always to remove debug lines from your final code.
  prefs: []
  type: TYPE_NORMAL
- en: Processing varints with the single_varint() function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `single_varint` function finds the first varint within the supplied data
    and uses an index to keep track of its current position. When it finds the varint,
    it returns the value along with the index. This tells the calling function how
    many bytes the varint was and is used to update its own index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'For this script, we''ve made a simplifying assumption that varints will never
    be greater than 2 bytes. This is a simplifying assumption and won''t be appropriate
    in all situations. This leaves two possible scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: The first byte has a decimal value less than 128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first byte is greater than or equal to 128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Based on the outcome, one of the following two things will happen. If the byte
    is greater than or equal to 128, the varint is 2 bytes long. Otherwise, it''s
    only 1 byte in length. On line 256, we use the `ord()` function to convert the
    value of the byte into an integer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'If the value is greater than 128, we know that the second byte is also required
    and must apply the following generic formula, where `x` is the first byte and
    `y` is the second byte:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We return this value after incrementing the index by 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'If the first byte is less than 128, all we must do is return the byte''s integer
    value and increment the index by 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Processing varints with the multi_varint() function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `multi_varint()` function is a looping function that repeatedly calls `single_varint()`
    until there are no more varints in the supplied data. It returns a list of varints
    and an index to the parent function. On lines 282 and 283, we initialize the list
    of varints and set our local index variable to zero:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'We use a `while` loop to execute until the length of data is equal to 0\. In
    each loop, we call `single_varint()`, append the resulting varint to the list,
    update the index, and shorten the data using string slicing. By executing line
    293 with the size of the varint returned from the `single_varint()` function,
    we can progressively shorten data until it has a length of 0\. Upon reaching this
    point, we can be assured that we''ve extracted all varints in the string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Converting serial types with the type_helper() function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `type_helper()` function is responsible for extracting the payload based
    on the types of values in the data. While consisting of many lines of code, it''s
    really no more than a series of conditional statements that, if one is `True`,
    dictates how the data is processed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'On lines 307 and 308, we create the list that will store the extracted payload
    data and the index. The index is used to denote the current position within the
    data. On line 313, we begin iterating over each serial type to check how each
    should be processed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The first ten types are fairly straightforward. We''re using the serial types
    table to identify the type of data and then using struct to unpack it. Some of
    the types, such as 0, 8, and 9 are static and don''t require us to parse the data
    or update our index value. Types 3 and 5 are data types that are not supported
    by struct and require a different method of extraction. Let''s take a look at
    both struct supported and unsupported types to ensure we understand what''s happening:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: We know from the serial types table that type 6 (on line 339) is a 64-bit big-endian
    integer. The `q` character in struct parses 64-bit integers making our job relatively
    simple. We must make sure to supply struct only with the data that makes up the
    64-bit integer. We can do this by string slicing with the current index and stopping
    after 8 bytes. Afterwards, we need to increment the index by 8, so the next type
    is at the correct starting point.
  prefs: []
  type: TYPE_NORMAL
- en: 'If struct doesn''t support the type of variable, such as is the case for type
    3, a 24-bit integer, we need to extract the data in a more round-about fashion.
    This requires us to use the `binascii.hexlify()` function to convert our data
    string into hex. We then simply wrap the `int()` object constructor around the
    hex to convert to its integer value. Notice that we need to specifically tell
    the `int` function the base of the value being converted, which in this case is
    base 16 as the value is in hexadecimal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'For types 12 and 13, we must first identify the actual length of the value
    by applying the appropriate equation. Next, we can simply append the extracted
    string right into the `cell_data` list. We also need to increment the index by
    the size of the calculated string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'On line 363, we create an else case to catch any unexpected serial types and
    print and log the error. After all types are processed, the `cell_data` list is
    returned on line 368:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Writing output with the csv_writer() function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `csv_writer()` function is similar to most of our previous CSV writers.
    A few special considerations need to be made due to the complexity of the data
    being written to the file. Additionally, we''re only writing some of the data
    out to a file and discarding everything else. Dumping the data out to a serialized
    data structure, such as JSON, is left to the reader as a challenge. As with any
    `csv_writer`, we create a list of our headers, open `csvfile`, create our writer
    object, and write the headers to the first row:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Because of our nested structure, we need to create two `for` loops to iterate
    through the structure. On line 399, we check to see whether the cell actually
    contained any data. We noticed during development that sometimes empty cells would
    be generated and are discarded in the output. However, it might be relevant in
    a particular investigation to include empty cells, in which case we''d remove
    the conditional statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: If there is data, we calculate the `frame_offset` and `cell_offset` relative
    to the beginning of the file. The offsets we parsed before were relative to the
    current position within the file. This relative value wouldn't be very helpful
    to an examiner who would have to backtrack to find where the relative offset position
    starts.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our frame offset, we need to add the file header size (32 bytes), the total
    page size (frames * page size), and the total frame header size (frames * 24 bytes).
    The cell offset is a little simpler and is the frame offset plus the frame header
    size, and the parsed cell offset from the `wal_attributes` dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we create a list, `cell_identifiers`, on line 411, which will store the
    row data to write. This list contains the frame number, `salt-1`, `salt-2`, `frame
    offset`, cell number, `cell offset`, and the row ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, on line 418, we write the row along with the payload data to CSV file
    writer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'If the cell had no payload, then the continue block is executed and we proceed
    to the next cell. Once the outer for loop finishes executing, that is, all frames
    are written to the CSV, we flush any remaining buffered content to the CSV and
    close the handle on the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'An example of the CSV output that might be generated from a WAL file is captured
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2d0ccd6f-5e13-4dda-b226-5dfba4669ac0.png)'
  prefs: []
  type: TYPE_IMG
- en: Using regular expression in the regular_search() function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `regular_search()` function is an optional function. If the user supplies
    the `-m` or `-r` switches, the function is executed. This function uses regular
    expressions to identify relevant information within the WAL file and, if identified,
    print the data to the Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: We'll use a dictionary that contains the regular expression patterns to run.
    This will make it easy to identify what category of expression, that is, URL or
    phone number, had a match and print that with the data to provide context.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we must identify which switches were specified by the user. If only
    `args.r` was specified, then we only need to create the regexp dictionary with
    the supplied custom regular expression. Because either `args.r` or `args.m` were
    supplied to even reach this function, we know that if the first `if` is `False`,
    then at least `args.m` must have been supplied:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'If that''s the case, we need to build our regexp dictionary containing our
    regular expression patterns. By default, we have included our credit card and
    phone number examples from before, along with the patterns for SSNs, URLs, and
    IP addresses. Additionally, on line 452, we need to check for the scenario where
    both `args.r` and `args.m` were passed. If they were, we add the custom expression
    to our dictionary, which already contains the `args.m` expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'For each expression in our dictionary, we need to compile it before we can
    use the match function. As we compile each expression, we use several more loops
    to walk through the `wal_attributes` dictionary and check each cell for any matches:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Starting with lines 457, we create a triple `for` loop to get at each individual
    piece of data. In `csv_writer()`, we only used two `for` loops because we didn't
    need to interact with each data point. However, in this case, we need to do this
    to successfully identify matches using regular expressions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice the try and except wrapped around the match function. The match function
    expects a string or buffer. It will error out if it tries to match the expression
    to an integer. So, we decided to catch the error and, if encountered, skip to
    the next piece of data. We could have also solved the issue by casting the datum
    as a string using the `str()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Executing wal_crawler.py
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we''ve written the script, it''s time to actually run it. The simplest
    way of doing so is to supply the input WAL file and output directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c332e006-70b9-4b05-8499-dc3475e4481e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Optionally, we can use the `-m` or `-r` switches to engage the regular expression
    module. The following screenshot shows an example of what the regular expression
    output looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/90a83c10-f0ab-42df-ad96-3b74ac7b7889.png)'
  prefs: []
  type: TYPE_IMG
- en: Note that, when supplying a custom regular expression to run with the `-r` switch,
    surround the expression with double quotes. If you fail to do so, you might encounter
    an error due to havoc that was wreaked by the special characters in the regular
    expression.
  prefs: []
  type: TYPE_NORMAL
- en: Challenge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a few directions in which we could take this script. As we've already
    mentioned, there's a great deal of potentially useful data that we aren't writing
    out to a file. It might be useful to store the entire dictionary structure in
    a JSON file so that others can easily import and manipulate the data. This would
    allow us to utilize the parsed structure in a separate program and create additional
    reports from it.
  prefs: []
  type: TYPE_NORMAL
- en: Another useful feature we could develop is a timeline report or graphic for
    the user. This report would list the current contents of each record and then
    show a progression from the current contents of the records to their older versions
    or even non-existing records. A tree-diagram or flowchart might be a good means
    of visualizing change for a particular database record.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, add in a function that supports processing of varint that can be greater
    than 2 bytes. In our script, we made a simplifying assumption that we were unlikely
    to encounter a varint greater than 2 bytes. However, it isn't impossible to encounter
    a larger varint and so it may be worthwhile adding in this functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned the forensic significance of a WAL file and how
    to parse it. We also briefly touched on how to use regular expressions in Python
    with the `re` module to create generic search patterns. Lastly, we utilized the
    `tqdm` module to create a progress bar in one line of code. The code for this
    project can be downloaded from GitHub or Packt, as described in the *Preface*.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll be combining our knowledge from this entire book
    into a single framework. We'll design a framework that allows for basic pre-processing
    of common artifacts that we've covered. We'll demonstrate the framework design
    and development process and reveal the framework you've been secretly building
    throughout this book.
  prefs: []
  type: TYPE_NORMAL
