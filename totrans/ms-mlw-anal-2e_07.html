<html><head></head><body>
		<div><h1 id="_idParaDest-227" class="chapter-number"><a id="_idTextAnchor669"/>7</h1>
			<h1 id="_idParaDest-228"><a id="_idTextAnchor670"/>Understanding Kernel-Mode Rootkits</h1>
			<p>In this chapter, we are going to dig deeper into the Windows kernel and its internal structures and mechanisms. We will cover different techniques used by malware authors to hide the presence of their malware from users and antivirus products.</p>
			<p>We will look at different advanced kernel-mode hooking techniques, process injection in kernel mode, and how to perform static and dynamic analysis there.</p>
			<p>Before we get into rootkits and learn how they are implemented, we need to understand how the <strong class="bold">operating system</strong> (<strong class="bold">OS</strong>) works and how rootkits can target different parts of the OS and use it to their advantage.</p>
			<p>In this chapter, we will cover the following topics: </p>
			<ul>
				<li>Kernel mode versus user mode</li>
				<li>Windows internals</li>
				<li>Rootkits and device drivers </li>
				<li>Hooking mechanisms</li>
				<li><a id="_idTextAnchor671"/>DKOM </li>
				<li>Process injection in kernel mode</li>
				<li>KPP in x64 systems (PatchGuard) <a id="_idTextAnchor672"/></li>
				<li>Static and dynamic analysis in kernel mode</li>
			</ul>
			<h1 id="_idParaDest-229"><a id="_idTextAnchor673"/>Kernel mode versus user mode</h1>
			<p>You have already seen several user-mode processes on your computer (all the applications you see are running in user mode) and learned how to modify files, connect to the internet, and perform lots of activities. However, you might be surprised to know that user-mode applications don't have privileges to do all of this.</p>
			<p>For any process to create a file or connect to a domain, it needs to send a request to the kernel mode to perform that action. This request is done through what is known as a system call, and this system call switches to kernel mode to perform this action (if permission is granted). Kernel mode and user mode are not only supported by the OS – they are also supported by the processors through protection <a id="_idTextAnchor674"/>rings (or hardware restrictions).</p>
			<h2 id="_idParaDest-230"><a id="_idTextAnchor675"/>Protection rings</h2>
			<p>x86 processors provide four rings of privileges (x64 is slightly different). Each ring has lower privileges than the previous one, as shown in the following diagram:</p>
			<div><div><img src="img/Figure_7.1_B18500.jpg" alt="Figure 7.1 – Processor rings&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">
<a id="_idTextAnchor676"/>Figure 7.1 – Processor rings</p>
			<p>Windows uses mainly <a id="_idIndexMarker939"/>two of these rings: <em class="italic">RING 0</em> for kernel mode and <em class="italic">RING 3</em> for user mode. Modern processors such as Intel and AMD have another ring (<em class="italic">RING 1</em>) for hypervisors and virtualization so that each OS can run natively with hypervisors controlling certain operations, such as hard disk access.</p>
			<p>These rings<a id="_idIndexMarker940"/> are created for handling faults (such as memory access faults or any type of exceptions) and <a id="_idIndexMarker941"/>for security. <em class="italic">RING 3</em> has the least privileges – that is, the processes in this ring cannot affect the system, they<a id="_idIndexMarker942"/> cannot access the memory of other processes, and they cannot access physical memory (they must run in virtualized memory). In contrast, <em class="italic">RING 0</em> can do anything – it can directly affect the system and its resources. Therefore, it's o<a id="_idTextAnchor677"/>nly accessible to the Windows kernel and the device drive<a id="_idTextAnchor678"/>rs.</p>
			<h1 id="_idParaDest-231"><a id="_idTextAnchor679"/>Windows internals</h1>
			<p>Before we dive into the <a id="_idIndexMarker943"/>malicious activities of rootkits, let's take a look at how the Windows OS works and how the interaction between the user mode and kernel mode is organized. This knowledge will allow us to understand the specifics of kernel-mode malware and what parts of the system it may target.</p>
			<h2 id="_idParaDest-232"><a id="_idTextAnchor680"/>The anatomy of Windows</h2>
			<p>As we <a id="_idIndexMarker944"/>mentioned previously, the OS is divided into two parts: user mode and kernel mode. This is shown in the following diagram:</p>
			<div><div><img src="img/Figure_7.2_B18500.jpg" alt="Figure 7.2 – The Windows OS design&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.2 – The Windows OS d<a id="_idTextAnchor681"/>esign</p>
			<p>Now, let's learn about<a id="_idIndexMarker945"/> the scope of these applications:</p>
			<ul>
				<li><code>kernel32.dll</code> in the Win32 and Win64 subsystems.</li>
			</ul>
			<p>These <code>ntdll.dll</code>), which<a id="_idIndexMarker947"/> communicates directly to kernel mode. <code>Ntdll.dll</code> is a library that sends requests to <a id="_idIndexMarker948"/>the kernel using special instructions, such as <code>sysenter</code> or <code>syscall</code> (depending on the mode and whether it is Intel or AMD; in this chapter, we will be using them interchangeably). The request ID is passed using the <code>eax</code> register:</p>
			<div><div><img src="img/Figure_7.3_B18500.jpg" alt="Figure 7.3 – The syscall instruction&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.3 – The syscall instruction</p>
			<ul>
				<li><strong class="bold">Kernel mode</strong>: This<a id="_idIndexMarker949"/> manages all the resources, including the memory, files, UI, sound, graphics, and more. It also schedules threads and processes and manages the UI of all applications. Kernel mode communicates with device drivers that directly send commands or receive inputs from the hardware. It manages all of these requests and any operations that should be done before and after.</li>
			</ul>
			<p>That was a brief explanation of how the Windows OS works. Now, it is time to explore the life cycle of a request from user mode to kernel mode so that we can gain an understanding of how all this works together. Additionally, we will explore how rootkits can interfere with the system to perform malicious activities.</p>
			<h2 id="_idParaDest-233"><a id="_idTextAnchor682"/>The execution path from user mode to kernel mode</h2>
			<p>First, let's take<a id="_idIndexMarker950"/> a look at the life cycle of one API call that requires kernel mode functionality (in this example, this will be <code>FindFirstFileA</code>). We will dissect each step so that we can understand the role that each part of the system plays in handling process requests. This is an important <a id="_idIndexMarker951"/>prerequisite for us to understand where malware can intervene in this sequence of actions:</p>
			<div><div><img src="img/Figure_7.4_B18500.jpg" alt="Figure 7.4 – The API call life cycle &#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.4 – The API call life cycle </p>
			<p>Let's break down the preceding diagram, as follows:</p>
			<ol>
				<li>First, the process calls the <code>FindFirstFileA</code> API, which is implemented in the <code>kernel32.dll</code> library.</li>
				<li>Then, <code>kernel32.dll</code> (like all subsystem DLLs) calls a function in the <code>ntdll.dll</code> library. In this example, it calls an API called <code>ZwQueryDirectoryFile</code> (or <code>ZwQueryDirectoryFileEx</code>).</li>
				<li>All of the <code>Zw*</code> APIs execute the <code>syscall</code> instruction, as you saw in <em class="italic">Figure 7.3</em>. <code>ZwQueryDirectoryFile</code> executes <code>syscall</code> by providing the command ID in <code>eax</code> form (here, the command ID is changing from one Windows version to another).</li>
				<li>Now, the application moves to kernel mode and the execution is redirected to a kernel-mode function called System Service Dispatcher. It is available under the name <code>KiSystemService</code> (or directly <code>KiFastCallEntry</code>) on 32-bit machines and <code>KiSystemCall64</code> on 64-bit machines; compatibility mode will use the <code>KiSystemCall32</code> name. The system may also use shadow versions of them with a suffix of <code>Shadow</code> at the end of it (for example, <code>KiSystemServiceShadow</code> or <code>KiSystemCall64Shadow</code>).</li>
				<li>System<a id="_idIndexMarker952"/> Service Dispatcher searches for the function that represents the command ID that was in <code>eax</code> form (in this case, it is 0x91) in the <code>NtQueryDirectoryFile</code>. It calls this function<a id="_idIndexMarker953"/> and passes all the arguments that were passed to <code>FindFirstFileA</code>:</li>
			</ol>
			<div><div><img src="img/Figure_7.5_B18500.jpg" alt="Figure 7.5 – SSDT explained&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.5 – SSDT explained</p>
			<ol>
				<li value="6">Next, <code>NtQueryDirectoryFile</code> is executed, and this function sends a request called <a id="_idIndexMarker954"/>an <code>fastfat.sys</code> or <code>ntfs.sys</code> driver (this depends on the filesystem that is installed). More details on IRPs will be provided shortly.</li>
				<li>This request passes through multiple device drivers attached to the filesystem driver. These device drivers can modify the inputs in any request and the outputs (or responses) from the filesystem.</li>
				<li>Finally, the<a id="_idIndexMarker955"/> filesystem driver processes the request. The IRP request makes its way back to <code>NtQueryDirectoryFile</code> with an instruction called <code>sysret</code> (or <code>sysexit</code>). Then, control is returned to the user-mode process, along with<a id="_idTextAnchor683"/> the results.</li>
			</ol>
			<p>This may sound relatively complex but for now, this is all you need to know to be able to understand how kernel-mode rootkits work and, more importantly, what w<a id="_idTextAnchor684"/>eaknesses in this process the rootkits can use to achieve <a id="_idTextAnchor685"/>their goals.</p>
			<h1 id="_idParaDest-234"><a id="_idTextAnchor686"/>Rootkits and device drivers</h1>
			<p>Now that you understand Windows internals and how user mode and kernel mode interactions work, let's dig into rootkits. In this section, we will understand what rootkits are and how they are designed. After we grasp the basic concepts of <a id="_idTextAnchor687"/>rootkits, we will discuss dev<a id="_idTextAnchor688"/>ice drivers.</p>
			<h2 id="_idParaDest-235"><a id="_idTextAnchor689"/>What is a rootkit?</h2>
			<p>Rootkits are <a id="_idIndexMarker956"/>essentially low-level tools that provide stealth capabilities to malicious modules. This way, their main purpose is generally to complicate the malware detection and remediation procedures on the target machine by hiding the presen<a id="_idTextAnchor690"/>ce of related artifacts. There are multiple ways this can be done, so let's discuss th<a id="_idTextAnchor691"/>em in detail.</p>
			<h2 id="_idParaDest-236"><a id="_idTextAnchor692"/>Types of rootkits</h2>
			<p>There are various <a id="_idIndexMarker957"/>types of rootkits in user mode, kernel mode, and even boot mode:</p>
			<ul>
				<li><strong class="bold">User-mode or application rootkits</strong>: We covered user-mode rootkits in <a href="B18500_05.xhtml#_idTextAnchor446"><em class="italic">Chapter 5</em></a>, <em class="italic">Inspecting Process Injection and API Hooking</em>; they inject malicious<a id="_idIndexMarker958"/> code into other processes and hook their APIs to hide the malware files, registry keys, and other <strong class="bold">Indicators of Compromise</strong> (<strong class="bold">IoCs</strong>) from<a id="_idIndexMarker959"/> these processes. They can be used to bypass AV programs, task man<a id="_idTextAnchor693"/>agers, and more.</li>
				<li><strong class="bold">Kernel-mode rootkits</strong>: We <a id="_idIndexMarker960"/>will be primarily covering these rootkits in this chapter. These rootkits are device drivers that hook different functions in kernel mode to hide the malware's presence and give the malware the power of kernel mode. They can also inject code and data<a id="_idIndexMarker961"/> into other processes, terminate AV processes, intercept network traffic, perform <strong class="bold">man-in-the-middle</strong> (<strong class="bold">MITM</strong>) attacks, and more.</li>
				<li><strong class="bold">Bootkits</strong>: Bootkits are<a id="_idIndexMarker962"/> rootkits that modify the boot loader. They are used to load malicious files before the OS even boots. This allows the malware to take full control before the OS and its security mechanisms launch.</li>
				<li><strong class="bold">Firmware rootkits</strong>: This group <a id="_idIndexMarker963"/>of threats targets <a id="_idIndexMarker964"/>firmware (such as <strong class="bold">Unified Extensible Firmware Interface</strong> (<strong class="bold">UEFI</strong>) or <strong class="bold">Basic Input/Output System</strong> (<strong class="bold">BIOS</strong>)) to <a id="_idIndexMarker965"/>achieve the earliest execution possible.</li>
				<li><strong class="bold">Hypervisor or virtual rootkits</strong>: At the<a id="_idIndexMarker966"/> time of writing, these threats exist mostly in the form of <strong class="bold">Proofs of Concept</strong> (<strong class="bold">PoCs</strong>). They <a id="_idIndexMarker967"/>are supposed to reside in Ring 1 (hypervisor).</li>
			</ul>
			<p>In this chapter, we will focus on kernel-mode rootkits and how they can hook multiple functions or modify kernel objects to hide malware. Before w<a id="_idTextAnchor694"/>e get into their hooking mechanisms, first, let's understand <a id="_idTextAnchor695"/>what device drivers are.</p>
			<h2 id="_idParaDest-237"><a id="_idTextAnchor696"/>What is a device driver?</h2>
			<p>Device drivers <a id="_idIndexMarker968"/>are kernel-mode tools that are created to interact with hardware. Each hardware manufacturer creates a device driver to communicate with their own hardware and translate the IRPs into requests that the hardware device understands.</p>
			<p>One of the main purposes of any OS is to standardize the channel of communication with any type of device, regardless of the vendor. For example, if you have replaced your wired mouse with a wireless one from a different vendor, it should not affect the applications that interact with the mouse in general. Additionally, if you are a developer, you should not worry about what type of keyboard or printer the user has.</p>
			<p>Device drivers make it possible to understand the I/O request and return the output in a standardized format, regardless of how the device works.</p>
			<p>There are other drivers as well that are not related to actual devices, such as antivirus modules and, in our case, rootkits. Kernel-mode rootkits are device drivers that use the capabilities that kernel mode provides to support the actual malware in terms of stealth and persistence.</p>
			<p>Now, let's take a look at how rootkits achieve their goals and what weaknesses in the execution path from user mode to kernel mod<a id="_idTextAnchor697"/><a id="_idTextAnchor698"/><a id="_idTextAnchor699"/>e they take advantage of.</p>
			<h1 id="_idParaDest-238"><a id="_idTextAnchor700"/>Hooking mechanisms</h1>
			<p>In this section, we <a id="_idIndexMarker969"/>will explore different types of hooking mechanisms. In the following diagram, we can see various types of hooking techniques that rootkits use at different stages of the request processing flow:</p>
			<div><div><img src="img/Figure_7.6_B18500_.jpg" alt="Figure 7.6 – The hooking mechanisms of rootkits&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.6 – The hooki<a id="_idTextAnchor701"/>ng mechanisms of rootkits</p>
			<p>Rootkits can install <a id="_idIndexMarker970"/>hooks at different stages of this process flow:</p>
			<ul>
				<li><strong class="bold">User-mode hooking/API hooking</strong>: These are the user-mode API hooking mechanisms <a id="_idIndexMarker971"/>that are used for hiding <a id="_idIndexMarker972"/>malware processes, files, registry keys, and <a id="_idIndexMarker973"/>more. We covered this in <a href="B18500_05.xhtml#_idTextAnchor446"><em class="italic">Chapter 5</em></a>, <em class="italic">Inspecting Process Injection and API Hooking</em>.</li>
				<li><code>sysenter</code> will transfer the execution to and intercept all requests from user mode to kernel mode.</li>
				<li><strong class="bold">SSDT hooking</strong>: This<a id="_idIndexMarker976"/> technique works more <a id="_idIndexMarker977"/>closely with the functions that the rootkit wants to hook. This type of hooking modifies the SSDT so that it redirects requests to a malicious function instead of the actual function that handles the request (it is similar to IAT hooking).</li>
				<li><strong class="bold">Code patching</strong>: Rather<a id="_idIndexMarker978"/> than modifying the <a id="_idIndexMarker979"/>SSDT, this rootkit patches the function that handles the request to call the malicious function at the start (it is similar to API hooking).</li>
				<li><strong class="bold">Layered drivers/IRP hooking</strong>: This <a id="_idIndexMarker980"/>is the <a id="_idIndexMarker981"/>legitimate technique for hooking <a id="_idIndexMarker982"/>and intercepting requests and modifying inputs and outputs. It is harder to detect as it is officially supported by Microsoft.</li>
			</ul>
			<p>We will also be exploring other techniques used <a id="_idIndexMarker983"/>by rootkits, such as <code>EPROCESS</code> and <code>ETHREAD</code>, which we talked about in <a href="B18500_03.xhtml#_idTextAnchor084"><em class="italic">Chapter 3</em></a>, <em class="italic">Basic Static and Dynamic Analysis for x86/x64</em>. Apart from that, <code>sysenter</code> be<a id="_idTextAnchor702"/>came the preferred method of doing this.</p>
			<p>Now, let's go thr<a id="_idTextAnchor703"/><a id="_idTextAnchor704"/><a id="_idTextAnchor705"/>ough these techniques in greater detail.</p>
			<h2 id="_idParaDest-239"><a id="_idTextAnchor706"/>Hooking the SYSENTER entry function</h2>
			<p>When a <a id="_idIndexMarker985"/>user-mode application<a id="_idIndexMarker986"/> executes <code>sysenter</code> (<code>int 0x2e</code> in Windows 2000 and earlier versions), the processor switches the execution to kernel mode and, in particular, to a <a id="_idIndexMarker987"/>specific address stored in the <strong class="bold">Model-Specific Register</strong> (<strong class="bold">MSR</strong>). MSRs <a id="_idIndexMarker988"/>are the control registers that are used for debugging, monitoring, toggling, or disabling various CPU features.</p>
			<p>There are<a id="_idIndexMarker989"/> several important registers <a id="_idIndexMarker990"/>for the user-mode-to-kernel-mode switching process when it's using <code>sysenter</code>:</p>
			<ul>
				<li><code>sysenter</code>; here, the SS segment register will be a CS value of + 8.</li><li><code>sysenter</code> is executed; it is where the arguments will be copied to.</li><li><code>sysenter</code>. It points to System Service Dispatcher.</li></ul></li>
				<li><code>KiSystemCall64</code>).</li><li><code>KiSystemCall32</code>).</li></ul></li>
			</ul>
			<p>These registers can be read and modified using the <code>rdmsr</code> and <code>wrmsr</code> assembly instructions, respectively. The <code>rdmsr</code> instruction takes the register ID in the <code>ecx/rcx</code> register and returns the result in <code>edx:eax</code> (<code>rdx:rax</code> registers in x64; the higher 32 bits in both registers are not used). An example of this is as follows:</p>
			<pre class="source-code">
mov ecx, 0x176 ; IA32_SYSENTER_EIP
rdmsr ; read msr register
mov &lt;eip_low&gt;, eax
mov &lt;eip_high&gt;, edx</pre>
			<p><code>wrmsr</code> is very similar to <code>rdmsr</code>. <code>wrmsr</code> takes the register ID in <code>ecx</code> and the value to write in the <code>edx:eax</code> pair. The <a id="_idIndexMarker992"/>hooking code is as follows:</p>
			<pre class="source-code">
mov ecx, 0x176 ; IA32_SYSENTER_EIP
xor edx, edx
mov eax, &lt;malicious_hooking_function&gt;
wrmsr ; write this value to IA32_SYSENTER_EIP</pre>
			<p>This technique has multiple drawbacks<a id="_idIndexMarker993"/>, as follows:</p>
			<ul>
				<li>For environments that have multiple processors, only one processor is hooked. This means that the attacker has to create multiple threads, hoping that they will run on all processors<a id="_idTextAnchor707"/> so that it becomes possible to hook all of them.</li>
				<li>The attacker needs to get the arguments from the user-mode stack and parse them.</li>
				<li>In this way, all functions are being hooked, so it is necessary to implement some filtration to check only the functions that are supposed to be hooked.</li>
			</ul>
			<p>This is the first place that malware can hoo<a id="_idTextAnchor708"/>k in kernel mode. Let's take a look at<a id="_idTextAnchor709"/> the second place, which is while modifying SSDT.</p>
			<h2 id="_idParaDest-240"><a id="_idTextAnchor710"/>Modifying SSDT in an x86 environment</h2>
			<p>First<a id="_idIndexMarker994"/> things first, the SSDT table is different from <a id="_idIndexMarker995"/>and pointed to by the first element of the <code>ntoskrnl.exe</code> under the name of <code>KeServiceDescriptorTable</code>. There are slots for four different SDT entries, but Windows has used only two of them at the time of writing: <code>KeServiceDescriptorTable</code> and <code>KeServiceDescriptorTableShadow</code>.</p>
			<p>When a user-mode application uses <code>sysenter</code>, as you saw in <em class="italic">Figure 7.3</em>, the application provides the function number or ID in the <code>eax</code> register. In <code>eax</code>, this value is divided in the following way:</p>
			<div><div><img src="img/Figure_7.7_B18500.jpg" alt="Figure 7.7 – The sysenter eax argument value &#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.7 – The sysenter eax argument value </p>
			<p>These values <a id="_idIndexMarker996"/>are as follows:</p>
			<ul>
				<li><code>bits 0-11</code>: This is<a id="_idIndexMarker997"/> the <strong class="bold">System Service Number</strong> (<strong class="bold">SSN</strong>), which is the index of this function in the SSDT</li>
				<li><code>bits 12-13</code>: This is the SDT, which represents the SDT number (here, <code>KeServiceDescriptorTable</code> is 0x00 and <code>KeServiceDescriptorTableShadow</code> is 0x01)</li>
				<li><code>bits 1<a id="_idTextAnchor711"/>4-31</code>: This value is not used and is filled with zeros</li>
			</ul>
			<p>The SDT stores an array of <code>SYSTEM_SERVICE_TABLE</code> entries with the first element mainly used by modern OSs. It consists of the following fields:</p>
			<ul>
				<li><code>KiServiceTable</code>: This is an SSDT table, an array of function addresses representing each SSN that can be passed via <code>eax</code> before <code>sysenter</code>.</li>
				<li><code>CounterBaseTable</code>: Not used in free (retail) versions of Windows.</li>
				<li><code>nSystemCalls</code>: This is the number of items in the <code>KiServiceTable</code> and <code>KiArgumentTable</code> tables.</li>
				<li><code>KiArgumentTable</code>: This is an array that is sorted in the same way as <code>KiServiceTable</code>. Here, each item includes the number of bytes that should be allocated for each function's arguments.</li>
			</ul>
			<p>For malware to hook this table, it needs to get <code>KeServiceDescriptorTable</code>, which is exported by <code>ntoskrnl.exe</code>, and then move to <code>KiServiceTable</code> and modify the function that it wants to hook. To be able to modify this table, it needs to disable the write protection (as this is a read-only table). There are multiple ways to do this, and the <a id="_idIndexMarker998"/>most common way is by modifying the <code>CR0</code> register value and setting the write-protection bit to zero:</p>
			<pre class="source-code">
PUSH EBX
MOV EBX, CR0
OR EBX, 0x00010000
MOV CR0,EBX
POP EBX</pre>
			<p>The full hooking mechanism looks as follows:</p>
			<div><div><img src="img/Figure_7.8_B18500.jpg" alt="Figure 7.8 – The SSDT hooking code from the winSRDF project&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure <a id="_idTextAnchor712"/>7.8 – The SSDT hooking code from the winSRDF project</p>
			<p>As you can see, the application was able to get the address of the SDT, which was exported under the <code>KeServiceDescriptorTable</code> name from <code>ntoskrnl.exe</code>. Then, it got the <code>KiServiceTable</code> array, disabled the write protection, and, finally, used <code>InterlockedExchange</code> to modify the table while no other thread was using it (<code>InterlockedExhange</code> protect<a id="_idTextAnchor713"/>s the application from writi<a id="_idTextAnchor714"/>ng at the same time when another thread is reading).</p>
			<h2 id="_idParaDest-241"><a id="_idTextAnchor715"/>Modifying SSDT in an x64 environment</h2>
			<p>For x64 environments, Windows<a id="_idIndexMarker999"/> implemented more protection from patching SSDT. Initially, SSDT hooking was used by malware and anti-malware products alike. It was also used by sandboxes and other behavioral antivirus tools. However, in the 64-bit version, Microsoft decided to stop this completely and began offering legitimate applications and other alternatives rather than SSDT hooking.</p>
			<p>Microsoft<a id="_idIndexMarker1000"/> implemented multiple forms of protection to stop SSDT hooking, such as <code>KeServiceDescriptorTable</code> via <code>ntoskrnl.exe</code>.</p>
			<p>Since <code>KeServiceDescriptorTable</code> is not exported, malware families started to search for functions that used this table to gain access to the addresses. One of the functions they used was <code>KiSystemServiceRepeat</code>.</p>
			<p>This function contains the following code:</p>
			<pre class="source-code">
lea r10, &lt;KeServiceDescriptorTable&gt;
lea r11, &lt;KeServiceDe<a id="_idTextAnchor716"/>scriptorTableShadow&gt;
test DWORD PTR [rbx + lOOh] , 80h</pre>
			<p>As you can see, this function uses the addresses of both SSDT entries. However, finding this function and the code inside it isn't very easy. As this function is close to <code>KiSystemCall64</code> (the <code>sysenter</code> entry function in the x64 environment), malware generally gets the address of <code>KiSystemCall64</code> using the <code>IA32_SYSENTER_EIP</code> MSR register. By doing so, it can start searching from it until it finds the preceding code. In general, malware searches for particular opcodes to find this function, as shown in the following screenshot:</p>
			<div><div><img src="img/Figure_7.9_B18500.jpg" alt="Figure 7.9 – SSDT hooking in the x64 environment by the zer0m0n project&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.9 – SSDT hooking in the x64 environment by the zer0m0n project</p>
			<p>This <a id="_idIndexMarker1001"/>mechanism is not completely reliable, and it could easily be broken in a later Windows version; however, it's one of the bes<a id="_idTextAnchor717"/><a id="_idTextAnchor718"/><a id="_idTextAnchor719"/>t-known mechanisms for finding an SSDT address in x64.</p>
			<h2 id="_idParaDest-242"><a id="_idTextAnchor720"/>Patching SSDT functions</h2>
			<p>The final technique<a id="_idIndexMarker1002"/> worth mentioning in SSDT hooking is hooking the functions that are referenced in the SSDT. This is very similar to API hooking. In this case, malware gets the function from the SSDT using the function ID and patches the first few bytes with <code>jmp &lt;malicious_func&gt;</code>. Then, it returns the execution to the original function after checking the process that called this function and its parameters.</p>
			<p>This technique is used because SSDT hooks can easily be detected by antivirus or rootkit scanning programs. It's easy to loop through all the functions inside the SSDT and search for a function that is outside<a id="_idTextAnchor721"/> the legitimate driver's or application's memory image.</p>
			<p>That's all for SSDT hooking; now, let's tak<a id="_idTextAnchor722"/>e a look at layered drivers, also known as IRP hooking.</p>
			<h2 id="_idParaDest-243"><a id="_idTextAnchor723"/>IRP hooking</h2>
			<p>IRPs are the<a id="_idIndexMarker1003"/> main objects that represent the input (a request) and <a id="_idIndexMarker1004"/>the output (a response) from a device. In many cases, a request packet is processed by a chain of drivers until the message can be understood by either the final device or the user-mode application (depending on the direction):</p>
			<div><div><img src="img/Figure_7.10_B18500.jpg" alt="Figure 7.10 – The structure of the IRP from the official documentation&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.10 – The structure of the IRP from the official documentation</p>
			<p>For example, consider that you want to play a music file (such as an MP3 file). Once the file has been opened by an application that understands MP3 format, it is converted into the format<a id="_idIndexMarker1005"/> that can be understood by a kernel-mode driver. Then, this driver simplifies it for the next driver and so on, until it reaches the actual speaker as an encoded group of waves. Another example is an electric signal from a keyboard, which is simplified to be a click on a button using an ID (for example, the <em class="italic">r</em> button). Then, it is passed to a keyboard driver, which understands that this is the letter <em class="italic">r</em> and passes it to the next one. This continues until it reaches, say, a text editor, such as Notepad, to write the letter <em class="italic">r</em>.</p>
			<p>So, how<a id="_idIndexMarker1006"/> does all of this relate to rootkits? Well, a rootkit that is present in a chain of drivers that processes IRP request packets can change the input or the output, thus manipulating the outcome. For example, when a malicious file is looked for by a researcher or an antivirus product, the driver can make it invisible. This is the only legitimate way that Windows allows developers to hook any request from user mode and modify its input and output.</p>
			<p>Now, let's learn how it will look in assembly.</p>
			<h3>Devices and major functions</h3>
			<p>For <a id="_idIndexMarker1007"/>any driver to be able to receive and handle IRP requests, it is necessary to create a device object. This device can be attached to a chain of device drivers that process a specific type of IRP request. For example, if the attackers want to hook filesystem requests, they need to create a device and attach it to the chain of filesystem devices. After this, it becomes possible to start receiving IRP requests associated with this filesystem (such as opening a file or querying a directory).</p>
			<p>Creating a device object is simple: the driver can simply call the <code>IoCreateDevice</code> API and provide the flags that correspond to the device it wants to attach to. For malware analysis, these flags could help you understand the goal of this device, such as the <code>FILE_DEVICE_DISK_FILE_SYSTEM</code> flag.</p>
			<p>The driver also needs to set up all the dispatch functions (following the <code>DRIVER_DISPATCH</code> structure) that will receive and handle these requests. Each IRP request has a major function code in <code>IRP_MJ_XXX</code> format. This code helps us understand what this IRP request is about, such as <code>IRP_MJ_CREATE</code> (this could be used for creating a file or opening a file) or <code>IRP_MJ_DIRECTORY_CONTROL</code> (this could be used for querying a directory). The initialization is done by placing a pointer to the dispatch function in the right place in the <code>MajorFunction</code> array of <code>DriverObject</code> (following the <code>_DRIVER_OBJECT</code> structure), where <code>IPR_MJ_XXX</code> codes serve as indexes. Here is an example of the code implementing this setup:</p>
			<div><div><img src="img/Figure_7.11_B18500.jpg" alt="Figure 7.11 – Setting up the major functions&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.11 – Setting up the major functions</p>
			<p>In each of<a id="_idIndexMarker1008"/> these functions, the driver can get the parameters of this request from what is known as the IRP stack. The IRP stack contains all the necessary information related to this request, and the driver can add, modify, or remove them along the way. To get the pointer to this stack, the driver calls the <code>IoGetCurrentIrpStackLocation</code> API and provides the address of the IRP of interest. The following is an example of a<a id="_idTextAnchor724"/> major function that filters files with the <code>_root_</code> name:</p>
			<div><div><img src="img/Figure_7.12_B18500.jpg" alt="Figure 7.12 – A major function creates a ﬁlter to process ﬁles with the &quot;_root_&quot; name&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.12 – A major function creates a ﬁlter to process ﬁles with the "_root_" name</p>
			<p>After the rootkit has created its device(s) and set up its major functions, it can hook the corresponding requests by attach<a id="_idTextAnchor725"/>ing itself to the device that receives the requests of the rootkit's interest.</p>
			<p>From the user-mode side, software can also send custom requests to drivers by utilizing <code>DeviceIoControl</code> API. Calling this function will create an <code>IRP_MJ_DEVICE_CONTROL</code> request. Some IOCTLs are public in that they are system-defined and documented by Microsoft, while some are private in that they are unique to a particular piece of software, including malware. It is also worth <a id="_idIndexMarker1010"/>mentioning that upper-level drivers can send IOCTL codes to lower-level drivers using the <code>IRP_MJ_DEVICE_CONTROL</code> and <code>IRP_MJ_INTERNAL_DEVICE_CONTROL</code> requests. The drivers process them the same way as any other IRPs – by registering dedica<a id="_idTextAnchor726"/>ted <code>DRIVER_DISPATCH</code> callback functions in the driver object.</p>
			<h3>Attaching to a device</h3>
			<p>For the rootkit to<a id="_idIndexMarker1011"/> attach to a named device (for example, <code>\\FileSystem\\fastfat</code>, to receive filesystem requests), it needs to get the device object for that named device. There are multiple ways to do this, and one of them is to use the undocumented <code>ObReferenceObjectByName</code> API. Once the device object is found, the rootkit can use the <code>IoAttachDeviceToDeviceStack</code> API to attach to its chain of drivers and receive the IRP requests that are sent to it. The code for this could be as<a id="_idTextAnchor727"/> follows:</p>
			<div><div><img src="img/Figure_7.13_B18500.jpg" alt="Figure 7.13 – Attaching to the FastFat ﬁlesystem&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.13 – Attaching to the FastFat ﬁlesystem</p>
			<p>After executing the <code>IoAttachDeviceToDeviceStack</code> API, the driver will be added to the top of the chain, which means that the rootkit driver will be the first driver to receive the IRP requests. Then, it can pass requests along to the next driver using the <code>IoCallDriver</code> API. Additionally, the rootki<a id="_idTextAnchor728"/>t would be the last driver to modify the res<a id="_idTextAnchor729"/>ponse of the IRP request after setting a completion routine.</p>
			<h3>Modifying the IRP response and setting a completion routine</h3>
			<p>Completion routines <a id="_idIndexMarker1012"/>cover situations where more <a id="_idIndexMarker1013"/>processing is required after the request is processed by the last driver. For a rootkit, completion routines allow it to modify the output of the request; for example, deleting a filename from a list of files in a specific directory. Setting up a completion routine requires it to copy the request parameters to the lower driver in the chain. To copy these parameters to the next driver's stack, the rootkit can use the <code>IoCopyCurrentIrpStackLocationToNext</code> API.</p>
			<p>Once all the parameters have been copied for the next driver, the malware can set the completion routine using <code>IoSetCompletionRoutine</code>, and then pass this request to the next driver using <code>IoCallDriver</code>. An example from the Microsoft documentation is as follows:</p>
			<pre class="source-code">
IoCopyCurrentIrpStackLocationToNext( Irp ); IoSetCompletionRoutine(
  Irp, // Irp
  MyLegacyFilterPassThroughCompletion, // CompletionRoutine
  NULL, // Context
  TRUE, // InvokeOnSuccess
  TRUE, // InvokeOnError
  TRUE); // InvokeOnCancel
return IoCallDriver(NextLowerDriverDeviceObject, Irp);</pre>
			<p>Once the last driver in the chain executes the <code>IoCompleteRequest</code> API, the completion routines will be executed one by one, starting from the lowest driver's completion routine to the highest. If the rootki<a id="_idTextAnchor730"/>t is the last driver attached to this device, it will have its completion routine executed last.</p>
			<p>Now, let's learn about another techniqu<a id="_idTextAnchor731"/>e that's commonly used by rootkits to hide malicious activity.</p>
			<h1 id="_idParaDest-244"><a id="_idTextAnchor732"/>DKOM</h1>
			<p>DKOM is <a id="_idIndexMarker1014"/>one of the most common techniques used by rootkits to hide malicious user-mode processes. This technique relies on how the OS represents processes and threads. To understand this technique, you need to learn more about the objects t<a id="_idTextAnchor733"/><a id="_idTextAnchor734"/><a id="_idTextAnchor735"/>hat are being manipulated by the rootkit: <code>EPROCESS</code> and <code>ETHREAD</code>.</p>
			<h2 id="_idParaDest-245"><a id="_idTextAnchor736"/>The kernel objects – EPROCESS and ETHREAD</h2>
			<p>Windows creates <a id="_idIndexMarker1015"/>an<a id="_idIndexMarker1016"/> object called <code>EPROCESS</code> for each process that's created in the system. This object includes all the important information about this process, such <a id="_idIndexMarker1017"/>as its <code>ActiveProcessLinks</code>, which connects all <code>EPROCESS</code> objects of all processes. Each <code>EPROCESS</code> includes an address to the next <code>EPROCESS</code> object (which represents the next process) called <code>FLink</code> and the address to the previous <code>EPROCESS</code> object (which is associated with the previous process) called <code>BLink</code>. Both addresses are sto<a id="_idTextAnchor737"/>red in <code>ActiveProcessLinks</code>:</p>
			<div><div><img src="img/Figure_7.14_B18500.jpg" alt="Figure 7.14 – The EPROCESS structure&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.14 – The EPROCESS structure</p>
			<p>The<a id="_idIndexMarker1018"/> exact structure of <code>EPROCESS</code> changes from one version of the OS to another. That is, some fields get added, some get removed, and, sometimes, rearrangements happen. Rootkits have to keep up with these changes if they want to manipulate these structures.</p>
			<p>Before we dive into the object <a id="_idIndexMarker1019"/>manipulation strategies, there's another object that you need to know about: <code>ETHREAD</code>. <code>ETHREAD</code>, and its core, <code>KTHREAD</code>, includes all the information related to a specific thread, including its context, status, and the address of the correspondin<a id="_idTextAnchor738"/>g process object (<code>EPROCESS</code>):</p>
			<div><div><img src="img/Figure_7.15_B18500.jpg" alt="Figure 7.15 – The ETHREAD structure&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.15 – The ETHREAD structure</p>
			<p>When<a id="_idIndexMarker1020"/> Windows switches between<a id="_idIndexMarker1021"/> threads, it follows the links between them in the <code>ETHREAD</code> structure (that is, the linked list that connects all <code>ETHREAD</code> objects). From this object, it loads the thread's process (following its <code>EPROCESS</code> address) and then loads the thread context to execute it. This process of loading each thread is not directly connected to the linked list that connects all processes (particularly, their <code>EPRO<a id="_idTextAnchor739"/><a id="_idTextAnchor740"/>CESS</code> representations), and this is what makes the DKOM so effective.</p>
			<h2 id="_idParaDest-246"><a id="_idTextAnchor741"/>How do rootkits perform an object manipulation attack?</h2>
			<p>For a<a id="_idIndexMarker1022"/> rootkit to hide a process, it is enough to modify <code>ActiveProcessLink</code> in the previous and the following <code>EPROCESS</code> objects (relative to malware) to skip the <code>EPROCESS</code> address of the process it wants to hide. The steps are simple and are given as follows:</p>
			<ol>
				<li value="1">Get the current process's <code>EPROCESS</code> using the <code>PsLookupProcessByProcessId</code> API.</li>
				<li>Follow the ActiveProcessLinks to find the <code>EPROCESS</code> object of the process that needs to be hidden.</li>
				<li>Change the <code>FLink</code> property of the previous <code>EPROCESS</code> so that it doesn't point to this <code>EPROCESS</code> but the next one instead.</li>
				<li>Change the <code>BLink</code> property of the next process so that it doesn't point to this <code>EPROCESS</code> but the previous one instead.</li>
			</ol>
			<p>The <a id="_idIndexMarker1023"/>challenging part in this process is to reliably find the <code>ActiveProcessLinks</code> with all the changes that Windows introduces from one version to another. There are multiple techniques for dealing with the offset of <code>ActiveProcessLinks</code> (and the process ID as well), as follows:</p>
			<ol>
				<li value="1">Get the OS version and, based on that version, choose the right offset from the precalculated offsets for each version of the OS.</li>
				<li>Search for the process ID (you can get it from <code>PsGetCurren<a id="_idTextAnchor742"/>tProcessId</code>) and find the <code>ActiveProcessLinks</code> offset from the process ID.</li>
			</ol>
			<p>Here is an example of the second technique:</p>
			<div><div><img src="img/Figure_7.16_B18500.jpg" alt="Figure 7.16 – Finding the process ID from the EPROCESS object&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.16 – Finding the process ID from the EPROCESS object</p>
			<p>Once <a id="_idIndexMarker1024"/>the rootkit can find the process ID (<code>pids</code>) inside the <code>EPROCESS</code> object (<code>epocs</code>), it can use the offset between <code>ActiveProcessLinks</code> and the process ID (this is usually precalculated and is the next field in the structure). The last step is to remove the<a id="_idTextAnchor743"/> links between the processes, as shown in the following screenshot:</p>
			<div><div><img src="img/Figure_7.17_B18500.jpg" alt="Figure 7.17 – Removing the process links to perform a DKOM attack&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.17 – Removing the process links to perform a DKOM attack</p>
			<p>This<a id="_idIndexMarker1025"/> is what the result will look like:</p>
			<div><div><img src="img/Figure_7.18_B18500.jpg" alt="Figure 7.18 – DKOM attack – the process in the middle is skipped during traversal&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.18 – DKOM attack – the process in the middle is skipped during traversal</p>
			<p>The most popular technique for detecting DKOM attacks is to loop through all the running threads and follow their link to <code>EPROCESS</code>, before comparing the results with the data obtained<a id="_idIndexMarker1026"/> by following <code>ActiveProcessLinks</code>. If there's a missing <code>EPROCESS</code> object in <code>ActiveProcessLink</code> that appeared as an <code>EPROCESS</code> for an active thread, it implies that a DKOM attack is being performed by a rootkit to hide this process and its <code>EPROCESS</code> object.</p>
			<p>Now, let's <a id="_idTextAnchor744"/><a id="_idTextAnchor745"/>talk about how malware can perform process injection from kernel mode.</p>
			<h1 id="_idParaDest-247"><a id="_idTextAnchor746"/>Process injection in kernel mode</h1>
			<p>Process injection<a id="_idIndexMarker1027"/> in kernel mode is a popular technique <a id="_idIndexMarker1028"/>used by multiple malware families, including <strong class="bold">Stuxnet</strong> (with its <strong class="bold">MRxCls</strong> rootkit), to<a id="_idIndexMarker1029"/> create another way of <a id="_idIndexMarker1030"/>maintaining persistence and disguising malware activities under a legitimate process name. For a device driver to be able to read and write memory inside a process, it needs to attach itself to this process's memory space.</p>
			<p>Once the driver is attached to this process's memory space, it can see this process's virtual memory, and it becomes possible to read and write directly to it. For example, if the process executable's ImageBase is <code>0x00400000</code>, then the driver can <a id="_idTextAnchor747"/>access it normally, as follows:</p>
			<pre class="source-code">
CMP WORD PTR [00400000h], 'ZM'
JNZ &lt;not_mz&gt;</pre>
			<p>For a driver to be able to attach to the process memory, it needs to get its <code>EPROCESS</code> using the <code>PsLookupProcessByProcessId</code> API and then use the <code>KeStackAttachProcess</code> API to attach to this process's memory space. In disassembly, the code will be as follows:</p>
			<div><div><img src="img/Figure_7.19_B18500.jpg" alt="Figure 7.19 – Getting the EPROCESS object using its PID (from the Stuxnet rootkit, MRxCls)&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.19 – Get<a id="_idTextAnchor748"/>ting the EPROCESS object using its PID (from the Stuxnet rootkit, MRxCls)</p>
			<p>Then, to <a id="_idIndexMarker1031"/>attach<a id="_idIndexMarker1032"/> to that process's memory space, you can use t<a id="_idTextAnchor749"/>he following code:</p>
			<div><div><img src="img/Figure_7.20_B18500.jpg" alt="Figure 7.20 – Attaching to the process's memory space&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.20 – Attaching to the process's memory space</p>
			<p>Once <a id="_idIndexMarker1033"/>the driver is attached, it can read and write <a id="_idIndexMarker1034"/>to its memory space, as well as allocate memory using the <code>ZwAllocateVirtualMemory</code> API, providing the process handle using the <code>ZwOpenProcess</code> API (which is equivalent to <code>OpenProcess</code> in user mode).</p>
			<p>For a driver to detach from the process memory, it can execute the <code>KeUnstackDetachProcess</code> API, as follows:</p>
			<pre class="source-code">
KeUnstackDetachProcess(APCState);</pre>
			<p>There are other techniques as well, but this technique is the most common way for any driver to e<a id="_idTextAnchor750"/>asily access the virtual memory of any process as its own me<a id="_idTextAnchor751"/>mory. Now, let's take a look at how it can execute code inside that process.</p>
			<h2 id="_idParaDest-248"><a id="_idTextAnchor752"/>Executing the inject code using APC queuing</h2>
			<p>An <code>SleepEx</code>, <code>SignalObjectAndWait</code>, <code>MsgWaitForMultipleObjectsEx</code>, <code>WaitForMultipleObjectsEx</code>, or <code>WaitForSingleObjectEx</code> APIs) and before it gets resumed, all the queued user-mode and kernel-mode APC functions are executed in the context of that thread, allowing the malware to execute user-mode code inside that process before returning control to it.</p>
			<p>For a <a id="_idIndexMarker1036"/>malware sample to queue an APC function, it needs to perform the following steps:</p>
			<ol>
				<li value="1">Get the <code>ETHREAD</code> object of the thread it wants to queue an APC function by providing <a id="_idIndexMarker1037"/>its <code>PsLookupThreadByThreadId</code> API.</li>
			</ol>
			<p>Attach the user-mode function to this thread using the <code>KeInitializeApc</code> API.</p>
			<ol>
				<li value="2">Add this function to the queue of the APC functions to be executed in this thread using the <code>KeInsertQueueApc</code> API, as shown in the following screenshot:</li>
			</ol>
			<div><div><img src="img/Figure_7.21_B18500.jpg" alt="Figure 7.21 – APC queuing to execute a user-mode function (from the winSRDF project)&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figur<a id="_idTextAnchor753"/>e 7.21 – APC queuing to execute a user-mode function (from the winSRDF project)</p>
			<p>In this<a id="_idIndexMarker1038"/> example, the <code>KeInitializeApc</code> API will execute a kernel-mode function called <code>ApcKernelRoutine</code> and a user-mode function called <code>Entrypoint</code> once the thread returns from its alertable state.</p>
			<p>If the thread didn't execute any of the previously mentioned APIs and never enters an alertable state until it is terminated, none of the queued APC functions will be executed. Therefore, some malware families tend to attach their APC thread to multiple running threads in the application.</p>
			<p>Other rootkits, such as MRxCls (from Stuxnet), modify the entry point of the application before it gets executed. This allows the malicious code to be executed in the context o<a id="_idTextAnchor754"/>f the main<a id="_idIndexMarker1039"/> thread before the application runs and without using any APC queuing functionality.</p>
			<p>At this stage, we have learned enough about how rootkits generally work, s<a id="_idTextAnchor755"/>o let's talk about what protection mechanisms have been developed to fight them.</p>
			<h1 id="_idParaDest-249"><a id="_idTextAnchor756"/>KPP in x64 systems (PatchGuard)</h1>
			<p>In x64 systems, Microsoft<a id="_idIndexMarker1040"/> has introduced new protection against kernel-mode hooking and patching called <strong class="bold">KPP</strong>, or <strong class="bold">PatchGuard</strong>. This protection disables any patching of the SSDT and the core kernel code. It doesn't allow the usage of kernel stacks beyond what was allocated by the kernel itself.</p>
			<p>Additionally, Microsoft allows only signed drivers to be loaded in the x64 systems, except for situations when the system is running in test mode or driver signature enforcement is disabled.</p>
			<p>KPP received lots of criticism from antivirus and firewall vendors when it was first introduced because SSDT hooking and other hooking types were heavily used in multiple security products. Microsoft has created a new API to help antivirus products replace their hooking methods.</p>
			<p>Although several ways of bypassing PatchGuard have been documented, for the last several years, Microsoft has released only a few major updates to deal with these techniques. In addition, the PatchGuard code is changing its position in kernel mode from one update to another, making it a moving target and breaking all the previous malware families that had been able to bypass it in the previous versions.</p>
			<p>Now, let's take a look at different by<a id="_idTextAnchor757"/><a id="_idTextAnchor758"/><a id="_idTextAnchor759"/>passing techniques that were introduced in some of the previous malware families.</p>
			<h2 id="_idParaDest-250"><a id="_idTextAnchor760"/>Bypassing driver signature enforcement</h2>
			<p>Apart from the <a id="_idIndexMarker1041"/>ability to use stolen certificates to sign the malicious driver (an example of this could be Stuxnet drivers), it's also possible to disable the driver signature enforcement option using the Command Prompt, as follows:</p>
			<pre>bcdedit.exe /set testsigning on</pre>
			<p>In this case, the <a id="_idIndexMarker1042"/>system will start allowing drivers to be signed with certificates that are not issued by Microsoft. This command requires administrator privileges and the machine to be restarted afterward. However, with the help of social engineering, it's possible to trick the user into making it. Another option that used to be available was the following command:</p>
			<pre>bcdedit /set nointegritychecks on</pre>
			<p>However, at the time of writing, this option is ignored on major modern versions of Windows.</p>
			<p>Additionally, some malware families abuse vulnerable signed drivers of legitimate products, which either have code execution vulnerabilities or vulnerabilities that allow the arbitrary memory inside the kernel to be modified. An example of this is Turla malware (which is believed to be state-sponsored APT malware). It loads a VirtualBox dr<a id="_idTextAnchor761"/>iver and uses it to amend the <code>g_CiEnabled</code> kernel variable and, by doing so, disabl<a id="_idTextAnchor762"/>e driver signature enforcement on the fly (without the need to restart the system).</p>
			<h2 id="_idParaDest-251"><a id="_idTextAnchor763"/>Bypassing PatchGuard – the Turla example</h2>
			<p>Turla was <a id="_idIndexMarker1043"/>also able to bypass PatchGuard by disabling its ability to show the blue screen of death when the system integrity check fails. After PatchGuard detects the unauthorized patching of the system kernel or its important tables (such as SSDT or IDT), it calls the <code>KeBugCheckEx</code> API to show the blue screen of death. Turla malware hooks this API and continues its execution normally.</p>
			<p>A later version of PatchGuard was cloning this API on-the-fly to ensure that the verification was enforced and caused the system to shut down. However, Turla was able to hook an early subroutine in the <code>KeBugCheckEx</code> API to make sure it was able to resume the execution of the system normally after the integrity check failed. The following code is a snippet of the <code>KeBugCheckEx</code> API:</p>
			<pre class="source-code">
mov qword ptr [rsp+8],rcx
mov qword ptr [r<a id="_idTextAnchor764"/>sp+10h],rdx
mov qword ptr [rsp+18h],r8
mov qword ptr [rsp+20h],r9
pushfq
sub rsp,30h
cli
mov rcx, qword ptr gs:[20h]
add rcx,120h
call nt!RtlCaptureContext</pre>
			<p><a id="_idTextAnchor765"/>As you can see, it <a id="_idIndexMarker1044"/>executes a function called <a id="_idTextAnchor766"/><code>RtlCaptureContext</code>, which is what Turla malware decided to hook to bypass this update.</p>
			<h2 id="_idParaDest-252"><a id="_idTextAnchor767"/>Bypassing PatchGuard – GhostHook</h2>
			<p>This <a id="_idIndexMarker1045"/>technique was introduced by the CyberArk research team in 2017. It abuses a new feature that was introduced by Intel called <strong class="bold">Intel Processor Trace</strong> (<strong class="bold">Intel PT</strong>). This <a id="_idIndexMarker1046"/>technology allows debugging software to trace single processes, user-mode and kernel-mode execution, or perform instruction pointer tracing. This Intel PT technology was designed for performance monitoring, diagnostic code coverage, debugging, fuzzing, malware analysis, and exploit detection.</p>
			<p>Intel processors <a id="_idIndexMarker1047"/>and their <code>callback</code> routine to handle the memory space issue. This <code>callback</code> function (that is, the PMI handler) is a function that is targeted by the malware as it gets executed in the context of the running thread that is being monitored.</p>
			<p>Under specific circumstances and by using a very small buffer, malware can force the execution of its PMI handler after each <code>sysenter</code> call and perform another technique, known as<a id="_idTextAnchor768"/> <code>sysenter</code> hooking, without alerting the PatchGuard protection and without the need to do API hooking.</p>
			<p>Now, we will take a<a id="_idTextAnchor769"/> look at how to analyze rootkits and, in particular, how to dynamically analyze rootkits.</p>
			<h1 id="_idParaDest-253"><a id="_idTextAnchor770"/>Static and dynamic analysis in kernel mode</h1>
			<p>Once we know how rootkits work, it becomes possible to analyze them. The first thing worth mentioning is that not all kernel-mode malware families just hide the presence of actual payloads – some of them can perform malicious actions on their own as well. In this section, we will familiarize ourselves with tools that can facilitate rootkit analysi<a id="_idTextAnchor771"/>s to understand malware functionalities and learn some particular usage-related nuances.</p>
			<h2 id="_idParaDest-254"><a id="_idTextAnchor772"/>Static analysis</h2>
			<p>It always <a id="_idIndexMarker1048"/>makes sense to start from static analysis, especially if <a id="_idIndexMarker1049"/>the debugging setup is not available straight away. In so<a id="_idTextAnchor773"/>me cases, it is possible to perform both static and dynamic analysis using the same tools.</p>
			<h3>Rootkit file structure</h3>
			<p>Rootkit samples are<a id="_idIndexMarker1050"/> usually drivers that implement the traditional MZ-PE structure with the <code>IMAGE_SUBSYSTEM_NATIVE</code>  value specified in the subsystem field of the <code>IMAGE_OPTIONAL_HEADER32</code> structure. They use the usual x86 or x64 instructions that we are already familiar with. Thus, any tool (excluding user-mode debuggers such as OllyDbg) that <a id="_idIndexMarker1051"/>supports them should handle rootkits without any major problems. Examples of them include tools such as IDA, radare2, and many others. Additionally, IDA plugins<a id="_idIndexMarker1052"/> such as <strong class="bold">win_driver_plugin</strong> and <strong class="bold">DriverBuddy</strong> can be very useful for auxiliary operations, such as decoding the IOCTL codes involved.</p>
			<h3>Analysis workflow</h3>
			<p>Once the <a id="_idIndexMarker1053"/>sample is open, the first step is to track down <code>DriverObject</code>, which is provided as the first argument of the main function (through the stack for 32-bit systems and the <code>rcx</code> register for 64-bit systems). In this way, we can monitor whether any of the major functions are defined by malware. This object <a id="_idIndexMarker1054"/>implements the <code>_DRIVER_OBJECT</code> structure with a list of major functions located at the end of it. The corresponding structure member is as follows:</p>
			<pre class="source-code">
PDRIVER_DISPATCH MajorFunction[IRP_MJ_MAXIMUM_FUNCTION + 1];</pre>
			<p>In assembly, they will likely be accessed by offsets and can easily be mapped by applying this structure.</p>
			<p>Additionally, it is worth checking whether any completion routine is specified using the <code>IoSetCompletionRoutine</code> API.</p>
			<p>Then, we need to search for the presence of instructions that allow us to disable security measures such as the previously mentioned write protection, which involves using the <code>CR0</code> register. In this way, it becomes possible to easily identify the exact location in the code where this functionality is implemented.</p>
			<p>Following this, we need to keep track of the crucial import functions we've already discussed, which are most commonly used by rootkits, and check the corresponding argument strings to learn their purpose. Are there any devices malware attaches to? Is there any process or filename mentioned there? Once all these questions have been answered, it becomes possible to figure out the rootkit's goal.</p>
			<p>Finally, if import functions are resolved dynamically, it makes sense to restore them before continuing the <a id="_idTextAnchor774"/>analysis. Generally, this can be done either by scripting or with the help of dynamic analysis.</p>
			<h2 id="_idParaDest-255"><a id="_idTextAnchor775"/>Dynamic and behavioral analysis</h2>
			<p>The<a id="_idIndexMarker1055"/> dynamic analysis of kernel-mode threats is a trickier part here because it<a id="_idIndexMarker1056"/> is performed on a low level, and any mistake may result in a system crash. Therefore, it is highly recommended to perform it on <strong class="bold">virtual machines</strong> (<strong class="bold">VMs</strong>) so<a id="_idIndexMarker1057"/> that the debugging state can be quickly restored to the previous state. Another option is to use a separate machine that is attached using a serial p<a id="_idTextAnchor776"/><a id="_idTextAnchor777"/><a id="_idTextAnchor778"/>ort. However, in this case, it generally takes more effort to restore the previous debugging state.</p>
			<h3>Debuggers</h3>
			<p>When we talk about dynamic analysis, the main group of tools we are referring to is debuggers. The<a id="_idIndexMarker1058"/> most popular <a id="_idIndexMarker1059"/>debuggers are as follows:</p>
			<ul>
				<li><code>.</code>"), and extension commands (the ones that start with "<code>!</code>"). Here are some of the most common commands that are used when performing rootkit analysis:<ul><li><code>?</code>: This is used to display regular commands.</li><li><code>.help</code>: This is used to display meta-commands.</li><li><code>.hh</code>: This is used to open the documentation for the specified command.</li><li><code>bp</code>, <code>bu</code>, and <code>ba</code>: These are used to set breakpoints, including the usual breakpoint, the unresolved breakpoint (this is activated once the module is loaded), and the breakpoint on access.</li><li><code>bl</code>, <code>bd</code>, <code>be</code>, and <code>bc</code>: These are used to list, disable, enable, and clear breakpoints, respectively.</li><li><code>g</code>, <code>p</code>, and <code>t</code>: These commands refer to go (continue execution), single step, and single trace, respectively.</li><li><code>d</code> and <code>u</code>: These commands display memory and disassembled instructions, respectively.</li><li><code>e</code>: This is used to enter specified values into memory (that is, edit memory).</li><li><code>dt</code>: This is used to parse and describe data types. For example, <code>dt ntdll!_PEB</code> will display the PEB structure with offsets, field names, and data types.</li><li><code>r</code>: This <a id="_idIndexMarker1063"/>allows you to display or modify registers. Here, <code>r eip=&lt;val&gt;</code> can be used to change the instruction pointer.</li><li><code>x</code>: This is used to list symbols that match the pattern; for example, <code>x ntdll!*</code> will list all symbols from <code>ntdll</code>.</li><li><code>lm</code>: This is used<a id="_idTextAnchor779"/> to<a id="_idIndexMarker1064"/> list modules; it works by displaying a list of loaded drivers and their corresponding memory ranges.</li><li><code>!dh</code>: This is a dump header command; it can be used to parse and display the MZ-PE header by ImageBase.</li><li><code>!process</code>: This displays various pieces of information about the specified process, including the PEB address. For example, <code>!process 0 0 lsass.exe</code> will display basic information about <code>lsass.exe</code>, and the 7 flag can be used to display full details, including TEB structures.</li><li><code>.process</code>: This command sets the process context. For example, <code>.process /i &lt;PROCESS&gt;</code> (where the <code>&lt;PROCESS&gt;</code> value can be taken from the output of the <code>!process</code> command that was previously mentioned) followed by <code>g</code> and <code>.reload /user</code> allows you to switch to the debugging of the specified process.</li><li><code>!peb</code>: This parses and displays the PEB structure of the specified process. This command can help you switch to the process context using the <code>.process</code> command first.</li><li><code>!teb</code>: This parses and displays the specified TEB structure.</li><li><code>.shell</code>: This allows you to use Windows console commands from WinDbg. For example, <code>.shell -ci "&lt;windbg_command&gt;" findstr &lt;value&gt;</code> will allow you to parse the output of executed commands.</li><li><code>.writemem</code>: This dumps memory to a file.</li></ul></li>
				<li><strong class="bold">IDA</strong>: While <a id="_idIndexMarker1065"/>unable to debug kernel-mode code on <a id="_idIndexMarker1066"/>its own, this can be used as a UI for WinDbg. In this way, it can allow you to store all markup from the static analysis and debug code in the same place.</li>
				<li><strong class="bold">radare2</strong>: Same<a id="_idIndexMarker1067"/> as IDA, this tool can be used on top<a id="_idIndexMarker1068"/> of WinDbg with a dedicated plugin.</li>
				<li><strong class="bold">SoftICE (obsolete)</strong>: This<a id="_idIndexMarker1069"/> was once one of the<a id="_idIndexMarker1070"/> most popular tools for performing low-level dynamic analysis on Windows. At the time of writing, the tool is obsolete and doesn't support new systems.</li>
			</ul>
			<p>Apart from this, there are several other<a id="_idIndexMarker1071"/> kernel-mode debuggers, s<a id="_idTextAnchor780"/><a id="_idTextAnchor781"/><a id="_idTextAnchor782"/>uch as <strong class="bold">Syser</strong>, <strong class="bold">Rasta Ring 0 Debugger</strong> (<strong class="bold">RR0D</strong>), <strong class="bold">HyperDbg</strong>, and <strong class="bold">BugChecker</strong>, that<a id="_idIndexMarker1072"/> don't appear<a id="_idIndexMarker1073"/> to be <a id="_idIndexMarker1074"/>maintained anymore.</p>
			<h3>Monitors</h3>
			<p>These tools<a id="_idIndexMarker1075"/> are supposed to give us insight into various objects and events associated with kernel mode:</p>
			<ul>
				<li><strong class="bold">DriverView</strong>: This<a id="_idIndexMarker1076"/> is a tool developed by NirSoft; it allows you to quickly get a list of loaded drivers and their location in memory.</li>
				<li><strong class="bold">DebugView</strong>: This <a id="_idIndexMarker1077"/>is a Sysinternals tool that allows you to monitor the debugging output from both user and kernel mode.</li>
				<li><strong class="bold">WinObj</strong>: This<a id="_idIndexMarker1078"/> is another useful tool fro<a id="_idTextAnchor783"/>m Sysinternals that can present a list of various system objects relevant to kernel-mode debug<a id="_idTextAnchor784"/>ging, such as devices and drivers.</li>
			</ul>
			<p>Using them may give you a quick insight into the current global state of the system.</p>
			<h3>Rootkit detectors</h3>
			<p>This group of <a id="_idIndexMarker1079"/>tools checks for the <a id="_idIndexMarker1080"/>presence of techniques commonly used by rootkits in the system and provides detailed information. They are very useful for behavioral analysis to confirm that the sample has been loaded properly. Additionally, they can be used to determine the functionality of the sample relatively quickly. Some of the most popular tools are as follows:</p>
			<ul>
				<li><strong class="bold">GMER</strong>: This <a id="_idIndexMarker1081"/>powerful tool supports multiple rootkit patterns and provides relatively detailed technical information. It can search for various hidden artifacts, such as processes, services, files, registry keys, and more. Additionally, it features the rootkit removal tool.</li>
				<li><strong class="bold">RootkitRevealer</strong>: This<a id="_idIndexMarker1082"/> is another advanced rootkit detection tool, this time from Sysinternals. Unlike GMER, its output is less technical, and it hasn't been updated for a while.</li>
				<li>Other <a id="_idIndexMarker1083"/>rootkit <a id="_idIndexMarker1084"/>detection<a id="_idIndexMarker1085"/> tools (now discontinued) include <strong class="bold">Rootkit Unhooker</strong>, <strong class="bold">DarkSpy</strong>, and <strong class="bold">IceSword</strong>.</li>
			</ul>
			<p>Apart from<a id="_idIndexMarker1086"/> these, multiple rootkit removal tools are be<a id="_idTextAnchor785"/><a id="_idTextAnchor786"/><a id="_idTextAnchor787"/>ing developed by antivirus vendors; however, they generally don't provide enough information to technically analyze the threat.</p>
			<h2 id="_idParaDest-256"><a id="_idTextAnchor788"/>Setting up a testing environment</h2>
			<p>There are <a id="_idIndexMarker1087"/>several options available for performing kernel-mode debugging:</p>
			<ul>
				<li><strong class="bold">The debugger client is running on the target machine</strong>: An example of such a setup is WinDbg or the KD debugger, utilizing local kernel debugging or working together with<a id="_idIndexMarker1088"/> the <strong class="bold">LiveKd</strong> tool. This approach doesn't require an engineer to set up a remote connection, but not all the commands will be available in this case.</li>
				<li><strong class="bold">The debugger client is running on the host machine</strong>: Here, the virtual or another physical machine is used to execute a sample, and all the debugging tools with the result of your work in the form of markup are stored outside of it. This approach may take slightly more time to set up, but it is generally recommended as it will save lots of time and effort later.</li>
				<li><strong class="bold">The debugger client is running on the remote machine</strong>: This setup is not commonly used; the idea here is that the host machine is running a debugging server that can interact with the target machine, and the engineer connects to this server remotely from a third machine. This technique is called remote debugging by Microsoft.</li>
			</ul>
			<p>The exact way to set up a connection between host and target machines may vary, depending on the engineer's preferences. Generally, this is done either through a network or through cables. For VMs, it is commonly done by mapping a serial port to the pipe; for<a id="_idIndexMarker1089"/> example, if the <strong class="bold">COM1</strong> port is being used, you would follow these steps:</p>
			<ol>
				<li value="1">In VMWare, go to <code>\\.\pipe\&lt;any_pipe_name&gt;</code>. In the remaining options, choose <strong class="bold">This end is the server</strong> and <strong class="bold">The other end is an application</strong>, and then tick the <strong class="bold">Yield CPU on poll</strong> checkbox.</li>
				<li>In VirtualBox, open the VM's settings and go to the <code>\\.\pipe\&lt;any_pipe_name&gt;</code>:</li>
			</ol>
			<div><div><img src="img/Figure_7.22_B18500.jpg" alt="Figure 7.22 – VirtualBox setup for kernel-mode debugging over the COM port&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.22 – VirtualBox setup for kernel-mode debugging over the COM port</p>
			<p>Remote debugging via a network is also possible, but in this case, the guest and the host machines should share a network connection, which may not always be desirable.</p>
			<p>Apart from<a id="_idIndexMarker1090"/> this, to be able to perform kernel-mode debugging, it should also be explicitly allowed by the target system. Perform the following steps to do so:</p>
			<ol>
				<li value="1">On a modern Windows OS, run a standard <code>bcdedit</code> tool as an administrator and type the foll<a id="_idTextAnchor790"/>owing command:<pre><strong class="bold">bcdedit /debug on</strong></pre></li>
				<li>If local kernel debugging is being used, execute the following command:<pre><strong class="bold">bcdedit /dbgsettings local</strong></pre></li>
				<li>Alternatively, if a serial port is being used, execute the following command instead (for COM1):<pre><strong class="bold">bcdedit /dbgsettings serial debugport:1 baudrate:115200</strong></pre></li>
				<li>If you want to keep the original boot settings as well, you can create a separate entry, as follows:<pre><strong class="bold">bcdedit /copy {current} /d "&lt;any_custom_display_name&gt;"</strong></pre></li>
				<li>Then, you can take the generated <code>&lt;guid&gt;</code> value and use it to apply the required settings to the new entry:<pre><strong class="bold">bcdedit /set &lt;guid&gt; debug on</strong>
<strong class="bold">bcdedit /set &lt;guid&gt; debugport 1</strong>
<strong class="bold">bcdedit /set &lt;guid&gt; baudrate 115200</strong></pre></li>
			</ol>
			<p>On an older OS, such as Windows XP, it is possible to enable kernel-mode debugging by duplicating the default boot entry in the <code>boot.ini</code> file with a new display name and adding the <code>/debug</code> argument. It can also be combined with setting up a debug port by adding the <code>/debugport=com1 /baudrate=115200</code> argument. The resulting entry will be as follows:</p>
			<pre class="source-code">
multi(0)disk(0)rdisk(0)partition(1)\WINDOWS="&lt;any_custom_display_name&gt;" /fastdetect /debug /debugport=com1 /baudrate=115200</pre>
			<p>Make sure that the system location specified matches the one used in the original entry.</p>
			<p>After this, it is <a id="_idIndexMarker1091"/>necessary to restart the machine and choose the newly added option during the bootup process. This step can also be done la<a id="_idTextAnchor791"/>ter, after disabling the security checks.</p>
			<p>If i<a id="_idTextAnchor792"/>t is necessary to set up network debugging or use Hyper-V machines, always follow the most recent official Microsoft documentation.</p>
			<h2 id="_idParaDest-257"><a id="_idTextAnchor793"/>Setting up the debugger</h2>
			<p>Now, we can<a id="_idIndexMarker1092"/> run the debugger and check that everything works as expected. If lo<a id="_idTextAnchor794"/>cal debugging is being used, it can be done by executing WinDbg as an administrator using the following command line:</p>
			<pre>windbg.exe -kl</pre>
			<p>For debugging over a serial port, it is possible to specify the port and the baud rate using the <code>_NT_DEBUG_PORT</code> and <code>_NT_DEBUG_BAUD_RATE</code> environment variables or using the right command-line arguments. For the COM port, this will look as follows:</p>
			<pre>windbg.exe -k com:pipe,port=\\.\pipe\&lt;pipe_name&gt;,baud=115200,resets=0,reconnect</pre>
			<p>It is also possible to do this from the GUI using <strong class="bold">File</strong> | <strong class="bold">Kernel Debug...</strong>:</p>
			<div><div><img src="img/Figure_7.23_B18500.jpg" alt="Figure 7.23 – Kernel-mode debugging with VirtualBox and WinDbg over the COM port&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.23 – Kernel-mode debugging with VirtualBox and WinDbg over the COM port</p>
			<p>Don't forget to restart the guest machine afterward.</p>
			<p>Another option <a id="_idIndexMarker1093"/>here is to use a separate <strong class="bold">VirtualKD</strong> project, which<a id="_idIndexMarker1094"/> is aimed at improving kernel debugging performance if VMWare or VirtualBox VMs are being used. Follow the official installation documentation to make sure it is working as expected.</p>
			<p>If you are using a combination of IDA and WinDbg, then it can be set up in the following way:</p>
			<ol>
				<li value="1">It is better to make sure that the correct path to WinDbg is specified in the <code>PATH</code> environment variable or the <code>%IDA%\cfg\ida.cfg</code> file (the <code>DBGTOOLS</code> variable).</li>
				<li>For kernel-mode debugging, it is often recommended to use the 32-bit version of WinDbg; double-check w<a id="_idTextAnchor795"/>hich version is being used in IDA's <strong class="bold">Output</strong> window.</li>
				<li>Open the IDA instance, don't open any files, but select the <strong class="bold">Go</strong> quick start option.</li>
				<li>Go to <strong class="bold">Debugger</strong> | <strong class="bold">Attach</strong> | <strong class="bold">Windbg debugger</strong> and specify the following connection string, with the pipe name matching the one used in the VM:<pre><strong class="bold">com:pipe,port=\\.\pipe\&lt;pipe_name&gt;,baud=115200,resets=0,reconnect</strong></pre></li>
				<li>Then, in the same dialog window, go to <strong class="bold">Debug options</strong> | <strong class="bold">Set specific options</strong> and select the <strong class="bold">Kernel mode debugging with reconnect and initial break</strong> option (reconnect is optional, but it should match the value specified in the connection string).</li>
			</ol>
			<p>Once confirmed, the following dialog window will appear:</p>
			<div><div><img src="img/Figure_7.24_B18500.jpg" alt="Figure 7.24 – The IDA attaching to the Windows kernel on a target machine&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.24 – The IDA attaching to the Windows kernel on a target machine</p>
			<ol>
				<li value="6">Press <strong class="bold">OK</strong>. The<a id="_idIndexMarker1095"/> debugger will break in the kernel and the WINDBG command line will become available at the bottom of the window.</li>
				<li>Add the kernel mode-related type libraries (usually, they have <code>ddk</code> or <code>wdk</code> in their names) in <strong class="bold">View</strong> | <strong class="bold">Open subviews</strong> | <strong class="bold">Type libraries</strong> (you can also use the <em class="italic">Shift</em> + <em class="italic">F11 </em>keyboard shortcut) to get access to multiple standard enums and structures.</li>
			</ol>
			<p>Once we've made sure that the debugger executes successfully, it is necessary to set up symbol information so that standard Windows names can be used in various WinDbg commands. To do this, execute the following command in the WinDbg console:</p>
			<pre class="source-code">
.sympath srv*&lt;local_path_for_downloaded_symbols&gt;*https://msdl.microsoft.com/download /symbols
.reload /f</pre>
			<p>In the WinDbg GUI, this can be specified in the <code>-y</code> command-line argument. Additionally, it is possible to set it in the <code>_NT_SYMBOL_PATH</code> environment variable.</p>
			<p>If the target and host machines don't have internet access, then symbols can also be downloaded from another computer using a symbol manifest file created on the target machine. To do this, perform the following steps:</p>
			<ol>
				<li value="1">On the target machine, execute the following command:<pre><strong class="bold">symchk /om manifest.txt /ie ntoskrnl.exe /s</strong>
<strong class="bold">&lt;path_to_any_empty_dir&gt;</strong></pre></li>
				<li>The <code>ntkrnlpa.exe</code> can<a id="_idIndexMarker1097"/> be used instead of <code>ntoskrnl.exe</code>. The last argument, <code>/s</code>, aims to avoid name resolution delays.</li>
			</ol>
			<p class="callout-heading">Important Note</p>
			<p class="callout">Some WinDbg versions have a bug that results in the output file being empty. In this case, try a different version of it.</p>
			<ol>
				<li value="3">Move the created <code>manifest.txt</code> file to the machine that has internet access.</li>
				<li>Run the following command:<pre><strong class="bold">symchk /im manifest.txt /s srv*&lt;local_path_for_downloaded_symbols&gt;*https://msdl.microsoft. com/download/symbols</strong></pre></li>
				<li>Once this is done, the downloaded symbols can be moved to the host machine and used for debugging purposes:<pre><strong class="bold">.sympath &lt;local_path_to_downloaded_symb<a id="_idTextAnchor797"/><a id="_idTextAnchor798"/>ols&gt;</strong>
<strong class="bold">.reload /f</strong></pre></li>
			</ol>
			<p>Keep in mind that if you update the target machine, the symbols may become invalid, and the process should be repeated.</p>
			<h2 id="_idParaDest-258"><a id="_idTextAnchor799"/>Stopping at the driver's entry point</h2>
			<p>Now, we<a id="_idIndexMarker1098"/> should set up a debugger to intercept the moment the driver code gets executed so that we can get control over it immediately once it starts. In most cases, we don't have symbol information for the analyzed sample, so we can't use common WinDbg commands such as <code>bp &lt;driver_name&gt;!DriverEntry</code> to stop at the driver's entry point. There are several other ways this can be done, as follows:</p>
			<ul>
				<li><strong class="bold">By setting unresolved breakpoints</strong>: The following command can be used to set a breakpoint that will trigger once the module is loaded:<pre><strong class="bold">bu &lt;driver_name&gt;!&lt;any_string&gt;</strong></pre></li>
			</ul>
			<p>Even though the debugger doesn't stop exactly at the entry point here, it is possible to reach it manually after the first stop. To do this, take the base of the driver from the console output window, add the entry point's offset to it, and then set <a id="_idIndexMarker1099"/>a breakpoint for the result address. Then, remove or disable the previous breakpoint and continue execution.</p>
			<ul>
				<li><strong class="bold">By breaking on the module load</strong>: The following command allows you to intercept all new modules being loaded (a colon or space can be used):<pre><strong class="bold">sxe ld:&lt;driver_name&gt;.sys</strong></pre></li>
			</ul>
			<p>Here is how it will look in the debugger:</p>
			<div><div><img src="img/Figure_7.25_B18500.jpg" alt="Figure 7.25 – Breaking when a particular module is loading&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.25 – Breaking when a particular module is loading</p>
			<p>Once <a id="_idIndexMarker1100"/>the debugger breaks, it is possible to set a breakpoint on the driver's entry point and continue to make the execution stop there:</p>
			<div><div><img src="img/Figure_7.26_B18500.jpg" alt="Figure 7.26 – Setting a breakpoint on the driver's entry point&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.26 – Setting a breakpoint on the driver's entry point</p>
			<p>In IDA, when working with WinDbg, this can be achieved globally for all modules by going to <strong class="bold">Debugger</strong> | <strong class="bold">Debugger options...</strong> and enabling the <strong class="bold">Suspend on library load/unload</strong> option.</p>
			<ul>
				<li><code>IopLoadDriver</code> API transfers control to the driver. It will be slightly different for different versions of Windows, and it can be found using the following commands:<pre><strong class="bold">.shell -ci "uf /c nt!Io<a id="_idTextAnchor800"/>pLoadDriver" grep -B 1 -i "call.*ptr</strong>
<strong class="bold">\[.*h"</strong>
<strong class="bold">Or, on newer systems:</strong>
<strong class="bold">.shell -ci "uf nt!guard_dispatch_icall" grep -i "jmp.* rax" | head -n 1</strong></pre></li>
			</ul>
			<p>Once the offset has been found (it will look like <code>nt!IopLoadDriver+N</code>), it is possible to set a breakpoint at this address and intercept all moments when the system transfers control to the newly loaded drivers. The good thing is that it can be reused multiple times until the system receives an update changing it:</p>
			<div><div><img src="img/Figure_7.27_B18500.jpg" alt="Figure 7.27 – Intercepting the moment when the system transfers control to the loaded driver&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.27 – Intercepting the moment when the system transfers control to the loaded driver</p>
			<ul>
				<li><code>int 3</code> instruction representing a software breakpoint), recalculate the checksum field in its header (in the <strong class="bold">Hiew</strong> editor, this can be done by selecting this field in the header, pressing <em class="italic">F3</em> once to recalculate it, and then <em class="italic">F9</em> to save the changes), and <a id="_idIndexMarker1102"/>load it. The debugger will break at this instruction, so it becomes possible to restore the modified value to the original one. Usually, the modified instruction won't be <a id="_idIndexMarker1103"/>executed after patching. This means that it is necessary to do a single step, make sure that it didn't work, return the IP register to the c<a id="_idTextAnchor801"/>hanged instruction, and only then continue the ana<a id="_idTextAnchor802"/>lysis as usual.</li>
			</ul>
			<p>This approach generally takes more time and will also break the driver's signature, but it can still be used if necessary.</p>
			<h2 id="_idParaDest-259"><a id="_idTextAnchor803"/>Loading the driver</h2>
			<p>You <a id="_idIndexMarker1104"/>aren't allowed to load unsigned drivers on modern 64-bit Windows systems or 32-bit systems with Secure Boot turned on. If the sample driver is not signed, it generally makes sense to figure out the way it is being executed in the wild (for <a id="_idTextAnchor804"/>example, by abusing other legitimate drivers) and reproduce it. In this way, we can guarantee that malware will behave exactly as expected.</p>
			<p>Alternatively, it is possible to disable system security mechanisms. The most reliable way to temporarily disable it is by going to the advanced options for the booting process and selecting the <code>bcdedit.exe /set testsigning on</code> command is not recommended for analysis as it still requires the driver to be correctly signed by some certificate.</p>
			<p>Now, it is time to load the analyzed driver. This can also be done straight from the Windows console using the standard <code>sc</code> functionality:</p>
			<pre>sc create &lt;any_name&gt; type= kernel binpath= "&lt;path_to_driver&gt;" sc start &lt;same_name&gt;</pre>
			<p>An example of the preceding code block is as follows:<a id="_idTextAnchor805"/></p>
			<div><div><img src="img/Figure_7.28_B18500.jpg" alt="Figure 7.28 – Loading a custom driver using the sc tool&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.28 – Loading a cus<a id="_idTextAnchor806"/>tom driver using the sc tool</p>
			<p>Notice the spaces after the <code>type=</code> and <code>binpath=</code> arguments; they are important to make things work as expected.</p>
			<h2 id="_idParaDest-260"><a id="_idTextAnchor807"/>Restoring the debugging state</h2>
			<p>If IDA is <a id="_idIndexMarker1105"/>being used, the problem that many engineers face when they load the driver again is that its base address changes in memory, so IDA can't apply existing markup to it. One option here is to save the markup in IDC files and create a script that will remap all the addresses according to the new locations. However, there is a better way to organize this: it is recommended to make VM snapshots with debugging states and then reconnect to them with IDA when necess<a id="_idTextAnchor808"/>ary. In this way, all the addresses are guaranteed to be the same, so the same IDC files can be applied without any changes being required.</p>
			<h1 id="_idParaDest-261"><a id="_idTextAnchor809"/>Summary</h1>
			<p>In this chapter, we familiarized ourselves with Windows kernel mode and learned how requests are passed from user mode to kernel mode and back again. Then, we discussed rootkits, what parts of this process may be targeted by them, and for what reason. We also covered various techniques that are implemented in modern rootkits, including how existing security mechanisms can be bypassed by malware.</p>
			<p>Finally, we explored the tools that are available to perform static and dynamic analysis of kernel-mode threats, learned how to set up a testing environment, and summarized generic guidelines that can be followed when performing the analysis. By completing this chapter, you should have a strong understanding of how advanced kernel-mode threats work and how they can be analyzed using various tools and approaches.</p>
			<p>In <a href="B18500_08.xhtml#_idTextAnchor811"><em class="italic">Chapter 8</em></a>, <em class="italic">Handling Exploits and Shellcode</em>, we will explore the various types of exploits and learn how legitimate software can be abused to let attackers perform malicious actions.</p>
		</div>
		<div><div></div>
		</div>
	

		<div><h1 id="_idParaDest-262"><a id="_idTextAnchor810"/>Part 3 Examining Cross-Platform and Bytecode-Based Malware</h1>
		</div>
		<div><p>Being able to support multiple platforms using the same source code is always preferred by both attackers looking to infect as many users as possible and those specializing in targeted attacks. Consequently, multiple cross-platform malware families have appeared over the last several years, creating a need for engineers who know how to analyze them. By going through this section, you will learn about the specifics of cross-platform malware and will get a hands-on understanding of how to deal with them.</p>
			<p>In this section are the following chapters:</p>
			<ul>
				<li><a href="B18500_08.xhtml#_idTextAnchor811"><em class="italic">Chapter 8</em></a><em class="italic">, Handling Exploits and Shellcode</em></li>
				<li><a href="B18500_09.xhtml#_idTextAnchor946"><em class="italic">Chapter 9</em></a><em class="italic">, Reversing Bytecode Languages – .NET, Java, and More</em></li>
				<li><a href="B18500_10.xhtml#_idTextAnchor1106"><em class="italic">Chapter 10</em></a><em class="italic">, Scripts and Macros – Reversing, Deobfuscation, and Debugging</em></li>
			</ul>
		</div>
		<div><div></div>
		</div>
		<div><div></div>
		</div>
	</body></html>