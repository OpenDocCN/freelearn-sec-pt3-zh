<html><head></head><body>
		<div><h1 id="_idParaDest-45" class="chapter-number"><a id="_idTextAnchor071" class="pcalibre pcalibre1 calibre6"/>2</h1>
			<h1 id="_idParaDest-46" class="calibre5"><a id="_idTextAnchor072" class="pcalibre pcalibre1 calibre6"/>Python for Security Professionals – Beyond  the Basics</h1>
			<p class="calibre3">This chapter <a id="_idTextAnchor073" class="pcalibre pcalibre1 calibre6"/>looks into complex Python applications designed exclusively for security professionals, pushing you beyond the fundamentals and into the field of <a id="_idTextAnchor074" class="pcalibre pcalibre1 calibre6"/>cutting-edge cybersecurity practices.</p>
			<p class="calibre3">By the end of this chapter, you will not only have a thorough understanding of Python’s role in cybersecurity, but you will also have firsthand experience designing a comprehensive security tool. You will obtain the expertise required to effectively address real-world security concerns through practical examples and in-depth explanations.</p>
			<p class="calibre3">In this chapter, we are going to cover the following main topics:</p>
			<ul class="calibre17">
				<li class="calibre16"><a id="_idTextAnchor075" class="pcalibre pcalibre1 calibre6"/>Utilizing essential security libraries</li>
				<li class="calibre16">Harnessing advanced Python techniques for security</li>
				<li class="calibre16">Compiling a Python library</li>
				<li class="calibre16">Advanced Python features</li>
			</ul>
			<h1 id="_idParaDest-47" class="calibre5"><a id="_idTextAnchor076" class="pcalibre pcalibre1 calibre6"/>Utilizing essential security libraries</h1>
			<p class="calibre3">At the heart of network analysis is the practice of <a id="_idIndexMarker145" class="pcalibre pcalibre1 calibre6"/>network scanning. <strong class="bold">Network scanning</strong> is a technique used to discover devices on a network, determine open ports, identify available services, and <a id="_idIndexMarker146" class="pcalibre pcalibre1 calibre6"/>uncover vulnerabilities. This information is invaluable for security assessments and maintaining the overall security of a network.</p>
			<p class="calibre3">Without further ado, let us<a id="_idIndexMarker147" class="pcalibre pcalibre1 calibre6"/> write a network scanner. <strong class="bold">Scapy</strong> will be our library of choice.</p>
			<p class="calibre3">Scapy is a powerful packet manipulation tool that allows users to capture, analyze, and forge network packets. It can be used for network discovery, security testing, and forensic analysis.</p>
			<p class="callout-heading">How can I determine that Scapy is the preferred library for our tool?</p>
			<p class="callout">You’ll need to do some Google searches, and you can also use <a href="https://pypi.org/" class="pcalibre pcalibre1 calibre6">https://pypi.org/</a> to find modules that suit your needs.</p>
			<p class="calibre3">So, now that we have our library, how can I find the modules from Scapy that are needed for our tool? For that, you can make use of the documentation that is available either at <a href="https://pypi.org/" class="pcalibre pcalibre1 calibre6">https://pypi.org/</a> or the GitHub repository for the library (<a href="https://github.com/secdev/scapy" class="pcalibre pcalibre1 calibre6">https://github.com/secdev/scapy</a>).</p>
			<p class="calibre3">One effective method for network discovery is <a id="_idIndexMarker148" class="pcalibre pcalibre1 calibre6"/>utilizing an <strong class="bold">Address Resolution Protocol</strong> (<strong class="bold">ARP</strong>) scan to query devices on the local network, gathering their IP and MAC addresses. With Scapy, a powerful packet manipulation library, we can create a simple yet efficient script to perform<a id="_idIndexMarker149" class="pcalibre pcalibre1 calibre6"/> this task. Scapy’s flexibility allows for detailed customization of packets, enabling precise control over the ARP requests we send out. This not only increases the efficacy of the scanning process but also minimizes any potential network disturbance. The following is an optimized script that demonstrates this process.</p>
			<p class="calibre3">The first step in any Python script involves loading the necessary modules.</p>
			<p class="calibre3">Import the necessary<a id="_idIndexMarker150" class="pcalibre pcalibre1 calibre6"/> modules from Scapy, including <code>ARP</code>, <code>Ether</code> (<code>srp</code> (<strong class="bold">send and </strong><strong class="bold">receive packets</strong>):</p>
			<pre class="source-code">
 1. # Import the necessary modules from Scapy
 2. from scapy.all import ARP, Ether, srp
 3.</pre>			<p class="calibre3">We can start by creating the function to perform an ARP scan. The <code>arp_scan</code> function takes a target IP range as input and creates an ARP request packet for each IP address in the specified range. It sends the packets, receives responses, and extracts IP and MAC addresses, storing them in a list called <code>devices_list</code>:</p>
			<pre class="source-code">
 4. # Function to perform ARP scan
 5. def arp_scan(target_ip):
 6.     # Create an ARP request packet
 7.     arp_requ<a id="_idTextAnchor077" class="pcalibre pcalibre1 calibre14"/>est = ARP(pdst=target_ip)
 8.     # Create an Ethernet frame to encapsulate the ARP request
 9.     ether_frame = Ether(dst="ff:ff:ff:ff<a id="_idTextAnchor078" class="pcalibre pcalibre1 calibre14"/>:ff:ff")  # Broadcasting to all devices in the network
10.
11.     # Combine the Ethernet frame and ARP request packet
12.     arp_request_packet = ether_frame / arp_request
13.
14.     # Send the packet and receive the response
15.     result = srp(arp_request_packet, timeout=3, ve<a id="_idTextAnchor079" class="pcalibre pcalibre1 calibre14"/>rbose=False)[0]
16.
17.     # List to store the discovered devices
18.     devices_list = []
19.
20.     # Parse the response and extract IP and MAC addresses
21.     for sent, received in result:
22.         devices_list.append({’ip’: received.psrc, ’mac’: received.hwsrc})
23.
24.     return devices_list
25.</pre>			<p class="calibre3">Another task is displaying the scan result in the input-output stream. The <code>print_scan_results</code> function takes the <code>devices_list</code> as input and prints the discovered IP and MAC addresses in a formatted manner:</p>
			<pre class="source-code">
26. # Function to print scan results
27. def print_scan_results(devices_list):
28<a id="_idTextAnchor080" class="pcalibre pcalibre1 calibre14"/>.     print("IP Address\t\tMAC Address")
29<a id="_idTextAnchor081" class="pcalibre pcalibre1 calibre14"/>.     print("-----------------------------------------")
30.     for device in devices_list:
31.         print(f"{devic<a id="_idTextAnchor082" class="pcalibre pcalibre1 calibre14"/>e[’ip’]}\t\t{device[’mac’]}")
32.</pre>			<p class="calibre3">The <code>main</code> function, the primary <a id="_idIndexMarker151" class="pcalibre pcalibre1 calibre6"/>function to initiate the script, takes the target IP range as input, initiates the ARP scan, and prints the scan results:</p>
			<pre class="source-code">
33. # Main function to perform the scan
34. def main(target_ip):
3<a id="_idTextAnchor083" class="pcalibre pcalibre1 calibre14"/>5.     print(f"Scanning {target_ip}...")
36.     devices_list = arp_scan(target_ip)
37.     print_scan_results(devices_list)
38.</pre>			<p class="calibre3">The <code>if __name__ == "__main__":</code> block makes the script executable in a command line and capable of accepting parameters. The script prompts the user to enter the target IP range, such as <code>192.168.1.1/24</code>:</p>
			<pre class="source-code">
39. # Entry point of the script
40. if __name__ == "__main__":
41.     # Define the target IP range (e.g., "192.168.1.1/24")
42.     targe<a id="_idTextAnchor084" class="pcalibre pcalibre1 calibre14"/>t_ip = input("Enter the target IP range (e.g., 192.168.1.1/24): ")
43.     main(target_ip)</pre>			<p class="calibre3">To run the script, ensure you are in the virtual environment, have the Scapy library installed (<code>pip install scapy</code>), and <a id="_idIndexMarker152" class="pcalibre pcalibre1 calibre6"/>execute it with elevated privilege. It will perform an ARP scan on the specified IP range and print the discovered devices’ IP and MAC addresses.</p>
			<p class="calibre3">The result should look like this:</p>
			<div><div><img src="img/B21287_01_1.jpg" alt="Figure 2.1 – Output of the executed ARP scanner script" class="calibre4"/>
				</div>
			</div>
			<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 2.1 – Output of the executed ARP scanner script</p>
			<p class="calibre3">The preceding is a simple example of how powerful Python libraries are. In addition to Scapy, I have listed some of the most common libraries that we can utilize in our security operations in the previous chapter. The given libraries are just a few; there are many more that you can utilize for different needs.</p>
			<p class="calibre3">Let us now deep dive into harnessing advanced Python techniques, utilizing our newfound knowledge to navigate complex security terrains with utmost precision, innovation, and resilience.</p>
			<h1 id="_idParaDest-48" class="calibre5"><a id="_idTextAnchor085" class="pcalibre pcalibre1 calibre6"/>Harnessing advanced Python techniques for security</h1>
			<p class="calibre3">Using the IP addresses obtained<a id="_idIndexMarker153" class="pcalibre pcalibre1 calibre6"/> from our network scan, we will create a Python module, import it into our program, and perform a port scan on these IPs. Along the way, we will also cover some advanced Python concepts.</p>
			<p class="calibre3">In this section, we will delve into the intricacies of<a id="_idIndexMarker154" class="pcalibre pcalibre1 calibre6"/> complex Python concepts, starting with basic elements such as <strong class="bold">object-oriented programming</strong> and <strong class="bold">list comprehensions</strong>. We will break down these advanced aspects of Python, making them easy to understand, and <a id="_idIndexMarker155" class="pcalibre pcalibre1 calibre6"/>discuss how they can be utilized in the realm of technical security testing.</p>
			<p class="calibre3">Before starting the port scanner, we need to import the necessary modules in Python, in this case, the <code>socket</code> module. The <code>socket</code> module is a key tool used to create networking interfaces in Python. It is important to do so because the <code>socket</code> module provides us with the ability to connect with other computers over a network. This connection with other computers is a crucial starting point for any port scanning procedure. Hence, importing the <code>socket</code> module is the first step in setting up the port scanner.</p>
			<p class="calibre3">In this initial stage, we will be importing the necessary modules as usual:</p>
			<pre class="source-code">
 1. import socket
 2. import threading
 3. import time</pre>			<p class="calibre3">We will initiate the creation of a <code>PortScanner</code> class. In the realm of Python, a class serves as a blueprint for creating objects that encapsulate a set of variables and functions:</p>
			<pre class="source-code">
 5. #Class Definition
 6. class PortScanner:</pre>			<p class="calibre3">The first method that one encounters within a class is the <code>__init__</code> method. This method is crucial as it is used to initialize the instances of a class or to set the default values. The <code>__init__</code> method is a special method in Python classes. It acts as a constructor and is automatically called when a new instance of the class is created. In this method:</p>
			<ul class="calibre17">
				<li class="calibre16"><strong class="source-inline1">self</strong>: This refers to the instance of the class being created. It allows you to access the instance’s attributes and methods.</li>
				<li class="calibre16"><strong class="source-inline1">target_host</strong>: A parameter representing the target host (e.g., a website or IP address) that the port scanner will scan.</li>
				<li class="calibre16"><strong class="source-inline1">start_port</strong> and <strong class="source-inline1">end_port</strong> are parameters representing the range of ports to be scanned, from <strong class="source-inline1">start_port</strong> to <strong class="source-inline1">end_port</strong>.</li>
				<li class="calibre16"><strong class="source-inline1">open_ports</strong>: An empty <a id="_idIndexMarker156" class="pcalibre pcalibre1 calibre6"/>list that will store the list of open ports found during the scanning process. This list is specific to each instance of the <strong class="source-inline1">PortScanner</strong> class:</li>
			</ul>
			<pre class="source-code">
 7.     <a id="_idTextAnchor086" class="pcalibre pcalibre1 calibre14"/>def __init__(self, target_host, start_port, end_port):
 8.         self.target_host = target_host
 9.         self.start_port = start_port
10.         self.end_port = end_port
11.         self.open_ports = []</pre>			<p class="calibre3">The method named <code>is_port_open</code> is thoroughly discussed next. This procedure is designed to check if certain network ports are open, which is crucial for identifying potential vulnerabilities in a network’s security system.</p>
			<p class="calibre3">The following are the parameters for the method:</p>
			<ul class="calibre17">
				<li class="calibre16"><strong class="source-inline1">self</strong>: This represents the instance of the class on which the method is called.</li>
				<li class="calibre16"><strong class="source-inline1">port</strong>: This is a parameter representing the port number to be checked for openness.</li>
			</ul>
			<pre class="source-code">
12. #is_port_open Method
13.     def is_port_open(self, port):
14.         try:
15.             with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
16.                 s.settimeout(1)
17.                 s.connect((self.target_host, port))
18.             return True
19.         except (socket.timeout, ConnectionRefusedError):
20.             return False</pre>			<p class="calibre3">The following are the <a id="_idIndexMarker157" class="pcalibre pcalibre1 calibre6"/>principles outlined in the preceding code block elaborated on in detail:</p>
			<ul class="calibre17">
				<li class="calibre16"><strong class="source-inline1">with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:</strong>: This line creates a new socket object:<ul class="calibre18"><li class="calibre16"><strong class="source-inline1">socket.AF_INET</strong>: This indicates that the socket will use IPv4 addressing.</li><li class="calibre16"><strong class="source-inline1">socket.SOCK_STREAM</strong>: This indicates that the socket is a TCP socket, used for streaming data.</li></ul></li>
				<li class="calibre16"><strong class="source-inline1">s.settimeout(1)</strong>: This sets a timeout of <strong class="source-inline1">1</strong> second for the socket. connection attempt. If the connection does not succeed within <strong class="source-inline1">1</strong> second, a <strong class="source-inline1">socket.timeout</strong> exception will be raised.</li>
				<li class="calibre16"><strong class="source-inline1">s.connect((self.target_host, port))</strong>: This attempts to establish a connection to the target host (<strong class="source-inline1">self.target_host</strong>) on the specified port (<strong class="source-inline1">port</strong>).</li>
				<li class="calibre16"><strong class="bold">Handling a connection result</strong>: If the connection attempt is successful (i.e., the port is open and accepts connections), the code inside the <strong class="source-inline1">try</strong> block is executed without errors. In this case, the method immediately returns <strong class="source-inline1">True</strong>, indicating that the port is open.</li>
				<li class="calibre16"><strong class="bold">Handling exceptions</strong>: If the connection attempt results in a timeout (<strong class="source-inline1">socket.timeout</strong>) or <strong class="source-inline1">ConnectionRefusedError</strong>, it means the port is closed or unreachable. These exceptions are caught in the <strong class="source-inline1">except</strong> block, and the method returns <strong class="source-inline1">False</strong>, indicating that the port is closed.</li>
			</ul>
			<p class="calibre3">The <code>is_port_open</code> method is used internally within the <code>PortScanner</code> class. It provides a simple and reusable way to check whether a specific port on the target host is open or closed. By encapsulating this logic into a separate method, the code becomes more modular and easier to <a id="_idIndexMarker158" class="pcalibre pcalibre1 calibre6"/>maintain. The method allows the <code>PortScanner</code> class to efficiently determine the status of ports during the scanning process.</p>
			<p class="calibre3">Next, we discuss the <code>scan_ports</code> method. This method is an intricate process that systematically scans and analyzes network ports.</p>
			<p class="calibre3">The following is the parameter for the method (<code>self</code>); it represents the instance of the class on which the method is called:</p>
			<pre class="source-code">
21. #scan_ports Method
22.     def scan_ports(self):
23.         open_ports = [port<a id="_idTextAnchor087" class="pcalibre pcalibre1 calibre14"/> for port in range(self.start_port, self.end_port + 1) if self.is_port_open(port)]
24.         return open_ports</pre>			<p class="calibre3">The following are the principles outlined in the preceding code block elaborated on in detail:</p>
			<ul class="calibre17">
				<li class="calibre16"> <code>iterable</code> and optionally filtering the items based on a condition.</p><p class="calibre3">The syntax for the list comprehension will be as follows:</p><pre class="source-code">
1. new_list = [expression for item in iterable if condition]</pre><p class="calibre3">The constituents of the structure can be elucidated as follows:</p><ul class="calibre18"><li class="calibre16"><code>[por<a id="_idTextAnchor089" class="pcalibre pcalibre1 calibre6"/>t for port in range(self.start_port, self.end_port + 1) if self.is_port_open(port)]</code> line in the <code>scan_ports</code> method, it is a list comprehension. Its components can be dissected and expounded upon as follows:</p><ul class="calibre18"><li class="calibre16"><code>iterable</code>. They are a fundamental part of Python’s expressive syntax, enabling developers to write efficient and readable cod<a id="_idTextAnchor092" class="pcalibre pcalibre1 calibre6"/>e.</p></li>				<li class="calibre16"><code>start_port</code> and <code>end_port</code>.</p></li>
				<li class="calibre16"><code>is_port_open</code> method to check whether the port is open (using the <code>is_port_open</code> helper method explained earlier).</p></li>
				<li class="calibre16"><code>is_port_open(port)</code> returns <code>True</code>. This list comprehensively identifies and captures all open ports within the specified range.</p></li>
				<li class="calibre16"><code>scan_ports</code> method <a id="_idIndexMarker161" class="pcalibre pcalibre1 calibre6"/>provides a concise way to scan a range of ports and collect the list of open ports. It utilizes list comprehension, a powerful feature in Python, to create the <code>open_ports</code> list in a single line. By using this method, the <code>PortScanner</code> class can easily and efficiently identify open ports within a specified range on the target host. This method is integral to the functionality of the <code>PortScanner</code> class, as it encapsulates the logic of scanning and identifying open ports.</p></li>
			</ul>
			<p class="calibre3">Now, we will focus on the <code>main()</code> function. The following are its features:<a id="_idTextAnchor094" class="pcalibre pcalibre1 calibre6"/></p>
			<ul class="calibre17">
				<li class="calibre16"><strong class="source-inline1">target_host = input("Enter target host: ")</strong>: This prompts the user to input the target host (e.g., a website domain or IP address) and stores the input in the <strong class="source-inline1">target_host</strong> variabl<a id="_idTextAnchor095" class="pcalibre pcalibre1 calibre6"/>e.</li>
				<li class="calibre16"><strong class="source-inline1">s<a id="_idTextAnchor096" class="pcalibre pcalibre1 calibre6"/>tart_port = int(input("Enter starting port: "))</strong>: This prompts the user to input the starting port number and stores the input after converting it to an integer in the <strong class="source-inline1">start_port</strong> varia<a id="_idTextAnchor097" class="pcalibre pcalibre1 calibre6"/>ble.<a id="_idTextAnchor098" class="pcalibre pcalibre1 calibre6"/></li>
				<li class="calibre16"><strong class="source-inline1">end_port = int(input("Enter ending port: "))</strong>: This prompts the user to input the ending port number <a id="_idIndexMarker162" class="pcalibre pcalibre1 calibre6"/>and stores the input after converting it to an integer in the <strong class="source-inline1">end_port</strong> variable.</li>
			</ul>
			<p class="calibre3">The <a id="_idTextAnchor099" class="pcalibre pcalibre1 calibre6"/>following is the <code>main()</code> function code <a id="_idTextAnchor100" class="pcalibre pcalibre1 calibre6"/>section:</p>
			<pre class="source-code">
25. def main():
26.  <a id="_idTextAnchor101" class="pcalibre pcalibre1 calibre14"/>   target_host = input("Enter target host: ")
27.     <a id="_idTextAnchor102" class="pcalibre pcalibre1 calibre14"/>start_port = int(input("Enter starting port: "))
28<a id="_idTextAnchor103" class="pcalibre pcalibre1 calibre14"/>.     end_port = int(input("Enter ending port: "))
29.
30.     scanner = PortScanner(target_host, start_port, end_port)
31.
32.     open_ports = scanner.scan<a id="_idTextAnchor104" class="pcalibre pcalibre1 calibre14"/>_ports()
33.     print("Open ports: ", open_ports)
34.</pre>			<p class="calibre3">The following are the code <a id="_idIndexMarker163" class="pcalibre pcalibre1 calibre6"/>execution steps explained in depth:</p>
			<ul class="calibre17">
				<li class="calibre16"><code>PortScanner</code> class, passing the <code>target_host</code>, <code>start_port</code>, and <code>end_port</code> as parameters. This instance will be used to scan ports.</p></li>
				<li class="calibre16"><code>scan_ports</code> method of the <code>PortScanner</code> instance to scan ports. This method returns a list of open ports using list comprehension, as explained in prev<a id="_idTextAnchor105" class="pcalibre pcalibre1 calibre6"/>ious discussions.</p></li>
				<li class="calibre16"><code>scan_ports</code> method using list comprehension.</p></li>
			</ul>
			<p class="calibre3">Finally, add the following code block to call the <code>main</code> method when the file is executed as a script, but not when it is utilized as an import module:</p>
			<pre class="source-code">
35. if __name__ == "_<a id="_idTextAnchor106" class="pcalibre pcalibre1 calibre14"/>_main__":
36.     main()</pre>			<p class="calibre3">The <code>if __name__ == "__main__":</code> line checks whether the script is being run directly (not imported as a<a id="_idIndexMarker164" class="pcalibre pcalibre1 calibre6"/> module). When you execute the script directly, this condition evaluates to <code>True</code>. If the script is being run dire<a id="_idTextAnchor107" class="pcalibre pcalibre1 calibre6"/>ctly, it calls the <code>main()</code> function, initiating the process of input gathering, port scanning, and displaying the results.</p>
			<p class="calibre3">In summary, this script prompts the user for a target host, starting port, and ending port. It then creates an instance of the <code>PortScanner</code> class and uses list comprehension to scan ports within the specified range. The open ports are displayed to the user. The script is structured to be run directly as a standalone program, allowing users to interactively scan ports based on their input.</p>
			<p class="calibre3">Now, let us convert our code into a Python library, so we can install and use this library in any of our Python scripts.</p>
			<h1 id="_idParaDest-49" class="calibre5"><a id="_idTextAnchor108" class="pcalibre pcalibre1 calibre6"/>Compiling a Python library</h1>
			<p class="calibre3">Creating a Python library involves <a id="_idIndexMarker165" class="pcalibre pcalibre1 calibre6"/>packaging your code in a way that allows others to easily install, import, and use it in their projects. To convert your code into a Python library, follow these steps:</p>
			<ol class="calibre15">
				<li class="calibre16"><strong class="bold">Organize your code</strong>: Ensure our code is well-organized and follows the package structure:<pre class="source-code">
portscanner/
|-- portscanner/
|   |-- __init__.py
|   |-- portscanner.py
|-- setup.py
|-- README.md</pre><p class="calibre3">The components of a Python library are as follows:</p><ul class="calibre18"><li class="calibre16"><strong class="source-inline1">portscanner/</strong>: The main folder containing your package</li><li class="calibre16"><strong class="source-inline1">portscanner/__init__.py</strong>: An empty file indicating that <strong class="source-inline1">portscanner</strong> is a Python package</li><li class="calibre16"><strong class="source-inline1">portscanner/scanner.py</strong>: Your <strong class="source-inline1">PortScanner</strong> class and related functions</li><li class="calibre16"><strong class="source-inline1">setup.py</strong>: The script for packaging and distributing your library</li><li class="calibre16"><strong class="source-inline1">README.md</strong>: Documentation <a id="_idIndexMarker166" class="pcalibre pcalibre1 calibre6"/>explaining how to use your library</li></ul></li>				<li class="calibre16"><strong class="bold">Update setup.py</strong>:<pre class="source-code">
 1. from setuptools <a id="_idTextAnchor109" class="pcalibre pcalibre1 calibre14"/>import setup
 2.
 3. setup(
 4.     name='portscanner',
 5.     version='0.1',
 6.     packages=['portscanner'],
 7.<a id="_idTextAnchor110" class="pcalibre pcalibre1 calibre14"/>     install_requires=[],<a id="_idTextAnchor111" class="pcalibre pcalibre1 calibre14"/>
 8.     entry_points={
 9.         'console_scripts': [
10.             'portscanner = portscanner.portsca<a id="_idTextAnchor112" class="pcalibre pcalibre1 calibre14"/>nner:main'<a id="_idTextAnchor113" class="pcalibre pcalibre1 calibre14"/>
11.<a id="_idTextAnchor114" class="pcalibre pcalibre1 calibre14"/>         ]
12.     }
13. )</pre><p class="calibre3">In this file, you specify the package name (<code>portscanner</code>), version number, and the packages to include (use <code>find_packages()</code> to automatically discover packages). Add any dependencies your library requires to the <code>install_requires</code> list.</p></li>				<li class="calibre16"><strong class="bold">Package your code</strong>: In your<a id="_idIndexMarker167" class="pcalibre pcalibre1 calibre6"/> terminal, navigate to the directory containing your <strong class="source-inline1">setup.py</strong> file and run the following command to create a source distribution package:<pre class="source-code">
<code>.tar.gz</code> file in the <code>dist</code> directory.</p></li>				<li class="calibre16"><strong class="bold">Publish your library (optional)</strong>: If you want to make your library publicly available, you can publish it on the <strong class="bold">Python Package Index</strong> (<strong class="bold">PyPI</strong>). You will need to <a id="_idIndexMarker168" class="pcalibre pcalibre1 calibre6"/>create an account on PyPI and install <strong class="source-inline1">twine</strong> if you have not already:<pre class="source-code">
<code>twine</code>:</p><pre class="source-code"><strong class="bold1">twine upload dist/*</strong></pre></li>				<li class="calibre16"><strong class="bold">Install and use your library</strong>: To test your library, you can install it locally using <strong class="source-inline1">pip</strong>. In the same directory as your <strong class="source-inline1">setup.py</strong>, run the <a id="_idTextAnchor116" class="pcalibre pcalibre1 calibre6"/>following command:<pre class="source-code">
<code>PortScanner</code> class from the <code>portscanner</code> package:</p><pre class="source-code">1. from portscanner.portscanner import PortScanner
2.
3. scanner = PortScanner(target_host, start_port, end_port)
4. open_ports = s<a id="_idTextAnchor117" class="pcalibre pcalibre1 calibre14"/>canner.scan_ports()
5. print("Open ports: ", open_ports)</pre><p class="calibre3">Our code is now packaged as a Python library, ready for distribution and use by others.</p></li>			</ol>
			<p class="calibre3">As we bring our discussion on compiling a Python library to a close, we turn toward the exploration of advanced Python <a id="_idIndexMarker169" class="pcalibre pcalibre1 calibre6"/>features to further enhance our knowledge and skills in cybersecurity. The following section will delve deeper into these sophisticated components of Python.</p>
			<h1 id="_idParaDest-50" class="calibre5"><a id="_idTextAnchor118" class="pcalibre pcalibre1 calibre6"/>Advanced Python features</h1>
			<p class="calibre3">We can combine our library created in the earlier section into our network mapping tool and transform our code, which does a network scan and a port scan of the discovered IP addresses. Let us keep it there and talk<a id="_idIndexMarker170" class="pcalibre pcalibre1 calibre6"/> about some more advanced Python features, starting with <strong class="bold">decorators</strong>.</p>
			<h2 id="_idParaDest-51" class="calibre7"><a id="_idTextAnchor119" class="pcalibre pcalibre1 calibre6"/>Decorators</h2>
			<p class="calibre3">Decorators are a powerful aspect <a id="_idIndexMarker171" class="pcalibre pcalibre1 calibre6"/>of Python’s syntax, allowing you to modify or enhance<a id="_idIndexMarker172" class="pcalibre pcalibre1 calibre6"/> the behavior of functions or methods without changing their source code.</p>
			<p class="calibre3">For an improved understanding of Python decorators, we will delve into the examination of the following code:</p>
			<pre class="source-code">
1. def timing_d<a id="_idTextAnchor120" class="pcalibre pcalibre1 calibre14"/>ecorator(func):
2.     def wrapper(*args, **kwargs):
3.    <a id="_idTextAnchor121" class="pcalibre pcalibre1 calibre14"/>     start_time = time.time()  # Record the start time
4.         result = func(*args, **kwargs)  # Call the original function
5.  <a id="_idTextAnchor122" class="pcalibre pcalibre1 calibre14"/>       end_time = time.time()  # Reco<a id="_idTextAnchor123" class="pcalibre pcalibre1 calibre14"/>rd the end time
6.         print(f"Scanning took {end_time - start_time:.2f} seconds.")  # Calculate and print the ti<a id="_idTextAnchor124" class="pcalibre pcalibre1 calibre14"/>me taken
7.         return result  # Return the result of the origi<a id="_idTextAnchor125" class="pcalibre pcalibre1 calibre14"/>nal function
8.     return wrapper  # Return the wrapper function</pre>			<p class="calibre3">The following are the code execution<a id="_idIndexMarker173" class="pcalibre pcalibre1 calibre6"/> steps explained in depth:</p>
			<ul class="calibre17">
				<li class="calibre16"><strong class="source-inline1">timing_decorator(func)</strong>: This decorator function, known as <strong class="source-inline1">timing_decorator(func)</strong>, operates by accepting a function (<strong class="source-inline1">func</strong>) as a parameter, and then producing a new function (<strong class="source-inline1">wrapper</strong>). <strong class="source-inline1">wrapper</strong> fundamentally functions as a housing<a id="_idIndexMarker174" class="pcalibre pcalibre1 calibre6"/> for the original function, offering <a id="_idTextAnchor126" class="pcalibre pcalibre1 calibre6"/>an extra layer of operation.</li>
				<li class="calibre16"><strong class="source-inline1">wrapper(*args, **kwargs)</strong>: This is the <strong class="source-inline1">wrapper</strong> function returned by the decorator. It captures the arguments and keyword arguments passed to the original function, records the start time, calls the original function, records the end time, calculates the time taken, prints the duration, and finally returns the result of the original function.</li>
			</ul>
			<p class="calibre3">Let us examine how to utilize this decorator in the code:</p>
			<pre class="source-code">
1.     @timing_decorator
2.     def scan_ports(self):
3.         op<a id="_idTextAnchor127" class="pcalibre pcalibre1 calibre14"/>en_ports = [port for port in range(self.start_port, self.end_port + 1) if self.is_port_open(port)]
4.         return open_ports</pre>			<p class="calibre3">Here, <code>@timing_decorator</code> decorates the <code>scan_ports</code> method using <code>timing_decorator</code>. It is equivalent to writing <code>scan_ports = </code><code>timing_decorator(scan_ports)</code>.</p>
			<p class="calibre3"><code>timing_decorator</code> measures the time taken for the <code>scan_ports</code> method to execute and prints the duration. This is a com<a id="_idTextAnchor128" class="pcalibre pcalibre1 calibre6"/>mon use case for decorators, showcasing how they can enhance the functionality of methods in a clean and reusable way. Decorators provide a flexible and elegant approach to modifying or extending the behavior of functions and methods in Python.</p>
			<p class="calibre3">Next, we will explore various<a id="_idIndexMarker175" class="pcalibre pcalibre1 calibre6"/> scenarios where decorators can be effectively employed for enhancing code functionality in an uncomplicated manner. We will highlight the benefits of using decorators in improving code maintainability, <a id="_idTextAnchor129" class="pcalibre pcalibre1 calibre6"/>readability, and reusability, ultimately contributing to<a id="_idIndexMarker176" class="pcalibre pcalibre1 calibre6"/> a more secure and optimized code base.</p>
			<p class="calibre3">The following are the use cases and<a id="_idIndexMarker177" class="pcalibre pcalibre1 calibre6"/> benefits of decorators:</p>
			<ul class="calibre17">
				<li class="calibre16"><strong class="bold">Code reusability</strong>: Decorators allow you to encapsulate reusable functionality and apply it to multiple functions or methods without duplicating code.</li>
				<li class="calibre16"><strong class="bold">Logging and timing</strong>: Decorators are often used for logging, timing, and profiling functions to monitor their behavior and performance.</li>
				<li class="calibre16"><strong class="bold">Authentication and authorization</strong>: Decorators can enforce authentication and authorization checks, ensuring that only authorized users can access certain functions or methods.</li>
				<li class="calibre16"><strong class="bold">Error handling</strong>: Decorators can handle exceptions raised by functions, providing c<a id="_idTextAnchor130" class="pcalibre pcalibre1 calibre6"/>onsistent error handling across different parts of the code.</li>
				<li class="calibre16"><strong class="bold">Aspect-oriented programming (AOP)</strong>: Decorators<a id="_idIndexMarker178" class="pcalibre pcalibre1 calibre6"/> enable AOP, allowing you to separate cross-cutting concerns (e.g., logging, security) from the core logic of functions or methods.</li>
				<li class="calibre16"><strong class="bold">Method chaining and modification</strong>: Decorators can modify the output or behavior of functions, enabling method chaining or transforming return <a id="_idTextAnchor131" class="pcalibre pcalibre1 calibre6"/>values.</li>
			</ul>
			<p class="calibre3">This previous code usage appears to be<a id="_idIndexMarker179" class="pcalibre pcalibre1 calibre6"/> almost complete, however, it appears that our port scanner tool we started at the beginning of this chapter utilizes a list to store<a id="_idIndexMarker180" class="pcalibre pcalibre1 calibre6"/> the open ports and then return them, which makes the code not so memory efficient, so let’s introduce <strong class="bold">generators</strong>, another Python concept.</p>
			<h2 id="_idParaDest-52" class="calibre7"><a id="_idTextAnchor132" class="pcalibre pcalibre1 calibre6"/>Generators</h2>
			<p class="calibre3">Generators in Python are special types <a id="_idIndexMarker181" class="pcalibre pcalibre1 calibre6"/>of functions that return a sequence of results. They allow you to declare a function that behaves like an iterator, iterating over it in a for-loop or explicitly with the next function, while also maintaining the program’s internal state <a id="_idIndexMarker182" class="pcalibre pcalibre1 calibre6"/>and pausing execution between values, thus optimizing memory use.</p>
			<p class="calibre3">The characteristics of the generator are detailed and explained more thoroughly as follows:</p>
			<ul class="calibre17">
				<li class="calibre16"><strong class="bold">Lazy evaluation</strong>: Generators use lazy evaluation, meaning they produce values on the fly and only when <a id="_idIndexMarker183" class="pcalibre pcalibre1 calibre6"/>requested. This makes them memory efficient, especially when dealing with large datasets or potentially infinite sequences.</li>
				<li class="calibre16"><strong class="bold">Memory efficiency</strong>: Generators do not store all values in memory at once. They generate each value one at a time, consuming minimal memory. This is particularly beneficial for working with large data streams.</li>
				<li class="calibre16"><strong class="bold">Efficient iteration</strong>: Generators are <strong class="source-inline1">iterable</strong> objects, allowing them to be used in loops and comprehensions just like lists. However, they generate values efficiently, processing each item as it is needed.</li>
				<li class="calibre16"><strong class="bold">Infinite sequences</strong>: Generators can represent infinite sequences. Since they produce values on demand, you can create a generator that theoretically generates values forever.</li>
			</ul>
			<p class="calibre3">We will enhance our understanding of Python generators by thoroughly analyzing the following code:</p>
			<pre class="source-code">
1.     def scan_ports_ge<a id="_idTextAnchor133" class="pcalibre pcalibre1 calibre14"/>nerator(self):
2.         for port in range(self.start_port, self.end_port + 1):
3.             if self.is_port_open(port):
4.                 yield port</pre>			<p class="calibre3">Following are the code execution steps explained in depth to understand the gene<a id="_idTextAnchor134" class="pcalibre pcalibre1 calibre6"/>rator function behavior:</p>
			<ul class="calibre17">
				<li class="calibre16"><strong class="source-inline1">for port in range(self.start_port, self.end_port + 1)</strong>: This loop iterates over each<a id="_idIndexMarker184" class="pcalibre pcalibre1 calibre6"/> port number in the specified range (<strong class="source-inline1">self.start_port</strong> to <strong class="source-inline1">self.end_port</strong>), inclusive of both <strong class="source-inline1">start_port</strong> and <strong class="source-inline1">end_port</strong>.</li>
				<li class="calibre16"><strong class="source-inline1">if self.is_port_open(port)</strong>: For each port in the range, it calls the <strong class="source-inline1">is_port_open</strong> method to check whether the port is open (using the <strong class="source-inline1">is_port_open</strong> helper method explained earlier).</li>
				<li class="calibre16"><strong class="source-inline1">yield port</strong>: If the port is open, the <strong class="source-inline1">yield</strong> keyword is used to produce a value (<strong class="source-inline1">port</strong>) from the generator. The <strong class="source-inline1">generator</strong> function maintains its state, allowing it to resume execution<a id="_idIndexMarker185" class="pcalibre pcalibre1 calibre6"/> from where it left off when the next value is requested.</li>
			</ul>
			<p class="calibre3">The use cases of the generator are<a id="_idIndexMarker186" class="pcalibre pcalibre1 calibre6"/> detailed and explained further as follows:</p>
			<ul class="calibre17">
				<li class="calibre16"><strong class="bold">Processing large files</strong>: Reading large files line-by-line without loading the entire file into memory</li>
				<li class="calibre16"><strong class="bold">Stream processing</strong>: Analyzing real-time data streams where data is continuously generated</li>
				<li class="calibre16"><strong class="bold">Efficient filtering</strong>: Generating filtered sequences without creating intermediate lists</li>
				<li class="calibre16"><strong class="bold">Mathematical calculations</strong>: Generating sequences such as Fibonacci numbers or prime numb<a id="_idTextAnchor135" class="pcalibre pcalibre1 calibre6"/>ers on the fly</li>
			</ul>
			<p class="calibre3">Generators are a powerful concept in Python, enabling <a id="_idIndexMarker187" class="pcalibre pcalibre1 calibre6"/>the creation of memory-efficient and scalable code, especially when working with large datasets or sequences. They are a fundamental feature of <a id="_idIndexMarker188" class="pcalibre pcalibre1 calibre6"/>Python’s expressive syntax and are widely used in various programming scenarios.</p>
			<p class="calibre3">Upon utilizing advanced features such as decorators and generators, our code will take on a certain form. This is how the code should appear in its final iteration:</p>
			<pre class="source-code">
 1. import socket
 2. import time
 3.
 4. #Class Definition<a id="_idTextAnchor136" class="pcalibre pcalibre1 calibre14"/>
 5. class PortScanner:
 6.     def __init__(self, target_host, start_port, end_port):
 7.         self.target_host = target_host
 8.         self.start_port = start_port
 9.         self.end_port = end_port
10.         self.open_ports = []
11.     #timing_decorator Decorator Method
12.     d<a id="_idTextAnchor137" class="pcalibre pcalibre1 calibre14"/>ef timing_decorator(func):
13.         def wrapper(*args, **kwargs):
14.             start_time = time.time()
15.             result = func(*args, **kwargs)
16.             end_time = time.time()
17.             print(f"Scanning took {end_time - start_time:.2f} seconds.")
18.             return result
19.         return wrapper
20.     #is_port_open Method
21.     def is_port_open(self, port):
22.         try:
23.             with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
24.                 s.settimeout(1)
25.                 s.connect((self.target_host, port))
26.             return True
27.         except (socket.timeout, ConnectionRefusedError):
28.             return False
29.     #scan_ports Method
30.     @timing_decorator
31.     def scan_ports(self):
<a id="_idTextAnchor138" class="pcalibre pcalibre1 calibre14"/>32.         open_ports = [port for port in range(self.start_port, self.end_port + 1) if self.is_port_open(port)]
33.         return open_ports
34.     #scan_ports_generator Method
35.     @timing_decorator
36.     def scan_port<a id="_idTextAnchor139" class="pcalibre pcalibre1 calibre14"/>s_generator(self):
37.         for port in range(self.start_port, self.end_port + 1):
38.             if self.is_port_open(port):
39<a id="_idTextAnchor140" class="pcalibre pcalibre1 calibre14"/>.                 yield port
4<a id="_idTextAnchor141" class="pcalibre pcalibre1 calibre14"/>0.
41. def main():
42.     target_host = input("<a id="_idTextAnchor142" class="pcalibre pcalibre1 calibre14"/>Ente<a id="_idTextAnchor143" class="pcalibre pcalibre1 calibre14"/>r target host: ")
43.     start_port = int(input("E<a id="_idTextAnchor144" class="pcalibre pcalibre1 calibre14"/>nter<a id="_idTextAnchor145" class="pcalibre pcalibre1 calibre14"/> starting port: "))
44.     end_port = int(input("Enter ending port: "))
45.
46.     scanner = PortScanner(target_host, start_port, end_port)
47.
48.     open_ports = scanner.scan_ports()
49.     print("Open ports: ", open_ports)
50.
51.     open_ports_generato<a id="_idTextAnchor146" class="pcalibre pcalibre1 calibre14"/>r = scanner.scan_ports_generator()
52.     print("Open ports (using generator):", list(open_ports_generator))
53<a id="_idTextAnchor147" class="pcalibre pcalibre1 calibre14"/>.
54. if __name__ == "__main__":
55.     main()</pre>			<p class="calibre3">Having explored the<a id="_idIndexMarker189" class="pcalibre pcalibre1 calibre6"/> intricacies of a port scanner script, its modularization, and the use of advanced features such as decorators and generators, our next task is to delve<a id="_idIndexMarker190" class="pcalibre pcalibre1 calibre6"/> into the subsequent steps. This translates into a hands-on activity, allowing readers an opportunity to further analyze and comprehend coding practices.</p>
			<h1 id="_idParaDest-53" class="calibre5"><a id="_idTextAnchor148" class="pcalibre pcalibre1 calibre6"/>Summary</h1>
			<p class="calibre3">In this chapter, we learned how to use Python to create a network mapper and a port scanner. We covered several complex Python topics along the road, such as object-oriented programming, comprehensions, decorators, generators, and how to package a Python program into a library.</p>
			<p class="calibre3">You will be able to build more elegant Python code that stands out from the crowd with these. The presented concepts are difficult to execute at first, but once you get the feel of it, you will never consider coding in any other way.</p>
			<p class="calibre3">The next chapter will dive into the exciting and paramount field of web security through the usage of Python. It will explore various strategies, tools, and techniques that Python offers to identify and neutralize security threats, alongside understanding the fundamentals of web security itself. This knowledge is imperative in today’s digi<a id="_idTextAnchor149" class="pcalibre pcalibre1 calibre6"/>tal age, where security breaches can come at a high cost.</p>
			<h1 id="_idParaDest-54" class="calibre5"><a id="_idTextAnchor150" class="pcalibre pcalibre1 calibre6"/>Activity</h1>
			<p class="calibre3">Now, I will leave it up to you to package both the network scanner and the port scanner into a library and use the libraries to write a more compact script that does a network scan and scan for open ports for each IP that is found.</p>
			<p class="calibre3">Readers are recommended to follow the outlined steps to reinforce the concepts presented in this chapter. Every task designed within this activity aims to test and solidify the reader’s comprehension effectively:</p>
			<ol class="calibre15">
				<li class="calibre16">Package both code snippets into the library.</li>
				<li class="calibre16">Name your new Python file <strong class="source-inline1">network-and-port-scanner.py</strong>.</li>
				<li class="calibre16">Import both libraries into the new program.</li>
				<li class="calibre16">Use argument parsing to obtain the IP and port ranges for scanning.</li>
				<li class="calibre16">Pass the IP address range to the network mapper for ARP scanning and write the IPs to a file.</li>
				<li class="calibre16">Read the IPs from the file and provide the discovered IP addresses with the port range to the port scanner.</li>
				<li class="calibre16">Print the IPs and ports into a table in a more visually appealing manner.</li>
			</ol>
		</div>
	</body></html>