<html><head></head><body><div class="chapter" title="Chapter&#xA0;11.&#xA0;Memory Forensics"><div class="titlepage"><div><div><h1 class="title"><a id="ch11"/>Chapter 11. Memory Forensics</h1></div></div></div><p>System memory is the working space of the operating system. The operating system uses memory to place the data that is needed to execute programs and the programs themselves. This is why acquiring the system memory is one of the steps that must be performed when applicable in digital forensics. Analyzing the memory may reveal the existence of a malicious process or program that has no traces in the machine hard disk. Memory also contains the opened network connections, which could include the connection of an attacker controlling the machine or stealing user data and information.</p><p>In this chapter, we will briefly discuss the Windows memory structure, some techniques that are used by attackers to hide their malicious activities and existence, and the tools that are used to investigate memory dump.</p><div class="section" title="Memory structure"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec65"/>Memory structure</h1></div></div></div><p>Each process that runs in memory allocates space in memory to store its code and data. This space consists of memory pages. Each memory page is 4 KB in size in x86 systems. All the processes address their memory spaces with virtual addresses, which are translated into physical addresses by the system itself with no interaction by any process.</p><p>In modern operating systems, there are two categories of the running processes: processes run in user mode and others run in kernel mode. The difference between both modes is the level of access that is granted to the operating system. In the user mode, the processes can't modify paging or access other processes' memory locations except some inter-process communications using Windows APIs. All the processes start in user mode, except the SYSTEM process.</p><p>Kernel mode is used by the Windows kernel at system booting to set up memory space and paging. In some situations, such as executing the Windows API, the processor receives interrupt, which requires it to switch to kernel mode to execute the interrupt and then return back to the user mode.</p></div></div>
<div class="section" title="Memory acquisition"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec66"/>Memory acquisition</h1></div></div></div><p>We discussed memory acquisition previously in volatile evidence acquisition in <span class="emphasis"><em>
Chapter 3
</em></span>, <span class="emphasis"><em>Volatile Data Collection</em></span>. However, we now need to highlight this in a modern Windows operating system, the different security controls which forbid processes to access the whole memory, and the step which is required by any acquisition tool to acquire the system memory. This may cause a system crash and the loss of system memory, or the whole hard disk in the case of active hard disk encryption.</p><p>So, modern digital forensics acquisition tools tend to install a driver first to the operating system and then use this driver to access the system memory, which will need higher privileges on the system.</p></div>
<div class="section" title="The sources of memory dump"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec67"/>The sources of memory dump</h1></div></div></div><p>We can consider a memory dump during the incident response process as the main source for memory forensics. However, what if we have a powered off machine or, for any reason, we couldn't acquire the memory of the machine? The question here is do we have any other way to conduct memory forensics? Fortunately, we have a positive answer for this question in many situations. Let's see what they are.</p><div class="section" title="Hibernation file"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec103"/>Hibernation file</h2></div></div></div><p>Hibernation is a power option in most operating systems, including Windows OS. In this mode, the system copies the memory, which is volatile, to a single file named <code class="literal">hiberfil.sys</code>, which is located under the system root in the hard disk, which is non-volatile, and completely shuts down the machine. When the user turns the machine on again from hibernation, the system copies the contents of this file again to memory and resumes the execution of the previous processes.</p><p>If the investigator has a forensic image of the victim's or suspect's hard disk, they can extract the hibernation file and conduct memory forensics on this file using the memory analysis tools that we will be discussing later in this chapter. The hibernation file will provide the investigator or the analyst with a memory image from specific time in the past that may contain traces to the malicious activities or important evidence related to the case under investigation.</p><p>The filesystem's last modification time of the hibernation file will indicate the time when the hibernation was used in the system. Fortunately, the structure of the hibernation file is different but known, which makes it possible to convert it to a raw memory image in order to conduct analysis on it using the memory forensics tools. Although it contains most of the memory data, the hibernation file won't contain some data, such as the dynamically obtained network information using DHCP. We need to consider this during analysis.</p></div><div class="section" title="Crash dump"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec104"/>Crash dump</h2></div></div></div><p>If the Windows system crashed, it is designed to store information about the system state at the time of the crash for future troubleshooting of the crash after recovering the system. Crashing the system was an old way to dump the memory to the crash dump file, which can be done using the NotMyFault tool from Sysinternals (<a class="ulink" href="http://download.sysinternals.com/files/NotMyFault.zip">http://download.sysinternals.com/files/NotMyFault.zip</a>). However, better methods and tools are available nowadays. The crash dump file is named <code class="literal">MEMPRY.DMP</code> by default and is located under system root directly. The crash dump file can hold different data depending on the settings of the crash dumps, as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Complete memory dump</strong></span>: This contains the physical memory at the time of the crash with a 1 MB header. This type is not common because it has a large size especially for systems with a large memory.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Kernel memory dump</strong></span>: This is when the system dumps the memory pages in the kernel mode only and ignores the pages in the user mode.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Small dump files</strong></span>: These are small files that have a size of 64 KB in 32bit systems and 128 KB in 64bit systems. This contains information about running processes and loaded drivers in the system.</li></ul></div><p>For the investigator to know which type of dump file is present in the case, they can determine this from the size of the file. They can also open the registry location of <code class="literal">HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\CrashControl</code>, under a value called <span class="strong"><strong>CrashDumpEnable</strong></span>, which will be one of the following four values:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">0: This is when debugging information is not written to a file</li><li class="listitem" style="list-style-type: disc">1: This is when the complete crash dump is written to a file</li><li class="listitem" style="list-style-type: disc">2: This is when the kernel memory dump is written to a file</li><li class="listitem" style="list-style-type: disc">3: This is when a small memory dump is written to a file</li></ul></div><p>After extracting the crash dump file, the investigator can use the <code class="literal">dmp2bin.exe</code> tool from Moonsols to convert the dump.</p></div><div class="section" title="Page files"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec105"/>Page files</h2></div></div></div><p>Paging is a memory management technique that works as a secondary storage for Windows memory. It speeds up the system by moving the least-used pages in memory to the hard drive in a file named <code class="literal">pagefile</code>. By applying such techniques, the user will have more memory space to use. When the user starts using the saved pages again, the system restores these pages to memory again. This can be noticed in small lagging while accessing some opened applications that haven't been used for some time.</p><p>The page files on the hard drive can be up to 16 files, and not only under the root directory. To find out the locations of the page files from the registry, check <code class="literal">HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Memory Management\ExistingPageFiles</code> and <code class="literal">PagingFiles</code>. Some memory acquisition tools, such as FTK imager can add the page file to memory image during live acquisition:</p><div class="mediaobject"><img src="graphics/image_11_001.jpg" alt="Page files"/><div class="caption"><p>Figure 1: FTK imager; adding page files during memory acquisition</p></div></div><p>Page files store unordered data, which make it more difficult for in-depth analysis. This means that string search in the page files may give some clues about the contents of the page files and the case under investigation, such as the IP, path, or the registry key. File carving also can be conducted in the page files in order to recover some related files. Scanning the page files for a malware signature may uncover malware running in memory.</p></div></div>
<div class="section" title="Processes in memory"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec68"/>Processes in memory</h1></div></div></div><p>A process is an instance of a program that has been executed in the system. Each process in memory has a private isolated memory space. A process contains the execution code and the data that is required to complete the execution of the code, such as files, DLLs, and user input. All this data and code are located in a memory space allocated for this process.</p><p>Many processes can be in the memory at the same time. All the processes are listed in one structure called <code class="literal">_EPROCESS</code> in the memory of the running Windows operating system.</p><p>Each entry of the <code class="literal">_PROCESS</code> structure holds one process with its metadata; the process name, its executable path, parent process, start time, and in some cases, the exit time. The metadata can be used as an indication of the presence of malicious activity if the parent process of a well-known process is different. For example, the <code class="literal">lsass.exe</code> process has parent process of <code class="literal">Explorer.exe</code>, while its parent process should be <code class="literal">Wininit.exe</code>. We can assume here that this <code class="literal">lsass.exe</code> process is not the genuine <code class="literal">lsass.exe</code> process and it is trying to deceive the user by taking the name of a legitimate process.</p><p>The <code class="literal">_EPROCESS</code> structure is similar to a double-linked list, each process points to the previous and the next process in a chain-like structure. This is used to circulate the processing time between different processes. The normal Windows command that is used to list the system processes uses the <code class="literal">EPROCESS</code> structure to read all the processes in a sequential way. So, if a malicious process was able to change the addresses in two processes before and after its location to point to each other, it won't be shown in the processes list. This is one way used by some malware samples to hide their existence. This technique is called <span class="strong"><strong>Direct Kernel Object Manipulation</strong></span> or <span class="strong"><strong>DKOM</strong></span>.</p><p>To overcome this technique and because the <code class="literal">_EPROCESS</code> entry has a specific structure, instead of depending on the manipulated <code class="literal">EPROCESS</code> structure, we can carve the memory file for all the <code class="literal">_EPROCESS</code> entries by their signature. In this case, the carving tool won't go through <code class="literal">EPROCESS</code> sequentially and won't miss any hidden processes. This can also display some closed processes which were removed from <code class="literal">_EPROCESS</code> but their entries still exist in memory.</p></div>
<div class="section" title="Network connections in memory"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec69"/>Network connections in memory</h1></div></div></div><p>Usually, networks are used by attackers to control the machine remotely, to send captured user information, or to receive new commands. Checking the network connections, which were opened in the system at the time of acquisition, would provide clues about the attack.</p><p>Network activities in general leave traces in memory. Investigating network connections could lead to discovery of a hidden connection created by rootkits. These connections can be hidden from normal listing tools in the same way that can be done with the processes. Carving for the network connection structure in memory can reveal such connections.</p><p>Another technique to hide a connection is to inject code into a legitimate process to open a malicious connection, so we need to check all the connections in the memory file.</p></div>
<div class="section" title="The DLL injection"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec70"/>The DLL injection</h1></div></div></div><p><span class="strong"><strong>DLL</strong></span> or <span class="strong"><strong>Dynamic Link Libraries</strong></span> are resources and functions that are shared among different processes running within the system. Some processes and programs require special external DLLs, which can be included with the program to run properly. As DLLs usually run within the processes in memory, they are usually targeted by the malware as a way to access and control other processes in memory. DLLs are loaded into the process with different ways:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Dynamic linking</strong></span>: This is when an executable has an <span class="strong"><strong>Import Address Table</strong></span> (<span class="strong"><strong>IAT</strong></span>), which describes the resources needed for this executable to load along with their addresses, which are loaded in the process memory space.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Runtime Dynamic Linking</strong></span>: Some DLLs may not be mentioned in the IAT, but are called out by the program itself during execution, by calling out one of the Windows functions such as <code class="literal">LoadLibrary</code>.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Injection</strong></span>: DLLs can be injected into a process by different techniques. Let's see what they are.</li></ul></div><div class="section" title="Remote DLL injection"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec106"/>Remote DLL injection</h2></div></div></div><p>A malicious process allocates memory space in a legitimate process with read/write protection and writes the path to the malicious DLL in the legitimate process memory space. Then, the malicious process opens a remote thread to force open the DLL in the legitimate process and then removes the DLL path. In this way, the malicious process controls the legitimate one by the code in the DLL.</p><p>It won't be easy to detect this type of injection. We need to list all the DLLs loaded by the legitimate process and check the names, paths, and time of loading of all the DLLs.</p></div><div class="section" title="Remote code injection"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec107"/>Remote code injection</h2></div></div></div><p>We follow the same steps of the Remote DLL injections, but instead of writing the path to the DLL in the hard drive, the malicious process injects the code directly to the allocated memory space. Here, the protection of the allocated memory space will be read/write and execute. This protection scheme, which isn't popular, is found a lot in memory that is used to detect this kind of injection.</p></div><div class="section" title="Reflective DLL injection"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec108"/>Reflective DLL injection</h2></div></div></div><p>The hybrid technique combines the previous two methods. The malicious process loads the DLL directly into the legitimate process's allocated memory space. In this way, DLL won't ever be written to the hard drive and won't go through the normal loading process, so it won't be found while listing the process's loaded DLLs.</p></div></div>
<div class="section" title="API hooking"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec71"/>API hooking</h1></div></div></div><p>Hooking is usually used by rootkits, forcing the kernel to hide all activities that are related to the malware and to intercept the user input in order to steal sensitive information from the user. This used to be achieved by manipulating the output of the API calls by the system kernel. This can be deceptive in live analysis during the incident-handling process. In depth analysis of the memory image acquired during the evidence acquisition of the infected system would making it much easier to detect such behavior. Hooking is done simply by redirecting the normal flow of one process execution to execute malicious code in another location in the memory, and then return back to complete the normal process code.</p></div>
<div class="section" title="Memory analysis"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec72"/>Memory analysis</h1></div></div></div><p>After a successful memory acquisition process, the investigator will have a single dump file that contains the full memory. Fortunately, the structure of the memory can be parsed by many analysis programs, including volatility, which is the most famous memory analysis framework nowadays.</p><div class="section" title="The volatility framework"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec109"/>The volatility framework</h2></div></div></div><p>A free memory forensics framework can be downloaded from <a class="ulink" href="http://www.volatilityfoundation.org">http://www.volatilityfoundation.org</a>. This framework supports many versions of Windows, Mac, and Linux operating systems. An independent book called <span class="emphasis"><em>Art of Memory Forensics</em></span> was released with volatility 2.4. It explains in detail different operating systems' artifacts in memory and how to extract and analyze them using the volatility framework. In this section, we will discuss the usage of volatility framework and how it detects the malicious activities in memory dump.</p><p>Each operating system has a different memory structure. Volatility has the ability to understand different structures. Using this profile, volatility can understand the correct data structures of the image under investigation and apply the right analysis and parsing tools.</p><p>Volatility works with plugins, each plugin performs specific tasks with the memory dump file. You can add or write your own plugin and add it to your version. In the following sections, we will discuss some volatility plugins.</p><div class="section" title="Volatility plugins"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl3sec30"/>Volatility plugins</h3></div></div></div><p>A complete list of volatility plugins can be found in the tool's documentation. Here, we will discuss some plugins which are usually used to discover the discussed malware techniques.</p><div class="section" title="imagecopy"><div class="titlepage"><div><div><h4 class="title"><a id="ch11lvl4sec0"/>imagecopy</h4></div></div></div><p>In case the available memory file is a hibernation file or a crash dump file, volatility can convert this file to the raw format using the imagecopy plugin.</p><p>Usage: <code class="literal">vol.py -f &lt;Hiber|DumpFile&gt; --profile=&lt;ImageProfile&gt; imagecopy -O &lt;OutputFile&gt;</code></p></div><div class="section" title="raw2dmp"><div class="titlepage"><div><div><h4 class="title"><a id="ch11lvl4sec1"/>raw2dmp</h4></div></div></div><p>In some situations, you need to convert the dumped raw memory file to the crash dump format in order to use it with other tools, such as WinDBG, the Windows debugger. In such cases, the raw2dmp plugin can do this job.</p><p>Usage: <code class="literal">vol.py -f &lt;ImageFile&gt; --profile=&lt;ImageProfile&gt; raw2dmp -O &lt;OutputFile&gt;</code></p></div><div class="section" title="imageprofile"><div class="titlepage"><div><div><h4 class="title"><a id="ch11lvl4sec2"/>imageprofile</h4></div></div></div><p>Before starting the analysis and in case you don't know the right image profile or don't know how to write it in a volatility command, you can run the imageinfo plugin against the image file and volatility will suggest the right profile to you. Imageinfo actually uses another plugin called <span class="strong"><strong>kdbgscan</strong></span>, which scans a part of the NT kernel module for specific unique strings which identifies the image profile. The profile provided by one string, such as Win7SP0X86, and the profile which Volatility uses by default is WinXPSP2x86.</p><p>Usage: <code class="literal">vol.py -f &lt;ImageFile&gt; imageinfo</code></p></div><div class="section" title="pslist"><div class="titlepage"><div><div><h4 class="title"><a id="ch11lvl4sec3"/>pslist</h4></div></div></div><p>This plugin lists the processes from the memory image file. It walks through the double-linked list in the <code class="literal">_EPROCESS</code> structure and prints all the processes in the list. It displays the process name, ID, offset, parent process ID, number of threads and handles, and timestamp of the start and end of the process. This plugin's output has the logical offset of each process in the <code class="literal">_EPROCESS</code> structure. If we need to view the physical offset, we can use the <code class="literal">-P</code> option. If there are hidden processes that were unlinked from the list, this plugin won't detect them.</p><p>Usage: <code class="literal">vol.py -f &lt;ImageFile&gt; --profile=&lt;ImageProfile&gt; pslist -P &lt;OptionalPhysicalOffset&gt;</code></p><p>The following is the output of the preceding command:</p><div class="mediaobject"><img src="graphics/image_11_002.jpg" alt="pslist"/><div class="caption"><p>Figure 2: An example of running the pslist plugin</p></div></div></div><div class="section" title="psscan"><div class="titlepage"><div><div><h4 class="title"><a id="ch11lvl4sec4"/>psscan</h4></div></div></div><p>This plugin lists the processes in the memory dump file by carving the dump for any process structure, and it doesn't consider the <code class="literal">EPROCESS</code> structure. It can get all the processes in the memory, including active, terminated, and hidden processes.</p><p>Usage: <code class="literal">vol.py -f &lt;ImageFile&gt; --profile=&lt;ImageProfile&gt; psscan</code></p></div><div class="section" title="pstree"><div class="titlepage"><div><div><h4 class="title"><a id="ch11lvl4sec5"/>pstree</h4></div></div></div><p>The pstree plugin lists the processes in a tree view, identifying the parent and child processes. It lists the process using the same method that is used by the pslist plugin, so it won't detect hidden or unlinked processes. The output is structured in levels to show the different levels of parenthood between processes.</p><p>Usage: <code class="literal">vol.py -f &lt;ImageFile&gt; --profile=&lt;ImageProfile&gt; pstree</code></p></div><div class="section" title="psxview"><div class="titlepage"><div><div><h4 class="title"><a id="ch11lvl4sec6"/>psxview</h4></div></div></div><p>The plugin psxview compares the results of different process-viewing techniques, for example, using pslist and psscan. This helps in detecting hidden and unlinked processes from one output window.</p><p>Usage: <code class="literal">vol.py -f &lt;ImageFile&gt; --profile=&lt;ImageProfile&gt; psxview</code></p><p>The following is the output of the preceding command:</p><div class="mediaobject"><img src="graphics/image_11_003.jpg" alt="psxview"/><div class="caption"><p>Figure 3: An example of running psscan</p></div></div></div><div class="section" title="getsids"><div class="titlepage"><div><div><h4 class="title"><a id="ch11lvl4sec7"/>getsids</h4></div></div></div><p>Each process has the privilege of the user who started it. The security identifier of the user, the SID, describes the user's privilege in the system. The process has a copy of the access token that is created for the user when they logged on to the system.</p><p>Use the getsids plugin and the process ID to provide the SID of the user who started the process.</p><p>The SID can be mapped easily from the system registry along the following path: <code class="literal">HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\ProfileList</code>.</p><p>It can also be extracted from the opened registry in memory, which will be discussed later.</p><p>Usage: <code class="literal">vol.py -f &lt;ImageFile&gt; --profile=&lt;ImageProfile&gt; getsids -p &lt;optionalPID&gt;</code></p></div><div class="section" title="dlllist"><div class="titlepage"><div><div><h4 class="title"><a id="ch11lvl4sec8"/>dlllist</h4></div></div></div><p>This plugin lists all the DLLs that are called and added to the process using the normal way in the operating system. It shows all the DLLs for all the processes in memory. If the investigator used the <code class="literal">-p</code> option with specific PID, then in this case, this will list only the DLLs of that specific process.</p><p>While addressing hidden of unlinked processes, we need to use the physical address of its structure in memory. So, if we need to list the DLLs of an unlinked or hidden process, we need to provide the plugin with the physical offset of the process in the psscan plugin output, with the <code class="literal">--offset= option</code>.</p><p>Usage: <code class="literal">vol.py -f &lt;ImageFile&gt; --profile=&lt;ImageProfile&gt; dlllist -p &lt;OptionalPID&gt; --offset= &lt;PhysicalOffsetOfTheProcessFromPsscan&gt;</code></p></div><div class="section" title="handles"><div class="titlepage"><div><div><h4 class="title"><a id="ch11lvl4sec9"/>handles</h4></div></div></div><p>A process can have many handles to many objects in the operating system. Analysis of these handles can be difficult because of the huge number of handles for each process. However, this could play an important role in proving a theory about the incident. It could provide the investigator with proof that one process has requested a handle to access a specific file in the filesystem or to create a specific mutant used as a signature for specific malware.</p><p>Using the handles plugin in volatility, we can display all the plugins of one process by the process ID and choose which type of handles will be displayed in the results.</p><p>Usage: <code class="literal">vol.py -f &lt;ImageFile&gt; --profile=&lt;ImageProfile&gt; handles -p &lt;optionalPID&gt; -t &lt;OptionalHandleType&gt;</code></p></div><div class="section" title="filescan"><div class="titlepage"><div><div><h4 class="title"><a id="ch11lvl4sec10"/>filescan</h4></div></div></div><p>For any process to create or read a file, it needs to open this file first in memory. The volatility plugin, filescan, parses for the file object tag in memory and lists all the opened files or the files hidden from ordinary file-scanning tools by the rootkit.</p><p>This plugin will display the physical offset of the detected file object and the filename with the permissions on the file. Like the handles plugin, filescan will be useful in confirming the existence of specific malware by scanning for its specific files that are opened in memory. We can pipeline the output of this plugin with the <code class="literal">grep</code> command in Linux to filter on a specific filename.</p><p>Usage: <code class="literal">vol.py -f &lt;ImageFile&gt; --profile=&lt;ImageProfile&gt; filescan | grep "&lt;FileName&gt;"</code></p></div><div class="section" title="procexedump"><div class="titlepage"><div><div><h4 class="title"><a id="ch11lvl4sec11"/>procexedump</h4></div></div></div><p>When an executable runs in system, a version of this executable is copied to memory. During analysis, we can dump the executable from memory in order to investigate the executable code, or fix the code and run it within a controlled environment, such as a sandbox. Volatility has the procexedump plugin to dump any process executable from memory. It must be provided with the process ID.</p><p>Another plugin that does the same thing, but dumps the slack space along with the executable, is procmemdump and this is used in the same way. This will be helpful if the malware is manipulating the PE header in order to deceive the dumping tools.</p><p>Usage: <code class="literal">vol.py -f &lt;ImageFile&gt; --profile=&lt;ImageProfile&gt; procexedump -p &lt;PID&gt; -D &lt;OptionalOutputDir&gt;</code></p></div><div class="section" title="memdump"><div class="titlepage"><div><div><h4 class="title"><a id="ch11lvl4sec12"/>memdump</h4></div></div></div><p>When the process starts executing, it uses some space in memory to store its code and data that is required during execution. This area could contain important information about the malware, such as strings, code, file paths, contents of files, and so on.</p><p>Volatility can dump this whole area into a single file for further analysis. We can run this file against the Linux native command-Strings in order to extract all the strings in the file.</p><p>Usage: <code class="literal">vol.py -f &lt;ImageFile&gt; --profile=&lt;ImageProfile&gt; procexedump -p &lt;PID&gt; -D &lt;OutputDir&gt;</code></p><p>The following is the output of the preceding command:</p><div class="mediaobject"><img src="graphics/image_11_004.jpg" alt="memdump"/><div class="caption"><p>Figure 4: Dumping malicious process for further analysis</p></div></div></div><div class="section" title="svcscan"><div class="titlepage"><div><div><h4 class="title"><a id="ch11lvl4sec13"/>svcscan</h4></div></div></div><p>Windows services are usually run in the background with higher privileges than other programs, which are run by system users. Some malware samples run as services to work in the background and to ensure the malware's existence in the system after reboot. Rootkits can manipulate the Windows native service-monitoring tools in order to hide some services. Volatility has a plugin called <span class="strong"><strong>svcscan</strong></span>, which, besides listing the services by normal means, also parses the memory space that is owned by the <code class="literal">services.exe</code> process, searching for unique tags for services. This method will reveal any hidden process in memory.</p><p>The output displays the process ID of each service, the service name, service display name, service type, and current status. It also shows the binary path for the registered service, which will be an <code class="literal">EXE</code> for user mode services and a driver name for services that run from kernel mode.</p><p>Usage: <code class="literal">vol.py -f &lt;ImageFile&gt; --profile=&lt;ImageProfile&gt; svcscan</code></p></div><div class="section" title="connections"><div class="titlepage"><div><div><h4 class="title"><a id="ch11lvl4sec14"/>connections</h4></div></div></div><p>As discussed earlier, network traces are very important while analyzing memory samples. Volatility has plugins to scan opened TCP connections in memory with different methods. The first plugin is connections, which displays the TCP connections as Windows tools would do. This lists the all the connections in a linked list structure.</p><p>This plugin only works with Windows XP and the Windows 2003 server, only x68 or x64.</p><p>Usage: <code class="literal">vol.py -f &lt;ImageFile&gt; --profile=&lt;ImageProfile&gt; connections -P &lt;OptionalPhysicalOffset&gt;</code></p></div><div class="section" title="connscan"><div class="titlepage"><div><div><h4 class="title"><a id="ch11lvl4sec15"/>connscan</h4></div></div></div><p>Just like the psscan plugin, connscan searches for connection object structure instead of listing all the connections in the linked list only. It will also list the terminated connections.</p><p>Some connections may have been fully or partially overwritten. So, we need to pay attention during analysis and compare the results with the normal connections plugin.</p><p>Usage: <code class="literal">vol.py -f &lt;ImageFile&gt; --profile=&lt;ImageProfile&gt; connscan</code></p></div><div class="section" title="sockets"><div class="titlepage"><div><div><h4 class="title"><a id="ch11lvl4sec16"/>sockets</h4></div></div></div><p>Another plugin from volatility to network is sockets, which lists all the opened sockets on the system with any protocol. This lists the connection in the way that any Windows API would use for this purpose by walking though the sockets-linked list. This won't be able to find closed sockets or residuals from old sockets.</p><p>This plugin only works with Windows XP and the Windows 2003 server, either x68 or x64.</p><p>Usage: <code class="literal">vol.py -f &lt;ImageFile&gt; --profile=&lt;ImageProfile&gt; sockets</code></p></div><div class="section" title="sockscan"><div class="titlepage"><div><div><h4 class="title"><a id="ch11lvl4sec17"/>sockscan</h4></div></div></div><p>Like the connscan plugin, sockscan searches for the socket structure in memory, which makes it possible to recover residual sockets that were previously opened.</p><p>Usage: <code class="literal">vol.py -f &lt;ImageFile&gt; --profile=&lt;ImageProfile&gt; sockscan</code></p></div><div class="section" title="Netscan"><div class="titlepage"><div><div><h4 class="title"><a id="ch11lvl4sec18"/>Netscan</h4></div></div></div><p>For memory dumped from Windows Vista and higher, both x68 and x64 systems, the netscan plugin checks network traces. This plugin finds TCP endpoints, TCP listeners, UDP endpoints, and UDP listeners. It distinguishes between IPv4 and IPv6, prints the local and remote IP, the local and remote port, and the time when the socket was bound or when the connection was established.</p><p>Some fields could be missed, as netscan parses through the memory for tags of network data structure and views all the results in the same output.</p><p>Usage: <code class="literal">vol.py -f &lt;ImageFile&gt; --profile=&lt;ImageProfile&gt; netscan</code></p></div><div class="section" title="hivelist and printkey"><div class="titlepage"><div><div><h4 class="title"><a id="ch11lvl4sec19"/>hivelist and printkey</h4></div></div></div><p>The registry hives are opened in memory. To locate the hive files in memory, we can use the hivelist volatility plugin, which will list the addresses of the hive files in memory with virtual and physical addresses with the full path of the hive files on the hard drive.</p><p>We can use the printkey plugin to display the subkeys, values, and data in one specific registry key. This will parse all the hives to locate the key that you want, and it may be located in more than one hive.</p><p>If you want to limit the search to one hive, you can provide the virtual address to the plugin with the <code class="literal">-o</code> option.</p><p>Usage: <code class="literal">vol.py -f &lt;ImageFile&gt; --profile=&lt;ImageProfile&gt; hivelist</code></p><p>Usage: <code class="literal">vol.py -f &lt;ImageFile&gt; --profile=&lt;ImageProfile&gt; printkey -o &lt;OptionalVirtualOffsetOfTheHiveFile&gt; -K "PathWithinTheregisty"</code></p></div><div class="section" title="malfind"><div class="titlepage"><div><div><h4 class="title"><a id="ch11lvl4sec20"/>malfind</h4></div></div></div><p>The malfind volatility plugin finds hidden injected code or DLLs that are based on the permissions granted for specific pages in memory. It detects DLLs or code injected in a suspicious way, for example, using the <code class="literal">CreateRemoteThread</code> or <code class="literal">LoadLibrary</code> functions.</p><p>The output of the malfind plugin disassembles the code in the detected area. This output could contain malicious code or an executable file that starts with an executable signature that starts with MZ.</p><p>A copy of the identified memory segments can be extracted for further analysis using <code class="literal">-D</code> or <code class="literal">-dump-dir=&lt;Dir&gt;</code> and the extracted segment will be located under <code class="literal">&lt;Dir&gt;</code>.</p><p>Usage: <code class="literal">vol.py -f &lt;ImageFile&gt; --profile=&lt;ImageProfile&gt; malfind -p &lt;PID&gt; -D &lt;OptionalOutputDir&gt;</code></p><p>The following is the output of the preceding command:</p><div class="mediaobject"><img src="graphics/image_11_005.jpg" alt="malfind"/><div class="caption"><p>Figure 5: An example of malfind</p></div></div><p>In the preceding screenshot, an area of memory with the <code class="literal">0x00210000</code> base address and the <code class="literal">PAGE_EXECUTE_READWRITE</code> permissions in the <code class="literal">wininit.exe</code> process (ID <code class="literal">392</code>).</p></div><div class="section" title="vaddump"><div class="titlepage"><div><div><h4 class="title"><a id="ch11lvl4sec21"/>vaddump</h4></div></div></div><p>The <span class="strong"><strong>VAD</strong></span> (<span class="strong"><strong>Virtual Address Descriptor</strong></span>) is used in Windows memory to describe memory locations that are allocated by a process running in memory. Every time the process allocates new memory, a new VAD entry is created in what is called a VAD tree. Each VAD entry has a start and end, and it covers a specific area in the process memory space.</p><p>The volatility framework has a plugin, vaddump, which can dump each VAD area separately if we are interested in only one VAD entry. This is usually helpful if code or DLL injection has occurred, where we can extract the VAD that contains the malicious code.</p><p>Each VAD has metadata, including a start and end. The vadinfo volatility plugin can provide more information about VADs in one process.</p><p>Usage: <code class="literal">vol.py -f &lt;ImageFile&gt; --profile=&lt;ImageProfile&gt; vaddump -p &lt;PID&gt; -b &lt;VADStartAddressInHex&gt; -D &lt;OutputDir&gt;</code></p></div><div class="section" title="apihooks"><div class="titlepage"><div><div><h4 class="title"><a id="ch11lvl4sec22"/>apihooks</h4></div></div></div><p>The apihooks volatility plugin detects hooks. It detects CALLs and JMPs to other locations in memory. The function being imported or exported begins with the following instructions:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">CALL addr</li><li class="listitem" style="list-style-type: disc">JMP addr</li><li class="listitem" style="list-style-type: disc">PUSH addr; RET</li><li class="listitem" style="list-style-type: disc">MOV reg, addr; CALL reg</li><li class="listitem" style="list-style-type: disc">MOV reg, addr; JMP reg,</li></ul></div><p>If the plugin detects an addr outside of the process memory space, it reports a hook.</p><p>Usage: <code class="literal">vol.py -f &lt;ImageFile&gt; --profile=&lt;ImageProfile&gt; apihooks</code></p></div><div class="section" title="mftparser"><div class="titlepage"><div><div><h4 class="title"><a id="ch11lvl4sec23"/>mftparser</h4></div></div></div><p>The maftparser volatility plugin scans memory file for master file table MFT entries using the FILE or BAAD entry signature. This can list information from the <code class="literal">$FILE_NAME</code>, <code class="literal">$STANDARD_INFORMATION</code>, and <code class="literal">$DATA NTFS</code> attributes.</p><p>The output of this plugin can be in text format by the <code class="literal">--output=text</code> option. It can also format the body, which is compatible with The Sleuth Kit 3 using the <code class="literal">--output=body</code> option.</p><p>In the case of a body file we can use the mactime tool to create one timeline of all the MFT activities in memory which will be useful in tracking activities by time.</p><p>Usage: <code class="literal">vol.py -f &lt;ImageFile&gt; --profile=&lt;ImageProfile&gt; mftparser --output=&lt;body|text&gt; --output-file=&lt;OutputFile&gt;</code></p></div></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec73"/>Summary</h1></div></div></div><p>In this chapter, we discussed the importance of memory forensics in discovering malicious activities, briefly explained the memory structure, and went through volatility as one of the most-famous and effective memory forensics tools.</p><p>In the next chapter, we will be discussing the network forensics tools and techniques in order to extract evidential data from any network dump.</p></div></body></html>