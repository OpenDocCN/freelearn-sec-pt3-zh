["```\n 1\\. # Import the necessary modules from Scapy\n 2\\. from scapy.all import ARP, Ether, srp\n 3.\n```", "```\n 4\\. # Function to perform ARP scan\n 5\\. def arp_scan(target_ip):\n 6.     # Create an ARP request packet\n 7.     arp_request = ARP(pdst=target_ip)\n 8.     # Create an Ethernet frame to encapsulate the ARP request\n 9.     ether_frame = Ether(dst=\"ff:ff:ff:ff:ff:ff\")  # Broadcasting to all devices in the network\n10.\n11.     # Combine the Ethernet frame and ARP request packet\n12.     arp_request_packet = ether_frame / arp_request\n13.\n14.     # Send the packet and receive the response\n15.     result = srp(arp_request_packet, timeout=3, verbose=False)[0]\n16.\n17.     # List to store the discovered devices\n18.     devices_list = []\n19.\n20.     # Parse the response and extract IP and MAC addresses\n21.     for sent, received in result:\n22.         devices_list.append({’ip’: received.psrc, ’mac’: received.hwsrc})\n23.\n24.     return devices_list\n25.\n```", "```\n26\\. # Function to print scan results\n27\\. def print_scan_results(devices_list):\n28.     print(\"IP Address\\t\\tMAC Address\")\n29.     print(\"-----------------------------------------\")\n30.     for device in devices_list:\n31.         print(f\"{device[’ip’]}\\t\\t{device[’mac’]}\")\n32.\n```", "```\n33\\. # Main function to perform the scan\n34\\. def main(target_ip):\n35.     print(f\"Scanning {target_ip}...\")\n36.     devices_list = arp_scan(target_ip)\n37.     print_scan_results(devices_list)\n38.\n```", "```\n39\\. # Entry point of the script\n40\\. if __name__ == \"__main__\":\n41.     # Define the target IP range (e.g., \"192.168.1.1/24\")\n42.     target_ip = input(\"Enter the target IP range (e.g., 192.168.1.1/24): \")\n43.     main(target_ip)\n```", "```\n 1\\. import socket\n 2\\. import threading\n 3\\. import time\n```", "```\n 5\\. #Class Definition\n 6\\. class PortScanner:\n```", "```\n 7.     def __init__(self, target_host, start_port, end_port):\n 8.         self.target_host = target_host\n 9.         self.start_port = start_port\n10.         self.end_port = end_port\n11.         self.open_ports = []\n```", "```\n12\\. #is_port_open Method\n13.     def is_port_open(self, port):\n14.         try:\n15.             with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n16.                 s.settimeout(1)\n17.                 s.connect((self.target_host, port))\n18.             return True\n19.         except (socket.timeout, ConnectionRefusedError):\n20.             return False\n```", "```\n21\\. #scan_ports Method\n22.     def scan_ports(self):\n23.         open_ports = [port for port in range(self.start_port, self.end_port + 1) if self.is_port_open(port)]\n24.         return open_ports\n```", "```\n    1\\. new_list = [expression for item in iterable if condition]\n    ```", "```\n        25\\. def main():\n        26.     target_host = input(\"Enter target host: \")\n        27.     start_port = int(input(\"Enter starting port: \"))\n        28.     end_port = int(input(\"Enter ending port: \"))\n        29.\n        30.     scanner = PortScanner(target_host, start_port, end_port)\n        31.\n        32.     open_ports = scanner.scan_ports()\n        33.     print(\"Open ports: \", open_ports)\n        34.\n        ```", "```\n        35\\. if __name__ == \"__main__\":\n        36.     main()\n        ```", "```\n            portscanner/\n            |-- portscanner/\n            |   |-- __init__.py\n            |   |-- portscanner.py\n            |-- setup.py\n            |-- README.md\n            ```", "```\n             1\\. from setuptools import setup\n             2.\n             3\\. setup(\n             4.     name='portscanner',\n             5.     version='0.1',\n             6.     packages=['portscanner'],\n             7.     install_requires=[],\n             8.     entry_points={\n             9.         'console_scripts': [\n            10.             'portscanner = portscanner.portscanner:main'\n            11.         ]\n            12.     }\n            13\\. )\n            ```", "```\n            .tar.gz file in the dist directory.\n            ```", "```\n            twine:\n\n            ```", "```\n\n            ```", "```\n            PortScanner class from the portscanner package:\n\n            ```", "```\n\n            Our code is now packaged as a Python library, ready for distribution and use by others.\n            ```", "```\n        1\\. def timing_decorator(func):\n        2.     def wrapper(*args, **kwargs):\n        3.         start_time = time.time()  # Record the start time\n        4.         result = func(*args, **kwargs)  # Call the original function\n        5.         end_time = time.time()  # Record the end time\n        6.         print(f\"Scanning took {end_time - start_time:.2f} seconds.\")  # Calculate and print the time taken\n        7.         return result  # Return the result of the original function\n        8.     return wrapper  # Return the wrapper function\n        ```", "```\n        1.     @timing_decorator\n        2.     def scan_ports(self):\n        3.         open_ports = [port for port in range(self.start_port, self.end_port + 1) if self.is_port_open(port)]\n        4.         return open_ports\n        ```", "```\n        1.     def scan_ports_generator(self):\n        2.         for port in range(self.start_port, self.end_port + 1):\n        3.             if self.is_port_open(port):\n        4.                 yield port\n        ```", "```\n         1\\. import socket\n         2\\. import time\n         3.\n         4\\. #Class Definition\n         5\\. class PortScanner:\n         6.     def __init__(self, target_host, start_port, end_port):\n         7.         self.target_host = target_host\n         8.         self.start_port = start_port\n         9.         self.end_port = end_port\n        10.         self.open_ports = []\n        11.     #timing_decorator Decorator Method\n        12.     def timing_decorator(func):\n        13.         def wrapper(*args, **kwargs):\n        14.             start_time = time.time()\n        15.             result = func(*args, **kwargs)\n        16.             end_time = time.time()\n        17.             print(f\"Scanning took {end_time - start_time:.2f} seconds.\")\n        18.             return result\n        19.         return wrapper\n        20.     #is_port_open Method\n        21.     def is_port_open(self, port):\n        22.         try:\n        23.             with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n        24.                 s.settimeout(1)\n        25.                 s.connect((self.target_host, port))\n        26.             return True\n        27.         except (socket.timeout, ConnectionRefusedError):\n        28.             return False\n        29.     #scan_ports Method\n        30.     @timing_decorator\n        31.     def scan_ports(self):\n        32.         open_ports = [port for port in range(self.start_port, self.end_port + 1) if self.is_port_open(port)]\n        33.         return open_ports\n        34.     #scan_ports_generator Method\n        35.     @timing_decorator\n        36.     def scan_ports_generator(self):\n        37.         for port in range(self.start_port, self.end_port + 1):\n        38.             if self.is_port_open(port):\n        39.                 yield port\n        40.\n        41\\. def main():\n        42.     target_host = input(\"Enter target host: \")\n        43.     start_port = int(input(\"Enter starting port: \"))\n        44.     end_port = int(input(\"Enter ending port: \"))\n        45.\n        46.     scanner = PortScanner(target_host, start_port, end_port)\n        47.\n        48.     open_ports = scanner.scan_ports()\n        49.     print(\"Open ports: \", open_ports)\n        50.\n        51.     open_ports_generator = scanner.scan_ports_generator()\n        52.     print(\"Open ports (using generator):\", list(open_ports_generator))\n        53.\n        54\\. if __name__ == \"__main__\":\n        55.     main()\n        ```"]