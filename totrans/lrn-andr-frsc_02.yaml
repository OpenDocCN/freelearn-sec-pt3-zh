- en: Setting up the Android Forensic Environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before starting a forensic examination, you need a workstation. A forensic
    analyst needs to be in total control of their workstation at all times. This chapter
    will take you through everything that is necessary to have an established forensic
    setup for examining Android devices. The following topics are going to be covered
    in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Android forensic setup
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Android Debug Bridge
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rooting Android
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Android forensic setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Setting up a sound and well-controlled forensic environment is crucial before
    the start of any investigation. Start with a fresh and forensically sterile computer.
    A forensically sterile computer is one that prevents the potential of cross-contamination
    and doesn''t introduce unwanted data. This is to ensure that the software present
    on the machine does not interfere with the current investigation. Install basic
    software, such as the ones mentioned in the following list, which are necessary
    to connect to the device and to perform analysis:'
  prefs: []
  type: TYPE_NORMAL
- en: Android SDK
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drivers for mobile devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Office packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tools used for analysis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Android SDK
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's important that we begin the discussion with Android Studio and the Android
    SDK. **Android Studio** is a fully-fledged **Integrated Development Environment**
    (**IDE**), and contains everything needed to build a full app from the ground
    up. The Android **Software Development Kit** (**SDK**) is a subset of Android
    Studio, including only the tools needed to communicate with a device via the command
    line. It includes software libraries, APIs, emulator, reference material, and
    many other tools that not only help to create Android applications but also provide
    documentation and utilities that help significantly in forensic analysis of Android
    devices. Having sound knowledge of the Android SDK can help you understand the
    particulars of a device that, in turn, aid during investigation.
  prefs: []
  type: TYPE_NORMAL
- en: During examination, the SDK helps us to connect to the device and access the
    data. The SDK is supported in Windows, Linux, and OS X and can be downloaded for
    free at [https://developer.android.com/studio](https://developer.android.com/studio).
  prefs: []
  type: TYPE_NORMAL
- en: For the purposes of this book, only the SDK is needed. It can be found at the
    previous link under the *Command line tools only* section.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the Android SDK
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following is a step-by-step procedure to install the Android SDK on a Windows
    10 machine:'
  prefs: []
  type: TYPE_NORMAL
- en: Before the start of the Android SDK installation, make sure the system has the
    latest **Java Development Kit** (**JDK**) installed, as the Android SDK is dependent
    on Java SE Development Kit. JDK can be downloaded from [http://www.oracle.com/technetwork/java/javase/downloads/index.html](http://www.oracle.com/technetwork/java/javase/downloads/index.html).
    Select the correct download based on your operating system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Download the latest version of SDK tools package from [https://developer.android.com/studio/#command-tools](https://developer.android.com/studio/#command-tools).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Unzip the archive you have just downloaded at the location of your choice.
    That''s it: you''re ready to go.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s look at the most interesting parts of the SDK tools from a forensic
    point of view:'
  prefs: []
  type: TYPE_NORMAL
- en: '`apkanalyzer`: This allows you to examine the contents of an APK file in a
    fast and efficient manner. For example, you can collect information about application ID,
    version code, and version name and analyze the contents of its manifest, the DEX
    files inside it, as well as resources, such as texts, images, and strings. You
    can find it under `\sdk\tools\bin`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`avdmanager`: This allows you to create and manage **Android Virtual Devices**
    (**AVDs**) using the command line. Such AVDs can help you with malware analysis
    or can be used for testing if you don''t have a physical Android device, but want
    to research different applications for new forensic artifacts. You can find it
    under `\sdk\tools\bin`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`emulator`: This QEMU-based device-emulation tool that allows you to debug
    and test applications, including malicious ones, in an actual Android runtime
    environment. You can find it under `\sdk\emulator`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sdkmanager`: This helps you to keep your SDK tools updated. With this tool
    you can view, install, update, and uninstall packages. You can find it under `\sdk\tools\bin`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`adb` or Android Debug Bridge: This is a command-line tool that allows you
    to communicate with a device. It can be used not only for installing applications
    or copying data from a device, but also can provide a forensic examiner with a
    Unix shell. You can find it under `\sdk\platform-tools`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fastboot`: This allows you to flash a device different system images. It can
    be used, for example, for flashing custom recovery images—you''ll learn about
    them later in this chapter. You can find it under `\sdk\platform-tools`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It''s important to note that so-called SDK platform tools are not included
    in SDK tools by default, and you''ll have to install it; here is how to do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If you think that you don't need all of the SDK tools, but want to work only
    with platform tools, you can get it on Android Developers ([https://developer.android.com/studio/releases/platform-tools](https://developer.android.com/studio/releases/platform-tools)).
    All you need to start using these tools is to extract contents of the downloaded
    archive to a directory of your choice.
  prefs: []
  type: TYPE_NORMAL
- en: Android Virtual Device
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the Android SDK installed, you can create an AVD, which is an emulator
    that runs on the workstation. An emulator is often used by developers when creating
    new applications. However, an emulator is also considered helpful during forensic
    investigation as it allows the investigator to understand how certain applications
    behave and to understand how installation of an application affects the device.
    Another advantage is you can design an emulator with the desired version. This
    is especially helpful when working with devices running on older versions of Android.
    Also, AVD comes with root as default.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps will guide you to create an AVD on the workstation:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure you have the `emulator` subdirectory under `\sdk`; if not, run the
    following command to install it: `sdkmanager.bat "emulator"`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We need a system image for our virtual device, for example, `system-images;android-28;google_apis;x86`;
    you can download it this way: `sdkmanager.bat "system-images;android-28;google_apis;x86"`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we can create an AVD using `avdmanager`: `avdmanager.bat create avd -k "system-images;android-28;google_apis;x86"
    -n test`. As you may have already guessed, the `k` switch allows you to choose
    a system image, and the `n` switch allows you to choose a name for the AVD.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'It''s time to launch it! Use `emulator.exe` to do it: `emulator.exe -avd test`.
    The following is a screenshot of an AVD after a successful launch:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/9db01dc7-8326-4dd4-9638-608c0ecf0fd8.png)'
  prefs: []
  type: TYPE_IMG
- en: Android Virtual Device (AVD) running Android 9 (Pie)
  prefs: []
  type: TYPE_NORMAL
- en: 'An emulator can be used to configure email accounts, install applications,
    surf the internet, send text messages, and so on. Forensic analysts and security
    engineers can learn a great deal about Android and how it operates by leveraging
    the emulator and examining the network, filesystem, and data artifacts. The data
    created when working on an emulator is stored in your home directory, in a folder
    named `.android`. For instance, in our example, the details about the test AVD
    that we created earlier are stored in `C:\Users\0136\.android\avd\test.avd`. There
    are several files present under this directory and the following are some of the
    files of interest for a forensic analyst:'
  prefs: []
  type: TYPE_NORMAL
- en: '`cache.img`: This is the disk image of the `/cache` partition.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sdcard.img`: This is the disk image of the SD card partition.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Userdata-qemu.img`: This is the disk image of the `/data` partition. The `/data`
    partition contains valuable information about the device user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`config.ini`: This file contains information about the system image used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hardware-qemu.ini`: This file contains the emulator''s hardware options, such
    as architecture, RAM size, and screen type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting and accessing Android devices from the workstation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to extract information from an Android device, it first needs to be
    connected to the workstation. As mentioned earlier, care should be taken to make
    sure that the workstation is forensically sterile and used only for the purpose
    of investigation. A forensically sterile workstation is one that has a proper
    build and is free from malware. So, if you are familiar with virtual machines
    and snapshots, it may be a good idea for mobile forensics in general and Android
    forensics in particular, as you can have a perfectly clean workstation every time
    you need to examine a new device.
  prefs: []
  type: TYPE_NORMAL
- en: When a device is connected to the computer, changes can be made to the device,
    and so it is crucial that the forensic examiner maintains control over the device
    at all times. In the world of mobile forensics, using write protection mechanisms
    may not be of great help as they prevent successful acquisition of the device.
    This is because during acquisition certain commands need to be pushed to the device
    to extract necessary data. What is more, sometimes even small applications need
    to be installed in order to extract more data from the device or, for example,
    to root it.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying the correct device cable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An Android device can be connected to a workstation using the physical USB
    interface of the device. This physical USB interface allows the device to connect,
    share data, and recharge from a computer. USB interfaces may change from manufacturer
    to manufacturer, also from device to device. There are different types, such as
    micro-USB, USB-C, and some other less popular proprietary formats. The following
    is a brief description of the most widely used connector types:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Connector type** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Micro-USB | It is approximately 6 by 1.5 mm in size, with two corners cut
    off to form a trapezoid. |'
  prefs: []
  type: TYPE_TB
- en: '| USB-C | It is 8.4 by 2.6 mm in size, in the form of a rectangle with round
    corners. |'
  prefs: []
  type: TYPE_TB
- en: Hence, the first step in acquisition is to identify what kind of device cable
    is required.
  prefs: []
  type: TYPE_NORMAL
- en: Installing device drivers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A mobile device can communicate with the computer only when the necessary device
    drivers are installed on it. Without the necessary drivers, the computer may not
    be able to identify and work with the connected device. Since Android is allowed
    to be modified and customized by the manufacturers, there is no single generic
    driver that would work for all Android devices. Each manufacturer has its own
    proprietary drivers and distributes them along with the phone. Hence, it is important
    to identify the specific device driver that needs to be installed. Of course,
    some of the Android forensic toolkits do come with some generic drivers or a set
    of the most frequently used drivers, but they may not work with all models of
    Android phones. Some Windows operating systems are able to auto detect and install
    the drivers once the device is plugged in but, more often than not, it fails.
    The device drivers for each manufacturer can be found on their respective websites.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing the device
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After installing the necessary device drivers, connect the Android device to
    the computer directly using the USB cable in order to access it. It is important
    to use genuine, manufacturer-specific cables because universal cables may not
    work properly with certain devices and the investigator may encounter certain
    driver issues. Some of the devices may not be USB 3.0 compatible, which may lead
    to failed driver installations. In that case, it's recommended to try switching
    to USB 2.0 ports. Once the device is connected, it will appear as a new drive
    and you can access the files on the external storage. Some older Android devices
    may not be accessible unless the Connect storage to PC option (present under Settings
    | USB utilities) is enabled on the device.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, after connecting the device through USB, the Turn on USB storage
    option needs to be selected, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e64cc8f2-d38a-4609-a75a-6cd032a4bf22.png)'
  prefs: []
  type: TYPE_IMG
- en: USB mass storage connection
  prefs: []
  type: TYPE_NORMAL
- en: This is because older Android devices required USB mass storage mode for transferring
    files between computer and the device. The latest Android devices use MTP or PTP
    protocols, as there were some issues with the USB mass storage protocol. With
    USB mass storage, the drive makes itself completely available to the computer,
    just as if it were an internal drive. But the problem is that the device that
    is accessing the storage needs exclusive access to it. In other words, when the
    device drive is connected to the computer, it has to be disconnected from the
    Android operating system running on the device in order to work. So any files
    or apps stored on the SD card or USB storage would be unavailable when it was
    connected to the computer. In **Media Transfer Protocol** (**MTP**), the Android
    device doesn't expose its entire storage to Windows. Instead, when you connect
    a device to your computer, the computer queries the device and the device responds
    with a list of files and directories it offers. If the computer has to download
    a file, it sends a request to the file from the device, and the device will send
    the file over the connection. **Picture Transfer Protocol** (**PTP**) is also
    similar to MTP and is commonly used by digital cameras. In this mode, Android
    device will work with digital camera applications that support PTP but not MTP.
    On the latest devices, you can select either MTP or PTP options under Settings
    | Storage | USB computer connection.
  prefs: []
  type: TYPE_NORMAL
- en: On some Android devices, the option to select MTP and PTP protocols is provided
    only after connecting the device to the computer. After the device is connected,
    watch the **notifications** bar at the top of your screen and you will see a USB
    symbol appear. Pull down the notifications and you will find an option to switch
    between MTP and PTP.
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in the following screenshot, the MTP and PTP options are shown only
    after connecting the device to a computer and pulling down the notifications bar:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e6e50f20-7668-420e-9c0a-44ee3ed22455.png)'
  prefs: []
  type: TYPE_IMG
- en: Changing USB connection mode on an Android device
  prefs: []
  type: TYPE_NORMAL
- en: The default selection is Charging. When the File transfers option is selected,
    it is mounted as a disk drive. When the device is mounted as a disk drive, you
    will be able to access the SD card present on the device.
  prefs: []
  type: TYPE_NORMAL
- en: From a forensic point of view, the SD card has a significant value as it may
    contain files that are important for an investigation. Most of the images and
    large files related to multimedia are stored in this external storage. SD cards
    are commonly formatted with the FAT32 filesystem, but you might also encounter
    some having exFAT and some other filesystems. As discussed in [Chapter 1](1e7a3a23-96c6-4085-9981-44b579bb2a7f.xhtml),
    *Introducing Android Forensics*, please note that most of the recent devices have
    emulated SD card feature that uses the devices NAND flash to create a non-removable
    SD card. Thus, all the sensitive files present on external storage can be accessed
    in this way. However, the core application data stored under `/data/data` will
    remain on the device and cannot be accessed this way.
  prefs: []
  type: TYPE_NORMAL
- en: Android Debug Bridge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Android forensics, **Android Debug Bridge** (**ADB**) plays a very crucial
    role. It is present under the `<sdk_path>/platform-tools` location. In order to
    work with ADB, the USB-Debugging option needs to be enabled. On most Android phones
    and tablets, you can access this under Settings | Developer Options, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/669f6339-782d-4787-9e4c-786321e3fe04.png)'
  prefs: []
  type: TYPE_IMG
- en: USB debugging option
  prefs: []
  type: TYPE_NORMAL
- en: However, this may not be the case with all the devices, as different devices
    have different environments and configuration features. Sometimes, the examiner
    might have to use certain techniques to access the Developer Options on a few
    devices. These techniques are device-specific and need to be researched and determined
    by the forensic analyst based on the device type and model.
  prefs: []
  type: TYPE_NORMAL
- en: On some devices, the Developer Options menu is hidden and can be turned on by
    tapping the **Build Number** field (present under Settings | System | About Phone)
    seven times.
  prefs: []
  type: TYPE_NORMAL
- en: Once the USB Debugging option is selected, the device will run the ADB daemon
    (`adbd`) in the background and will continuously look for a USB connection. The
    daemon will usually run under a non-privileged shell user account and so doesn't
    provide access to internal application data. But on rooted phones `adbd` will
    run under the root account and hence provides access to all of the data. On the
    workstation (where the Android SDK is installed), `adbd` will run as a background
    process. Also, on the same workstation, a client program will run that can be
    invoked from a shell by issuing the `adb` command that we are going to see in
    the following sections. When the ADB client is started, it first checks whether
    an ADB daemon is already running. If there isn't, it initiates a new process to
    start the ADB daemon. The daemons communicate over their local host on the `5555`
    through `5585` ports. The even port communicates with the device's console, while
    the odd port is for ADB connections. The ADB client program communicates with
    the local `adbd` over the `5037` port.
  prefs: []
  type: TYPE_NORMAL
- en: Using ADB to access the device
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As stated before, ADB is a powerful tool that allows you to communicate with
    the Android device. We will now look at how to use ADB and access certain parts
    of the device that cannot be accessed normally. It is important to note that the
    collection of data through ADB may or may not be accepted as evidence in court
    depending on the respective laws of the country. The following sections list some
    of the commonly used ADB commands and their meaning and usage in a logical sequence.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting a connected device
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After connecting the device to the workstation and before issuing other ADB
    commands, it is helpful to know whether the Android device is properly connected
    to the ADB server. This can be done using the ADB devices command, which lists
    out all of the devices that are connected to the computer as shown in the following
    command lines. This would also list the emulator if it is running at the time
    of issuing the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Remember that, if necessary drivers are not installed, then the preceding command
    would show a blank message. If you encounter that situation, download the necessary
    drivers from the manufacturer and install them.
  prefs: []
  type: TYPE_NORMAL
- en: 'As seen in the preceding command lines, the output contains the serial number
    of the device followed by the connection state. The serial number is a unique
    string used by ADB to identify each Android device. The possible connection state
    values and their meaning is explained in the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Offline**: The instance is not connected to ADB or is not responding.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Device**: The instance is connected to the ADB server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**No device**: There''s no device connected.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Unauthorized**: USB debugging isn''t authorized.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Directing commands to a specific device
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If more than one device is connected to the system, you must specify the target
    device while issuing the commands. For example, consider the following case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in the preceding command-line output, there are two devices attached
    to the workstation. In this case, `adb` needs to be used along with the `–s` option
    to issue commands to the device of your choice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, the `d` switch can be used to direct an `adb` command to the only
    attached USB device, and the `e` switch can be used to direct an `adb` command
    to the only running emulator instance.
  prefs: []
  type: TYPE_NORMAL
- en: Issuing shell commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned in [Chapter 1](1e7a3a23-96c6-4085-9981-44b579bb2a7f.xhtml), *Introducing
    Android Forensics*, Android runs on a Linux kernel and so provides a way to access
    the shell. Using `adb`, you can access a shell to run several commands on an Android
    device. For those who are not familiar with Linux environment, Linux shell refers
    to a special program that allows you to interact with it by entering certain commands
    from the keyboard; the shell will execute the commands and display its output.
    More details about how things work on Linux environment have been provided under
    the *Rooting Android device* section in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `adb shell` command can be used to enter into a remote shell, as shown
    in the following command-line output. Once you enter the shell, you can execute
    most of the Linux commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'After executing the command, observe that the shell prompt is displayed to
    the user where commands can be executed on the device. For instance, as shown
    in the following command line, the `ls` command can be used to view all of the
    files within a directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The following section explains some of the most widely used Linux commands that
    are very helpful while interacting with an Android device.
  prefs: []
  type: TYPE_NORMAL
- en: Basic Linux commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will now take a look at some of the Linux commands and their usage with
    respect to Android device:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ls`: The `ls` command (with no option) lists files and directories present
    in the current directory. With the `l` switch, this command shows files and directories
    and their size, modified date and time, the owner of the file and its permission,
    and so on, as shown in the following command-line output:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, the following are a few options that can be used along with the `ls`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Option** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `a` | Lists hidden files |'
  prefs: []
  type: TYPE_TB
- en: '| `c` | Displays files by timestamp |'
  prefs: []
  type: TYPE_TB
- en: '| `d` | Displays only directories |'
  prefs: []
  type: TYPE_TB
- en: '| `n` | Displays the long format listing, with GID and UID numbers |'
  prefs: []
  type: TYPE_TB
- en: '| `R` | Displays subdirectories as well |'
  prefs: []
  type: TYPE_TB
- en: '| `t` | Displays files based on timestamp |'
  prefs: []
  type: TYPE_TB
- en: '| `u` | Displays the file access time |'
  prefs: []
  type: TYPE_TB
- en: Depending on the requirement, one or more of these options can be used by the
    investigator to view the details.
  prefs: []
  type: TYPE_NORMAL
- en: '`cat`: The `cat` command reads one or more files and prints them to standard
    output, as shown in the following command lines:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `>` operator can be used to combine multiple files into one. The `>>` operator can
    be used to append to an existing file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cd`: The `cd` command is used to change from one directory to another. This
    is much used while navigating from one folder to another. The following example
    shows commands used to change to system folder:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '`cp`: The `cp` command can be used to copy a file from one location to another.
    The syntax for this command is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are the main options for the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Option** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `s` | Creates a `symlink` function instead of a copy |'
  prefs: []
  type: TYPE_TB
- en: '| `l` | Creates a hard link instead of a copy |'
  prefs: []
  type: TYPE_TB
- en: '| `R` | Copies files in subdirectories recursively |'
  prefs: []
  type: TYPE_TB
- en: '| `p` | Preserves timestamps, ownership, and mode |'
  prefs: []
  type: TYPE_TB
- en: '`chmod`: The `chmod` command is used to change the access permissions to filesystem
    objects (files and directories). It may also alter special mode flags. The syntax
    for this command is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: For example, `chmod 777` on a file gives permission to everyone to read, write,
    and execute.
  prefs: []
  type: TYPE_NORMAL
- en: '`dd`: The `dd` command is used to copy a file, converting and formatting it
    according to the operands. With Android, the `dd` command can be used to create
    a bit-by-bit image of the Android device. More details about the imaging are covered
    in [Chapter 4](b5ab11df-1911-4deb-accd-f92c74650e6d.xhtml), *Extracting Data Logically
    from Android Devices*. The following is the syntax that needs to be used with
    this command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '`rm`: The `rm` command can be used to delete files or directories. The following
    is the syntax for this command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '`grep`: The `grep` command is used to search files or output for a particular
    pattern. The following example shows how to search a `default.prop` file for `secure`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '`pwd`: The `pwd` command displays the current working directory. For example,
    the following command-line output shows that the current working directory is
    `/data`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '`mkdir`: The `mkdir` command is used to create a new directory. The following
    is the syntax for this command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Using the `p` switch, you can also create parent directory if you need it.
  prefs: []
  type: TYPE_NORMAL
- en: '`exit`: The `exit` command can be used to exit the shell you are in. Just type
    `exit` in the shell to exit from it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing an application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'During forensic analysis, there might be cases where you need to install a
    few applications on the device in order to extract some data. To do so, you can
    use the `adb install` command. Along with this command, as shown in the following
    command-line output, you need to specify the path to the `.apk` file that you
    want to install:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: However, it is important to note that installing third-party apps may not accepted
    in a court of law. Hence, a forensic investigator needs to be cautious before
    installing any third-party app on the device.
  prefs: []
  type: TYPE_NORMAL
- en: Pulling data from the device
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can use the `adb pull` command to pull the files present on the Android
    device to the local workstation. The following is the syntax for using this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '`<remote>` refers to the path of the file on the Android device and `<local>`
    refers to the location on the local workstation where the file needs to be stored.
    For instance, the following command-line output shows a `Sample.png` file being
    pulled from the Android device to a `temp` folder on the computer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: However, on a normal Android phone, you will not be able to download all of
    the files using the `adb pull` command because of inherent security features enforced
    by the operating system. For example, files present in the `/data/data` folder
    cannot be accessed in this manner on an Android device that is not rooted. More
    details about this topic have been covered in [Chapter 4](b5ab11df-1911-4deb-accd-f92c74650e6d.xhtml),
    *Extracting Data Logically from Android Device*.
  prefs: []
  type: TYPE_NORMAL
- en: Pushing data to the device
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can use the `adb push` command to copy files from the local workstation
    to the Android device. The following is the syntax for using this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '`<local>` refers to the location of the file on the local workstation and `<remote>`
    refers to the path on the Android device where the file needs to be stored. For
    instance, the following command-line output shows `filetest.pngcopied` from the
    computer to the `Pictures` folder of an Android device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: You can only push the files to those folders for which the user account has
    privileges.
  prefs: []
  type: TYPE_NORMAL
- en: Restarting the ADB server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In some cases, you might need to terminate the ADB server process and then restart
    it. For example, if `adb` does not respond to a command, you can terminate the
    server and restart it and that may resolve the problem.
  prefs: []
  type: TYPE_NORMAL
- en: To stop the ADB server, use the `kill-server` command. You can then restart
    the server by issuing any other `adb` command.
  prefs: []
  type: TYPE_NORMAL
- en: Recovery and fastboot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before dealing with the process of rooting, it is necessary to understand about
    boot loader, recovery, and fastboot modes in Android. The following sections explain
    these in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Recovery mode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An Android phone can be seen as a device having three main partitions: boot
    loader, Android ROM, and recovery. *Boot loader* is present in the first partition
    and is the first program that runs when the phone is powered on. The primary job
    of this boot loader is to take care of low-level hardware initialization and to
    boot into other partitions. It usually loads the Android partition, commonly referred
    to as **Android ROM**, by default. Android ROM contains all of the operating system
    files that are necessary to run the device. The *recovery* partition, commonly
    referred to as stock recovery, is the one that is used to delete all user data
    and files, or to perform system updates.'
  prefs: []
  type: TYPE_NORMAL
- en: Both of these operations can be started from the running Android system or by
    manually booting into the recovery mode. For example, when you do a factory reset
    on your phone, recovery is what boots up and erases the files and data. Likewise,
    with updates, the phone boots into recovery mode to install the latest updates
    that are written directly to the Android ROM partition. Hence, recovery mode is
    the screen that you see when you install any official update on the device.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing recovery mode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The recovery image is stored on the recovery partition and consists of a Linux
    image with a simple user interface controlled by hardware buttons. Recovery mode
    can be accessed in two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: By pressing a certain keypress combination when booting the device (usually
    by holding the Volume+, Volume-, and Power buttons during the boot up)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By issuing the `adb reboot recovery` command to a booted Android system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is a screenshot of a stock recovery mode on an Android device:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/909305b1-5cc8-4650-ad92-29fe7415c076.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Android stock recovery
  prefs: []
  type: TYPE_NORMAL
- en: The stock Android recovery is intentionally very limited in functionality. It
    has the options to reboot the system, apply updates from ADB and SD card, factory
    reset, and so on. However, custom recovery offers many more options.
  prefs: []
  type: TYPE_NORMAL
- en: Custom recovery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A custom recovery is a recovery environment created by a third party. It can
    be used to replace the default, stock recovery environment with a customized recovery
    environment on the target device. Here is a list of the most common features that
    can be found in custom recovery:'
  prefs: []
  type: TYPE_NORMAL
- en: It provides full backup and restores functionality (such as NANDroid).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It allow unsigned update packages or allows signed packages with custom keys.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It selectively mounts device partitions and SD card.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It provides USB mass storage access to SD card or data partitions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It provides full ADB access, with the ADB daemon running as root.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's a fully featured BusyBox binary. BusyBox is a collection of powerful
    command line tools in a single binary executable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are several custom recovery images available in the market today, such
    as ClockworkMod recovery, TeamWin Recovery Project, and so on. The following screenshot
    shows the options available with **TeamWin Recovery Project (TWRP) 3.0.0.0**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/02a83390-48e6-468d-baf9-d696c56bb2ba.png)'
  prefs: []
  type: TYPE_IMG
- en: TWRP recovery
  prefs: []
  type: TYPE_NORMAL
- en: Viewing log data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Android, the `logcat` command provides a way to view system debug output.
    Logs from various applications and portions of the system are collected in a series
    of circular buffers, which can then be viewed and filtered by using this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The log message shown here is just a sample message and, during investigation,
    logs need to be carefully analyzed to gather information on location details,
    data/time information, application details, and so on. Each log begins with a
    message type indicator as described in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Message type** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| V | Verbose |'
  prefs: []
  type: TYPE_TB
- en: '| D | Debug |'
  prefs: []
  type: TYPE_TB
- en: '| I | Information |'
  prefs: []
  type: TYPE_TB
- en: '| W | Warning |'
  prefs: []
  type: TYPE_TB
- en: '| E | Error |'
  prefs: []
  type: TYPE_TB
- en: '| F | Fatal |'
  prefs: []
  type: TYPE_TB
- en: '| S | Silent |'
  prefs: []
  type: TYPE_TB
- en: Rooting Android
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rooting is a word that is very often heard with respect to Android devices.
    As a forensic examiner, it is essential to understand this in detail. This would
    help you to gain knowledge that is required to understand the internals of the
    device and gain expertise on several issues that are encountered during an investigation.
    Rooting Android phones has become a common phenomenon and very often rooted phones
    are encountered during investigations. Also, depending upon the situation and
    data to be extracted, the examiner themself has to root the device in order to
    extract certain data. The following sections cover rooting an Android device and
    other related concepts in detail.
  prefs: []
  type: TYPE_NORMAL
- en: What is rooting?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To understand rooting, it is essential to understand how Unix-like systems
    work. The original Unix operating system, on which Linux and other Unix-like systems
    are based, was designed from the very beginning as a multiuser system. This is
    primarily because personal computers did not yet exist and hence it was necessary
    to have a mechanism for separating and protecting the resources of the individual
    users while allowing them to use the system simultaneously. But in order to perform
    privileged tasks such as granting and revoking powers for ordinary users and accessing
    critical system files to repair or upgrade the system, it was necessary to have
    a system administrator account that has superuser access. So, we have two types
    of accounts: normal user accounts that have fewer privileges and a superuser or
    **root account** that has all of the privileges.'
  prefs: []
  type: TYPE_NORMAL
- en: Hence, *root* is the username or account that by default has access to all commands
    and files on a Linux or other Unix-like operating system. It is also referred
    to as the root account, root user, and the superuser. So, in Linux, the root user
    has the power to start/stop any system service, edit/delete any file, change the
    privileges of other users, and so on. We have learned earlier that Android uses
    the Linux kernel and hence most of the concepts present in Linux are applicable
    to Android as well. However, when you buy an Android phone, normally it does not
    let you log in as a root user. Rooting an Android phone is all about gaining this
    root access on the device to perform actions that are not normally allowed on
    the device.
  prefs: []
  type: TYPE_NORMAL
- en: It is also important to understand the difference between *rooting* and *jailbreaking,*
    as both are often wrongly assumed to be the same. Jailbreaking a device running
    an Apple iOS operating system allows you to remove certain restrictions and limitations
    put in place by Apple. For instance, Apple does not allow sideloading unsigned
    applications on the device. So, by jailbreaking, you can install applications
    that are not approved by Apple. In contrast, Android by functionality allows sideloading
    of applications. Jailbreaking a phone involves bypassing several security restrictions
    simultaneously. Hence, gaining root access on the device is only one of the aspects
    of jailbreaking a device.
  prefs: []
  type: TYPE_NORMAL
- en: Why root?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rooting is often performed by many people with the goal of overcoming limitations
    that carriers and hardware manufacturers put on Android devices. By rooting an
    Android device you can alter or replace system applications and settings, run
    specialized apps that require administrator-level permissions, or perform operations
    that are otherwise inaccessible to a normal Android user, such as uninstalling
    the default apps (especially the bloatware) that come along with the phone. Rooting
    is also done for extreme customization; for instance, new, customized ROMs could
    be downloaded and installed. However, from a forensic analysis point of view,
    the main reason for rooting is to gain access to those parts of the system that
    are normally not accessible. Most of the public root tools will result in a permanent
    root where the changes persist even after rebooting the device. In the temporary
    root, the changes are lost once the device reboots. Temporary roots should always
    be preferred in forensic cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'As explained in [Chapter 1](1e7a3a23-96c6-4085-9981-44b579bb2a7f.xhtml), *Introducing
    Android Forensics*, in Linux systems, each user is assigned a unique **User ID**
    (**UID**) and users are segregated so that one user does not access the data of
    another user. Similarly, in Android each application is assigned a UID and is
    run as a separate process. App UIDs are usually assigned in the order that they
    are installed, starting from 10001\. These IDs are stored in the `packages.xml`
    file in `/data/system`. This file, in addition to storing UIDs, stores the Android
    permissions of each program as described in its manifest file. The private data
    of each application is stored in the `/data/data` location and is accessible only
    to that application. Hence, during the course of an investigation, data present
    under this location cannot be accessed. But rooting a phone would allow you to
    access the data present in any location. It is important to keep in mind that
    rooting a phone has several implications, as described in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Security risk**: Rooting a phone might expose the device to security risks.
    For instance, imagine a malicious app that has access to the entire operating
    system and to the data of all of the other apps installed on the device.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bricking of your device**: If rooting is not done in the proper manner it
    might result in bricking your device. Bricking is a word commonly used with those
    phones that are dead or cannot be turned on in any way.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Voiding your warranty**: Depending on the manufacturer and carrier, rooting
    a device may void your warranty since it exposes the device to several threats.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Forensic implications**: Rooting an Android device will allow an investigator
    to access a larger set of data, but it involves the alteration of certain portions
    of the device. Hence, a device should be rooted only when it is absolutely necessary.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fastboot mode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Fastboot is a protocol that can be used to re-flash partitions on your device.
    It is one of the tools that comes along with the Android SDK and is an alternative
    to the recovery mode for doing installations and updates and for unlocking the
    boot loader in some cases. While in fastboot, you can modify the filesystem images
    from a computer over a USB connection. Hence, it is one of the ways to install
    the recovery images and to just boot in some cases. Once the phone is booted into
    fastboot, you can flash image files to the internal memory. For example, the previously
    discussed custom recovery images such as TWRP recovery can be flashed in this
    manner.
  prefs: []
  type: TYPE_NORMAL
- en: 'All you need is to type a few commands. First, reboot the device into bootloader/fastboot
    mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, flash TWRP using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can reboot the device using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Before flashing TWRP, make sure you've read the thread about target devices
    at the XDA Developers forum ([https://forum.xda-developers.com/](https://forum.xda-developers.com/)).
  prefs: []
  type: TYPE_NORMAL
- en: Locked and unlocked boot loaders
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Boot loaders may be locked or unlocked. Locked boot loaders don't allow you
    to perform modifications to the device's firmware by implementing restrictions
    at the boot loader level, usually done through cryptographic signature verification.
    Hence, unsigned code cannot be flashed to the device. In other words, in order
    to run any recovery image or your own operating system, the boot loader needs
    to be unlocked first. Unlocking the boot loader could result in serious security
    implications. If the device is lost or stolen, all data on it can be recovered
    by an attacker simply by uploading a custom Android boot image or flashing a custom
    recovery image. After doing so, the attacker has full access to the data contained
    on the device. Because of this reason, a factory data reset is performed on the
    phone when unlocking a locked boot loader so that all of the data is erased. Hence,
    it is important to perform this only when it is absolutely necessary. Some devices
    have ways to unlock them officially. For these devices, the boot loader can be
    unlocked by putting the device into fastboot mode and running the `fastboot oem
    unlock` command. This will unlock the boot loader and do a complete wipe of the
    Android device.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some other manufacturers provide unlocking through different means, for instance,
    through their website. The following screenshot shows the Xiaomi website providing
    support for unlocking Xiaomi devices:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c964fdcb-4938-44cc-a751-6c09d35980c6.png)'
  prefs: []
  type: TYPE_IMG
- en: Xiaomi website providing support to unlock boot loader
  prefs: []
  type: TYPE_NORMAL
- en: How to root
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section is based on whether the underlying boot loader is locked or unlocked.
    Gaining root access on a device with an unlocked boot loader is very easy, while
    gaining root access on a device with a locked boot loader is not so straightforward.
    The following sections explain this in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Rooting an unlocked boot loader
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Unix-like systems, the superuser is a special user account used for system
    administration and has privileges to access and modify all of the files in an
    operating system. The process of rooting mainly involves copying the `su` (superuser)
    binary to a location in the current process's path (`/system/xbin/su`) and granting
    it executable permissions with the `chmod` command. Hence, the first step here
    is to unlock the boot loader. As explained in the *Locked and unlocked boot loaders *section,
    depending on the device in question, unlocking a boot loader can be done either
    through fastboot mode or through following a vendor specific boot loader unlock
    procedure.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `su` binary is usually accompanied by an Android application, such as SuperUser,
    that provides a graphical prompt each time an application requests root access,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a3a6451e-e09a-42fc-8bc5-60b70f92c904.png)'
  prefs: []
  type: TYPE_IMG
- en: Superuser request
  prefs: []
  type: TYPE_NORMAL
- en: Once the boot loader is unlocked, you can make all of the desired changes to
    the device. Hence, copying the `su` binary and granting it executable permissions
    can be done in many ways. The most common method is to boot a custom recovery
    image. This allows copying the `su` binary into the system partition and setting
    the appropriate permissions through a custom update package.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how to root a Samsung Galaxy S7 (International SM-G930F/FD/X, Korean
    SM-G930K/L/S, and Canadian SM-G930W8 Exynos models):'
  prefs: []
  type: TYPE_NORMAL
- en: Make sure **OEM unlock** is enabled in Developer options.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Download ODIN (available here: [https://build.nethunter.com/samsung-tools/Odin_3.12.3.zip](https://build.nethunter.com/samsung-tools/Odin_3.12.3.zip))
    and extract the contents of the archive in the directory of your choice.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Download the TWRP image (available here: [http://teamw.in/devices/samsunggalaxys7.html](http://teamw.in/devices/samsunggalaxys7.html)).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Reboot your device into Download mode. To do this, hold the [Volume Down] +
    [Home] buttons while your device reboots. Once you see the Download mode warning screen,
    press [Volume Up] to continue.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start Odin and put the TWRP image in the [AP] slot; don't forget to disable
    **Auto-Reboot**. Start flashing the recovery.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To exit Download mode, hold [Volume Down] + [Home] + [Power]; when the screen
    blanks, immediately change [Volume Down] to [Volume Up].
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Allow system modifications by swiping right.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Download **SuperSU** (available here: [https://download.chainfire.eu/supersu](https://download.chainfire.eu/supersu)).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Transfer the archive with SuperSU to the device via MTP, and install it via
    the corresponding TWRP option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since Android version 4.1, a new feature called sideload mode has been introduced.
    This feature allows applying an update ZIP over ADB without copying it to the
    device beforehand. To sideload an update, run the `adb sideload su-package.zip` command,
    where `su-package.zip` is the filename of the update package on your computer.
  prefs: []
  type: TYPE_NORMAL
- en: Alternately, you can also modify a factory image to add an `su` binary. This
    can be done by unpacking an ext4 formatted system image, adding a `su` binary
    and repacking it. If this image is flashed, it will contain the `su` binary and
    the device will be rooted.
  prefs: []
  type: TYPE_NORMAL
- en: Rooting is a highly device-specific process and hence forensic investigator
    needs to be cautious before applying these techniques on any Android device.
  prefs: []
  type: TYPE_NORMAL
- en: Rooting a locked boot loader
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When the boot loader is locked and cannot be unlocked through any available
    means, rooting the device requires finding a security flaw that can be exploited.
    But before that, it is important to identify the type of boot loader lock. It
    can vary depending on the manufacturer and software version. With some mobiles,
    fastboot access may not be allowed, but you can still flash using the manufacturer's
    proprietary flashing protocol, such as Samsung ODIN. Some devices enforce signature
    verification on selected partitions only, such as boot and recovery. Hence, it
    may not be possible to boot into custom recovery. However, you can still modify
    the factory image to include `su` binary, as explained in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: If the boot loader cannot be unlocked through any means, then the only option
    is to find some vulnerability on the device that allows us to exploit and add
    `su` binary. The vulnerability can be in the Android kernel or in a process running
    as root or any other issue. It is device-specific and needs to be researched extensively
    before trying it on any device.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the most popular applications for Android rooting:'
  prefs: []
  type: TYPE_NORMAL
- en: Kingo ([https://www.kingoapp.com/](https://www.kingoapp.com/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Root Genius ([http://www.shuame.com/en/root/](http://www.shuame.com/en/root/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: iRoot ([http://www.iroot.com/](http://www.iroot.com/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ADB on a rooted device
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have already seen how the ADB tool can be used to interact with the device
    and execute certain commands on the device. However, on a normal Android phone,
    certain locations such as `/data/data` cannot be accessed. For example, the following
    shows the command-line output when trying to access `/data/data` on a normal device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This is because the private data of all of the applications is stored in this
    folder and so the security is enforced by the Android. Only the root user has
    access to this location. Hence, on a rooted device, you will be able to see all
    of the data under this location, as shown in the following command lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the previous code, all of the application's private data can now
    be seen easily by navigating to the respective folders. Hence, the ADB tool on
    a rooted device is very powerful and allows an examiner to access all of the data
    of applications installed on the device, provided the device is not pattern or
    PIN protected or registered to the machine with an RSA key.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, even on a rooted phone, you would see the permission denied message.
    In such cases, after executing the `adb shell` command, try entering SuperUser
    mode by typing `su`. If root is enabled, you will see `#` without asking for the
    password.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Setting up a proper forensic environment is crucial prior to conducting investigation
    on an Android device. The Android SDK installation is necessary to use tools such
    as ADB, which come along with it. Using ADB, an examiner can communicate with
    the device, view folders on the device, pull data, and copy data to the device.
    However, not all folders can be accessed on a normal phone in this manner, since
    the device's security enforcements prevent an examiner from viewing locations
    that contain private data. Hence, rooting a device solves this issue, as it provides
    unlimited access to all the data present on the device. Rooting a device with
    an unlocked boot loader is straightforward, while rooting a device with a locked
    boot loader involves exploiting some security bugs.
  prefs: []
  type: TYPE_NORMAL
- en: With this knowledge on accessing the device, we will now cover how data is organized
    on an Android device and many other details in [Chapter 3](615ae74c-4301-46e6-92f2-387637bebd38.xhtml),
    *Understanding Data Storage on Android Devices.*
  prefs: []
  type: TYPE_NORMAL
