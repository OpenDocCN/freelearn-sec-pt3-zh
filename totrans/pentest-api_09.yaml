- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: API Abuse and Business Logic Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With this chapter, we will finish the fourth part of our book. We just learned
    about **data exposure** and **information leakage**, which are unfortunately very
    common nowadays. It is also unfortunate that there are even more dangerous ways
    to break API protection controls. Abusing the right way of using endpoints is
    one of them. Exploiting the API logic is another fearsome one.
  prefs: []
  type: TYPE_NORMAL
- en: '**API abuse** refers to the misuse of an API beyond its intended purpose, leading
    to security vulnerabilities, data breaches, or service disruptions. **Business
    logic testing** involves identifying vulnerabilities in the application’s business
    rules and workflows. This ensures that the application behaves as intended in
    all scenarios. Together, these tests help secure APIs against misuse and logical
    flaws.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will stay engaged with the advanced API topics, but we will
    learn why the business logic behind an API can impact the frequency and/or depth
    at which API endpoints are exploited. We will begin by dissecting what business
    logic is and how it may have vulnerabilities. Then, we will take a look at abuse
    scenarios, simulating environments where such logic can be explored in a bad way.
    Finally, using a method like the one we applied in [*Chapter 8*](B19657_08.xhtml#_idTextAnchor131),
    we will search for vulnerabilities in business logic. I hope you enjoy this journey.
    Let’s go on it together!
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding business logic vulnerabilities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring API abuse scenarios
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing for business logic vulnerabilities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ll leverage the same environment as the one pointed out in previous chapters,
    such as an Ubuntu distro. Some other new relevant utilities will be mentioned
    in the corresponding sections.
  prefs: []
  type: TYPE_NORMAL
- en: We will create more code in this chapter, which we’ll leverage to simulate and
    test some vulnerabilities, this time focused on business logic.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding business logic vulnerabilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To understand what types of vulnerabilities may arise from the business logic
    behind API endpoints and their applications, we first have to understand what
    business logic is. Well, it is nothing other than several processes, rules, and
    workflows that define how data can be processed by software. To reach specific
    business objectives, the software needs to handle interactions with the users,
    as well as transactions and data handling. In other words, it’s the implementation
    of business specificities into code.
  prefs: []
  type: TYPE_NORMAL
- en: Using web commerce as a common scenario, the business logic part of the application
    (that could also be represented by APIs and their endpoints) handles various tasks
    such as the maintenance of the shopping cart, the insertion of discount codes,
    all logistics activities (such as calculating shipping costs and estimated delivery
    time), and finally, the processing or transferring to a trusted third party of
    payments. The final purpose is to ensure that the application behaves as it was
    designed to, such that all phases are deterministic and not probabilistic. That’s
    a very important point to remember.
  prefs: []
  type: TYPE_NORMAL
- en: 'If it is not yet obvious, you could ask why business logic is so important.
    Well, it does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Maintains integrity and efficiency**: It guarantees that the application
    operates smoothly and handles data with integrity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Converts business rules**: By following some methodologies, business policies
    and rules are translated into lines of code. This allows the application to perform
    tasks such as validating user input, enforcing security measures, managing data
    flow, and complying with regulations. Imagine a banking application – its business
    logic would enforce rules around transaction limits, account access, and fraud
    detection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Automates processes**: By encapsulating these rules within the application,
    businesses can automate complex tasks, reduce errors, and ensure consistent execution
    of business activities.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Impacts reliability and security**: Robust business logic directly affects
    the software’s reliability, security, and ultimately, user satisfaction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In simple terms, business logic is the software’s rulebook, making sure it runs
    efficiently and fulfills the specific needs of the business it serves.
  prefs: []
  type: TYPE_NORMAL
- en: 'Nice! Now that we have established some groundwork on the subject, we can talk
    about the vulnerabilities that may affect it. They can usually bypass traditional
    security measures such as firewalls and **Intrusion Detection Systems** (**IDSs**),
    and they are dangerous for the following reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: Their target is the core business.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are difficult to detect and block.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are some methods to cause errors in business logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Workflow tampering**: With this, we change the sequence of operations to
    overcome security protections or to obtain unauthorized access.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Validation bypass**: With this, we look for ways to skip or manipulate some
    validations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Inconsistent error handling**: In this, we identify patterns in error messages
    that could possibly leak sensitive data or the API behavior.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Escalate privileges**: In this, through the leverage of some failure in the
    API’s code or some system supporting it, we gain higher levels of access.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Concurrency issues**: APIs that implement concurrency may be vulnerable to
    this, where we can exploit race conditions or failures in logic synchronization.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Manipulate transactions**: Through this, we directly interfere with the logic’s
    operations to impose inconsistencies or to obtain some benefit, usually financial.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There were some notable incidents that deserve mention to illustrate how API
    business logic’s vulnerabilities can cause devastating damage to companies. You
    will find links with more information about all of them in the *Further reading*
    section. In April 2021, an independent security researcher discovered a vulnerability
    in an API used by **Experian** to assess individuals’ creditworthiness. This API
    used minimal authentication information, making it easy to exploit. Attackers
    could retrieve sensitive personal data, including **Fair Isaac Corporation** (**FICO**)
    scores and credit risk factors, using easily obtainable public information. This
    incident highlighted the risks of weak authentication and excessive data exposure.
  prefs: []
  type: TYPE_NORMAL
- en: In the same month and year, security researchers from the **Sick Codes** security
    firm uncovered vulnerabilities in John Deere’s APIs, which allowed them to access
    user accounts and sensitive data without authentication. John Deere is a global
    company that produces agricultural, construction, and forestry equipment and solutions.
    The researchers were able to identify customers of John Deere, including major
    Fortune 1,000 companies, and retrieve personal data associated with their equipment.
    The lack of rate limiting and authentication controls in these APIs posed significant
    security risks.
  prefs: []
  type: TYPE_NORMAL
- en: In December 2021, hackers exploited a vulnerability in the X (which was still
    called Twitter at the time) API to access the personal data of over 5.4 million
    users. By submitting email addresses or phone numbers to the API, attackers could
    retrieve the associated accounts. This breach exposed usernames, phone numbers,
    and email addresses, significantly affecting user trust and confidence in X.
  prefs: []
  type: TYPE_NORMAL
- en: Again in December 2021, FlexBooker, a social media scheduling platform, experienced
    an API breach that exposed 3.7 million user records. The breach, caused by vulnerabilities
    in their AWS configuration, led to the download of sensitive user data and system
    downtime. The breach stemmed from flaws in how FlexBooker configured its access
    controls on AWS, which can be seen as a business logic issue related to API security.
    The exposed user data resided within FlexBooker’s system, likely accessed through
    a compromised API. This incident underscores the importance of securing API endpoints
    and storage systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'In January 2022, the **Texas Department of Insurance** had an API endpoint
    publicly exposed (for nearly three years) due to a software error. This breach
    exposed 1.8 million records containing Social Security numbers, addresses, and
    other personal information. There were two problems: a vulnerable web application,
    and data that was exposed. This vulnerability resided within the application’s
    code, suggesting a problem with business logic implementation. Among the exposed
    data, there were names, Social Security numbers, addresses, dates of birth, and
    details of claims. The incident highlighted the importance of continuous monitoring
    and proper configuration of API endpoints to protect sensitive data.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have covered what API business logic is and the problems that may
    be caused as part of API vulnerabilities, let’s learn how we can abuse APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring API abuse scenarios
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'API abuse is related to the unexpected use of an API in a way that deviates
    from its intended purpose or project/design. This can naturally uncover security
    vulnerabilities, which in turn can cause data breaches and/or service interruptions.
    Some common ways of abusing an API include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Credential stuffing**: By using stolen credentials, access to the API is
    gained.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data scraping**: Consists of exfiltrating large volumes of data from an API,
    which usually violates terms of service or its privacy policies.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Endpoint discovery**: It’s accomplished with the use of automation tools
    to discover and exploit “hidden” (forgotten or undocumented) API endpoints.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mass assignment**: You send unexpected data fields to the endpoint to manipulate
    internal object properties.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Parameter tampering**: Consists of changing API parameters to be able to
    access data or features that would be denied or restricted by default.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rate limiting violations**: Done by exceeding the maximum number of allowed
    requests per unit of time, which usually leads to DoS attacks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have theoretically and practically covered some of the aforementioned methods.
    Let’s dive deeper into the ones that are completely new. For each method, we will
    have a dummy API written in Python and the steps that you may follow to accomplish
    the attack.
  prefs: []
  type: TYPE_NORMAL
- en: Credential stuffing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is a universal type of attack whereby criminals use a large database of
    stolen or leaked credentials to attempt to gain unauthorized access to user accounts
    that are accessible via API endpoints. The main intent here is to leverage what
    many human beings do in their daily lives: reusing the same password throughout
    various systems and websites. Criminals make use of automated tools to help them
    speed up these attacks. It is possible to generate millions of attempts in short
    periods of time. This is not the same as brute force attacks, wherein you need
    to generate random passwords and sometimes usernames or read them from dictionary
    files, or even rainbow tables (when the targets are hashes). Credential stuffing
    does use actual usernames and passwords.'
  prefs: []
  type: TYPE_NORMAL
- en: The damage of such attacks is based on their capability to overcome basic security
    countermeasures. Once valid credentials pairs are presented, if the protection
    mechanisms are based only on password length and complexity, they can easily be
    bypassed. They are especially dangerous to applications that deal with sensitive
    data since even small breaches can cause severe damage to the company’s reputation.
  prefs: []
  type: TYPE_NORMAL
- en: On the subject of reputation, credential stuffing also imposes a reasonable
    economic impact. Research from the **Ponemon Institute** ([https://ag.ny.gov/publications/business-guide-credential-stuffing-attacks](https://ag.ny.gov/publications/business-guide-credential-stuffing-attacks))
    concluded that the average cost of this type of attack is around USD $6 million,
    including the expenses of incident response, customer notification, compliance,
    and regulatory fines. That’s without accounting for reputation. This is enough
    to bankrupt many small companies. To mitigate such threats, robust security measures
    need to be applied such as **Multi-Factor Authentication** (**MFA**), **User Entity
    and Behavior Analytics** (**UEBA**), and anomaly detection (nowadays, this is
    usually implemented with a **Machine Learning** (**ML**) solution).
  prefs: []
  type: TYPE_NORMAL
- en: Creating the dummy target
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Credential stuffing is usually implemented with automated tools, such as **Sentry
    MBA**, **Snipr**, or **OpenBullet**. We will apply **OpenBullet 2** ([https://github.com/openbullet/OpenBullet2](https://github.com/openbullet/OpenBullet2)),
    a superset of the initial version, to implement our attack. For that sake, the
    following dummy API will be used as a target. This code is available at [https://github.com/PacktPublishing/Pentesting-APIs/blob/main/chapters/chapter09/credential_stuffing/api_credential.py](https://github.com/PacktPublishing/Pentesting-APIs/blob/main/chapters/chapter09/credential_stuffing/api_credential.py):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Observe that the API has a single endpoint, to deal with the login process.
    It also has a function that applies a basic rate-limiting control. When the number
    of failed attempts is greater than or equal to five in one minute, the request
    is denied. There are only two dummy users. As we did not actually steal any credentials,
    we will create a file with other dummy usernames and passwords, including the
    ones present in the API. The purpose here is just to show that this logic is vulnerable
    to credential stuffing.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will run this API as a Docker container since, as you’ll see next, our attack
    tool will also run like that. This is not exactly required. You could also run
    the Python code directly on your host system. However, to be able to access its
    5000/TCP port from a container, you’d have to tweak the container’s network a
    bit, since this communication might not be allowed at first depending on the Docker
    version you are using. To keep it safe, it’s easier to simply run both software
    as containers. If you don’t specify anything different while starting up the container
    or in its `Dockerfile`, they will both share the same Docker network (the `bridge`
    one):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Great! So, to run this Python code as a Docker container, we need a `Dockerfile`
    file. The following content is just a suggestion. You are free to use any other
    container image that includes Python. I just recommend that you choose a light
    one to keep it small. For your convenience, this Dockerfile can be downloaded
    from [https://github.com/PacktPublishing/Pentesting-APIs/blob/main/chapters/chapter09/credential_stuffing/Dockerfile](https://github.com/PacktPublishing/Pentesting-APIs/blob/main/chapters/chapter09/credential_stuffing/Dockerfile):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The `requirements.txt` file that’s mentioned twice is a single-line file containing
    only `Flask`. I’m not sure about your Docker knowledge. So, let me give you a
    brief explanation here. This Dockerfile will expose `port 5000` (enabling other
    containers and the host itself to connect to it through this port), install Flask,
    and copy all of the current directory’s contents (including the `api_credential.py`
    Python file itself) to the container’s current directory (which is `/app`). Then,
    it will run the application. To put this container to work, type the following
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The first command parses the `Dockerfile`, downloads the specified image, tags
    it as `api`, and follows the rest of the contents to finish building such an image.
    The second command effectively runs the container by mapping the host’s `port
    5000` to the container’s `port 5000`, naming it `credential_api`, and picking
    the previously built `api` image. Now we are good to move to the attack tool.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up OpenBullet2
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'OpenBullet2 has a native client for Windows. As we are not using this operating
    system, we will go with the other option: the web client. There is more than one
    path to install this second way. You can first install Microsoft’s .NET runtime
    environment, download OpenBullet2 (which includes Windows’ DLL files), and then
    use .NET to run it. This may impose some difficulties depending on the system
    you are using. On Ubuntu, I personally prefer to take the Docker approach. You
    just need to create a directory that the container will use to store configurations
    and attacks’ captured data, and then run the following command (which is in the
    product’s documentation):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In this case, I specified a local `UserData` directory under my current directory
    that will be mounted on the container as `/app/UserData` volume (the `-v` option
    means volume). This command names the container `openbullet2` (`--name`) and runs
    it in interactive mode (`-it`), which is good to allow you to watch eventual log
    messages. The container listens on port 5000, which is mapped to the host’s port
    8069\. The container will be removed after you close it (`--rm`). Just open `http://localhost:8069`
    on your preferred browser, and you will see the utility’s interface (*Figure 9**.1*).
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1 – OpenBullet2’s initial screen](img/B19657_figure_09.01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.1 – OpenBullet2’s initial screen
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'While conducting the tests with OpenBullet2, I wasted a reasonable amount of
    time trying to understand why my attacks were not working. I’m not sure whether
    it was some bug with the version I used. The truth is that the following helped
    me fix it and put the utility to work as expected. You are good to skip this note
    and keep reading the rest of the section, but if at some stage you face errors
    such as `UserData` local directory. You’ll realize that the tool creates several
    files and directories. The only one that’s important at this moment is `Environment.ini`.
    Check its permissions and grant write permission if it doesn’t have it yet. Edit
    it and change the `WORDLIST TYPE` Default block to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: What we are doing here is instructing OpenBullet2 to use a colon (`:`) as a
    field separator, as well as to name the left part of such a colon `USERNAME` and
    the right part `PASSWORD`. This shouldn’t be the case, but it made a tremendous
    change to my environment. Save the file and run the container again as you did
    the first time. Now continue reading.
  prefs: []
  type: TYPE_NORMAL
- en: When you click on the flag, other flags and languages are presented. When this
    chapter was being written, a total of twelve languages were available! After clicking
    on your preferred language/flag, the license will be presented, and you just need
    to accept it. Also, the first time the application is running, an initial setup
    is necessary (*Figure 9**.2*).
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.2 – The initial setup](img/B19657_figure_09.02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.2 – The initial setup
  prefs: []
  type: TYPE_NORMAL
- en: We are setting it up to run locally. Then, just click on the corresponding button.
    You also have the option to set OpenBullet2 to run on a remote host. After selecting
    the option, the setup will be finished. You will see the dashboard, which shows
    an interesting number of options and general usage statistics, including CPU,
    memory, and network consumption. Do not waste too much time on the screen shown
    in *Figure 9**.2*, as we must focus on the attack.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a configuration and attacking
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We will start the attack by creating a configuration. Follow this sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: Click on **Configs** on the left pane bar.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the new screen, click on **New**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This will take you to a form where you can enter some metadata such as the config’s
    author, its name, and a graphical image located in a file or URL. This is the
    metadata part of the configuration. The other options are **Readme**, **Stacker**,
    **LoliCode**, **Settings**, and **C# Code**. It’s important to note that you can
    put C# code as part of the configuration. It will be executed by OpenBullet2 as
    part of the attack. When starting, the application logs a warning message to notify
    you that you shouldn’t run it as administrator or root due to the fact that binary
    code will be executed, and such code can bypass your host system’s security controls.
    *Figure 9**.3* shows OpenBullet2’s dashboard.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.3 – The OpenBullet2 dashboard Screen](img/B19657_figure_09.03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.3 – The OpenBullet2 dashboard Screen
  prefs: []
  type: TYPE_NORMAL
- en: The next figure shows the config’s metadata screen.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.4 – The metadata part of the configuration](img/B19657_figure_09.04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.4 – The metadata part of the configuration
  prefs: []
  type: TYPE_NORMAL
- en: Just write a name for the configuration itself and an author name. Leave the
    rest as its defaults. *Figure 9**.5* shows the warning message when you start
    the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.5 – The startup warning message](img/B19657_figure_09.05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.5 – The startup warning message
  prefs: []
  type: TYPE_NORMAL
- en: 'Before continuing with the configuration, we need to recall that both OpenBullet2
    and the API are running as containers. This means that they have received IP addresses
    belonging to Docker’s bridge network. The IP segment may change according to the
    Docker engine version and the system you are running, so you need to check which
    addresses were assigned to them. The host usually picks the first address of the
    block. In my case, which looks like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: $ docker inspect -f \
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '''{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}'' credential_api'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 172.17.0.3). Let’s get back to our process.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you want to create some text to describe what it is about, which is useful
    when more people are using the same instance, you can go to the **Readme** section
    and write some instructions there. Now click on **Stacker**. There, we can tell
    OpenBullet2 how the attack must be carried out. You will see that the stack is
    currently empty.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the green plus sign to create a new stack config. This will open the
    **Add** **block** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Requests** | **Http** | **Http Request** (*Figure 9**.6*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.6 – Inserting an HTTP request block to the stack config](img/B19657_figure_09.06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.6 – Inserting an HTTP request block to the stack config
  prefs: []
  type: TYPE_NORMAL
- en: 'You are back to the stack config screen where all of the request’s details
    can be edited. We’ll have to change the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Set `URL` to `http://172.17.0.2:5000/login` (recall that the API’s endpoint
    is `/login`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the `POST`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Under `Content-Type: application/json`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Under **Content**, type what you want to send as the request’s body. It will
    consist of a simple JSON structure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `<input.USERNAME>` and `<input.PASSWORD>` parts will be replaced by lines
    in the `credentials.txt` file that we will create later.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When reading a wordlist (you’ll see this later on), OpenBullet2 will iteratively
    pick each line of the `credentials.txt` file and consider the left part of the
    colon as `input.USERNAME` and the right part as `input.PASSWORD`. The dynamically
    built JSON string will then be sent to the API endpoint as login information.
    This will provide you with something like *Figure 9**.7*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.7 – Configuring the attack HTTP request](img/B19657_figure_09.07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.7 – Configuring the attack HTTP request
  prefs: []
  type: TYPE_NORMAL
- en: We must analyze what the API is sending us as a response. Hence, we need to
    add another block. Click on the green plus sign again to add a new block. You
    won’t see it at first. Type **key** into the search bar and press **Search**.
    Select the **Keycheck** block (*Figure 9**.8*).
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.8 – Adding a Keycheck control block](img/B19657_figure_09.08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.8 – Adding a Keycheck control block
  prefs: []
  type: TYPE_NORMAL
- en: 'You will be sent back to the stack config screen. Do this to finish the request
    config:'
  prefs: []
  type: TYPE_NORMAL
- en: Click on the other green plus sign that is available under the **Keychains:**
    string.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure that **Result Status** is set as **SUCCESS**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **+String** button. This will open a few text boxes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Contains** on the combo box and type **Login successful** in the textbox
    right beside it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Repeat *steps 1* to *4* but with the following changes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For `Invalid credentials`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: You will see something like *Figure 9**.9*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.9 – Configuring the expected successful and failed responses.](img/B19657_figure_09.09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.9 – Configuring the expected successful and failed responses.
  prefs: []
  type: TYPE_NORMAL
- en: 'Save the config using the `credentials.txt` and insert the following contents.
    For your convenience, this file can be downloaded from [https://github.com/PacktPublishing/Pentesting-APIs/blob/main/chapters/chapter09/credential_stuffing/credentials.txt](https://github.com/PacktPublishing/Pentesting-APIs/blob/main/chapters/chapter09/credential_stuffing/credentials.txt):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will put actual credentials that, in our case, are hardcoded into the API’s
    application among other useless values. Back to the utility’s interface, do the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: Click on **Wordlists** on the left pane.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On this new screen, click on **+Add**. This will open a new window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change **My Wordlist** to **Credentials**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the `credentials.txt` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Upload** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Your wordlist-adding screen will look like *Figure 9**.10*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.10 – Adding a wordlist](img/B19657_figure_09.10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.10 – Adding a wordlist
  prefs: []
  type: TYPE_NORMAL
- en: You will be taken back to the wordlists screen, and you’ll see the one you just
    added with the number of parsed lines (five). The next step we need to follow
    is to create a job to combine the configuration and the wordlist to actually send
    packets to the API. Click on **Jobs** on the left pane. On this screen, click
    on the green **+New** button to add a job. Click on the **Multi Run** button.
    At this stage, it’s important for you to know that you can leverage proxy serves
    to split the requests. OpenBullet2 comes with an empty **Default** proxy group.
    You can go to the **Proxies** area and either manually add their URLs or import
    them, either via URLs or text files. We won’t use proxies in our example.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Select Config** button. This will open a window showing all configs
    you have saved. As we only save the one we just created, click on it and push
    **Select** (*Figure 9**.11*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.11 – Selecting the config to be part of the job](img/B19657_figure_09.11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.11 – Selecting the config to be part of the job
  prefs: []
  type: TYPE_NORMAL
- en: After selecting it, you will be back to the job definition screen that’s now
    updated with the selected config. Click on the **Select wordlist** button located
    on the right of this screen. This will open another window will all the saved
    wordlists you have. As you have only added a single wordlist, it will be the only
    one showing up. Observe that, once you select the wordlist you’d like to add to
    the job, its contents will be displayed on the bottom part of this window. This
    is good to do a final visual check and attest whether they are as expected. Click
    on the green **Select** button (*Figure 9**.12*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.12 – Adding a wordlist to the job](img/B19657_figure_09.12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.12 – Adding a wordlist to the job
  prefs: []
  type: TYPE_NORMAL
- en: We are back to the job definition screen. Scroll down the screen a little bit
    until you see the green **Create Job** button. Push it. If you have done something
    wrong with the job, you can change the job definition by clicking on the corresponding
    button. Otherwise, you can shoot the job with the **Start** button. Do it! As
    our wordlist is small and we are running everything locally, the job will finish
    quickly. All valid credentials (**Hits**) are located under the control buttons.
    **Fails** and skipped lines also have their stats lines (*Figure 9**.13*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.13 – The results after running an attack job; valid credentials
    are shown in green](img/B19657_figure_09.13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.13 – The results after running an attack job; valid credentials are
    shown in green
  prefs: []
  type: TYPE_NORMAL
- en: Now that this lab is complete, let’s learn more about other important topics.
  prefs: []
  type: TYPE_NORMAL
- en: Other features and security recommendations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: OpenBullet2 has many other features that can be useful depending on the pentesting
    scenario you are facing. It suffered a revamp since the initial version and now
    has the web client option, which is quite handy when the testing system is not
    Windows. By the way, OpenBullet was initially designed and built as a .NET application.
  prefs: []
  type: TYPE_NORMAL
- en: To get protected against credential stuffing, APIs should apply MFA. Rate limiting
    adds another protection layer since it reduces the impact of automated tools (such
    as OpenBullet2) carrying out too many login attempts in a specific timeframe.
    Finally, anomaly detection solutions, especially nowadays with the rich feature
    sets enabled by **Artificial Intelligence** (**AI**) and ML, are worth considering
    because they can track and analyze multiple different types of evidence at the
    same time, such as unusual login patterns, multiple failures from different geographic
    locations (something that can occur when you apply proxies), and notification
    of sysadmins based on some thresholds. In the next section, we will explore data
    scraping.
  prefs: []
  type: TYPE_NORMAL
- en: Data scraping
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Data scraping consists of extracting data from websites or APIs in an automated
    way, usually without proper authorization. It’s not always criminal though. You
    can be conducting research and need to aggregate publicly available data; this
    is legitimate. Nonetheless, it becomes a real problem when the target is private
    or sensitive data. APIs handling data exchanges between multiple systems may be
    particularly vulnerable to this threat since they can expose structured data using
    machine-readable formats, which makes the automated extraction even easier. With
    the large adoption of APIs, a part of which is driven by cloud providers, the
    attack surface has dramatically increased.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pentesters apply several tools and techniques to achieve success with this.
    The tools can vary from simple code written in Python or **Golang** to more sophisticated
    frameworks such as Scrapy, which we will exemplify in this section. Scrapy can
    handle very large data masses at once. Another notable example is **Selenium**,
    which is normally used to scrape dynamic content rendered by client-side JavaScript.
    The behavior is pretty much the same: these tools send requests to the API endpoints
    simulating human beings. These tools can be configured to adapt to different specificities
    presented by some endpoints, such as pagination, tokenization, rate limiting,
    and more. Being as adaptable and as human as this makes it easier for such tools
    to bypass some security countermeasures. One common evasion technique is switching
    source IP addresses (which can be accomplished with botnets) or employing proxy
    servers.'
  prefs: []
  type: TYPE_NORMAL
- en: Unauthorized data scraping can be extremely damaging for companies and organizations.
    They can lead to sensitive data thefts and/or leaks. Things such as user profiles,
    private datasets, financial records, intellectual property information, health
    records, or scholarly history are some examples of possible targets. Aside from
    financial and reputational damage, enterprises and their representatives can face
    legal outcomes, depending on the proportion of the leak and the nature of the
    leaked data. This can include trials and even imprisonment.
  prefs: []
  type: TYPE_NORMAL
- en: In the next sub-sections, you’ll create and run a dummy target API and write
    some code to attack it.
  prefs: []
  type: TYPE_NORMAL
- en: Raising the dummy target
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To practice data scraping, we will use the following GraphQL dummy API as a
    target. For your convenience, this code can be downloaded from [https://github.com/PacktPublishing/Pentesting-APIs/blob/main/chapters/chapter09/data_scraping/api_scraping.py](https://github.com/PacktPublishing/Pentesting-APIs/blob/main/chapters/chapter09/data_scraping/api_scraping.py):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Observe that the API establishes a basic authentication mechanism through a
    pair of credentials (`admin` and `password`). When they are successfully sent
    by the client, a JWT is created and sent back. The only available endpoint (`/graphql`)
    only works when a valid JWT is presented by the client (enforced by the `@jwt_required()`
    decorator). The data itself is the user database. It’s our target.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run the code, you’ll need to install a few other Python modules. To be safe,
    simply type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: You are good to put the API to run. Now, let’s focus on the attacking code.
  prefs: []
  type: TYPE_NORMAL
- en: Putting the attack to work
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First, you must install Scrapy with `pip`. Then, create a project and enter
    its directory with the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Since we need to authenticate first, part of the code is dedicated to performing
    multiple authentication attempts until a valid credential pair is found. There’s
    a class named `BruteForcespider`. Everything starts with the `start_requests()`
    method. This is specified by Scrapy’s spider definition (which will be explained
    later on), and it iterates through the hardcoded credential pairs. Every time
    a request is sent, the code calls the `parse_login()` method to analyze the result.
    When the token is present in a result, it means that the authentication was successful.
    So, the code executes the GraphQL query to request the user database. Finally,
    the `parse_users()` method is invoked to print the gathered data. The `bruteforce_spider.py`
    code can be found at [https://github.com/PacktPublishing/Pentesting-APIs/blob/main/chapters/chapter09/data_scraping/bruteforce_spider.py](https://github.com/PacktPublishing/Pentesting-APIs/blob/main/chapters/chapter09/data_scraping/bruteforce_spider.py).
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we can run the code, we must create a Scrapy project. This is accomplished
    with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'When created, the `graphqlscraper` project is represented by a directory where
    several other files are inserted as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The code is located inside the `spiders` subdirectory. To run it, type the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This instructs Scrapy to start a crawler whose class can be found inside the
    `bruteforce_spider.py` file. The output is sent to `users.json`. After a few seconds,
    you should receive the chatty output of Scrapy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: $ more graphqlscraper/spiders/users.json
  prefs: []
  type: TYPE_NORMAL
- en: '['
  prefs: []
  type: TYPE_NORMAL
- en: '{"ID": "1", "Name": "Alice", "Email": "alice@example.com"},'
  prefs: []
  type: TYPE_NORMAL
- en: '{"ID": "2", "Name": "Bob", "Email": "bob@example.com"},'
  prefs: []
  type: TYPE_NORMAL
- en: '{"ID": "3", "Name": "Charlie", "Email": "charlie@example.com"}'
  prefs: []
  type: TYPE_NORMAL
- en: ']'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: $ curl http://localhost:5000/api/user/1
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"id": 1,'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"name": "Alice",'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"email": "alice@example.com",'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"role": "user"'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'admin_secret) password to provide special access, we can manipulate the role
    parameter with a single request in Python and make *Alice* an administrator (this
    code can be downloaded from https://github.com/PacktPublishing/Pentesting-APIs/blob/main/chapters/chapter09/parameter_tampering/manipulate_role.py):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '{'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"message": "User role updated"'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: $ curl http://localhost:5000/api/user/1
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"id": 1,'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"name": "Alice",'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"email": "alice@example.com",'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"role": "admin"'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '/transaction one deals with financial information. To retrieve some data, we
    need to provide the transaction ID. We might infer the numerical sequence (how
    about 1?):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: import requests
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: data = {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '''transaction_id'': ''1'','
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '''status'': ''completed'','
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '''auth'': ''admin_secret'''
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: response = requests.post(
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '''http://localhost:5000/api/admin/update_status'', data=data'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: )
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: print(response.json())
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '{'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"message": "Transaction status updated"'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: $ curl http://localhost:5000/api/transaction/1
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"id": 1,'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"user_id": 1,'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"amount": 100,'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"status": "completed"'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '/admin/update_status endpoint without providing the corresponding password:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: import requests
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: data = {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '''auth'': ''admin_secret'''
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: response = requests.post(
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '''http://localhost:5000/api/admin/update_status'', data=data'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: )
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: print(response.json())
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '{'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"super_secret": "This is top secret data!"'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: $ safety scan --target .
  prefs: []
  type: TYPE_NORMAL
- en: Please login or register Safety CLI (free forever) to scan and secure your projects
    with Safety
  prefs: []
  type: TYPE_NORMAL
- en: '(R)egister for a free account in 30 seconds, or (L)ogin with an existing account
    to continue (R/L): R'
  prefs: []
  type: TYPE_NORMAL
- en: Redirecting your browser to register for a free account. Once registered, return
    here to start using Safety.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the browser does not automatically open in 5 seconds, copy and paste this
    url into your browser:'
  prefs: []
  type: TYPE_NORMAL
- en: <<<A dynamic URL is presented here.>>>
  prefs: []
  type: TYPE_NORMAL
- en: '[=   ] waiting for browser authenticationupdate.go:85: cannot change mount
    namespace according to change mount (/var/lib/snapd/hostfs/usr/local/share/doc
    /usr/local/share/doc none bind,ro 0 0): cannot open directory "/usr/local/share":
    permission denied'
  prefs: []
  type: TYPE_NORMAL
- en: '[  ==] waiting for browser authenticationGtk-Message: 22:45:48.735: Not loading
    module "atk-bridge": The functionality is provided by GTK natively. Please try
    to not load it.'
  prefs: []
  type: TYPE_NORMAL
- en: Successfully registered address@domain.com
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Part 5: API Security Best Practices'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is the final part of the book. You have been learning how to discover,
    get information on, and attack APIs in different scenarios. Throughout the previous
    parts, vulnerable code has been presented to you with exploitable points in RESTful
    and GraphQL APIs. In this part, you will understand that a reasonable portion
    of security problems with APIs originate from bad coding practices. Knowing best
    practices is vital for securing APIs in a more appropriate way. When a pentester
    gets more acquainted with how the API code was written and which parts were ignored
    or forgotten by the developers, this can definitely help in the invasion journey.
  prefs: []
  type: TYPE_NORMAL
- en: 'This section contains the following chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 10*](B19657_10.xhtml#_idTextAnchor153), *Secure Coding Practices
    for APIs*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
