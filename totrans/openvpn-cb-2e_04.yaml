- en: Chapter 4.  PKI, Certificates, and OpenSSL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Certificate generation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'OpenSSL tricks: x509, pkcs12, verify output'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Revoking certificates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The use of CRLs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking expired/revoked certificates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Intermediary CAs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Multiple CAs: stacking, using the `capath` directive'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Determining which crypto library is used
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Crypto features of OpenSSL and PolarSSL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pushing ciphers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Elliptic curve support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is a small detour into the public key infrastructures (PKIs), certificates,
    and `openssl` commands. The primary purpose of the recipes in this chapter is
    to show how the certificates, which are used in OpenVPN, can be generated, managed,
    viewed, and what kind of interactions exist between OpenSSL and OpenVPN.
  prefs: []
  type: TYPE_NORMAL
- en: Certificate generation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will demonstrate how to create and sign a certificate request using
    plain `openssl` commands. This is slightly different from using the `easy-rsa`
    scripts, but very instructive.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Set up the `easy-rsa` certificate environment using the first recipe from [Chapter
    2](part0025.xhtml#aid-NQU21 "Chapter 2.  Client-server IP-only Networks"), *Client-server
    IP-only Networks*, by sourcing the `vars` file. This recipe was performed on a
    computer running Fedora 22 Linux but it can easily be run on Windows or MacOS.
    Note that the `easy-rsa` package can be downloaded independently of OpenVPN itself.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we can use plain `openssl` commands to generate and sign a request, there
    are a few environment variables that need to be set. These variables are not set
    in the `vars` file by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the missing environment variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that the `openssl-1.0.0.cnf` file is part of the easy-rsa distribution
    and should already be present in the directory `/etc/openvpn/cookbook`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, we generate the certificate request without a password. This is achieved
    by adding the option `-nodes` to the `openssl req` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we sign the certificate request using the Certificate Authority private
    key:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first step is always to generate a private key. In this recipe, we generate
    a private key without a password, which is not really secure. A certificate request
    is signed using the private key to prove that the certificate request and the
    private key belong together. The `openssl req` command generates both the private
    key and the certificate requests in one go.
  prefs: []
  type: TYPE_NORMAL
- en: The second step is to sign the certificate request using the private key of
    the **Certificate Authority** (**CA**). This results in an X.509 certificate file,
    which can be used in OpenVPN.
  prefs: []
  type: TYPE_NORMAL
- en: A copy of the (public) X.509 certificate is also stored in the `/etc/openvpn/cookbook/keys`
    directory. This copy is important if the certificate needs to be revoked later
    on, so do not remove it from that directory.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is also possible to generate a private key protected by a password ("pass
    phrase" in OpenSSL terms). In order to generate such a private key, simply remove
    the `-nodes` command line parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The OpenSSL command will now ask for a passphrase:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Setting up the public and private keys* recipe from [Chapter 2](part0025.xhtml#aid-NQU21
    "Chapter 2.  Client-server IP-only Networks"), *Client-server IP-only Networks*,
    where the initial setup of the PKI using the `easy-rsa` scripts is explained
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OpenSSL tricks - x509, pkcs12, verify output
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The OpenSSL commands may seem daunting at first, but there are a lot of useful
    commands in the OpenSSL toolbox for viewing and managing X.509 certificates and
    private keys. This recipe will show how to use a few of those commands.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Set up the `easy-rsa` certificate environment using the first recipe from [Chapter
    2](part0025.xhtml#aid-NQU21 "Chapter 2.  Client-server IP-only Networks"), *Client-server
    IP-only Networks*, by sourcing the `vars` file. This recipe was performed on a
    computer running Fedora 22 Linux but it can easily be run on Windows or MacOS.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this recipe, we need to perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To view the subject and expiry date of a given certificate, type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To export a certificate and private key in `PKCS12` format:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that the `chmod 600` ensures that the PKCS12 file is readable only by the
    user.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Verify the purpose of a given certificate:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Notice the error if we select the wrong purpose (`sslclient` versus `sslserver`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Change the password (passphrase) of a certificate:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The OpenSSL toolkit consists of a wide range of commands to generate, manipulate,
    and view X.509 certificates and their corresponding private keys. The commands
    in this chapter are but a small subset of the available commands. On Linux and
    UNIX systems, you can use `openssl -h` and the manual pages for `x509`, `pkcs12`,
    and `req` for more details. The manual pages are also available online at [http://www.openssl.org/docs/apps/openssl.html](http://www.openssl.org/docs/apps/openssl.html).
  prefs: []
  type: TYPE_NORMAL
- en: Click on the OpenSSL commands lower down in the list of all commands for direct
    pointers.
  prefs: []
  type: TYPE_NORMAL
- en: Revoking certificates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A common task when managing a PKI is to revoke certificates that are no longer
    needed or that have been compromised. This recipe demonstrates how certificates
    can be revoked using the `easy-rsa` script and how OpenVPN can be configured to
    make use of a **Certificate Revocation List** (**CRL**).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Set up the client and server certificates using the first recipe from [Chapter
    2](part0025.xhtml#aid-NQU21 "Chapter 2.  Client-server IP-only Networks"), *Client-server
    IP-only Networks*. This recipe was performed on a computer running CentOS 6 Linux,
    but it can easily be run on Windows or Mac OS.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we generate a certificate:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we immediately revoke it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will also update the CRL list. The CRL can be viewed using the command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A CRL contains a list of certificate serial numbers that have been revoked.
    Each serial number can be handed out by a CA only once, so this serial number
    is unique to this particular CA. The CRL is signed using the CA's private key,
    ensuring that the CRL is indeed issued by the appropriate party.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The question "what exactly is needed to revoke a certificate" is often asked,
    so the following section goes a bit deeper into this.
  prefs: []
  type: TYPE_NORMAL
- en: What is needed to revoke a certificate
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In order to revoke a certificate, the certificate subject ("DN") is required
    as well as the certificate serial number. If a certificate is lost, then it is
    simply not possible to revoke it. This shows how important it is to do proper
    PKI management, including backing up the certificates that have been handed out
    to users.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next recipe, *The use of CRLs*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The recipe later in this chapter, *Multiple CA''s: stacking, using the -capath directive*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The use of CRLs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This recipe shows how to configure OpenVPN to use a CRL. It uses the CRL created
    in the previous recipe. This recipe is an extension of the recipe *Routing: masquerading*
    in [Chapter 2](part0025.xhtml#aid-NQU21 "Chapter 2.  Client-server IP-only Networks"), *Client-server
    IP-only Networks*, in the sense that the server and client configuration files
    are almost identical.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Set up the client and server certificates using the first recipe from [Chapter
    2](part0025.xhtml#aid-NQU21 "Chapter 2.  Client-server IP-only Networks"), *Client-server
    IP-only Networks*. Generate the CRL using the previous recipe. For this recipe,
    the server computer was running CentOS 6 Linux and OpenVPN 2.3.10\. The client
    was running Fedora 22 Linux and OpenVPN 2.3.10\. Keep the server configuration
    file `basic-udp-server.conf` from the *Server-side routing* recipe in [Chapter
    2](part0025.xhtml#aid-NQU21 "Chapter 2.  Client-server IP-only Networks"), *Client-server
    IP-only Networks*.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Copy the generated CRL to a more public directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Modify the server config file `basic-udp-server.conf` by adding the lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save it as `example4-6-server.conf`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Start the server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, create the client configuration file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: And save it as `example4-6-client.conf`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, start the client:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The client will not be able to connect but instead, the server log file shows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This rather cryptic message proves that the client is not allowed to connect
    because the certificate is not valid.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each time a client connects to the OpenVPN server, the CRL is checked to see
    whether the client certificate is listed. If it is, the OpenVPN server simply
    refuses to accept the client certificate and the connection will not be established.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Generating a CRL is one thing and keeping it up-to-date is another. It is very
    important to ensure that the CRL is kept up-to-date. For this purpose, it is best
    to set up a cron job that updates the server CRL file overnight. There is an outstanding
    bug in OpenVPN related to CRL updates: each time a client connects, the OpenVPN
    server tries to access the CRL file. If the file is not present or not accessible,
    then the OpenVPN server process aborts with an error. The proper behavior would
    be to temporarily refuse access to the clients but unfortunately, this is not
    the case.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The recipe later in this chapter, *Multiple CAs: stacking, using the -capath
    directive*, in which a more advanced use of CA and CRL is explained'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking expired/revoked certificates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The goal of this recipe is to give an insight into some of the internals of
    the OpenSSL CA commands. We will show how a certificate's status is changed from
    "Valid" to "Revoked", or "Expired".
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Set up the client and server certificates using the first recipe from [Chapter
    2](part0025.xhtml#aid-NQU21 "Chapter 2.  Client-server IP-only Networks"), *Client-server
    IP-only Networks*. This recipe was performed on a computer running CentOS 6 Linux
    but it can easily be run on Windows or Mac OS.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we can use plain `openssl` commands, there are a few environment variables
    that need to be set. These variables are not set in the `vars` file by default:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can query the status of a certificate using its serial number:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This shows that our OpenVPN server certificate is still valid.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The certificate we revoked in the *Revoking certificates* recipe, shows the
    following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If we look at the file `index.txt` in the `/etc/openvpn/cookbook/keys` directory,
    we see:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we modify this file using a normal text editor and replace the `R` with
    an `E` and we blank out the third field `160422155408Z` with spaces. This field
    is the timestamp when the certificate was revoked. The second line now becomes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, if we check the status again we get:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If we generate the CRL again, we see that the certificate has been "un-revoked":'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The OpenSSL `ca` command generates its CRL by looking at the `index.txt` file.
    Each line that starts with an `R` is added to the CRL, after which the CRL is
    cryptographically signed using the CA private key.
  prefs: []
  type: TYPE_NORMAL
- en: By changing the status of a revoked certificate to `E` or even `V` we can unrevoke
    a certificate.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we changed a certificate from `Revoked` to `Expired`. This will
    allow the client from the previous recipe to connect again to the server, as the
    certificate is still valid. The main reason to change a certificate from `Valid`
    to `Expired` in the `indext.txt` file is to allow us to generate and hand out
    a new certificate using the exact same name.
  prefs: []
  type: TYPE_NORMAL
- en: Intermediary CAs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe shows how to set up an intermediary CA and how to configure OpenVPN
    to make use of an intermediary CA. The OpenVPN `easy-rsa` scripts also include
    functionality to set up an intermediary CA. The advantage of an intermediary CA
    (or sub CA) is that the top-level CA (also known as the root CA) can be guarded
    more closely. The intermediary CAs can be distributed to the people responsible
    for generating the server and client certificates.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Set up the client and server certificates using the first recipe from [Chapter
    2](part0025.xhtml#aid-NQU21 "Chapter 2.  Client-server IP-only Networks"), *Client-server
    IP-only Networks*. This recipe was performed on a computer running CentOS 6 Linux
    but it can easily be run on Windows or Mac OS.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we create the intermediary CA certificate:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Verify that this certificate can indeed act as a Certificate Authority:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we create a new `keys` directory for our intermediary CA (the current
    directory is still `/etc/openvpn/cookbook`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Edit the `vars` file in the new directory and change the `EASY_RSA` line to:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Source this new `vars` file and set up the `keys` directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we are ready to create our first intermediary certificate:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Verify that the certificate has the new Intermediary CA as its issuer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And finally, we verify that the certificate is indeed a valid certificate.
    In order to do this we need to "stack" the root CA (public) certificate and the
    intermediary CA certificate into a single file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The intermediary CA certificate has the "right" to act as a certificate authority,
    meaning that it can sign new certificates itself. The intermediary CA needs a
    directory structure for this, which is very similar to the root CA directory structure.
    First, we set up this directory structure and then we copy over all the necessary
    files. After that we create a client certificate and verify that it is a valid
    certificate. In order to perform this validation, the entire certificate chain
    from the root-level CA to the intermediary CA to the client certificate need to
    be present. This is why the root CA public certificate and the intermediary CA
    public certificate are stacked into a single file. This single file is then used
    to perform the entire certificate chain validation.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Certificates that have been issued by an intermediary CA also need to be revoked
    by the same CA. This means that with multiple CAs you will also have to use multiple
    CRLs. Fortunately, CRLs can be stacked just like CA certificates: concatenate
    the files together using the `cat` command, as will be explained in the next recipe.'
  prefs: []
  type: TYPE_NORMAL
- en: Multiple CAs - stacking, using the capath directive
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The goal of this recipe is to create an OpenVPN setup where the client certificates
    are signed by a "client-only" CA and the server certificate is signed by a different
    "server-only" CA. This provides an extra level of operational security, where
    one person is allowed to create only client certificates, whereas another is allowed
    to generate only a server certificate. This ensures that the client and server
    certificates can never be mixed for a Man-in-the-Middle attack.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Set up the server certificate using the first recipe from [Chapter 2](part0025.xhtml#aid-NQU21
    "Chapter 2.  Client-server IP-only Networks"), *Client-server IP-only Networks*.
    Use the client certificate and the intermediary CA certificate from the previous
    recipe. For this recipe, the server computer was running CentOS 6 Linux and OpenVPN
    2.3.10\. The client was running Fedora 22 Linux and OpenVPN 2.3.10.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create the server configuration file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save it as `example4-9-server.conf`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Start the server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, create the client configuration file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save it as `example4-9-client.conf`. Note that we did not specify the `ca+subca.pem`
    file in the client configuration.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Start the client:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the server log files, you can now see the client connecting using the certificate
    that was created by the Intermediary CA:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the client connects to the server, the client (public) certificate is sent
    to the server for verification. The server needs to have access to the full certificate
    chain in order to do the verification; therefore, we stack the root CA certificate
    and the intermediary CA (or sub-CA) certificate together. This allows the client
    to connect to the server.
  prefs: []
  type: TYPE_NORMAL
- en: Vice versa, when the client connects, the server (public) certificate is also
    sent to the client. As the server certificate was originally signed by the root
    CA, we do not need to specify the full certificate stack here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that if we had forgotten to specify the `ca+subca.pem` file in the OpenVPN
    server configuration file, we would have received an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Apart from stacking the CA certificates, it is also possible to stack the CRLs
    or to use an entirely different mechanism to support multiple CA certificates
    and their corresponding CRLs.
  prefs: []
  type: TYPE_NORMAL
- en: Using the -capath directive
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Another way to include multiple CAs and CRLs in the OpenVPN server configuration
    is to use the following directive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'This directory needs to contain all CA certificates and CRLs using a special
    naming convention:'
  prefs: []
  type: TYPE_NORMAL
- en: All CA certificates must have a name equal to the hash of the CA certificate,
    and must end with `.0`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All CRLs must have a name equal to the hash of the CA certificate, and must
    end with `.r0`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For our root CA and intermediary CA, we can achieve this using the following
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'This hexadecimal number `bcd54da9` is the hash of the root CA certificate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, for the intermediary CA certificate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: When using many different CA certificates and corresponding CRLs, this method
    is far easier to manage than the "stacked" files.
  prefs: []
  type: TYPE_NORMAL
- en: Determining the crypto library to be used
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Starting with OpenVPN 2.3, it became possible to build OpenVPN using either
    the OpenSSL cryptographic library or the PolarSSL library. The PolarSSL library
    is nowadays known as "mbedTLS". The PolarSSL library is used in the OpenVPN Connect
    apps for both Android and iOS, but the library can be used on all other supported
    platforms as well.
  prefs: []
  type: TYPE_NORMAL
- en: The goal of this recipe is to show how to determine which cryptographic library
    is used, including the run-time version number.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Set up the server certificate using the first recipe from [Chapter 2](part0025.xhtml#aid-NQU21
    "Chapter 2.  Client-server IP-only Networks"), *Client-server IP-only Networks*.
    Use the client certificate and the intermediary CA certificate from the previous
    recipe. For this recipe, the computer was running Fedora 22 Linux and OpenVPN
    2.3.10, built both for OpenSSL and for PolarSSL. Keep the server configuration
    file `basic-udp-server.conf` from the *Server-side routing* recipe in [Chapter
    2](part0025.xhtml#aid-NQU21 "Chapter 2.  Client-server IP-only Networks"), *Client-server
    IP-only Networks*.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Start the regular version of OpenVPN using the standard configuration file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Check the first few lines of the server log file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Stop the server by killing the `openvpn` process.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, change the system''s `LD_LIBRARY_PATH` to point to a more recent version
    of OpenSSL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Check the first few lines of the server log file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Again, stop the server by killing the `openvpn` process.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Switch to the PolarSSL-built version of OpenVPN and start the server again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Check the first few lines of the server log file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When OpenVPN starts the cryptographics libraries are loaded and initialized.
    At this point, the library's version string is retrieved and printed. By using
    different builds of the crypto libraries we see that only the few first lines
    of the server logfile alter.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The type and build of cryptographics library used determine some of the more
    advanced features of OpenVPN, as we will see in the next few recipes. The library
    version string provides vital information for debugging a non-working setup, as
    we will see in [Chapter 6](part0071.xhtml#aid-23MNU1 "Chapter 6. Troubleshooting
    OpenVPN - Configurations"), *Troubleshooting OpenVPN - Configurations*.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next recipe, in which the differences between the cryptographic libraries
    is explained
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *How to read the OpenVPN log files* recipe, from [Chapter 6](part0071.xhtml#aid-23MNU1
    "Chapter 6. Troubleshooting OpenVPN - Configurations"), *Troubleshooting OpenVPN
    - Configurations*, which shows in detail how to read the OpenVPN log files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Crypto features of OpenSSL and PolarSSL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As stated in the previous recipe, it has been possible to build OpenVPN using
    either the OpenSSL cryptographic library or the PolarSSL library since version
    2.3\. In this recipe, we will show what some of the key differences between the
    two cryptographic libraries are.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Set up the server certificate using the first recipe from [Chapter 2](part0025.xhtml#aid-NQU21
    "Chapter 2.  Client-server IP-only Networks"), *Client-server IP-only Networks*.
    Use the client certificate and the intermediary CA certificate from the previous
    recipe. For this recipe, the computer was running Fedora 22 Linux and OpenVPN
    2.3.10, built both for OpenSSL and for PolarSSL.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Start the regular version of OpenVPN with the `--show-ciphers` option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'OpenVPN will now list all available ciphers, which can easily exceed 50 ciphers
    for OpenSSL 1.0+. The most common ciphers are:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, switch to the PolarSSL-built version of OpenVPN and re-run the same command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The list of ciphers now is:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Start the regular version of OpenVPN with the `--show-digests` option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'OpenVPN will now list all available HMAC algorithms, which can be specified
    using the `--auth` option. This list can easily exceed 25 entries, therefore only
    the most commonly used are printed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, switch to the PolarSSL-built version of OpenVPN and re-run the same command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The list of HMAC algorithms now is:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When OpenVPN starts the cryptographics libraries are loaded and initialized.
    Only at that point are the available encryption algorithms and HMAC algorithms
    known. Both OpenSSL and PolarSSL provide a mechanism for retrieving the list of
    available algorithms, which OpenVPN uses for both the `--show-ciphers` and the `--show-digests`
    options.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe shows that the PolarSSL/mbed-TLS library does not support all of
    the algorithms that OpenSSL does. When you need to support a PolarSSL-built version
    of OpenVPN (like the OpenVPN Connect clients for Android and iOS) then you can
    use only ciphers or digests (`--auth` parameter) which are supported by both crypto
    libraries.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Apart from the data channel cipher and HMAC algorithms, there is one more set
    of available algorithms that can be listed. This is the set of TLS algorithms
    that can be used for encrypting and authenticating the control channel. In order
    to list the set of TLS parameters, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: AEAD Ciphers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Starting with OpenVPN 2.4, a new set of ciphers is supported. These ciphers
    are known as **AEAD** ciphers, which stands for **Authenticated Encryption with
    Associated Data**. These ciphers combine encryption with authentication, thereby
    removing the need for a separate HMAC algorithm and thus providing increased performance.
    Both OpenSSL 1.0+ and mbed-TLS 1.3+ support these ciphers. With OpenVPN 2.4+,
    the list of ciphers will include:'
  prefs: []
  type: TYPE_NORMAL
- en: AES-128-GCM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AES-192-GCM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AES-256-GCM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encryption speed
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another major difference between OpenSSL and PolarSSL is the encryption/decryption
    speed of the algorithms. OpenSSL included hand-tuned assembly routines for maximum
    encryption speed, especially for the AES algorithms on newer Intel CPUs. However,
    the encryption speed is not the most important factor when determining the throughput
    of an OpenVPN network, as we will see in [Chapter 8](part0092.xhtml#aid-2NNJO1
    "Chapter 8. Performance Tuning"), *Performance Tuning*.
  prefs: []
  type: TYPE_NORMAL
- en: Pushing ciphers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another new feature of OpenVPN 2.4+ is the ability to "push" a cipher or HMAC
    algorithm from the server to the client. This makes it much easier to switch encryption
    or HMAC authentication algorithms, provided that all clients are using OpenVPN
    2.4\. This recipe provides a setup for explicitly pushing a cipher, as well as
    an explanation of the new cipher negotiation protocol.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe uses the PKI files created in the first recipe from [Chapter 2](part0025.xhtml#aid-NQU21
    "Chapter 2.  Client-server IP-only Networks"), *Client-server IP-only Networks*.
    For this recipe, the server computer was running CentOS 6 Linux and OpenVPN 2.4.0\.
    The client was running Fedora 22 Linux and OpenVPN 2.4.0\. For the server, keep
    the server configuration file `basic-udp-server.conf` from the *Server-side routing*
    recipe in [Chapter 2](part0025.xhtml#aid-NQU21 "Chapter 2.  Client-server IP-only
    Networks"), *Client-server IP-only Networks*. For the Windows client, keep the
    corresponding client configuration file `basic-udp-client.ovpn`, from the *Using
    an ifconfig-pool block* recipe in [Chapter 2](part0025.xhtml#aid-NQU21 "Chapter 2. 
    Client-server IP-only Networks"), *Client-server IP-only Networks*.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Modify the server configuration file, `basic-udp-server.conf`, by adding the
    following lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Then save it as `example4-10-server.conf`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Start the server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Start the client using the "standard" configuration file but with verbose logging:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The output showing that OpenVPN is now using an AES-256 cipher is shown in bold
    face.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Verify that we can reach the server using the `ping` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Pushing a cipher is now just as simple as pushing other OpenVPN options. Versions
    prior to 2.4 did not support this, however. This allows VPN administrators to
    change the encryption parameters used without having to modify all (remote) client
    configuration files.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Starting with OpenVPN 2.4 a new cipher negotiation protocol is introduced. At
    startup, the client and server will check whether both sides support the new GCM
    encryption protocols. The strongest cipher from this list is then chosen as the
    cipher. If no match is found, then OpenVPN reverts to the default BlowFish (BF-CBC)
    cipher, to ensure backward compatibility.
  prefs: []
  type: TYPE_NORMAL
- en: This feature can be tuned using the new directives `ncp-ciphers` and `disable-ncp`.
    The first directive specifies the list of ciphers to negotiate, whereas the second
    directive turns off cipher negotiation altogether.
  prefs: []
  type: TYPE_NORMAL
- en: When explicitly pushing a cipher from the server to the client you can only
    specify a cipher from the NCP cipher list. The default NCP cipher list is AES-256-GCM:AES-128-CGM:BF-CBC.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Future enhancements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It is expected that future enhancements of this new feature will be:'
  prefs: []
  type: TYPE_NORMAL
- en: A separate control channel HMAC algorithm so that you can switch the data channel
    algorithm independently
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ability to set a "per-client" encryption cipher, allowing you to support
    different ciphers for different platforms and clients
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Elliptic curve support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In version 2.4 of OpenVPN support was added for using **elliptic curve** (**EC**)
    certificates instead of the more common RSA type certificates. **Elliptic curve
    cryptography** (**ECC**) provides a fast method for encrypting and authenticating
    a secure connection, but are not widely used yet. In part, this is due to some
    patenting issues. As most modern OpenSSL libraries provide ECC support, however,
    OpenVPN can also use EC certificates. The main advantage of ECC is that you can
    provide smaller keys to achieve the same level of security than with the more
    common RSA and DSA type encryption. This will result in a better VPN performance
    without sacrificing security. As we will see in this recipe, OpenVPN's control
    channel can be authenticated using an EC algorithm. The data channel is still
    authenticated using a non-EC HMAC algorithm, such as SHA1.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, the server computer was running CentOS 6 Linux and OpenVPN
    2.4.0\. The client was running Fedora 22 Linux and OpenVPN 2.4.0.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We first need to generate a new EC-based Certificate Authority:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will result in an `ec-ca.crt` and `ec-ca.key` file using the `sect571k1`
    elliptic curve that we will use to sign the EC-based client and server certificates.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, generate the new EC server certificate:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will result in an `ec-server.crt` and `ec-server.key` file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Similarly, generate the new EC client certificate:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will result in an `ec-client.crt` and `ec-client.key` file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create the server configuration file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save it as `example4-11-server.conf`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Start the server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, create the client configuration file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Then save it as `example4-11-client.conf`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Transfer the files such as `ec-ca.crt`, `ec-client.crt`, and `ec-client.key`
    to the client machine using a secure channel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, start the client:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And observe the chosen control channel cipher:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This shows that the control channel is protected using an ECDSA-based cipher.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By generating an EC-based Certificate Authority and by using EC-based certificates
    OpenVPN can now support elliptic curve cryptography on the control channel. The
    data channel is still protected using the default cipher BF-CBC (Blowfish) and
    the default HMAC algorithm SHA1.
  prefs: []
  type: TYPE_NORMAL
- en: 'It should be noted that with RSA-based certificates the control channel cipher
    looks remarkably similar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: It is not the "ECDHE" part which proves that ECC is used, but "ECDSA".
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is also possible to choose different ECDH "curves". This is done by first
    listing the available ECDH curves on the OpenVPN server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'And then by adding the option to the server configuration file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Elliptic curve support
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Not all Linux distributions provide an OpenSSL library that supports elliptic
    curve cryptography out of the box. Notably RedHat-based and RedHat-derived distributions,
    such as RedHat Enterprise Linux, CentOS and Fedora explicitly disable ECC support.
    RedHat cites patent issues as the reason, but the "default" OpenSSL library ships
    with full ECC support.
  prefs: []
  type: TYPE_NORMAL
- en: As the Linux distributions used throughout this book are CentOS and Fedora,
    a custom build of the OpenSSL 1.0.2 library was made especially for this recipe.
  prefs: []
  type: TYPE_NORMAL
