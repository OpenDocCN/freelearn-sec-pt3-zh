["```\n# Insecure implementation\npassword = request.form['password']\nuser = authenticate(username, password)\n# A more secure way of doing things\nfrom bcrypt import hashpw, gensalt\npassword = request.form['password']\nhashed_password = hashpw(password.encode('utf-8'), gensalt())\nuser = authenticate(username, hashed_password)\n```", "```\n// Insecure way of storing token in local storage\nlocalStorage.setItem('token', token);\n// Secure way of doing the same, but with HttpOnly cookies\nres.cookie('token', token, { httpOnly: true, secure: true });\n```", "```\n# How you do an insecure SQL query\ncursor.execute(\"SELECT * FROM users WHERE id = '%s'\" % user_id)\n# A secure approach by using parameterized queries\ncursor.execute(\"SELECT * FROM users WHERE id = %s\", (user_id,))\n```", "```\n// When you concatenate strings for SQL queries, you make them insecure\nString query = \"SELECT * FROM users WHERE id = \" + userId;\nList<User> users = entityManager.createNativeQuery(query, User.class).getResultList();\n// Prefer instead using parameterized queries with HQL, for example\nString query = \"FROM User WHERE id = :userId\";\nList<User> users = entityManager.createQuery(query, User.class)\n    .setParameter(\"userId\", userId)\n    .getResultList();\n```", "```\n// This is insecure since it directly applies the user input\nconst userId = req.params.userId;\nUser.find({ where: { id: userId } });\n// This is a parameterized query with Sequelize\nconst userId = req.params.userId;\nUser.find({ where: { id: Sequelize.literal('?'), replacements: [userId] } });\n```", "```\n// Insecure: Directly using user input\nuserId := r.URL.Query().Get(\"user_id\")\ndb.Query(\"SELECT * FROM users WHERE id = \" + userId)\n// Secure: Using parameterized queries with sql package\nuserId := r.URL.Query().Get(\"user_id\")\ndb.Query(\"SELECT * FROM users WHERE id = ?\", userId)\n```", "```\n// The insecure way: not validating input in GraphQL resolver\nconst resolvers = {\n  Query: {\n    user: (parent, args) => User.findById(args.id),\n  },\n};\n// Here we make use of GraphQL middleware to reinforce protection\nconst { GraphQLObjectType, GraphQLString } = require('graphql');\nconst { GraphQLSchema, validateSchema } = require('graphql');\nconst userType = new GraphQLObjectType({\n  name: 'User',\n  fields: {\n    id: { type: GraphQLString },\n    name: { type: GraphQLString },\n  },\n});\nconst queryType = new GraphQLObjectType({\n  name: 'Query',\n  fields: {\n    user: {\n      type: userType,\n      args: {\n        id: { type: GraphQLString },\n      },\n      resolve: (parent, args) => {\n        if (!args.id.match(/^[0-9a-fA-F]{24}$/)) {\n          throw new Error('Invalid user ID format');\n        }\n        return User.findById(args.id);\n      },\n    },\n  },\n});\nconst schema = new GraphQLSchema({ query: queryType });\nvalidateSchema(schema);\n```", "```\n# Here you expose stack traces. Bad!\ntry:\n    user = User.get(user_id)\nexcept Exception as e:\n    return str(e)\n# Here you treat and hide internal error details\ntry:\n    user = User.get(user_id)\nexcept Exception as e:\n    log.error(f\"Error retrieving user: {e}\")\n    return \"An error occurred\"\n```", "```\n// Do not expose internal details\ntry {\n    User user = userService.findUserById(userId);\n} catch (Exception e) {\n    return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(e.getMessage());\n}\n// Instead, treat them and hide them\ntry {\n    User user = userService.findUserById(userId);\n} catch (Exception e) {\n    log.error(\"Error retrieving user\", e);\n    return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(\"An error occurred\");\n}\n```", "```\n// Do not log errors directly to the console\napp.use((err, req, res, next) => {\n  console.error(err.stack);\n  res.status(500).send(err.message);\n});\n// Instead, prefer a logging library and hide error details\nconst winston = require('winston');\nconst logger = winston.createLogger({\n  transports: [new winston.transports.File({ filename: 'error.log' })],\n});\napp.use((err, req, res, next) => {\n  logger.error(err.stack);\n  res.status(500).send('An error occurred');\n});\n```", "```\n// Insecure way: Allowing panic to expose sensitive data\nfunc handler(w http.ResponseWriter, r *http.Request) {\n    defer func() {\n        if err := recover(); err != nil {\n            fmt.Fprintf(w, \"An error occurred: %v\", err)\n        }\n    }()\n    // Put here some code that could panic\n}\n// Secure way: Recovering from panic and hiding internal details\nfunc handler(w http.ResponseWriter, r *http.Request) {\n    defer func() {\n        if err := recover(); err != nil {\n            log.Printf(\"Recovered from panic: %v\", err)\n            http.Error(w, \"An error occurred\", http.StatusInternalServerError)\n        }\n    }()\n    // Put here some code that could panic\n}\n```", "```\n// Insecure form: Exposing detailed error messages in GraphQL\nconst resolvers = {\n  Query: {\n    user: (parent, args) => {\n      throw new Error('Detailed error message with internal information');\n    },\n  },\n};\n// Secure form: Using custom error classes and middleware\nclass UserError extends Error {\n  constructor(message) {\n    super(message);\n    this.name = 'UserError';\n  }\n}\nconst resolvers = {\n  Query: {\n    user: (parent, args) => {\n      try {\n        // Put here some code that may throw an error\n      } catch (error) {\n        throw new UserError('An error occurred');\n      }\n    },\n  },\n};\n```", "```\n# The wrong way: Storing sensitive data without encryption\nuser_data = {'ssn': '123-45-6789'}\ndatabase.store(user_data)\n# The correct way: Encrypting sensitive data before storing\nfrom cryptography.fernet import Fernet\nkey = Fernet.generate_key()\ncipher_suite = Fernet(key)\nencrypted_ssn = cipher_suite.encrypt(b'123-45-6789')\nuser_data = {'ssn': encrypted_ssn}\ndatabase.store(user_data)\n```", "```\n// Insecure: Using flawed encryption algorithm\nCipher cipher = Cipher.getInstance(\"DES\");\nSecretKey key = KeyGenerator.getInstance(\"DES\").generateKey();\ncipher.init(Cipher.ENCRYPT_MODE, key);\n// Secure: Using a more robust encryption algorithm (AES)\nCipher cipher = Cipher.getInstance(\"AES/GCM/NoPadding\");\nSecretKey key = KeyGenerator.getInstance(\"AES\").generateKey();\ncipher.init(Cipher.ENCRYPT_MODE, key, new GCMParameterSpec(128, iv));\n```", "```\n// Hardcoding encryption keys (bad!)\nconst crypto = require('crypto');\nconst key = 'hardcodedkey123';\nconst cipher = crypto.createCipher('aes-256-cbc', key);\n// Using environment variables for encryption key (better!)\nconst key = process.env.ENCRYPTION_KEY;\nconst cipher = crypto.createCipher('aes-256-cbc', key);\n```", "```\n// Insecure: Using weak encryption key\nblock, err := aes.NewCipher([]byte(\"weakkey12345678\"))\nif err != nil {\n    panic(err)\n}\n// Secure: Using strong encryption key\nkey := []byte(\"strongkey12345678901234567890\")\nblock, err := aes.NewCipher(key)\nif err != nil {\n    panic(err)\n}\n```", "```\n// Bad way: Returning sensitive data without encryption\nconst resolvers = {\n  Query: {\n    user: (parent, args) => {\n      return User.findById(args.id);\n    },\n  },\n};\n// Right way: Encrypting sensitive data before returning\nconst crypto = require('crypto');\nconst secret = process.env.SECRET_KEY;\nconst resolvers = {\n  Query: {\n    user: async (parent, args) => {\n      const user = await User.findById(args.id);\n      user.ssn = crypto.createHmac('sha256', secret)\n                       .update(user.ssn)\n                       .digest('hex');\n      return user;\n    },\n  },\n};\n```"]